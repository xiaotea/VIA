{
    "django/core/handlers/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     response_fixes = ["
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         http.fix_location_header,"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         http.conditional_content_removal,"
            },
            "3": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        http.fix_IE_for_attach,"
            },
            "4": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        http.fix_IE_for_vary,"
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     ]"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     def __init__(self):"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import logging",
            "import sys",
            "import types",
            "",
            "from django import http",
            "from django.conf import settings",
            "from django.core import exceptions",
            "from django.core import urlresolvers",
            "from django.core import signals",
            "from django.utils.encoding import force_text",
            "from django.utils.importlib import import_module",
            "from django.utils import six",
            "from django.views import debug",
            "",
            "logger = logging.getLogger('django.request')",
            "",
            "",
            "class BaseHandler(object):",
            "    # Changes that are always applied to a response (in this order).",
            "    response_fixes = [",
            "        http.fix_location_header,",
            "        http.conditional_content_removal,",
            "        http.fix_IE_for_attach,",
            "        http.fix_IE_for_vary,",
            "    ]",
            "",
            "    def __init__(self):",
            "        self._request_middleware = self._view_middleware = self._template_response_middleware = self._response_middleware = self._exception_middleware = None",
            "",
            "",
            "    def load_middleware(self):",
            "        \"\"\"",
            "        Populate middleware lists from settings.MIDDLEWARE_CLASSES.",
            "",
            "        Must be called after the environment is fixed (see __call__ in subclasses).",
            "        \"\"\"",
            "        self._view_middleware = []",
            "        self._template_response_middleware = []",
            "        self._response_middleware = []",
            "        self._exception_middleware = []",
            "",
            "        request_middleware = []",
            "        for middleware_path in settings.MIDDLEWARE_CLASSES:",
            "            try:",
            "                mw_module, mw_classname = middleware_path.rsplit('.', 1)",
            "            except ValueError:",
            "                raise exceptions.ImproperlyConfigured('%s isn\\'t a middleware module' % middleware_path)",
            "            try:",
            "                mod = import_module(mw_module)",
            "            except ImportError as e:",
            "                raise exceptions.ImproperlyConfigured('Error importing middleware %s: \"%s\"' % (mw_module, e))",
            "            try:",
            "                mw_class = getattr(mod, mw_classname)",
            "            except AttributeError:",
            "                raise exceptions.ImproperlyConfigured('Middleware module \"%s\" does not define a \"%s\" class' % (mw_module, mw_classname))",
            "            try:",
            "                mw_instance = mw_class()",
            "            except exceptions.MiddlewareNotUsed:",
            "                continue",
            "",
            "            if hasattr(mw_instance, 'process_request'):",
            "                request_middleware.append(mw_instance.process_request)",
            "            if hasattr(mw_instance, 'process_view'):",
            "                self._view_middleware.append(mw_instance.process_view)",
            "            if hasattr(mw_instance, 'process_template_response'):",
            "                self._template_response_middleware.insert(0, mw_instance.process_template_response)",
            "            if hasattr(mw_instance, 'process_response'):",
            "                self._response_middleware.insert(0, mw_instance.process_response)",
            "            if hasattr(mw_instance, 'process_exception'):",
            "                self._exception_middleware.insert(0, mw_instance.process_exception)",
            "",
            "        # We only assign to this when initialization is complete as it is used",
            "        # as a flag for initialization being complete.",
            "        self._request_middleware = request_middleware",
            "",
            "    def get_response(self, request):",
            "        \"Returns an HttpResponse object for the given HttpRequest\"",
            "        try:",
            "            # Setup default url resolver for this thread, this code is outside",
            "            # the try/except so we don't get a spurious \"unbound local",
            "            # variable\" exception in the event an exception is raised before",
            "            # resolver is set",
            "            urlconf = settings.ROOT_URLCONF",
            "            urlresolvers.set_urlconf(urlconf)",
            "            resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "            try:",
            "                response = None",
            "                # Apply request middleware",
            "                for middleware_method in self._request_middleware:",
            "                    response = middleware_method(request)",
            "                    if response:",
            "                        break",
            "",
            "                if response is None:",
            "                    if hasattr(request, 'urlconf'):",
            "                        # Reset url resolver with a custom urlconf.",
            "                        urlconf = request.urlconf",
            "                        urlresolvers.set_urlconf(urlconf)",
            "                        resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "",
            "                    resolver_match = resolver.resolve(request.path_info)",
            "                    callback, callback_args, callback_kwargs = resolver_match",
            "                    request.resolver_match = resolver_match",
            "",
            "                    # Apply view middleware",
            "                    for middleware_method in self._view_middleware:",
            "                        response = middleware_method(request, callback, callback_args, callback_kwargs)",
            "                        if response:",
            "                            break",
            "",
            "                if response is None:",
            "                    try:",
            "                        response = callback(request, *callback_args, **callback_kwargs)",
            "                    except Exception as e:",
            "                        # If the view raised an exception, run it through exception",
            "                        # middleware, and if the exception middleware returns a",
            "                        # response, use that. Otherwise, reraise the exception.",
            "                        for middleware_method in self._exception_middleware:",
            "                            response = middleware_method(request, e)",
            "                            if response:",
            "                                break",
            "                        if response is None:",
            "                            raise",
            "",
            "                # Complain if the view returned None (a common error).",
            "                if response is None:",
            "                    if isinstance(callback, types.FunctionType):    # FBV",
            "                        view_name = callback.__name__",
            "                    else:                                           # CBV",
            "                        view_name = callback.__class__.__name__ + '.__call__'",
            "                    raise ValueError(\"The view %s.%s didn't return an HttpResponse object.\" % (callback.__module__, view_name))",
            "",
            "                # If the response supports deferred rendering, apply template",
            "                # response middleware and the render the response",
            "                if hasattr(response, 'render') and callable(response.render):",
            "                    for middleware_method in self._template_response_middleware:",
            "                        response = middleware_method(request, response)",
            "                    response = response.render()",
            "",
            "            except http.Http404 as e:",
            "                logger.warning('Not Found: %s', request.path,",
            "                            extra={",
            "                                'status_code': 404,",
            "                                'request': request",
            "                            })",
            "                if settings.DEBUG:",
            "                    response = debug.technical_404_response(request, e)",
            "                else:",
            "                    try:",
            "                        callback, param_dict = resolver.resolve404()",
            "                        response = callback(request, **param_dict)",
            "                    except:",
            "                        signals.got_request_exception.send(sender=self.__class__, request=request)",
            "                        response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "            except exceptions.PermissionDenied:",
            "                logger.warning(",
            "                    'Forbidden (Permission denied): %s', request.path,",
            "                    extra={",
            "                        'status_code': 403,",
            "                        'request': request",
            "                    })",
            "                try:",
            "                    callback, param_dict = resolver.resolve403()",
            "                    response = callback(request, **param_dict)",
            "                except:",
            "                    signals.got_request_exception.send(",
            "                            sender=self.__class__, request=request)",
            "                    response = self.handle_uncaught_exception(request,",
            "                            resolver, sys.exc_info())",
            "            except SystemExit:",
            "                # Allow sys.exit() to actually exit. See tickets #1023 and #4701",
            "                raise",
            "            except: # Handle everything else, including SuspiciousOperation, etc.",
            "                # Get the exception info now, in case another exception is thrown later.",
            "                signals.got_request_exception.send(sender=self.__class__, request=request)",
            "                response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "        finally:",
            "            # Reset URLconf for this thread on the way out for complete",
            "            # isolation of request.urlconf",
            "            urlresolvers.set_urlconf(None)",
            "",
            "        try:",
            "            # Apply response middleware, regardless of the response",
            "            for middleware_method in self._response_middleware:",
            "                response = middleware_method(request, response)",
            "            response = self.apply_response_fixes(request, response)",
            "        except: # Any exception should be gathered and handled",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        return response",
            "",
            "    def handle_uncaught_exception(self, request, resolver, exc_info):",
            "        \"\"\"",
            "        Processing for any otherwise uncaught exceptions (those that will",
            "        generate HTTP 500 responses). Can be overridden by subclasses who want",
            "        customised 500 handling.",
            "",
            "        Be *very* careful when overriding this because the error could be",
            "        caused by anything, so assuming something like the database is always",
            "        available would be an error.",
            "        \"\"\"",
            "        if settings.DEBUG_PROPAGATE_EXCEPTIONS:",
            "            raise",
            "",
            "        logger.error('Internal Server Error: %s', request.path,",
            "            exc_info=exc_info,",
            "            extra={",
            "                'status_code': 500,",
            "                'request': request",
            "            }",
            "        )",
            "",
            "        if settings.DEBUG:",
            "            return debug.technical_500_response(request, *exc_info)",
            "",
            "        # If Http500 handler is not installed, re-raise last exception",
            "        if resolver.urlconf_module is None:",
            "            six.reraise(*exc_info)",
            "        # Return an HttpResponse that displays a friendly error message.",
            "        callback, param_dict = resolver.resolve500()",
            "        return callback(request, **param_dict)",
            "",
            "    def apply_response_fixes(self, request, response):",
            "        \"\"\"",
            "        Applies each of the functions in self.response_fixes to the request and",
            "        response, modifying the response in the process. Returns the new",
            "        response.",
            "        \"\"\"",
            "        for func in self.response_fixes:",
            "            response = func(request, response)",
            "        return response",
            "",
            "",
            "def get_path_info(environ):",
            "    \"\"\"",
            "    Returns the HTTP request's PATH_INFO as a unicode string.",
            "    \"\"\"",
            "    path_info = environ.get('PATH_INFO', str('/'))",
            "    # Under Python 3, strings in environ are decoded with ISO-8859-1;",
            "    # re-encode to recover the original bytestring provided by the webserver.",
            "    if six.PY3:",
            "        path_info = path_info.encode('iso-8859-1')",
            "    # It'd be better to implement URI-to-IRI decoding, see #19508.",
            "    return path_info.decode('utf-8')",
            "",
            "",
            "def get_script_name(environ):",
            "    \"\"\"",
            "    Returns the equivalent of the HTTP request's SCRIPT_NAME environment",
            "    variable. If Apache mod_rewrite has been used, returns what would have been",
            "    the script name prior to any rewriting (so it's the script name as seen",
            "    from the client's perspective), unless the FORCE_SCRIPT_NAME setting is",
            "    set (to anything).",
            "    \"\"\"",
            "    if settings.FORCE_SCRIPT_NAME is not None:",
            "        return force_text(settings.FORCE_SCRIPT_NAME)",
            "",
            "    # If Apache's mod_rewrite had a whack at the URL, Apache set either",
            "    # SCRIPT_URL or REDIRECT_URL to the full resource URL before applying any",
            "    # rewrites. Unfortunately not every Web server (lighttpd!) passes this",
            "    # information through all the time, so FORCE_SCRIPT_NAME, above, is still",
            "    # needed.",
            "    script_url = environ.get('SCRIPT_URL', environ.get('REDIRECT_URL', str('')))",
            "    if script_url:",
            "        script_name = script_url[:-len(environ.get('PATH_INFO', str('')))]",
            "    else:",
            "        script_name = environ.get('SCRIPT_NAME', str(''))",
            "    # Under Python 3, strings in environ are decoded with ISO-8859-1;",
            "    # re-encode to recover the original bytestring provided by the webserver.",
            "    if six.PY3:",
            "        script_name = script_name.encode('iso-8859-1')",
            "    # It'd be better to implement URI-to-IRI decoding, see #19508.",
            "    return script_name.decode('utf-8')"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import logging",
            "import sys",
            "import types",
            "",
            "from django import http",
            "from django.conf import settings",
            "from django.core import exceptions",
            "from django.core import urlresolvers",
            "from django.core import signals",
            "from django.utils.encoding import force_text",
            "from django.utils.importlib import import_module",
            "from django.utils import six",
            "from django.views import debug",
            "",
            "logger = logging.getLogger('django.request')",
            "",
            "",
            "class BaseHandler(object):",
            "    # Changes that are always applied to a response (in this order).",
            "    response_fixes = [",
            "        http.fix_location_header,",
            "        http.conditional_content_removal,",
            "    ]",
            "",
            "    def __init__(self):",
            "        self._request_middleware = self._view_middleware = self._template_response_middleware = self._response_middleware = self._exception_middleware = None",
            "",
            "",
            "    def load_middleware(self):",
            "        \"\"\"",
            "        Populate middleware lists from settings.MIDDLEWARE_CLASSES.",
            "",
            "        Must be called after the environment is fixed (see __call__ in subclasses).",
            "        \"\"\"",
            "        self._view_middleware = []",
            "        self._template_response_middleware = []",
            "        self._response_middleware = []",
            "        self._exception_middleware = []",
            "",
            "        request_middleware = []",
            "        for middleware_path in settings.MIDDLEWARE_CLASSES:",
            "            try:",
            "                mw_module, mw_classname = middleware_path.rsplit('.', 1)",
            "            except ValueError:",
            "                raise exceptions.ImproperlyConfigured('%s isn\\'t a middleware module' % middleware_path)",
            "            try:",
            "                mod = import_module(mw_module)",
            "            except ImportError as e:",
            "                raise exceptions.ImproperlyConfigured('Error importing middleware %s: \"%s\"' % (mw_module, e))",
            "            try:",
            "                mw_class = getattr(mod, mw_classname)",
            "            except AttributeError:",
            "                raise exceptions.ImproperlyConfigured('Middleware module \"%s\" does not define a \"%s\" class' % (mw_module, mw_classname))",
            "            try:",
            "                mw_instance = mw_class()",
            "            except exceptions.MiddlewareNotUsed:",
            "                continue",
            "",
            "            if hasattr(mw_instance, 'process_request'):",
            "                request_middleware.append(mw_instance.process_request)",
            "            if hasattr(mw_instance, 'process_view'):",
            "                self._view_middleware.append(mw_instance.process_view)",
            "            if hasattr(mw_instance, 'process_template_response'):",
            "                self._template_response_middleware.insert(0, mw_instance.process_template_response)",
            "            if hasattr(mw_instance, 'process_response'):",
            "                self._response_middleware.insert(0, mw_instance.process_response)",
            "            if hasattr(mw_instance, 'process_exception'):",
            "                self._exception_middleware.insert(0, mw_instance.process_exception)",
            "",
            "        # We only assign to this when initialization is complete as it is used",
            "        # as a flag for initialization being complete.",
            "        self._request_middleware = request_middleware",
            "",
            "    def get_response(self, request):",
            "        \"Returns an HttpResponse object for the given HttpRequest\"",
            "        try:",
            "            # Setup default url resolver for this thread, this code is outside",
            "            # the try/except so we don't get a spurious \"unbound local",
            "            # variable\" exception in the event an exception is raised before",
            "            # resolver is set",
            "            urlconf = settings.ROOT_URLCONF",
            "            urlresolvers.set_urlconf(urlconf)",
            "            resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "            try:",
            "                response = None",
            "                # Apply request middleware",
            "                for middleware_method in self._request_middleware:",
            "                    response = middleware_method(request)",
            "                    if response:",
            "                        break",
            "",
            "                if response is None:",
            "                    if hasattr(request, 'urlconf'):",
            "                        # Reset url resolver with a custom urlconf.",
            "                        urlconf = request.urlconf",
            "                        urlresolvers.set_urlconf(urlconf)",
            "                        resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "",
            "                    resolver_match = resolver.resolve(request.path_info)",
            "                    callback, callback_args, callback_kwargs = resolver_match",
            "                    request.resolver_match = resolver_match",
            "",
            "                    # Apply view middleware",
            "                    for middleware_method in self._view_middleware:",
            "                        response = middleware_method(request, callback, callback_args, callback_kwargs)",
            "                        if response:",
            "                            break",
            "",
            "                if response is None:",
            "                    try:",
            "                        response = callback(request, *callback_args, **callback_kwargs)",
            "                    except Exception as e:",
            "                        # If the view raised an exception, run it through exception",
            "                        # middleware, and if the exception middleware returns a",
            "                        # response, use that. Otherwise, reraise the exception.",
            "                        for middleware_method in self._exception_middleware:",
            "                            response = middleware_method(request, e)",
            "                            if response:",
            "                                break",
            "                        if response is None:",
            "                            raise",
            "",
            "                # Complain if the view returned None (a common error).",
            "                if response is None:",
            "                    if isinstance(callback, types.FunctionType):    # FBV",
            "                        view_name = callback.__name__",
            "                    else:                                           # CBV",
            "                        view_name = callback.__class__.__name__ + '.__call__'",
            "                    raise ValueError(\"The view %s.%s didn't return an HttpResponse object.\" % (callback.__module__, view_name))",
            "",
            "                # If the response supports deferred rendering, apply template",
            "                # response middleware and the render the response",
            "                if hasattr(response, 'render') and callable(response.render):",
            "                    for middleware_method in self._template_response_middleware:",
            "                        response = middleware_method(request, response)",
            "                    response = response.render()",
            "",
            "            except http.Http404 as e:",
            "                logger.warning('Not Found: %s', request.path,",
            "                            extra={",
            "                                'status_code': 404,",
            "                                'request': request",
            "                            })",
            "                if settings.DEBUG:",
            "                    response = debug.technical_404_response(request, e)",
            "                else:",
            "                    try:",
            "                        callback, param_dict = resolver.resolve404()",
            "                        response = callback(request, **param_dict)",
            "                    except:",
            "                        signals.got_request_exception.send(sender=self.__class__, request=request)",
            "                        response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "            except exceptions.PermissionDenied:",
            "                logger.warning(",
            "                    'Forbidden (Permission denied): %s', request.path,",
            "                    extra={",
            "                        'status_code': 403,",
            "                        'request': request",
            "                    })",
            "                try:",
            "                    callback, param_dict = resolver.resolve403()",
            "                    response = callback(request, **param_dict)",
            "                except:",
            "                    signals.got_request_exception.send(",
            "                            sender=self.__class__, request=request)",
            "                    response = self.handle_uncaught_exception(request,",
            "                            resolver, sys.exc_info())",
            "            except SystemExit:",
            "                # Allow sys.exit() to actually exit. See tickets #1023 and #4701",
            "                raise",
            "            except: # Handle everything else, including SuspiciousOperation, etc.",
            "                # Get the exception info now, in case another exception is thrown later.",
            "                signals.got_request_exception.send(sender=self.__class__, request=request)",
            "                response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "        finally:",
            "            # Reset URLconf for this thread on the way out for complete",
            "            # isolation of request.urlconf",
            "            urlresolvers.set_urlconf(None)",
            "",
            "        try:",
            "            # Apply response middleware, regardless of the response",
            "            for middleware_method in self._response_middleware:",
            "                response = middleware_method(request, response)",
            "            response = self.apply_response_fixes(request, response)",
            "        except: # Any exception should be gathered and handled",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        return response",
            "",
            "    def handle_uncaught_exception(self, request, resolver, exc_info):",
            "        \"\"\"",
            "        Processing for any otherwise uncaught exceptions (those that will",
            "        generate HTTP 500 responses). Can be overridden by subclasses who want",
            "        customised 500 handling.",
            "",
            "        Be *very* careful when overriding this because the error could be",
            "        caused by anything, so assuming something like the database is always",
            "        available would be an error.",
            "        \"\"\"",
            "        if settings.DEBUG_PROPAGATE_EXCEPTIONS:",
            "            raise",
            "",
            "        logger.error('Internal Server Error: %s', request.path,",
            "            exc_info=exc_info,",
            "            extra={",
            "                'status_code': 500,",
            "                'request': request",
            "            }",
            "        )",
            "",
            "        if settings.DEBUG:",
            "            return debug.technical_500_response(request, *exc_info)",
            "",
            "        # If Http500 handler is not installed, re-raise last exception",
            "        if resolver.urlconf_module is None:",
            "            six.reraise(*exc_info)",
            "        # Return an HttpResponse that displays a friendly error message.",
            "        callback, param_dict = resolver.resolve500()",
            "        return callback(request, **param_dict)",
            "",
            "    def apply_response_fixes(self, request, response):",
            "        \"\"\"",
            "        Applies each of the functions in self.response_fixes to the request and",
            "        response, modifying the response in the process. Returns the new",
            "        response.",
            "        \"\"\"",
            "        for func in self.response_fixes:",
            "            response = func(request, response)",
            "        return response",
            "",
            "",
            "def get_path_info(environ):",
            "    \"\"\"",
            "    Returns the HTTP request's PATH_INFO as a unicode string.",
            "    \"\"\"",
            "    path_info = environ.get('PATH_INFO', str('/'))",
            "    # Under Python 3, strings in environ are decoded with ISO-8859-1;",
            "    # re-encode to recover the original bytestring provided by the webserver.",
            "    if six.PY3:",
            "        path_info = path_info.encode('iso-8859-1')",
            "    # It'd be better to implement URI-to-IRI decoding, see #19508.",
            "    return path_info.decode('utf-8')",
            "",
            "",
            "def get_script_name(environ):",
            "    \"\"\"",
            "    Returns the equivalent of the HTTP request's SCRIPT_NAME environment",
            "    variable. If Apache mod_rewrite has been used, returns what would have been",
            "    the script name prior to any rewriting (so it's the script name as seen",
            "    from the client's perspective), unless the FORCE_SCRIPT_NAME setting is",
            "    set (to anything).",
            "    \"\"\"",
            "    if settings.FORCE_SCRIPT_NAME is not None:",
            "        return force_text(settings.FORCE_SCRIPT_NAME)",
            "",
            "    # If Apache's mod_rewrite had a whack at the URL, Apache set either",
            "    # SCRIPT_URL or REDIRECT_URL to the full resource URL before applying any",
            "    # rewrites. Unfortunately not every Web server (lighttpd!) passes this",
            "    # information through all the time, so FORCE_SCRIPT_NAME, above, is still",
            "    # needed.",
            "    script_url = environ.get('SCRIPT_URL', environ.get('REDIRECT_URL', str('')))",
            "    if script_url:",
            "        script_name = script_url[:-len(environ.get('PATH_INFO', str('')))]",
            "    else:",
            "        script_name = environ.get('SCRIPT_NAME', str(''))",
            "    # Under Python 3, strings in environ are decoded with ISO-8859-1;",
            "    # re-encode to recover the original bytestring provided by the webserver.",
            "    if six.PY3:",
            "        script_name = script_name.encode('iso-8859-1')",
            "    # It'd be better to implement URI-to-IRI decoding, see #19508.",
            "    return script_name.decode('utf-8')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [
                "BaseHandler"
            ],
            "26": [
                "BaseHandler"
            ]
        },
        "addLocation": []
    },
    "django/http/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": "     HttpResponseRedirect, HttpResponseNotModified, HttpResponseBadRequest,"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": "     HttpResponseForbidden, HttpResponseNotFound, HttpResponseNotAllowed,"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     HttpResponseGone, HttpResponseServerError, Http404, BadHeaderError)"
            },
            "3": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.http.utils import (fix_location_header, conditional_content_removal,"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fix_IE_for_attach, fix_IE_for_vary)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from django.http.utils import fix_location_header, conditional_content_removal"
            }
        },
        "frontPatchFile": [
            "from django.http.cookie import SimpleCookie, parse_cookie",
            "from django.http.request import (HttpRequest, QueryDict, UnreadablePostError,",
            "    build_request_repr)",
            "from django.http.response import (HttpResponse, StreamingHttpResponse,",
            "    CompatibleStreamingHttpResponse, HttpResponsePermanentRedirect,",
            "    HttpResponseRedirect, HttpResponseNotModified, HttpResponseBadRequest,",
            "    HttpResponseForbidden, HttpResponseNotFound, HttpResponseNotAllowed,",
            "    HttpResponseGone, HttpResponseServerError, Http404, BadHeaderError)",
            "from django.http.utils import (fix_location_header, conditional_content_removal,",
            "    fix_IE_for_attach, fix_IE_for_vary)"
        ],
        "afterPatchFile": [
            "from django.http.cookie import SimpleCookie, parse_cookie",
            "from django.http.request import (HttpRequest, QueryDict, UnreadablePostError,",
            "    build_request_repr)",
            "from django.http.response import (HttpResponse, StreamingHttpResponse,",
            "    CompatibleStreamingHttpResponse, HttpResponsePermanentRedirect,",
            "    HttpResponseRedirect, HttpResponseNotModified, HttpResponseBadRequest,",
            "    HttpResponseForbidden, HttpResponseNotFound, HttpResponseNotAllowed,",
            "    HttpResponseGone, HttpResponseServerError, Http404, BadHeaderError)",
            "from django.http.utils import fix_location_header, conditional_content_removal"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "9": [],
            "10": []
        },
        "addLocation": []
    },
    "django/http/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         else:"
            },
            "1": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "             response.content = ''"
            },
            "2": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     return response"
            },
            "3": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def fix_IE_for_attach(request, response):"
            },
            "6": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    This function will prevent Django from serving a Content-Disposition header"
            },
            "8": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    while expecting the browser to cache it (only when the browser is IE). This"
            },
            "9": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    leads to IE not allowing the client to download."
            },
            "10": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    useragent = request.META.get('HTTP_USER_AGENT', '').upper()"
            },
            "12": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'MSIE' not in useragent and 'CHROMEFRAME' not in useragent:"
            },
            "13": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return response"
            },
            "14": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    offending_headers = ('no-cache', 'no-store')"
            },
            "16": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if response.has_header('Content-Disposition'):"
            },
            "17": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "18": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            del response['Pragma']"
            },
            "19": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except KeyError:"
            },
            "20": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            pass"
            },
            "21": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if response.has_header('Cache-Control'):"
            },
            "22": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cache_control_values = [value.strip() for value in"
            },
            "23": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    response['Cache-Control'].split(',')"
            },
            "24": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if value.strip().lower() not in offending_headers]"
            },
            "25": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not len(cache_control_values):"
            },
            "27": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                del response['Cache-Control']"
            },
            "28": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "29": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                response['Cache-Control'] = ', '.join(cache_control_values)"
            },
            "30": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return response"
            },
            "32": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "33": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "34": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def fix_IE_for_vary(request, response):"
            },
            "35": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "36": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    This function will fix the bug reported at"
            },
            "37": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    http://support.microsoft.com/kb/824847/en-us?spid=8722&sid=global"
            },
            "38": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    by clearing the Vary header whenever the mime-type is not safe"
            },
            "39": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    enough for Internet Explorer to handle.  Poor thing."
            },
            "40": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "41": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    useragent = request.META.get('HTTP_USER_AGENT', '').upper()"
            },
            "42": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'MSIE' not in useragent and 'CHROMEFRAME' not in useragent:"
            },
            "43": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return response"
            },
            "44": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "45": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # These mime-types that are decreed \"Vary-safe\" for IE:"
            },
            "46": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    safe_mime_types = ('text/html', 'text/plain', 'text/sgml')"
            },
            "47": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "48": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # The first part of the Content-Type field will be the MIME type,"
            },
            "49": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # everything after ';', such as character-set, can be ignored."
            },
            "50": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    mime_type = response.get('Content-Type', '').partition(';')[0]"
            },
            "51": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if mime_type not in safe_mime_types:"
            },
            "52": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "53": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            del response['Vary']"
            },
            "54": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except KeyError:"
            },
            "55": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            pass"
            },
            "56": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "57": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return response"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Functions that modify an HTTP request or response in some way.",
            "\"\"\"",
            "",
            "# This group of functions are run as part of the response handling, after",
            "# everything else, including all response middleware. Think of them as",
            "# \"compulsory response middleware\". Be careful about what goes here, because",
            "# it's a little fiddly to override this behavior, so they should be truly",
            "# universally applicable.",
            "",
            "",
            "def fix_location_header(request, response):",
            "    \"\"\"",
            "    Ensures that we always use an absolute URI in any location header in the",
            "    response. This is required by RFC 2616, section 14.30.",
            "",
            "    Code constructing response objects is free to insert relative paths, as",
            "    this function converts them to absolute paths.",
            "    \"\"\"",
            "    if 'Location' in response and request.get_host():",
            "        response['Location'] = request.build_absolute_uri(response['Location'])",
            "    return response",
            "",
            "",
            "def conditional_content_removal(request, response):",
            "    \"\"\"",
            "    Removes the content of responses for HEAD requests, 1xx, 204 and 304",
            "    responses. Ensures compliance with RFC 2616, section 4.3.",
            "    \"\"\"",
            "    if 100 <= response.status_code < 200 or response.status_code in (204, 304):",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = ''",
            "        response['Content-Length'] = '0'",
            "    if request.method == 'HEAD':",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = ''",
            "    return response",
            "",
            "",
            "def fix_IE_for_attach(request, response):",
            "    \"\"\"",
            "    This function will prevent Django from serving a Content-Disposition header",
            "    while expecting the browser to cache it (only when the browser is IE). This",
            "    leads to IE not allowing the client to download.",
            "    \"\"\"",
            "    useragent = request.META.get('HTTP_USER_AGENT', '').upper()",
            "    if 'MSIE' not in useragent and 'CHROMEFRAME' not in useragent:",
            "        return response",
            "",
            "    offending_headers = ('no-cache', 'no-store')",
            "    if response.has_header('Content-Disposition'):",
            "        try:",
            "            del response['Pragma']",
            "        except KeyError:",
            "            pass",
            "        if response.has_header('Cache-Control'):",
            "            cache_control_values = [value.strip() for value in",
            "                    response['Cache-Control'].split(',')",
            "                    if value.strip().lower() not in offending_headers]",
            "",
            "            if not len(cache_control_values):",
            "                del response['Cache-Control']",
            "            else:",
            "                response['Cache-Control'] = ', '.join(cache_control_values)",
            "",
            "    return response",
            "",
            "",
            "def fix_IE_for_vary(request, response):",
            "    \"\"\"",
            "    This function will fix the bug reported at",
            "    http://support.microsoft.com/kb/824847/en-us?spid=8722&sid=global",
            "    by clearing the Vary header whenever the mime-type is not safe",
            "    enough for Internet Explorer to handle.  Poor thing.",
            "    \"\"\"",
            "    useragent = request.META.get('HTTP_USER_AGENT', '').upper()",
            "    if 'MSIE' not in useragent and 'CHROMEFRAME' not in useragent:",
            "        return response",
            "",
            "    # These mime-types that are decreed \"Vary-safe\" for IE:",
            "    safe_mime_types = ('text/html', 'text/plain', 'text/sgml')",
            "",
            "    # The first part of the Content-Type field will be the MIME type,",
            "    # everything after ';', such as character-set, can be ignored.",
            "    mime_type = response.get('Content-Type', '').partition(';')[0]",
            "    if mime_type not in safe_mime_types:",
            "        try:",
            "            del response['Vary']",
            "        except KeyError:",
            "            pass",
            "",
            "    return response"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Functions that modify an HTTP request or response in some way.",
            "\"\"\"",
            "",
            "# This group of functions are run as part of the response handling, after",
            "# everything else, including all response middleware. Think of them as",
            "# \"compulsory response middleware\". Be careful about what goes here, because",
            "# it's a little fiddly to override this behavior, so they should be truly",
            "# universally applicable.",
            "",
            "",
            "def fix_location_header(request, response):",
            "    \"\"\"",
            "    Ensures that we always use an absolute URI in any location header in the",
            "    response. This is required by RFC 2616, section 14.30.",
            "",
            "    Code constructing response objects is free to insert relative paths, as",
            "    this function converts them to absolute paths.",
            "    \"\"\"",
            "    if 'Location' in response and request.get_host():",
            "        response['Location'] = request.build_absolute_uri(response['Location'])",
            "    return response",
            "",
            "",
            "def conditional_content_removal(request, response):",
            "    \"\"\"",
            "    Removes the content of responses for HEAD requests, 1xx, 204 and 304",
            "    responses. Ensures compliance with RFC 2616, section 4.3.",
            "    \"\"\"",
            "    if 100 <= response.status_code < 200 or response.status_code in (204, 304):",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = ''",
            "        response['Content-Length'] = '0'",
            "    if request.method == 'HEAD':",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = ''",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1"
        ],
        "dele_reviseLocation": {
            "42": [],
            "43": [],
            "44": [
                "fix_IE_for_attach"
            ],
            "45": [
                "fix_IE_for_attach"
            ],
            "46": [
                "fix_IE_for_attach"
            ],
            "47": [
                "fix_IE_for_attach"
            ],
            "48": [
                "fix_IE_for_attach"
            ],
            "49": [
                "fix_IE_for_attach"
            ],
            "50": [
                "fix_IE_for_attach"
            ],
            "51": [
                "fix_IE_for_attach"
            ],
            "52": [
                "fix_IE_for_attach"
            ],
            "53": [
                "fix_IE_for_attach"
            ],
            "54": [
                "fix_IE_for_attach"
            ],
            "55": [
                "fix_IE_for_attach"
            ],
            "56": [
                "fix_IE_for_attach"
            ],
            "57": [
                "fix_IE_for_attach"
            ],
            "58": [
                "fix_IE_for_attach"
            ],
            "59": [
                "fix_IE_for_attach"
            ],
            "60": [
                "fix_IE_for_attach"
            ],
            "61": [
                "fix_IE_for_attach"
            ],
            "62": [
                "fix_IE_for_attach"
            ],
            "63": [
                "fix_IE_for_attach"
            ],
            "64": [
                "fix_IE_for_attach"
            ],
            "65": [
                "fix_IE_for_attach"
            ],
            "66": [
                "fix_IE_for_attach"
            ],
            "67": [
                "fix_IE_for_attach"
            ],
            "68": [
                "fix_IE_for_attach"
            ],
            "69": [
                "fix_IE_for_attach"
            ],
            "70": [
                "fix_IE_for_attach"
            ],
            "71": [],
            "72": [],
            "73": [
                "fix_IE_for_vary"
            ],
            "74": [
                "fix_IE_for_vary"
            ],
            "75": [
                "fix_IE_for_vary"
            ],
            "76": [
                "fix_IE_for_vary"
            ],
            "77": [
                "fix_IE_for_vary"
            ],
            "78": [
                "fix_IE_for_vary"
            ],
            "79": [
                "fix_IE_for_vary"
            ],
            "80": [
                "fix_IE_for_vary"
            ],
            "81": [
                "fix_IE_for_vary"
            ],
            "82": [
                "fix_IE_for_vary"
            ],
            "83": [
                "fix_IE_for_vary"
            ],
            "84": [
                "fix_IE_for_vary"
            ],
            "85": [
                "fix_IE_for_vary"
            ],
            "86": [
                "fix_IE_for_vary"
            ],
            "87": [
                "fix_IE_for_vary"
            ],
            "88": [
                "fix_IE_for_vary"
            ],
            "89": [
                "fix_IE_for_vary"
            ],
            "90": [
                "fix_IE_for_vary"
            ],
            "91": [
                "fix_IE_for_vary"
            ],
            "92": [
                "fix_IE_for_vary"
            ],
            "93": [
                "fix_IE_for_vary"
            ],
            "94": [
                "fix_IE_for_vary"
            ],
            "95": [
                "fix_IE_for_vary"
            ],
            "96": [
                "fix_IE_for_vary"
            ]
        },
        "addLocation": []
    }
}