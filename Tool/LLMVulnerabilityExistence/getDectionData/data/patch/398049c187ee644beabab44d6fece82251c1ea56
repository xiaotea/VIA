{
    "opendiamond/dataretriever/augment_store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     jsonify"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from werkzeug.datastructures import Headers"
            },
            "3": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from werkzeug.utils import safe_join"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from werkzeug.security import safe_join"
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from opendiamond.dataretriever.util import read_file_list, write_data"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "from builtins import next",
            "from builtins import range",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "import sys",
            "",
            "import logging",
            "import random",
            "import glob",
            "from itertools import cycle",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.utils import safe_join",
            "from opendiamond.dataretriever.util import read_file_list, write_data",
            "",
            "",
            "BASEURL = 'augment'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "ITEMS_PER_ITERATION = int(1e4)",
            "KEYWORD = 'yellowthroat'",
            "",
            "\"\"\"",
            "    Example url:",
            "        /augment/root/<ROOT_DIR>/distributed/<id>of<N>/ \\",
            "            keywords/<d/r ([d]eterminant/[r]andom)>_<random_seed>_<base_rate>",
            "",
            "        /augment/root/STREAM/distributed/1of2/keywords/d_42_1.0",
            "\"\"\"",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = 'STREAM'",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('augment_store', __name__)",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +",
            "                        '/keywords/<params>')",
            "@scope_blueprint.route('/root/<rootdir>/keywords/<params>')",
            "@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +",
            "                        '/keywords/<params>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/root/<rootdir>/keywords/<params>' +",
            "                        '/start/<int:start>/limit/<int:limit>')",
            "def get_scope(rootdir, index=0, total=1, params=None, start=0, limit=sys.maxsize):",
            "    global KEYWORD",
            "    if rootdir == \"0\":",
            "        rootdir = INDEXDIR",
            "",
            "    rootdir = _get_obj_absolute_path(rootdir)",
            "    seed = None",
            "    percentage = 0.",
            "    seed, percentage = decode_params(params)",
            "",
            "    # Assuming the same positive list is present in all the servers",
            "    # Always create a new index file",
            "    base_list, KEYWORD = create_index(rootdir, percentage, seed, index, total)",
            "    total_entries = len(base_list)",
            "",
            "    start = start if start > 0 else 0",
            "    end = min(total_entries, start + limit) if limit > 0 else total_entries",
            "    base_list = base_list[start:end]",
            "    total_entries = end - start",
            "",
            "    def generate():",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)",
            "",
            "        for path in base_list:",
            "            path = path.strip()",
            "            yield _get_object_element(object_path=path) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "def decode_params(params):",
            "    \"\"\"",
            "    Decodes the params which are '_' seperated",
            "    <[d]eterminant/[r]andom>_<random_seed>_<baserate>",
            "    \"\"\"",
            "    keywords = params.split('_')",
            "    mix_type = keywords[0]",
            "    seed = None",
            "    if len(keywords) > 1:",
            "        seed = int(keywords[1])",
            "    if mix_type == 'r' or seed is None:",
            "        seed = random.randrange(10000)",
            "    percentage = 0.1 # default base_rate = 0.1%",
            "    if len(keywords) > 2:",
            "        percentage = float(keywords[2])",
            "    return seed, round(percentage, 4)",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    meta = {'_gt_label': KEYWORD}",
            "    if KEYWORD in path:",
            "        return '<object id={} src={} meta={} />' \\",
            "                .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                        quoteattr(_get_object_src_uri(object_path)),",
            "                        quoteattr(url_for('.get_object_meta', present=True)))",
            "",
            "    return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:present>')",
            "def get_object_meta(present=False):",
            "    attrs = dict()",
            "    if present:",
            "        attrs['_gt_label'] = KEYWORD",
            "",
            "    return jsonify(attrs)",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "",
            "    return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return safe_join(DATAROOT, obj_path)",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response",
            "",
            "def create_index(base_dir, base_rate=0.05, seed=42, rank=0, total_servers=1):",
            "    \"\"\"",
            "    Creates Index List File:",
            "    Assuming name of files NEGATIVE (e.g:subset YFCC), POSITIVE",
            "    \"\"\"",
            "",
            "    filepath_split = ['STREAM', \"{:.2f}\".format(base_rate), str(rank), str(total_servers), str(seed)]",
            "    filepath = '_'.join(filepath_split)",
            "    filepath = os.path.join(base_dir, filepath)",
            "    positive_path = os.path.join(base_dir, 'POSITIVE')",
            "    negative_path = os.path.join(base_dir, 'NEGATIVE')",
            "    positive_firstline = open(positive_path).readline().rstrip()",
            "    keyword = positive_firstline.split('/')[-2] # Assuming all positives are in the same parent dir",
            "",
            "    _log.info(\"Dir {} BR: {} Seed:{} FP{}\".format(base_dir, base_rate, seed, filepath))",
            "    sys.stdout.flush()",
            "",
            "    if not os.path.exists(filepath):",
            "        positive_data = read_file_list(positive_path) # same across servers",
            "        negative_data = read_file_list(negative_path) # different across servers",
            "        random.Random(seed).shuffle(positive_data)",
            "        random.Random(seed).shuffle(negative_data)",
            "        len_positive = len(positive_data)",
            "        start_idx = int(rank * (1.0 / total_servers) * len_positive)",
            "        end_idx = int((rank+1) * (1.0 / total_servers) * len_positive)",
            "        positive_data = positive_data[start_idx:end_idx]",
            "        len_positive = len(positive_data)",
            "        negative_sample = int(len_positive * (100./base_rate -1))",
            "        negative_data = negative_data[:negative_sample]",
            "        return write_data(filepath, [negative_data, positive_data], seed), keyword",
            "",
            "    return read_file_list(filepath), keyword"
        ],
        "afterPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "from builtins import next",
            "from builtins import range",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "import sys",
            "",
            "import logging",
            "import random",
            "import glob",
            "from itertools import cycle",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import safe_join",
            "from opendiamond.dataretriever.util import read_file_list, write_data",
            "",
            "",
            "BASEURL = 'augment'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "ITEMS_PER_ITERATION = int(1e4)",
            "KEYWORD = 'yellowthroat'",
            "",
            "\"\"\"",
            "    Example url:",
            "        /augment/root/<ROOT_DIR>/distributed/<id>of<N>/ \\",
            "            keywords/<d/r ([d]eterminant/[r]andom)>_<random_seed>_<base_rate>",
            "",
            "        /augment/root/STREAM/distributed/1of2/keywords/d_42_1.0",
            "\"\"\"",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = 'STREAM'",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('augment_store', __name__)",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +",
            "                        '/keywords/<params>')",
            "@scope_blueprint.route('/root/<rootdir>/keywords/<params>')",
            "@scope_blueprint.route('/root/<rootdir>/distributed/<int:index>of<int:total>' +",
            "                        '/keywords/<params>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/root/<rootdir>/keywords/<params>' +",
            "                        '/start/<int:start>/limit/<int:limit>')",
            "def get_scope(rootdir, index=0, total=1, params=None, start=0, limit=sys.maxsize):",
            "    global KEYWORD",
            "    if rootdir == \"0\":",
            "        rootdir = INDEXDIR",
            "",
            "    rootdir = _get_obj_absolute_path(rootdir)",
            "    seed = None",
            "    percentage = 0.",
            "    seed, percentage = decode_params(params)",
            "",
            "    # Assuming the same positive list is present in all the servers",
            "    # Always create a new index file",
            "    base_list, KEYWORD = create_index(rootdir, percentage, seed, index, total)",
            "    total_entries = len(base_list)",
            "",
            "    start = start if start > 0 else 0",
            "    end = min(total_entries, start + limit) if limit > 0 else total_entries",
            "    base_list = base_list[start:end]",
            "    total_entries = end - start",
            "",
            "    def generate():",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)",
            "",
            "        for path in base_list:",
            "            path = path.strip()",
            "            yield _get_object_element(object_path=path) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "def decode_params(params):",
            "    \"\"\"",
            "    Decodes the params which are '_' seperated",
            "    <[d]eterminant/[r]andom>_<random_seed>_<baserate>",
            "    \"\"\"",
            "    keywords = params.split('_')",
            "    mix_type = keywords[0]",
            "    seed = None",
            "    if len(keywords) > 1:",
            "        seed = int(keywords[1])",
            "    if mix_type == 'r' or seed is None:",
            "        seed = random.randrange(10000)",
            "    percentage = 0.1 # default base_rate = 0.1%",
            "    if len(keywords) > 2:",
            "        percentage = float(keywords[2])",
            "    return seed, round(percentage, 4)",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    meta = {'_gt_label': KEYWORD}",
            "    if KEYWORD in path:",
            "        return '<object id={} src={} meta={} />' \\",
            "                .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                        quoteattr(_get_object_src_uri(object_path)),",
            "                        quoteattr(url_for('.get_object_meta', present=True)))",
            "",
            "    return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:present>')",
            "def get_object_meta(present=False):",
            "    attrs = dict()",
            "    if present:",
            "        attrs['_gt_label'] = KEYWORD",
            "",
            "    return jsonify(attrs)",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "",
            "    return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return safe_join(DATAROOT, obj_path)",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response",
            "",
            "def create_index(base_dir, base_rate=0.05, seed=42, rank=0, total_servers=1):",
            "    \"\"\"",
            "    Creates Index List File:",
            "    Assuming name of files NEGATIVE (e.g:subset YFCC), POSITIVE",
            "    \"\"\"",
            "",
            "    filepath_split = ['STREAM', \"{:.2f}\".format(base_rate), str(rank), str(total_servers), str(seed)]",
            "    filepath = '_'.join(filepath_split)",
            "    filepath = os.path.join(base_dir, filepath)",
            "    positive_path = os.path.join(base_dir, 'POSITIVE')",
            "    negative_path = os.path.join(base_dir, 'NEGATIVE')",
            "    positive_firstline = open(positive_path).readline().rstrip()",
            "    keyword = positive_firstline.split('/')[-2] # Assuming all positives are in the same parent dir",
            "",
            "    _log.info(\"Dir {} BR: {} Seed:{} FP{}\".format(base_dir, base_rate, seed, filepath))",
            "    sys.stdout.flush()",
            "",
            "    if not os.path.exists(filepath):",
            "        positive_data = read_file_list(positive_path) # same across servers",
            "        negative_data = read_file_list(negative_path) # different across servers",
            "        random.Random(seed).shuffle(positive_data)",
            "        random.Random(seed).shuffle(negative_data)",
            "        len_positive = len(positive_data)",
            "        start_idx = int(rank * (1.0 / total_servers) * len_positive)",
            "        end_idx = int((rank+1) * (1.0 / total_servers) * len_positive)",
            "        positive_data = positive_data[start_idx:end_idx]",
            "        len_positive = len(positive_data)",
            "        negative_sample = int(len_positive * (100./base_rate -1))",
            "        negative_data = negative_data[:negative_sample]",
            "        return write_data(filepath, [negative_data, positive_data], seed), keyword",
            "",
            "    return read_file_list(filepath), keyword"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "27": []
        },
        "addLocation": []
    },
    "opendiamond/dataretriever/diamond_store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     jsonify"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from werkzeug.datastructures import Headers"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from werkzeug.security import safe_join"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from opendiamond.dataretriever.util import ATTR_SUFFIX"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " def _get_obj_absolute_path(obj_path):"
            },
            "10": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(DATAROOT, obj_path)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    return safe_join(DATAROOT, obj_path)"
            },
            "12": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " def _get_index_absolute_path(index):"
            },
            "15": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(INDEXDIR, index)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    return safe_join(INDEXDIR, index)"
            },
            "17": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " @scope_blueprint.route('/obj/<path:obj_path>')"
            }
        },
        "frontPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "",
            "from opendiamond.dataretriever.util import ATTR_SUFFIX",
            "",
            "BASEURL = 'collection'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = config.indexdir",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('diamond_store', __name__)",
            "",
            "",
            "@scope_blueprint.route('/<gididx>')",
            "@scope_blueprint.route('/<gididx>/limit/<int:limit>')",
            "def get_scope(gididx, limit=None):",
            "    index = 'GIDIDX' + gididx.upper()",
            "    index = _get_index_absolute_path(index)",
            "",
            "    # Streaming response:",
            "    # http://flask.pocoo.org/docs/0.12/patterns/streaming/",
            "    def generate():",
            "        num_entries = 0",
            "        with open(index, 'r') as f:",
            "            for _ in f.readlines():",
            "                num_entries += 1",
            "                if limit is not None and num_entries >= limit:",
            "                    break",
            "",
            "        with open(index, 'r') as f:",
            "            yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "            if STYLE:",
            "                yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "            yield '<objectlist count=\"{:d}\">\\n'.format(num_entries)",
            "            ",
            "            count = 0",
            "            for path in f.readlines():",
            "                path = path.strip()",
            "                yield _get_object_element(object_path=path) + '\\n'",
            "                count += 1",
            "                if limit is not None and count >= limit:",
            "                    break",
            "",
            "            yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:object_path>')",
            "def get_object_meta(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    attrs = dict()",
            "",
            "    try:",
            "        with DiamondTextAttr(path, 'r') as attributes:",
            "            for key, value in attributes:",
            "                attrs[key] = value",
            "    except IOError:",
            "        pass",
            "",
            "    return jsonify(attrs)",
            "",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "",
            "    if os.path.isfile(path + ATTR_SUFFIX):",
            "        return '<object id={} src={} meta={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)),",
            "                    quoteattr(url_for('.get_object_meta', object_path=object_path)))",
            "    else:",
            "        return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "    else:",
            "        return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return os.path.join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return os.path.join(INDEXDIR, index)",
            "",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response"
        ],
        "afterPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import safe_join",
            "",
            "from opendiamond.dataretriever.util import ATTR_SUFFIX",
            "",
            "BASEURL = 'collection'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = config.indexdir",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('diamond_store', __name__)",
            "",
            "",
            "@scope_blueprint.route('/<gididx>')",
            "@scope_blueprint.route('/<gididx>/limit/<int:limit>')",
            "def get_scope(gididx, limit=None):",
            "    index = 'GIDIDX' + gididx.upper()",
            "    index = _get_index_absolute_path(index)",
            "",
            "    # Streaming response:",
            "    # http://flask.pocoo.org/docs/0.12/patterns/streaming/",
            "    def generate():",
            "        num_entries = 0",
            "        with open(index, 'r') as f:",
            "            for _ in f.readlines():",
            "                num_entries += 1",
            "                if limit is not None and num_entries >= limit:",
            "                    break",
            "",
            "        with open(index, 'r') as f:",
            "            yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "            if STYLE:",
            "                yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "            yield '<objectlist count=\"{:d}\">\\n'.format(num_entries)",
            "            ",
            "            count = 0",
            "            for path in f.readlines():",
            "                path = path.strip()",
            "                yield _get_object_element(object_path=path) + '\\n'",
            "                count += 1",
            "                if limit is not None and count >= limit:",
            "                    break",
            "",
            "            yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:object_path>')",
            "def get_object_meta(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    attrs = dict()",
            "",
            "    try:",
            "        with DiamondTextAttr(path, 'r') as attributes:",
            "            for key, value in attributes:",
            "                attrs[key] = value",
            "    except IOError:",
            "        pass",
            "",
            "    return jsonify(attrs)",
            "",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "",
            "    if os.path.isfile(path + ATTR_SUFFIX):",
            "        return '<object id={} src={} meta={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)),",
            "                    quoteattr(url_for('.get_object_meta', object_path=object_path)))",
            "    else:",
            "        return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "    else:",
            "        return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return safe_join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return safe_join(INDEXDIR, index)",
            "",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "123": [
                "_get_obj_absolute_path"
            ],
            "127": [
                "_get_index_absolute_path"
            ]
        },
        "addLocation": []
    },
    "opendiamond/dataretriever/mixer_store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     jsonify"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from werkzeug.datastructures import Headers"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from werkzeug.security import safe_join"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " BASEURL = 'cocktail'"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " STYLE = False"
            },
            "7": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "     return obj_path.replace(DATAROOT+'/', '')"
            },
            "8": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 252,
                "PatchRowcode": " def _get_obj_absolute_path(obj_path):"
            },
            "10": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(DATAROOT, obj_path)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    return safe_join(DATAROOT, obj_path)"
            },
            "12": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 255,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 256,
                "PatchRowcode": " def _get_index_absolute_path(index):"
            },
            "15": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(INDEXDIR, index)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+    return safe_join(INDEXDIR, index)"
            },
            "17": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 260,
                "PatchRowcode": " @scope_blueprint.route('/obj/<path:obj_path>')"
            }
        },
        "frontPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "from builtins import next",
            "from builtins import range",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "import sys",
            "",
            "import logging",
            "import random",
            "import glob",
            "from itertools import cycle",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "",
            "BASEURL = 'cocktail'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "ITEMS_PER_ITERATION = int(1e4)",
            "",
            "\"\"\"",
            "    Example cocktail url:",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\",
            "            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal",
            "        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0",
            "\"\"\"",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = config.indexdir",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('mixer_store', __name__)",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')",
            "def get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, ",
            "                      classes=None, start=0, limit=-1):",
            "",
            "    mixer_list = get_mixer_list(mixeridx, classes)",
            "    start_idx = int((index-1)*(1.0/total)*len(mixer_list))",
            "    end_idx = int(index*(1.0/total)*len(mixer_list))",
            "    mixer_list = mixer_list[start_idx:end_idx]",
            "    print(\"Mixer Size {}\".format(len(mixer_list)))",
            "    sys.stdout.flush()",
            "",
            "    return get_scope(baseidx, params, mixer_list, start, limit)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')",
            "def get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):",
            "    print(\"Enter Scope\")",
            "    sys.stdout.flush()",
            "    base_list = []",
            "    seed, percentage = decode_params(params)",
            "    if baseidx != \"0\":",
            "        base_index = _get_index_absolute_path('GIDIDX' + baseidx.upper())",
            "        with open(base_index, 'r') as f:",
            "            base_list = list(f.readlines())",
            "        if limit > 0:",
            "            base_list = base_list[start:start+limit]",
            "        elif start > 0:",
            "            base_list = base_list[start:]",
            "        total_entries = len(base_list)",
            "",
            "",
            "    make_cocktail = bool(mixer_list and base_list)",
            "        ",
            "    if base_list:",
            "        total_entries = len(base_list)  #base_entries",
            "    else:",
            "        total_entries = len(mixer_list)",
            "        base_list = mixer_list.copy()",
            "        del mixer_list",
            "",
            "    random.seed(seed)",
            "    #random.Random(seed).shuffle(base_list)",
            "",
            "    total_sample = 0 ",
            "    if make_cocktail:",
            "        random.Random(seed).shuffle(mixer_list)",
            "        total_sample = int(percentage*total_entries)",
            "        total_entries = total_entries + total_sample",
            "",
            "    # Streaming response:",
            "    # http://flask.pocoo.org/docs/0.12/patterns/streaming/",
            "    def generate():",
            "",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)",
            "",
            "        mix_per_iteration = 0",
            "        iteration_count = 0",
            "        if make_cocktail:",
            "            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)",
            "            pool = cycle(mixer_list)",
            "",
            "        mix_indices = []",
            "",
            "        def generate_mix_indices():",
            "            random.seed(seed)",
            "            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,",
            "                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))",
            "",
            "        for count in range(total_entries):",
            "            if not count % ITEMS_PER_ITERATION and make_cocktail:",
            "                mix_indices = generate_mix_indices()",
            "                iteration_count += 1",
            "",
            "            if count in mix_indices:",
            "                obj_path = next(pool).strip()",
            "            else:",
            "                obj_path = base_list.pop(0).strip()",
            "            yield _get_object_element(object_path=obj_path) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "def decode_params(params):",
            "    keywords = params.split('_')",
            "    m_type = keywords[0]",
            "    seed = int(keywords[1])",
            "    percentage = 0.0001",
            "    if m_type == 'r':",
            "        seed = None",
            "    if len(keywords) > 2:",
            "        percentage = float(keywords[2])/100.",
            "    return seed, round(percentage, 4)",
            "",
            "def get_mixer_list(idx, classes=None):",
            "    \"\"\"",
            "    Return list of file paths present in given classes of mixer set",
            "    If class list is None or incorrect then return list of entire mixer set.",
            "",
            "    Args:",
            "        classes (str): Comma seperated classes of interest",
            "        idx     (str): Index of mixer collection",
            "",
            "    Returns:",
            "    \"\"\"",
            "    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())",
            "    classes_list = []",
            "    if classes:",
            "        classes.replace('%2C', ',')",
            "        classes.replace('%20', ' ')",
            "        classes_list = classes.split(',')",
            "",
            "    def get_class_path():",
            "        with open(mixer_index, 'r') as f:",
            "            dataset_path = f.readline()",
            "        dataset_path = '/'.join(dataset_path.split('/')[:-2])",
            "        class_paths = []",
            "        for c in classes_list:",
            "            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))",
            "        return class_paths",
            "",
            "    mixer_list = []",
            "    class_paths = get_class_path()",
            "    print(\"Class paths : {}\".format(class_paths))",
            "    sys.stdout.flush()",
            "",
            "    if class_paths:",
            "        for path in class_paths:",
            "            print(\"Path Exists ? {}\".format(os.path.exists(path)))",
            "            sys.stdout.flush()",
            "",
            "            mixer_list.extend(sorted(glob.glob(os.path.join(path, \"*.jpg\"))))",
            "        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]",
            "    else:",
            "        with open(mixer_index, 'r') as f:",
            "            mixer_list = list(f.readlines())",
            "",
            "    return mixer_list",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:object_path>')",
            "def get_object_meta(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    attrs = dict()",
            "",
            "    try:",
            "        attrs['_gt_label'] = path.split('/')[-2]",
            "    except IOError:",
            "        pass",
            "",
            "    return jsonify(attrs)",
            "",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'",
            "    if os.path.isfile(class_text):",
            "        return '<object id={} src={} meta={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)),",
            "                    quoteattr(url_for('.get_object_meta', object_path=object_path)))",
            "    return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "",
            "    return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "def _get_obj_path(obj_path):",
            "    return obj_path.replace(DATAROOT+'/', '')",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return os.path.join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return os.path.join(INDEXDIR, index)",
            "",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response"
        ],
        "afterPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "from builtins import next",
            "from builtins import range",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "import sys",
            "",
            "import logging",
            "import random",
            "import glob",
            "from itertools import cycle",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import safe_join",
            "",
            "BASEURL = 'cocktail'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "ITEMS_PER_ITERATION = int(1e4)",
            "",
            "\"\"\"",
            "    Example cocktail url:",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\",
            "            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal",
            "        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0",
            "\"\"\"",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = config.indexdir",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('mixer_store', __name__)",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')",
            "def get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, ",
            "                      classes=None, start=0, limit=-1):",
            "",
            "    mixer_list = get_mixer_list(mixeridx, classes)",
            "    start_idx = int((index-1)*(1.0/total)*len(mixer_list))",
            "    end_idx = int(index*(1.0/total)*len(mixer_list))",
            "    mixer_list = mixer_list[start_idx:end_idx]",
            "    print(\"Mixer Size {}\".format(len(mixer_list)))",
            "    sys.stdout.flush()",
            "",
            "    return get_scope(baseidx, params, mixer_list, start, limit)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')",
            "def get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):",
            "    print(\"Enter Scope\")",
            "    sys.stdout.flush()",
            "    base_list = []",
            "    seed, percentage = decode_params(params)",
            "    if baseidx != \"0\":",
            "        base_index = _get_index_absolute_path('GIDIDX' + baseidx.upper())",
            "        with open(base_index, 'r') as f:",
            "            base_list = list(f.readlines())",
            "        if limit > 0:",
            "            base_list = base_list[start:start+limit]",
            "        elif start > 0:",
            "            base_list = base_list[start:]",
            "        total_entries = len(base_list)",
            "",
            "",
            "    make_cocktail = bool(mixer_list and base_list)",
            "        ",
            "    if base_list:",
            "        total_entries = len(base_list)  #base_entries",
            "    else:",
            "        total_entries = len(mixer_list)",
            "        base_list = mixer_list.copy()",
            "        del mixer_list",
            "",
            "    random.seed(seed)",
            "    #random.Random(seed).shuffle(base_list)",
            "",
            "    total_sample = 0 ",
            "    if make_cocktail:",
            "        random.Random(seed).shuffle(mixer_list)",
            "        total_sample = int(percentage*total_entries)",
            "        total_entries = total_entries + total_sample",
            "",
            "    # Streaming response:",
            "    # http://flask.pocoo.org/docs/0.12/patterns/streaming/",
            "    def generate():",
            "",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)",
            "",
            "        mix_per_iteration = 0",
            "        iteration_count = 0",
            "        if make_cocktail:",
            "            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)",
            "            pool = cycle(mixer_list)",
            "",
            "        mix_indices = []",
            "",
            "        def generate_mix_indices():",
            "            random.seed(seed)",
            "            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,",
            "                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))",
            "",
            "        for count in range(total_entries):",
            "            if not count % ITEMS_PER_ITERATION and make_cocktail:",
            "                mix_indices = generate_mix_indices()",
            "                iteration_count += 1",
            "",
            "            if count in mix_indices:",
            "                obj_path = next(pool).strip()",
            "            else:",
            "                obj_path = base_list.pop(0).strip()",
            "            yield _get_object_element(object_path=obj_path) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "def decode_params(params):",
            "    keywords = params.split('_')",
            "    m_type = keywords[0]",
            "    seed = int(keywords[1])",
            "    percentage = 0.0001",
            "    if m_type == 'r':",
            "        seed = None",
            "    if len(keywords) > 2:",
            "        percentage = float(keywords[2])/100.",
            "    return seed, round(percentage, 4)",
            "",
            "def get_mixer_list(idx, classes=None):",
            "    \"\"\"",
            "    Return list of file paths present in given classes of mixer set",
            "    If class list is None or incorrect then return list of entire mixer set.",
            "",
            "    Args:",
            "        classes (str): Comma seperated classes of interest",
            "        idx     (str): Index of mixer collection",
            "",
            "    Returns:",
            "    \"\"\"",
            "    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())",
            "    classes_list = []",
            "    if classes:",
            "        classes.replace('%2C', ',')",
            "        classes.replace('%20', ' ')",
            "        classes_list = classes.split(',')",
            "",
            "    def get_class_path():",
            "        with open(mixer_index, 'r') as f:",
            "            dataset_path = f.readline()",
            "        dataset_path = '/'.join(dataset_path.split('/')[:-2])",
            "        class_paths = []",
            "        for c in classes_list:",
            "            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))",
            "        return class_paths",
            "",
            "    mixer_list = []",
            "    class_paths = get_class_path()",
            "    print(\"Class paths : {}\".format(class_paths))",
            "    sys.stdout.flush()",
            "",
            "    if class_paths:",
            "        for path in class_paths:",
            "            print(\"Path Exists ? {}\".format(os.path.exists(path)))",
            "            sys.stdout.flush()",
            "",
            "            mixer_list.extend(sorted(glob.glob(os.path.join(path, \"*.jpg\"))))",
            "        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]",
            "    else:",
            "        with open(mixer_index, 'r') as f:",
            "            mixer_list = list(f.readlines())",
            "",
            "    return mixer_list",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:object_path>')",
            "def get_object_meta(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    attrs = dict()",
            "",
            "    try:",
            "        attrs['_gt_label'] = path.split('/')[-2]",
            "    except IOError:",
            "        pass",
            "",
            "    return jsonify(attrs)",
            "",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'",
            "    if os.path.isfile(class_text):",
            "        return '<object id={} src={} meta={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)),",
            "                    quoteattr(url_for('.get_object_meta', object_path=object_path)))",
            "    return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "",
            "    return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "def _get_obj_path(obj_path):",
            "    return obj_path.replace(DATAROOT+'/', '')",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return safe_join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return safe_join(INDEXDIR, index)",
            "",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "252": [
                "_get_obj_absolute_path"
            ],
            "256": [
                "_get_index_absolute_path"
            ]
        },
        "addLocation": []
    },
    "opendiamond/dataretriever/test_store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     jsonify"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from werkzeug.datastructures import Headers"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from werkzeug.security import safe_join"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from opendiamond.dataretriever.test_utils import *"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "     return obj_path.replace(DATAROOT+'/', '')"
            },
            "9": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 282,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 283,
                "PatchRowcode": " def _get_obj_absolute_path(obj_path):"
            },
            "11": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(DATAROOT, obj_path)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+    return safe_join(DATAROOT, obj_path)"
            },
            "13": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 285,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 286,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 287,
                "PatchRowcode": " def _get_index_absolute_path(index):"
            },
            "16": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(INDEXDIR, index)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+    return safe_join(INDEXDIR, index)"
            },
            "18": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 290,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " @scope_blueprint.route('/obj/<path:obj_path>')"
            }
        },
        "frontPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "from builtins import next",
            "from builtins import range",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "import sys",
            "",
            "import logging",
            "import random",
            "import glob",
            "from itertools import cycle",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "from opendiamond.dataretriever.test_utils import *",
            "",
            "",
            "BASEURL = 'cocktailtest'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "ITEMS_PER_ITERATION = int(1e4)",
            "",
            "\"\"\"",
            "    Example cocktail url:",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\",
            "            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal",
            "        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0",
            "\"\"\"",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = '/srv/diamond/STREAM'",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('test_store', __name__)",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')",
            "def get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, ",
            "                      classes=None, start=0, limit=-1):",
            "",
            "    mixer_list = get_mixer_list(mixeridx, classes)",
            "    start_idx = int((index-1)*(1.0/total)*len(mixer_list))",
            "    end_idx = int(index*(1.0/total)*len(mixer_list))",
            "    mixer_list = mixer_list[start_idx:end_idx]",
            "    _log.info(\"Mixer Size {}\".format(len(mixer_list)))",
            "    sys.stdout.flush()",
            "",
            "    return get_scope(baseidx, params, mixer_list, start, limit)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/base/<baseidx>/start/<int:start>/limit/<int:limit>')",
            "def get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):",
            "    _log.info(\"Enter Scope baseIdx {}\".format(baseidx))",
            "    sys.stdout.flush()",
            "    base_list = []",
            "    seed = None",
            "    percentage = 0.",
            "    if params:",
            "        seed, percentage = decode_params(params)",
            "    s_seed = seed",
            "    if s_seed == None:",
            "        s_seed = random.randrange(10000)",
            "    if baseidx != \"0\":",
            "        # format of baseidx: stream_inat ",
            "        # format of base file: stream_{int: seed}_{float(.2f): baserate} ",
            "        base_index = _get_index_absolute_path(baseidx)",
            "        data_type, pos_file = base_index.split('_')",
            "        # index[-1] = str(\"{:.2f}\".format(index[-1])) # to ensure there is exactly two decial places",
            "        # if seed != s_seed:",
            "        #     index[1] = str(s_seed)",
            "        #     base_index = '_'.join(index)",
            "        base_list = [data_type, str(s_seed), pos_file, \"{:.2f}\".format(percentage)]",
            "        base_index = '_'.join(base_list)",
            "        print(base_index)",
            "        if not os.path.exists(base_index):",
            "            split_data(INDEXDIR, percentage, s_seed)",
            "        #base_index = base_index.replace(str(seed),str(s_seed))",
            "",
            "        with open(base_index, 'r') as f:",
            "            base_list = list(f.readlines())",
            "        if start > 0:",
            "            base_list = base_list[start:]",
            "        if limit > 0:",
            "            end_ = len(base_list)",
            "            if limit > end_:",
            "                limit = end_",
            "            base_list = base_list[:limit]",
            "        total_entries = len(base_list)",
            "",
            "",
            "    make_cocktail = bool(mixer_list and base_list)",
            "        ",
            "    if base_list:",
            "        total_entries = len(base_list)  #base_entries",
            "    else:",
            "        total_entries = len(mixer_list)",
            "        base_list = mixer_list.copy()",
            "        del mixer_list",
            "",
            "    random.seed(seed)",
            "    #random.Random(seed).shuffle(base_list)",
            "",
            "    total_sample = 0 ",
            "    if make_cocktail:",
            "        random.Random(seed).shuffle(mixer_list)",
            "        total_sample = int(percentage*total_entries)",
            "        total_entries = total_entries + total_sample",
            "",
            "    # Streaming response:",
            "    # http://flask.pocoo.org/docs/0.12/patterns/streaming/",
            "    def generate():",
            "",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)",
            "",
            "        mix_per_iteration = 0",
            "        iteration_count = 0",
            "        if make_cocktail:",
            "            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)",
            "            pool = cycle(mixer_list)",
            "",
            "        mix_indices = []",
            "",
            "        def generate_mix_indices():",
            "            random.seed(seed)",
            "            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,",
            "                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))",
            "",
            "        for count in range(total_entries):",
            "            if not count % ITEMS_PER_ITERATION and make_cocktail:",
            "                mix_indices = generate_mix_indices()",
            "                iteration_count += 1",
            "",
            "            if count in mix_indices:",
            "                obj_path = next(pool).strip()",
            "            else:",
            "                obj_path = base_list.pop(0).strip()",
            "            yield _get_object_element(object_path=obj_path) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "def decode_params(params):",
            "    keywords = params.split('_')",
            "    m_type = keywords[0]",
            "    seed = int(keywords[1])",
            "    percentage = 0.1",
            "    if m_type == 'r':",
            "        seed = None",
            "    if len(keywords) > 2:",
            "        percentage = float(keywords[2]) #float(keywords[2])/100.",
            "    return seed, round(percentage, 4)",
            "",
            "def get_mixer_list(idx, classes=None):",
            "    \"\"\"",
            "    Return list of file paths present in given classes of mixer set",
            "    If class list is None or incorrect then return list of entire mixer set.",
            "",
            "    Args:",
            "        classes (str): Comma seperated classes of interest",
            "        idx     (str): Index of mixer collection",
            "",
            "    Returns:",
            "    \"\"\"",
            "    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())",
            "",
            "    image_types = ('*.jpg', '*.JPG', '*.jpeg', '.png')",
            "",
            "    classes_list = []",
            "    if classes:",
            "        classes.replace('%2C', ',')",
            "        classes.replace('%20', ' ')",
            "        classes_list = classes.split(',')",
            "",
            "    def get_class_path():",
            "        with open(mixer_index, 'r') as f:",
            "            dataset_path = f.readline()",
            "        dataset_path = '/'.join(dataset_path.split('/')[:-2])",
            "        class_paths = []",
            "        for c in classes_list:",
            "            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))",
            "        return class_paths",
            "",
            "    mixer_list = []",
            "    class_paths = get_class_path()",
            "    _log.info(\"Class paths : {}\".format(class_paths))",
            "",
            "    if class_paths:",
            "        for path in class_paths:",
            "            _log.info(\"Path Exists ? {}\".format(os.path.exists(path)))",
            "            sys.stdout.flush()",
            "            file_list = []",
            "            for ext in image_types:",
            "                file_list.extend(glob.glob(os.path.join(path, ext)))",
            "            mixer_list.extend(sorted(file_list))",
            "        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]",
            "    else:",
            "        with open(mixer_index, 'r') as f:",
            "            mixer_list = list(f.readlines())",
            "",
            "    return mixer_list",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:object_path>')",
            "def get_object_meta(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    attrs = dict()",
            "",
            "    try:",
            "        attrs['_gt_label'] = path.split('/')[-2]",
            "    except IOError:",
            "        pass",
            "",
            "    return jsonify(attrs)",
            "",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'",
            "    if os.path.isfile(class_text):",
            "        return '<object id={} src={} meta={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)),",
            "                    quoteattr(url_for('.get_object_meta', object_path=object_path)))",
            "    return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "",
            "    return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "def _get_obj_path(obj_path):",
            "    return obj_path.replace(DATAROOT+'/', '')",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return os.path.join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return os.path.join(INDEXDIR, index)",
            "",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response"
        ],
        "afterPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2009-2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "",
            "from builtins import next",
            "from builtins import range",
            "import os",
            "import datetime",
            "from xml.sax.saxutils import quoteattr",
            "import sys",
            "",
            "import logging",
            "import random",
            "import glob",
            "from itertools import cycle",
            "from flask import Blueprint, url_for, Response, stream_with_context, send_file, \\",
            "    jsonify",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import safe_join",
            "",
            "from opendiamond.dataretriever.test_utils import *",
            "",
            "",
            "BASEURL = 'cocktailtest'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local file path, otherwise http.",
            "INDEXDIR = DATAROOT = None",
            "ITEMS_PER_ITERATION = int(1e4)",
            "",
            "\"\"\"",
            "    Example cocktail url:",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/distrbuted/1of2/ \\",
            "            mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0/classes/gull,cardinal",
            "        /cocktail/base/\"0\"/mixers/FFFFFFFFFFFFFFFC/keywords/d_42_1.0",
            "        /cocktail/base/FFFFFFFFFFFFFFFF/keywords/d_42_1.0",
            "\"\"\"",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = '/srv/diamond/STREAM'",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('test_store', __name__)",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>')",
            "@scope_blueprint.route('/base/<baseidx>/mixers/<mixeridx>/keywords/<params>/' +",
            "                        'classes/<classes>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/distrbuted/<int:index>of<int:total>/' +",
            "                        'mixers/<mixeridx>/keywords/<params>/classes/<classes>')",
            "def get_mixer_classes(baseidx, mixeridx=None, index=1, total=1, params=None, ",
            "                      classes=None, start=0, limit=-1):",
            "",
            "    mixer_list = get_mixer_list(mixeridx, classes)",
            "    start_idx = int((index-1)*(1.0/total)*len(mixer_list))",
            "    end_idx = int(index*(1.0/total)*len(mixer_list))",
            "    mixer_list = mixer_list[start_idx:end_idx]",
            "    _log.info(\"Mixer Size {}\".format(len(mixer_list)))",
            "    sys.stdout.flush()",
            "",
            "    return get_scope(baseidx, params, mixer_list, start, limit)",
            "",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>')",
            "@scope_blueprint.route('/base/<baseidx>/keywords/<params>/start/<int:start>/limit/<int:limit>')",
            "@scope_blueprint.route('/base/<baseidx>/start/<int:start>/limit/<int:limit>')",
            "def get_scope(baseidx, params=None, mixer_list=None, start=0, limit=-1):",
            "    _log.info(\"Enter Scope baseIdx {}\".format(baseidx))",
            "    sys.stdout.flush()",
            "    base_list = []",
            "    seed = None",
            "    percentage = 0.",
            "    if params:",
            "        seed, percentage = decode_params(params)",
            "    s_seed = seed",
            "    if s_seed == None:",
            "        s_seed = random.randrange(10000)",
            "    if baseidx != \"0\":",
            "        # format of baseidx: stream_inat ",
            "        # format of base file: stream_{int: seed}_{float(.2f): baserate} ",
            "        base_index = _get_index_absolute_path(baseidx)",
            "        data_type, pos_file = base_index.split('_')",
            "        # index[-1] = str(\"{:.2f}\".format(index[-1])) # to ensure there is exactly two decial places",
            "        # if seed != s_seed:",
            "        #     index[1] = str(s_seed)",
            "        #     base_index = '_'.join(index)",
            "        base_list = [data_type, str(s_seed), pos_file, \"{:.2f}\".format(percentage)]",
            "        base_index = '_'.join(base_list)",
            "        print(base_index)",
            "        if not os.path.exists(base_index):",
            "            split_data(INDEXDIR, percentage, s_seed)",
            "        #base_index = base_index.replace(str(seed),str(s_seed))",
            "",
            "        with open(base_index, 'r') as f:",
            "            base_list = list(f.readlines())",
            "        if start > 0:",
            "            base_list = base_list[start:]",
            "        if limit > 0:",
            "            end_ = len(base_list)",
            "            if limit > end_:",
            "                limit = end_",
            "            base_list = base_list[:limit]",
            "        total_entries = len(base_list)",
            "",
            "",
            "    make_cocktail = bool(mixer_list and base_list)",
            "        ",
            "    if base_list:",
            "        total_entries = len(base_list)  #base_entries",
            "    else:",
            "        total_entries = len(mixer_list)",
            "        base_list = mixer_list.copy()",
            "        del mixer_list",
            "",
            "    random.seed(seed)",
            "    #random.Random(seed).shuffle(base_list)",
            "",
            "    total_sample = 0 ",
            "    if make_cocktail:",
            "        random.Random(seed).shuffle(mixer_list)",
            "        total_sample = int(percentage*total_entries)",
            "        total_entries = total_entries + total_sample",
            "",
            "    # Streaming response:",
            "    # http://flask.pocoo.org/docs/0.12/patterns/streaming/",
            "    def generate():",
            "",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist count=\"{:d}\">\\n'.format(total_entries)",
            "",
            "        mix_per_iteration = 0",
            "        iteration_count = 0",
            "        if make_cocktail:",
            "            mix_per_iteration = int(percentage * ITEMS_PER_ITERATION)",
            "            pool = cycle(mixer_list)",
            "",
            "        mix_indices = []",
            "",
            "        def generate_mix_indices():",
            "            random.seed(seed)",
            "            return list(map(lambda x: x + ITEMS_PER_ITERATION*iteration_count,",
            "                    sorted(random.sample(list(range(ITEMS_PER_ITERATION)), mix_per_iteration))))",
            "",
            "        for count in range(total_entries):",
            "            if not count % ITEMS_PER_ITERATION and make_cocktail:",
            "                mix_indices = generate_mix_indices()",
            "                iteration_count += 1",
            "",
            "            if count in mix_indices:",
            "                obj_path = next(pool).strip()",
            "            else:",
            "                obj_path = base_list.pop(0).strip()",
            "            yield _get_object_element(object_path=obj_path) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "def decode_params(params):",
            "    keywords = params.split('_')",
            "    m_type = keywords[0]",
            "    seed = int(keywords[1])",
            "    percentage = 0.1",
            "    if m_type == 'r':",
            "        seed = None",
            "    if len(keywords) > 2:",
            "        percentage = float(keywords[2]) #float(keywords[2])/100.",
            "    return seed, round(percentage, 4)",
            "",
            "def get_mixer_list(idx, classes=None):",
            "    \"\"\"",
            "    Return list of file paths present in given classes of mixer set",
            "    If class list is None or incorrect then return list of entire mixer set.",
            "",
            "    Args:",
            "        classes (str): Comma seperated classes of interest",
            "        idx     (str): Index of mixer collection",
            "",
            "    Returns:",
            "    \"\"\"",
            "    mixer_index = _get_index_absolute_path('GIDIDX' + idx.upper())",
            "",
            "    image_types = ('*.jpg', '*.JPG', '*.jpeg', '.png')",
            "",
            "    classes_list = []",
            "    if classes:",
            "        classes.replace('%2C', ',')",
            "        classes.replace('%20', ' ')",
            "        classes_list = classes.split(',')",
            "",
            "    def get_class_path():",
            "        with open(mixer_index, 'r') as f:",
            "            dataset_path = f.readline()",
            "        dataset_path = '/'.join(dataset_path.split('/')[:-2])",
            "        class_paths = []",
            "        for c in classes_list:",
            "            class_paths.append(_get_obj_absolute_path(dataset_path+'/'+c.strip()))",
            "        return class_paths",
            "",
            "    mixer_list = []",
            "    class_paths = get_class_path()",
            "    _log.info(\"Class paths : {}\".format(class_paths))",
            "",
            "    if class_paths:",
            "        for path in class_paths:",
            "            _log.info(\"Path Exists ? {}\".format(os.path.exists(path)))",
            "            sys.stdout.flush()",
            "            file_list = []",
            "            for ext in image_types:",
            "                file_list.extend(glob.glob(os.path.join(path, ext)))",
            "            mixer_list.extend(sorted(file_list))",
            "        mixer_list = [_get_obj_path(l.strip()) for l in mixer_list]",
            "    else:",
            "        with open(mixer_index, 'r') as f:",
            "            mixer_list = list(f.readlines())",
            "",
            "    return mixer_list",
            "",
            "@scope_blueprint.route('/id/<path:object_path>')",
            "def get_object_id(object_path):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(object_path=object_path),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/meta/<path:object_path>')",
            "def get_object_meta(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    attrs = dict()",
            "",
            "    try:",
            "        attrs['_gt_label'] = path.split('/')[-2]",
            "    except IOError:",
            "        pass",
            "",
            "    return jsonify(attrs)",
            "",
            "",
            "def _get_object_element(object_path):",
            "    path = _get_obj_absolute_path(object_path)",
            "    class_text = '/'.join(path.split('/')[:-2])+'/classes.txt'",
            "    if os.path.isfile(class_text):",
            "        return '<object id={} src={} meta={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)),",
            "                    quoteattr(url_for('.get_object_meta', object_path=object_path)))",
            "    return '<object id={} src={} />' \\",
            "            .format(quoteattr(url_for('.get_object_id', object_path=object_path)),",
            "                    quoteattr(_get_object_src_uri(object_path)))",
            "",
            "",
            "def _get_object_src_uri(object_path):",
            "    if LOCAL_OBJ_URI:",
            "        return 'file://' + _get_obj_absolute_path(object_path)",
            "",
            "    return url_for('.get_object_src_http', obj_path=object_path)",
            "",
            "def _get_obj_path(obj_path):",
            "    return obj_path.replace(DATAROOT+'/', '')",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return safe_join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return safe_join(INDEXDIR, index)",
            "",
            "",
            "@scope_blueprint.route('/obj/<path:obj_path>')",
            "def get_object_src_http(obj_path):",
            "    path = _get_obj_absolute_path(obj_path)",
            "",
            "    headers = Headers()",
            "    # With add_etags=True, conditional=True",
            "    # Flask should be smart enough to do 304 Not Modified",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    response.headers.extend(headers)",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "282": [
                "_get_obj_absolute_path"
            ],
            "286": [
                "_get_index_absolute_path"
            ]
        },
        "addLocation": []
    },
    "opendiamond/dataretriever/video_store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from flask import Blueprint, Response, request, stream_with_context, url_for"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from opendiamond.dataretriever.util import DiamondTextAttr"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from werkzeug.datastructures import Headers"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from werkzeug.security import safe_join"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " # IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping."
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " def _get_obj_absolute_path(obj_path):"
            },
            "10": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(DATAROOT, obj_path)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    return safe_join(DATAROOT, obj_path)"
            },
            "12": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " def _get_index_absolute_path(index):"
            },
            "15": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(INDEXDIR, index)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    return safe_join(INDEXDIR, index)"
            },
            "17": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " def _ffprobe(video_path):"
            }
        },
        "frontPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "from builtins import range, str",
            "",
            "import datetime",
            "import json",
            "import os",
            "import subprocess",
            "import sys",
            "from math import ceil",
            "",
            "from flask import Blueprint, Response, request, stream_with_context, url_for",
            "from opendiamond.dataretriever.util import DiamondTextAttr",
            "from werkzeug.datastructures import Headers",
            "",
            "# IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.",
            "",
            "BASEURL = 'video'",
            "STYLE = False",
            "INDEXDIR = DATAROOT = None",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = config.indexdir",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('video_store', __name__)",
            "",
            "@scope_blueprint.route('/scope/<gididx>')",
            "@scope_blueprint.route('/scope/stride/<int:stride>/span/<int:span>/<gididx>')",
            "def get_scope(gididx, stride=5, span=5):",
            "    index = 'GIDIDX' + gididx.upper()",
            "",
            "    def generate():",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist>\\n'",
            "",
            "        with open(_get_index_absolute_path(index), 'rt') as f:",
            "            for line in f:",
            "                video = line.strip()",
            "                video_path = str(_get_obj_absolute_path(video))",
            "                try:",
            "                    video_meta = _ffprobe(video_path)",
            "                    length_sec = float(video_meta['format']['duration'])",
            "                    num_clips = int(ceil(length_sec / stride))",
            "                    yield '<count adjust=\"{}\"/>\\n'.format(num_clips)",
            "                    for clip in range(num_clips):",
            "                        yield _get_object_element(start=clip * stride, span=span, video=video) + '\\n'",
            "                except Exception as e:",
            "                    print(\"Error parsing {}. {}. Skip.\".format(video, str(e)), file=sys.stderr)",
            "                    pass",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/id/start/<int:start>/span/<int:span>/<path:video>')",
            "def get_object_id(start, span, video):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(start, span, video),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/obj/start/<int:start>/span/<int:span>/<path:video>')",
            "def get_object(start, span, video):",
            "    # Reference:",
            "    # https://github.com/mikeboers/PyAV/blob/master/tests/test_seek.py",
            "    video_path = str(_get_obj_absolute_path(video))",
            "    proc = _create_ffmpeg_segment_proc(video_path,",
            "                                       start_sec=start,",
            "                                       duration_sec=span)",
            "",
            "    def generate():",
            "        while True:",
            "            data = proc.stdout.read(4096)",
            "            if not data:",
            "                break",
            "            yield data",
            "",
            "    headers = Headers([('Content-Type', 'video/mp4')])",
            "    response = Response(stream_with_context(generate()),",
            "                        status=\"200 OK\",",
            "                        headers=headers)",
            "    # Cache control",
            "    stat = os.stat(video_path)",
            "    last_modified = stat.st_mtime",
            "    size = stat.st_size",
            "    etag = \"{}_{}_{}_{}\".format(last_modified, size, start, span)",
            "    response.last_modified = last_modified",
            "    response.set_etag(etag=etag)",
            "    response.cache_control.public = True",
            "    response.cache_control.max_age = \\",
            "        datetime.timedelta(days=365).total_seconds()",
            "    response.make_conditional(request)",
            "",
            "    return response",
            "",
            "",
            "def _get_object_element(start, span, video):",
            "    return '<object id=\"{}\" src=\"{}\" />'.format(",
            "        url_for('.get_object_id', start=start, span=span, video=video),",
            "        url_for('.get_object', start=start, span=span, video=video))",
            "",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return os.path.join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return os.path.join(INDEXDIR, index)",
            "",
            "",
            "def _ffprobe(video_path):",
            "    cmd_l = ['ffprobe', '-v', 'quiet', '-print_format', 'json',",
            "                '-show_format', video_path]",
            "",
            "    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)",
            "    data = json.load(proc.stdout)",
            "    ",
            "    return data",
            "",
            "",
            "def _create_ffmpeg_segment_proc(video_path, start_sec, duration_sec):",
            "    \"\"\"",
            "    Use ffmpeg to extract a .mp4 segment of the video. Outfile is written to stdout.",
            "    Note: requires ffmpeg >= 3.3. Lower versions produce wrong results.",
            "    Reference: http://trac.ffmpeg.org/wiki/Seeking",
            "    https://stackoverflow.com/questions/34123272/ffmpeg-transmux-mpegts-to-mp4-gives-error-muxer-does-not-support-non-seekable",
            "    :param video_path:",
            "    :param start_sec:",
            "    :param duration_sec:",
            "    :return: the subprocess",
            "    \"\"\"",
            "    cmd_l = ['ffmpeg', '-v', 'quiet',",
            "             '-ss', str(start_sec),",
            "             '-t', str(duration_sec),",
            "             '-i', str(video_path),",
            "             '-movflags', 'frag_keyframe+empty_moov',",
            "             '-c', 'copy',",
            "             '-f', 'mp4',",
            "             'pipe:1']",
            "",
            "    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)",
            "    return proc"
        ],
        "afterPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "from builtins import range, str",
            "",
            "import datetime",
            "import json",
            "import os",
            "import subprocess",
            "import sys",
            "from math import ceil",
            "",
            "from flask import Blueprint, Response, request, stream_with_context, url_for",
            "from opendiamond.dataretriever.util import DiamondTextAttr",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import safe_join",
            "",
            "# IMPORTANT: requires ffmpeg >= 3.3. Lower versions produce incorrect clipping.",
            "",
            "BASEURL = 'video'",
            "STYLE = False",
            "INDEXDIR = DATAROOT = None",
            "",
            "",
            "def init(config):",
            "    global INDEXDIR, DATAROOT  # pylint: disable=global-statement",
            "    INDEXDIR = config.indexdir",
            "    DATAROOT = config.dataroot",
            "",
            "",
            "scope_blueprint = Blueprint('video_store', __name__)",
            "",
            "@scope_blueprint.route('/scope/<gididx>')",
            "@scope_blueprint.route('/scope/stride/<int:stride>/span/<int:span>/<gididx>')",
            "def get_scope(gididx, stride=5, span=5):",
            "    index = 'GIDIDX' + gididx.upper()",
            "",
            "    def generate():",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist>\\n'",
            "",
            "        with open(_get_index_absolute_path(index), 'rt') as f:",
            "            for line in f:",
            "                video = line.strip()",
            "                video_path = str(_get_obj_absolute_path(video))",
            "                try:",
            "                    video_meta = _ffprobe(video_path)",
            "                    length_sec = float(video_meta['format']['duration'])",
            "                    num_clips = int(ceil(length_sec / stride))",
            "                    yield '<count adjust=\"{}\"/>\\n'.format(num_clips)",
            "                    for clip in range(num_clips):",
            "                        yield _get_object_element(start=clip * stride, span=span, video=video) + '\\n'",
            "                except Exception as e:",
            "                    print(\"Error parsing {}. {}. Skip.\".format(video, str(e)), file=sys.stderr)",
            "                    pass",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/id/start/<int:start>/span/<int:span>/<path:video>')",
            "def get_object_id(start, span, video):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(start, span, video),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "",
            "@scope_blueprint.route('/obj/start/<int:start>/span/<int:span>/<path:video>')",
            "def get_object(start, span, video):",
            "    # Reference:",
            "    # https://github.com/mikeboers/PyAV/blob/master/tests/test_seek.py",
            "    video_path = str(_get_obj_absolute_path(video))",
            "    proc = _create_ffmpeg_segment_proc(video_path,",
            "                                       start_sec=start,",
            "                                       duration_sec=span)",
            "",
            "    def generate():",
            "        while True:",
            "            data = proc.stdout.read(4096)",
            "            if not data:",
            "                break",
            "            yield data",
            "",
            "    headers = Headers([('Content-Type', 'video/mp4')])",
            "    response = Response(stream_with_context(generate()),",
            "                        status=\"200 OK\",",
            "                        headers=headers)",
            "    # Cache control",
            "    stat = os.stat(video_path)",
            "    last_modified = stat.st_mtime",
            "    size = stat.st_size",
            "    etag = \"{}_{}_{}_{}\".format(last_modified, size, start, span)",
            "    response.last_modified = last_modified",
            "    response.set_etag(etag=etag)",
            "    response.cache_control.public = True",
            "    response.cache_control.max_age = \\",
            "        datetime.timedelta(days=365).total_seconds()",
            "    response.make_conditional(request)",
            "",
            "    return response",
            "",
            "",
            "def _get_object_element(start, span, video):",
            "    return '<object id=\"{}\" src=\"{}\" />'.format(",
            "        url_for('.get_object_id', start=start, span=span, video=video),",
            "        url_for('.get_object', start=start, span=span, video=video))",
            "",
            "",
            "def _get_obj_absolute_path(obj_path):",
            "    return safe_join(DATAROOT, obj_path)",
            "",
            "",
            "def _get_index_absolute_path(index):",
            "    return safe_join(INDEXDIR, index)",
            "",
            "",
            "def _ffprobe(video_path):",
            "    cmd_l = ['ffprobe', '-v', 'quiet', '-print_format', 'json',",
            "                '-show_format', video_path]",
            "",
            "    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)",
            "    data = json.load(proc.stdout)",
            "    ",
            "    return data",
            "",
            "",
            "def _create_ffmpeg_segment_proc(video_path, start_sec, duration_sec):",
            "    \"\"\"",
            "    Use ffmpeg to extract a .mp4 segment of the video. Outfile is written to stdout.",
            "    Note: requires ffmpeg >= 3.3. Lower versions produce wrong results.",
            "    Reference: http://trac.ffmpeg.org/wiki/Seeking",
            "    https://stackoverflow.com/questions/34123272/ffmpeg-transmux-mpegts-to-mp4-gives-error-muxer-does-not-support-non-seekable",
            "    :param video_path:",
            "    :param start_sec:",
            "    :param duration_sec:",
            "    :return: the subprocess",
            "    \"\"\"",
            "    cmd_l = ['ffmpeg', '-v', 'quiet',",
            "             '-ss', str(start_sec),",
            "             '-t', str(duration_sec),",
            "             '-i', str(video_path),",
            "             '-movflags', 'frag_keyframe+empty_moov',",
            "             '-c', 'copy',",
            "             '-f', 'mp4',",
            "             'pipe:1']",
            "",
            "    proc = subprocess.Popen(cmd_l, stdout=subprocess.PIPE, bufsize=-1)",
            "    return proc"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "125": [
                "_get_obj_absolute_path"
            ],
            "129": [
                "_get_index_absolute_path"
            ]
        },
        "addLocation": []
    },
    "opendiamond/dataretriever/yfcc100m_mysql_store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " import mysql.connector"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from werkzeug.datastructures import Headers"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from werkzeug.security import safe_join"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from xml.sax.saxutils import quoteattr"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " BASEURL = 'yfcc100m_mysql'"
            },
            "7": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " @scope_blueprint.route('/obj/<dataset>/<path:rel_path>')"
            },
            "9": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " def get_object_src_http(dataset, rel_path):"
            },
            "10": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    path = _get_obj_abosolute_path(dataset, rel_path)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    path = _get_obj_absolute_path(dataset, rel_path)"
            },
            "12": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     response = send_file(path,"
            },
            "13": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "                          cache_timeout=datetime.timedelta("
            },
            "14": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                              days=365).total_seconds(),"
            },
            "15": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     return response"
            },
            "16": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _get_obj_abosolute_path(dataset, rel_path):"
            },
            "19": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return os.path.join(DATAROOT, dataset, rel_path)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+def _get_obj_absolute_path(dataset, rel_path):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    return safe_join(DATAROOT, dataset, rel_path)"
            },
            "22": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " def _get_object_element(dataset, seq_no, rel_path, download_link):"
            },
            "25": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         rel_path, download_link = row[0], row[1]"
            },
            "26": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     if LOCAL_OBJ_URI:"
            },
            "28": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        src_uri = 'file://' + os.path.join(DATAROOT, dataset, rel_path)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        src_uri = 'file://' + _get_obj_absolute_path(dataset, rel_path)"
            },
            "30": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     else:"
            },
            "31": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)"
            },
            "32": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "\"\"\"",
            "Pre-conditions:",
            "Metadata of a data set is stored in a table <dataset> in a MySQL database.",
            "Files (objects) belonging to a dataset are stored under DATAROOT/<dataset>/.",
            "MySQL table stores relative path to the above directory.",
            "Table provides keyword search to get list of objects.",
            "Database login info is obtained from DiamondConfig.",
            "MySQL table is indexed with:",
            " FULLTEXT (title, keywords, description)",
            "",
            "Requires:",
            "pip install mysql-connector-python==8.0.6",
            "\"\"\"",
            "import datetime",
            "import os",
            "from flask import Blueprint, url_for, Response, \\",
            "    stream_with_context, abort, jsonify, send_file",
            "import logging",
            "import mysql.connector",
            "from werkzeug.datastructures import Headers",
            "from xml.sax.saxutils import quoteattr",
            "",
            "BASEURL = 'yfcc100m_mysql'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local path, otherwise http.",
            "DATAROOT = None",
            "DB_HOST = DB_DBNAME = DB_USER = DB_PASSWORD = DB_PORT = None",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "yfcc100m_s3_image_prefix = 'https://multimedia-commons.s3-us-west-2.amazonaws.com/data/images/'",
            "",
            "",
            "def init(config):",
            "    global DATAROOT  # pylint: disable=global-statement",
            "    DATAROOT = config.dataroot",
            "    global DB_HOST, DB_DBNAME, DB_USER, DB_PASSWORD, DB_PORT",
            "    DB_HOST = config.yfcc100m_db_host",
            "    DB_DBNAME = config.yfcc100m_db_dbname",
            "    DB_USER = config.yfcc100m_db_user",
            "    DB_PASSWORD = config.yfcc100m_db_password",
            "    DB_PORT = config.yfcc100m_db_port",
            "",
            "",
            "scope_blueprint = Blueprint('mysql_store', __name__)",
            "",
            "",
            "@scope_blueprint.route('/scope/<dataset>')",
            "@scope_blueprint.route('/scope/<dataset>/keywords/<keywords>')",
            "@scope_blueprint.route('/scope/<dataset>/modulo/<int:divisor>/<expression>')",
            "@scope_blueprint.route(",
            "    '/scope/<dataset>/keywords/<keywords>/modulo/<int:divisor>/<expression>')",
            "def get_scope(dataset, keywords=None, divisor=None, expression=None):",
            "    \"\"\"",
            "",
            "    :param expression: Can be \"<3\", \"=3\", \">3\", etc.",
            "    :param dataset:",
            "    :param keywords: a string of comma-separated keywords",
            "    :param divisor: positive int",
            "    :return:",
            "    \"\"\"",
            "    # cursor.execute() can't substitute table name",
            "    query = \"SELECT sequence_no, rel_path, download_link FROM \" + dataset",
            "    conditions = []",
            "    substitutes = []",
            "    if keywords:",
            "        conditions.append(\"MATCH (title, keywords, description) AGAINST(%s)\")",
            "        substitutes.append(keywords)",
            "",
            "    if divisor:",
            "        # TODO sanity check expression",
            "        conditions.append(\"(sequence_no % %s) \" + expression)",
            "        substitutes.extend([divisor])",
            "",
            "    if conditions:",
            "        query += \" WHERE \" + ' AND '.join(conditions)",
            "",
            "    _log.debug(\"Query used: %s, substitutes: %s\", query, substitutes)",
            "",
            "    def generate():",
            "        cnx = mysql.connector.connect(user=DB_USER,",
            "                                      password=DB_PASSWORD,",
            "                                      host=DB_HOST,",
            "                                      database=DB_DBNAME,",
            "                                      port=DB_PORT)",
            "        cursor = cnx.cursor()",
            "        cursor.execute(query, substitutes)",
            "",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist>\\n'",
            "        for seq_no, rel_path, download_link in cursor:",
            "            yield '<count adjust=\"1\"/>\\n'",
            "            yield _get_object_element(dataset, seq_no, rel_path,",
            "                                      download_link) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "@scope_blueprint.route('/id/<dataset>/<int:seq_no>')",
            "def get_object_id(dataset, seq_no):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(dataset, seq_no, None, None),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "@scope_blueprint.route('/obj/<dataset>/<path:rel_path>')",
            "def get_object_src_http(dataset, rel_path):",
            "    path = _get_obj_abosolute_path(dataset, rel_path)",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    return response",
            "",
            "",
            "def _get_obj_abosolute_path(dataset, rel_path):",
            "    return os.path.join(DATAROOT, dataset, rel_path)",
            "",
            "",
            "def _get_object_element(dataset, seq_no, rel_path, download_link):",
            "    \"\"\"If rel_path and download_link are not None, we are called from scope.",
            "    Otherwise we are called from ID and need to run SQL query to fetch these attrs.\"\"\"",
            "",
            "    if rel_path is None:",
            "        query = \"SELECT rel_path, download_link FROM \" + \\",
            "        dataset + \\",
            "        \" WHERE sequence_no = %s\"",
            "",
            "        cnx = mysql.connector.connect(user=DB_USER,",
            "                                    password=DB_PASSWORD,",
            "                                    host=DB_HOST,",
            "                                    database=DB_DBNAME,",
            "                                    port=DB_PORT)",
            "        cursor = cnx.cursor()",
            "        cursor.execute(query, (seq_no,))",
            "",
            "        row = cursor.fetchone()",
            "",
            "        if not row:",
            "            return None",
            "",
            "        rel_path, download_link = row[0], row[1]",
            "",
            "    if LOCAL_OBJ_URI:",
            "        src_uri = 'file://' + os.path.join(DATAROOT, dataset, rel_path)",
            "    else:",
            "        src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)",
            "",
            "    return '<object id={} src={} hyperfind.external-link={} />' \\",
            "        .format(",
            "        quoteattr(url_for('.get_object_id', dataset=dataset, seq_no=seq_no)),",
            "        quoteattr(src_uri),",
            "        quoteattr(download_link))"
        ],
        "afterPatchFile": [
            "#",
            "#  The OpenDiamond Platform for Interactive Search",
            "#",
            "#  Copyright (c) 2018 Carnegie Mellon University",
            "#  All rights reserved.",
            "#",
            "#  This software is distributed under the terms of the Eclipse Public",
            "#  License, Version 1.0 which can be found in the file named LICENSE.",
            "#  ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES",
            "#  RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT",
            "#",
            "\"\"\"",
            "Pre-conditions:",
            "Metadata of a data set is stored in a table <dataset> in a MySQL database.",
            "Files (objects) belonging to a dataset are stored under DATAROOT/<dataset>/.",
            "MySQL table stores relative path to the above directory.",
            "Table provides keyword search to get list of objects.",
            "Database login info is obtained from DiamondConfig.",
            "MySQL table is indexed with:",
            " FULLTEXT (title, keywords, description)",
            "",
            "Requires:",
            "pip install mysql-connector-python==8.0.6",
            "\"\"\"",
            "import datetime",
            "import os",
            "from flask import Blueprint, url_for, Response, \\",
            "    stream_with_context, abort, jsonify, send_file",
            "import logging",
            "import mysql.connector",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.security import safe_join",
            "from xml.sax.saxutils import quoteattr",
            "",
            "BASEURL = 'yfcc100m_mysql'",
            "STYLE = False",
            "LOCAL_OBJ_URI = True  # if true, return local path, otherwise http.",
            "DATAROOT = None",
            "DB_HOST = DB_DBNAME = DB_USER = DB_PASSWORD = DB_PORT = None",
            "",
            "_log = logging.getLogger(__name__)",
            "",
            "yfcc100m_s3_image_prefix = 'https://multimedia-commons.s3-us-west-2.amazonaws.com/data/images/'",
            "",
            "",
            "def init(config):",
            "    global DATAROOT  # pylint: disable=global-statement",
            "    DATAROOT = config.dataroot",
            "    global DB_HOST, DB_DBNAME, DB_USER, DB_PASSWORD, DB_PORT",
            "    DB_HOST = config.yfcc100m_db_host",
            "    DB_DBNAME = config.yfcc100m_db_dbname",
            "    DB_USER = config.yfcc100m_db_user",
            "    DB_PASSWORD = config.yfcc100m_db_password",
            "    DB_PORT = config.yfcc100m_db_port",
            "",
            "",
            "scope_blueprint = Blueprint('mysql_store', __name__)",
            "",
            "",
            "@scope_blueprint.route('/scope/<dataset>')",
            "@scope_blueprint.route('/scope/<dataset>/keywords/<keywords>')",
            "@scope_blueprint.route('/scope/<dataset>/modulo/<int:divisor>/<expression>')",
            "@scope_blueprint.route(",
            "    '/scope/<dataset>/keywords/<keywords>/modulo/<int:divisor>/<expression>')",
            "def get_scope(dataset, keywords=None, divisor=None, expression=None):",
            "    \"\"\"",
            "",
            "    :param expression: Can be \"<3\", \"=3\", \">3\", etc.",
            "    :param dataset:",
            "    :param keywords: a string of comma-separated keywords",
            "    :param divisor: positive int",
            "    :return:",
            "    \"\"\"",
            "    # cursor.execute() can't substitute table name",
            "    query = \"SELECT sequence_no, rel_path, download_link FROM \" + dataset",
            "    conditions = []",
            "    substitutes = []",
            "    if keywords:",
            "        conditions.append(\"MATCH (title, keywords, description) AGAINST(%s)\")",
            "        substitutes.append(keywords)",
            "",
            "    if divisor:",
            "        # TODO sanity check expression",
            "        conditions.append(\"(sequence_no % %s) \" + expression)",
            "        substitutes.extend([divisor])",
            "",
            "    if conditions:",
            "        query += \" WHERE \" + ' AND '.join(conditions)",
            "",
            "    _log.debug(\"Query used: %s, substitutes: %s\", query, substitutes)",
            "",
            "    def generate():",
            "        cnx = mysql.connector.connect(user=DB_USER,",
            "                                      password=DB_PASSWORD,",
            "                                      host=DB_HOST,",
            "                                      database=DB_DBNAME,",
            "                                      port=DB_PORT)",
            "        cursor = cnx.cursor()",
            "        cursor.execute(query, substitutes)",
            "",
            "        yield '<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n'",
            "        if STYLE:",
            "            yield '<?xml-stylesheet type=\"text/xsl\" href=\"/scopelist.xsl\" ?>\\n'",
            "",
            "        yield '<objectlist>\\n'",
            "        for seq_no, rel_path, download_link in cursor:",
            "            yield '<count adjust=\"1\"/>\\n'",
            "            yield _get_object_element(dataset, seq_no, rel_path,",
            "                                      download_link) + '\\n'",
            "",
            "        yield '</objectlist>\\n'",
            "",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "",
            "    return Response(stream_with_context(generate()),",
            "                    status=\"200 OK\",",
            "                    headers=headers)",
            "",
            "@scope_blueprint.route('/id/<dataset>/<int:seq_no>')",
            "def get_object_id(dataset, seq_no):",
            "    headers = Headers([('Content-Type', 'text/xml')])",
            "    return Response(_get_object_element(dataset, seq_no, None, None),",
            "                    \"200 OK\",",
            "                    headers=headers)",
            "",
            "@scope_blueprint.route('/obj/<dataset>/<path:rel_path>')",
            "def get_object_src_http(dataset, rel_path):",
            "    path = _get_obj_absolute_path(dataset, rel_path)",
            "    response = send_file(path,",
            "                         cache_timeout=datetime.timedelta(",
            "                             days=365).total_seconds(),",
            "                         add_etags=True,",
            "                         conditional=True)",
            "    return response",
            "",
            "",
            "def _get_obj_absolute_path(dataset, rel_path):",
            "    return safe_join(DATAROOT, dataset, rel_path)",
            "",
            "",
            "def _get_object_element(dataset, seq_no, rel_path, download_link):",
            "    \"\"\"If rel_path and download_link are not None, we are called from scope.",
            "    Otherwise we are called from ID and need to run SQL query to fetch these attrs.\"\"\"",
            "",
            "    if rel_path is None:",
            "        query = \"SELECT rel_path, download_link FROM \" + \\",
            "        dataset + \\",
            "        \" WHERE sequence_no = %s\"",
            "",
            "        cnx = mysql.connector.connect(user=DB_USER,",
            "                                    password=DB_PASSWORD,",
            "                                    host=DB_HOST,",
            "                                    database=DB_DBNAME,",
            "                                    port=DB_PORT)",
            "        cursor = cnx.cursor()",
            "        cursor.execute(query, (seq_no,))",
            "",
            "        row = cursor.fetchone()",
            "",
            "        if not row:",
            "            return None",
            "",
            "        rel_path, download_link = row[0], row[1]",
            "",
            "    if LOCAL_OBJ_URI:",
            "        src_uri = 'file://' + _get_obj_absolute_path(dataset, rel_path)",
            "    else:",
            "        src_uri = url_for('.get_object_src_http', dataset=dataset, rel_path=rel_path)",
            "",
            "    return '<object id={} src={} hyperfind.external-link={} />' \\",
            "        .format(",
            "        quoteattr(url_for('.get_object_id', dataset=dataset, seq_no=seq_no)),",
            "        quoteattr(src_uri),",
            "        quoteattr(download_link))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "127": [
                "get_object_src_http"
            ],
            "136": [
                "_get_obj_abosolute_path"
            ],
            "137": [
                "_get_obj_abosolute_path"
            ],
            "165": [
                "_get_object_element"
            ]
        },
        "addLocation": []
    }
}