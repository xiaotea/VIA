{
    "glance/store/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     'glance.store.vmware_datastore.Store'"
            },
            "1": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " ]"
            },
            "2": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+RESTRICTED_URI_SCHEMAS = frozenset(['file', 'filesystem', 'swift+config'])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " class BackendException(Exception):"
            },
            "7": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     pass"
            },
            "8": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "     :param uri: The URI of external image location."
            },
            "9": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "     :return: Whether given URI of external image location are OK."
            },
            "10": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "     \"\"\""
            },
            "11": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pieces = urlparse.urlparse(uri)"
            },
            "12": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    valid_schemes = [scheme for scheme in get_known_schemes()"
            },
            "13": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     if scheme != 'file' and scheme != 'swift+config']"
            },
            "14": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return pieces.scheme in valid_schemes"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+    # TODO(gm): Use a whitelist of allowed schemes"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+    scheme = urlparse.urlparse(uri).scheme"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+    return (scheme in get_known_schemes() and"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+            scheme not in RESTRICTED_URI_SCHEMAS)"
            },
            "20": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 444,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 445,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 446,
                "PatchRowcode": " class ImageRepoProxy(glance.domain.proxy.Repo):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import sys",
            "",
            "from oslo.config import cfg",
            "import six",
            "import six.moves.urllib.parse as urlparse",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.context",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "import glance.openstack.common.log as logging",
            "from glance import scrubber",
            "from glance.store import location",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "store_opts = [",
            "    cfg.ListOpt('known_stores',",
            "                default=[",
            "                    'glance.store.filesystem.Store',",
            "                    'glance.store.http.Store'",
            "                ],",
            "                help=_('List of which store classes and store class locations '",
            "                       'are currently known to glance at startup.')),",
            "    cfg.StrOpt('default_store', default='file',",
            "               help=_(\"Default scheme to use to store image data. The \"",
            "                      \"scheme must be registered by one of the stores \"",
            "                      \"defined by the 'known_stores' config option.\")),",
            "    cfg.StrOpt('scrubber_datadir',",
            "               default='/var/lib/glance/scrubber',",
            "               help=_('Directory that the scrubber will use to track '",
            "                      'information about what to delete. '",
            "                      'Make sure this is set in glance-api.conf and '",
            "                      'glance-scrubber.conf.')),",
            "    cfg.BoolOpt('delayed_delete', default=False,",
            "                help=_('Turn on/off delayed delete.')),",
            "    cfg.BoolOpt('use_user_token', default=True,",
            "                help=_('Whether to pass through the user token when '",
            "                       'making requests to the registry.')),",
            "    cfg.IntOpt('scrub_time', default=0,",
            "               help=_('The amount of time in seconds to delay before '",
            "                      'performing a delete.')),",
            "]",
            "",
            "REGISTERED_STORES = set()",
            "CONF = cfg.CONF",
            "CONF.register_opts(store_opts)",
            "",
            "_ALL_STORES = [",
            "    'glance.store.filesystem.Store',",
            "    'glance.store.http.Store',",
            "    'glance.store.rbd.Store',",
            "    'glance.store.s3.Store',",
            "    'glance.store.swift.Store',",
            "    'glance.store.sheepdog.Store',",
            "    'glance.store.cinder.Store',",
            "    'glance.store.gridfs.Store',",
            "    'glance.store.vmware_datastore.Store'",
            "]",
            "",
            "",
            "class BackendException(Exception):",
            "    pass",
            "",
            "",
            "class UnsupportedBackend(BackendException):",
            "    pass",
            "",
            "",
            "class Indexable(object):",
            "",
            "    \"\"\"",
            "    Wrapper that allows an iterator or filelike be treated as an indexable",
            "    data structure. This is required in the case where the return value from",
            "    Store.get() is passed to Store.add() when adding a Copy-From image to a",
            "    Store where the client library relies on eventlet GreenSockets, in which",
            "    case the data to be written is indexed over.",
            "    \"\"\"",
            "",
            "    def __init__(self, wrapped, size):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param wrappped: the wrapped iterator or filelike.",
            "        :param size: the size of data available",
            "        \"\"\"",
            "        self.wrapped = wrapped",
            "        self.size = int(size) if size else (wrapped.len",
            "                                            if hasattr(wrapped, 'len') else 0)",
            "        self.cursor = 0",
            "        self.chunk = None",
            "",
            "    def __iter__(self):",
            "        \"\"\"",
            "        Delegate iteration to the wrapped instance.",
            "        \"\"\"",
            "        for self.chunk in self.wrapped:",
            "            yield self.chunk",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"",
            "        Index into the next chunk (or previous chunk in the case where",
            "        the last data returned was not fully consumed).",
            "",
            "        :param i: a slice-to-the-end",
            "        \"\"\"",
            "        start = i.start if isinstance(i, slice) else i",
            "        if start < self.cursor:",
            "            return self.chunk[(start - self.cursor):]",
            "",
            "        self.chunk = self.another()",
            "        if self.chunk:",
            "            self.cursor += len(self.chunk)",
            "",
            "        return self.chunk",
            "",
            "    def another(self):",
            "        \"\"\"Implemented by subclasses to return the next element\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def getvalue(self):",
            "        \"\"\"",
            "        Return entire string value... used in testing",
            "        \"\"\"",
            "        return self.wrapped.getvalue()",
            "",
            "    def __len__(self):",
            "        \"\"\"",
            "        Length accessor.",
            "        \"\"\"",
            "        return self.size",
            "",
            "",
            "def _register_stores(store_classes):",
            "    \"\"\"",
            "    Given a set of store names, add them to a globally available set",
            "    of store names.",
            "    \"\"\"",
            "    for store_cls in store_classes:",
            "        REGISTERED_STORES.add(store_cls.__module__.split('.')[2])",
            "    # NOTE (spredzy): The actual class name is filesystem but in order",
            "    # to maintain backward compatibility we need to keep the 'file' store",
            "    # as a known store",
            "    if 'filesystem' in REGISTERED_STORES:",
            "        REGISTERED_STORES.add('file')",
            "",
            "",
            "def _get_store_class(store_entry):",
            "    store_cls = None",
            "    try:",
            "        LOG.debug(\"Attempting to import store %s\", store_entry)",
            "        store_cls = importutils.import_class(store_entry)",
            "    except exception.NotFound:",
            "        raise BackendException('Unable to load store. '",
            "                               'Could not find a class named %s.'",
            "                               % store_entry)",
            "    return store_cls",
            "",
            "",
            "def create_stores():",
            "    \"\"\"",
            "    Registers all store modules and all schemes",
            "    from the given config. Duplicates are not re-registered.",
            "    \"\"\"",
            "    store_count = 0",
            "    store_classes = set()",
            "    for store_entry in set(CONF.known_stores + _ALL_STORES):",
            "        store_entry = store_entry.strip()",
            "        if not store_entry:",
            "            continue",
            "        store_cls = _get_store_class(store_entry)",
            "        try:",
            "            store_instance = store_cls()",
            "        except exception.BadStoreConfiguration as e:",
            "            if store_entry in CONF.known_stores:",
            "                LOG.warn(_(\"%s Skipping store driver.\") % unicode(e))",
            "            continue",
            "        finally:",
            "            # NOTE(flaper87): To be removed in Juno",
            "            if store_entry not in CONF.known_stores:",
            "                LOG.deprecated(_(\"%s not found in `known_store`. \"",
            "                                 \"Stores need to be explicitly enabled in \"",
            "                                 \"the configuration file.\") % store_entry)",
            "",
            "        schemes = store_instance.get_schemes()",
            "        if not schemes:",
            "            raise BackendException('Unable to register store %s. '",
            "                                   'No schemes associated with it.'",
            "                                   % store_cls)",
            "        else:",
            "            if store_cls not in store_classes:",
            "                LOG.debug(\"Registering store %s with schemes %s\",",
            "                          store_cls, schemes)",
            "                store_classes.add(store_cls)",
            "                scheme_map = {}",
            "                for scheme in schemes:",
            "                    loc_cls = store_instance.get_store_location_class()",
            "                    scheme_map[scheme] = {",
            "                        'store_class': store_cls,",
            "                        'location_class': loc_cls,",
            "                    }",
            "                location.register_scheme_map(scheme_map)",
            "                store_count += 1",
            "            else:",
            "                LOG.debug(\"Store %s already registered\", store_cls)",
            "    _register_stores(store_classes)",
            "    return store_count",
            "",
            "",
            "def verify_default_store():",
            "    scheme = cfg.CONF.default_store",
            "    context = glance.context.RequestContext()",
            "    try:",
            "        get_store_from_scheme(context, scheme)",
            "    except exception.UnknownScheme:",
            "        msg = _(\"Store for scheme %s not found\") % scheme",
            "        raise RuntimeError(msg)",
            "",
            "",
            "def get_known_schemes():",
            "    \"\"\"Returns list of known schemes\"\"\"",
            "    return location.SCHEME_TO_CLS_MAP.keys()",
            "",
            "",
            "def get_known_stores():",
            "    \"\"\"Returns list of known stores\"\"\"",
            "    return list(REGISTERED_STORES)",
            "",
            "",
            "def get_store_from_scheme(context, scheme, loc=None):",
            "    \"\"\"",
            "    Given a scheme, return the appropriate store object",
            "    for handling that scheme.",
            "    \"\"\"",
            "    if scheme not in location.SCHEME_TO_CLS_MAP:",
            "        raise exception.UnknownScheme(scheme=scheme)",
            "    scheme_info = location.SCHEME_TO_CLS_MAP[scheme]",
            "    store = scheme_info['store_class'](context, loc)",
            "    return store",
            "",
            "",
            "def get_store_from_uri(context, uri, loc=None):",
            "    \"\"\"",
            "    Given a URI, return the store object that would handle",
            "    operations on the URI.",
            "",
            "    :param uri: URI to analyze",
            "    \"\"\"",
            "    scheme = uri[0:uri.find('/') - 1]",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    return store",
            "",
            "",
            "def get_from_backend(context, uri, **kwargs):",
            "    \"\"\"Yields chunks of data from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.get(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreGetNotSupported",
            "",
            "",
            "def get_size_from_backend(context, uri):",
            "    \"\"\"Retrieves image size from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    return store.get_size(loc)",
            "",
            "",
            "def delete_from_backend(context, uri, **kwargs):",
            "    \"\"\"Removes chunks of data from backend specified by uri\"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.delete(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreDeleteNotSupported",
            "",
            "",
            "def get_store_from_location(uri):",
            "    \"\"\"",
            "    Given a location (assumed to be a URL), attempt to determine",
            "    the store from the location.  We use here a simple guess that",
            "    the scheme of the parsed URL is the store...",
            "",
            "    :param uri: Location to check for the store",
            "    \"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    return loc.store_name",
            "",
            "",
            "def safe_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, delete an image from the store.\"\"\"",
            "    try:",
            "        return delete_from_backend(context, uri, **kwargs)",
            "    except exception.NotFound:",
            "        msg = _('Failed to delete image %s in store from URI')",
            "        LOG.warn(msg % image_id)",
            "    except exception.StoreDeleteNotSupported as e:",
            "        LOG.warn(six.text_type(e))",
            "    except UnsupportedBackend:",
            "        exc_type = sys.exc_info()[0].__name__",
            "        msg = (_('Failed to delete image %(image_id)s from store '",
            "                 '(%(error)s)') % {'image_id': image_id,",
            "                                   'error': exc_type})",
            "        LOG.error(msg)",
            "",
            "",
            "def schedule_delayed_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, schedule the deletion of an image location.\"\"\"",
            "    (file_queue, _db_queue) = scrubber.get_scrub_queues()",
            "    # NOTE(zhiyan): Defautly ask glance-api store using file based queue.",
            "    # In future we can change it using DB based queued instead,",
            "    # such as using image location's status to saving pending delete flag",
            "    # when that property be added.",
            "    if CONF.use_user_token is False:",
            "        context = None",
            "    file_queue.add_location(image_id, uri, user_context=context)",
            "",
            "",
            "def delete_image_from_backend(context, store_api, image_id, uri):",
            "    if CONF.delayed_delete:",
            "        store_api.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "    else:",
            "        store_api.safe_delete_from_backend(context, uri, image_id)",
            "",
            "",
            "def check_location_metadata(val, key=''):",
            "    if isinstance(val, dict):",
            "        for key in val:",
            "            check_location_metadata(val[key], key=key)",
            "    elif isinstance(val, list):",
            "        ndx = 0",
            "        for v in val:",
            "            check_location_metadata(v, key='%s[%d]' % (key, ndx))",
            "            ndx = ndx + 1",
            "    elif not isinstance(val, unicode):",
            "        raise BackendException(_(\"The image metadata key %(key)s has an \"",
            "                                 \"invalid type of %(val)s.  Only dict, list, \"",
            "                                 \"and unicode are supported.\") %",
            "                               {'key': key,",
            "                                'val': type(val)})",
            "",
            "",
            "def store_add_to_backend(image_id, data, size, store):",
            "    \"\"\"",
            "    A wrapper around a call to each stores add() method.  This gives glance",
            "    a common place to check the output",
            "",
            "    :param image_id:  The image add to which data is added",
            "    :param data: The data to be stored",
            "    :param size: The length of the data in bytes",
            "    :param store: The store to which the data is being added",
            "    :return: The url location of the file,",
            "             the size amount of data,",
            "             the checksum of the data",
            "             the storage systems metadata dictionary for the location",
            "    \"\"\"",
            "    (location, size, checksum, metadata) = store.add(image_id, data, size)",
            "    if metadata is not None:",
            "        if not isinstance(metadata, dict):",
            "            msg = (_(\"The storage driver %(store)s returned invalid metadata \"",
            "                     \"%(metadata)s. This must be a dictionary type\") %",
            "                   {'store': six.text_type(store),",
            "                    'metadata': six.text_type(metadata)})",
            "            LOG.error(msg)",
            "            raise BackendException(msg)",
            "        try:",
            "            check_location_metadata(metadata)",
            "        except BackendException as e:",
            "            e_msg = (_(\"A bad metadata structure was returned from the \"",
            "                       \"%(store)s storage driver: %(metadata)s.  %(error)s.\") %",
            "                     {'store': six.text_type(store),",
            "                      'metadata': six.text_type(metadata),",
            "                      'error': six.text_type(e)})",
            "            LOG.error(e_msg)",
            "            raise BackendException(e_msg)",
            "    return (location, size, checksum, metadata)",
            "",
            "",
            "def add_to_backend(context, scheme, image_id, data, size):",
            "    store = get_store_from_scheme(context, scheme)",
            "    try:",
            "        return store_add_to_backend(image_id, data, size, store)",
            "    except NotImplementedError:",
            "        raise exception.StoreAddNotSupported",
            "",
            "",
            "def set_acls(context, location_uri, public=False, read_tenants=[],",
            "             write_tenants=[]):",
            "    loc = location.get_location_from_uri(location_uri)",
            "    scheme = get_store_from_location(location_uri)",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    try:",
            "        store.set_acls(loc, public=public, read_tenants=read_tenants,",
            "                       write_tenants=write_tenants)",
            "    except NotImplementedError:",
            "        LOG.debug(_(\"Skipping store.set_acls... not implemented.\"))",
            "",
            "",
            "def validate_external_location(uri):",
            "    \"\"\"",
            "    Validate if URI of external location are supported.",
            "",
            "    Only over non-local store types are OK, i.e. S3, Swift,",
            "    HTTP. Note the absence of 'file://' for security reasons,",
            "    see LP bug #942118, 1400966, 'swift+config://' is also",
            "    absent for security reasons, see LP bug #1334196.",
            "",
            "    :param uri: The URI of external image location.",
            "    :return: Whether given URI of external image location are OK.",
            "    \"\"\"",
            "    pieces = urlparse.urlparse(uri)",
            "    valid_schemes = [scheme for scheme in get_known_schemes()",
            "                     if scheme != 'file' and scheme != 'swift+config']",
            "    return pieces.scheme in valid_schemes",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(self.context, location['url'], public,",
            "                                    read_tenants=member_ids)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, uri):",
            "    \"\"\"Check if an image location is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "",
            "    is_ok = True",
            "    try:",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = (store_api.validate_external_location(uri) and",
            "                 store_api.get_size_from_backend(context, uri) > 0)",
            "    except (exception.UnknownScheme, exception.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        reason = _('Invalid location')",
            "        raise exception.BadStoreUri(message=reason)",
            "",
            "",
            "def _check_image_location(context, store_api, location):",
            "    _check_location_uri(context, store_api, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = glance.store.get_size_from_backend(",
            "                context, location['url'])",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for l in locations:",
            "            _check_image_location(self.context, self.store_api, l)",
            "",
            "            if locations.count(l) > 1:",
            "                raise exception.DuplicateLocation(location=l['url'])",
            "",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "",
            "        if location in self.value:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "        except Exception:",
            "            self.value.insert(i, location)",
            "            raise",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        delete_image_from_backend(self.image_proxy.context,",
            "                                  self.image_proxy.store_api,",
            "                                  self.image_proxy.image.image_id,",
            "                                  location['url'])",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            raise exception.BadStoreUri(_('Invalid locations: %s') % value)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context, self.store_api,",
            "                                      location)",
            "",
            "                if value.count(location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            delete_image_from_backend(self.context, self.store_api,",
            "                                      self.image.image_id, value[0]['url'])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_api.delete_image_from_backend(self.context,",
            "                                                         self.store_api,",
            "                                                         self.image.image_id,",
            "                                                         location['url'])",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            self.context, CONF.default_store,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self):",
            "        if not self.image.locations:",
            "            raise exception.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(self.context,",
            "                                                             loc['url'])",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': six.text_type(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_('Glance tried all locations to get data for image %s '",
            "                    'but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(self.context, location['url'], public,",
            "                                        read_tenants=member_ids)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "afterPatchFile": [
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import copy",
            "import sys",
            "",
            "from oslo.config import cfg",
            "import six",
            "import six.moves.urllib.parse as urlparse",
            "",
            "from glance.common import exception",
            "from glance.common import utils",
            "import glance.context",
            "import glance.domain.proxy",
            "from glance.openstack.common import importutils",
            "import glance.openstack.common.log as logging",
            "from glance import scrubber",
            "from glance.store import location",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "store_opts = [",
            "    cfg.ListOpt('known_stores',",
            "                default=[",
            "                    'glance.store.filesystem.Store',",
            "                    'glance.store.http.Store'",
            "                ],",
            "                help=_('List of which store classes and store class locations '",
            "                       'are currently known to glance at startup.')),",
            "    cfg.StrOpt('default_store', default='file',",
            "               help=_(\"Default scheme to use to store image data. The \"",
            "                      \"scheme must be registered by one of the stores \"",
            "                      \"defined by the 'known_stores' config option.\")),",
            "    cfg.StrOpt('scrubber_datadir',",
            "               default='/var/lib/glance/scrubber',",
            "               help=_('Directory that the scrubber will use to track '",
            "                      'information about what to delete. '",
            "                      'Make sure this is set in glance-api.conf and '",
            "                      'glance-scrubber.conf.')),",
            "    cfg.BoolOpt('delayed_delete', default=False,",
            "                help=_('Turn on/off delayed delete.')),",
            "    cfg.BoolOpt('use_user_token', default=True,",
            "                help=_('Whether to pass through the user token when '",
            "                       'making requests to the registry.')),",
            "    cfg.IntOpt('scrub_time', default=0,",
            "               help=_('The amount of time in seconds to delay before '",
            "                      'performing a delete.')),",
            "]",
            "",
            "REGISTERED_STORES = set()",
            "CONF = cfg.CONF",
            "CONF.register_opts(store_opts)",
            "",
            "_ALL_STORES = [",
            "    'glance.store.filesystem.Store',",
            "    'glance.store.http.Store',",
            "    'glance.store.rbd.Store',",
            "    'glance.store.s3.Store',",
            "    'glance.store.swift.Store',",
            "    'glance.store.sheepdog.Store',",
            "    'glance.store.cinder.Store',",
            "    'glance.store.gridfs.Store',",
            "    'glance.store.vmware_datastore.Store'",
            "]",
            "",
            "RESTRICTED_URI_SCHEMAS = frozenset(['file', 'filesystem', 'swift+config'])",
            "",
            "",
            "class BackendException(Exception):",
            "    pass",
            "",
            "",
            "class UnsupportedBackend(BackendException):",
            "    pass",
            "",
            "",
            "class Indexable(object):",
            "",
            "    \"\"\"",
            "    Wrapper that allows an iterator or filelike be treated as an indexable",
            "    data structure. This is required in the case where the return value from",
            "    Store.get() is passed to Store.add() when adding a Copy-From image to a",
            "    Store where the client library relies on eventlet GreenSockets, in which",
            "    case the data to be written is indexed over.",
            "    \"\"\"",
            "",
            "    def __init__(self, wrapped, size):",
            "        \"\"\"",
            "        Initialize the object",
            "",
            "        :param wrappped: the wrapped iterator or filelike.",
            "        :param size: the size of data available",
            "        \"\"\"",
            "        self.wrapped = wrapped",
            "        self.size = int(size) if size else (wrapped.len",
            "                                            if hasattr(wrapped, 'len') else 0)",
            "        self.cursor = 0",
            "        self.chunk = None",
            "",
            "    def __iter__(self):",
            "        \"\"\"",
            "        Delegate iteration to the wrapped instance.",
            "        \"\"\"",
            "        for self.chunk in self.wrapped:",
            "            yield self.chunk",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"",
            "        Index into the next chunk (or previous chunk in the case where",
            "        the last data returned was not fully consumed).",
            "",
            "        :param i: a slice-to-the-end",
            "        \"\"\"",
            "        start = i.start if isinstance(i, slice) else i",
            "        if start < self.cursor:",
            "            return self.chunk[(start - self.cursor):]",
            "",
            "        self.chunk = self.another()",
            "        if self.chunk:",
            "            self.cursor += len(self.chunk)",
            "",
            "        return self.chunk",
            "",
            "    def another(self):",
            "        \"\"\"Implemented by subclasses to return the next element\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def getvalue(self):",
            "        \"\"\"",
            "        Return entire string value... used in testing",
            "        \"\"\"",
            "        return self.wrapped.getvalue()",
            "",
            "    def __len__(self):",
            "        \"\"\"",
            "        Length accessor.",
            "        \"\"\"",
            "        return self.size",
            "",
            "",
            "def _register_stores(store_classes):",
            "    \"\"\"",
            "    Given a set of store names, add them to a globally available set",
            "    of store names.",
            "    \"\"\"",
            "    for store_cls in store_classes:",
            "        REGISTERED_STORES.add(store_cls.__module__.split('.')[2])",
            "    # NOTE (spredzy): The actual class name is filesystem but in order",
            "    # to maintain backward compatibility we need to keep the 'file' store",
            "    # as a known store",
            "    if 'filesystem' in REGISTERED_STORES:",
            "        REGISTERED_STORES.add('file')",
            "",
            "",
            "def _get_store_class(store_entry):",
            "    store_cls = None",
            "    try:",
            "        LOG.debug(\"Attempting to import store %s\", store_entry)",
            "        store_cls = importutils.import_class(store_entry)",
            "    except exception.NotFound:",
            "        raise BackendException('Unable to load store. '",
            "                               'Could not find a class named %s.'",
            "                               % store_entry)",
            "    return store_cls",
            "",
            "",
            "def create_stores():",
            "    \"\"\"",
            "    Registers all store modules and all schemes",
            "    from the given config. Duplicates are not re-registered.",
            "    \"\"\"",
            "    store_count = 0",
            "    store_classes = set()",
            "    for store_entry in set(CONF.known_stores + _ALL_STORES):",
            "        store_entry = store_entry.strip()",
            "        if not store_entry:",
            "            continue",
            "        store_cls = _get_store_class(store_entry)",
            "        try:",
            "            store_instance = store_cls()",
            "        except exception.BadStoreConfiguration as e:",
            "            if store_entry in CONF.known_stores:",
            "                LOG.warn(_(\"%s Skipping store driver.\") % unicode(e))",
            "            continue",
            "        finally:",
            "            # NOTE(flaper87): To be removed in Juno",
            "            if store_entry not in CONF.known_stores:",
            "                LOG.deprecated(_(\"%s not found in `known_store`. \"",
            "                                 \"Stores need to be explicitly enabled in \"",
            "                                 \"the configuration file.\") % store_entry)",
            "",
            "        schemes = store_instance.get_schemes()",
            "        if not schemes:",
            "            raise BackendException('Unable to register store %s. '",
            "                                   'No schemes associated with it.'",
            "                                   % store_cls)",
            "        else:",
            "            if store_cls not in store_classes:",
            "                LOG.debug(\"Registering store %s with schemes %s\",",
            "                          store_cls, schemes)",
            "                store_classes.add(store_cls)",
            "                scheme_map = {}",
            "                for scheme in schemes:",
            "                    loc_cls = store_instance.get_store_location_class()",
            "                    scheme_map[scheme] = {",
            "                        'store_class': store_cls,",
            "                        'location_class': loc_cls,",
            "                    }",
            "                location.register_scheme_map(scheme_map)",
            "                store_count += 1",
            "            else:",
            "                LOG.debug(\"Store %s already registered\", store_cls)",
            "    _register_stores(store_classes)",
            "    return store_count",
            "",
            "",
            "def verify_default_store():",
            "    scheme = cfg.CONF.default_store",
            "    context = glance.context.RequestContext()",
            "    try:",
            "        get_store_from_scheme(context, scheme)",
            "    except exception.UnknownScheme:",
            "        msg = _(\"Store for scheme %s not found\") % scheme",
            "        raise RuntimeError(msg)",
            "",
            "",
            "def get_known_schemes():",
            "    \"\"\"Returns list of known schemes\"\"\"",
            "    return location.SCHEME_TO_CLS_MAP.keys()",
            "",
            "",
            "def get_known_stores():",
            "    \"\"\"Returns list of known stores\"\"\"",
            "    return list(REGISTERED_STORES)",
            "",
            "",
            "def get_store_from_scheme(context, scheme, loc=None):",
            "    \"\"\"",
            "    Given a scheme, return the appropriate store object",
            "    for handling that scheme.",
            "    \"\"\"",
            "    if scheme not in location.SCHEME_TO_CLS_MAP:",
            "        raise exception.UnknownScheme(scheme=scheme)",
            "    scheme_info = location.SCHEME_TO_CLS_MAP[scheme]",
            "    store = scheme_info['store_class'](context, loc)",
            "    return store",
            "",
            "",
            "def get_store_from_uri(context, uri, loc=None):",
            "    \"\"\"",
            "    Given a URI, return the store object that would handle",
            "    operations on the URI.",
            "",
            "    :param uri: URI to analyze",
            "    \"\"\"",
            "    scheme = uri[0:uri.find('/') - 1]",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    return store",
            "",
            "",
            "def get_from_backend(context, uri, **kwargs):",
            "    \"\"\"Yields chunks of data from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.get(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreGetNotSupported",
            "",
            "",
            "def get_size_from_backend(context, uri):",
            "    \"\"\"Retrieves image size from backend specified by uri\"\"\"",
            "",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    return store.get_size(loc)",
            "",
            "",
            "def delete_from_backend(context, uri, **kwargs):",
            "    \"\"\"Removes chunks of data from backend specified by uri\"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    store = get_store_from_uri(context, uri, loc)",
            "",
            "    try:",
            "        return store.delete(loc)",
            "    except NotImplementedError:",
            "        raise exception.StoreDeleteNotSupported",
            "",
            "",
            "def get_store_from_location(uri):",
            "    \"\"\"",
            "    Given a location (assumed to be a URL), attempt to determine",
            "    the store from the location.  We use here a simple guess that",
            "    the scheme of the parsed URL is the store...",
            "",
            "    :param uri: Location to check for the store",
            "    \"\"\"",
            "    loc = location.get_location_from_uri(uri)",
            "    return loc.store_name",
            "",
            "",
            "def safe_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, delete an image from the store.\"\"\"",
            "    try:",
            "        return delete_from_backend(context, uri, **kwargs)",
            "    except exception.NotFound:",
            "        msg = _('Failed to delete image %s in store from URI')",
            "        LOG.warn(msg % image_id)",
            "    except exception.StoreDeleteNotSupported as e:",
            "        LOG.warn(six.text_type(e))",
            "    except UnsupportedBackend:",
            "        exc_type = sys.exc_info()[0].__name__",
            "        msg = (_('Failed to delete image %(image_id)s from store '",
            "                 '(%(error)s)') % {'image_id': image_id,",
            "                                   'error': exc_type})",
            "        LOG.error(msg)",
            "",
            "",
            "def schedule_delayed_delete_from_backend(context, uri, image_id, **kwargs):",
            "    \"\"\"Given a uri, schedule the deletion of an image location.\"\"\"",
            "    (file_queue, _db_queue) = scrubber.get_scrub_queues()",
            "    # NOTE(zhiyan): Defautly ask glance-api store using file based queue.",
            "    # In future we can change it using DB based queued instead,",
            "    # such as using image location's status to saving pending delete flag",
            "    # when that property be added.",
            "    if CONF.use_user_token is False:",
            "        context = None",
            "    file_queue.add_location(image_id, uri, user_context=context)",
            "",
            "",
            "def delete_image_from_backend(context, store_api, image_id, uri):",
            "    if CONF.delayed_delete:",
            "        store_api.schedule_delayed_delete_from_backend(context, uri, image_id)",
            "    else:",
            "        store_api.safe_delete_from_backend(context, uri, image_id)",
            "",
            "",
            "def check_location_metadata(val, key=''):",
            "    if isinstance(val, dict):",
            "        for key in val:",
            "            check_location_metadata(val[key], key=key)",
            "    elif isinstance(val, list):",
            "        ndx = 0",
            "        for v in val:",
            "            check_location_metadata(v, key='%s[%d]' % (key, ndx))",
            "            ndx = ndx + 1",
            "    elif not isinstance(val, unicode):",
            "        raise BackendException(_(\"The image metadata key %(key)s has an \"",
            "                                 \"invalid type of %(val)s.  Only dict, list, \"",
            "                                 \"and unicode are supported.\") %",
            "                               {'key': key,",
            "                                'val': type(val)})",
            "",
            "",
            "def store_add_to_backend(image_id, data, size, store):",
            "    \"\"\"",
            "    A wrapper around a call to each stores add() method.  This gives glance",
            "    a common place to check the output",
            "",
            "    :param image_id:  The image add to which data is added",
            "    :param data: The data to be stored",
            "    :param size: The length of the data in bytes",
            "    :param store: The store to which the data is being added",
            "    :return: The url location of the file,",
            "             the size amount of data,",
            "             the checksum of the data",
            "             the storage systems metadata dictionary for the location",
            "    \"\"\"",
            "    (location, size, checksum, metadata) = store.add(image_id, data, size)",
            "    if metadata is not None:",
            "        if not isinstance(metadata, dict):",
            "            msg = (_(\"The storage driver %(store)s returned invalid metadata \"",
            "                     \"%(metadata)s. This must be a dictionary type\") %",
            "                   {'store': six.text_type(store),",
            "                    'metadata': six.text_type(metadata)})",
            "            LOG.error(msg)",
            "            raise BackendException(msg)",
            "        try:",
            "            check_location_metadata(metadata)",
            "        except BackendException as e:",
            "            e_msg = (_(\"A bad metadata structure was returned from the \"",
            "                       \"%(store)s storage driver: %(metadata)s.  %(error)s.\") %",
            "                     {'store': six.text_type(store),",
            "                      'metadata': six.text_type(metadata),",
            "                      'error': six.text_type(e)})",
            "            LOG.error(e_msg)",
            "            raise BackendException(e_msg)",
            "    return (location, size, checksum, metadata)",
            "",
            "",
            "def add_to_backend(context, scheme, image_id, data, size):",
            "    store = get_store_from_scheme(context, scheme)",
            "    try:",
            "        return store_add_to_backend(image_id, data, size, store)",
            "    except NotImplementedError:",
            "        raise exception.StoreAddNotSupported",
            "",
            "",
            "def set_acls(context, location_uri, public=False, read_tenants=[],",
            "             write_tenants=[]):",
            "    loc = location.get_location_from_uri(location_uri)",
            "    scheme = get_store_from_location(location_uri)",
            "    store = get_store_from_scheme(context, scheme, loc)",
            "    try:",
            "        store.set_acls(loc, public=public, read_tenants=read_tenants,",
            "                       write_tenants=write_tenants)",
            "    except NotImplementedError:",
            "        LOG.debug(_(\"Skipping store.set_acls... not implemented.\"))",
            "",
            "",
            "def validate_external_location(uri):",
            "    \"\"\"",
            "    Validate if URI of external location are supported.",
            "",
            "    Only over non-local store types are OK, i.e. S3, Swift,",
            "    HTTP. Note the absence of 'file://' for security reasons,",
            "    see LP bug #942118, 1400966, 'swift+config://' is also",
            "    absent for security reasons, see LP bug #1334196.",
            "",
            "    :param uri: The URI of external image location.",
            "    :return: Whether given URI of external image location are OK.",
            "    \"\"\"",
            "",
            "    # TODO(gm): Use a whitelist of allowed schemes",
            "    scheme = urlparse.urlparse(uri).scheme",
            "    return (scheme in get_known_schemes() and",
            "            scheme not in RESTRICTED_URI_SCHEMAS)",
            "",
            "",
            "class ImageRepoProxy(glance.domain.proxy.Repo):",
            "",
            "    def __init__(self, image_repo, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageRepoProxy, self).__init__(image_repo,",
            "                                             item_proxy_class=ImageProxy,",
            "                                             item_proxy_kwargs=proxy_kwargs)",
            "",
            "    def _set_acls(self, image):",
            "        public = image.visibility == 'public'",
            "        member_ids = []",
            "        if image.locations and not public:",
            "            member_repo = image.get_member_repo()",
            "            member_ids = [m.member_id for m in member_repo.list()]",
            "        for location in image.locations:",
            "            self.store_api.set_acls(self.context, location['url'], public,",
            "                                    read_tenants=member_ids)",
            "",
            "    def add(self, image):",
            "        result = super(ImageRepoProxy, self).add(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "    def save(self, image):",
            "        result = super(ImageRepoProxy, self).save(image)",
            "        self._set_acls(image)",
            "        return result",
            "",
            "",
            "def _check_location_uri(context, store_api, uri):",
            "    \"\"\"Check if an image location is valid.",
            "",
            "    :param context: Glance request context",
            "    :param store_api: store API module",
            "    :param uri: location's uri string",
            "    \"\"\"",
            "",
            "    is_ok = True",
            "    try:",
            "        # NOTE(zhiyan): Some stores return zero when it catch exception",
            "        is_ok = (store_api.validate_external_location(uri) and",
            "                 store_api.get_size_from_backend(context, uri) > 0)",
            "    except (exception.UnknownScheme, exception.NotFound):",
            "        is_ok = False",
            "    if not is_ok:",
            "        reason = _('Invalid location')",
            "        raise exception.BadStoreUri(message=reason)",
            "",
            "",
            "def _check_image_location(context, store_api, location):",
            "    _check_location_uri(context, store_api, location['url'])",
            "    store_api.check_location_metadata(location['metadata'])",
            "",
            "",
            "def _set_image_size(context, image, locations):",
            "    if not image.size:",
            "        for location in locations:",
            "            size_from_backend = glance.store.get_size_from_backend(",
            "                context, location['url'])",
            "            if size_from_backend:",
            "                # NOTE(flwang): This assumes all locations have the same size",
            "                image.size = size_from_backend",
            "                break",
            "",
            "",
            "class ImageFactoryProxy(glance.domain.proxy.ImageFactory):",
            "    def __init__(self, factory, context, store_api):",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {'context': context, 'store_api': store_api}",
            "        super(ImageFactoryProxy, self).__init__(factory,",
            "                                                proxy_class=ImageProxy,",
            "                                                proxy_kwargs=proxy_kwargs)",
            "",
            "    def new_image(self, **kwargs):",
            "        locations = kwargs.get('locations', [])",
            "        for l in locations:",
            "            _check_image_location(self.context, self.store_api, l)",
            "",
            "            if locations.count(l) > 1:",
            "                raise exception.DuplicateLocation(location=l['url'])",
            "",
            "        return super(ImageFactoryProxy, self).new_image(**kwargs)",
            "",
            "",
            "class StoreLocations(collections.MutableSequence):",
            "    \"\"\"",
            "    The proxy for store location property. It takes responsibility for:",
            "    1. Location uri correctness checking when adding a new location.",
            "    2. Remove the image data from the store when a location is removed",
            "       from an image.",
            "    \"\"\"",
            "    def __init__(self, image_proxy, value):",
            "        self.image_proxy = image_proxy",
            "        if isinstance(value, list):",
            "            self.value = value",
            "        else:",
            "            self.value = list(value)",
            "",
            "    def append(self, location):",
            "        # NOTE(flaper87): Insert this",
            "        # location at the very end of",
            "        # the value list.",
            "        self.insert(len(self.value), location)",
            "",
            "    def extend(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            locations = other.value",
            "        else:",
            "            locations = list(other)",
            "",
            "        for location in locations:",
            "            self.append(location)",
            "",
            "    def insert(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "",
            "        if location in self.value:",
            "            raise exception.DuplicateLocation(location=location['url'])",
            "",
            "        self.value.insert(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def pop(self, i=-1):",
            "        location = self.value.pop(i)",
            "        try:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "        except Exception:",
            "            self.value.insert(i, location)",
            "            raise",
            "        return location",
            "",
            "    def count(self, location):",
            "        return self.value.count(location)",
            "",
            "    def index(self, location, *args):",
            "        return self.value.index(location, *args)",
            "",
            "    def remove(self, location):",
            "        if self.count(location):",
            "            self.pop(self.index(location))",
            "        else:",
            "            self.value.remove(location)",
            "",
            "    def reverse(self):",
            "        self.value.reverse()",
            "",
            "    # Mutable sequence, so not hashable",
            "    __hash__ = None",
            "",
            "    def __getitem__(self, i):",
            "        return self.value.__getitem__(i)",
            "",
            "    def __setitem__(self, i, location):",
            "        _check_image_location(self.image_proxy.context,",
            "                              self.image_proxy.store_api, location)",
            "        self.value.__setitem__(i, location)",
            "        _set_image_size(self.image_proxy.context,",
            "                        self.image_proxy,",
            "                        [location])",
            "",
            "    def __delitem__(self, i):",
            "        location = None",
            "        try:",
            "            location = self.value.__getitem__(i)",
            "        except Exception:",
            "            return self.value.__delitem__(i)",
            "        delete_image_from_backend(self.image_proxy.context,",
            "                                  self.image_proxy.store_api,",
            "                                  self.image_proxy.image.image_id,",
            "                                  location['url'])",
            "        self.value.__delitem__(i)",
            "",
            "    def __delslice__(self, i, j):",
            "        i = max(i, 0)",
            "        j = max(j, 0)",
            "        locations = []",
            "        try:",
            "            locations = self.value.__getslice__(i, j)",
            "        except Exception:",
            "            return self.value.__delslice__(i, j)",
            "        for location in locations:",
            "            delete_image_from_backend(self.image_proxy.context,",
            "                                      self.image_proxy.store_api,",
            "                                      self.image_proxy.image.image_id,",
            "                                      location['url'])",
            "            self.value.__delitem__(i)",
            "",
            "    def __iadd__(self, other):",
            "        self.extend(other)",
            "        return self",
            "",
            "    def __contains__(self, location):",
            "        return location in self.value",
            "",
            "    def __len__(self):",
            "        return len(self.value)",
            "",
            "    def __cast(self, other):",
            "        if isinstance(other, StoreLocations):",
            "            return other.value",
            "        else:",
            "            return other",
            "",
            "    def __cmp__(self, other):",
            "        return cmp(self.value, self.__cast(other))",
            "",
            "    def __iter__(self):",
            "        return iter(self.value)",
            "",
            "    def __copy__(self):",
            "        return type(self)(self.image_proxy, self.value)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # NOTE(zhiyan): Only copy location entries, others can be reused.",
            "        value = copy.deepcopy(self.value, memo)",
            "        self.image_proxy.image.locations = value",
            "        return type(self)(self.image_proxy, value)",
            "",
            "",
            "def _locations_proxy(target, attr):",
            "    \"\"\"",
            "    Make a location property proxy on the image object.",
            "",
            "    :param target: the image object on which to add the proxy",
            "    :param attr: the property proxy we want to hook",
            "    \"\"\"",
            "    def get_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        return StoreLocations(self, value)",
            "",
            "    def set_attr(self, value):",
            "        if not isinstance(value, (list, StoreLocations)):",
            "            raise exception.BadStoreUri(_('Invalid locations: %s') % value)",
            "        ori_value = getattr(getattr(self, target), attr)",
            "        if ori_value != value:",
            "            # NOTE(zhiyan): Enforced locations list was previously empty list.",
            "            if len(ori_value) > 0:",
            "                raise exception.Invalid(_('Original locations is not empty: '",
            "                                          '%s') % ori_value)",
            "            # NOTE(zhiyan): Check locations are all valid.",
            "            for location in value:",
            "                _check_image_location(self.context, self.store_api,",
            "                                      location)",
            "",
            "                if value.count(location) > 1:",
            "                    raise exception.DuplicateLocation(location=location['url'])",
            "            _set_image_size(self.context, getattr(self, target), value)",
            "            return setattr(getattr(self, target), attr, list(value))",
            "",
            "    def del_attr(self):",
            "        value = getattr(getattr(self, target), attr)",
            "        while len(value):",
            "            delete_image_from_backend(self.context, self.store_api,",
            "                                      self.image.image_id, value[0]['url'])",
            "            del value[0]",
            "            setattr(getattr(self, target), attr, value)",
            "        return delattr(getattr(self, target), attr)",
            "",
            "    return property(get_attr, set_attr, del_attr)",
            "",
            "",
            "class ImageProxy(glance.domain.proxy.Image):",
            "",
            "    locations = _locations_proxy('image', 'locations')",
            "",
            "    def __init__(self, image, context, store_api):",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        proxy_kwargs = {",
            "            'context': context,",
            "            'image': self,",
            "            'store_api': store_api,",
            "        }",
            "        super(ImageProxy, self).__init__(",
            "            image, member_repo_proxy_class=ImageMemberRepoProxy,",
            "            member_repo_proxy_kwargs=proxy_kwargs)",
            "",
            "    def delete(self):",
            "        self.image.delete()",
            "        if self.image.locations:",
            "            for location in self.image.locations:",
            "                self.store_api.delete_image_from_backend(self.context,",
            "                                                         self.store_api,",
            "                                                         self.image.image_id,",
            "                                                         location['url'])",
            "",
            "    def set_data(self, data, size=None):",
            "        if size is None:",
            "            size = 0  # NOTE(markwash): zero -> unknown size",
            "        location, size, checksum, loc_meta = self.store_api.add_to_backend(",
            "            self.context, CONF.default_store,",
            "            self.image.image_id,",
            "            utils.LimitingReader(utils.CooperativeReader(data),",
            "                                 CONF.image_size_cap),",
            "            size)",
            "        self.image.locations = [{'url': location, 'metadata': loc_meta}]",
            "        self.image.size = size",
            "        self.image.checksum = checksum",
            "        self.image.status = 'active'",
            "",
            "    def get_data(self):",
            "        if not self.image.locations:",
            "            raise exception.NotFound(_(\"No image data could be found\"))",
            "        err = None",
            "        for loc in self.image.locations:",
            "            try:",
            "                data, size = self.store_api.get_from_backend(self.context,",
            "                                                             loc['url'])",
            "",
            "                return data",
            "            except Exception as e:",
            "                LOG.warn(_('Get image %(id)s data failed: '",
            "                           '%(err)s.') % {'id': self.image.image_id,",
            "                                          'err': six.text_type(e)})",
            "                err = e",
            "        # tried all locations",
            "        LOG.error(_('Glance tried all locations to get data for image %s '",
            "                    'but all have failed.') % self.image.image_id)",
            "        raise err",
            "",
            "",
            "class ImageMemberRepoProxy(glance.domain.proxy.Repo):",
            "    def __init__(self, repo, image, context, store_api):",
            "        self.repo = repo",
            "        self.image = image",
            "        self.context = context",
            "        self.store_api = store_api",
            "        super(ImageMemberRepoProxy, self).__init__(repo)",
            "",
            "    def _set_acls(self):",
            "        public = self.image.visibility == 'public'",
            "        if self.image.locations and not public:",
            "            member_ids = [m.member_id for m in self.repo.list()]",
            "            for location in self.image.locations:",
            "                self.store_api.set_acls(self.context, location['url'], public,",
            "                                        read_tenants=member_ids)",
            "",
            "    def add(self, member):",
            "        super(ImageMemberRepoProxy, self).add(member)",
            "        self._set_acls()",
            "",
            "    def remove(self, member):",
            "        super(ImageMemberRepoProxy, self).remove(member)",
            "        self._set_acls()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "437": [
                "validate_external_location"
            ],
            "438": [
                "validate_external_location"
            ],
            "439": [
                "validate_external_location"
            ],
            "440": [
                "validate_external_location"
            ]
        },
        "addLocation": []
    },
    "glance/tests/unit/test_store_location.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 524,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 525,
                "PatchRowcode": "         loc1 = {'url': 'file:///fake1.img.tar.gz', 'metadata': {}}"
            },
            "2": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": 526,
                "PatchRowcode": "         loc2 = {'url': 'swift+config:///xxx', 'metadata': {}}"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+        loc3 = {'url': 'filesystem:///foo.img.tar.gz', 'metadata': {}}"
            },
            "4": {
                "beforePatchRowNumber": 527,
                "afterPatchRowNumber": 528,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 528,
                "afterPatchRowNumber": 529,
                "PatchRowcode": "         # Test for insert location"
            },
            "6": {
                "beforePatchRowNumber": 529,
                "afterPatchRowNumber": 530,
                "PatchRowcode": "         image1 = TestStoreLocation.FakeImageProxy(utils.FakeStoreAPI())"
            },
            "7": {
                "beforePatchRowNumber": 530,
                "afterPatchRowNumber": 531,
                "PatchRowcode": "         locations = glance.store.StoreLocations(image1, [])"
            },
            "8": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 532,
                "PatchRowcode": "         self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc1)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 533,
                "PatchRowcode": "+        self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc3)"
            },
            "10": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": 534,
                "PatchRowcode": "         self.assertNotIn(loc1, locations)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 535,
                "PatchRowcode": "+        self.assertNotIn(loc3, locations)"
            },
            "12": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": 536,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": 537,
                "PatchRowcode": "         # Test for set_attr of _locations_proxy"
            },
            "14": {
                "beforePatchRowNumber": 535,
                "afterPatchRowNumber": 538,
                "PatchRowcode": "         image2 = TestStoreLocation.FakeImageProxy(utils.FakeStoreAPI())"
            }
        },
        "frontPatchFile": [
            "# Copyright 2011-2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import mock",
            "",
            "from glance.common import exception",
            "from glance import context",
            "import glance.store",
            "import glance.store.filesystem",
            "import glance.store.http",
            "import glance.store.location as location",
            "import glance.store.s3",
            "import glance.store.swift",
            "import glance.store.vmware_datastore",
            "from glance.tests.unit import base",
            "from glance.tests.unit import utils",
            "",
            "",
            "class TestStoreLocation(base.StoreClearingUnitTest):",
            "",
            "    def setUp(self):",
            "        self.config(default_store='file')",
            "",
            "        # NOTE(flaper87): Each store should test",
            "        # this in their test suite.",
            "        self.config(known_stores=[",
            "            \"glance.store.filesystem.Store\",",
            "            \"glance.store.http.Store\",",
            "            \"glance.store.rbd.Store\",",
            "            \"glance.store.s3.Store\",",
            "            \"glance.store.swift.Store\",",
            "            \"glance.store.sheepdog.Store\",",
            "            \"glance.store.cinder.Store\",",
            "            \"glance.store.gridfs.Store\",",
            "            \"glance.store.vmware_datastore.Store\",",
            "        ])",
            "        super(TestStoreLocation, self).setUp()",
            "",
            "    def test_get_location_from_uri_back_to_uri(self):",
            "        \"\"\"",
            "        Test that for various URIs, the correct Location",
            "        object can be contructed and then the original URI",
            "        returned via the get_store_uri() method.",
            "        \"\"\"",
            "        good_store_uris = [",
            "            'https://user:pass@example.com:80/images/some-id',",
            "            'http://images.oracle.com/123456',",
            "            'swift://account%3Auser:pass@authurl.com/container/obj-id',",
            "            'swift://storeurl.com/container/obj-id',",
            "            'swift+https://account%3Auser:pass@authurl.com/container/obj-id',",
            "            's3://accesskey:secretkey@s3.amazonaws.com/bucket/key-id',",
            "            's3://accesskey:secretwith/aslash@s3.amazonaws.com/bucket/key-id',",
            "            's3+http://accesskey:secret@s3.amazonaws.com/bucket/key-id',",
            "            's3+https://accesskey:secretkey@s3.amazonaws.com/bucket/key-id',",
            "            'file:///var/lib/glance/images/1',",
            "            'rbd://imagename',",
            "            'rbd://fsid/pool/image/snap',",
            "            'rbd://%2F/%2F/%2F/%2F',",
            "            'sheepdog://244e75f1-9c69-4167-9db7-1aa7d1973f6c',",
            "            'cinder://12345678-9012-3455-6789-012345678901',",
            "            'vsphere://ip/folder/openstack_glance/2332298?dcPath=dc&dsName=ds',",
            "        ]",
            "",
            "        for uri in good_store_uris:",
            "            loc = location.get_location_from_uri(uri)",
            "            # The get_store_uri() method *should* return an identical URI",
            "            # to the URI that is passed to get_location_from_uri()",
            "            self.assertEqual(loc.get_store_uri(), uri)",
            "",
            "    def test_bad_store_scheme(self):",
            "        \"\"\"",
            "        Test that a URI with a non-existing scheme triggers exception",
            "        \"\"\"",
            "        bad_uri = 'unknown://user:pass@example.com:80/images/some-id'",
            "",
            "        self.assertRaises(exception.UnknownScheme,",
            "                          location.get_location_from_uri,",
            "                          bad_uri)",
            "",
            "    def test_filesystem_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Filesystem store",
            "        \"\"\"",
            "        uri = 'file:///var/lib/glance/images/1'",
            "        loc = glance.store.filesystem.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"file\", loc.scheme)",
            "        self.assertEqual(\"/var/lib/glance/images/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'fil://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'file://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_http_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the HTTP store",
            "        \"\"\"",
            "        uri = 'http://example.com/images/1'",
            "        loc = glance.store.http.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"http\", loc.scheme)",
            "        self.assertEqual(\"example.com\", loc.netloc)",
            "        self.assertEqual(\"/images/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'https://example.com:8080/images/container/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"https\", loc.scheme)",
            "        self.assertEqual(\"example.com:8080\", loc.netloc)",
            "        self.assertEqual(\"/images/container/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'https://user:password@example.com:8080/images/container/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"https\", loc.scheme)",
            "        self.assertEqual(\"example.com:8080\", loc.netloc)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"password\", loc.password)",
            "        self.assertEqual(\"/images/container/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'https://user:@example.com:8080/images/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"https\", loc.scheme)",
            "        self.assertEqual(\"example.com:8080\", loc.netloc)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"\", loc.password)",
            "        self.assertEqual(\"/images/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'htt://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://user@example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_swift_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Swift store",
            "        \"\"\"",
            "        uri = 'swift://example.com/images/1'",
            "        loc = glance.store.swift.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift\", loc.scheme)",
            "        self.assertEqual(\"example.com\", loc.auth_or_store_url)",
            "        self.assertEqual(\"https://example.com\", loc.swift_url)",
            "        self.assertEqual(\"images\", loc.container)",
            "        self.assertEqual(\"1\", loc.obj)",
            "        self.assertIsNone(loc.user)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'swift+https://user:pass@authurl.com/images/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+https\", loc.scheme)",
            "        self.assertEqual(\"authurl.com\", loc.auth_or_store_url)",
            "        self.assertEqual(\"https://authurl.com\", loc.swift_url)",
            "        self.assertEqual(\"images\", loc.container)",
            "        self.assertEqual(\"1\", loc.obj)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"pass\", loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'swift+https://user:pass@authurl.com/v1/container/12345'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+https\", loc.scheme)",
            "        self.assertEqual(\"authurl.com/v1\", loc.auth_or_store_url)",
            "        self.assertEqual(\"https://authurl.com/v1\", loc.swift_url)",
            "        self.assertEqual(\"container\", loc.container)",
            "        self.assertEqual(\"12345\", loc.obj)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"pass\", loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = ('swift+http://a%3Auser%40example.com:p%40ss@authurl.com/'",
            "               'v1/container/12345')",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+http\", loc.scheme)",
            "        self.assertEqual(\"authurl.com/v1\", loc.auth_or_store_url)",
            "        self.assertEqual(\"http://authurl.com/v1\", loc.swift_url)",
            "        self.assertEqual(\"container\", loc.container)",
            "        self.assertEqual(\"12345\", loc.obj)",
            "        self.assertEqual(\"a:user@example.com\", loc.user)",
            "        self.assertEqual(\"p@ss\", loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        # multitenant puts store URL in the location (not auth)",
            "        uri = ('swift+http://storeurl.com/v1/container/12345')",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+http\", loc.scheme)",
            "        self.assertEqual(\"storeurl.com/v1\", loc.auth_or_store_url)",
            "        self.assertEqual(\"http://storeurl.com/v1\", loc.swift_url)",
            "        self.assertEqual(\"container\", loc.container)",
            "        self.assertEqual(\"12345\", loc.obj)",
            "        self.assertIsNone(loc.user)",
            "        self.assertIsNone(loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'swif://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'swift://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'swift://user@example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'swift://user:pass@http://example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_s3_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the S3 store",
            "        \"\"\"",
            "        uri = 's3://example.com/images/1'",
            "        loc = glance.store.s3.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3\", loc.scheme)",
            "        self.assertEqual(\"example.com\", loc.s3serviceurl)",
            "        self.assertEqual(\"images\", loc.bucket)",
            "        self.assertEqual(\"1\", loc.key)",
            "        self.assertIsNone(loc.accesskey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 's3+https://accesskey:pass@s3serviceurl.com/images/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3+https\", loc.scheme)",
            "        self.assertEqual(\"s3serviceurl.com\", loc.s3serviceurl)",
            "        self.assertEqual(\"images\", loc.bucket)",
            "        self.assertEqual(\"1\", loc.key)",
            "        self.assertEqual(\"accesskey\", loc.accesskey)",
            "        self.assertEqual(\"pass\", loc.secretkey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 's3+https://accesskey:pass@s3serviceurl.com/v1/bucket/12345'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3+https\", loc.scheme)",
            "        self.assertEqual(\"s3serviceurl.com/v1\", loc.s3serviceurl)",
            "        self.assertEqual(\"bucket\", loc.bucket)",
            "        self.assertEqual(\"12345\", loc.key)",
            "        self.assertEqual(\"accesskey\", loc.accesskey)",
            "        self.assertEqual(\"pass\", loc.secretkey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 's3://accesskey:pass/withslash@s3serviceurl.com/v1/bucket/12345'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3\", loc.scheme)",
            "        self.assertEqual(\"s3serviceurl.com/v1\", loc.s3serviceurl)",
            "        self.assertEqual(\"bucket\", loc.bucket)",
            "        self.assertEqual(\"12345\", loc.key)",
            "        self.assertEqual(\"accesskey\", loc.accesskey)",
            "        self.assertEqual(\"pass/withslash\", loc.secretkey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 's://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 's3://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 's3://accesskey@example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 's3://user:pass@http://example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_rbd_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the RBD store",
            "        \"\"\"",
            "        uri = 'rbd://imagename'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('imagename', loc.image)",
            "        self.assertIsNone(loc.fsid)",
            "        self.assertIsNone(loc.pool)",
            "        self.assertIsNone(loc.snapshot)",
            "",
            "        uri = u'rbd://imagename'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('imagename', loc.image)",
            "        self.assertIsNone(loc.fsid)",
            "        self.assertIsNone(loc.pool)",
            "        self.assertIsNone(loc.snapshot)",
            "",
            "        uri = 'rbd://fsid/pool/image/snap'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('image', loc.image)",
            "        self.assertEqual('fsid', loc.fsid)",
            "        self.assertEqual('pool', loc.pool)",
            "        self.assertEqual('snap', loc.snapshot)",
            "",
            "        uri = u'rbd://fsid/pool/image/snap'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('image', loc.image)",
            "        self.assertEqual('fsid', loc.fsid)",
            "        self.assertEqual('pool', loc.pool)",
            "        self.assertEqual('snap', loc.snapshot)",
            "",
            "        uri = 'rbd://%2f/%2f/%2f/%2f'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('/', loc.image)",
            "        self.assertEqual('/', loc.fsid)",
            "        self.assertEqual('/', loc.pool)",
            "        self.assertEqual('/', loc.snapshot)",
            "",
            "        uri = u'rbd://%2f/%2f/%2f/%2f'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('/', loc.image)",
            "        self.assertEqual('/', loc.fsid)",
            "        self.assertEqual('/', loc.pool)",
            "        self.assertEqual('/', loc.snapshot)",
            "",
            "        bad_uri = 'rbd:/image'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://image/extra'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://image/'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://image'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://fsid/pool/image/snap'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://fsid/pool/image/'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://fsid/pool/image/snap/'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://///'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://' + unichr(300)",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_sheepdog_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Sheepdog store",
            "        \"\"\"",
            "        uri = 'sheepdog://244e75f1-9c69-4167-9db7-1aa7d1973f6c'",
            "        loc = glance.store.sheepdog.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "        self.assertEqual('244e75f1-9c69-4167-9db7-1aa7d1973f6c', loc.image)",
            "",
            "        bad_uri = 'sheepdog:/244e75f1-9c69-4167-9db7-1aa7d1973f6c'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://244e75f1-9c69-4167-9db7-1aa7d1973f6c'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'image; name'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_vmware_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the VMware store",
            "        \"\"\"",
            "        ds_url_prefix = glance.store.vmware_datastore.DS_URL_PREFIX",
            "        image_dir = glance.store.vmware_datastore.DEFAULT_STORE_IMAGE_DIR",
            "        uri = ('vsphere://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds' %",
            "               (ds_url_prefix, image_dir))",
            "        loc = glance.store.vmware_datastore.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"vsphere\", loc.scheme)",
            "        self.assertEqual(\"127.0.0.1\", loc.server_host)",
            "        self.assertEqual(\"%s%s/29038321\" %",
            "                         (ds_url_prefix, image_dir), loc.path)",
            "        self.assertEqual(\"dcPath=my-dc&dsName=my-ds\", loc.query)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'vphere://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vspheer://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('http://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vsphere:/127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vsphere://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, \"/folder_not_in_configuration\"))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vsphere://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (\"/wrong_folder_path\", image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_cinder_store_good_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Cinder store",
            "        \"\"\"",
            "        good_uri = 'cinder://12345678-9012-3455-6789-012345678901'",
            "        loc = glance.store.cinder.StoreLocation({})",
            "        loc.parse_uri(good_uri)",
            "        self.assertEqual('12345678-9012-3455-6789-012345678901', loc.volume_id)",
            "",
            "    def test_cinder_store_bad_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Cinder store",
            "        \"\"\"",
            "        bad_uri = 'cinder://volume-id-is-a-uuid'",
            "        loc = glance.store.cinder.StoreLocation({})",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_get_store_from_scheme(self):",
            "        \"\"\"",
            "        Test that the backend returned by glance.store.get_backend_class",
            "        is correct or raises an appropriate error.",
            "        \"\"\"",
            "        good_results = {",
            "            'swift': glance.store.swift.SingleTenantStore,",
            "            'swift+http': glance.store.swift.SingleTenantStore,",
            "            'swift+https': glance.store.swift.SingleTenantStore,",
            "            's3': glance.store.s3.Store,",
            "            's3+http': glance.store.s3.Store,",
            "            's3+https': glance.store.s3.Store,",
            "            'file': glance.store.filesystem.Store,",
            "            'filesystem': glance.store.filesystem.Store,",
            "            'http': glance.store.http.Store,",
            "            'https': glance.store.http.Store,",
            "            'rbd': glance.store.rbd.Store,",
            "            'sheepdog': glance.store.sheepdog.Store,",
            "            'cinder': glance.store.cinder.Store,",
            "            'vsphere': glance.store.vmware_datastore.Store}",
            "",
            "        ctx = context.RequestContext()",
            "        for scheme, store in good_results.items():",
            "            store_obj = glance.store.get_store_from_scheme(ctx, scheme)",
            "            self.assertEqual(store_obj.__class__, store)",
            "",
            "        bad_results = ['fil', 'swift+h', 'unknown']",
            "",
            "        for store in bad_results:",
            "            self.assertRaises(exception.UnknownScheme,",
            "                              glance.store.get_store_from_scheme,",
            "                              ctx,",
            "                              store)",
            "",
            "    class FakeImageProxy(object):",
            "        size = None",
            "        context = None",
            "",
            "        def __init__(self, store_api):",
            "            self.store_api = store_api",
            "",
            "    def test_add_location_for_image_without_size(self):",
            "",
            "        def fake_get_size_from_backend(context, uri):",
            "            return 1",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       fake_get_size_from_backend)",
            "        with mock.patch('glance.store._check_image_location'):",
            "            loc1 = {'url': 'file:///fake1.img.tar.gz', 'metadata': {}}",
            "            loc2 = {'url': 'file:///fake2.img.tar.gz', 'metadata': {}}",
            "",
            "            # Test for insert location",
            "            image1 = TestStoreLocation.FakeImageProxy(mock.Mock())",
            "            locations = glance.store.StoreLocations(image1, [])",
            "            locations.insert(0, loc2)",
            "            self.assertEqual(image1.size, 1)",
            "",
            "            # Test for set_attr of _locations_proxy",
            "            image2 = TestStoreLocation.FakeImageProxy(mock.Mock())",
            "            locations = glance.store.StoreLocations(image2, [loc1])",
            "            locations[0] = loc2",
            "            self.assertTrue(loc2 in locations)",
            "            self.assertEqual(image2.size, 1)",
            "",
            "    def test_add_location_with_restricted_sources(self):",
            "",
            "        loc1 = {'url': 'file:///fake1.img.tar.gz', 'metadata': {}}",
            "        loc2 = {'url': 'swift+config:///xxx', 'metadata': {}}",
            "",
            "        # Test for insert location",
            "        image1 = TestStoreLocation.FakeImageProxy(utils.FakeStoreAPI())",
            "        locations = glance.store.StoreLocations(image1, [])",
            "        self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc1)",
            "        self.assertNotIn(loc1, locations)",
            "",
            "        # Test for set_attr of _locations_proxy",
            "        image2 = TestStoreLocation.FakeImageProxy(utils.FakeStoreAPI())",
            "        locations = glance.store.StoreLocations(image2, [loc1])",
            "        self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc2)",
            "        self.assertNotIn(loc2, locations)"
        ],
        "afterPatchFile": [
            "# Copyright 2011-2013 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "import mock",
            "",
            "from glance.common import exception",
            "from glance import context",
            "import glance.store",
            "import glance.store.filesystem",
            "import glance.store.http",
            "import glance.store.location as location",
            "import glance.store.s3",
            "import glance.store.swift",
            "import glance.store.vmware_datastore",
            "from glance.tests.unit import base",
            "from glance.tests.unit import utils",
            "",
            "",
            "class TestStoreLocation(base.StoreClearingUnitTest):",
            "",
            "    def setUp(self):",
            "        self.config(default_store='file')",
            "",
            "        # NOTE(flaper87): Each store should test",
            "        # this in their test suite.",
            "        self.config(known_stores=[",
            "            \"glance.store.filesystem.Store\",",
            "            \"glance.store.http.Store\",",
            "            \"glance.store.rbd.Store\",",
            "            \"glance.store.s3.Store\",",
            "            \"glance.store.swift.Store\",",
            "            \"glance.store.sheepdog.Store\",",
            "            \"glance.store.cinder.Store\",",
            "            \"glance.store.gridfs.Store\",",
            "            \"glance.store.vmware_datastore.Store\",",
            "        ])",
            "        super(TestStoreLocation, self).setUp()",
            "",
            "    def test_get_location_from_uri_back_to_uri(self):",
            "        \"\"\"",
            "        Test that for various URIs, the correct Location",
            "        object can be contructed and then the original URI",
            "        returned via the get_store_uri() method.",
            "        \"\"\"",
            "        good_store_uris = [",
            "            'https://user:pass@example.com:80/images/some-id',",
            "            'http://images.oracle.com/123456',",
            "            'swift://account%3Auser:pass@authurl.com/container/obj-id',",
            "            'swift://storeurl.com/container/obj-id',",
            "            'swift+https://account%3Auser:pass@authurl.com/container/obj-id',",
            "            's3://accesskey:secretkey@s3.amazonaws.com/bucket/key-id',",
            "            's3://accesskey:secretwith/aslash@s3.amazonaws.com/bucket/key-id',",
            "            's3+http://accesskey:secret@s3.amazonaws.com/bucket/key-id',",
            "            's3+https://accesskey:secretkey@s3.amazonaws.com/bucket/key-id',",
            "            'file:///var/lib/glance/images/1',",
            "            'rbd://imagename',",
            "            'rbd://fsid/pool/image/snap',",
            "            'rbd://%2F/%2F/%2F/%2F',",
            "            'sheepdog://244e75f1-9c69-4167-9db7-1aa7d1973f6c',",
            "            'cinder://12345678-9012-3455-6789-012345678901',",
            "            'vsphere://ip/folder/openstack_glance/2332298?dcPath=dc&dsName=ds',",
            "        ]",
            "",
            "        for uri in good_store_uris:",
            "            loc = location.get_location_from_uri(uri)",
            "            # The get_store_uri() method *should* return an identical URI",
            "            # to the URI that is passed to get_location_from_uri()",
            "            self.assertEqual(loc.get_store_uri(), uri)",
            "",
            "    def test_bad_store_scheme(self):",
            "        \"\"\"",
            "        Test that a URI with a non-existing scheme triggers exception",
            "        \"\"\"",
            "        bad_uri = 'unknown://user:pass@example.com:80/images/some-id'",
            "",
            "        self.assertRaises(exception.UnknownScheme,",
            "                          location.get_location_from_uri,",
            "                          bad_uri)",
            "",
            "    def test_filesystem_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Filesystem store",
            "        \"\"\"",
            "        uri = 'file:///var/lib/glance/images/1'",
            "        loc = glance.store.filesystem.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"file\", loc.scheme)",
            "        self.assertEqual(\"/var/lib/glance/images/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'fil://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'file://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_http_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the HTTP store",
            "        \"\"\"",
            "        uri = 'http://example.com/images/1'",
            "        loc = glance.store.http.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"http\", loc.scheme)",
            "        self.assertEqual(\"example.com\", loc.netloc)",
            "        self.assertEqual(\"/images/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'https://example.com:8080/images/container/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"https\", loc.scheme)",
            "        self.assertEqual(\"example.com:8080\", loc.netloc)",
            "        self.assertEqual(\"/images/container/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'https://user:password@example.com:8080/images/container/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"https\", loc.scheme)",
            "        self.assertEqual(\"example.com:8080\", loc.netloc)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"password\", loc.password)",
            "        self.assertEqual(\"/images/container/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'https://user:@example.com:8080/images/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"https\", loc.scheme)",
            "        self.assertEqual(\"example.com:8080\", loc.netloc)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"\", loc.password)",
            "        self.assertEqual(\"/images/1\", loc.path)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'htt://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://user@example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_swift_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Swift store",
            "        \"\"\"",
            "        uri = 'swift://example.com/images/1'",
            "        loc = glance.store.swift.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift\", loc.scheme)",
            "        self.assertEqual(\"example.com\", loc.auth_or_store_url)",
            "        self.assertEqual(\"https://example.com\", loc.swift_url)",
            "        self.assertEqual(\"images\", loc.container)",
            "        self.assertEqual(\"1\", loc.obj)",
            "        self.assertIsNone(loc.user)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'swift+https://user:pass@authurl.com/images/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+https\", loc.scheme)",
            "        self.assertEqual(\"authurl.com\", loc.auth_or_store_url)",
            "        self.assertEqual(\"https://authurl.com\", loc.swift_url)",
            "        self.assertEqual(\"images\", loc.container)",
            "        self.assertEqual(\"1\", loc.obj)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"pass\", loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 'swift+https://user:pass@authurl.com/v1/container/12345'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+https\", loc.scheme)",
            "        self.assertEqual(\"authurl.com/v1\", loc.auth_or_store_url)",
            "        self.assertEqual(\"https://authurl.com/v1\", loc.swift_url)",
            "        self.assertEqual(\"container\", loc.container)",
            "        self.assertEqual(\"12345\", loc.obj)",
            "        self.assertEqual(\"user\", loc.user)",
            "        self.assertEqual(\"pass\", loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = ('swift+http://a%3Auser%40example.com:p%40ss@authurl.com/'",
            "               'v1/container/12345')",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+http\", loc.scheme)",
            "        self.assertEqual(\"authurl.com/v1\", loc.auth_or_store_url)",
            "        self.assertEqual(\"http://authurl.com/v1\", loc.swift_url)",
            "        self.assertEqual(\"container\", loc.container)",
            "        self.assertEqual(\"12345\", loc.obj)",
            "        self.assertEqual(\"a:user@example.com\", loc.user)",
            "        self.assertEqual(\"p@ss\", loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        # multitenant puts store URL in the location (not auth)",
            "        uri = ('swift+http://storeurl.com/v1/container/12345')",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"swift+http\", loc.scheme)",
            "        self.assertEqual(\"storeurl.com/v1\", loc.auth_or_store_url)",
            "        self.assertEqual(\"http://storeurl.com/v1\", loc.swift_url)",
            "        self.assertEqual(\"container\", loc.container)",
            "        self.assertEqual(\"12345\", loc.obj)",
            "        self.assertIsNone(loc.user)",
            "        self.assertIsNone(loc.key)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'swif://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'swift://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'swift://user@example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'swift://user:pass@http://example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_s3_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the S3 store",
            "        \"\"\"",
            "        uri = 's3://example.com/images/1'",
            "        loc = glance.store.s3.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3\", loc.scheme)",
            "        self.assertEqual(\"example.com\", loc.s3serviceurl)",
            "        self.assertEqual(\"images\", loc.bucket)",
            "        self.assertEqual(\"1\", loc.key)",
            "        self.assertIsNone(loc.accesskey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 's3+https://accesskey:pass@s3serviceurl.com/images/1'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3+https\", loc.scheme)",
            "        self.assertEqual(\"s3serviceurl.com\", loc.s3serviceurl)",
            "        self.assertEqual(\"images\", loc.bucket)",
            "        self.assertEqual(\"1\", loc.key)",
            "        self.assertEqual(\"accesskey\", loc.accesskey)",
            "        self.assertEqual(\"pass\", loc.secretkey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 's3+https://accesskey:pass@s3serviceurl.com/v1/bucket/12345'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3+https\", loc.scheme)",
            "        self.assertEqual(\"s3serviceurl.com/v1\", loc.s3serviceurl)",
            "        self.assertEqual(\"bucket\", loc.bucket)",
            "        self.assertEqual(\"12345\", loc.key)",
            "        self.assertEqual(\"accesskey\", loc.accesskey)",
            "        self.assertEqual(\"pass\", loc.secretkey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        uri = 's3://accesskey:pass/withslash@s3serviceurl.com/v1/bucket/12345'",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"s3\", loc.scheme)",
            "        self.assertEqual(\"s3serviceurl.com/v1\", loc.s3serviceurl)",
            "        self.assertEqual(\"bucket\", loc.bucket)",
            "        self.assertEqual(\"12345\", loc.key)",
            "        self.assertEqual(\"accesskey\", loc.accesskey)",
            "        self.assertEqual(\"pass/withslash\", loc.secretkey)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 's://'",
            "        self.assertRaises(AssertionError, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 's3://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 's3://accesskey@example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 's3://user:pass@http://example.com:8080/images/1'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_rbd_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the RBD store",
            "        \"\"\"",
            "        uri = 'rbd://imagename'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('imagename', loc.image)",
            "        self.assertIsNone(loc.fsid)",
            "        self.assertIsNone(loc.pool)",
            "        self.assertIsNone(loc.snapshot)",
            "",
            "        uri = u'rbd://imagename'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('imagename', loc.image)",
            "        self.assertIsNone(loc.fsid)",
            "        self.assertIsNone(loc.pool)",
            "        self.assertIsNone(loc.snapshot)",
            "",
            "        uri = 'rbd://fsid/pool/image/snap'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('image', loc.image)",
            "        self.assertEqual('fsid', loc.fsid)",
            "        self.assertEqual('pool', loc.pool)",
            "        self.assertEqual('snap', loc.snapshot)",
            "",
            "        uri = u'rbd://fsid/pool/image/snap'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('image', loc.image)",
            "        self.assertEqual('fsid', loc.fsid)",
            "        self.assertEqual('pool', loc.pool)",
            "        self.assertEqual('snap', loc.snapshot)",
            "",
            "        uri = 'rbd://%2f/%2f/%2f/%2f'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('/', loc.image)",
            "        self.assertEqual('/', loc.fsid)",
            "        self.assertEqual('/', loc.pool)",
            "        self.assertEqual('/', loc.snapshot)",
            "",
            "        uri = u'rbd://%2f/%2f/%2f/%2f'",
            "        loc = glance.store.rbd.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual('/', loc.image)",
            "        self.assertEqual('/', loc.fsid)",
            "        self.assertEqual('/', loc.pool)",
            "        self.assertEqual('/', loc.snapshot)",
            "",
            "        bad_uri = 'rbd:/image'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://image/extra'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://image/'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://image'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://fsid/pool/image/snap'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://fsid/pool/image/'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://fsid/pool/image/snap/'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://///'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'rbd://' + unichr(300)",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_sheepdog_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Sheepdog store",
            "        \"\"\"",
            "        uri = 'sheepdog://244e75f1-9c69-4167-9db7-1aa7d1973f6c'",
            "        loc = glance.store.sheepdog.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "        self.assertEqual('244e75f1-9c69-4167-9db7-1aa7d1973f6c', loc.image)",
            "",
            "        bad_uri = 'sheepdog:/244e75f1-9c69-4167-9db7-1aa7d1973f6c'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'http://244e75f1-9c69-4167-9db7-1aa7d1973f6c'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = 'image; name'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_vmware_store_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the VMware store",
            "        \"\"\"",
            "        ds_url_prefix = glance.store.vmware_datastore.DS_URL_PREFIX",
            "        image_dir = glance.store.vmware_datastore.DEFAULT_STORE_IMAGE_DIR",
            "        uri = ('vsphere://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds' %",
            "               (ds_url_prefix, image_dir))",
            "        loc = glance.store.vmware_datastore.StoreLocation({})",
            "        loc.parse_uri(uri)",
            "",
            "        self.assertEqual(\"vsphere\", loc.scheme)",
            "        self.assertEqual(\"127.0.0.1\", loc.server_host)",
            "        self.assertEqual(\"%s%s/29038321\" %",
            "                         (ds_url_prefix, image_dir), loc.path)",
            "        self.assertEqual(\"dcPath=my-dc&dsName=my-ds\", loc.query)",
            "        self.assertEqual(uri, loc.get_uri())",
            "",
            "        bad_uri = 'vphere://'",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vspheer://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('http://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vsphere:/127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vsphere://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (ds_url_prefix, \"/folder_not_in_configuration\"))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "        bad_uri = ('vsphere://127.0.0.1%s%s/29038321?dcPath=my-dc&dsName=my-ds'",
            "                   % (\"/wrong_folder_path\", image_dir))",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_cinder_store_good_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Cinder store",
            "        \"\"\"",
            "        good_uri = 'cinder://12345678-9012-3455-6789-012345678901'",
            "        loc = glance.store.cinder.StoreLocation({})",
            "        loc.parse_uri(good_uri)",
            "        self.assertEqual('12345678-9012-3455-6789-012345678901', loc.volume_id)",
            "",
            "    def test_cinder_store_bad_location(self):",
            "        \"\"\"",
            "        Test the specific StoreLocation for the Cinder store",
            "        \"\"\"",
            "        bad_uri = 'cinder://volume-id-is-a-uuid'",
            "        loc = glance.store.cinder.StoreLocation({})",
            "        self.assertRaises(exception.BadStoreUri, loc.parse_uri, bad_uri)",
            "",
            "    def test_get_store_from_scheme(self):",
            "        \"\"\"",
            "        Test that the backend returned by glance.store.get_backend_class",
            "        is correct or raises an appropriate error.",
            "        \"\"\"",
            "        good_results = {",
            "            'swift': glance.store.swift.SingleTenantStore,",
            "            'swift+http': glance.store.swift.SingleTenantStore,",
            "            'swift+https': glance.store.swift.SingleTenantStore,",
            "            's3': glance.store.s3.Store,",
            "            's3+http': glance.store.s3.Store,",
            "            's3+https': glance.store.s3.Store,",
            "            'file': glance.store.filesystem.Store,",
            "            'filesystem': glance.store.filesystem.Store,",
            "            'http': glance.store.http.Store,",
            "            'https': glance.store.http.Store,",
            "            'rbd': glance.store.rbd.Store,",
            "            'sheepdog': glance.store.sheepdog.Store,",
            "            'cinder': glance.store.cinder.Store,",
            "            'vsphere': glance.store.vmware_datastore.Store}",
            "",
            "        ctx = context.RequestContext()",
            "        for scheme, store in good_results.items():",
            "            store_obj = glance.store.get_store_from_scheme(ctx, scheme)",
            "            self.assertEqual(store_obj.__class__, store)",
            "",
            "        bad_results = ['fil', 'swift+h', 'unknown']",
            "",
            "        for store in bad_results:",
            "            self.assertRaises(exception.UnknownScheme,",
            "                              glance.store.get_store_from_scheme,",
            "                              ctx,",
            "                              store)",
            "",
            "    class FakeImageProxy(object):",
            "        size = None",
            "        context = None",
            "",
            "        def __init__(self, store_api):",
            "            self.store_api = store_api",
            "",
            "    def test_add_location_for_image_without_size(self):",
            "",
            "        def fake_get_size_from_backend(context, uri):",
            "            return 1",
            "",
            "        self.stubs.Set(glance.store, 'get_size_from_backend',",
            "                       fake_get_size_from_backend)",
            "        with mock.patch('glance.store._check_image_location'):",
            "            loc1 = {'url': 'file:///fake1.img.tar.gz', 'metadata': {}}",
            "            loc2 = {'url': 'file:///fake2.img.tar.gz', 'metadata': {}}",
            "",
            "            # Test for insert location",
            "            image1 = TestStoreLocation.FakeImageProxy(mock.Mock())",
            "            locations = glance.store.StoreLocations(image1, [])",
            "            locations.insert(0, loc2)",
            "            self.assertEqual(image1.size, 1)",
            "",
            "            # Test for set_attr of _locations_proxy",
            "            image2 = TestStoreLocation.FakeImageProxy(mock.Mock())",
            "            locations = glance.store.StoreLocations(image2, [loc1])",
            "            locations[0] = loc2",
            "            self.assertTrue(loc2 in locations)",
            "            self.assertEqual(image2.size, 1)",
            "",
            "    def test_add_location_with_restricted_sources(self):",
            "",
            "        loc1 = {'url': 'file:///fake1.img.tar.gz', 'metadata': {}}",
            "        loc2 = {'url': 'swift+config:///xxx', 'metadata': {}}",
            "        loc3 = {'url': 'filesystem:///foo.img.tar.gz', 'metadata': {}}",
            "",
            "        # Test for insert location",
            "        image1 = TestStoreLocation.FakeImageProxy(utils.FakeStoreAPI())",
            "        locations = glance.store.StoreLocations(image1, [])",
            "        self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc1)",
            "        self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc3)",
            "        self.assertNotIn(loc1, locations)",
            "        self.assertNotIn(loc3, locations)",
            "",
            "        # Test for set_attr of _locations_proxy",
            "        image2 = TestStoreLocation.FakeImageProxy(utils.FakeStoreAPI())",
            "        locations = glance.store.StoreLocations(image2, [loc1])",
            "        self.assertRaises(exception.BadStoreUri, locations.insert, 0, loc2)",
            "        self.assertNotIn(loc2, locations)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "asyncua.common.connection",
            "glance.tests.unit.test_store_location.TestStoreLocation.test_add_location_with_restricted_sources.loc2",
            "glance.tests.unit.test_store_location.TestStoreLocation.test_add_location_with_restricted_sources.loc1"
        ]
    },
    "glance/tests/unit/v1/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1010,
                "afterPatchRowNumber": 1010,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 1011,
                "afterPatchRowNumber": 1011,
                "PatchRowcode": "     def test_add_copy_from_with_restricted_sources(self):"
            },
            "2": {
                "beforePatchRowNumber": 1012,
                "afterPatchRowNumber": 1012,
                "PatchRowcode": "         \"\"\"Tests creates an image from copy-from with restricted sources\"\"\""
            },
            "3": {
                "beforePatchRowNumber": 1013,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        fixture_headers = {'x-image-meta-store': 'file',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1013,
                "PatchRowcode": "+        header_template = {'x-image-meta-store': 'file',"
            },
            "5": {
                "beforePatchRowNumber": 1014,
                "afterPatchRowNumber": 1014,
                "PatchRowcode": "                            'x-image-meta-disk-format': 'vhd',"
            },
            "6": {
                "beforePatchRowNumber": 1015,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           'x-glance-api-copy-from': 'file:///etc/passwd',"
            },
            "7": {
                "beforePatchRowNumber": 1016,
                "afterPatchRowNumber": 1015,
                "PatchRowcode": "                            'x-image-meta-container-format': 'ovf',"
            },
            "8": {
                "beforePatchRowNumber": 1017,
                "afterPatchRowNumber": 1016,
                "PatchRowcode": "                            'x-image-meta-name': 'fake image #F'}"
            },
            "9": {
                "beforePatchRowNumber": 1018,
                "afterPatchRowNumber": 1017,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 1019,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images\")"
            },
            "11": {
                "beforePatchRowNumber": 1020,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'POST'"
            },
            "12": {
                "beforePatchRowNumber": 1021,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for k, v in six.iteritems(fixture_headers):"
            },
            "13": {
                "beforePatchRowNumber": 1022,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            req.headers[k] = v"
            },
            "14": {
                "beforePatchRowNumber": 1023,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        res = req.get_response(self.api)"
            },
            "15": {
                "beforePatchRowNumber": 1024,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(400, res.status_int)"
            },
            "16": {
                "beforePatchRowNumber": 1025,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "17": {
                "beforePatchRowNumber": 1026,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        fixture_headers = {'x-image-meta-store': 'file',"
            },
            "18": {
                "beforePatchRowNumber": 1027,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           'x-image-meta-disk-format': 'vhd',"
            },
            "19": {
                "beforePatchRowNumber": 1028,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           'x-glance-api-copy-from': 'swift+config://xxx',"
            },
            "20": {
                "beforePatchRowNumber": 1029,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           'x-image-meta-container-format': 'ovf',"
            },
            "21": {
                "beforePatchRowNumber": 1030,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                           'x-image-meta-name': 'fake image #F'}"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1018,
                "PatchRowcode": "+        schemas = [\"file:///etc/passwd\","
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1019,
                "PatchRowcode": "+                   \"swift+config:///xxx\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1020,
                "PatchRowcode": "+                   \"filesystem:///etc/passwd\"]"
            },
            "25": {
                "beforePatchRowNumber": 1031,
                "afterPatchRowNumber": 1021,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 1032,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req = webob.Request.blank(\"/images\")"
            },
            "27": {
                "beforePatchRowNumber": 1033,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        req.method = 'POST'"
            },
            "28": {
                "beforePatchRowNumber": 1034,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for k, v in six.iteritems(fixture_headers):"
            },
            "29": {
                "beforePatchRowNumber": 1035,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            req.headers[k] = v"
            },
            "30": {
                "beforePatchRowNumber": 1036,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        res = req.get_response(self.api)"
            },
            "31": {
                "beforePatchRowNumber": 1037,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(400, res.status_int)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1022,
                "PatchRowcode": "+        for schema in schemas:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1023,
                "PatchRowcode": "+            req = webob.Request.blank(\"/images\")"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1024,
                "PatchRowcode": "+            req.method = 'POST'"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1025,
                "PatchRowcode": "+            for k, v in six.iteritems(header_template):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1026,
                "PatchRowcode": "+                req.headers[k] = v"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1027,
                "PatchRowcode": "+            req.headers['x-glance-api-copy-from'] = schema"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1028,
                "PatchRowcode": "+            res = req.get_response(self.api)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1029,
                "PatchRowcode": "+            self.assertEqual(400, res.status_int)"
            },
            "40": {
                "beforePatchRowNumber": 1038,
                "afterPatchRowNumber": 1030,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 1039,
                "afterPatchRowNumber": 1031,
                "PatchRowcode": "     def test_add_copy_from_upload_image_unauthorized_with_body(self):"
            },
            "42": {
                "beforePatchRowNumber": 1040,
                "afterPatchRowNumber": 1032,
                "PatchRowcode": "         rules = {\"upload_image\": '!', \"modify_image\": '@',"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import datetime",
            "import hashlib",
            "import uuid",
            "",
            "import mock",
            "from oslo.config import cfg",
            "import routes",
            "import six",
            "import webob",
            "",
            "import glance.api",
            "import glance.api.common",
            "from glance.api.v1 import router",
            "from glance.api.v1 import upload_utils",
            "import glance.common.config",
            "from glance.common import exception",
            "import glance.context",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.db.sqlalchemy import models as db_models",
            "from glance.openstack.common import jsonutils",
            "from glance.openstack.common import timeutils",
            "",
            "import glance.registry.client.v1.api as registry",
            "import glance.store.filesystem",
            "from glance.store import http",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "_gen_uuid = lambda: str(uuid.uuid4())",
            "",
            "UUID1 = _gen_uuid()",
            "UUID2 = _gen_uuid()",
            "",
            "",
            "class TestGlanceAPI(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestGlanceAPI, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        self.FIXTURES = [",
            "            {'id': UUID1,",
            "             'name': 'fake image #1',",
            "             'status': 'active',",
            "             'disk_format': 'ami',",
            "             'container_format': 'ami',",
            "             'is_public': False,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': None,",
            "             'size': 13,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID1),",
            "                            'metadata': {}}],",
            "             'properties': {'type': 'kernel'}},",
            "            {'id': UUID2,",
            "             'name': 'fake image #2',",
            "             'status': 'active',",
            "             'disk_format': 'vhd',",
            "             'container_format': 'ovf',",
            "             'is_public': True,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': 'abc123',",
            "             'size': 19,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID2),",
            "                            'metadata': {}}],",
            "             'properties': {}}]",
            "        self.context = glance.context.RequestContext(is_admin=True)",
            "        db_api.get_engine()",
            "        self.destroy_fixtures()",
            "        self.create_fixtures()",
            "        # Used to store/track image status changes for post-analysis",
            "        self.image_status = []",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestGlanceAPI, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def create_fixtures(self):",
            "        for fixture in self.FIXTURES:",
            "            db_api.image_create(self.context, fixture)",
            "            # We write a fake image file to the filesystem",
            "            with open(\"%s/%s\" % (self.test_dir, fixture['id']), 'wb') as image:",
            "                image.write(\"chunk00000remainder\")",
            "                image.flush()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _do_test_defaulted_format(self, format_key, format_value):",
            "        fixture_headers = {'x-image-meta-name': 'defaulted',",
            "                           'x-image-meta-location': 'http://localhost:0/image',",
            "                           format_key: format_value}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)['image']",
            "            self.assertEqual(format_value, res_body['disk_format'])",
            "            self.assertEqual(format_value, res_body['container_format'])",
            "",
            "    def test_defaulted_amazon_format(self):",
            "        for key in ('x-image-meta-disk-format',",
            "                    'x-image-meta-container-format'):",
            "            for value in ('aki', 'ari', 'ami'):",
            "                self._do_test_defaulted_format(key, value)",
            "",
            "    def test_bad_min_disk_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-disk': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_disk_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-disk'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-ram': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-ram'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_disk_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'invalid',",
            "            'x-image-meta-container-format': 'ami',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_disk_format_good(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'foo',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_disk_format_bad(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'bar',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_container_format_good(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'foo',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_container_format_bad(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'bar',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body, res.body)",
            "",
            "    def test_container_and_disk_amazon_format_differs(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'aki',",
            "            'x-image-meta-container-format': 'ami'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        expected = (\"Invalid mix of disk and container formats. \"",
            "                    \"When setting a disk or container format to one of \"",
            "                    \"'aki', 'ari', or 'ami', \"",
            "                    \"the container and disk formats must match.\")",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue(expected in res.body, res.body)",
            "",
            "    def test_create_with_location_no_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_create_with_bad_store_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Required store bad is invalid' in res.body)",
            "",
            "    def test_create_with_location_unknown_scheme(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'bad+scheme://localhost:0/image.qcow2',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertIn('External source are not supported', res.body)",
            "",
            "    def test_create_with_location_bad_store_uri(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'swift',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_create_image_with_too_many_properties(self):",
            "        self.config(image_property_quota=1)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images', method='POST')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 413)",
            "",
            "    def test_bad_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'invalid',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body)",
            "",
            "    def test_bad_image_size(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        def exec_bad_size_test(bad_size, expected_substr):",
            "            fixture_headers['x-image-meta-size'] = bad_size",
            "            req = webob.Request.blank(\"/images\",",
            "                                      method='POST',",
            "                                      headers=fixture_headers)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertTrue(expected_substr in res.body)",
            "",
            "        expected = \"Cannot convert image size 'invalid' to an integer.\"",
            "        exec_bad_size_test('invalid', expected)",
            "        expected = \"Image size must be >= 0 ('-10' specified).\"",
            "        exec_bad_size_test(-10, expected)",
            "",
            "    def test_bad_image_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'X' * 256,",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_no_location_no_image_as_body(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://localhost:0/images/123'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        # Once the location is set, the image should be activated",
            "        # see LP Bug #939484",
            "        self.assertEqual('active', res_body['status'])",
            "        self.assertFalse('location' in res_body)  # location never shown",
            "",
            "    def test_add_image_no_location_no_content_type(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1,",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {'x-image-meta-size': quota + 1,",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-container_format': 'bare',",
            "                           'x-image-meta-disk_format': 'qcow2',",
            "                           'content-type': 'application/octet-stream',",
            "                           }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.body = 'X' * (quota + 1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota_readd(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        used_size = sum([f['size'] for f in self.FIXTURES])",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota - used_size)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def _add_check_no_url_info(self):",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertFalse('locations' in res_body)",
            "        self.assertFalse('direct_url' in res_body)",
            "        image_id = res_body['id']",
            "",
            "        # HEAD empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('x-image-meta-locations' in res.headers)",
            "        self.assertFalse('x-image-meta-direct_url' in res.headers)",
            "",
            "    def test_add_check_no_url_info_ml(self):",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_direct_url(self):",
            "        self.config(show_image_direct_url=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_on(self):",
            "        self.config(show_image_direct_url=True)",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_off(self):",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_image_zero_size(self):",
            "        \"\"\"Tests creating an active image with explicitly zero size\"\"\"",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # GET empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 0)",
            "",
            "    def _do_test_add_image_attribute_mismatch(self, attributes):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "        }",
            "        fixture_headers.update(attributes)",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"XXXX\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_checksum_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_checksum_and_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_bad_store(self):",
            "        \"\"\"Tests raises BadRequest for invalid store header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'bad',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_basic_file_store(self):",
            "        \"\"\"Tests to add a basic image in the file store\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        # Test that the Location: header is set to the URI to",
            "        # edit the newly-created image, as required by APP.",
            "        # See LP Bug #719825",
            "        self.assertTrue('location' in res.headers,",
            "                        \"'location' not in response headers.\\n\"",
            "                        \"res.headerlist = %r\" % res.headerlist)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertTrue('/images/%s' % res_body['id']",
            "                        in res.headers['location'])",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are NOT able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://example.com/images/123'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_unauthorized(self):",
            "        rules = {\"add_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_image_authorized_upload_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from copy-from and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from location and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 2",
            "",
            "            for k, v in fixture_headers.iteritems():",
            "                req.headers[k] = v",
            "",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 409)",
            "",
            "    def test_add_location_with_invalid_location_on_restricted_sources(self):",
            "        \"\"\"Tests creates an image from location and restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_with_location(self):",
            "        \"\"\"Tests creates an image from copy-from and location\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_copy_from_with_restricted_sources(self):",
            "        \"\"\"Tests creates an image from copy-from with restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in six.iteritems(fixture_headers):",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized_with_body(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_data_upload_bad_store_uri(self):",
            "        fixture_headers = {'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.headers['x-image-meta-location'] = 'http://'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_update_data_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['transfer-encoding'] = 'chunked'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_unauthorized(self):",
            "        rules = {\"upload_image\": '@', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def _do_test_post_image_content_missing_format(self, missing):",
            "        \"\"\"Tests creation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_post_image_content_missing_disk_format(self):",
            "        \"\"\"Tests creation of an image with missing disk format\"\"\"",
            "        self._do_test_post_image_content_missing_format('disk_format')",
            "",
            "    def test_post_image_content_missing_container_type(self):",
            "        \"\"\"Tests creation of an image with missing container format\"\"\"",
            "        self._do_test_post_image_content_missing_format('container_format')",
            "",
            "    def _do_test_put_image_content_missing_format(self, missing):",
            "        \"\"\"Tests delayed activation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_put_image_content_missing_disk_format(self):",
            "        \"\"\"Tests delayed activation of image with missing disk format\"\"\"",
            "        self._do_test_put_image_content_missing_format('disk_format')",
            "",
            "    def test_put_image_content_missing_container_type(self):",
            "        \"\"\"Tests delayed activation of image with missing container format\"\"\"",
            "        self._do_test_put_image_content_missing_format('container_format')",
            "",
            "    def test_update_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to update a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = {'name': 'test_del_img'}",
            "        req = webob.Request.blank('/images/%s' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to update deleted image' in res.body)",
            "",
            "    def test_delete_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to delete a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        msg = \"Image %s not found.\" % UUID2",
            "        self.assertTrue(msg in res.body)",
            "",
            "        # Verify the status is still 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "    @mock.patch.object(glance.store.filesystem.Store, 'delete')",
            "    def test_image_status_when_delete_fails(self, mock_fsstore_delete):",
            "        \"\"\"",
            "        Tests that the image status set to active if deletion of image fails.",
            "        \"\"\"",
            "        mock_fsstore_delete.side_effect = exception.Forbidden()",
            "",
            "        # trigger the v1 delete api",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete image' in res.body)",
            "",
            "        # check image metadata is still there with active state",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_pending_delete_image(self):",
            "        \"\"\"",
            "        Tests that correct response returned when deleting",
            "        a pending_delete image",
            "        \"\"\"",
            "        # First deletion",
            "        self.config(delayed_delete=True, scrubber_datadir='/tmp/scrubber')",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "        # Second deletion",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete a pending_delete image'",
            "                        in res.body)",
            "",
            "        # Verify the status is still 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_to_image_status_saving(self):",
            "        \"\"\"Test image upload conflict.",
            "",
            "        If an image is uploaded before an existing upload to the same image",
            "        completes, the original upload should succeed and the conflicting",
            "        one should fail and any data be deleted.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'some-foo-image'}",
            "",
            "        # create an image but don't upload yet.",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        orig_get_image_metadata = registry.get_image_metadata",
            "        orig_image_get = db_api._image_get",
            "        orig_image_update = db_api._image_update",
            "        orig_initiate_deletion = upload_utils.initiate_deletion",
            "",
            "        # this will be used to track what is called and their order.",
            "        call_sequence = []",
            "        # use this to determine if we are within a db session i.e. atomic",
            "        # operation, that is setting our active state.",
            "        test_status = {'activate_session_started': False}",
            "        # We want first status check to be 'queued' so we get past the first",
            "        # guard.",
            "        test_status['queued_guard_passed'] = False",
            "",
            "        state_changes = []",
            "",
            "        def mock_image_update(context, values, image_id, purge_props=False,",
            "                              from_state=None):",
            "",
            "            status = values.get('status')",
            "            if status:",
            "                state_changes.append(status)",
            "                if status == 'active':",
            "                    # We only expect this state to be entered once.",
            "                    if test_status['activate_session_started']:",
            "                        raise Exception(\"target session already started\")",
            "",
            "                    test_status['activate_session_started'] = True",
            "                    call_sequence.append('update_active')",
            "",
            "                else:",
            "                    call_sequence.append('update')",
            "",
            "            return orig_image_update(context, values, image_id,",
            "                                     purge_props=purge_props,",
            "                                     from_state=from_state)",
            "",
            "        def mock_image_get(*args, **kwargs):",
            "            \"\"\"Force status to 'saving' if not within activate db session.",
            "",
            "            If we are in the activate db session we return 'active' which we",
            "            then expect to cause exception.Conflict to be raised since this",
            "            indicates that another upload has succeeded.",
            "            \"\"\"",
            "            image = orig_image_get(*args, **kwargs)",
            "            if test_status['activate_session_started']:",
            "                call_sequence.append('image_get_active')",
            "                setattr(image, 'status', 'active')",
            "            else:",
            "                setattr(image, 'status', 'saving')",
            "",
            "            return image",
            "",
            "        def mock_get_image_metadata(*args, **kwargs):",
            "            \"\"\"Force image status sequence.",
            "            \"\"\"",
            "            call_sequence.append('get_image_meta')",
            "            meta = orig_get_image_metadata(*args, **kwargs)",
            "            if not test_status['queued_guard_passed']:",
            "                meta['status'] = 'queued'",
            "                test_status['queued_guard_passed'] = True",
            "",
            "            return meta",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            call_sequence.append('init_del')",
            "            orig_initiate_deletion(*args, **kwargs)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = \\",
            "            'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "",
            "        with mock.patch.object(upload_utils, 'initiate_deletion') as \\",
            "                mock_init_del:",
            "            mock_init_del.side_effect = mock_initiate_deletion",
            "            with mock.patch.object(registry, 'get_image_metadata') as \\",
            "                    mock_get_meta:",
            "                mock_get_meta.side_effect = mock_get_image_metadata",
            "                with mock.patch.object(db_api, '_image_get') as mock_db_get:",
            "                    mock_db_get.side_effect = mock_image_get",
            "                    with mock.patch.object(db_api, '_image_update') as \\",
            "                            mock_db_update:",
            "                        mock_db_update.side_effect = mock_image_update",
            "",
            "                        # Expect a 409 Conflict.",
            "                        res = req.get_response(self.api)",
            "                        self.assertEqual(res.status_int, 409)",
            "",
            "                        # Check expected call sequence",
            "                        self.assertEqual(['get_image_meta', 'get_image_meta',",
            "                                          'update', 'update_active',",
            "                                          'image_get_active',",
            "                                          'init_del'],",
            "                                         call_sequence)",
            "",
            "                        self.assertTrue(mock_get_meta.called)",
            "                        self.assertTrue(mock_db_get.called)",
            "                        self.assertTrue(mock_db_update.called)",
            "",
            "                        # Ensure cleanup occured.",
            "                        self.assertEqual(1, mock_init_del.call_count)",
            "",
            "                        self.assertEqual(state_changes, ['saving', 'active'])",
            "",
            "    def test_register_and_upload(self):",
            "        \"\"\"",
            "        Test that the process of registering an image with",
            "        some metadata, then uploading an image file with some",
            "        more metadata doesn't mark the original metadata deleted",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now upload the image file along with some more",
            "        # metadata and verify original metadata properties",
            "        # are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'queued'",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key1' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def _get_image_status(self, image_id):",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        return req.get_response(self.api)",
            "",
            "    def _verify_image_status(self, image_id, status, check_deleted=False,",
            "                             use_cached=False):",
            "        if not use_cached:",
            "            res = self._get_image_status(image_id)",
            "        else:",
            "            res = self.image_status.pop(0)",
            "",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(res.headers['x-image-meta-status'], status)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'],",
            "                         str(check_deleted))",
            "",
            "    def _upload_safe_kill_common(self, mocks):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        self.image_id = res_body['id']",
            "        self.assertTrue('/images/%s' %",
            "                        self.image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        for m in mocks:",
            "            m['mock'].side_effect = m['side_effect']",
            "",
            "        # Now upload the image file along with some more metadata and",
            "        # verify original metadata properties are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        # We expect 500 since an exception occured during upload.",
            "        self.assertEqual(500, res.status_int)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill(self, mock_store_add_to_backend):",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"Trigger mid-upload failure by raising an exception.\"\"\"",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "            # Raise an exception to emulate failed upload.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'killed'",
            "        self._verify_image_status(self.image_id, 'saving', use_cached=True)",
            "        self._verify_image_status(self.image_id, 'killed')",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill_deleted(self, mock_store_add_to_backend):",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router_api,",
            "                                                 is_admin=True)",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"We now delete the image, assert status is 'deleted' then",
            "            raise an exception to emulate a failed upload. This will be caught",
            "            by upload_data_to_store() which will then try to set status to",
            "            'killed' which will be ignored since the image has been deleted.",
            "            \"\"\"",
            "            # expect 'saving'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "            # expect 'deleted'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            # Raise an exception to make the upload fail.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'deleted' -> 'deleted'",
            "        self._verify_image_status(self.image_id, 'saving', check_deleted=False,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True)",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    def test_delete_during_image_upload(self):",
            "        req = unit_test_utils.get_fake_request()",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        called = {'initiate_deletion': False}",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            called['initiate_deletion'] = True",
            "",
            "        self.stubs.Set(glance.api.v1.upload_utils, 'initiate_deletion',",
            "                       mock_initiate_deletion)",
            "",
            "        orig_update_image_metadata = registry.update_image_metadata",
            "        ctlr = glance.api.v1.controller.BaseController",
            "        orig_get_image_meta_or_404 = ctlr.get_image_meta_or_404",
            "",
            "        def mock_update_image_metadata(*args, **kwargs):",
            "",
            "            if args[2].get('status', None) == 'deleted':",
            "",
            "                # One shot.",
            "                def mock_get_image_meta_or_404(*args, **kwargs):",
            "                    ret = orig_get_image_meta_or_404(*args, **kwargs)",
            "                    ret['status'] = 'queued'",
            "                    self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                                   orig_get_image_meta_or_404)",
            "                    return ret",
            "",
            "                self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                               mock_get_image_meta_or_404)",
            "",
            "                req = webob.Request.blank(\"/images/%s\" % image_id)",
            "                req.method = 'PUT'",
            "                req.headers['Content-Type'] = 'application/octet-stream'",
            "                req.body = \"somedata\"",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                self.stubs.Set(registry, 'update_image_metadata',",
            "                               orig_update_image_metadata)",
            "",
            "            return orig_update_image_metadata(*args, **kwargs)",
            "",
            "        self.stubs.Set(registry, 'update_image_metadata',",
            "                       mock_update_image_metadata)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        self.assertTrue(called['initiate_deletion'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_disable_purge_props(self):",
            "        \"\"\"",
            "        Test the special x-glance-registry-purge-props header controls",
            "        the purge property behaviour of the registry.",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('active', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now update the image, setting new properties without",
            "        # passing the x-glance-registry-purge-props header and",
            "        # verify that original properties are marked deleted.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the original property no longer in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertFalse('x-image-meta-property-key1' in res.headers,",
            "                         \"Found property in headers that was not expected. \"",
            "                         \"Got headers: %r\" % res.headers)",
            "",
            "        # Now update the image, setting new properties and",
            "        # passing the x-glance-registry-purge-props header with",
            "        # a value of \"false\" and verify that second property",
            "        # still appears in headers.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key3'] = 'value3'",
            "        req.headers['x-glance-registry-purge-props'] = 'false'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the second and third property in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertTrue('x-image-meta-property-key3' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "",
            "    def test_publicize_image_unauthorized(self):",
            "        \"\"\"Create a non-public image then fail to make public\"\"\"",
            "        rules = {\"add_image\": '@', \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'false',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-is-public'] = 'true'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1}",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        fixture_headers = {'content-type': 'application/octet-stream'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        # Create new image that has no data",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.headers['x-image-meta-name'] = 'something'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        res = req.get_response(self.api)",
            "        image_id = jsonutils.loads(res.body)['image']['id']",
            "",
            "        fixture_headers = {",
            "            'content-type': 'application/octet-stream',",
            "            'transfer-encoding': 'chunked',",
            "        }",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_update_non_existing_image(self):",
            "        self.config(image_size_cap=100)",
            "",
            "        req = webob.Request.blank(\"images/%s\" % _gen_uuid)",
            "        req.method = 'PUT'",
            "        req.body = 'test'",
            "        req.headers['x-image-meta-name'] = 'test'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        req.headers['x-image-meta-is_public'] = 'False'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_update_public_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-name'] = 'updated public image'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "    def test_add_image_wrong_content_type(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-st',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_index_sort_name_asc(self):",
            "        \"\"\"",
            "        Tests that the /images registry API returns list of",
            "        public images sorted alphabetically by name in",
            "        ascending order.",
            "        \"\"\"",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'asdf',",
            "                         'size': 19,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'xyz',",
            "                         'size': 20,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        req = webob.Request.blank('/images?sort_key=name&sort_dir=asc')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID3)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "        self.assertEqual(images[2]['id'], UUID4)",
            "",
            "    def test_get_details_filter_changes_since(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns list of",
            "        public images that have a size less than or equal to size_max",
            "        \"\"\"",
            "        dt1 = timeutils.utcnow() - datetime.timedelta(1)",
            "        iso1 = timeutils.isotime(dt1)",
            "",
            "        date_only1 = dt1.strftime('%Y-%m-%d')",
            "        date_only2 = dt1.strftime('%Y%m%d')",
            "        date_only3 = dt1.strftime('%Y-%m%d')",
            "",
            "        dt2 = timeutils.utcnow() + datetime.timedelta(1)",
            "        iso2 = timeutils.isotime(dt2)",
            "",
            "        image_ts = timeutils.utcnow() + datetime.timedelta(2)",
            "        hour_before = image_ts.strftime('%Y-%m-%dT%H:%M:%S%%2B01:00')",
            "        hour_after = image_ts.strftime('%Y-%m-%dT%H:%M:%S-01:00')",
            "",
            "        dt4 = timeutils.utcnow() + datetime.timedelta(3)",
            "        iso4 = timeutils.isotime(dt4)",
            "",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'fake image #3',",
            "                         'size': 18,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "        db_api.image_destroy(self.context, UUID3)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'fake image #4',",
            "                         'size': 20,",
            "                         'checksum': None,",
            "                         'created_at': image_ts,",
            "                         'updated_at': image_ts}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Check a standard list, 4 images in db (2 deleted)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "",
            "        # Expect 3 images (1 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "        self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_before)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_after)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso4)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        for param in [date_only1, date_only2, date_only3]:",
            "            # Expect 3 images (1 deleted)",
            "            req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                      param)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "            images = res_dict['images']",
            "            self.assertEqual(len(images), 3)",
            "            self.assertEqual(images[0]['id'], UUID4)",
            "            self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "            self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Bad request (empty changes-since param)",
            "        req = webob.Request.blank('/images/detail?changes-since=')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_images_bad_urls(self):",
            "        \"\"\"Check that routes collections are not on (LP bug 1185828)\"\"\"",
            "        req = webob.Request.blank('/images/detail.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images/new')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members.xxx\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_get_index_filter_on_user_defined_properties(self):",
            "        \"\"\"Check that image filtering works on user-defined properties\"\"\"",
            "",
            "        image1_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'i386'}",
            "        extra_fixture = {'id': image1_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'image-extra-1',",
            "                         'size': 18, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        image2_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'x86_64', 'foo': 'bar'}",
            "        extra_fixture = {'id': image2_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'image-extra-2',",
            "                         'size': 20, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Test index with filter containing one user-defined property.",
            "        # Filter is 'property-distro=ubuntu'.",
            "        # Verify both image1 and image2 are returned",
            "        req = webob.Request.blank('/images?property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # non-existent value. Filter is 'property-distro=fedora'.",
            "        # Verify neither images are returned",
            "        req = webob.Request.blank('/images?property-distro=fedora')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=i386'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=x86_64'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property.",
            "        # Filter is 'property-foo=bar'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-foo=bar')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property but",
            "        # .value is non-existent. Filter is 'property-foo=baz'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=baz')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=x86_64&property-distro=ubuntu'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=i386&property-distro=ubuntu'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=ubuntu'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=random'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=random')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-boo=far&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-boo=far&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-foo=bar&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=bar&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "    def test_get_images_detailed_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_images_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_store_location_not_revealed(self):",
            "        \"\"\"",
            "        Test that the internal store location is NOT revealed",
            "        through the API server",
            "        \"\"\"",
            "        # Check index and details...",
            "        for url in ('/images', '/images/detail'):",
            "            req = webob.Request.blank(url)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "",
            "            images = res_dict['images']",
            "            num_locations = sum([1 for record in images",
            "                                if 'location' in record.keys()])",
            "            self.assertEqual(0, num_locations, images)",
            "",
            "        # Check GET",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check HEAD",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check PUT",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.body = res.body",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_body = jsonutils.loads(res.body)",
            "        self.assertFalse('location' in res_body['image'])",
            "",
            "        # Check POST",
            "        req = webob.Request.blank(\"/images\")",
            "        headers = {'x-image-meta-location': 'http://localhost',",
            "                   'x-image-meta-disk-format': 'vhd',",
            "                   'x-image-meta-container-format': 'ovf',",
            "                   'x-image-meta-name': 'fake image #3'}",
            "        for k, v in headers.iteritems():",
            "            req.headers[k] = v",
            "        req.method = 'POST'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)",
            "            self.assertNotIn('location', res_body['image'])",
            "",
            "    def test_image_is_checksummed(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual(image_checksum, res_body['checksum'],",
            "                         \"Mismatched checksum. Expected %s, got %s\" %",
            "                         (image_checksum, res_body['checksum']))",
            "",
            "    def test_etag_equals_checksum_header(self):",
            "        \"\"\"Test that the ETag header matches the x-image-meta-checksum\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        image = jsonutils.loads(res.body)['image']",
            "",
            "        # HEAD the image and check the ETag equals the checksum header...",
            "        expected_headers = {'x-image-meta-checksum': image_checksum,",
            "                            'etag': image_checksum}",
            "        req = webob.Request.blank(\"/images/%s\" % image['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key in expected_headers.keys():",
            "            self.assertTrue(key in res.headers,",
            "                            \"required header '%s' missing from \"",
            "                            \"returned headers\" % key)",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_bad_checksum_prevents_image_creation(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        image_contents = \"chunk00000remainder\"",
            "        bad_checksum = hashlib.md5(\"invalid\").hexdigest()",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-checksum': bad_checksum,",
            "                           'x-image-meta-is-public': 'true'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "        # Test that only one image was returned (that already exists)",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "",
            "    def test_image_meta(self):",
            "        \"\"\"Test for HEAD /images/<ID>\"\"\"",
            "        expected_headers = {'x-image-meta-id': UUID2,",
            "                            'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_image_meta_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_basic(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.content_type, 'application/octet-stream')",
            "        self.assertEqual('chunk00000remainder', res.body)",
            "",
            "    def test_show_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_show_image_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_unauthorized_download(self):",
            "        rules = {\"download_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.body, '')",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404, res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_not_allowed(self):",
            "        # Verify we can get the image data",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.headers['X-Auth-Token'] = 'user:tenant:'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "        # Verify we cannot delete the image",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "        # Verify the image data is still there",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "    def test_delete_queued_image(self):",
            "        \"\"\"Delete an image in a queued state",
            "",
            "        Bug #747799 demonstrated that trying to DELETE an image",
            "        that had had its save process killed manually results in failure",
            "        because the location attribute is None.",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_queued_image_delayed_delete(self):",
            "        \"\"\"Delete an image in a queued state when delayed_delete is on",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        self.config(delayed_delete=True)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_protected_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-protected': 'True'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image_unauthorized(self):",
            "        rules = {\"delete_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_details_invalid_marker(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns a 400",
            "        when an invalid marker is provided",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/detail?marker=%s' % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_image_members(self):",
            "        \"\"\"",
            "        Tests members listing for existing images",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_allowed_by_policy(self):",
            "        rules = {\"get_members\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_forbidden_by_policy(self):",
            "        rules = {\"get_members\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_get_image_members_not_existing(self):",
            "        \"\"\"",
            "        Tests proper exception is raised if attempt to get members of",
            "        non-existing image",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_positive(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_get_member_images(self):",
            "        \"\"\"",
            "        Tests image listing for members",
            "        \"\"\"",
            "        req = webob.Request.blank('/shared-images/pattieblack')",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['shared_images'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_replace_members(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_active_image_immutable_props_for_user(self):",
            "        \"\"\"",
            "        Tests user cannot update immutable props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                orig_value = res.headers[k]",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 403)",
            "                prop = k[len('x-image-meta-'):]",
            "                self.assertNotEqual(res.body.find(\"Forbidden to modify '%s' \"",
            "                                                  \"of active \"",
            "                                                  \"image\" % prop), -1)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(orig_value, res.headers[k])",
            "",
            "    def test_props_of_active_image_mutable_for_admin(self):",
            "        \"\"\"",
            "        Tests admin can update 'immutable' props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(v, res.headers[k])",
            "",
            "    def test_replace_members_non_existing_image(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_replace_members_bad_request(self):",
            "        \"\"\"",
            "        Tests replacing image members raises bad request if body is wrong",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_replace_members_positive(self):",
            "        \"\"\"",
            "        Tests replacing image members",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "",
            "        fixture = [dict(member_id='pattieblack', can_share=False)]",
            "        # Replace",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_replace_members_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_replace_members_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_add_member_unauthorized(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_add_member_non_existing_image(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_with_body(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        fixture = dict(can_share=True)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_overlimit(self):",
            "        self.config(image_member_quota=0)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_member_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_add_member_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_get_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests members listing for deleted image raises 404.",
            "        \"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests deleting members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_update_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests update members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_replace_members_of_image(self):",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        self.assertEqual(len(memb_list), 1)",
            "",
            "    def test_replace_members_of_image_overlimit(self):",
            "        # Set image_member_quota to 1",
            "        self.config(image_member_quota=1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        # PUT an original member entry",
            "        fixture = [{'member_id': 'baz', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # GET original image member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        original_members = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(len(original_members), 1)",
            "",
            "        # PUT 2 image members to replace existing (overlimit)",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        # GET member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Assert the member list was not changed",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, original_members)",
            "",
            "    def test_replace_members_of_image_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, fixture)",
            "",
            "    def test_create_member_to_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests adding members to deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_delete_member_on_non_existing_image(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_non_exist_member(self):",
            "        \"\"\"",
            "        Test deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/test_user' % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_image_member(self):",
            "        test_rserver = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_rserver, is_admin=True)",
            "",
            "        # Add member to image:",
            "        fixture = dict(can_share=True)",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # Delete member",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.headers['X-Auth-Token'] = 'test1:test1:'",
            "        req.method = 'DELETE'",
            "        req.content_type = 'application/json'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        self.assertTrue('Forbidden' in res.body)",
            "",
            "    def test_delete_member_allowed_by_policy(self):",
            "        rules = {\"delete_member\": '@', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_delete_member_forbidden_by_policy(self):",
            "        rules = {\"delete_member\": '!', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "",
            "class TestImageSerializer(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestImageSerializer, self).setUp()",
            "        self.receiving_user = 'fake_user'",
            "        self.receiving_tenant = 2",
            "        self.context = glance.context.RequestContext(",
            "            is_admin=True,",
            "            user=self.receiving_user,",
            "            tenant=self.receiving_tenant)",
            "        self.serializer = glance.api.v1.images.ImageSerializer()",
            "",
            "        def image_iter():",
            "            for x in ['chunk', '678911234', '56789']:",
            "                yield x",
            "",
            "        self.FIXTURE = {",
            "            'image_iterator': image_iter(),",
            "            'image_meta': {",
            "                'id': UUID2,",
            "                'name': 'fake image #2',",
            "                'status': 'active',",
            "                'disk_format': 'vhd',",
            "                'container_format': 'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': _gen_uuid(),",
            "                'location': \"file:///tmp/glance-tests/2\",",
            "                'properties': {},",
            "            }",
            "        }",
            "",
            "    def test_meta(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "    def test_meta_utf8(self):",
            "        # We get unicode strings from JSON, and therefore all strings in the",
            "        # metadata will actually be unicode when handled internally. But we",
            "        # want to output utf-8.",
            "        FIXTURE = {",
            "            'image_meta': {",
            "                'id': unicode(UUID2),",
            "                'name': u'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                'status': u'active',",
            "                'disk_format': u'vhd',",
            "                'container_format': u'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': u'06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': unicode(_gen_uuid()),",
            "                'location': u\"file:///tmp/glance-tests/2\",",
            "                'properties': {",
            "                    u'prop_\u00e9\u00e9': u'\u00e7a marche',",
            "                    u'prop_\u00e7\u00e9': u'\u00e7\u00e9',",
            "                }",
            "            }",
            "        }",
            "        exp_headers = {'x-image-meta-id': UUID2.encode('utf-8'),",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                       'x-image-meta-size': '19',  # str, not int",
            "                       'x-image-meta-name': 'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                       'x-image-meta-property-prop_\u00e9\u00e9': '\u00e7a marche',",
            "                       'x-image-meta-property-prop_\u00e7\u00e9': u'\u00e7\u00e9'.encode('utf-8')}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, FIXTURE)",
            "        self.assertNotEqual(type(FIXTURE['image_meta']['name']),",
            "                            type(response.headers['x-image-meta-name']))",
            "        self.assertEqual(response.headers['x-image-meta-name'].decode('utf-8'),",
            "                         FIXTURE['image_meta']['name'])",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        FIXTURE['image_meta']['properties'][u'prop_bad'] = '\u00e7\u00e9'",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          self.serializer.meta, response, FIXTURE)",
            "",
            "    def test_show(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.show(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        self.assertEqual(response.body, 'chunk67891123456789')",
            "",
            "    def test_show_notify(self):",
            "        \"\"\"Make sure an eventlet posthook for notify_image_sent is added.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        response.request.environ['eventlet.posthooks'] = []",
            "",
            "        self.serializer.show(response, self.FIXTURE)",
            "",
            "        #just make sure the app_iter is called",
            "        for chunk in response.app_iter:",
            "            pass",
            "",
            "        self.assertNotEqual(response.request.environ['eventlet.posthooks'], [])",
            "",
            "    def test_image_send_notification(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 19,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_info(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'info', fake_info)",
            "",
            "        glance.api.common.image_send_notification(19, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_image_send_notification_error(self):",
            "        \"\"\"Ensure image.send notification is sent on error.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 17,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_error(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'error', fake_error)",
            "",
            "        #expected and actually sent bytes differ",
            "        glance.api.common.image_send_notification(17, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_redact_location(self):",
            "        \"\"\"Ensure location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123', 'location': 'http://localhost'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "",
            "    def test_noop_redact_location(self):",
            "        \"\"\"Check no-op location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "        self.assertEqual(image_meta, redacted_image_meta)",
            "",
            "",
            "class TestFilterValidator(base.IsolatedUnitTest):",
            "    def test_filter_validator(self):",
            "        self.assertFalse(glance.api.v1.filters.validate('size_max', -1))",
            "        self.assertTrue(glance.api.v1.filters.validate('size_max', 1))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'True'))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'FALSE'))",
            "        self.assertFalse(glance.api.v1.filters.validate('protected', '-1'))",
            "",
            "",
            "class TestAPIProtectedProps(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        # turn on property protections",
            "        self.set_property_protections()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_prop_protection_with_create_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_permitted_policy_config(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_create_prop_policy': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_create_prop_policy'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_create_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify unpermitted role",
            "        'fake_member' can *not* create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        another_request.get_response(self.api)",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_show_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_show_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_get_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_get_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_detail_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'admin' can update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_default_policy': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_default_policy': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_default_policy'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_update_without_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be updated without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_only_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_only_prop': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_only_prop\", output.body)",
            "",
            "    def test_prop_protection_update_noop(self):",
            "        \"\"\"",
            "        Test protected property update is allowed as long as the user has read",
            "        access and the value is unchanged",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_read_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_prop': 'foo'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_read_prop'], 'foo')",
            "        self.assertEqual(output.status_int, 200)",
            "",
            "    def test_prop_protection_with_delete_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(output.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_delete(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without delete permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': 'foo'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_prop\", output.body)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-spl_update_prop'], 'foo')",
            "",
            "    def test_read_protected_props_leak_with_update(self):",
            "        \"\"\"",
            "        Verify when updating props that ones we don't have read permission for",
            "        are not disclosed",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': '0',",
            "             'x-image-meta-property-foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_prop': '1',",
            "                   'X-Glance-Registry-Purge-Props': 'False'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "        self.assertNotIn('foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/updatable by member.  Verify member can successfully update",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "             'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/updatable by admin, but",
            "        also readable by spl_role.  The other is readable/updatable by",
            "        spl_role.  Verify spl_role can successfully update their property but",
            "        not the admin owned one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_update_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "",
            "        # verify spl_role can update it's prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '1',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual(res_body['properties']['spl_read_only_prop'], '1')",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "",
            "        # verify spl_role can not update admin controlled prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '2',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/deletable by member.  Verify member can successfully delete",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "                'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertNotIn('x_owner_foo', res_body['properties'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_delete_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/deletable by admin, but",
            "        also readable by spl_role.  The other is readable/deletable by",
            "        spl_role.  Verify spl_role is forbidden to purge_props in this scenario",
            "        without retaining the readable prop.",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_delete_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_create_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is creatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "",
            "    def test_read_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is readable by an unknown",
            "        role",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_all_permitted': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-x_all_permitted'], '1')",
            "",
            "    def test_update_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is updatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '2')",
            "",
            "    def test_delete_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is deletable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_create_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is creatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can not create",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_permitted_admin': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_read_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is readable by no one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_none_read': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "        # also check admin can not read",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "",
            "    def test_update_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is updatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_update': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't update property",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is deletable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_delete': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't delete",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "",
            "class TestAPIPropertyQuotas(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIPropertyQuotas, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_update_image_with_too_many_properties(self):",
            "        \"\"\"",
            "        Ensure that updating image properties enforces the quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_image_with_too_many_properties_without_purge_props(self):",
            "        \"\"\"",
            "        Ensure that updating image properties counts existing image propertys",
            "        when enforcing property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_properties_without_purge_props_overwrite_value(self):",
            "        \"\"\"",
            "        Ensure that updating image properties does not count against image",
            "        property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=2)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted_create': '3',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "        self.assertEqual(res_body['properties']['x_all_permitted_create'], '3')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import datetime",
            "import hashlib",
            "import uuid",
            "",
            "import mock",
            "from oslo.config import cfg",
            "import routes",
            "import six",
            "import webob",
            "",
            "import glance.api",
            "import glance.api.common",
            "from glance.api.v1 import router",
            "from glance.api.v1 import upload_utils",
            "import glance.common.config",
            "from glance.common import exception",
            "import glance.context",
            "from glance.db.sqlalchemy import api as db_api",
            "from glance.db.sqlalchemy import models as db_models",
            "from glance.openstack.common import jsonutils",
            "from glance.openstack.common import timeutils",
            "",
            "import glance.registry.client.v1.api as registry",
            "import glance.store.filesystem",
            "from glance.store import http",
            "from glance.tests.unit import base",
            "import glance.tests.unit.utils as unit_test_utils",
            "from glance.tests import utils as test_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "_gen_uuid = lambda: str(uuid.uuid4())",
            "",
            "UUID1 = _gen_uuid()",
            "UUID2 = _gen_uuid()",
            "",
            "",
            "class TestGlanceAPI(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestGlanceAPI, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        self.FIXTURES = [",
            "            {'id': UUID1,",
            "             'name': 'fake image #1',",
            "             'status': 'active',",
            "             'disk_format': 'ami',",
            "             'container_format': 'ami',",
            "             'is_public': False,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': None,",
            "             'size': 13,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID1),",
            "                            'metadata': {}}],",
            "             'properties': {'type': 'kernel'}},",
            "            {'id': UUID2,",
            "             'name': 'fake image #2',",
            "             'status': 'active',",
            "             'disk_format': 'vhd',",
            "             'container_format': 'ovf',",
            "             'is_public': True,",
            "             'created_at': timeutils.utcnow(),",
            "             'updated_at': timeutils.utcnow(),",
            "             'deleted_at': None,",
            "             'deleted': False,",
            "             'checksum': 'abc123',",
            "             'size': 19,",
            "             'locations': [{'url': \"file:///%s/%s\" % (self.test_dir, UUID2),",
            "                            'metadata': {}}],",
            "             'properties': {}}]",
            "        self.context = glance.context.RequestContext(is_admin=True)",
            "        db_api.get_engine()",
            "        self.destroy_fixtures()",
            "        self.create_fixtures()",
            "        # Used to store/track image status changes for post-analysis",
            "        self.image_status = []",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestGlanceAPI, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def create_fixtures(self):",
            "        for fixture in self.FIXTURES:",
            "            db_api.image_create(self.context, fixture)",
            "            # We write a fake image file to the filesystem",
            "            with open(\"%s/%s\" % (self.test_dir, fixture['id']), 'wb') as image:",
            "                image.write(\"chunk00000remainder\")",
            "                image.flush()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _do_test_defaulted_format(self, format_key, format_value):",
            "        fixture_headers = {'x-image-meta-name': 'defaulted',",
            "                           'x-image-meta-location': 'http://localhost:0/image',",
            "                           format_key: format_value}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)['image']",
            "            self.assertEqual(format_value, res_body['disk_format'])",
            "            self.assertEqual(format_value, res_body['container_format'])",
            "",
            "    def test_defaulted_amazon_format(self):",
            "        for key in ('x-image-meta-disk-format',",
            "                    'x-image-meta-container-format'):",
            "            for value in ('aki', 'ari', 'ami'):",
            "                self._do_test_defaulted_format(key, value)",
            "",
            "    def test_bad_min_disk_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-disk': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_disk_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-disk'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_create(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-min-ram': '-42',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_min_ram_size_update(self):",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-min-ram'] = '-42'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid value' in res.body, res.body)",
            "",
            "    def test_bad_disk_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'invalid',",
            "            'x-image-meta-container-format': 'ami',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_disk_format_good(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'foo',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_disk_format_bad(self):",
            "        self.config(disk_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'bar',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid disk format' in res.body, res.body)",
            "",
            "    def test_configured_container_format_good(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'foo',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "",
            "    def test_configured_container_format_bad(self):",
            "        self.config(container_formats=['foo'], group=\"image_format\")",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'raw',",
            "            'x-image-meta-container-format': 'bar',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body, res.body)",
            "",
            "    def test_container_and_disk_amazon_format_differs(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'aki',",
            "            'x-image-meta-container-format': 'ami'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        expected = (\"Invalid mix of disk and container formats. \"",
            "                    \"When setting a disk or container format to one of \"",
            "                    \"'aki', 'ari', or 'ami', \"",
            "                    \"the container and disk formats must match.\")",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue(expected in res.body, res.body)",
            "",
            "    def test_create_with_location_no_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertIn('Invalid container format', res.body)",
            "",
            "    def test_create_with_bad_store_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Required store bad is invalid' in res.body)",
            "",
            "    def test_create_with_location_unknown_scheme(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'bad+scheme://localhost:0/image.qcow2',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertIn('External source are not supported', res.body)",
            "",
            "    def test_create_with_location_bad_store_uri(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'swift',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://',",
            "            'x-image-meta-disk-format': 'qcow2',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_create_image_with_too_many_properties(self):",
            "        self.config(image_property_quota=1)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images', method='POST')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 413)",
            "",
            "    def test_bad_container_format(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://localhost:0/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'invalid',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid container format' in res.body)",
            "",
            "    def test_bad_image_size(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'bogus',",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        def exec_bad_size_test(bad_size, expected_substr):",
            "            fixture_headers['x-image-meta-size'] = bad_size",
            "            req = webob.Request.blank(\"/images\",",
            "                                      method='POST',",
            "                                      headers=fixture_headers)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 400)",
            "            self.assertTrue(expected_substr in res.body)",
            "",
            "        expected = \"Cannot convert image size 'invalid' to an integer.\"",
            "        exec_bad_size_test('invalid', expected)",
            "        expected = \"Image size must be >= 0 ('-10' specified).\"",
            "        exec_bad_size_test(-10, expected)",
            "",
            "    def test_bad_image_name(self):",
            "        fixture_headers = {",
            "            'x-image-meta-store': 'bad',",
            "            'x-image-meta-name': 'X' * 256,",
            "            'x-image-meta-location': 'http://example.com/image.tar.gz',",
            "            'x-image-meta-disk-format': 'vhd',",
            "            'x-image-meta-container-format': 'bare',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_no_location_no_image_as_body(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://localhost:0/images/123'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as mocked_size:",
            "            mocked_size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        # Once the location is set, the image should be activated",
            "        # see LP Bug #939484",
            "        self.assertEqual('active', res_body['status'])",
            "        self.assertFalse('location' in res_body)  # location never shown",
            "",
            "    def test_add_image_no_location_no_content_type(self):",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1,",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_size_header_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {'x-image-meta-size': quota + 1,",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-container_format': 'bare',",
            "                           'x-image-meta-disk_format': 'qcow2',",
            "                           'content-type': 'application/octet-stream',",
            "                           }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.body = 'X' * (quota + 1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_image_size_data_exceed_quota_readd(self):",
            "        quota = 500",
            "        self.config(user_storage_quota=quota)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'bare',",
            "            'x-image-meta-disk_format': 'qcow2',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        used_size = sum([f['size'] for f in self.FIXTURES])",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.body = 'X' * (quota - used_size)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def _add_check_no_url_info(self):",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertFalse('locations' in res_body)",
            "        self.assertFalse('direct_url' in res_body)",
            "        image_id = res_body['id']",
            "",
            "        # HEAD empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('x-image-meta-locations' in res.headers)",
            "        self.assertFalse('x-image-meta-direct_url' in res.headers)",
            "",
            "    def test_add_check_no_url_info_ml(self):",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_direct_url(self):",
            "        self.config(show_image_direct_url=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_on(self):",
            "        self.config(show_image_direct_url=True)",
            "        self.config(show_multiple_locations=True)",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_check_no_url_info_both_off(self):",
            "        self._add_check_no_url_info()",
            "",
            "    def test_add_image_zero_size(self):",
            "        \"\"\"Tests creating an active image with explicitly zero size\"\"\"",
            "        fixture_headers = {'x-image-meta-disk-format': 'ami',",
            "                           'x-image-meta-container-format': 'ami',",
            "                           'x-image-meta-size': '0',",
            "                           'x-image-meta-name': 'empty image'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # GET empty image",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 0)",
            "",
            "    def _do_test_add_image_attribute_mismatch(self, attributes):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "        }",
            "        fixture_headers.update(attributes)",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"XXXX\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_checksum_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_checksum_and_size_mismatch(self):",
            "        attributes = {",
            "            'x-image-meta-checksum': 'asdf',",
            "            'x-image-meta-size': str(len(\"XXXX\") + 1),",
            "        }",
            "        self._do_test_add_image_attribute_mismatch(attributes)",
            "",
            "    def test_add_image_bad_store(self):",
            "        \"\"\"Tests raises BadRequest for invalid store header\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'bad',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_basic_file_store(self):",
            "        \"\"\"Tests to add a basic image in the file store\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        # Test that the Location: header is set to the URI to",
            "        # edit the newly-created image, as required by APP.",
            "        # See LP Bug #719825",
            "        self.assertTrue('location' in res.headers,",
            "                        \"'location' not in response headers.\\n\"",
            "                        \"res.headerlist = %r\" % res.headerlist)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertTrue('/images/%s' % res_body['id']",
            "                        in res.headers['location'])",
            "        self.assertEqual('active', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        # Test that we are NOT able to edit the Location field",
            "        # per LP Bug #911599",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-location'] = 'http://example.com/images/123'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_image_unauthorized(self):",
            "        rules = {\"add_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_publicize_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"modify_image\": '@',",
            "                 \"publicize_image\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_add_copy_from_image_authorized_upload_image_authorized(self):",
            "        rules = {\"add_image\": '@', \"copy_from\": '@', \"upload_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://glance.com/i.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "    def test_add_copy_from_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from copy-from and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_nonempty_body(self):",
            "        \"\"\"Tests creates an image from location and nonempty body\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        req.body = \"chunk00000remainder\"",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_location_with_conflict_image_size(self):",
            "        \"\"\"Tests creates an image from location and conflict image size\"\"\"",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-size': '1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 2",
            "",
            "            for k, v in fixture_headers.iteritems():",
            "                req.headers[k] = v",
            "",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 409)",
            "",
            "    def test_add_location_with_invalid_location_on_restricted_sources(self):",
            "        \"\"\"Tests creates an image from location and restricted sources\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'file:///etc/passwd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-location': 'swift+config://xxx',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_with_location(self):",
            "        \"\"\"Tests creates an image from copy-from and location\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-glance-api-copy-from': 'http://a/b/c.ovf',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F',",
            "                           'x-image-meta-location': 'http://a/b/c.tar.gz'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_add_copy_from_with_restricted_sources(self):",
            "        \"\"\"Tests creates an image from copy-from with restricted sources\"\"\"",
            "        header_template = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #F'}",
            "",
            "        schemas = [\"file:///etc/passwd\",",
            "                   \"swift+config:///xxx\",",
            "                   \"filesystem:///etc/passwd\"]",
            "",
            "        for schema in schemas:",
            "            req = webob.Request.blank(\"/images\")",
            "            req.method = 'POST'",
            "            for k, v in six.iteritems(header_template):",
            "                req.headers[k] = v",
            "            req.headers['x-glance-api-copy-from'] = schema",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(400, res.status_int)",
            "",
            "    def test_add_copy_from_upload_image_unauthorized_with_body(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-stream',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_data_upload_bad_store_uri(self):",
            "        fixture_headers = {'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.headers['x-image-meta-location'] = 'http://'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "        self.assertTrue('Invalid location' in res.body)",
            "",
            "    def test_update_data_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@'}",
            "        self.set_policy_rules(rules)",
            "        \"\"\"Tests creates a queued image for no body and no loc header\"\"\"",
            "        self.config(image_size_cap=512)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['transfer-encoding'] = 'chunked'",
            "        req.headers['x-image-disk-format'] = 'vhd'",
            "        req.headers['x-image-container-format'] = 'ovf'",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_upload_image_unauthorized(self):",
            "        rules = {\"upload_image\": '!', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_copy_from_unauthorized(self):",
            "        rules = {\"upload_image\": '@', \"modify_image\": '@',",
            "                 \"add_image\": '@', \"copy_from\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-glance-api-copy-from'] = 'http://glance.com/i.ovf'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def _do_test_post_image_content_missing_format(self, missing):",
            "        \"\"\"Tests creation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_post_image_content_missing_disk_format(self):",
            "        \"\"\"Tests creation of an image with missing disk format\"\"\"",
            "        self._do_test_post_image_content_missing_format('disk_format')",
            "",
            "    def test_post_image_content_missing_container_type(self):",
            "        \"\"\"Tests creation of an image with missing container format\"\"\"",
            "        self._do_test_post_image_content_missing_format('container_format')",
            "",
            "    def _do_test_put_image_content_missing_format(self, missing):",
            "        \"\"\"Tests delayed activation of an image with missing format\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        header = 'x-image-meta-' + missing.replace('_', '-')",
            "",
            "        del fixture_headers[header]",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "        image_id = res_body['id']",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_put_image_content_missing_disk_format(self):",
            "        \"\"\"Tests delayed activation of image with missing disk format\"\"\"",
            "        self._do_test_put_image_content_missing_format('disk_format')",
            "",
            "    def test_put_image_content_missing_container_type(self):",
            "        \"\"\"Tests delayed activation of image with missing container format\"\"\"",
            "        self._do_test_put_image_content_missing_format('container_format')",
            "",
            "    def test_update_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to update a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = {'name': 'test_del_img'}",
            "        req = webob.Request.blank('/images/%s' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to update deleted image' in res.body)",
            "",
            "    def test_delete_deleted_image(self):",
            "        \"\"\"Tests that exception raised trying to delete a deleted image\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        msg = \"Image %s not found.\" % UUID2",
            "        self.assertTrue(msg in res.body)",
            "",
            "        # Verify the status is still 'deleted'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"deleted\", res.headers['x-image-meta-status'])",
            "",
            "    @mock.patch.object(glance.store.filesystem.Store, 'delete')",
            "    def test_image_status_when_delete_fails(self, mock_fsstore_delete):",
            "        \"\"\"",
            "        Tests that the image status set to active if deletion of image fails.",
            "        \"\"\"",
            "        mock_fsstore_delete.side_effect = exception.Forbidden()",
            "",
            "        # trigger the v1 delete api",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete image' in res.body)",
            "",
            "        # check image metadata is still there with active state",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def test_delete_pending_delete_image(self):",
            "        \"\"\"",
            "        Tests that correct response returned when deleting",
            "        a pending_delete image",
            "        \"\"\"",
            "        # First deletion",
            "        self.config(delayed_delete=True, scrubber_datadir='/tmp/scrubber')",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "        # Second deletion",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "        self.assertTrue('Forbidden to delete a pending_delete image'",
            "                        in res.body)",
            "",
            "        # Verify the status is still 'pending_delete'",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(\"pending_delete\", res.headers['x-image-meta-status'])",
            "",
            "    def test_upload_to_image_status_saving(self):",
            "        \"\"\"Test image upload conflict.",
            "",
            "        If an image is uploaded before an existing upload to the same image",
            "        completes, the original upload should succeed and the conflicting",
            "        one should fail and any data be deleted.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'some-foo-image'}",
            "",
            "        # create an image but don't upload yet.",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        orig_get_image_metadata = registry.get_image_metadata",
            "        orig_image_get = db_api._image_get",
            "        orig_image_update = db_api._image_update",
            "        orig_initiate_deletion = upload_utils.initiate_deletion",
            "",
            "        # this will be used to track what is called and their order.",
            "        call_sequence = []",
            "        # use this to determine if we are within a db session i.e. atomic",
            "        # operation, that is setting our active state.",
            "        test_status = {'activate_session_started': False}",
            "        # We want first status check to be 'queued' so we get past the first",
            "        # guard.",
            "        test_status['queued_guard_passed'] = False",
            "",
            "        state_changes = []",
            "",
            "        def mock_image_update(context, values, image_id, purge_props=False,",
            "                              from_state=None):",
            "",
            "            status = values.get('status')",
            "            if status:",
            "                state_changes.append(status)",
            "                if status == 'active':",
            "                    # We only expect this state to be entered once.",
            "                    if test_status['activate_session_started']:",
            "                        raise Exception(\"target session already started\")",
            "",
            "                    test_status['activate_session_started'] = True",
            "                    call_sequence.append('update_active')",
            "",
            "                else:",
            "                    call_sequence.append('update')",
            "",
            "            return orig_image_update(context, values, image_id,",
            "                                     purge_props=purge_props,",
            "                                     from_state=from_state)",
            "",
            "        def mock_image_get(*args, **kwargs):",
            "            \"\"\"Force status to 'saving' if not within activate db session.",
            "",
            "            If we are in the activate db session we return 'active' which we",
            "            then expect to cause exception.Conflict to be raised since this",
            "            indicates that another upload has succeeded.",
            "            \"\"\"",
            "            image = orig_image_get(*args, **kwargs)",
            "            if test_status['activate_session_started']:",
            "                call_sequence.append('image_get_active')",
            "                setattr(image, 'status', 'active')",
            "            else:",
            "                setattr(image, 'status', 'saving')",
            "",
            "            return image",
            "",
            "        def mock_get_image_metadata(*args, **kwargs):",
            "            \"\"\"Force image status sequence.",
            "            \"\"\"",
            "            call_sequence.append('get_image_meta')",
            "            meta = orig_get_image_metadata(*args, **kwargs)",
            "            if not test_status['queued_guard_passed']:",
            "                meta['status'] = 'queued'",
            "                test_status['queued_guard_passed'] = True",
            "",
            "            return meta",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            call_sequence.append('init_del')",
            "            orig_initiate_deletion(*args, **kwargs)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = \\",
            "            'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "",
            "        with mock.patch.object(upload_utils, 'initiate_deletion') as \\",
            "                mock_init_del:",
            "            mock_init_del.side_effect = mock_initiate_deletion",
            "            with mock.patch.object(registry, 'get_image_metadata') as \\",
            "                    mock_get_meta:",
            "                mock_get_meta.side_effect = mock_get_image_metadata",
            "                with mock.patch.object(db_api, '_image_get') as mock_db_get:",
            "                    mock_db_get.side_effect = mock_image_get",
            "                    with mock.patch.object(db_api, '_image_update') as \\",
            "                            mock_db_update:",
            "                        mock_db_update.side_effect = mock_image_update",
            "",
            "                        # Expect a 409 Conflict.",
            "                        res = req.get_response(self.api)",
            "                        self.assertEqual(res.status_int, 409)",
            "",
            "                        # Check expected call sequence",
            "                        self.assertEqual(['get_image_meta', 'get_image_meta',",
            "                                          'update', 'update_active',",
            "                                          'image_get_active',",
            "                                          'init_del'],",
            "                                         call_sequence)",
            "",
            "                        self.assertTrue(mock_get_meta.called)",
            "                        self.assertTrue(mock_db_get.called)",
            "                        self.assertTrue(mock_db_update.called)",
            "",
            "                        # Ensure cleanup occured.",
            "                        self.assertEqual(1, mock_init_del.call_count)",
            "",
            "                        self.assertEqual(state_changes, ['saving', 'active'])",
            "",
            "    def test_register_and_upload(self):",
            "        \"\"\"",
            "        Test that the process of registering an image with",
            "        some metadata, then uploading an image file with some",
            "        more metadata doesn't mark the original metadata deleted",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now upload the image file along with some more",
            "        # metadata and verify original metadata properties",
            "        # are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the status is 'queued'",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key1' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertEqual(\"active\", res.headers['x-image-meta-status'])",
            "",
            "    def _get_image_status(self, image_id):",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        return req.get_response(self.api)",
            "",
            "    def _verify_image_status(self, image_id, status, check_deleted=False,",
            "                             use_cached=False):",
            "        if not use_cached:",
            "            res = self._get_image_status(image_id)",
            "        else:",
            "            res = self.image_status.pop(0)",
            "",
            "        self.assertEqual(200, res.status_int)",
            "        self.assertEqual(res.headers['x-image-meta-status'], status)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'],",
            "                         str(check_deleted))",
            "",
            "    def _upload_safe_kill_common(self, mocks):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(201, res.status_int)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        self.image_id = res_body['id']",
            "        self.assertTrue('/images/%s' %",
            "                        self.image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        for m in mocks:",
            "            m['mock'].side_effect = m['side_effect']",
            "",
            "        # Now upload the image file along with some more metadata and",
            "        # verify original metadata properties are not marked deleted",
            "        req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "        req.method = 'PUT'",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        # We expect 500 since an exception occured during upload.",
            "        self.assertEqual(500, res.status_int)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill(self, mock_store_add_to_backend):",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"Trigger mid-upload failure by raising an exception.\"\"\"",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "            # Raise an exception to emulate failed upload.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'killed'",
            "        self._verify_image_status(self.image_id, 'saving', use_cached=True)",
            "        self._verify_image_status(self.image_id, 'killed')",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    @mock.patch('glance.store.store_add_to_backend')",
            "    def test_upload_safe_kill_deleted(self, mock_store_add_to_backend):",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router_api,",
            "                                                 is_admin=True)",
            "",
            "        def mock_store_add_to_backend_w_exception(*args, **kwargs):",
            "            \"\"\"We now delete the image, assert status is 'deleted' then",
            "            raise an exception to emulate a failed upload. This will be caught",
            "            by upload_data_to_store() which will then try to set status to",
            "            'killed' which will be ignored since the image has been deleted.",
            "            \"\"\"",
            "            # expect 'saving'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            req = webob.Request.blank(\"/images/%s\" % self.image_id)",
            "            req.method = 'DELETE'",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(200, res.status_int)",
            "",
            "            # expect 'deleted'",
            "            self.image_status.append(self._get_image_status(self.image_id))",
            "",
            "            # Raise an exception to make the upload fail.",
            "            raise Exception(\"== UNIT TEST UPLOAD EXCEPTION ==\")",
            "",
            "        mocks = [{'mock': mock_store_add_to_backend,",
            "                 'side_effect': mock_store_add_to_backend_w_exception}]",
            "",
            "        self._upload_safe_kill_common(mocks)",
            "",
            "        # Check we went from 'saving' -> 'deleted' -> 'deleted'",
            "        self._verify_image_status(self.image_id, 'saving', check_deleted=False,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True,",
            "                                  use_cached=True)",
            "",
            "        self._verify_image_status(self.image_id, 'deleted', check_deleted=True)",
            "",
            "        self.assertEqual(1, mock_store_add_to_backend.call_count)",
            "",
            "    def test_delete_during_image_upload(self):",
            "        req = unit_test_utils.get_fake_request()",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is 'queued'",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        called = {'initiate_deletion': False}",
            "",
            "        def mock_initiate_deletion(*args, **kwargs):",
            "            called['initiate_deletion'] = True",
            "",
            "        self.stubs.Set(glance.api.v1.upload_utils, 'initiate_deletion',",
            "                       mock_initiate_deletion)",
            "",
            "        orig_update_image_metadata = registry.update_image_metadata",
            "        ctlr = glance.api.v1.controller.BaseController",
            "        orig_get_image_meta_or_404 = ctlr.get_image_meta_or_404",
            "",
            "        def mock_update_image_metadata(*args, **kwargs):",
            "",
            "            if args[2].get('status', None) == 'deleted':",
            "",
            "                # One shot.",
            "                def mock_get_image_meta_or_404(*args, **kwargs):",
            "                    ret = orig_get_image_meta_or_404(*args, **kwargs)",
            "                    ret['status'] = 'queued'",
            "                    self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                                   orig_get_image_meta_or_404)",
            "                    return ret",
            "",
            "                self.stubs.Set(ctlr, 'get_image_meta_or_404',",
            "                               mock_get_image_meta_or_404)",
            "",
            "                req = webob.Request.blank(\"/images/%s\" % image_id)",
            "                req.method = 'PUT'",
            "                req.headers['Content-Type'] = 'application/octet-stream'",
            "                req.body = \"somedata\"",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                self.stubs.Set(registry, 'update_image_metadata',",
            "                               orig_update_image_metadata)",
            "",
            "            return orig_update_image_metadata(*args, **kwargs)",
            "",
            "        self.stubs.Set(registry, 'update_image_metadata',",
            "                       mock_update_image_metadata)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        self.assertTrue(called['initiate_deletion'])",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_disable_purge_props(self):",
            "        \"\"\"",
            "        Test the special x-glance-registry-purge-props header controls",
            "        the purge property behaviour of the registry.",
            "        :see LP Bug#901534",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-property-key1': 'value1'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = \"chunk00000remainder\"",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "        res_body = jsonutils.loads(res.body)['image']",
            "",
            "        self.assertTrue('id' in res_body)",
            "",
            "        image_id = res_body['id']",
            "        self.assertTrue('/images/%s' % image_id in res.headers['location'])",
            "",
            "        # Verify the status is queued",
            "        self.assertTrue('status' in res_body)",
            "        self.assertEqual('active', res_body['status'])",
            "",
            "        # Check properties are not deleted",
            "        self.assertTrue('properties' in res_body)",
            "        self.assertTrue('key1' in res_body['properties'])",
            "        self.assertEqual('value1', res_body['properties']['key1'])",
            "",
            "        # Now update the image, setting new properties without",
            "        # passing the x-glance-registry-purge-props header and",
            "        # verify that original properties are marked deleted.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key2'] = 'value2'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the original property no longer in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertFalse('x-image-meta-property-key1' in res.headers,",
            "                         \"Found property in headers that was not expected. \"",
            "                         \"Got headers: %r\" % res.headers)",
            "",
            "        # Now update the image, setting new properties and",
            "        # passing the x-glance-registry-purge-props header with",
            "        # a value of \"false\" and verify that second property",
            "        # still appears in headers.",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-property-key3'] = 'value3'",
            "        req.headers['x-glance-registry-purge-props'] = 'false'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Verify the second and third property in headers",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'HEAD'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertTrue('x-image-meta-property-key2' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "        self.assertTrue('x-image-meta-property-key3' in res.headers,",
            "                        \"Did not find required property in headers. \"",
            "                        \"Got headers: %r\" % res.headers)",
            "",
            "    def test_publicize_image_unauthorized(self):",
            "        \"\"\"Create a non-public image then fail to make public\"\"\"",
            "        rules = {\"add_image\": '@', \"publicize_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'false',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-is-public'] = 'true'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_update_image_size_header_too_big(self):",
            "        \"\"\"Tests raises BadRequest for supplied image size that is too big\"\"\"",
            "        fixture_headers = {'x-image-meta-size': CONF.image_size_cap + 1}",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        fixture_headers = {'content-type': 'application/octet-stream'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        req.body = 'X' * (CONF.image_size_cap + 1)",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_image_size_chunked_data_too_big(self):",
            "        self.config(image_size_cap=512)",
            "",
            "        # Create new image that has no data",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        req.headers['x-image-meta-name'] = 'something'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        res = req.get_response(self.api)",
            "        image_id = jsonutils.loads(res.body)['image']['id']",
            "",
            "        fixture_headers = {",
            "            'content-type': 'application/octet-stream',",
            "            'transfer-encoding': 'chunked',",
            "        }",
            "        req = webob.Request.blank(\"/images/%s\" % image_id)",
            "        req.method = 'PUT'",
            "",
            "        req.body_file = six.StringIO('X' * (CONF.image_size_cap + 1))",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_update_non_existing_image(self):",
            "        self.config(image_size_cap=100)",
            "",
            "        req = webob.Request.blank(\"images/%s\" % _gen_uuid)",
            "        req.method = 'PUT'",
            "        req.body = 'test'",
            "        req.headers['x-image-meta-name'] = 'test'",
            "        req.headers['x-image-meta-container_format'] = 'ami'",
            "        req.headers['x-image-meta-disk_format'] = 'ami'",
            "        req.headers['x-image-meta-is_public'] = 'False'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_update_public_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-is-public': 'true',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'PUT'",
            "        req.headers['x-image-meta-name'] = 'updated public image'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "    def test_add_image_wrong_content_type(self):",
            "        fixture_headers = {",
            "            'x-image-meta-name': 'fake image #3',",
            "            'x-image-meta-container_format': 'ami',",
            "            'x-image-meta-disk_format': 'ami',",
            "            'transfer-encoding': 'chunked',",
            "            'content-type': 'application/octet-st',",
            "        }",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_index_sort_name_asc(self):",
            "        \"\"\"",
            "        Tests that the /images registry API returns list of",
            "        public images sorted alphabetically by name in",
            "        ascending order.",
            "        \"\"\"",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'asdf',",
            "                         'size': 19,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'xyz',",
            "                         'size': 20,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        req = webob.Request.blank('/images?sort_key=name&sort_dir=asc')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID3)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "        self.assertEqual(images[2]['id'], UUID4)",
            "",
            "    def test_get_details_filter_changes_since(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns list of",
            "        public images that have a size less than or equal to size_max",
            "        \"\"\"",
            "        dt1 = timeutils.utcnow() - datetime.timedelta(1)",
            "        iso1 = timeutils.isotime(dt1)",
            "",
            "        date_only1 = dt1.strftime('%Y-%m-%d')",
            "        date_only2 = dt1.strftime('%Y%m%d')",
            "        date_only3 = dt1.strftime('%Y-%m%d')",
            "",
            "        dt2 = timeutils.utcnow() + datetime.timedelta(1)",
            "        iso2 = timeutils.isotime(dt2)",
            "",
            "        image_ts = timeutils.utcnow() + datetime.timedelta(2)",
            "        hour_before = image_ts.strftime('%Y-%m-%dT%H:%M:%S%%2B01:00')",
            "        hour_after = image_ts.strftime('%Y-%m-%dT%H:%M:%S-01:00')",
            "",
            "        dt4 = timeutils.utcnow() + datetime.timedelta(3)",
            "        iso4 = timeutils.isotime(dt4)",
            "",
            "        UUID3 = _gen_uuid()",
            "        extra_fixture = {'id': UUID3,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'fake image #3',",
            "                         'size': 18,",
            "                         'checksum': None}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "        db_api.image_destroy(self.context, UUID3)",
            "",
            "        UUID4 = _gen_uuid()",
            "        extra_fixture = {'id': UUID4,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'fake image #4',",
            "                         'size': 20,",
            "                         'checksum': None,",
            "                         'created_at': image_ts,",
            "                         'updated_at': image_ts}",
            "",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Check a standard list, 4 images in db (2 deleted)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID2)",
            "",
            "        # Expect 3 images (1 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 3)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "        self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "        self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 1 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_before)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], UUID4)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                  hour_after)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Expect 0 images (0 deleted)",
            "        req = webob.Request.blank('/images/detail?changes-since=%s' % iso4)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_dict = jsonutils.loads(res.body)",
            "        images = res_dict['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        for param in [date_only1, date_only2, date_only3]:",
            "            # Expect 3 images (1 deleted)",
            "            req = webob.Request.blank('/images/detail?changes-since=%s' %",
            "                                      param)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "            images = res_dict['images']",
            "            self.assertEqual(len(images), 3)",
            "            self.assertEqual(images[0]['id'], UUID4)",
            "            self.assertEqual(images[1]['id'], UUID3)  # deleted",
            "            self.assertEqual(images[2]['id'], UUID2)",
            "",
            "        # Bad request (empty changes-since param)",
            "        req = webob.Request.blank('/images/detail?changes-since=')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_images_bad_urls(self):",
            "        \"\"\"Check that routes collections are not on (LP bug 1185828)\"\"\"",
            "        req = webob.Request.blank('/images/detail.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images.xxx')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank('/images/new')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank(\"/images/%s/members.xxx\" % UUID1)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_get_index_filter_on_user_defined_properties(self):",
            "        \"\"\"Check that image filtering works on user-defined properties\"\"\"",
            "",
            "        image1_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'i386'}",
            "        extra_fixture = {'id': image1_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'vhd',",
            "                         'container_format': 'ovf',",
            "                         'name': 'image-extra-1',",
            "                         'size': 18, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        image2_id = _gen_uuid()",
            "        properties = {'distro': 'ubuntu', 'arch': 'x86_64', 'foo': 'bar'}",
            "        extra_fixture = {'id': image2_id,",
            "                         'status': 'active',",
            "                         'is_public': True,",
            "                         'disk_format': 'ami',",
            "                         'container_format': 'ami',",
            "                         'name': 'image-extra-2',",
            "                         'size': 20, 'properties': properties,",
            "                         'checksum': None}",
            "        db_api.image_create(self.context, extra_fixture)",
            "",
            "        # Test index with filter containing one user-defined property.",
            "        # Filter is 'property-distro=ubuntu'.",
            "        # Verify both image1 and image2 are returned",
            "        req = webob.Request.blank('/images?property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 2)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "        self.assertEqual(images[1]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # non-existent value. Filter is 'property-distro=fedora'.",
            "        # Verify neither images are returned",
            "        req = webob.Request.blank('/images?property-distro=fedora')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=i386'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing one user-defined property but",
            "        # unique value. Filter is 'property-arch=x86_64'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property.",
            "        # Filter is 'property-foo=bar'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-foo=bar')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing unique user-defined property but",
            "        # .value is non-existent. Filter is 'property-foo=baz'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=baz')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=x86_64&property-distro=ubuntu'.",
            "        # Verify only image2 is returned.",
            "        req = webob.Request.blank('/images?property-arch=x86_64&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image2_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties",
            "        # Filter is 'property-arch=i386&property-distro=ubuntu'.",
            "        # Verify only image1 is returned.",
            "        req = webob.Request.blank('/images?property-arch=i386&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "        self.assertEqual(images[0]['id'], image1_id)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=ubuntu'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=ubuntu')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-arch=random&property-distro=random'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-arch=random&'",
            "                                  'property-distro=random')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-boo=far&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-boo=far&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "        # Test index with filter containing multiple user-defined properties.",
            "        # Filter is 'property-foo=bar&property-poo=far'.",
            "        # Verify neither images are returned.",
            "        req = webob.Request.blank('/images?property-foo=bar&'",
            "                                  'property-poo=far')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 0)",
            "",
            "    def test_get_images_detailed_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images/detail')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_images_unauthorized(self):",
            "        rules = {\"get_images\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank('/images')",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_store_location_not_revealed(self):",
            "        \"\"\"",
            "        Test that the internal store location is NOT revealed",
            "        through the API server",
            "        \"\"\"",
            "        # Check index and details...",
            "        for url in ('/images', '/images/detail'):",
            "            req = webob.Request.blank(url)",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 200)",
            "            res_dict = jsonutils.loads(res.body)",
            "",
            "            images = res_dict['images']",
            "            num_locations = sum([1 for record in images",
            "                                if 'location' in record.keys()])",
            "            self.assertEqual(0, num_locations, images)",
            "",
            "        # Check GET",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check HEAD",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertFalse('X-Image-Meta-Location' in res.headers)",
            "",
            "        # Check PUT",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.body = res.body",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        res_body = jsonutils.loads(res.body)",
            "        self.assertFalse('location' in res_body['image'])",
            "",
            "        # Check POST",
            "        req = webob.Request.blank(\"/images\")",
            "        headers = {'x-image-meta-location': 'http://localhost',",
            "                   'x-image-meta-disk-format': 'vhd',",
            "                   'x-image-meta-container-format': 'ovf',",
            "                   'x-image-meta-name': 'fake image #3'}",
            "        for k, v in headers.iteritems():",
            "            req.headers[k] = v",
            "        req.method = 'POST'",
            "",
            "        with mock.patch.object(http.Store, 'get_size') as size:",
            "            size.return_value = 0",
            "            res = req.get_response(self.api)",
            "            self.assertEqual(res.status_int, 201)",
            "            res_body = jsonutils.loads(res.body)",
            "            self.assertNotIn('location', res_body['image'])",
            "",
            "    def test_image_is_checksummed(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual(image_checksum, res_body['checksum'],",
            "                         \"Mismatched checksum. Expected %s, got %s\" %",
            "                         (image_checksum, res_body['checksum']))",
            "",
            "    def test_etag_equals_checksum_header(self):",
            "        \"\"\"Test that the ETag header matches the x-image-meta-checksum\"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "        image_contents = \"chunk00000remainder\"",
            "        image_checksum = hashlib.md5(image_contents).hexdigest()",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        image = jsonutils.loads(res.body)['image']",
            "",
            "        # HEAD the image and check the ETag equals the checksum header...",
            "        expected_headers = {'x-image-meta-checksum': image_checksum,",
            "                            'etag': image_checksum}",
            "        req = webob.Request.blank(\"/images/%s\" % image['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key in expected_headers.keys():",
            "            self.assertTrue(key in res.headers,",
            "                            \"required header '%s' missing from \"",
            "                            \"returned headers\" % key)",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_bad_checksum_prevents_image_creation(self):",
            "        \"\"\"Test that the image contents are checksummed properly\"\"\"",
            "        image_contents = \"chunk00000remainder\"",
            "        bad_checksum = hashlib.md5(\"invalid\").hexdigest()",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-checksum': bad_checksum,",
            "                           'x-image-meta-is-public': 'true'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "",
            "        req.headers['Content-Type'] = 'application/octet-stream'",
            "        req.body = image_contents",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "        # Test that only one image was returned (that already exists)",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        images = jsonutils.loads(res.body)['images']",
            "        self.assertEqual(len(images), 1)",
            "",
            "    def test_image_meta(self):",
            "        \"\"\"Test for HEAD /images/<ID>\"\"\"",
            "        expected_headers = {'x-image-meta-id': UUID2,",
            "                            'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        for key, value in expected_headers.iteritems():",
            "            self.assertEqual(value, res.headers[key])",
            "",
            "    def test_image_meta_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_basic(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.content_type, 'application/octet-stream')",
            "        self.assertEqual('chunk00000remainder', res.body)",
            "",
            "    def test_show_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_show_image_unauthorized(self):",
            "        rules = {\"get_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_show_image_unauthorized_download(self):",
            "        rules = {\"download_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.body, '')",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404, res.body)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_non_exists_image(self):",
            "        req = webob.Request.blank(\"/images/%s\" % _gen_uuid())",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_not_allowed(self):",
            "        # Verify we can get the image data",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.headers['X-Auth-Token'] = 'user:tenant:'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "        # Verify we cannot delete the image",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "        # Verify the image data is still there",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(len(res.body), 19)",
            "",
            "    def test_delete_queued_image(self):",
            "        \"\"\"Delete an image in a queued state",
            "",
            "        Bug #747799 demonstrated that trying to DELETE an image",
            "        that had had its save process killed manually results in failure",
            "        because the location attribute is None.",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_queued_image_delayed_delete(self):",
            "        \"\"\"Delete an image in a queued state when delayed_delete is on",
            "",
            "        Bug #1048851 demonstrated that the status was not properly",
            "        being updated to 'deleted' from 'queued'.",
            "        \"\"\"",
            "        self.config(delayed_delete=True)",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-name': 'fake image #3'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s' % res_body['id'])",
            "        req.method = 'HEAD'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        self.assertEqual(res.headers['x-image-meta-deleted'], 'True')",
            "        self.assertEqual(res.headers['x-image-meta-status'], 'deleted')",
            "",
            "    def test_delete_protected_image(self):",
            "        fixture_headers = {'x-image-meta-store': 'file',",
            "                           'x-image-meta-name': 'fake image #3',",
            "                           'x-image-meta-disk-format': 'vhd',",
            "                           'x-image-meta-container-format': 'ovf',",
            "                           'x-image-meta-protected': 'True'}",
            "",
            "        req = webob.Request.blank(\"/images\")",
            "        req.method = 'POST'",
            "        for k, v in fixture_headers.iteritems():",
            "            req.headers[k] = v",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 201)",
            "",
            "        res_body = jsonutils.loads(res.body)['image']",
            "        self.assertEqual('queued', res_body['status'])",
            "",
            "        # Now try to delete the image...",
            "        req = webob.Request.blank(\"/images/%s\" % res_body['id'])",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_delete_image_unauthorized(self):",
            "        rules = {\"delete_image\": '!'}",
            "        self.set_policy_rules(rules)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 403)",
            "",
            "    def test_get_details_invalid_marker(self):",
            "        \"\"\"",
            "        Tests that the /images/detail registry API returns a 400",
            "        when an invalid marker is provided",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/detail?marker=%s' % _gen_uuid())",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_get_image_members(self):",
            "        \"\"\"",
            "        Tests members listing for existing images",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_allowed_by_policy(self):",
            "        rules = {\"get_members\": '@'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['members'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_get_image_members_forbidden_by_policy(self):",
            "        rules = {\"get_members\": '!'}",
            "        self.set_policy_rules(rules)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_get_image_members_not_existing(self):",
            "        \"\"\"",
            "        Tests proper exception is raised if attempt to get members of",
            "        non-existing image",
            "        \"\"\"",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_positive(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_get_member_images(self):",
            "        \"\"\"",
            "        Tests image listing for members",
            "        \"\"\"",
            "        req = webob.Request.blank('/shared-images/pattieblack')",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        num_members = len(memb_list['shared_images'])",
            "        self.assertEqual(num_members, 0)",
            "",
            "    def test_replace_members(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_active_image_immutable_props_for_user(self):",
            "        \"\"\"",
            "        Tests user cannot update immutable props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=False)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                orig_value = res.headers[k]",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 403)",
            "                prop = k[len('x-image-meta-'):]",
            "                self.assertNotEqual(res.body.find(\"Forbidden to modify '%s' \"",
            "                                                  \"of active \"",
            "                                                  \"image\" % prop), -1)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(orig_value, res.headers[k])",
            "",
            "    def test_props_of_active_image_mutable_for_admin(self):",
            "        \"\"\"",
            "        Tests admin can update 'immutable' props of active image",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture_header_list = [{'x-image-meta-checksum': '1234'},",
            "                               {'x-image-meta-size': '12345'}]",
            "        for fixture_header in fixture_header_list:",
            "            req = webob.Request.blank('/images/%s' % UUID2)",
            "            req.method = 'PUT'",
            "            for k, v in fixture_header.iteritems():",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.headers[k] = v",
            "                req.method = 'PUT'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "",
            "                req = webob.Request.blank('/images/%s' % UUID2)",
            "                req.method = 'HEAD'",
            "                res = req.get_response(self.api)",
            "                self.assertEqual(res.status_int, 200)",
            "                self.assertEqual(v, res.headers[k])",
            "",
            "    def test_replace_members_non_existing_image(self):",
            "        \"\"\"",
            "        Tests replacing image members raises right exception",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "        req = webob.Request.blank('/images/%s/members' % _gen_uuid())",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_replace_members_bad_request(self):",
            "        \"\"\"",
            "        Tests replacing image members raises bad request if body is wrong",
            "        \"\"\"",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        fixture = dict(member_id='pattieblack')",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(image_memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_replace_members_positive(self):",
            "        \"\"\"",
            "        Tests replacing image members",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "",
            "        fixture = [dict(member_id='pattieblack', can_share=False)]",
            "        # Replace",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_replace_members_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_replace_members_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID1)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_add_member_unauthorized(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_add_member_non_existing_image(self):",
            "        \"\"\"",
            "        Tests adding image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_add_member_with_body(self):",
            "        \"\"\"",
            "        Tests adding image members",
            "        \"\"\"",
            "        fixture = dict(can_share=True)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_overlimit(self):",
            "        self.config(image_member_quota=0)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "    def test_add_member_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router_api = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router_api, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "    def test_add_member_forbidden_by_policy(self):",
            "        rules = {\"modify_member\": '!'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "    def test_add_member_allowed_by_policy(self):",
            "        rules = {\"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID1)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_get_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests members listing for deleted image raises 404.",
            "        \"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests deleting members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_update_members_of_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests update members of deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_replace_members_of_image(self):",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'pattieblack', 'can_share': 'false'}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)",
            "        self.assertEqual(len(memb_list), 1)",
            "",
            "    def test_replace_members_of_image_overlimit(self):",
            "        # Set image_member_quota to 1",
            "        self.config(image_member_quota=1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        # PUT an original member entry",
            "        fixture = [{'member_id': 'baz', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # GET original image member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "        original_members = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(len(original_members), 1)",
            "",
            "        # PUT 2 image members to replace existing (overlimit)",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 413)",
            "",
            "        # GET member list",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        # Assert the member list was not changed",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, original_members)",
            "",
            "    def test_replace_members_of_image_unlimited(self):",
            "        self.config(image_member_quota=-1)",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "",
            "        fixture = [{'member_id': 'foo1', 'can_share': False},",
            "                   {'member_id': 'foo2', 'can_share': False}]",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'PUT'",
            "        req.body = jsonutils.dumps(dict(memberships=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        req = webob.Request.blank('/images/%s/members' % UUID2)",
            "        req.method = 'GET'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        memb_list = jsonutils.loads(res.body)['members']",
            "        self.assertEqual(memb_list, fixture)",
            "",
            "    def test_create_member_to_deleted_image_raises_404(self):",
            "        \"\"\"",
            "        Tests adding members to deleted image raises 404.",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 200)",
            "",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNotFound.code)",
            "        self.assertTrue(",
            "            'Image with identifier %s has been deleted.' % UUID2 in res.body)",
            "",
            "    def test_delete_member(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=False)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 401)",
            "",
            "    def test_delete_member_on_non_existing_image(self):",
            "        \"\"\"",
            "        Tests deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(test_router, is_admin=True)",
            "        test_uri = '/images/%s/members/pattieblack'",
            "        req = webob.Request.blank(test_uri % _gen_uuid())",
            "        req.method = 'DELETE'",
            "",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_non_exist_member(self):",
            "        \"\"\"",
            "        Test deleting image members raises right exception",
            "        \"\"\"",
            "        test_router = router.API(self.mapper)",
            "        api = test_utils.FakeAuthMiddleware(",
            "            test_router, is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/test_user' % UUID2)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(api)",
            "        self.assertEqual(res.status_int, 404)",
            "",
            "    def test_delete_image_member(self):",
            "        test_rserver = router.API(self.mapper)",
            "        self.api = test_utils.FakeAuthMiddleware(",
            "            test_rserver, is_admin=True)",
            "",
            "        # Add member to image:",
            "        fixture = dict(can_share=True)",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(dict(member=fixture))",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 204)",
            "",
            "        # Delete member",
            "        test_uri = '/images/%s/members/test_add_member_positive'",
            "        req = webob.Request.blank(test_uri % UUID2)",
            "        req.headers['X-Auth-Token'] = 'test1:test1:'",
            "        req.method = 'DELETE'",
            "        req.content_type = 'application/json'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, 404)",
            "        self.assertTrue('Forbidden' in res.body)",
            "",
            "    def test_delete_member_allowed_by_policy(self):",
            "        rules = {\"delete_member\": '@', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "",
            "    def test_delete_member_forbidden_by_policy(self):",
            "        rules = {\"delete_member\": '!', \"modify_member\": '@'}",
            "        self.set_policy_rules(rules)",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper),",
            "                                                 is_admin=True)",
            "        req = webob.Request.blank('/images/%s/members/pattieblack' % UUID2)",
            "        req.method = 'PUT'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPNoContent.code)",
            "        req.method = 'DELETE'",
            "        res = req.get_response(self.api)",
            "        self.assertEqual(res.status_int, webob.exc.HTTPForbidden.code)",
            "",
            "",
            "class TestImageSerializer(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestImageSerializer, self).setUp()",
            "        self.receiving_user = 'fake_user'",
            "        self.receiving_tenant = 2",
            "        self.context = glance.context.RequestContext(",
            "            is_admin=True,",
            "            user=self.receiving_user,",
            "            tenant=self.receiving_tenant)",
            "        self.serializer = glance.api.v1.images.ImageSerializer()",
            "",
            "        def image_iter():",
            "            for x in ['chunk', '678911234', '56789']:",
            "                yield x",
            "",
            "        self.FIXTURE = {",
            "            'image_iterator': image_iter(),",
            "            'image_meta': {",
            "                'id': UUID2,",
            "                'name': 'fake image #2',",
            "                'status': 'active',",
            "                'disk_format': 'vhd',",
            "                'container_format': 'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': _gen_uuid(),",
            "                'location': \"file:///tmp/glance-tests/2\",",
            "                'properties': {},",
            "            }",
            "        }",
            "",
            "    def test_meta(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "    def test_meta_utf8(self):",
            "        # We get unicode strings from JSON, and therefore all strings in the",
            "        # metadata will actually be unicode when handled internally. But we",
            "        # want to output utf-8.",
            "        FIXTURE = {",
            "            'image_meta': {",
            "                'id': unicode(UUID2),",
            "                'name': u'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                'status': u'active',",
            "                'disk_format': u'vhd',",
            "                'container_format': u'ovf',",
            "                'is_public': True,",
            "                'created_at': timeutils.utcnow(),",
            "                'updated_at': timeutils.utcnow(),",
            "                'deleted_at': None,",
            "                'deleted': False,",
            "                'checksum': u'06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                'size': 19,",
            "                'owner': unicode(_gen_uuid()),",
            "                'location': u\"file:///tmp/glance-tests/2\",",
            "                'properties': {",
            "                    u'prop_\u00e9\u00e9': u'\u00e7a marche',",
            "                    u'prop_\u00e7\u00e9': u'\u00e7\u00e9',",
            "                }",
            "            }",
            "        }",
            "        exp_headers = {'x-image-meta-id': UUID2.encode('utf-8'),",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': '06ff575a2856444fbe93100157ed74ab92eb7eff',",
            "                       'x-image-meta-size': '19',  # str, not int",
            "                       'x-image-meta-name': 'fake image #2 with utf-8 \u00e9\u00e0\u00e8',",
            "                       'x-image-meta-property-prop_\u00e9\u00e9': '\u00e7a marche',",
            "                       'x-image-meta-property-prop_\u00e7\u00e9': u'\u00e7\u00e9'.encode('utf-8')}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'HEAD'",
            "        req.remote_addr = \"1.2.3.4\"",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.meta(response, FIXTURE)",
            "        self.assertNotEqual(type(FIXTURE['image_meta']['name']),",
            "                            type(response.headers['x-image-meta-name']))",
            "        self.assertEqual(response.headers['x-image-meta-name'].decode('utf-8'),",
            "                         FIXTURE['image_meta']['name'])",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        FIXTURE['image_meta']['properties'][u'prop_bad'] = '\u00e7\u00e9'",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          self.serializer.meta, response, FIXTURE)",
            "",
            "    def test_show(self):",
            "        exp_headers = {'x-image-meta-id': UUID2,",
            "                       'x-image-meta-location': 'file:///tmp/glance-tests/2',",
            "                       'ETag': self.FIXTURE['image_meta']['checksum'],",
            "                       'x-image-meta-name': 'fake image #2'}",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        self.serializer.show(response, self.FIXTURE)",
            "        for key, value in exp_headers.iteritems():",
            "            self.assertEqual(value, response.headers[key])",
            "",
            "        self.assertEqual(response.body, 'chunk67891123456789')",
            "",
            "    def test_show_notify(self):",
            "        \"\"\"Make sure an eventlet posthook for notify_image_sent is added.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.context = self.context",
            "        response = webob.Response(request=req)",
            "        response.request.environ['eventlet.posthooks'] = []",
            "",
            "        self.serializer.show(response, self.FIXTURE)",
            "",
            "        #just make sure the app_iter is called",
            "        for chunk in response.app_iter:",
            "            pass",
            "",
            "        self.assertNotEqual(response.request.environ['eventlet.posthooks'], [])",
            "",
            "    def test_image_send_notification(self):",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 19,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_info(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'info', fake_info)",
            "",
            "        glance.api.common.image_send_notification(19, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_image_send_notification_error(self):",
            "        \"\"\"Ensure image.send notification is sent on error.\"\"\"",
            "        req = webob.Request.blank(\"/images/%s\" % UUID2)",
            "        req.method = 'GET'",
            "        req.remote_addr = '1.2.3.4'",
            "        req.context = self.context",
            "",
            "        image_meta = self.FIXTURE['image_meta']",
            "        called = {\"notified\": False}",
            "        expected_payload = {",
            "            'bytes_sent': 17,",
            "            'image_id': UUID2,",
            "            'owner_id': image_meta['owner'],",
            "            'receiver_tenant_id': self.receiving_tenant,",
            "            'receiver_user_id': self.receiving_user,",
            "            'destination_ip': '1.2.3.4',",
            "        }",
            "",
            "        def fake_error(_event_type, _payload):",
            "            self.assertEqual(_payload, expected_payload)",
            "            called['notified'] = True",
            "",
            "        self.stubs.Set(self.serializer.notifier, 'error', fake_error)",
            "",
            "        #expected and actually sent bytes differ",
            "        glance.api.common.image_send_notification(17, 19, image_meta, req,",
            "                                                  self.serializer.notifier)",
            "",
            "        self.assertTrue(called['notified'])",
            "",
            "    def test_redact_location(self):",
            "        \"\"\"Ensure location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123', 'location': 'http://localhost'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "",
            "    def test_noop_redact_location(self):",
            "        \"\"\"Check no-op location redaction does not change original metadata\"\"\"",
            "        image_meta = {'size': 3, 'id': '123'}",
            "        redacted_image_meta = {'size': 3, 'id': '123'}",
            "        copy_image_meta = copy.deepcopy(image_meta)",
            "        tmp_image_meta = glance.api.v1.images.redact_loc(image_meta)",
            "",
            "        self.assertEqual(image_meta, copy_image_meta)",
            "        self.assertEqual(tmp_image_meta, redacted_image_meta)",
            "        self.assertEqual(image_meta, redacted_image_meta)",
            "",
            "",
            "class TestFilterValidator(base.IsolatedUnitTest):",
            "    def test_filter_validator(self):",
            "        self.assertFalse(glance.api.v1.filters.validate('size_max', -1))",
            "        self.assertTrue(glance.api.v1.filters.validate('size_max', 1))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'True'))",
            "        self.assertTrue(glance.api.v1.filters.validate('protected', 'FALSE'))",
            "        self.assertFalse(glance.api.v1.filters.validate('protected', '-1'))",
            "",
            "",
            "class TestAPIProtectedProps(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        # turn on property protections",
            "        self.set_property_protections()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def tearDown(self):",
            "        \"\"\"Clear the test environment\"\"\"",
            "        super(TestAPIProtectedProps, self).tearDown()",
            "        self.destroy_fixtures()",
            "",
            "    def destroy_fixtures(self):",
            "        # Easiest to just drop the models and re-create them...",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_prop_protection_with_create_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_permitted_policy_config(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify permitted role 'member' can",
            "        create a protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_create_prop_policy': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_create_prop_policy'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_create_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image and verify unpermitted role",
            "        'fake_member' can *not* create a protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_member',",
            "                   'x-image-meta-property-x_owner_foo': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        another_request.get_response(self.api)",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_show_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_show_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        HEAD",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_get_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        res2 = another_request.get_response(self.api)",
            "        self.assertEqual(res2.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_get_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        GET",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "    def test_prop_protection_with_detail_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'member' can read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'bar')",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_detail_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with a protected property, and verify",
            "        permitted role 'fake_role' can *not* read that protected property via",
            "        /images/detail",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        self._create_admin_image({'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='GET', path='/images/detail')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['images'][0]",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo',",
            "                         res_body['properties'])",
            "",
            "    def test_prop_protection_with_update_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'admin' can update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_default_policy': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-spl_default_policy': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_default_policy'], 'baz')",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_with_update_and_unpermitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        unpermitted role 'fake_role' can *not* update that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"x_owner_foo\", output.body)",
            "",
            "    def test_prop_protection_update_without_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be updated without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_only_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_only_prop': 'bar'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, webob.exc.HTTPForbidden.code)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_only_prop\", output.body)",
            "",
            "    def test_prop_protection_update_noop(self):",
            "        \"\"\"",
            "        Test protected property update is allowed as long as the user has read",
            "        access and the value is unchanged",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_read_prop': 'foo'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_prop': 'foo'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_read_prop'], 'foo')",
            "        self.assertEqual(output.status_int, 200)",
            "",
            "    def test_prop_protection_with_delete_and_permitted_role(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_permitted_policy(self):",
            "        \"\"\"",
            "        As admin role, create an image with protected property, and verify",
            "        permitted role 'member' can can delete that protected property",
            "        \"\"\"",
            "        self.set_property_protections(use_policies=True)",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_read(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without read permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_owner_foo': 'bar'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:fake_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x-image-meta-property-x_owner_foo', output.headers)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(output.headers['x-image-meta-property-x_owner_foo'],",
            "                         'bar')",
            "",
            "    def test_prop_protection_with_delete_and_unpermitted_delete(self):",
            "        \"\"\"",
            "        Test protected property cannot be deleted without delete permission",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': 'foo'})",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        self.assertIn(\"Property '%s' is protected\" %",
            "                      \"spl_update_prop\", output.body)",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-spl_update_prop'], 'foo')",
            "",
            "    def test_read_protected_props_leak_with_update(self):",
            "        \"\"\"",
            "        Verify when updating props that ones we don't have read permission for",
            "        are not disclosed",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-spl_update_prop': '0',",
            "             'x-image-meta-property-foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_update_prop': '1',",
            "                   'X-Glance-Registry-Purge-Props': 'False'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "        self.assertNotIn('foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/updatable by member.  Verify member can successfully update",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "             'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_owner_foo': 'baz'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_owner_foo'], 'baz')",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_update_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/updatable by admin, but",
            "        also readable by spl_role.  The other is readable/updatable by",
            "        spl_role.  Verify spl_role can successfully update their property but",
            "        not the admin owned one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_update_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "",
            "        # verify spl_role can update it's prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '1',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual(res_body['properties']['spl_read_only_prop'], '1')",
            "        self.assertEqual(res_body['properties']['spl_update_prop'], '1')",
            "",
            "        # verify spl_role can not update admin controlled prop",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'x-image-meta-property-spl_read_only_prop': '2',",
            "                   'x-image-meta-property-spl_update_prop': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_protected_props_mix_no_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one only readable by admin, and one",
            "        readable/deletable by member.  Verify member can successfully delete",
            "        their property while the admin owned one is ignored transparently",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-admin_foo': 'bar',",
            "                'x-image-meta-property-x_owner_foo': 'bar'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertNotIn('x_owner_foo', res_body['properties'])",
            "        self.assertNotIn('admin_foo', res_body['properties'])",
            "",
            "    def test_delete_protected_props_mix_read(self):",
            "        \"\"\"",
            "        Create an image with two props - one readable/deletable by admin, but",
            "        also readable by spl_role.  The other is readable/deletable by",
            "        spl_role.  Verify spl_role is forbidden to purge_props in this scenario",
            "        without retaining the readable prop.",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-spl_read_only_prop': '1',",
            "            'x-image-meta-property-spl_delete_prop': '2'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:spl_role',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_create_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is creatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "",
            "    def test_read_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is readable by an unknown",
            "        role",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_all_permitted': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertEqual('', output.body)",
            "        self.assertEqual(",
            "            output.headers['x-image-meta-property-x_all_permitted'], '1')",
            "",
            "    def test_update_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is updatable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '2')",
            "",
            "    def test_delete_non_protected_prop(self):",
            "        \"\"\"",
            "        Verify property marked with special char '@' is deletable by an unknown",
            "        role",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_all_permitted': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties'], {})",
            "",
            "    def test_create_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is creatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can not create",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_permitted_admin': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_read_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is readable by no one",
            "        \"\"\"",
            "        custom_props = {",
            "            'x-image-meta-property-x_none_read': '1'",
            "        }",
            "        image_id = self._create_admin_image(custom_props)",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:member'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "        # also check admin can not read",
            "        another_request = unit_test_utils.get_fake_request(",
            "            method='HEAD', path='/images/%s' % image_id)",
            "        headers = {'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 200)",
            "        self.assertNotIn('x_none_read', output.headers)",
            "",
            "    def test_update_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is updatable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_update': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't update property",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'x-image-meta-property-x_none_update': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "    def test_delete_locked_down_protected_prop(self):",
            "        \"\"\"",
            "        Verify a property protected by special char '!' is deletable by no one",
            "        \"\"\"",
            "        image_id = self._create_admin_image(",
            "            {'x-image-meta-property-x_none_delete': '1'})",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:member',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "        # also check admin can't delete",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:admin',",
            "                   'X-Glance-Registry-Purge-Props': 'True'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "        output = another_request.get_response(self.api)",
            "        self.assertEqual(output.status_int, 403)",
            "",
            "",
            "class TestAPIPropertyQuotas(base.IsolatedUnitTest):",
            "    def setUp(self):",
            "        \"\"\"Establish a clean test environment\"\"\"",
            "        super(TestAPIPropertyQuotas, self).setUp()",
            "        self.mapper = routes.Mapper()",
            "        self.api = test_utils.FakeAuthMiddleware(router.API(self.mapper))",
            "        db_api.get_engine()",
            "        db_models.unregister_models(db_api.get_engine())",
            "        db_models.register_models(db_api.get_engine())",
            "",
            "    def _create_admin_image(self, props={}):",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        headers.update(props)",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "        return image_id",
            "",
            "    def test_update_image_with_too_many_properties(self):",
            "        \"\"\"",
            "        Ensure that updating image properties enforces the quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        image_id = self._create_admin_image()",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-image-meta-property-x_all_permitted': '1',",
            "                   'x-image-meta-property-x_all_permitted_foo': '2'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_image_with_too_many_properties_without_purge_props(self):",
            "        \"\"\"",
            "        Ensure that updating image properties counts existing image propertys",
            "        when enforcing property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=1)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 413)",
            "        self.assertTrue(\"Attempted: 2, Maximum: 1\" in output.text)",
            "",
            "    def test_update_properties_without_purge_props_overwrite_value(self):",
            "        \"\"\"",
            "        Ensure that updating image properties does not count against image",
            "        property quota.",
            "        \"\"\"",
            "        self.config(image_property_quota=2)",
            "        request = unit_test_utils.get_fake_request(path='/images')",
            "        headers = {'x-image-meta-disk-format': 'ami',",
            "                   'x-image-meta-container-format': 'ami',",
            "                   'x-image-meta-name': 'foo',",
            "                   'x-image-meta-size': '0',",
            "                   'x-image-meta-property-x_all_permitted_create': '1',",
            "                   'x-auth-token': 'user:tenant:admin'}",
            "        for k, v in headers.iteritems():",
            "            request.headers[k] = v",
            "        created_image = request.get_response(self.api)",
            "        res_body = jsonutils.loads(created_image.body)['image']",
            "        image_id = res_body['id']",
            "",
            "        another_request = unit_test_utils.get_fake_request(",
            "            path='/images/%s' % image_id, method='PUT')",
            "        headers = {'x-auth-token': 'user:tenant:joe_soap',",
            "                   'x-glance-registry-purge-props': 'False',",
            "                   'x-image-meta-property-x_all_permitted_create': '3',",
            "                   'x-image-meta-property-x_all_permitted': '1'}",
            "        for k, v in headers.iteritems():",
            "            another_request.headers[k] = v",
            "",
            "        output = another_request.get_response(self.api)",
            "",
            "        self.assertEqual(output.status_int, 200)",
            "        res_body = jsonutils.loads(output.body)['image']",
            "        self.assertEqual(res_body['properties']['x_all_permitted'], '1')",
            "        self.assertEqual(res_body['properties']['x_all_permitted_create'], '3')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1013": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1015": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1019": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1020": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1021": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1022": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1023": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1024": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1025": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1026": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1027": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1028": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1029": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1030": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1032": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1033": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1034": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1035": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1036": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ],
            "1037": [
                "TestGlanceAPI",
                "test_add_copy_from_with_restricted_sources"
            ]
        },
        "addLocation": []
    }
}