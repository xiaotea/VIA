{
    "saleor/checkout/error_codes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     EMAIL_NOT_SET = \"email_not_set\""
            },
            "1": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     NO_LINES = \"no_lines\""
            },
            "2": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     INACTIVE_PAYMENT = \"inactive_payment\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    SHIPPING_CHANGE_FORBIDDEN = \"shipping_change_forbidden\""
            },
            "4": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " class OrderCreateFromCheckoutErrorCode(Enum):"
            }
        },
        "frontPatchFile": [
            "from enum import Enum",
            "",
            "",
            "class CheckoutErrorCode(Enum):",
            "    BILLING_ADDRESS_NOT_SET = \"billing_address_not_set\"",
            "    CHECKOUT_NOT_FULLY_PAID = \"checkout_not_fully_paid\"",
            "    GRAPHQL_ERROR = \"graphql_error\"",
            "    PRODUCT_NOT_PUBLISHED = \"product_not_published\"",
            "    PRODUCT_UNAVAILABLE_FOR_PURCHASE = \"product_unavailable_for_purchase\"",
            "    INSUFFICIENT_STOCK = \"insufficient_stock\"",
            "    INVALID = \"invalid\"",
            "    INVALID_SHIPPING_METHOD = \"invalid_shipping_method\"",
            "    NOT_FOUND = \"not_found\"",
            "    PAYMENT_ERROR = \"payment_error\"",
            "    QUANTITY_GREATER_THAN_LIMIT = \"quantity_greater_than_limit\"",
            "    REQUIRED = \"required\"",
            "    SHIPPING_ADDRESS_NOT_SET = \"shipping_address_not_set\"",
            "    SHIPPING_METHOD_NOT_APPLICABLE = \"shipping_method_not_applicable\"",
            "    DELIVERY_METHOD_NOT_APPLICABLE = \"delivery_method_not_applicable\"",
            "    SHIPPING_METHOD_NOT_SET = \"shipping_method_not_set\"",
            "    SHIPPING_NOT_REQUIRED = \"shipping_not_required\"",
            "    TAX_ERROR = \"tax_error\"",
            "    UNIQUE = \"unique\"",
            "    VOUCHER_NOT_APPLICABLE = \"voucher_not_applicable\"",
            "    GIFT_CARD_NOT_APPLICABLE = \"gift_card_not_applicable\"",
            "    ZERO_QUANTITY = \"zero_quantity\"",
            "    MISSING_CHANNEL_SLUG = \"missing_channel_slug\"",
            "    CHANNEL_INACTIVE = \"channel_inactive\"",
            "    UNAVAILABLE_VARIANT_IN_CHANNEL = \"unavailable_variant_in_channel\"",
            "    EMAIL_NOT_SET = \"email_not_set\"",
            "    NO_LINES = \"no_lines\"",
            "    INACTIVE_PAYMENT = \"inactive_payment\"",
            "",
            "",
            "class OrderCreateFromCheckoutErrorCode(Enum):",
            "    GRAPHQL_ERROR = \"graphql_error\"",
            "    CHECKOUT_NOT_FOUND = \"checkout_not_found\"",
            "    CHANNEL_INACTIVE = \"channel_inactive\"",
            "    INSUFFICIENT_STOCK = \"insufficient_stock\"",
            "    VOUCHER_NOT_APPLICABLE = \"voucher_not_applicable\"",
            "    GIFT_CARD_NOT_APPLICABLE = \"gift_card_not_applicable\"",
            "    TAX_ERROR = \"tax_error\"",
            "    SHIPPING_METHOD_NOT_SET = \"shipping_method_not_set\"",
            "    BILLING_ADDRESS_NOT_SET = \"billing_address_not_set\"",
            "    SHIPPING_ADDRESS_NOT_SET = \"shipping_address_not_set\"",
            "    INVALID_SHIPPING_METHOD = \"invalid_shipping_method\"",
            "    NO_LINES = \"no_lines\"",
            "    EMAIL_NOT_SET = \"email_not_set\"",
            "    UNAVAILABLE_VARIANT_IN_CHANNEL = \"unavailable_variant_in_channel\"",
            "",
            "",
            "class CheckoutCreateFromOrderErrorCode(Enum):",
            "    GRAPHQL_ERROR = \"graphql_error\"",
            "    INVALID = \"invalid\"",
            "    ORDER_NOT_FOUND = \"order_not_found\"",
            "    CHANNEL_INACTIVE = \"channel_inactive\"",
            "    TAX_ERROR = \"tax_error\"",
            "",
            "",
            "class CheckoutCreateFromOrderUnavailableVariantErrorCode(Enum):",
            "    NOT_FOUND = \"not_found\"",
            "    PRODUCT_UNAVAILABLE_FOR_PURCHASE = \"product_unavailable_for_purchase\"",
            "    UNAVAILABLE_VARIANT_IN_CHANNEL = \"unavailable_variant_in_channel\"",
            "    PRODUCT_NOT_PUBLISHED = \"product_not_published\"",
            "    QUANTITY_GREATER_THAN_LIMIT = \"quantity_greater_than_limit\"",
            "    INSUFFICIENT_STOCK = \"insufficient_stock\""
        ],
        "afterPatchFile": [
            "from enum import Enum",
            "",
            "",
            "class CheckoutErrorCode(Enum):",
            "    BILLING_ADDRESS_NOT_SET = \"billing_address_not_set\"",
            "    CHECKOUT_NOT_FULLY_PAID = \"checkout_not_fully_paid\"",
            "    GRAPHQL_ERROR = \"graphql_error\"",
            "    PRODUCT_NOT_PUBLISHED = \"product_not_published\"",
            "    PRODUCT_UNAVAILABLE_FOR_PURCHASE = \"product_unavailable_for_purchase\"",
            "    INSUFFICIENT_STOCK = \"insufficient_stock\"",
            "    INVALID = \"invalid\"",
            "    INVALID_SHIPPING_METHOD = \"invalid_shipping_method\"",
            "    NOT_FOUND = \"not_found\"",
            "    PAYMENT_ERROR = \"payment_error\"",
            "    QUANTITY_GREATER_THAN_LIMIT = \"quantity_greater_than_limit\"",
            "    REQUIRED = \"required\"",
            "    SHIPPING_ADDRESS_NOT_SET = \"shipping_address_not_set\"",
            "    SHIPPING_METHOD_NOT_APPLICABLE = \"shipping_method_not_applicable\"",
            "    DELIVERY_METHOD_NOT_APPLICABLE = \"delivery_method_not_applicable\"",
            "    SHIPPING_METHOD_NOT_SET = \"shipping_method_not_set\"",
            "    SHIPPING_NOT_REQUIRED = \"shipping_not_required\"",
            "    TAX_ERROR = \"tax_error\"",
            "    UNIQUE = \"unique\"",
            "    VOUCHER_NOT_APPLICABLE = \"voucher_not_applicable\"",
            "    GIFT_CARD_NOT_APPLICABLE = \"gift_card_not_applicable\"",
            "    ZERO_QUANTITY = \"zero_quantity\"",
            "    MISSING_CHANNEL_SLUG = \"missing_channel_slug\"",
            "    CHANNEL_INACTIVE = \"channel_inactive\"",
            "    UNAVAILABLE_VARIANT_IN_CHANNEL = \"unavailable_variant_in_channel\"",
            "    EMAIL_NOT_SET = \"email_not_set\"",
            "    NO_LINES = \"no_lines\"",
            "    INACTIVE_PAYMENT = \"inactive_payment\"",
            "    SHIPPING_CHANGE_FORBIDDEN = \"shipping_change_forbidden\"",
            "",
            "",
            "class OrderCreateFromCheckoutErrorCode(Enum):",
            "    GRAPHQL_ERROR = \"graphql_error\"",
            "    CHECKOUT_NOT_FOUND = \"checkout_not_found\"",
            "    CHANNEL_INACTIVE = \"channel_inactive\"",
            "    INSUFFICIENT_STOCK = \"insufficient_stock\"",
            "    VOUCHER_NOT_APPLICABLE = \"voucher_not_applicable\"",
            "    GIFT_CARD_NOT_APPLICABLE = \"gift_card_not_applicable\"",
            "    TAX_ERROR = \"tax_error\"",
            "    SHIPPING_METHOD_NOT_SET = \"shipping_method_not_set\"",
            "    BILLING_ADDRESS_NOT_SET = \"billing_address_not_set\"",
            "    SHIPPING_ADDRESS_NOT_SET = \"shipping_address_not_set\"",
            "    INVALID_SHIPPING_METHOD = \"invalid_shipping_method\"",
            "    NO_LINES = \"no_lines\"",
            "    EMAIL_NOT_SET = \"email_not_set\"",
            "    UNAVAILABLE_VARIANT_IN_CHANNEL = \"unavailable_variant_in_channel\"",
            "",
            "",
            "class CheckoutCreateFromOrderErrorCode(Enum):",
            "    GRAPHQL_ERROR = \"graphql_error\"",
            "    INVALID = \"invalid\"",
            "    ORDER_NOT_FOUND = \"order_not_found\"",
            "    CHANNEL_INACTIVE = \"channel_inactive\"",
            "    TAX_ERROR = \"tax_error\"",
            "",
            "",
            "class CheckoutCreateFromOrderUnavailableVariantErrorCode(Enum):",
            "    NOT_FOUND = \"not_found\"",
            "    PRODUCT_UNAVAILABLE_FOR_PURCHASE = \"product_unavailable_for_purchase\"",
            "    UNAVAILABLE_VARIANT_IN_CHANNEL = \"unavailable_variant_in_channel\"",
            "    PRODUCT_NOT_PUBLISHED = \"product_not_published\"",
            "    QUANTITY_GREATER_THAN_LIMIT = \"quantity_greater_than_limit\"",
            "    INSUFFICIENT_STOCK = \"insufficient_stock\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "saleor.checkout.error_codes.CheckoutErrorCode.self"
        ]
    },
    "saleor/graphql/checkout/mutations/checkout_delivery_method_update.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from ....shipping import interface as shipping_interface"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from ....shipping import models as shipping_models"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from ....shipping.utils import convert_to_shipping_method_data"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from ....warehouse import WarehouseClickAndCollectOption"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from ....warehouse import models as warehouse_models"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from ....webhook.const import APP_ID_PREFIX"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from ....webhook.event_types import WebhookEventAsyncType, WebhookEventSyncType"
            },
            "7": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     class Meta:"
            },
            "8": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         description = ("
            },
            "9": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             \"Updates the delivery method (shipping method or pick up point) \""
            },
            "10": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"of the checkout.\" + ADDED_IN_31"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            \"of the checkout. \""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            \"Updates the checkout shipping_address for click and collect delivery \""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            \"for a warehouse address. \" + ADDED_IN_31"
            },
            "14": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         )"
            },
            "15": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         doc_category = DOC_CATEGORY_CHECKOUT"
            },
            "16": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         error_type_class = CheckoutError"
            },
            "17": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         external_shipping_method: Optional[shipping_interface.ShippingMethodData],"
            },
            "18": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         collection_point: Optional[Warehouse],"
            },
            "19": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "     ) -> None:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+        checkout_fields_to_update = [\"shipping_method\", \"collection_point\"]"
            },
            "21": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         checkout = checkout_info.checkout"
            },
            "22": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "         if external_shipping_method:"
            },
            "23": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             set_external_shipping_id("
            },
            "24": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "             delete_external_shipping_id(checkout=checkout)"
            },
            "25": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         checkout.shipping_method = shipping_method"
            },
            "26": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         checkout.collection_point = collection_point"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        if ("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+            collection_point is not None"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+            and collection_point.click_and_collect_option"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+            == WarehouseClickAndCollectOption.LOCAL_STOCK"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+        ):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+            checkout.shipping_address = collection_point.address"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+            checkout_info.shipping_address = collection_point.address"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+            checkout_fields_to_update += [\"shipping_address\"]"
            },
            "35": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         invalidate_prices_updated_fields = invalidate_checkout_prices("
            },
            "36": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "             checkout_info, lines, manager, save=False"
            },
            "37": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         )"
            },
            "38": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "         checkout.save("
            },
            "39": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            update_fields=["
            },
            "40": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"shipping_method\","
            },
            "41": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"collection_point\","
            },
            "42": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ]"
            },
            "43": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            + invalidate_prices_updated_fields"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+            update_fields=checkout_fields_to_update + invalidate_prices_updated_fields"
            },
            "45": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "         )"
            },
            "46": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "         get_or_create_checkout_metadata(checkout).save()"
            },
            "47": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         cls.call_event(manager.checkout_updated, checkout)"
            },
            "48": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "                 }"
            },
            "49": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "             )"
            },
            "50": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         type_name = cls._resolve_delivery_method_type(delivery_method_id)"
            },
            "51": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "52": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         checkout_info = fetch_checkout_info(checkout, lines, manager)"
            },
            "53": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         if type_name == \"Warehouse\":"
            },
            "54": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "             return cls.perform_on_collection_point("
            }
        },
        "frontPatchFile": [
            "from collections.abc import Iterable",
            "from typing import Optional",
            "",
            "import graphene",
            "from django.core.exceptions import ValidationError",
            "",
            "from ....checkout.error_codes import CheckoutErrorCode",
            "from ....checkout.fetch import (",
            "    CheckoutInfo,",
            "    CheckoutLineInfo,",
            "    fetch_checkout_info,",
            "    fetch_checkout_lines,",
            ")",
            "from ....checkout.utils import (",
            "    delete_external_shipping_id,",
            "    get_or_create_checkout_metadata,",
            "    invalidate_checkout_prices,",
            "    is_shipping_required,",
            "    set_external_shipping_id,",
            ")",
            "from ....shipping import interface as shipping_interface",
            "from ....shipping import models as shipping_models",
            "from ....shipping.utils import convert_to_shipping_method_data",
            "from ....warehouse import models as warehouse_models",
            "from ....webhook.const import APP_ID_PREFIX",
            "from ....webhook.event_types import WebhookEventAsyncType, WebhookEventSyncType",
            "from ...core import ResolveInfo",
            "from ...core.descriptions import ADDED_IN_31, ADDED_IN_34, DEPRECATED_IN_3X_INPUT",
            "from ...core.doc_category import DOC_CATEGORY_CHECKOUT",
            "from ...core.mutations import BaseMutation",
            "from ...core.scalars import UUID",
            "from ...core.types import CheckoutError",
            "from ...core.utils import WebhookEventInfo, from_global_id_or_error",
            "from ...plugins.dataloaders import get_plugin_manager_promise",
            "from ...shipping.types import ShippingMethod",
            "from ...warehouse.types import Warehouse",
            "from ..types import Checkout",
            "from .utils import ERROR_DOES_NOT_SHIP, clean_delivery_method, get_checkout",
            "",
            "",
            "class CheckoutDeliveryMethodUpdate(BaseMutation):",
            "    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")",
            "",
            "    class Arguments:",
            "        id = graphene.ID(",
            "            description=\"The checkout's ID.\" + ADDED_IN_34,",
            "            required=False,",
            "        )",
            "        token = UUID(",
            "            description=f\"Checkout token.{DEPRECATED_IN_3X_INPUT} Use `id` instead.\",",
            "            required=False,",
            "        )",
            "",
            "        delivery_method_id = graphene.ID(",
            "            description=\"Delivery Method ID (`Warehouse` ID or `ShippingMethod` ID).\",",
            "            required=False,",
            "        )",
            "",
            "    class Meta:",
            "        description = (",
            "            \"Updates the delivery method (shipping method or pick up point) \"",
            "            \"of the checkout.\" + ADDED_IN_31",
            "        )",
            "        doc_category = DOC_CATEGORY_CHECKOUT",
            "        error_type_class = CheckoutError",
            "        webhook_events_info = [",
            "            WebhookEventInfo(",
            "                type=WebhookEventSyncType.SHIPPING_LIST_METHODS_FOR_CHECKOUT,",
            "                description=(",
            "                    \"Triggered when updating the checkout delivery method with \"",
            "                    \"the external one.\"",
            "                ),",
            "            ),",
            "            WebhookEventInfo(",
            "                type=WebhookEventAsyncType.CHECKOUT_UPDATED,",
            "                description=\"A checkout was updated.\",",
            "            ),",
            "        ]",
            "",
            "    @classmethod",
            "    def perform_on_shipping_method(",
            "        cls,",
            "        info: ResolveInfo,",
            "        shipping_method_id,",
            "        checkout_info,",
            "        lines,",
            "        checkout,",
            "        manager,",
            "    ):",
            "        shipping_method = cls.get_node_or_error(",
            "            info,",
            "            shipping_method_id,",
            "            only_type=ShippingMethod,",
            "            field=\"delivery_method_id\",",
            "            qs=shipping_models.ShippingMethod.objects.prefetch_related(",
            "                \"postal_code_rules\"",
            "            ),",
            "        )",
            "",
            "        listing = shipping_models.ShippingMethodChannelListing.objects.filter(",
            "            shipping_method=shipping_method,",
            "            channel=checkout_info.channel,",
            "        ).first()",
            "        if not listing:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        \"This shipping method is not applicable in the given channel.\",",
            "                        code=CheckoutErrorCode.DELIVERY_METHOD_NOT_APPLICABLE.value,",
            "                    )",
            "                }",
            "            )",
            "        delivery_method = convert_to_shipping_method_data(shipping_method, listing)",
            "",
            "        cls._check_delivery_method(",
            "            checkout_info, lines, shipping_method=delivery_method, collection_point=None",
            "        )",
            "",
            "        cls._update_delivery_method(",
            "            manager,",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=shipping_method,",
            "            external_shipping_method=None,",
            "            collection_point=None,",
            "        )",
            "        return CheckoutDeliveryMethodUpdate(checkout=checkout)",
            "",
            "    @classmethod",
            "    def perform_on_external_shipping_method(",
            "        cls,",
            "        info: ResolveInfo,",
            "        shipping_method_id,",
            "        checkout_info,",
            "        lines,",
            "        checkout,",
            "        manager,",
            "    ):",
            "        delivery_method = manager.get_shipping_method(",
            "            checkout=checkout,",
            "            channel_slug=checkout.channel.slug,",
            "            shipping_method_id=shipping_method_id,",
            "        )",
            "",
            "        if delivery_method is None and shipping_method_id:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        f\"Couldn't resolve to a node: ${shipping_method_id}\",",
            "                        code=CheckoutErrorCode.NOT_FOUND.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "        cls._check_delivery_method(",
            "            checkout_info, lines, shipping_method=delivery_method, collection_point=None",
            "        )",
            "",
            "        cls._update_delivery_method(",
            "            manager,",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=None,",
            "            external_shipping_method=delivery_method,",
            "            collection_point=None,",
            "        )",
            "        return CheckoutDeliveryMethodUpdate(checkout=checkout)",
            "",
            "    @classmethod",
            "    def perform_on_collection_point(",
            "        cls,",
            "        info: ResolveInfo,",
            "        collection_point_id,",
            "        checkout_info,",
            "        lines,",
            "        checkout,",
            "        manager,",
            "    ):",
            "        collection_point = cls.get_node_or_error(",
            "            info,",
            "            collection_point_id,",
            "            only_type=Warehouse,",
            "            field=\"delivery_method_id\",",
            "            qs=warehouse_models.Warehouse.objects.select_related(\"address\"),",
            "        )",
            "        cls._check_delivery_method(",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=None,",
            "            collection_point=collection_point,",
            "        )",
            "        cls._update_delivery_method(",
            "            manager,",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=None,",
            "            external_shipping_method=None,",
            "            collection_point=collection_point,",
            "        )",
            "        return CheckoutDeliveryMethodUpdate(checkout=checkout)",
            "",
            "    @staticmethod",
            "    def _check_delivery_method(",
            "        checkout_info,",
            "        lines,",
            "        *,",
            "        shipping_method: Optional[shipping_interface.ShippingMethodData],",
            "        collection_point: Optional[Warehouse],",
            "    ) -> None:",
            "        delivery_method = shipping_method",
            "        error_msg = \"This shipping method is not applicable.\"",
            "",
            "        if collection_point is not None:",
            "            delivery_method = collection_point",
            "            error_msg = \"This pick up point is not applicable.\"",
            "",
            "        delivery_method_is_valid = clean_delivery_method(",
            "            checkout_info=checkout_info, lines=lines, method=delivery_method",
            "        )",
            "        if not delivery_method_is_valid:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        error_msg,",
            "                        code=CheckoutErrorCode.DELIVERY_METHOD_NOT_APPLICABLE.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "    @classmethod",
            "    def _update_delivery_method(",
            "        cls,",
            "        manager,",
            "        checkout_info: \"CheckoutInfo\",",
            "        lines: Iterable[\"CheckoutLineInfo\"],",
            "        *,",
            "        shipping_method: Optional[ShippingMethod],",
            "        external_shipping_method: Optional[shipping_interface.ShippingMethodData],",
            "        collection_point: Optional[Warehouse],",
            "    ) -> None:",
            "        checkout = checkout_info.checkout",
            "        if external_shipping_method:",
            "            set_external_shipping_id(",
            "                checkout=checkout, app_shipping_id=external_shipping_method.id",
            "            )",
            "        else:",
            "            delete_external_shipping_id(checkout=checkout)",
            "        checkout.shipping_method = shipping_method",
            "        checkout.collection_point = collection_point",
            "        invalidate_prices_updated_fields = invalidate_checkout_prices(",
            "            checkout_info, lines, manager, save=False",
            "        )",
            "        checkout.save(",
            "            update_fields=[",
            "                \"shipping_method\",",
            "                \"collection_point\",",
            "            ]",
            "            + invalidate_prices_updated_fields",
            "        )",
            "        get_or_create_checkout_metadata(checkout).save()",
            "        cls.call_event(manager.checkout_updated, checkout)",
            "",
            "    @staticmethod",
            "    def _resolve_delivery_method_type(id_) -> Optional[str]:",
            "        if id_ is None:",
            "            return None",
            "",
            "        possible_types = (\"Warehouse\", \"ShippingMethod\", APP_ID_PREFIX)",
            "        type_, id_ = from_global_id_or_error(id_)",
            "        str_type = str(type_)",
            "",
            "        if str_type not in possible_types:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        \"ID does not belong to Warehouse or ShippingMethod\",",
            "                        code=CheckoutErrorCode.INVALID.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "        return str_type",
            "",
            "    @classmethod",
            "    def perform_mutation(",
            "        cls,",
            "        _root,",
            "        info,",
            "        /,",
            "        token=None,",
            "        id=None,",
            "        delivery_method_id=None,",
            "    ):",
            "        checkout = get_checkout(cls, info, checkout_id=None, token=token, id=id)",
            "",
            "        use_legacy_error_flow_for_checkout = (",
            "            checkout.channel.use_legacy_error_flow_for_checkout",
            "        )",
            "",
            "        manager = get_plugin_manager_promise(info.context).get()",
            "        lines, unavailable_variant_pks = fetch_checkout_lines(checkout)",
            "        if use_legacy_error_flow_for_checkout and unavailable_variant_pks:",
            "            not_available_variants_ids = {",
            "                graphene.Node.to_global_id(\"ProductVariant\", pk)",
            "                for pk in unavailable_variant_pks",
            "            }",
            "            raise ValidationError(",
            "                {",
            "                    \"lines\": ValidationError(",
            "                        \"Some of the checkout lines variants are unavailable.\",",
            "                        code=CheckoutErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL.value,",
            "                        params={\"variants\": not_available_variants_ids},",
            "                    )",
            "                }",
            "            )",
            "",
            "        if use_legacy_error_flow_for_checkout and not is_shipping_required(lines):",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method\": ValidationError(",
            "                        ERROR_DOES_NOT_SHIP,",
            "                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value,",
            "                    )",
            "                }",
            "            )",
            "        type_name = cls._resolve_delivery_method_type(delivery_method_id)",
            "",
            "        checkout_info = fetch_checkout_info(checkout, lines, manager)",
            "        if type_name == \"Warehouse\":",
            "            return cls.perform_on_collection_point(",
            "                info, delivery_method_id, checkout_info, lines, checkout, manager",
            "            )",
            "        if type_name == \"ShippingMethod\":",
            "            return cls.perform_on_shipping_method(",
            "                info, delivery_method_id, checkout_info, lines, checkout, manager",
            "            )",
            "        return cls.perform_on_external_shipping_method(",
            "            info, delivery_method_id, checkout_info, lines, checkout, manager",
            "        )"
        ],
        "afterPatchFile": [
            "from collections.abc import Iterable",
            "from typing import Optional",
            "",
            "import graphene",
            "from django.core.exceptions import ValidationError",
            "",
            "from ....checkout.error_codes import CheckoutErrorCode",
            "from ....checkout.fetch import (",
            "    CheckoutInfo,",
            "    CheckoutLineInfo,",
            "    fetch_checkout_info,",
            "    fetch_checkout_lines,",
            ")",
            "from ....checkout.utils import (",
            "    delete_external_shipping_id,",
            "    get_or_create_checkout_metadata,",
            "    invalidate_checkout_prices,",
            "    is_shipping_required,",
            "    set_external_shipping_id,",
            ")",
            "from ....shipping import interface as shipping_interface",
            "from ....shipping import models as shipping_models",
            "from ....shipping.utils import convert_to_shipping_method_data",
            "from ....warehouse import WarehouseClickAndCollectOption",
            "from ....warehouse import models as warehouse_models",
            "from ....webhook.const import APP_ID_PREFIX",
            "from ....webhook.event_types import WebhookEventAsyncType, WebhookEventSyncType",
            "from ...core import ResolveInfo",
            "from ...core.descriptions import ADDED_IN_31, ADDED_IN_34, DEPRECATED_IN_3X_INPUT",
            "from ...core.doc_category import DOC_CATEGORY_CHECKOUT",
            "from ...core.mutations import BaseMutation",
            "from ...core.scalars import UUID",
            "from ...core.types import CheckoutError",
            "from ...core.utils import WebhookEventInfo, from_global_id_or_error",
            "from ...plugins.dataloaders import get_plugin_manager_promise",
            "from ...shipping.types import ShippingMethod",
            "from ...warehouse.types import Warehouse",
            "from ..types import Checkout",
            "from .utils import ERROR_DOES_NOT_SHIP, clean_delivery_method, get_checkout",
            "",
            "",
            "class CheckoutDeliveryMethodUpdate(BaseMutation):",
            "    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")",
            "",
            "    class Arguments:",
            "        id = graphene.ID(",
            "            description=\"The checkout's ID.\" + ADDED_IN_34,",
            "            required=False,",
            "        )",
            "        token = UUID(",
            "            description=f\"Checkout token.{DEPRECATED_IN_3X_INPUT} Use `id` instead.\",",
            "            required=False,",
            "        )",
            "",
            "        delivery_method_id = graphene.ID(",
            "            description=\"Delivery Method ID (`Warehouse` ID or `ShippingMethod` ID).\",",
            "            required=False,",
            "        )",
            "",
            "    class Meta:",
            "        description = (",
            "            \"Updates the delivery method (shipping method or pick up point) \"",
            "            \"of the checkout. \"",
            "            \"Updates the checkout shipping_address for click and collect delivery \"",
            "            \"for a warehouse address. \" + ADDED_IN_31",
            "        )",
            "        doc_category = DOC_CATEGORY_CHECKOUT",
            "        error_type_class = CheckoutError",
            "        webhook_events_info = [",
            "            WebhookEventInfo(",
            "                type=WebhookEventSyncType.SHIPPING_LIST_METHODS_FOR_CHECKOUT,",
            "                description=(",
            "                    \"Triggered when updating the checkout delivery method with \"",
            "                    \"the external one.\"",
            "                ),",
            "            ),",
            "            WebhookEventInfo(",
            "                type=WebhookEventAsyncType.CHECKOUT_UPDATED,",
            "                description=\"A checkout was updated.\",",
            "            ),",
            "        ]",
            "",
            "    @classmethod",
            "    def perform_on_shipping_method(",
            "        cls,",
            "        info: ResolveInfo,",
            "        shipping_method_id,",
            "        checkout_info,",
            "        lines,",
            "        checkout,",
            "        manager,",
            "    ):",
            "        shipping_method = cls.get_node_or_error(",
            "            info,",
            "            shipping_method_id,",
            "            only_type=ShippingMethod,",
            "            field=\"delivery_method_id\",",
            "            qs=shipping_models.ShippingMethod.objects.prefetch_related(",
            "                \"postal_code_rules\"",
            "            ),",
            "        )",
            "",
            "        listing = shipping_models.ShippingMethodChannelListing.objects.filter(",
            "            shipping_method=shipping_method,",
            "            channel=checkout_info.channel,",
            "        ).first()",
            "        if not listing:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        \"This shipping method is not applicable in the given channel.\",",
            "                        code=CheckoutErrorCode.DELIVERY_METHOD_NOT_APPLICABLE.value,",
            "                    )",
            "                }",
            "            )",
            "        delivery_method = convert_to_shipping_method_data(shipping_method, listing)",
            "",
            "        cls._check_delivery_method(",
            "            checkout_info, lines, shipping_method=delivery_method, collection_point=None",
            "        )",
            "",
            "        cls._update_delivery_method(",
            "            manager,",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=shipping_method,",
            "            external_shipping_method=None,",
            "            collection_point=None,",
            "        )",
            "        return CheckoutDeliveryMethodUpdate(checkout=checkout)",
            "",
            "    @classmethod",
            "    def perform_on_external_shipping_method(",
            "        cls,",
            "        info: ResolveInfo,",
            "        shipping_method_id,",
            "        checkout_info,",
            "        lines,",
            "        checkout,",
            "        manager,",
            "    ):",
            "        delivery_method = manager.get_shipping_method(",
            "            checkout=checkout,",
            "            channel_slug=checkout.channel.slug,",
            "            shipping_method_id=shipping_method_id,",
            "        )",
            "",
            "        if delivery_method is None and shipping_method_id:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        f\"Couldn't resolve to a node: ${shipping_method_id}\",",
            "                        code=CheckoutErrorCode.NOT_FOUND.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "        cls._check_delivery_method(",
            "            checkout_info, lines, shipping_method=delivery_method, collection_point=None",
            "        )",
            "",
            "        cls._update_delivery_method(",
            "            manager,",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=None,",
            "            external_shipping_method=delivery_method,",
            "            collection_point=None,",
            "        )",
            "        return CheckoutDeliveryMethodUpdate(checkout=checkout)",
            "",
            "    @classmethod",
            "    def perform_on_collection_point(",
            "        cls,",
            "        info: ResolveInfo,",
            "        collection_point_id,",
            "        checkout_info,",
            "        lines,",
            "        checkout,",
            "        manager,",
            "    ):",
            "        collection_point = cls.get_node_or_error(",
            "            info,",
            "            collection_point_id,",
            "            only_type=Warehouse,",
            "            field=\"delivery_method_id\",",
            "            qs=warehouse_models.Warehouse.objects.select_related(\"address\"),",
            "        )",
            "        cls._check_delivery_method(",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=None,",
            "            collection_point=collection_point,",
            "        )",
            "        cls._update_delivery_method(",
            "            manager,",
            "            checkout_info,",
            "            lines,",
            "            shipping_method=None,",
            "            external_shipping_method=None,",
            "            collection_point=collection_point,",
            "        )",
            "        return CheckoutDeliveryMethodUpdate(checkout=checkout)",
            "",
            "    @staticmethod",
            "    def _check_delivery_method(",
            "        checkout_info,",
            "        lines,",
            "        *,",
            "        shipping_method: Optional[shipping_interface.ShippingMethodData],",
            "        collection_point: Optional[Warehouse],",
            "    ) -> None:",
            "        delivery_method = shipping_method",
            "        error_msg = \"This shipping method is not applicable.\"",
            "",
            "        if collection_point is not None:",
            "            delivery_method = collection_point",
            "            error_msg = \"This pick up point is not applicable.\"",
            "",
            "        delivery_method_is_valid = clean_delivery_method(",
            "            checkout_info=checkout_info, lines=lines, method=delivery_method",
            "        )",
            "        if not delivery_method_is_valid:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        error_msg,",
            "                        code=CheckoutErrorCode.DELIVERY_METHOD_NOT_APPLICABLE.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "    @classmethod",
            "    def _update_delivery_method(",
            "        cls,",
            "        manager,",
            "        checkout_info: \"CheckoutInfo\",",
            "        lines: Iterable[\"CheckoutLineInfo\"],",
            "        *,",
            "        shipping_method: Optional[ShippingMethod],",
            "        external_shipping_method: Optional[shipping_interface.ShippingMethodData],",
            "        collection_point: Optional[Warehouse],",
            "    ) -> None:",
            "        checkout_fields_to_update = [\"shipping_method\", \"collection_point\"]",
            "        checkout = checkout_info.checkout",
            "        if external_shipping_method:",
            "            set_external_shipping_id(",
            "                checkout=checkout, app_shipping_id=external_shipping_method.id",
            "            )",
            "        else:",
            "            delete_external_shipping_id(checkout=checkout)",
            "        checkout.shipping_method = shipping_method",
            "        checkout.collection_point = collection_point",
            "        if (",
            "            collection_point is not None",
            "            and collection_point.click_and_collect_option",
            "            == WarehouseClickAndCollectOption.LOCAL_STOCK",
            "        ):",
            "            checkout.shipping_address = collection_point.address",
            "            checkout_info.shipping_address = collection_point.address",
            "            checkout_fields_to_update += [\"shipping_address\"]",
            "        invalidate_prices_updated_fields = invalidate_checkout_prices(",
            "            checkout_info, lines, manager, save=False",
            "        )",
            "        checkout.save(",
            "            update_fields=checkout_fields_to_update + invalidate_prices_updated_fields",
            "        )",
            "        get_or_create_checkout_metadata(checkout).save()",
            "        cls.call_event(manager.checkout_updated, checkout)",
            "",
            "    @staticmethod",
            "    def _resolve_delivery_method_type(id_) -> Optional[str]:",
            "        if id_ is None:",
            "            return None",
            "",
            "        possible_types = (\"Warehouse\", \"ShippingMethod\", APP_ID_PREFIX)",
            "        type_, id_ = from_global_id_or_error(id_)",
            "        str_type = str(type_)",
            "",
            "        if str_type not in possible_types:",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method_id\": ValidationError(",
            "                        \"ID does not belong to Warehouse or ShippingMethod\",",
            "                        code=CheckoutErrorCode.INVALID.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "        return str_type",
            "",
            "    @classmethod",
            "    def perform_mutation(",
            "        cls,",
            "        _root,",
            "        info,",
            "        /,",
            "        token=None,",
            "        id=None,",
            "        delivery_method_id=None,",
            "    ):",
            "        checkout = get_checkout(cls, info, checkout_id=None, token=token, id=id)",
            "",
            "        use_legacy_error_flow_for_checkout = (",
            "            checkout.channel.use_legacy_error_flow_for_checkout",
            "        )",
            "",
            "        manager = get_plugin_manager_promise(info.context).get()",
            "        lines, unavailable_variant_pks = fetch_checkout_lines(checkout)",
            "        if use_legacy_error_flow_for_checkout and unavailable_variant_pks:",
            "            not_available_variants_ids = {",
            "                graphene.Node.to_global_id(\"ProductVariant\", pk)",
            "                for pk in unavailable_variant_pks",
            "            }",
            "            raise ValidationError(",
            "                {",
            "                    \"lines\": ValidationError(",
            "                        \"Some of the checkout lines variants are unavailable.\",",
            "                        code=CheckoutErrorCode.UNAVAILABLE_VARIANT_IN_CHANNEL.value,",
            "                        params={\"variants\": not_available_variants_ids},",
            "                    )",
            "                }",
            "            )",
            "",
            "        if use_legacy_error_flow_for_checkout and not is_shipping_required(lines):",
            "            raise ValidationError(",
            "                {",
            "                    \"delivery_method\": ValidationError(",
            "                        ERROR_DOES_NOT_SHIP,",
            "                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value,",
            "                    )",
            "                }",
            "            )",
            "        type_name = cls._resolve_delivery_method_type(delivery_method_id)",
            "        checkout_info = fetch_checkout_info(checkout, lines, manager)",
            "        if type_name == \"Warehouse\":",
            "            return cls.perform_on_collection_point(",
            "                info, delivery_method_id, checkout_info, lines, checkout, manager",
            "            )",
            "        if type_name == \"ShippingMethod\":",
            "            return cls.perform_on_shipping_method(",
            "                info, delivery_method_id, checkout_info, lines, checkout, manager",
            "            )",
            "        return cls.perform_on_external_shipping_method(",
            "            info, delivery_method_id, checkout_info, lines, checkout, manager",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "62": [
                "CheckoutDeliveryMethodUpdate",
                "Meta"
            ],
            "254": [
                "CheckoutDeliveryMethodUpdate",
                "_update_delivery_method"
            ],
            "255": [
                "CheckoutDeliveryMethodUpdate",
                "_update_delivery_method"
            ],
            "256": [
                "CheckoutDeliveryMethodUpdate",
                "_update_delivery_method"
            ],
            "257": [
                "CheckoutDeliveryMethodUpdate",
                "_update_delivery_method"
            ],
            "258": [
                "CheckoutDeliveryMethodUpdate",
                "_update_delivery_method"
            ],
            "327": [
                "CheckoutDeliveryMethodUpdate",
                "perform_mutation"
            ]
        },
        "addLocation": []
    },
    "saleor/graphql/checkout/mutations/checkout_shipping_address_update.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from ..types import Checkout"
            },
            "1": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from .checkout_create import CheckoutAddressValidationRules"
            },
            "2": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from .utils import ("
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    ERROR_CC_ADDRESS_CHANGE_FORBIDDEN,"
            },
            "4": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     ERROR_DOES_NOT_SHIP,"
            },
            "5": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     check_lines_quantity,"
            },
            "6": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     get_checkout,"
            },
            "7": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "                     )"
            },
            "8": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "                 }"
            },
            "9": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             )"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        # prevent from changing the shipping address when click and collect is used."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        if checkout.collection_point_id:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            raise ValidationError("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+                {"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+                    \"shipping_address\": ValidationError("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+                        ERROR_CC_ADDRESS_CHANGE_FORBIDDEN,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+                        code=CheckoutErrorCode.SHIPPING_CHANGE_FORBIDDEN.value,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+                    )"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+                }"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            )"
            },
            "20": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         address_validation_rules = validation_rules or {}"
            },
            "21": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         shipping_address_instance = cls.validate_address("
            },
            "22": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             shipping_address,"
            }
        },
        "frontPatchFile": [
            "from collections.abc import Iterable",
            "from typing import TYPE_CHECKING",
            "",
            "import graphene",
            "from django.core.exceptions import ValidationError",
            "",
            "from ....checkout import AddressType, models",
            "from ....checkout.error_codes import CheckoutErrorCode",
            "from ....checkout.fetch import (",
            "    CheckoutLineInfo,",
            "    fetch_checkout_info,",
            "    fetch_checkout_lines,",
            ")",
            "from ....checkout.utils import (",
            "    change_shipping_address_in_checkout,",
            "    invalidate_checkout_prices,",
            "    is_shipping_required,",
            ")",
            "from ....core.tracing import traced_atomic_transaction",
            "from ....graphql.account.mixins import AddressMetadataMixin",
            "from ....warehouse.reservations import is_reservation_enabled",
            "from ....webhook.event_types import WebhookEventAsyncType",
            "from ...account.i18n import I18nMixin",
            "from ...account.types import AddressInput",
            "from ...core.descriptions import ADDED_IN_34, ADDED_IN_35, DEPRECATED_IN_3X_INPUT",
            "from ...core.doc_category import DOC_CATEGORY_CHECKOUT",
            "from ...core.mutations import BaseMutation",
            "from ...core.scalars import UUID",
            "from ...core.types import CheckoutError",
            "from ...core.utils import WebhookEventInfo",
            "from ...plugins.dataloaders import get_plugin_manager_promise",
            "from ...site.dataloaders import get_site_promise",
            "from ..types import Checkout",
            "from .checkout_create import CheckoutAddressValidationRules",
            "from .utils import (",
            "    ERROR_DOES_NOT_SHIP,",
            "    check_lines_quantity,",
            "    get_checkout,",
            "    update_checkout_shipping_method_if_invalid,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from ....checkout.fetch import DeliveryMethodBase",
            "",
            "",
            "class CheckoutShippingAddressUpdate(AddressMetadataMixin, BaseMutation, I18nMixin):",
            "    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")",
            "",
            "    class Arguments:",
            "        id = graphene.ID(",
            "            description=\"The checkout's ID.\" + ADDED_IN_34,",
            "            required=False,",
            "        )",
            "        token = UUID(",
            "            description=f\"Checkout token.{DEPRECATED_IN_3X_INPUT} Use `id` instead.\",",
            "            required=False,",
            "        )",
            "        checkout_id = graphene.ID(",
            "            required=False,",
            "            description=(",
            "                f\"The ID of the checkout. {DEPRECATED_IN_3X_INPUT} Use `id` instead.\"",
            "            ),",
            "        )",
            "        shipping_address = AddressInput(",
            "            required=True,",
            "            description=\"The mailing address to where the checkout will be shipped.\",",
            "        )",
            "        validation_rules = CheckoutAddressValidationRules(",
            "            required=False,",
            "            description=(",
            "                \"The rules for changing validation for received shipping address data.\"",
            "                + ADDED_IN_35",
            "            ),",
            "        )",
            "",
            "    class Meta:",
            "        description = \"Update shipping address in the existing checkout.\"",
            "        doc_category = DOC_CATEGORY_CHECKOUT",
            "        error_type_class = CheckoutError",
            "        error_type_field = \"checkout_errors\"",
            "        webhook_events_info = [",
            "            WebhookEventInfo(",
            "                type=WebhookEventAsyncType.CHECKOUT_UPDATED,",
            "                description=\"A checkout was updated.\",",
            "            )",
            "        ]",
            "",
            "    @classmethod",
            "    def process_checkout_lines(",
            "        cls,",
            "        info,",
            "        lines: Iterable[\"CheckoutLineInfo\"],",
            "        country: str,",
            "        channel_slug: str,",
            "        delivery_method_info: \"DeliveryMethodBase\",",
            "    ) -> None:",
            "        variants = []",
            "        quantities = []",
            "        for line_info in lines:",
            "            variants.append(line_info.variant)",
            "            quantities.append(line_info.line.quantity)",
            "        site = get_site_promise(info.context).get()",
            "        check_lines_quantity(",
            "            variants,",
            "            quantities,",
            "            country,",
            "            channel_slug,",
            "            site.settings.limit_quantity_per_checkout,",
            "            delivery_method_info=delivery_method_info,",
            "            # Set replace=True to avoid existing_lines and quantities from",
            "            # being counted twice by the check_stock_quantity_bulk",
            "            replace=True,",
            "            existing_lines=lines,",
            "            check_reservations=is_reservation_enabled(site.settings),",
            "        )",
            "",
            "    @classmethod",
            "    def perform_mutation(",
            "        cls,",
            "        _root,",
            "        info,",
            "        /,",
            "        shipping_address,",
            "        validation_rules=None,",
            "        checkout_id=None,",
            "        token=None,",
            "        id=None,",
            "    ):",
            "        checkout = get_checkout(",
            "            cls,",
            "            info,",
            "            checkout_id=checkout_id,",
            "            token=token,",
            "            id=id,",
            "            qs=models.Checkout.objects.prefetch_related(",
            "                \"lines__variant__product__product_type\"",
            "            ),",
            "        )",
            "        use_legacy_error_flow_for_checkout = (",
            "            checkout.channel.use_legacy_error_flow_for_checkout",
            "        )",
            "",
            "        lines, _ = fetch_checkout_lines(",
            "            checkout,",
            "        )",
            "",
            "        if use_legacy_error_flow_for_checkout and not is_shipping_required(lines):",
            "            raise ValidationError(",
            "                {",
            "                    \"shipping_address\": ValidationError(",
            "                        ERROR_DOES_NOT_SHIP,",
            "                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value,",
            "                    )",
            "                }",
            "            )",
            "        address_validation_rules = validation_rules or {}",
            "        shipping_address_instance = cls.validate_address(",
            "            shipping_address,",
            "            address_type=AddressType.SHIPPING,",
            "            instance=checkout.shipping_address,",
            "            info=info,",
            "            format_check=address_validation_rules.get(\"check_fields_format\", True),",
            "            required_check=address_validation_rules.get(\"check_required_fields\", True),",
            "            enable_normalization=address_validation_rules.get(",
            "                \"enable_fields_normalization\", True",
            "            ),",
            "        )",
            "        manager = get_plugin_manager_promise(info.context).get()",
            "        shipping_channel_listings = checkout.channel.shipping_method_listings.all()",
            "        checkout_info = fetch_checkout_info(",
            "            checkout, lines, manager, shipping_channel_listings",
            "        )",
            "",
            "        country = shipping_address_instance.country.code",
            "        checkout.set_country(country, commit=True)",
            "",
            "        # Resolve and process the lines, validating variants quantities",
            "        if lines and use_legacy_error_flow_for_checkout:",
            "            cls.process_checkout_lines(",
            "                info,",
            "                lines,",
            "                country,",
            "                checkout_info.channel.slug,",
            "                checkout_info.delivery_method_info,",
            "            )",
            "",
            "        update_checkout_shipping_method_if_invalid(checkout_info, lines)",
            "",
            "        shipping_address_updated_fields = []",
            "        with traced_atomic_transaction():",
            "            shipping_address_instance.save()",
            "            shipping_address_updated_fields = change_shipping_address_in_checkout(",
            "                checkout_info,",
            "                shipping_address_instance,",
            "                lines,",
            "                manager,",
            "                shipping_channel_listings,",
            "            )",
            "        invalidate_prices_updated_fields = invalidate_checkout_prices(",
            "            checkout_info, lines, manager, save=False",
            "        )",
            "        checkout.save(",
            "            update_fields=shipping_address_updated_fields",
            "            + invalidate_prices_updated_fields",
            "        )",
            "",
            "        cls.call_event(manager.checkout_updated, checkout)",
            "",
            "        return CheckoutShippingAddressUpdate(checkout=checkout)"
        ],
        "afterPatchFile": [
            "from collections.abc import Iterable",
            "from typing import TYPE_CHECKING",
            "",
            "import graphene",
            "from django.core.exceptions import ValidationError",
            "",
            "from ....checkout import AddressType, models",
            "from ....checkout.error_codes import CheckoutErrorCode",
            "from ....checkout.fetch import (",
            "    CheckoutLineInfo,",
            "    fetch_checkout_info,",
            "    fetch_checkout_lines,",
            ")",
            "from ....checkout.utils import (",
            "    change_shipping_address_in_checkout,",
            "    invalidate_checkout_prices,",
            "    is_shipping_required,",
            ")",
            "from ....core.tracing import traced_atomic_transaction",
            "from ....graphql.account.mixins import AddressMetadataMixin",
            "from ....warehouse.reservations import is_reservation_enabled",
            "from ....webhook.event_types import WebhookEventAsyncType",
            "from ...account.i18n import I18nMixin",
            "from ...account.types import AddressInput",
            "from ...core.descriptions import ADDED_IN_34, ADDED_IN_35, DEPRECATED_IN_3X_INPUT",
            "from ...core.doc_category import DOC_CATEGORY_CHECKOUT",
            "from ...core.mutations import BaseMutation",
            "from ...core.scalars import UUID",
            "from ...core.types import CheckoutError",
            "from ...core.utils import WebhookEventInfo",
            "from ...plugins.dataloaders import get_plugin_manager_promise",
            "from ...site.dataloaders import get_site_promise",
            "from ..types import Checkout",
            "from .checkout_create import CheckoutAddressValidationRules",
            "from .utils import (",
            "    ERROR_CC_ADDRESS_CHANGE_FORBIDDEN,",
            "    ERROR_DOES_NOT_SHIP,",
            "    check_lines_quantity,",
            "    get_checkout,",
            "    update_checkout_shipping_method_if_invalid,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from ....checkout.fetch import DeliveryMethodBase",
            "",
            "",
            "class CheckoutShippingAddressUpdate(AddressMetadataMixin, BaseMutation, I18nMixin):",
            "    checkout = graphene.Field(Checkout, description=\"An updated checkout.\")",
            "",
            "    class Arguments:",
            "        id = graphene.ID(",
            "            description=\"The checkout's ID.\" + ADDED_IN_34,",
            "            required=False,",
            "        )",
            "        token = UUID(",
            "            description=f\"Checkout token.{DEPRECATED_IN_3X_INPUT} Use `id` instead.\",",
            "            required=False,",
            "        )",
            "        checkout_id = graphene.ID(",
            "            required=False,",
            "            description=(",
            "                f\"The ID of the checkout. {DEPRECATED_IN_3X_INPUT} Use `id` instead.\"",
            "            ),",
            "        )",
            "        shipping_address = AddressInput(",
            "            required=True,",
            "            description=\"The mailing address to where the checkout will be shipped.\",",
            "        )",
            "        validation_rules = CheckoutAddressValidationRules(",
            "            required=False,",
            "            description=(",
            "                \"The rules for changing validation for received shipping address data.\"",
            "                + ADDED_IN_35",
            "            ),",
            "        )",
            "",
            "    class Meta:",
            "        description = \"Update shipping address in the existing checkout.\"",
            "        doc_category = DOC_CATEGORY_CHECKOUT",
            "        error_type_class = CheckoutError",
            "        error_type_field = \"checkout_errors\"",
            "        webhook_events_info = [",
            "            WebhookEventInfo(",
            "                type=WebhookEventAsyncType.CHECKOUT_UPDATED,",
            "                description=\"A checkout was updated.\",",
            "            )",
            "        ]",
            "",
            "    @classmethod",
            "    def process_checkout_lines(",
            "        cls,",
            "        info,",
            "        lines: Iterable[\"CheckoutLineInfo\"],",
            "        country: str,",
            "        channel_slug: str,",
            "        delivery_method_info: \"DeliveryMethodBase\",",
            "    ) -> None:",
            "        variants = []",
            "        quantities = []",
            "        for line_info in lines:",
            "            variants.append(line_info.variant)",
            "            quantities.append(line_info.line.quantity)",
            "        site = get_site_promise(info.context).get()",
            "        check_lines_quantity(",
            "            variants,",
            "            quantities,",
            "            country,",
            "            channel_slug,",
            "            site.settings.limit_quantity_per_checkout,",
            "            delivery_method_info=delivery_method_info,",
            "            # Set replace=True to avoid existing_lines and quantities from",
            "            # being counted twice by the check_stock_quantity_bulk",
            "            replace=True,",
            "            existing_lines=lines,",
            "            check_reservations=is_reservation_enabled(site.settings),",
            "        )",
            "",
            "    @classmethod",
            "    def perform_mutation(",
            "        cls,",
            "        _root,",
            "        info,",
            "        /,",
            "        shipping_address,",
            "        validation_rules=None,",
            "        checkout_id=None,",
            "        token=None,",
            "        id=None,",
            "    ):",
            "        checkout = get_checkout(",
            "            cls,",
            "            info,",
            "            checkout_id=checkout_id,",
            "            token=token,",
            "            id=id,",
            "            qs=models.Checkout.objects.prefetch_related(",
            "                \"lines__variant__product__product_type\"",
            "            ),",
            "        )",
            "        use_legacy_error_flow_for_checkout = (",
            "            checkout.channel.use_legacy_error_flow_for_checkout",
            "        )",
            "",
            "        lines, _ = fetch_checkout_lines(",
            "            checkout,",
            "        )",
            "",
            "        if use_legacy_error_flow_for_checkout and not is_shipping_required(lines):",
            "            raise ValidationError(",
            "                {",
            "                    \"shipping_address\": ValidationError(",
            "                        ERROR_DOES_NOT_SHIP,",
            "                        code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value,",
            "                    )",
            "                }",
            "            )",
            "        # prevent from changing the shipping address when click and collect is used.",
            "        if checkout.collection_point_id:",
            "            raise ValidationError(",
            "                {",
            "                    \"shipping_address\": ValidationError(",
            "                        ERROR_CC_ADDRESS_CHANGE_FORBIDDEN,",
            "                        code=CheckoutErrorCode.SHIPPING_CHANGE_FORBIDDEN.value,",
            "                    )",
            "                }",
            "            )",
            "        address_validation_rules = validation_rules or {}",
            "        shipping_address_instance = cls.validate_address(",
            "            shipping_address,",
            "            address_type=AddressType.SHIPPING,",
            "            instance=checkout.shipping_address,",
            "            info=info,",
            "            format_check=address_validation_rules.get(\"check_fields_format\", True),",
            "            required_check=address_validation_rules.get(\"check_required_fields\", True),",
            "            enable_normalization=address_validation_rules.get(",
            "                \"enable_fields_normalization\", True",
            "            ),",
            "        )",
            "        manager = get_plugin_manager_promise(info.context).get()",
            "        shipping_channel_listings = checkout.channel.shipping_method_listings.all()",
            "        checkout_info = fetch_checkout_info(",
            "            checkout, lines, manager, shipping_channel_listings",
            "        )",
            "",
            "        country = shipping_address_instance.country.code",
            "        checkout.set_country(country, commit=True)",
            "",
            "        # Resolve and process the lines, validating variants quantities",
            "        if lines and use_legacy_error_flow_for_checkout:",
            "            cls.process_checkout_lines(",
            "                info,",
            "                lines,",
            "                country,",
            "                checkout_info.channel.slug,",
            "                checkout_info.delivery_method_info,",
            "            )",
            "",
            "        update_checkout_shipping_method_if_invalid(checkout_info, lines)",
            "",
            "        shipping_address_updated_fields = []",
            "        with traced_atomic_transaction():",
            "            shipping_address_instance.save()",
            "            shipping_address_updated_fields = change_shipping_address_in_checkout(",
            "                checkout_info,",
            "                shipping_address_instance,",
            "                lines,",
            "                manager,",
            "                shipping_channel_listings,",
            "            )",
            "        invalidate_prices_updated_fields = invalidate_checkout_prices(",
            "            checkout_info, lines, manager, save=False",
            "        )",
            "        checkout.save(",
            "            update_fields=shipping_address_updated_fields",
            "            + invalidate_prices_updated_fields",
            "        )",
            "",
            "        cls.call_event(manager.checkout_updated, checkout)",
            "",
            "        return CheckoutShippingAddressUpdate(checkout=checkout)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nltk.downloader.Downloader.download",
            "saleor.graphql.checkout.mutations.checkout_shipping_address_update.CheckoutShippingAddressUpdate.perform_mutation.shipping_address_updated_fields"
        ]
    },
    "saleor/graphql/checkout/mutations/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " ERROR_DOES_NOT_SHIP = \"This checkout doesn't need shipping\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+ERROR_CC_ADDRESS_CHANGE_FORBIDDEN = ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    \"Can't change shipping address manually. \""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    \"For click and collect delivery, address is set to a warehouse address.\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+)"
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " @dataclass"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import uuid",
            "from collections import defaultdict",
            "from collections.abc import Iterable",
            "from dataclasses import dataclass",
            "from decimal import Decimal",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "import graphene",
            "import pytz",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.db.models import Q, QuerySet",
            "",
            "from ....checkout import models",
            "from ....checkout.error_codes import CheckoutErrorCode",
            "from ....checkout.fetch import CheckoutInfo, CheckoutLineInfo",
            "from ....checkout.utils import (",
            "    calculate_checkout_quantity,",
            "    clear_delivery_method,",
            "    is_shipping_required,",
            ")",
            "from ....core.exceptions import InsufficientStock, PermissionDenied",
            "from ....permission.enums import CheckoutPermissions",
            "from ....product import models as product_models",
            "from ....product.models import ProductChannelListing, ProductVariant",
            "from ....shipping import interface as shipping_interface",
            "from ....warehouse import models as warehouse_models",
            "from ....warehouse.availability import check_stock_and_preorder_quantity_bulk",
            "from ...core import ResolveInfo",
            "from ...core.validators import validate_one_of_args_is_in_mutation",
            "from ..types import Checkout",
            "",
            "if TYPE_CHECKING:",
            "    from ...core.mutations import BaseMutation",
            "",
            "",
            "ERROR_DOES_NOT_SHIP = \"This checkout doesn't need shipping\"",
            "",
            "",
            "@dataclass",
            "class CheckoutLineData:",
            "    variant_id: Optional[str] = None",
            "    line_id: Optional[str] = None",
            "    quantity: int = 0",
            "    quantity_to_update: bool = False",
            "    custom_price: Optional[Decimal] = None",
            "    custom_price_to_update: bool = False",
            "    metadata_list: Optional[list] = None",
            "",
            "",
            "def clean_delivery_method(",
            "    checkout_info: \"CheckoutInfo\",",
            "    lines: Iterable[CheckoutLineInfo],",
            "    method: Optional[",
            "        Union[",
            "            shipping_interface.ShippingMethodData,",
            "            warehouse_models.Warehouse,",
            "        ]",
            "    ],",
            ") -> bool:",
            "    \"\"\"Check if current shipping method is valid.\"\"\"",
            "    if not method:",
            "        # no shipping method was provided, it is valid",
            "        return True",
            "",
            "    if not is_shipping_required(lines):",
            "        raise ValidationError(",
            "            ERROR_DOES_NOT_SHIP, code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value",
            "        )",
            "",
            "    if not checkout_info.shipping_address and isinstance(",
            "        method, shipping_interface.ShippingMethodData",
            "    ):",
            "        raise ValidationError(",
            "            \"Cannot choose a shipping method for a checkout without the \"",
            "            \"shipping address.\",",
            "            code=CheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET.value,",
            "        )",
            "",
            "    valid_methods = checkout_info.valid_delivery_methods",
            "    return method in valid_methods",
            "",
            "",
            "def update_checkout_shipping_method_if_invalid(",
            "    checkout_info: \"CheckoutInfo\", lines: Iterable[CheckoutLineInfo]",
            "):",
            "    quantity = calculate_checkout_quantity(lines)",
            "",
            "    # remove shipping method when empty checkout",
            "    if quantity == 0 or not is_shipping_required(lines):",
            "        clear_delivery_method(checkout_info)",
            "",
            "    is_valid = clean_delivery_method(",
            "        checkout_info=checkout_info,",
            "        lines=lines,",
            "        method=checkout_info.delivery_method_info.delivery_method,",
            "    )",
            "",
            "    if not is_valid:",
            "        clear_delivery_method(checkout_info)",
            "",
            "",
            "def get_variants_and_total_quantities(",
            "    variants: list[ProductVariant],",
            "    lines_data: Iterable[CheckoutLineData],",
            "    quantity_to_update_check=False,",
            "):",
            "    variants_total_quantity_map: defaultdict[ProductVariant, int] = defaultdict(int)",
            "    mapped_data: defaultdict[Optional[str], int] = defaultdict(int)",
            "",
            "    if quantity_to_update_check:",
            "        lines_data = filter(lambda d: d.quantity_to_update, lines_data)",
            "",
            "    for data in lines_data:",
            "        mapped_data[data.variant_id] += data.quantity",
            "",
            "    for variant in variants:",
            "        quantity = mapped_data.get(str(variant.id), None)",
            "        if quantity is not None:",
            "            variants_total_quantity_map[variant] += quantity",
            "",
            "    return variants_total_quantity_map.keys(), variants_total_quantity_map.values()",
            "",
            "",
            "def check_lines_quantity(",
            "    variants,",
            "    quantities,",
            "    country,",
            "    channel_slug,",
            "    global_quantity_limit,",
            "    delivery_method_info=None,",
            "    allow_zero_quantity=False,",
            "    existing_lines=None,",
            "    replace=False,",
            "    check_reservations=False,",
            "):",
            "    \"\"\"Clean quantities and check if stock is sufficient for each checkout line.",
            "",
            "    By default, zero quantity is not allowed,",
            "    but if this validation is used for updating existing checkout lines,",
            "    allow_zero_quantities can be set to True",
            "    and checkout lines with this quantity can be later removed.",
            "    \"\"\"",
            "",
            "    for quantity in quantities:",
            "        if not allow_zero_quantity and quantity <= 0:",
            "            raise ValidationError(",
            "                {",
            "                    \"quantity\": ValidationError(",
            "                        \"The quantity should be higher than zero.\",",
            "                        code=CheckoutErrorCode.ZERO_QUANTITY.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "        elif allow_zero_quantity and quantity < 0:",
            "            raise ValidationError(",
            "                {",
            "                    \"quantity\": ValidationError(",
            "                        \"The quantity should be higher or equal zero.\",",
            "                        code=CheckoutErrorCode.ZERO_QUANTITY.value,",
            "                    )",
            "                }",
            "            )",
            "    try:",
            "        check_stock_and_preorder_quantity_bulk(",
            "            variants,",
            "            country,",
            "            quantities,",
            "            channel_slug,",
            "            global_quantity_limit,",
            "            delivery_method_info=delivery_method_info,",
            "            existing_lines=existing_lines,",
            "            replace=replace,",
            "            check_reservations=check_reservations,",
            "        )",
            "    except InsufficientStock as e:",
            "        errors = [",
            "            ValidationError(",
            "                f\"Could not add items {item.variant}. \"",
            "                f\"Only {max(item.available_quantity, 0)} remaining in stock.\",",
            "                code=e.code.value,",
            "            )",
            "            for item in e.items",
            "        ]",
            "        raise ValidationError({\"quantity\": errors})",
            "",
            "",
            "def get_not_available_variants_for_purchase(",
            "    variants_id: set, channel_id: int",
            ") -> tuple[set[int], set[str]]:",
            "    today = datetime.datetime.now(pytz.UTC)",
            "    is_available_for_purchase = Q(",
            "        available_for_purchase_at__lte=today,",
            "        product__variants__id__in=variants_id,",
            "        channel_id=channel_id,",
            "    )",
            "    available_variants = ProductChannelListing.objects.filter(",
            "        is_available_for_purchase",
            "    ).values_list(\"product__variants__id\", flat=True)",
            "    not_available_variants = variants_id.difference(set(available_variants))",
            "    not_available_graphql_ids = {",
            "        graphene.Node.to_global_id(\"ProductVariant\", pk)",
            "        for pk in not_available_variants",
            "    }",
            "    return not_available_variants, not_available_graphql_ids",
            "",
            "",
            "def validate_variants_available_for_purchase(",
            "    variants_id: set,",
            "    channel_id: int,",
            "    error_code: str = CheckoutErrorCode.PRODUCT_UNAVAILABLE_FOR_PURCHASE.value,",
            "):",
            "    (",
            "        not_available_variants,",
            "        not_available_graphql_ids,",
            "    ) = get_not_available_variants_for_purchase(variants_id, channel_id)",
            "    if not_available_variants:",
            "        raise ValidationError(",
            "            {",
            "                \"lines\": ValidationError(",
            "                    \"Cannot add lines for unavailable for purchase variants.\",",
            "                    code=error_code,",
            "                    params={\"variants\": not_available_graphql_ids},",
            "                )",
            "            }",
            "        )",
            "",
            "",
            "def get_not_published_variants(",
            "    variants_id: set, channel_id: int",
            ") -> tuple[set[int], set[str]]:",
            "    published_variants = product_models.ProductChannelListing.objects.filter(",
            "        channel_id=channel_id, product__variants__id__in=variants_id, is_published=True",
            "    ).values_list(\"product__variants__id\", flat=True)",
            "    not_published_ids = variants_id.difference(set(published_variants))",
            "    not_published_graphql_ids = {",
            "        graphene.Node.to_global_id(\"ProductVariant\", pk) for pk in not_published_ids",
            "    }",
            "    return not_published_ids, not_published_graphql_ids",
            "",
            "",
            "def validate_variants_are_published(",
            "    variants_id: set,",
            "    channel_id: int,",
            "    error_code: str = CheckoutErrorCode.PRODUCT_NOT_PUBLISHED.value,",
            "):",
            "    not_published_ids, not_published_graphql_ids = get_not_published_variants(",
            "        variants_id, channel_id",
            "    )",
            "    if not_published_ids:",
            "        raise ValidationError(",
            "            {",
            "                \"lines\": ValidationError(",
            "                    \"Cannot add lines for unpublished variants.\",",
            "                    code=error_code,",
            "                    params={\"variants\": not_published_graphql_ids},",
            "                )",
            "            }",
            "        )",
            "",
            "",
            "def get_checkout_by_token(",
            "    token: uuid.UUID, qs: Optional[QuerySet[models.Checkout]] = None",
            "):",
            "    if qs is None:",
            "        qs = models.Checkout.objects.select_related(",
            "            \"channel\",",
            "            \"shipping_method\",",
            "            \"collection_point\",",
            "            \"billing_address\",",
            "            \"shipping_address\",",
            "        )",
            "    try:",
            "        checkout = qs.get(token=token)",
            "    except ObjectDoesNotExist:",
            "        raise ValidationError(",
            "            {",
            "                \"token\": ValidationError(",
            "                    f\"Couldn't resolve to a node: {token}.\",",
            "                    code=CheckoutErrorCode.NOT_FOUND.value,",
            "                )",
            "            }",
            "        )",
            "    return checkout",
            "",
            "",
            "def get_checkout(",
            "    mutation_class: type[\"BaseMutation\"],",
            "    info: ResolveInfo,",
            "    checkout_id: Optional[str] = None,",
            "    token: Optional[uuid.UUID] = None,",
            "    id: Optional[str] = None,",
            "    qs: Optional[QuerySet] = None,",
            "):",
            "    \"\"\"Return checkout by using the current id field or the deprecated one.",
            "",
            "    It is helper logic to return a checkout for mutations that takes into account the",
            "    current `id` field and the deprecated one (`checkout_id`, `token`). If checkout is",
            "    not found, it will raise an exception.",
            "    \"\"\"",
            "",
            "    validate_one_of_args_is_in_mutation(",
            "        \"checkout_id\", checkout_id, \"token\", token, \"id\", id",
            "    )",
            "    if qs is None:",
            "        qs = models.Checkout.objects.select_related(",
            "            \"channel__tax_configuration\",",
            "            \"shipping_method\",",
            "            \"collection_point\",",
            "            \"billing_address\",",
            "            \"shipping_address\",",
            "        )",
            "",
            "    if id:",
            "        checkout = mutation_class.get_node_or_error(",
            "            info, id, only_type=Checkout, field=\"id\", qs=qs",
            "        )",
            "    else:  # DEPRECATED",
            "        if token:",
            "            checkout = get_checkout_by_token(token, qs=qs)",
            "        else:",
            "            checkout_id = cast(str, checkout_id)",
            "            checkout = mutation_class.get_node_or_error(",
            "                info, checkout_id, only_type=Checkout, field=\"checkout_id\", qs=qs",
            "            )",
            "    return checkout",
            "",
            "",
            "def group_lines_input_on_add(",
            "    lines: list[dict[str, Any]], existing_lines_info=None",
            ") -> list[CheckoutLineData]:",
            "    \"\"\"Return list od CheckoutLineData objects.",
            "",
            "    Lines data provided in CheckoutLineInput will be grouped depending on",
            "    provided parameters.",
            "    \"\"\"",
            "    grouped_checkout_lines_data: list[CheckoutLineData] = []",
            "    checkout_lines_data_map: dict[str, CheckoutLineData] = defaultdict(CheckoutLineData)",
            "",
            "    for line in lines:",
            "        variant_id = cast(str, line.get(\"variant_id\"))",
            "        force_new_line = line.get(\"force_new_line\")",
            "        metadata_list = line.get(\"metadata\")",
            "",
            "        _, variant_db_id = graphene.Node.from_global_id(variant_id)",
            "",
            "        if force_new_line:",
            "            line_data = CheckoutLineData(",
            "                variant_id=variant_db_id, metadata_list=metadata_list",
            "            )",
            "            grouped_checkout_lines_data.append(line_data)",
            "        else:",
            "            _, variant_db_id = graphene.Node.from_global_id(variant_id)",
            "",
            "            try:",
            "                line_db_id = find_line_id_when_variant_parameter_used(",
            "                    variant_db_id, existing_lines_info",
            "                )",
            "",
            "                if not line_db_id:",
            "                    line_data = checkout_lines_data_map[variant_db_id]",
            "                    line_data.variant_id = variant_db_id",
            "                    line_data.metadata_list = metadata_list",
            "                else:",
            "                    line_data = checkout_lines_data_map[line_db_id]",
            "                    line_data.line_id = line_db_id",
            "                    line_data.variant_id = find_variant_id_when_line_parameter_used(",
            "                        line_db_id, existing_lines_info",
            "                    )",
            "",
            "                    if line_data.metadata_list and metadata_list:",
            "                        line_data.metadata_list += metadata_list",
            "                    else:",
            "                        line_data.metadata_list = metadata_list",
            "",
            "            # when variant already exist in multiple lines then create a new line",
            "            except ValidationError:",
            "                line_data = CheckoutLineData(",
            "                    variant_id=variant_db_id, metadata_list=metadata_list",
            "                )",
            "                grouped_checkout_lines_data.append(line_data)",
            "",
            "        if (quantity := line.get(\"quantity\")) is not None:",
            "            line_data.quantity += quantity",
            "            line_data.quantity_to_update = True",
            "",
            "        if \"price\" in line:",
            "            line_data.custom_price = line[\"price\"]",
            "            line_data.custom_price_to_update = True",
            "",
            "    grouped_checkout_lines_data += list(checkout_lines_data_map.values())",
            "    return grouped_checkout_lines_data",
            "",
            "",
            "def group_lines_input_data_on_update(",
            "    lines: list[dict[str, Any]], existing_lines_info=None",
            ") -> list[CheckoutLineData]:",
            "    \"\"\"Return list od CheckoutLineData objects.",
            "",
            "    This function is used in CheckoutLinesUpdate mutation.",
            "    Lines data provided in CheckoutLineUpdateInput will be grouped depending on",
            "    provided parameters.",
            "    \"\"\"",
            "    grouped_checkout_lines_data: list[CheckoutLineData] = []",
            "    checkout_lines_data_map: dict[str, CheckoutLineData] = defaultdict(CheckoutLineData)",
            "",
            "    for line in lines:",
            "        variant_id = cast(str, line.get(\"variant_id\"))",
            "        line_id = cast(str, line.get(\"line_id\"))",
            "",
            "        if line_id:",
            "            _, line_db_id = graphene.Node.from_global_id(line_id)",
            "",
            "        if variant_id:",
            "            _, variant_db_id = graphene.Node.from_global_id(variant_id)",
            "            line_db_id = find_line_id_when_variant_parameter_used(",
            "                variant_db_id, existing_lines_info",
            "            )",
            "",
            "        if not line_db_id:",
            "            line_data = checkout_lines_data_map[variant_db_id]",
            "            line_data.variant_id = variant_db_id",
            "        else:",
            "            line_data = checkout_lines_data_map[line_db_id]",
            "            line_data.line_id = line_db_id",
            "            line_data.variant_id = find_variant_id_when_line_parameter_used(",
            "                line_db_id, existing_lines_info",
            "            )",
            "",
            "        if (quantity := line.get(\"quantity\")) is not None:",
            "            line_data.quantity += quantity",
            "            line_data.quantity_to_update = True",
            "",
            "        if \"price\" in line:",
            "            line_data.custom_price = line[\"price\"]",
            "            line_data.custom_price_to_update = True",
            "",
            "    grouped_checkout_lines_data += list(checkout_lines_data_map.values())",
            "    return grouped_checkout_lines_data",
            "",
            "",
            "def check_permissions_for_custom_prices(app, lines):",
            "    \"\"\"Raise PermissionDenied when custom price is changed by user or app without perm.",
            "",
            "    Checkout line custom price can be changed only by app with",
            "    handle checkout permission.",
            "    \"\"\"",
            "    if any([\"price\" in line for line in lines]) and (",
            "        not app or not app.has_perm(CheckoutPermissions.HANDLE_CHECKOUTS)",
            "    ):",
            "        raise PermissionDenied(permissions=[CheckoutPermissions.HANDLE_CHECKOUTS])",
            "",
            "",
            "def find_line_id_when_variant_parameter_used(",
            "    variant_db_id: str, lines_info: list[CheckoutLineInfo]",
            "):",
            "    \"\"\"Return line id when variantId parameter was used.",
            "",
            "    If variant exists in multiple lines error will be returned.",
            "    \"\"\"",
            "    if not lines_info:",
            "        return",
            "",
            "    line_info = list(filter(lambda x: (x.variant.pk == int(variant_db_id)), lines_info))",
            "",
            "    if not line_info:",
            "        return",
            "",
            "    # if same variant occur in multiple lines `lineId` parameter have to be used",
            "    if len(line_info) > 1:",
            "        message = (",
            "            \"Variant occurs in multiple lines. Use `lineId` instead of `variantId`.\"",
            "        )",
            "        variant_global_id = graphene.Node.to_global_id(\"ProductVariant\", variant_db_id)",
            "",
            "        raise ValidationError(",
            "            {",
            "                \"variantId\": ValidationError(",
            "                    message=message,",
            "                    code=CheckoutErrorCode.INVALID.value,",
            "                    params={\"variants\": [variant_global_id]},",
            "                )",
            "            }",
            "        )",
            "",
            "    return str(line_info[0].line.id)",
            "",
            "",
            "def find_variant_id_when_line_parameter_used(",
            "    line_db_id: str, lines_info: list[CheckoutLineInfo]",
            "):",
            "    \"\"\"Return variant id when lineId parameter was used.\"\"\"",
            "    if not lines_info:",
            "        return",
            "",
            "    line_info = list(filter(lambda x: (str(x.line.pk) == line_db_id), lines_info))",
            "    return str(line_info[0].line.variant_id)"
        ],
        "afterPatchFile": [
            "import datetime",
            "import uuid",
            "from collections import defaultdict",
            "from collections.abc import Iterable",
            "from dataclasses import dataclass",
            "from decimal import Decimal",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Optional,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "import graphene",
            "import pytz",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.db.models import Q, QuerySet",
            "",
            "from ....checkout import models",
            "from ....checkout.error_codes import CheckoutErrorCode",
            "from ....checkout.fetch import CheckoutInfo, CheckoutLineInfo",
            "from ....checkout.utils import (",
            "    calculate_checkout_quantity,",
            "    clear_delivery_method,",
            "    is_shipping_required,",
            ")",
            "from ....core.exceptions import InsufficientStock, PermissionDenied",
            "from ....permission.enums import CheckoutPermissions",
            "from ....product import models as product_models",
            "from ....product.models import ProductChannelListing, ProductVariant",
            "from ....shipping import interface as shipping_interface",
            "from ....warehouse import models as warehouse_models",
            "from ....warehouse.availability import check_stock_and_preorder_quantity_bulk",
            "from ...core import ResolveInfo",
            "from ...core.validators import validate_one_of_args_is_in_mutation",
            "from ..types import Checkout",
            "",
            "if TYPE_CHECKING:",
            "    from ...core.mutations import BaseMutation",
            "",
            "",
            "ERROR_DOES_NOT_SHIP = \"This checkout doesn't need shipping\"",
            "ERROR_CC_ADDRESS_CHANGE_FORBIDDEN = (",
            "    \"Can't change shipping address manually. \"",
            "    \"For click and collect delivery, address is set to a warehouse address.\"",
            ")",
            "",
            "",
            "@dataclass",
            "class CheckoutLineData:",
            "    variant_id: Optional[str] = None",
            "    line_id: Optional[str] = None",
            "    quantity: int = 0",
            "    quantity_to_update: bool = False",
            "    custom_price: Optional[Decimal] = None",
            "    custom_price_to_update: bool = False",
            "    metadata_list: Optional[list] = None",
            "",
            "",
            "def clean_delivery_method(",
            "    checkout_info: \"CheckoutInfo\",",
            "    lines: Iterable[CheckoutLineInfo],",
            "    method: Optional[",
            "        Union[",
            "            shipping_interface.ShippingMethodData,",
            "            warehouse_models.Warehouse,",
            "        ]",
            "    ],",
            ") -> bool:",
            "    \"\"\"Check if current shipping method is valid.\"\"\"",
            "    if not method:",
            "        # no shipping method was provided, it is valid",
            "        return True",
            "",
            "    if not is_shipping_required(lines):",
            "        raise ValidationError(",
            "            ERROR_DOES_NOT_SHIP, code=CheckoutErrorCode.SHIPPING_NOT_REQUIRED.value",
            "        )",
            "",
            "    if not checkout_info.shipping_address and isinstance(",
            "        method, shipping_interface.ShippingMethodData",
            "    ):",
            "        raise ValidationError(",
            "            \"Cannot choose a shipping method for a checkout without the \"",
            "            \"shipping address.\",",
            "            code=CheckoutErrorCode.SHIPPING_ADDRESS_NOT_SET.value,",
            "        )",
            "",
            "    valid_methods = checkout_info.valid_delivery_methods",
            "    return method in valid_methods",
            "",
            "",
            "def update_checkout_shipping_method_if_invalid(",
            "    checkout_info: \"CheckoutInfo\", lines: Iterable[CheckoutLineInfo]",
            "):",
            "    quantity = calculate_checkout_quantity(lines)",
            "",
            "    # remove shipping method when empty checkout",
            "    if quantity == 0 or not is_shipping_required(lines):",
            "        clear_delivery_method(checkout_info)",
            "",
            "    is_valid = clean_delivery_method(",
            "        checkout_info=checkout_info,",
            "        lines=lines,",
            "        method=checkout_info.delivery_method_info.delivery_method,",
            "    )",
            "",
            "    if not is_valid:",
            "        clear_delivery_method(checkout_info)",
            "",
            "",
            "def get_variants_and_total_quantities(",
            "    variants: list[ProductVariant],",
            "    lines_data: Iterable[CheckoutLineData],",
            "    quantity_to_update_check=False,",
            "):",
            "    variants_total_quantity_map: defaultdict[ProductVariant, int] = defaultdict(int)",
            "    mapped_data: defaultdict[Optional[str], int] = defaultdict(int)",
            "",
            "    if quantity_to_update_check:",
            "        lines_data = filter(lambda d: d.quantity_to_update, lines_data)",
            "",
            "    for data in lines_data:",
            "        mapped_data[data.variant_id] += data.quantity",
            "",
            "    for variant in variants:",
            "        quantity = mapped_data.get(str(variant.id), None)",
            "        if quantity is not None:",
            "            variants_total_quantity_map[variant] += quantity",
            "",
            "    return variants_total_quantity_map.keys(), variants_total_quantity_map.values()",
            "",
            "",
            "def check_lines_quantity(",
            "    variants,",
            "    quantities,",
            "    country,",
            "    channel_slug,",
            "    global_quantity_limit,",
            "    delivery_method_info=None,",
            "    allow_zero_quantity=False,",
            "    existing_lines=None,",
            "    replace=False,",
            "    check_reservations=False,",
            "):",
            "    \"\"\"Clean quantities and check if stock is sufficient for each checkout line.",
            "",
            "    By default, zero quantity is not allowed,",
            "    but if this validation is used for updating existing checkout lines,",
            "    allow_zero_quantities can be set to True",
            "    and checkout lines with this quantity can be later removed.",
            "    \"\"\"",
            "",
            "    for quantity in quantities:",
            "        if not allow_zero_quantity and quantity <= 0:",
            "            raise ValidationError(",
            "                {",
            "                    \"quantity\": ValidationError(",
            "                        \"The quantity should be higher than zero.\",",
            "                        code=CheckoutErrorCode.ZERO_QUANTITY.value,",
            "                    )",
            "                }",
            "            )",
            "",
            "        elif allow_zero_quantity and quantity < 0:",
            "            raise ValidationError(",
            "                {",
            "                    \"quantity\": ValidationError(",
            "                        \"The quantity should be higher or equal zero.\",",
            "                        code=CheckoutErrorCode.ZERO_QUANTITY.value,",
            "                    )",
            "                }",
            "            )",
            "    try:",
            "        check_stock_and_preorder_quantity_bulk(",
            "            variants,",
            "            country,",
            "            quantities,",
            "            channel_slug,",
            "            global_quantity_limit,",
            "            delivery_method_info=delivery_method_info,",
            "            existing_lines=existing_lines,",
            "            replace=replace,",
            "            check_reservations=check_reservations,",
            "        )",
            "    except InsufficientStock as e:",
            "        errors = [",
            "            ValidationError(",
            "                f\"Could not add items {item.variant}. \"",
            "                f\"Only {max(item.available_quantity, 0)} remaining in stock.\",",
            "                code=e.code.value,",
            "            )",
            "            for item in e.items",
            "        ]",
            "        raise ValidationError({\"quantity\": errors})",
            "",
            "",
            "def get_not_available_variants_for_purchase(",
            "    variants_id: set, channel_id: int",
            ") -> tuple[set[int], set[str]]:",
            "    today = datetime.datetime.now(pytz.UTC)",
            "    is_available_for_purchase = Q(",
            "        available_for_purchase_at__lte=today,",
            "        product__variants__id__in=variants_id,",
            "        channel_id=channel_id,",
            "    )",
            "    available_variants = ProductChannelListing.objects.filter(",
            "        is_available_for_purchase",
            "    ).values_list(\"product__variants__id\", flat=True)",
            "    not_available_variants = variants_id.difference(set(available_variants))",
            "    not_available_graphql_ids = {",
            "        graphene.Node.to_global_id(\"ProductVariant\", pk)",
            "        for pk in not_available_variants",
            "    }",
            "    return not_available_variants, not_available_graphql_ids",
            "",
            "",
            "def validate_variants_available_for_purchase(",
            "    variants_id: set,",
            "    channel_id: int,",
            "    error_code: str = CheckoutErrorCode.PRODUCT_UNAVAILABLE_FOR_PURCHASE.value,",
            "):",
            "    (",
            "        not_available_variants,",
            "        not_available_graphql_ids,",
            "    ) = get_not_available_variants_for_purchase(variants_id, channel_id)",
            "    if not_available_variants:",
            "        raise ValidationError(",
            "            {",
            "                \"lines\": ValidationError(",
            "                    \"Cannot add lines for unavailable for purchase variants.\",",
            "                    code=error_code,",
            "                    params={\"variants\": not_available_graphql_ids},",
            "                )",
            "            }",
            "        )",
            "",
            "",
            "def get_not_published_variants(",
            "    variants_id: set, channel_id: int",
            ") -> tuple[set[int], set[str]]:",
            "    published_variants = product_models.ProductChannelListing.objects.filter(",
            "        channel_id=channel_id, product__variants__id__in=variants_id, is_published=True",
            "    ).values_list(\"product__variants__id\", flat=True)",
            "    not_published_ids = variants_id.difference(set(published_variants))",
            "    not_published_graphql_ids = {",
            "        graphene.Node.to_global_id(\"ProductVariant\", pk) for pk in not_published_ids",
            "    }",
            "    return not_published_ids, not_published_graphql_ids",
            "",
            "",
            "def validate_variants_are_published(",
            "    variants_id: set,",
            "    channel_id: int,",
            "    error_code: str = CheckoutErrorCode.PRODUCT_NOT_PUBLISHED.value,",
            "):",
            "    not_published_ids, not_published_graphql_ids = get_not_published_variants(",
            "        variants_id, channel_id",
            "    )",
            "    if not_published_ids:",
            "        raise ValidationError(",
            "            {",
            "                \"lines\": ValidationError(",
            "                    \"Cannot add lines for unpublished variants.\",",
            "                    code=error_code,",
            "                    params={\"variants\": not_published_graphql_ids},",
            "                )",
            "            }",
            "        )",
            "",
            "",
            "def get_checkout_by_token(",
            "    token: uuid.UUID, qs: Optional[QuerySet[models.Checkout]] = None",
            "):",
            "    if qs is None:",
            "        qs = models.Checkout.objects.select_related(",
            "            \"channel\",",
            "            \"shipping_method\",",
            "            \"collection_point\",",
            "            \"billing_address\",",
            "            \"shipping_address\",",
            "        )",
            "    try:",
            "        checkout = qs.get(token=token)",
            "    except ObjectDoesNotExist:",
            "        raise ValidationError(",
            "            {",
            "                \"token\": ValidationError(",
            "                    f\"Couldn't resolve to a node: {token}.\",",
            "                    code=CheckoutErrorCode.NOT_FOUND.value,",
            "                )",
            "            }",
            "        )",
            "    return checkout",
            "",
            "",
            "def get_checkout(",
            "    mutation_class: type[\"BaseMutation\"],",
            "    info: ResolveInfo,",
            "    checkout_id: Optional[str] = None,",
            "    token: Optional[uuid.UUID] = None,",
            "    id: Optional[str] = None,",
            "    qs: Optional[QuerySet] = None,",
            "):",
            "    \"\"\"Return checkout by using the current id field or the deprecated one.",
            "",
            "    It is helper logic to return a checkout for mutations that takes into account the",
            "    current `id` field and the deprecated one (`checkout_id`, `token`). If checkout is",
            "    not found, it will raise an exception.",
            "    \"\"\"",
            "",
            "    validate_one_of_args_is_in_mutation(",
            "        \"checkout_id\", checkout_id, \"token\", token, \"id\", id",
            "    )",
            "    if qs is None:",
            "        qs = models.Checkout.objects.select_related(",
            "            \"channel__tax_configuration\",",
            "            \"shipping_method\",",
            "            \"collection_point\",",
            "            \"billing_address\",",
            "            \"shipping_address\",",
            "        )",
            "",
            "    if id:",
            "        checkout = mutation_class.get_node_or_error(",
            "            info, id, only_type=Checkout, field=\"id\", qs=qs",
            "        )",
            "    else:  # DEPRECATED",
            "        if token:",
            "            checkout = get_checkout_by_token(token, qs=qs)",
            "        else:",
            "            checkout_id = cast(str, checkout_id)",
            "            checkout = mutation_class.get_node_or_error(",
            "                info, checkout_id, only_type=Checkout, field=\"checkout_id\", qs=qs",
            "            )",
            "    return checkout",
            "",
            "",
            "def group_lines_input_on_add(",
            "    lines: list[dict[str, Any]], existing_lines_info=None",
            ") -> list[CheckoutLineData]:",
            "    \"\"\"Return list od CheckoutLineData objects.",
            "",
            "    Lines data provided in CheckoutLineInput will be grouped depending on",
            "    provided parameters.",
            "    \"\"\"",
            "    grouped_checkout_lines_data: list[CheckoutLineData] = []",
            "    checkout_lines_data_map: dict[str, CheckoutLineData] = defaultdict(CheckoutLineData)",
            "",
            "    for line in lines:",
            "        variant_id = cast(str, line.get(\"variant_id\"))",
            "        force_new_line = line.get(\"force_new_line\")",
            "        metadata_list = line.get(\"metadata\")",
            "",
            "        _, variant_db_id = graphene.Node.from_global_id(variant_id)",
            "",
            "        if force_new_line:",
            "            line_data = CheckoutLineData(",
            "                variant_id=variant_db_id, metadata_list=metadata_list",
            "            )",
            "            grouped_checkout_lines_data.append(line_data)",
            "        else:",
            "            _, variant_db_id = graphene.Node.from_global_id(variant_id)",
            "",
            "            try:",
            "                line_db_id = find_line_id_when_variant_parameter_used(",
            "                    variant_db_id, existing_lines_info",
            "                )",
            "",
            "                if not line_db_id:",
            "                    line_data = checkout_lines_data_map[variant_db_id]",
            "                    line_data.variant_id = variant_db_id",
            "                    line_data.metadata_list = metadata_list",
            "                else:",
            "                    line_data = checkout_lines_data_map[line_db_id]",
            "                    line_data.line_id = line_db_id",
            "                    line_data.variant_id = find_variant_id_when_line_parameter_used(",
            "                        line_db_id, existing_lines_info",
            "                    )",
            "",
            "                    if line_data.metadata_list and metadata_list:",
            "                        line_data.metadata_list += metadata_list",
            "                    else:",
            "                        line_data.metadata_list = metadata_list",
            "",
            "            # when variant already exist in multiple lines then create a new line",
            "            except ValidationError:",
            "                line_data = CheckoutLineData(",
            "                    variant_id=variant_db_id, metadata_list=metadata_list",
            "                )",
            "                grouped_checkout_lines_data.append(line_data)",
            "",
            "        if (quantity := line.get(\"quantity\")) is not None:",
            "            line_data.quantity += quantity",
            "            line_data.quantity_to_update = True",
            "",
            "        if \"price\" in line:",
            "            line_data.custom_price = line[\"price\"]",
            "            line_data.custom_price_to_update = True",
            "",
            "    grouped_checkout_lines_data += list(checkout_lines_data_map.values())",
            "    return grouped_checkout_lines_data",
            "",
            "",
            "def group_lines_input_data_on_update(",
            "    lines: list[dict[str, Any]], existing_lines_info=None",
            ") -> list[CheckoutLineData]:",
            "    \"\"\"Return list od CheckoutLineData objects.",
            "",
            "    This function is used in CheckoutLinesUpdate mutation.",
            "    Lines data provided in CheckoutLineUpdateInput will be grouped depending on",
            "    provided parameters.",
            "    \"\"\"",
            "    grouped_checkout_lines_data: list[CheckoutLineData] = []",
            "    checkout_lines_data_map: dict[str, CheckoutLineData] = defaultdict(CheckoutLineData)",
            "",
            "    for line in lines:",
            "        variant_id = cast(str, line.get(\"variant_id\"))",
            "        line_id = cast(str, line.get(\"line_id\"))",
            "",
            "        if line_id:",
            "            _, line_db_id = graphene.Node.from_global_id(line_id)",
            "",
            "        if variant_id:",
            "            _, variant_db_id = graphene.Node.from_global_id(variant_id)",
            "            line_db_id = find_line_id_when_variant_parameter_used(",
            "                variant_db_id, existing_lines_info",
            "            )",
            "",
            "        if not line_db_id:",
            "            line_data = checkout_lines_data_map[variant_db_id]",
            "            line_data.variant_id = variant_db_id",
            "        else:",
            "            line_data = checkout_lines_data_map[line_db_id]",
            "            line_data.line_id = line_db_id",
            "            line_data.variant_id = find_variant_id_when_line_parameter_used(",
            "                line_db_id, existing_lines_info",
            "            )",
            "",
            "        if (quantity := line.get(\"quantity\")) is not None:",
            "            line_data.quantity += quantity",
            "            line_data.quantity_to_update = True",
            "",
            "        if \"price\" in line:",
            "            line_data.custom_price = line[\"price\"]",
            "            line_data.custom_price_to_update = True",
            "",
            "    grouped_checkout_lines_data += list(checkout_lines_data_map.values())",
            "    return grouped_checkout_lines_data",
            "",
            "",
            "def check_permissions_for_custom_prices(app, lines):",
            "    \"\"\"Raise PermissionDenied when custom price is changed by user or app without perm.",
            "",
            "    Checkout line custom price can be changed only by app with",
            "    handle checkout permission.",
            "    \"\"\"",
            "    if any([\"price\" in line for line in lines]) and (",
            "        not app or not app.has_perm(CheckoutPermissions.HANDLE_CHECKOUTS)",
            "    ):",
            "        raise PermissionDenied(permissions=[CheckoutPermissions.HANDLE_CHECKOUTS])",
            "",
            "",
            "def find_line_id_when_variant_parameter_used(",
            "    variant_db_id: str, lines_info: list[CheckoutLineInfo]",
            "):",
            "    \"\"\"Return line id when variantId parameter was used.",
            "",
            "    If variant exists in multiple lines error will be returned.",
            "    \"\"\"",
            "    if not lines_info:",
            "        return",
            "",
            "    line_info = list(filter(lambda x: (x.variant.pk == int(variant_db_id)), lines_info))",
            "",
            "    if not line_info:",
            "        return",
            "",
            "    # if same variant occur in multiple lines `lineId` parameter have to be used",
            "    if len(line_info) > 1:",
            "        message = (",
            "            \"Variant occurs in multiple lines. Use `lineId` instead of `variantId`.\"",
            "        )",
            "        variant_global_id = graphene.Node.to_global_id(\"ProductVariant\", variant_db_id)",
            "",
            "        raise ValidationError(",
            "            {",
            "                \"variantId\": ValidationError(",
            "                    message=message,",
            "                    code=CheckoutErrorCode.INVALID.value,",
            "                    params={\"variants\": [variant_global_id]},",
            "                )",
            "            }",
            "        )",
            "",
            "    return str(line_info[0].line.id)",
            "",
            "",
            "def find_variant_id_when_line_parameter_used(",
            "    line_db_id: str, lines_info: list[CheckoutLineInfo]",
            "):",
            "    \"\"\"Return variant id when lineId parameter was used.\"\"\"",
            "    if not lines_info:",
            "        return",
            "",
            "    line_info = list(filter(lambda x: (str(x.line.pk) == line_db_id), lines_info))",
            "    return str(line_info[0].line.variant_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}