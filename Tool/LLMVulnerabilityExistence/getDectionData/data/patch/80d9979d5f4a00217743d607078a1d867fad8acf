{
    "lib/streamlit/components/v1/components.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "             self.set_status(404)"
            },
            "1": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "             return"
            },
            "2": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 318,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        # follow symlinks to get an accurate normalized path"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+        component_root = os.path.realpath(component_root)"
            },
            "5": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "         filename = \"/\".join(parts[1:])"
            },
            "6": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        abspath = os.path.join(component_root, filename)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+        abspath = os.path.realpath(os.path.join(component_root, filename))"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+        # Do NOT expose anything outside of the component root."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+        if os.path.commonprefix([component_root, abspath]) != component_root:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+            self.write(\"forbidden\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+            self.set_status(403)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+            return"
            },
            "14": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 329,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)"
            },
            "16": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 331,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2018-2022 Streamlit Inc.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import inspect",
            "import json",
            "import mimetypes",
            "import os",
            "import threading",
            "from typing import Any, Dict, Optional, Type, Union",
            "",
            "import tornado.web",
            "from streamlit.scriptrunner import get_script_run_ctx",
            "",
            "import streamlit.server.routes",
            "from streamlit import type_util",
            "from streamlit.elements.form import current_form_id",
            "from streamlit import util",
            "from streamlit.errors import StreamlitAPIException",
            "from streamlit.logger import get_logger",
            "from streamlit.proto.Components_pb2 import SpecialArg, ArrowTable as ArrowTableProto",
            "from streamlit.proto.Element_pb2 import Element",
            "from streamlit.state import NoValue, register_widget",
            "from streamlit.type_util import to_bytes",
            "",
            "LOGGER = get_logger(__name__)",
            "",
            "",
            "class MarshallComponentException(StreamlitAPIException):",
            "    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class CustomComponent:",
            "    \"\"\"A Custom Component declaration.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        name: str,",
            "        path: Optional[str] = None,",
            "        url: Optional[str] = None,",
            "    ):",
            "        if (path is None and url is None) or (path is not None and url is not None):",
            "            raise StreamlitAPIException(",
            "                \"Either 'path' or 'url' must be set, but not both.\"",
            "            )",
            "",
            "        self.name = name",
            "        self.path = path",
            "        self.url = url",
            "",
            "    def __repr__(self) -> str:",
            "        return util.repr_(self)",
            "",
            "    @property",
            "    def abspath(self) -> Optional[str]:",
            "        \"\"\"The absolute path that the component is served from.\"\"\"",
            "        if self.path is None:",
            "            return None",
            "        return os.path.abspath(self.path)",
            "",
            "    def __call__(",
            "        self,",
            "        *args,",
            "        default: Any = None,",
            "        key: Optional[str] = None,",
            "        **kwargs,",
            "    ) -> Any:",
            "        \"\"\"An alias for create_instance.\"\"\"",
            "        return self.create_instance(*args, default=default, key=key, **kwargs)",
            "",
            "    def create_instance(",
            "        self,",
            "        *args,",
            "        default: Any = None,",
            "        key: Optional[str] = None,",
            "        **kwargs,",
            "    ) -> Any:",
            "        \"\"\"Create a new instance of the component.",
            "",
            "        Parameters",
            "        ----------",
            "        *args",
            "            Must be empty; all args must be named. (This parameter exists to",
            "            enforce correct use of the function.)",
            "        default: any or None",
            "            The default return value for the component. This is returned when",
            "            the component's frontend hasn't yet specified a value with",
            "            `setComponentValue`.",
            "        key: str or None",
            "            If not None, this is the user key we use to generate the",
            "            component's \"widget ID\".",
            "        **kwargs",
            "            Keyword args to pass to the component.",
            "",
            "        Returns",
            "        -------",
            "        any or None",
            "            The component's widget value.",
            "",
            "        \"\"\"",
            "        if len(args) > 0:",
            "            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")",
            "",
            "        try:",
            "            import pyarrow",
            "            from streamlit.components.v1 import component_arrow",
            "        except ImportError:",
            "            raise StreamlitAPIException(",
            "                \"\"\"To use Custom Components in Streamlit, you need to install",
            "PyArrow. To do so locally:",
            "",
            "`pip install pyarrow`",
            "",
            "And if you're using Streamlit Cloud, add \"pyarrow\" to your requirements.txt.\"\"\"",
            "            )",
            "",
            "        # In addition to the custom kwargs passed to the component, we also",
            "        # send the special 'default' and 'key' params to the component",
            "        # frontend.",
            "        all_args = dict(kwargs, **{\"default\": default, \"key\": key})",
            "",
            "        json_args = {}",
            "        special_args = []",
            "        for arg_name, arg_val in all_args.items():",
            "            if type_util.is_bytes_like(arg_val):",
            "                bytes_arg = SpecialArg()",
            "                bytes_arg.key = arg_name",
            "                bytes_arg.bytes = to_bytes(arg_val)",
            "                special_args.append(bytes_arg)",
            "            elif type_util.is_dataframe_like(arg_val):",
            "                dataframe_arg = SpecialArg()",
            "                dataframe_arg.key = arg_name",
            "                component_arrow.marshall(dataframe_arg.arrow_dataframe.data, arg_val)",
            "                special_args.append(dataframe_arg)",
            "            else:",
            "                json_args[arg_name] = arg_val",
            "",
            "        try:",
            "            serialized_json_args = json.dumps(json_args)",
            "        except BaseException as e:",
            "            raise MarshallComponentException(",
            "                \"Could not convert component args to JSON\", e",
            "            )",
            "",
            "        def marshall_component(dg, element: Element) -> Union[Any, Type[NoValue]]:",
            "            element.component_instance.component_name = self.name",
            "            element.component_instance.form_id = current_form_id(dg)",
            "            if self.url is not None:",
            "                element.component_instance.url = self.url",
            "",
            "            # Normally, a widget's element_hash (which determines",
            "            # its identity across multiple runs of an app) is computed",
            "            # by hashing the entirety of its protobuf. This means that,",
            "            # if any of the arguments to the widget are changed, Streamlit",
            "            # considers it a new widget instance and it loses its previous",
            "            # state.",
            "            #",
            "            # However! If a *component* has a `key` argument, then the",
            "            # component's hash identity is determined by entirely by",
            "            # `component_name + url + key`. This means that, when `key`",
            "            # exists, the component will maintain its identity even when its",
            "            # other arguments change, and the component's iframe won't be",
            "            # remounted on the frontend.",
            "            #",
            "            # So: if `key` is None, we marshall the element's arguments",
            "            # *before* computing its widget_ui_value (which creates its hash).",
            "            # If `key` is not None, we marshall the arguments *after*.",
            "",
            "            def marshall_element_args():",
            "                element.component_instance.json_args = serialized_json_args",
            "                element.component_instance.special_args.extend(special_args)",
            "",
            "            if key is None:",
            "                marshall_element_args()",
            "",
            "            def deserialize_component(ui_value, widget_id=\"\"):",
            "                # ui_value is an object from json, an ArrowTable proto, or a bytearray",
            "                return ui_value",
            "",
            "            ctx = get_script_run_ctx()",
            "            component_state = register_widget(",
            "                element_type=\"component_instance\",",
            "                element_proto=element.component_instance,",
            "                user_key=key,",
            "                widget_func_name=self.name,",
            "                deserializer=deserialize_component,",
            "                serializer=lambda x: x,",
            "                ctx=ctx,",
            "            )",
            "            widget_value = component_state.value",
            "",
            "            if key is not None:",
            "                marshall_element_args()",
            "",
            "            if widget_value is None:",
            "                widget_value = default",
            "            elif isinstance(widget_value, ArrowTableProto):",
            "                widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)",
            "",
            "            # widget_value will be either None or whatever the component's most",
            "            # recent setWidgetValue value is. We coerce None -> NoValue,",
            "            # because that's what DeltaGenerator._enqueue expects.",
            "            return widget_value if widget_value is not None else NoValue",
            "",
            "        # We currently only support writing to st._main, but this will change",
            "        # when we settle on an improved API in a post-layout world.",
            "        dg = streamlit._main",
            "",
            "        element = Element()",
            "        return_value = marshall_component(dg, element)",
            "        result = dg._enqueue(",
            "            \"component_instance\", element.component_instance, return_value",
            "        )",
            "",
            "        return result",
            "",
            "    def __eq__(self, other) -> bool:",
            "        \"\"\"Equality operator.\"\"\"",
            "        return (",
            "            isinstance(other, CustomComponent)",
            "            and self.name == other.name",
            "            and self.path == other.path",
            "            and self.url == other.url",
            "        )",
            "",
            "    def __ne__(self, other) -> bool:",
            "        \"\"\"Inequality operator.\"\"\"",
            "        return not self == other",
            "",
            "    def __str__(self) -> str:",
            "        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"",
            "",
            "",
            "def declare_component(",
            "    name: str,",
            "    path: Optional[str] = None,",
            "    url: Optional[str] = None,",
            ") -> CustomComponent:",
            "    \"\"\"Create and register a custom component.",
            "",
            "    Parameters",
            "    ----------",
            "    name: str",
            "        A short, descriptive name for the component. Like, \"slider\".",
            "    path: str or None",
            "        The path to serve the component's frontend files from. Either",
            "        `path` or `url` must be specified, but not both.",
            "    url: str or None",
            "        The URL that the component is served from. Either `path` or `url`",
            "        must be specified, but not both.",
            "",
            "    Returns",
            "    -------",
            "    CustomComponent",
            "        A CustomComponent that can be called like a function.",
            "        Calling the component will create a new instance of the component",
            "        in the Streamlit app.",
            "",
            "    \"\"\"",
            "",
            "    # Get our stack frame.",
            "    current_frame = inspect.currentframe()",
            "    assert current_frame is not None",
            "",
            "    # Get the stack frame of our calling function.",
            "    caller_frame = current_frame.f_back",
            "    assert caller_frame is not None",
            "",
            "    # Get the caller's module name. `__name__` gives us the module's",
            "    # fully-qualified name, which includes its package.",
            "    module = inspect.getmodule(caller_frame)",
            "    assert module is not None",
            "    module_name = module.__name__",
            "",
            "    # If the caller was the main module that was executed (that is, if the",
            "    # user executed `python my_component.py`), then this name will be",
            "    # \"__main__\" instead of the actual package name. In this case, we use",
            "    # the main module's filename, sans `.py` extension, as the component name.",
            "    if module_name == \"__main__\":",
            "        file_path = inspect.getfile(caller_frame)",
            "        filename = os.path.basename(file_path)",
            "        module_name, _ = os.path.splitext(filename)",
            "",
            "    # Build the component name.",
            "    component_name = f\"{module_name}.{name}\"",
            "",
            "    # Create our component object, and register it.",
            "    component = CustomComponent(name=component_name, path=path, url=url)",
            "    ComponentRegistry.instance().register_component(component)",
            "",
            "    return component",
            "",
            "",
            "class ComponentRequestHandler(tornado.web.RequestHandler):",
            "    def initialize(self, registry: \"ComponentRegistry\"):",
            "        self._registry = registry",
            "",
            "    def get(self, path: str) -> None:",
            "        parts = path.split(\"/\")",
            "        component_name = parts[0]",
            "        component_root = self._registry.get_component_path(component_name)",
            "        if component_root is None:",
            "            self.write(\"not found\")",
            "            self.set_status(404)",
            "            return",
            "",
            "        filename = \"/\".join(parts[1:])",
            "        abspath = os.path.join(component_root, filename)",
            "",
            "        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)",
            "",
            "        try:",
            "            with open(abspath, \"rb\") as file:",
            "                contents = file.read()",
            "        except (OSError) as e:",
            "            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)",
            "            self.write(\"read error\")",
            "            self.set_status(404)",
            "            return",
            "",
            "        self.write(contents)",
            "        self.set_header(\"Content-Type\", self.get_content_type(abspath))",
            "",
            "        self.set_extra_headers(path)",
            "",
            "    def set_extra_headers(self, path) -> None:",
            "        \"\"\"Disable cache for HTML files.",
            "",
            "        Other assets like JS and CSS are suffixed with their hash, so they can",
            "        be cached indefinitely.",
            "        \"\"\"",
            "        is_index_url = len(path) == 0",
            "",
            "        if is_index_url or path.endswith(\".html\"):",
            "            self.set_header(\"Cache-Control\", \"no-cache\")",
            "        else:",
            "            self.set_header(\"Cache-Control\", \"public\")",
            "",
            "    def set_default_headers(self) -> None:",
            "        if streamlit.server.routes.allow_cross_origin_requests():",
            "            self.set_header(\"Access-Control-Allow-Origin\", \"*\")",
            "",
            "    def options(self) -> None:",
            "        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    @staticmethod",
            "    def get_content_type(abspath) -> str:",
            "        \"\"\"Returns the ``Content-Type`` header to be used for this request.",
            "        From tornado.web.StaticFileHandler.",
            "        \"\"\"",
            "        mime_type, encoding = mimetypes.guess_type(abspath)",
            "        # per RFC 6713, use the appropriate type for a gzip compressed file",
            "        if encoding == \"gzip\":",
            "            return \"application/gzip\"",
            "        # As of 2015-07-21 there is no bzip2 encoding defined at",
            "        # http://www.iana.org/assignments/media-types/media-types.xhtml",
            "        # So for that (and any other encoding), use octet-stream.",
            "        elif encoding is not None:",
            "            return \"application/octet-stream\"",
            "        elif mime_type is not None:",
            "            return mime_type",
            "        # if mime_type not detected, use application/octet-stream",
            "        else:",
            "            return \"application/octet-stream\"",
            "",
            "    @staticmethod",
            "    def get_url(file_id: str) -> str:",
            "        \"\"\"Return the URL for a component file with the given ID.\"\"\"",
            "        return \"components/{}\".format(file_id)",
            "",
            "",
            "class ComponentRegistry:",
            "    _instance_lock: threading.Lock = threading.Lock()",
            "    _instance: Optional[\"ComponentRegistry\"] = None",
            "",
            "    @classmethod",
            "    def instance(cls) -> \"ComponentRegistry\":",
            "        \"\"\"Returns the singleton ComponentRegistry\"\"\"",
            "        # We use a double-checked locking optimization to avoid the overhead",
            "        # of acquiring the lock in the common case:",
            "        # https://en.wikipedia.org/wiki/Double-checked_locking",
            "        if cls._instance is None:",
            "            with cls._instance_lock:",
            "                if cls._instance is None:",
            "                    cls._instance = ComponentRegistry()",
            "        return cls._instance",
            "",
            "    def __init__(self):",
            "        self._components = {}  # type: Dict[str, CustomComponent]",
            "        self._lock = threading.Lock()",
            "",
            "    def __repr__(self) -> str:",
            "        return util.repr_(self)",
            "",
            "    def register_component(self, component: CustomComponent) -> None:",
            "        \"\"\"Register a CustomComponent.",
            "",
            "        Parameters",
            "        ----------",
            "        component : CustomComponent",
            "            The component to register.",
            "        \"\"\"",
            "",
            "        # Validate the component's path",
            "        abspath = component.abspath",
            "        if abspath is not None and not os.path.isdir(abspath):",
            "            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")",
            "",
            "        with self._lock:",
            "            existing = self._components.get(component.name)",
            "            self._components[component.name] = component",
            "",
            "        if existing is not None and component != existing:",
            "            LOGGER.warning(",
            "                \"%s overriding previously-registered %s\",",
            "                component,",
            "                existing,",
            "            )",
            "",
            "        LOGGER.debug(\"Registered component %s\", component)",
            "",
            "    def get_component_path(self, name: str) -> Optional[str]:",
            "        \"\"\"Return the filesystem path for the component with the given name.",
            "",
            "        If no such component is registered, or if the component exists but is",
            "        being served from a URL, return None instead.",
            "        \"\"\"",
            "        component = self._components.get(name, None)",
            "        return component.abspath if component is not None else None"
        ],
        "afterPatchFile": [
            "# Copyright 2018-2022 Streamlit Inc.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import inspect",
            "import json",
            "import mimetypes",
            "import os",
            "import threading",
            "from typing import Any, Dict, Optional, Type, Union",
            "",
            "import tornado.web",
            "from streamlit.scriptrunner import get_script_run_ctx",
            "",
            "import streamlit.server.routes",
            "from streamlit import type_util",
            "from streamlit.elements.form import current_form_id",
            "from streamlit import util",
            "from streamlit.errors import StreamlitAPIException",
            "from streamlit.logger import get_logger",
            "from streamlit.proto.Components_pb2 import SpecialArg, ArrowTable as ArrowTableProto",
            "from streamlit.proto.Element_pb2 import Element",
            "from streamlit.state import NoValue, register_widget",
            "from streamlit.type_util import to_bytes",
            "",
            "LOGGER = get_logger(__name__)",
            "",
            "",
            "class MarshallComponentException(StreamlitAPIException):",
            "    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class CustomComponent:",
            "    \"\"\"A Custom Component declaration.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        name: str,",
            "        path: Optional[str] = None,",
            "        url: Optional[str] = None,",
            "    ):",
            "        if (path is None and url is None) or (path is not None and url is not None):",
            "            raise StreamlitAPIException(",
            "                \"Either 'path' or 'url' must be set, but not both.\"",
            "            )",
            "",
            "        self.name = name",
            "        self.path = path",
            "        self.url = url",
            "",
            "    def __repr__(self) -> str:",
            "        return util.repr_(self)",
            "",
            "    @property",
            "    def abspath(self) -> Optional[str]:",
            "        \"\"\"The absolute path that the component is served from.\"\"\"",
            "        if self.path is None:",
            "            return None",
            "        return os.path.abspath(self.path)",
            "",
            "    def __call__(",
            "        self,",
            "        *args,",
            "        default: Any = None,",
            "        key: Optional[str] = None,",
            "        **kwargs,",
            "    ) -> Any:",
            "        \"\"\"An alias for create_instance.\"\"\"",
            "        return self.create_instance(*args, default=default, key=key, **kwargs)",
            "",
            "    def create_instance(",
            "        self,",
            "        *args,",
            "        default: Any = None,",
            "        key: Optional[str] = None,",
            "        **kwargs,",
            "    ) -> Any:",
            "        \"\"\"Create a new instance of the component.",
            "",
            "        Parameters",
            "        ----------",
            "        *args",
            "            Must be empty; all args must be named. (This parameter exists to",
            "            enforce correct use of the function.)",
            "        default: any or None",
            "            The default return value for the component. This is returned when",
            "            the component's frontend hasn't yet specified a value with",
            "            `setComponentValue`.",
            "        key: str or None",
            "            If not None, this is the user key we use to generate the",
            "            component's \"widget ID\".",
            "        **kwargs",
            "            Keyword args to pass to the component.",
            "",
            "        Returns",
            "        -------",
            "        any or None",
            "            The component's widget value.",
            "",
            "        \"\"\"",
            "        if len(args) > 0:",
            "            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")",
            "",
            "        try:",
            "            import pyarrow",
            "            from streamlit.components.v1 import component_arrow",
            "        except ImportError:",
            "            raise StreamlitAPIException(",
            "                \"\"\"To use Custom Components in Streamlit, you need to install",
            "PyArrow. To do so locally:",
            "",
            "`pip install pyarrow`",
            "",
            "And if you're using Streamlit Cloud, add \"pyarrow\" to your requirements.txt.\"\"\"",
            "            )",
            "",
            "        # In addition to the custom kwargs passed to the component, we also",
            "        # send the special 'default' and 'key' params to the component",
            "        # frontend.",
            "        all_args = dict(kwargs, **{\"default\": default, \"key\": key})",
            "",
            "        json_args = {}",
            "        special_args = []",
            "        for arg_name, arg_val in all_args.items():",
            "            if type_util.is_bytes_like(arg_val):",
            "                bytes_arg = SpecialArg()",
            "                bytes_arg.key = arg_name",
            "                bytes_arg.bytes = to_bytes(arg_val)",
            "                special_args.append(bytes_arg)",
            "            elif type_util.is_dataframe_like(arg_val):",
            "                dataframe_arg = SpecialArg()",
            "                dataframe_arg.key = arg_name",
            "                component_arrow.marshall(dataframe_arg.arrow_dataframe.data, arg_val)",
            "                special_args.append(dataframe_arg)",
            "            else:",
            "                json_args[arg_name] = arg_val",
            "",
            "        try:",
            "            serialized_json_args = json.dumps(json_args)",
            "        except BaseException as e:",
            "            raise MarshallComponentException(",
            "                \"Could not convert component args to JSON\", e",
            "            )",
            "",
            "        def marshall_component(dg, element: Element) -> Union[Any, Type[NoValue]]:",
            "            element.component_instance.component_name = self.name",
            "            element.component_instance.form_id = current_form_id(dg)",
            "            if self.url is not None:",
            "                element.component_instance.url = self.url",
            "",
            "            # Normally, a widget's element_hash (which determines",
            "            # its identity across multiple runs of an app) is computed",
            "            # by hashing the entirety of its protobuf. This means that,",
            "            # if any of the arguments to the widget are changed, Streamlit",
            "            # considers it a new widget instance and it loses its previous",
            "            # state.",
            "            #",
            "            # However! If a *component* has a `key` argument, then the",
            "            # component's hash identity is determined by entirely by",
            "            # `component_name + url + key`. This means that, when `key`",
            "            # exists, the component will maintain its identity even when its",
            "            # other arguments change, and the component's iframe won't be",
            "            # remounted on the frontend.",
            "            #",
            "            # So: if `key` is None, we marshall the element's arguments",
            "            # *before* computing its widget_ui_value (which creates its hash).",
            "            # If `key` is not None, we marshall the arguments *after*.",
            "",
            "            def marshall_element_args():",
            "                element.component_instance.json_args = serialized_json_args",
            "                element.component_instance.special_args.extend(special_args)",
            "",
            "            if key is None:",
            "                marshall_element_args()",
            "",
            "            def deserialize_component(ui_value, widget_id=\"\"):",
            "                # ui_value is an object from json, an ArrowTable proto, or a bytearray",
            "                return ui_value",
            "",
            "            ctx = get_script_run_ctx()",
            "            component_state = register_widget(",
            "                element_type=\"component_instance\",",
            "                element_proto=element.component_instance,",
            "                user_key=key,",
            "                widget_func_name=self.name,",
            "                deserializer=deserialize_component,",
            "                serializer=lambda x: x,",
            "                ctx=ctx,",
            "            )",
            "            widget_value = component_state.value",
            "",
            "            if key is not None:",
            "                marshall_element_args()",
            "",
            "            if widget_value is None:",
            "                widget_value = default",
            "            elif isinstance(widget_value, ArrowTableProto):",
            "                widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)",
            "",
            "            # widget_value will be either None or whatever the component's most",
            "            # recent setWidgetValue value is. We coerce None -> NoValue,",
            "            # because that's what DeltaGenerator._enqueue expects.",
            "            return widget_value if widget_value is not None else NoValue",
            "",
            "        # We currently only support writing to st._main, but this will change",
            "        # when we settle on an improved API in a post-layout world.",
            "        dg = streamlit._main",
            "",
            "        element = Element()",
            "        return_value = marshall_component(dg, element)",
            "        result = dg._enqueue(",
            "            \"component_instance\", element.component_instance, return_value",
            "        )",
            "",
            "        return result",
            "",
            "    def __eq__(self, other) -> bool:",
            "        \"\"\"Equality operator.\"\"\"",
            "        return (",
            "            isinstance(other, CustomComponent)",
            "            and self.name == other.name",
            "            and self.path == other.path",
            "            and self.url == other.url",
            "        )",
            "",
            "    def __ne__(self, other) -> bool:",
            "        \"\"\"Inequality operator.\"\"\"",
            "        return not self == other",
            "",
            "    def __str__(self) -> str:",
            "        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"",
            "",
            "",
            "def declare_component(",
            "    name: str,",
            "    path: Optional[str] = None,",
            "    url: Optional[str] = None,",
            ") -> CustomComponent:",
            "    \"\"\"Create and register a custom component.",
            "",
            "    Parameters",
            "    ----------",
            "    name: str",
            "        A short, descriptive name for the component. Like, \"slider\".",
            "    path: str or None",
            "        The path to serve the component's frontend files from. Either",
            "        `path` or `url` must be specified, but not both.",
            "    url: str or None",
            "        The URL that the component is served from. Either `path` or `url`",
            "        must be specified, but not both.",
            "",
            "    Returns",
            "    -------",
            "    CustomComponent",
            "        A CustomComponent that can be called like a function.",
            "        Calling the component will create a new instance of the component",
            "        in the Streamlit app.",
            "",
            "    \"\"\"",
            "",
            "    # Get our stack frame.",
            "    current_frame = inspect.currentframe()",
            "    assert current_frame is not None",
            "",
            "    # Get the stack frame of our calling function.",
            "    caller_frame = current_frame.f_back",
            "    assert caller_frame is not None",
            "",
            "    # Get the caller's module name. `__name__` gives us the module's",
            "    # fully-qualified name, which includes its package.",
            "    module = inspect.getmodule(caller_frame)",
            "    assert module is not None",
            "    module_name = module.__name__",
            "",
            "    # If the caller was the main module that was executed (that is, if the",
            "    # user executed `python my_component.py`), then this name will be",
            "    # \"__main__\" instead of the actual package name. In this case, we use",
            "    # the main module's filename, sans `.py` extension, as the component name.",
            "    if module_name == \"__main__\":",
            "        file_path = inspect.getfile(caller_frame)",
            "        filename = os.path.basename(file_path)",
            "        module_name, _ = os.path.splitext(filename)",
            "",
            "    # Build the component name.",
            "    component_name = f\"{module_name}.{name}\"",
            "",
            "    # Create our component object, and register it.",
            "    component = CustomComponent(name=component_name, path=path, url=url)",
            "    ComponentRegistry.instance().register_component(component)",
            "",
            "    return component",
            "",
            "",
            "class ComponentRequestHandler(tornado.web.RequestHandler):",
            "    def initialize(self, registry: \"ComponentRegistry\"):",
            "        self._registry = registry",
            "",
            "    def get(self, path: str) -> None:",
            "        parts = path.split(\"/\")",
            "        component_name = parts[0]",
            "        component_root = self._registry.get_component_path(component_name)",
            "        if component_root is None:",
            "            self.write(\"not found\")",
            "            self.set_status(404)",
            "            return",
            "",
            "        # follow symlinks to get an accurate normalized path",
            "        component_root = os.path.realpath(component_root)",
            "        filename = \"/\".join(parts[1:])",
            "        abspath = os.path.realpath(os.path.join(component_root, filename))",
            "",
            "        # Do NOT expose anything outside of the component root.",
            "        if os.path.commonprefix([component_root, abspath]) != component_root:",
            "            self.write(\"forbidden\")",
            "            self.set_status(403)",
            "            return",
            "",
            "        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)",
            "",
            "        try:",
            "            with open(abspath, \"rb\") as file:",
            "                contents = file.read()",
            "        except (OSError) as e:",
            "            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)",
            "            self.write(\"read error\")",
            "            self.set_status(404)",
            "            return",
            "",
            "        self.write(contents)",
            "        self.set_header(\"Content-Type\", self.get_content_type(abspath))",
            "",
            "        self.set_extra_headers(path)",
            "",
            "    def set_extra_headers(self, path) -> None:",
            "        \"\"\"Disable cache for HTML files.",
            "",
            "        Other assets like JS and CSS are suffixed with their hash, so they can",
            "        be cached indefinitely.",
            "        \"\"\"",
            "        is_index_url = len(path) == 0",
            "",
            "        if is_index_url or path.endswith(\".html\"):",
            "            self.set_header(\"Cache-Control\", \"no-cache\")",
            "        else:",
            "            self.set_header(\"Cache-Control\", \"public\")",
            "",
            "    def set_default_headers(self) -> None:",
            "        if streamlit.server.routes.allow_cross_origin_requests():",
            "            self.set_header(\"Access-Control-Allow-Origin\", \"*\")",
            "",
            "    def options(self) -> None:",
            "        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    @staticmethod",
            "    def get_content_type(abspath) -> str:",
            "        \"\"\"Returns the ``Content-Type`` header to be used for this request.",
            "        From tornado.web.StaticFileHandler.",
            "        \"\"\"",
            "        mime_type, encoding = mimetypes.guess_type(abspath)",
            "        # per RFC 6713, use the appropriate type for a gzip compressed file",
            "        if encoding == \"gzip\":",
            "            return \"application/gzip\"",
            "        # As of 2015-07-21 there is no bzip2 encoding defined at",
            "        # http://www.iana.org/assignments/media-types/media-types.xhtml",
            "        # So for that (and any other encoding), use octet-stream.",
            "        elif encoding is not None:",
            "            return \"application/octet-stream\"",
            "        elif mime_type is not None:",
            "            return mime_type",
            "        # if mime_type not detected, use application/octet-stream",
            "        else:",
            "            return \"application/octet-stream\"",
            "",
            "    @staticmethod",
            "    def get_url(file_id: str) -> str:",
            "        \"\"\"Return the URL for a component file with the given ID.\"\"\"",
            "        return \"components/{}\".format(file_id)",
            "",
            "",
            "class ComponentRegistry:",
            "    _instance_lock: threading.Lock = threading.Lock()",
            "    _instance: Optional[\"ComponentRegistry\"] = None",
            "",
            "    @classmethod",
            "    def instance(cls) -> \"ComponentRegistry\":",
            "        \"\"\"Returns the singleton ComponentRegistry\"\"\"",
            "        # We use a double-checked locking optimization to avoid the overhead",
            "        # of acquiring the lock in the common case:",
            "        # https://en.wikipedia.org/wiki/Double-checked_locking",
            "        if cls._instance is None:",
            "            with cls._instance_lock:",
            "                if cls._instance is None:",
            "                    cls._instance = ComponentRegistry()",
            "        return cls._instance",
            "",
            "    def __init__(self):",
            "        self._components = {}  # type: Dict[str, CustomComponent]",
            "        self._lock = threading.Lock()",
            "",
            "    def __repr__(self) -> str:",
            "        return util.repr_(self)",
            "",
            "    def register_component(self, component: CustomComponent) -> None:",
            "        \"\"\"Register a CustomComponent.",
            "",
            "        Parameters",
            "        ----------",
            "        component : CustomComponent",
            "            The component to register.",
            "        \"\"\"",
            "",
            "        # Validate the component's path",
            "        abspath = component.abspath",
            "        if abspath is not None and not os.path.isdir(abspath):",
            "            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")",
            "",
            "        with self._lock:",
            "            existing = self._components.get(component.name)",
            "            self._components[component.name] = component",
            "",
            "        if existing is not None and component != existing:",
            "            LOGGER.warning(",
            "                \"%s overriding previously-registered %s\",",
            "                component,",
            "                existing,",
            "            )",
            "",
            "        LOGGER.debug(\"Registered component %s\", component)",
            "",
            "    def get_component_path(self, name: str) -> Optional[str]:",
            "        \"\"\"Return the filesystem path for the component with the given name.",
            "",
            "        If no such component is registered, or if the component exists but is",
            "        being served from a URL, return None instead.",
            "        \"\"\"",
            "        component = self._components.get(name, None)",
            "        return component.abspath if component is not None else None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "320": [
                "ComponentRequestHandler",
                "get"
            ]
        },
        "addLocation": [
            "src.pyload.core.database.user_database"
        ]
    },
    "lib/tests/streamlit/components_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         self.assertEqual(200, response.code)"
            },
            "1": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "         self.assertEqual(b\"Test Content\", response.body)"
            },
            "2": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 436,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+    def test_outside_component_root_request(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+        \"\"\"Tests to ensure a path based on the root directory (and therefore"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+        outside of the component root) is disallowed.\"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+            # We don't need the return value in this case."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+            declare_component(\"test\", path=PATH)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+        response = self._request_component("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+            \"components_test.test//etc/hosts\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 447,
                "PatchRowcode": "+        )"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+        self.assertEqual(403, response.code)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+        self.assertEqual(b\"forbidden\", response.body)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+    def test_relative_outside_component_root_request(self):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+        \"\"\"Tests to ensure a path relative to the component root directory"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        (and specifically outside of the component root) is disallowed.\"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+            # We don't need the return value in this case."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+            declare_component(\"test\", path=PATH)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+        response = self._request_component("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+            \"components_test.test/../foo\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+        )"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+        self.assertEqual(403, response.code)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+        self.assertEqual(b\"forbidden\", response.body)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+    def test_symlink_outside_component_root_request(self):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+        \"\"\"Tests to ensure a path symlinked to a file outside the component"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 469,
                "PatchRowcode": "+        root directory is disallowed.\"\"\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+            # We don't need the return value in this case."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+            declare_component(\"test\", path=PATH)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+        with mock.patch("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+            \"streamlit.components.v1.components.os.path.realpath\","
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+            side_effect=[PATH, \"/etc/hosts\"],"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        ):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+            response = self._request_component("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+                \"components_test.test\""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 481,
                "PatchRowcode": "+            )"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+        self.assertEqual(403, response.code)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+        self.assertEqual(b\"forbidden\", response.body)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 486,
                "PatchRowcode": "     def test_invalid_component_request(self):"
            },
            "53": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 487,
                "PatchRowcode": "         \"\"\"Test request failure when invalid component name is provided.\"\"\""
            },
            "54": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 488,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2018-2022 Streamlit Inc.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import json",
            "import os",
            "import unittest",
            "from typing import Any",
            "from unittest import mock",
            "from unittest.mock import patch",
            "",
            "import pandas as pd",
            "import pytest",
            "import tornado.testing",
            "import tornado.web",
            "",
            "from streamlit import StreamlitAPIException",
            "from streamlit.components.v1 import component_arrow",
            "from streamlit.components.v1.components import (",
            "    ComponentRegistry,",
            "    ComponentRequestHandler,",
            "    CustomComponent,",
            "    declare_component,",
            ")",
            "import streamlit.components.v1 as components",
            "from streamlit.errors import DuplicateWidgetID",
            "from streamlit.proto.Components_pb2 import SpecialArg",
            "from streamlit.type_util import to_bytes",
            "from tests import testutil",
            "from tests.testutil import DeltaGeneratorTestCase",
            "import streamlit as st",
            "",
            "URL = \"http://not.a.real.url:3001\"",
            "PATH = \"not/a/real/path\"",
            "",
            "",
            "def _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:",
            "    special_arg = SpecialArg()",
            "    special_arg.key = key",
            "    component_arrow.marshall(special_arg.arrow_dataframe.data, value)",
            "    return special_arg",
            "",
            "",
            "def _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:",
            "    special_arg = SpecialArg()",
            "    special_arg.key = key",
            "    special_arg.bytes = to_bytes(value)",
            "    return special_arg",
            "",
            "",
            "class DeclareComponentTest(unittest.TestCase):",
            "    \"\"\"Test component declaration.\"\"\"",
            "",
            "    def tearDown(self) -> None:",
            "        ComponentRegistry._instance = None",
            "",
            "    def test_name(self):",
            "        \"\"\"Test component name generation\"\"\"",
            "        # Test a component defined in a module with no package",
            "        component = components.declare_component(\"foo\", url=URL)",
            "        self.assertEqual(\"components_test.foo\", component.name)",
            "",
            "        # Test a component defined in __init__.py",
            "        from component_test_data import component as init_component",
            "",
            "        self.assertEqual(",
            "            \"component_test_data.foo\",",
            "            init_component.name,",
            "        )",
            "",
            "        # Test a component defined in a module within a package",
            "        from component_test_data.outer_module import component as outer_module_component",
            "",
            "        self.assertEqual(",
            "            \"component_test_data.outer_module.foo\",",
            "            outer_module_component.name,",
            "        )",
            "",
            "        # Test a component defined in module within a nested package",
            "        from component_test_data.nested.inner_module import (",
            "            component as inner_module_component,",
            "        )",
            "",
            "        self.assertEqual(",
            "            \"component_test_data.nested.inner_module.foo\",",
            "            inner_module_component.name,",
            "        )",
            "",
            "    def test_only_path(self):",
            "        \"\"\"Succeed when a path is provided.\"\"\"",
            "",
            "        def isdir(path):",
            "            return path == PATH or path == os.path.abspath(PATH)",
            "",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir",
            "        ):",
            "            component = components.declare_component(\"test\", path=PATH)",
            "",
            "        self.assertEqual(PATH, component.path)",
            "        self.assertIsNone(component.url)",
            "",
            "        self.assertEqual(",
            "            ComponentRegistry.instance().get_component_path(component.name),",
            "            component.abspath,",
            "        )",
            "",
            "    def test_only_url(self):",
            "        \"\"\"Succeed when a URL is provided.\"\"\"",
            "        component = components.declare_component(\"test\", url=URL)",
            "        self.assertEqual(URL, component.url)",
            "        self.assertIsNone(component.path)",
            "",
            "        self.assertEqual(",
            "            ComponentRegistry.instance().get_component_path(\"components_test\"),",
            "            component.abspath,",
            "        )",
            "",
            "    def test_path_and_url(self):",
            "        \"\"\"Fail if path AND url are provided.\"\"\"",
            "        with pytest.raises(StreamlitAPIException) as exception_message:",
            "            components.declare_component(\"test\", path=PATH, url=URL)",
            "        self.assertEqual(",
            "            \"Either 'path' or 'url' must be set, but not both.\",",
            "            str(exception_message.value),",
            "        )",
            "",
            "    def test_no_path_and_no_url(self):",
            "        \"\"\"Fail if neither path nor url is provided.\"\"\"",
            "        with pytest.raises(StreamlitAPIException) as exception_message:",
            "            components.declare_component(\"test\", path=None, url=None)",
            "        self.assertEqual(",
            "            \"Either 'path' or 'url' must be set, but not both.\",",
            "            str(exception_message.value),",
            "        )",
            "",
            "",
            "class ComponentRegistryTest(unittest.TestCase):",
            "    \"\"\"Test component registration.\"\"\"",
            "",
            "    def tearDown(self) -> None:",
            "        ComponentRegistry._instance = None",
            "",
            "    def test_register_component_with_path(self):",
            "        \"\"\"Registering a component should associate it with its path.\"\"\"",
            "        test_path = \"/a/test/component/directory\"",
            "",
            "        def isdir(path):",
            "            return path == test_path",
            "",
            "        registry = ComponentRegistry.instance()",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir",
            "        ):",
            "            registry.register_component(",
            "                CustomComponent(\"test_component\", path=test_path)",
            "            )",
            "",
            "        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))",
            "",
            "    def test_register_component_no_path(self):",
            "        \"\"\"It's not an error to register a component without a path.\"\"\"",
            "        registry = ComponentRegistry.instance()",
            "",
            "        # Return None when the component hasn't been registered",
            "        self.assertIsNone(registry.get_component_path(\"test_component\"))",
            "",
            "        # And also return None when the component doesn't have a path",
            "        registry.register_component(",
            "            CustomComponent(\"test_component\", url=\"http://not.a.url\")",
            "        )",
            "        self.assertIsNone(registry.get_component_path(\"test_component\"))",
            "",
            "    def test_register_invalid_path(self):",
            "        \"\"\"We raise an exception if a component is registered with a",
            "        non-existent path.",
            "        \"\"\"",
            "        test_path = \"/a/test/component/directory\"",
            "",
            "        registry = ComponentRegistry.instance()",
            "        with self.assertRaises(StreamlitAPIException) as ctx:",
            "            registry.register_component(CustomComponent(\"test_component\", test_path))",
            "            self.assertIn(\"No such component directory\", ctx.exception)",
            "",
            "    def test_register_duplicate_path(self):",
            "        \"\"\"It's not an error to re-register a component.",
            "        (This can happen during development).",
            "        \"\"\"",
            "        test_path_1 = \"/a/test/component/directory\"",
            "        test_path_2 = \"/another/test/component/directory\"",
            "",
            "        def isdir(path):",
            "            return path in (test_path_1, test_path_2)",
            "",
            "        registry = ComponentRegistry.instance()",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir",
            "        ):",
            "            registry.register_component(CustomComponent(\"test_component\", test_path_1))",
            "            registry.register_component(CustomComponent(\"test_component\", test_path_1))",
            "            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))",
            "",
            "            registry.register_component(CustomComponent(\"test_component\", test_path_2))",
            "            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))",
            "",
            "",
            "class InvokeComponentTest(DeltaGeneratorTestCase):",
            "    \"\"\"Test invocation of a custom component object.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.test_component = components.declare_component(\"test\", url=URL)",
            "",
            "    def test_only_json_args(self):",
            "        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"",
            "        self.test_component(foo=\"bar\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual(",
            "            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args",
            "        )",
            "        self.assertEqual(\"[]\", str(proto.special_args))",
            "",
            "    def test_only_df_args(self):",
            "        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"",
            "        raw_data = {",
            "            \"First Name\": [\"Jason\", \"Molly\"],",
            "            \"Last Name\": [\"Miller\", \"Jacobson\"],",
            "            \"Age\": [42, 52],",
            "        }",
            "        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])",
            "        self.test_component(df=df)",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "        self.assertEqual(1, len(proto.special_args))",
            "        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])",
            "",
            "    def test_only_list_args(self):",
            "        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"",
            "        self.test_component(data=[\"foo\", \"bar\", \"baz\"])",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual(",
            "            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},",
            "            proto.json_args,",
            "        )",
            "        self.assertEqual(\"[]\", str(proto.special_args))",
            "",
            "    def test_no_args(self):",
            "        \"\"\"Test that component with no args is marshalled correctly.\"\"\"",
            "        self.test_component()",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "        self.assertEqual(\"[]\", str(proto.special_args))",
            "",
            "    def test_bytes_args(self):",
            "        self.test_component(foo=b\"foo\", bar=b\"bar\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "        self.assertEqual(2, len(proto.special_args))",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"foo\", b\"foo\"),",
            "            proto.special_args[0],",
            "        )",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"bar\", b\"bar\"),",
            "            proto.special_args[1],",
            "        )",
            "",
            "    def test_mixed_args(self):",
            "        \"\"\"Test marshalling of a component with varied arg types.\"\"\"",
            "        df = pd.DataFrame(",
            "            {",
            "                \"First Name\": [\"Jason\", \"Molly\"],",
            "                \"Last Name\": [\"Miller\", \"Jacobson\"],",
            "                \"Age\": [42, 52],",
            "            },",
            "            columns=[\"First Name\", \"Last Name\", \"Age\"],",
            "        )",
            "        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual(",
            "            {\"string_arg\": \"string\", \"key\": None, \"default\": None},",
            "            proto.json_args,",
            "        )",
            "        self.assertEqual(2, len(proto.special_args))",
            "        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]",
            "        )",
            "",
            "    def test_duplicate_key(self):",
            "        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"",
            "        self.test_component(foo=\"bar\", key=\"baz\")",
            "",
            "        with self.assertRaises(DuplicateWidgetID):",
            "            self.test_component(key=\"baz\")",
            "",
            "    def test_key_sent_to_frontend(self):",
            "        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"",
            "        # Test a string key",
            "        self.test_component(key=\"baz\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)",
            "",
            "        # Test an empty key",
            "        self.test_component()",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "",
            "    def test_simple_default(self):",
            "        \"\"\"Test the 'default' param with a JSON value.\"\"\"",
            "        return_value = self.test_component(default=\"baz\")",
            "        self.assertEqual(\"baz\", return_value)",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)",
            "",
            "    def test_bytes_default(self):",
            "        \"\"\"Test the 'default' param with a bytes value.\"\"\"",
            "        return_value = self.test_component(default=b\"bytes\")",
            "        self.assertEqual(b\"bytes\", return_value)",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None}, proto.json_args)",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"default\", b\"bytes\"),",
            "            proto.special_args[0],",
            "        )",
            "",
            "    def test_df_default(self):",
            "        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"",
            "        df = pd.DataFrame(",
            "            {",
            "                \"First Name\": [\"Jason\", \"Molly\"],",
            "                \"Last Name\": [\"Miller\", \"Jacobson\"],",
            "                \"Age\": [42, 52],",
            "            },",
            "            columns=[\"First Name\", \"Last Name\", \"Age\"],",
            "        )",
            "        return_value = self.test_component(default=df)",
            "        self.assertTrue(df.equals(return_value), \"df != return_value\")",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None}, proto.json_args)",
            "        self.assertEqual(",
            "            _serialize_dataframe_arg(\"default\", df),",
            "            proto.special_args[0],",
            "        )",
            "",
            "    def assertJSONEqual(self, a, b):",
            "        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,",
            "        it will be first converted to a dict with json.loads().\"\"\"",
            "        # Ensure both objects are dicts.",
            "        dict_a = a if isinstance(a, dict) else json.loads(a)",
            "        dict_b = b if isinstance(b, dict) else json.loads(b)",
            "        self.assertEqual(dict_a, dict_b)",
            "",
            "    def test_outside_form(self):",
            "        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"",
            "",
            "        self.test_component()",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertEqual(proto.form_id, \"\")",
            "",
            "    @patch(\"streamlit._is_running_with_streamlit\", new=True)",
            "    def test_inside_form(self):",
            "        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"",
            "",
            "        with st.form(\"foo\"):",
            "            self.test_component()",
            "",
            "        # 2 elements will be created: form block, widget",
            "        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)",
            "",
            "        form_proto = self.get_delta_from_queue(0).add_block",
            "        component_instance_proto = self.get_delta_from_queue(",
            "            1",
            "        ).new_element.component_instance",
            "        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)",
            "",
            "",
            "class ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):",
            "    \"\"\"Test /component endpoint.\"\"\"",
            "",
            "    def tearDown(self) -> None:",
            "        ComponentRegistry._instance = None",
            "",
            "    def get_app(self):",
            "        self.registry = ComponentRegistry()",
            "        return tornado.web.Application(",
            "            [",
            "                (",
            "                    \"/component/(.*)\",",
            "                    ComponentRequestHandler,",
            "                    dict(registry=self.registry.instance()),",
            "                )",
            "            ]",
            "        )",
            "",
            "    def _request_component(self, path):",
            "        return self.fetch(\"/component/%s\" % path, method=\"GET\")",
            "",
            "    def test_success_request(self):",
            "        \"\"\"Test request success when valid parameters are provided.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            # We don't need the return value in this case.",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.open\",",
            "            mock.mock_open(read_data=\"Test Content\"),",
            "        ):",
            "            response = self._request_component(\"components_test.test\")",
            "",
            "        self.assertEqual(200, response.code)",
            "        self.assertEqual(b\"Test Content\", response.body)",
            "",
            "    def test_invalid_component_request(self):",
            "        \"\"\"Test request failure when invalid component name is provided.\"\"\"",
            "",
            "        response = self._request_component(\"invalid_component\")",
            "        self.assertEqual(404, response.code)",
            "        self.assertEqual(b\"not found\", response.body)",
            "",
            "    def test_invalid_content_request(self):",
            "        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.open\") as m:",
            "            m.side_effect = OSError(\"Invalid content\")",
            "            response = self._request_component(\"components_test.test\")",
            "",
            "        self.assertEqual(404, response.code)",
            "        self.assertEqual(",
            "            b\"read error\",",
            "            response.body,",
            "        )",
            "",
            "    def test_support_binary_files_request(self):",
            "        \"\"\"Test support for binary files reads.\"\"\"",
            "",
            "        def _open_read(m, payload):",
            "            is_binary = False",
            "            args, kwargs = m.call_args",
            "            if len(args) > 1:",
            "                if \"b\" in args[1]:",
            "                    is_binary = True",
            "            encoding = \"utf-8\"",
            "            if \"encoding\" in kwargs:",
            "                encoding = kwargs[\"encoding\"]",
            "",
            "            if is_binary:",
            "                from io import BytesIO",
            "",
            "                return BytesIO(payload)",
            "            else:",
            "                from io import TextIOWrapper",
            "",
            "                return TextIOWrapper(str(payload, encoding=encoding))",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.open\") as m:",
            "            m.return_value.__enter__ = lambda _: _open_read(m, payload)",
            "            response = self._request_component(\"components_test.test\")",
            "",
            "        self.assertEqual(200, response.code)",
            "        self.assertEqual(",
            "            payload,",
            "            response.body,",
            "        )",
            "",
            "",
            "class IFrameTest(testutil.DeltaGeneratorTestCase):",
            "    def test_iframe(self):",
            "        \"\"\"Test components.iframe\"\"\"",
            "        components.iframe(\"http://not.a.url\", width=200, scrolling=True)",
            "",
            "        el = self.get_delta_from_queue().new_element",
            "        self.assertEqual(el.iframe.src, \"http://not.a.url\")",
            "        self.assertEqual(el.iframe.srcdoc, \"\")",
            "        self.assertEqual(el.iframe.width, 200)",
            "        self.assertTrue(el.iframe.has_width)",
            "        self.assertTrue(el.iframe.scrolling)",
            "",
            "    def test_html(self):",
            "        \"\"\"Test components.html\"\"\"",
            "        html = r\"<html><body>An HTML string!</body></html>\"",
            "        components.html(html, width=200, scrolling=True)",
            "",
            "        el = self.get_delta_from_queue().new_element",
            "        self.assertEqual(el.iframe.src, \"\")",
            "        self.assertEqual(el.iframe.srcdoc, html)",
            "        self.assertEqual(el.iframe.width, 200)",
            "        self.assertTrue(el.iframe.has_width)",
            "        self.assertTrue(el.iframe.scrolling)"
        ],
        "afterPatchFile": [
            "# Copyright 2018-2022 Streamlit Inc.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import json",
            "import os",
            "import unittest",
            "from typing import Any",
            "from unittest import mock",
            "from unittest.mock import patch",
            "",
            "import pandas as pd",
            "import pytest",
            "import tornado.testing",
            "import tornado.web",
            "",
            "from streamlit import StreamlitAPIException",
            "from streamlit.components.v1 import component_arrow",
            "from streamlit.components.v1.components import (",
            "    ComponentRegistry,",
            "    ComponentRequestHandler,",
            "    CustomComponent,",
            "    declare_component,",
            ")",
            "import streamlit.components.v1 as components",
            "from streamlit.errors import DuplicateWidgetID",
            "from streamlit.proto.Components_pb2 import SpecialArg",
            "from streamlit.type_util import to_bytes",
            "from tests import testutil",
            "from tests.testutil import DeltaGeneratorTestCase",
            "import streamlit as st",
            "",
            "URL = \"http://not.a.real.url:3001\"",
            "PATH = \"not/a/real/path\"",
            "",
            "",
            "def _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:",
            "    special_arg = SpecialArg()",
            "    special_arg.key = key",
            "    component_arrow.marshall(special_arg.arrow_dataframe.data, value)",
            "    return special_arg",
            "",
            "",
            "def _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:",
            "    special_arg = SpecialArg()",
            "    special_arg.key = key",
            "    special_arg.bytes = to_bytes(value)",
            "    return special_arg",
            "",
            "",
            "class DeclareComponentTest(unittest.TestCase):",
            "    \"\"\"Test component declaration.\"\"\"",
            "",
            "    def tearDown(self) -> None:",
            "        ComponentRegistry._instance = None",
            "",
            "    def test_name(self):",
            "        \"\"\"Test component name generation\"\"\"",
            "        # Test a component defined in a module with no package",
            "        component = components.declare_component(\"foo\", url=URL)",
            "        self.assertEqual(\"components_test.foo\", component.name)",
            "",
            "        # Test a component defined in __init__.py",
            "        from component_test_data import component as init_component",
            "",
            "        self.assertEqual(",
            "            \"component_test_data.foo\",",
            "            init_component.name,",
            "        )",
            "",
            "        # Test a component defined in a module within a package",
            "        from component_test_data.outer_module import component as outer_module_component",
            "",
            "        self.assertEqual(",
            "            \"component_test_data.outer_module.foo\",",
            "            outer_module_component.name,",
            "        )",
            "",
            "        # Test a component defined in module within a nested package",
            "        from component_test_data.nested.inner_module import (",
            "            component as inner_module_component,",
            "        )",
            "",
            "        self.assertEqual(",
            "            \"component_test_data.nested.inner_module.foo\",",
            "            inner_module_component.name,",
            "        )",
            "",
            "    def test_only_path(self):",
            "        \"\"\"Succeed when a path is provided.\"\"\"",
            "",
            "        def isdir(path):",
            "            return path == PATH or path == os.path.abspath(PATH)",
            "",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir",
            "        ):",
            "            component = components.declare_component(\"test\", path=PATH)",
            "",
            "        self.assertEqual(PATH, component.path)",
            "        self.assertIsNone(component.url)",
            "",
            "        self.assertEqual(",
            "            ComponentRegistry.instance().get_component_path(component.name),",
            "            component.abspath,",
            "        )",
            "",
            "    def test_only_url(self):",
            "        \"\"\"Succeed when a URL is provided.\"\"\"",
            "        component = components.declare_component(\"test\", url=URL)",
            "        self.assertEqual(URL, component.url)",
            "        self.assertIsNone(component.path)",
            "",
            "        self.assertEqual(",
            "            ComponentRegistry.instance().get_component_path(\"components_test\"),",
            "            component.abspath,",
            "        )",
            "",
            "    def test_path_and_url(self):",
            "        \"\"\"Fail if path AND url are provided.\"\"\"",
            "        with pytest.raises(StreamlitAPIException) as exception_message:",
            "            components.declare_component(\"test\", path=PATH, url=URL)",
            "        self.assertEqual(",
            "            \"Either 'path' or 'url' must be set, but not both.\",",
            "            str(exception_message.value),",
            "        )",
            "",
            "    def test_no_path_and_no_url(self):",
            "        \"\"\"Fail if neither path nor url is provided.\"\"\"",
            "        with pytest.raises(StreamlitAPIException) as exception_message:",
            "            components.declare_component(\"test\", path=None, url=None)",
            "        self.assertEqual(",
            "            \"Either 'path' or 'url' must be set, but not both.\",",
            "            str(exception_message.value),",
            "        )",
            "",
            "",
            "class ComponentRegistryTest(unittest.TestCase):",
            "    \"\"\"Test component registration.\"\"\"",
            "",
            "    def tearDown(self) -> None:",
            "        ComponentRegistry._instance = None",
            "",
            "    def test_register_component_with_path(self):",
            "        \"\"\"Registering a component should associate it with its path.\"\"\"",
            "        test_path = \"/a/test/component/directory\"",
            "",
            "        def isdir(path):",
            "            return path == test_path",
            "",
            "        registry = ComponentRegistry.instance()",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir",
            "        ):",
            "            registry.register_component(",
            "                CustomComponent(\"test_component\", path=test_path)",
            "            )",
            "",
            "        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))",
            "",
            "    def test_register_component_no_path(self):",
            "        \"\"\"It's not an error to register a component without a path.\"\"\"",
            "        registry = ComponentRegistry.instance()",
            "",
            "        # Return None when the component hasn't been registered",
            "        self.assertIsNone(registry.get_component_path(\"test_component\"))",
            "",
            "        # And also return None when the component doesn't have a path",
            "        registry.register_component(",
            "            CustomComponent(\"test_component\", url=\"http://not.a.url\")",
            "        )",
            "        self.assertIsNone(registry.get_component_path(\"test_component\"))",
            "",
            "    def test_register_invalid_path(self):",
            "        \"\"\"We raise an exception if a component is registered with a",
            "        non-existent path.",
            "        \"\"\"",
            "        test_path = \"/a/test/component/directory\"",
            "",
            "        registry = ComponentRegistry.instance()",
            "        with self.assertRaises(StreamlitAPIException) as ctx:",
            "            registry.register_component(CustomComponent(\"test_component\", test_path))",
            "            self.assertIn(\"No such component directory\", ctx.exception)",
            "",
            "    def test_register_duplicate_path(self):",
            "        \"\"\"It's not an error to re-register a component.",
            "        (This can happen during development).",
            "        \"\"\"",
            "        test_path_1 = \"/a/test/component/directory\"",
            "        test_path_2 = \"/another/test/component/directory\"",
            "",
            "        def isdir(path):",
            "            return path in (test_path_1, test_path_2)",
            "",
            "        registry = ComponentRegistry.instance()",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir",
            "        ):",
            "            registry.register_component(CustomComponent(\"test_component\", test_path_1))",
            "            registry.register_component(CustomComponent(\"test_component\", test_path_1))",
            "            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))",
            "",
            "            registry.register_component(CustomComponent(\"test_component\", test_path_2))",
            "            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))",
            "",
            "",
            "class InvokeComponentTest(DeltaGeneratorTestCase):",
            "    \"\"\"Test invocation of a custom component object.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.test_component = components.declare_component(\"test\", url=URL)",
            "",
            "    def test_only_json_args(self):",
            "        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"",
            "        self.test_component(foo=\"bar\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual(",
            "            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args",
            "        )",
            "        self.assertEqual(\"[]\", str(proto.special_args))",
            "",
            "    def test_only_df_args(self):",
            "        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"",
            "        raw_data = {",
            "            \"First Name\": [\"Jason\", \"Molly\"],",
            "            \"Last Name\": [\"Miller\", \"Jacobson\"],",
            "            \"Age\": [42, 52],",
            "        }",
            "        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])",
            "        self.test_component(df=df)",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "        self.assertEqual(1, len(proto.special_args))",
            "        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])",
            "",
            "    def test_only_list_args(self):",
            "        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"",
            "        self.test_component(data=[\"foo\", \"bar\", \"baz\"])",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual(",
            "            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},",
            "            proto.json_args,",
            "        )",
            "        self.assertEqual(\"[]\", str(proto.special_args))",
            "",
            "    def test_no_args(self):",
            "        \"\"\"Test that component with no args is marshalled correctly.\"\"\"",
            "        self.test_component()",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "        self.assertEqual(\"[]\", str(proto.special_args))",
            "",
            "    def test_bytes_args(self):",
            "        self.test_component(foo=b\"foo\", bar=b\"bar\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "        self.assertEqual(2, len(proto.special_args))",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"foo\", b\"foo\"),",
            "            proto.special_args[0],",
            "        )",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"bar\", b\"bar\"),",
            "            proto.special_args[1],",
            "        )",
            "",
            "    def test_mixed_args(self):",
            "        \"\"\"Test marshalling of a component with varied arg types.\"\"\"",
            "        df = pd.DataFrame(",
            "            {",
            "                \"First Name\": [\"Jason\", \"Molly\"],",
            "                \"Last Name\": [\"Miller\", \"Jacobson\"],",
            "                \"Age\": [42, 52],",
            "            },",
            "            columns=[\"First Name\", \"Last Name\", \"Age\"],",
            "        )",
            "        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "",
            "        self.assertEqual(self.test_component.name, proto.component_name)",
            "        self.assertJSONEqual(",
            "            {\"string_arg\": \"string\", \"key\": None, \"default\": None},",
            "            proto.json_args,",
            "        )",
            "        self.assertEqual(2, len(proto.special_args))",
            "        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]",
            "        )",
            "",
            "    def test_duplicate_key(self):",
            "        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"",
            "        self.test_component(foo=\"bar\", key=\"baz\")",
            "",
            "        with self.assertRaises(DuplicateWidgetID):",
            "            self.test_component(key=\"baz\")",
            "",
            "    def test_key_sent_to_frontend(self):",
            "        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"",
            "        # Test a string key",
            "        self.test_component(key=\"baz\")",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)",
            "",
            "        # Test an empty key",
            "        self.test_component()",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)",
            "",
            "    def test_simple_default(self):",
            "        \"\"\"Test the 'default' param with a JSON value.\"\"\"",
            "        return_value = self.test_component(default=\"baz\")",
            "        self.assertEqual(\"baz\", return_value)",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)",
            "",
            "    def test_bytes_default(self):",
            "        \"\"\"Test the 'default' param with a bytes value.\"\"\"",
            "        return_value = self.test_component(default=b\"bytes\")",
            "        self.assertEqual(b\"bytes\", return_value)",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None}, proto.json_args)",
            "        self.assertEqual(",
            "            _serialize_bytes_arg(\"default\", b\"bytes\"),",
            "            proto.special_args[0],",
            "        )",
            "",
            "    def test_df_default(self):",
            "        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"",
            "        df = pd.DataFrame(",
            "            {",
            "                \"First Name\": [\"Jason\", \"Molly\"],",
            "                \"Last Name\": [\"Miller\", \"Jacobson\"],",
            "                \"Age\": [42, 52],",
            "            },",
            "            columns=[\"First Name\", \"Last Name\", \"Age\"],",
            "        )",
            "        return_value = self.test_component(default=df)",
            "        self.assertTrue(df.equals(return_value), \"df != return_value\")",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertJSONEqual({\"key\": None}, proto.json_args)",
            "        self.assertEqual(",
            "            _serialize_dataframe_arg(\"default\", df),",
            "            proto.special_args[0],",
            "        )",
            "",
            "    def assertJSONEqual(self, a, b):",
            "        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,",
            "        it will be first converted to a dict with json.loads().\"\"\"",
            "        # Ensure both objects are dicts.",
            "        dict_a = a if isinstance(a, dict) else json.loads(a)",
            "        dict_b = b if isinstance(b, dict) else json.loads(b)",
            "        self.assertEqual(dict_a, dict_b)",
            "",
            "    def test_outside_form(self):",
            "        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"",
            "",
            "        self.test_component()",
            "",
            "        proto = self.get_delta_from_queue().new_element.component_instance",
            "        self.assertEqual(proto.form_id, \"\")",
            "",
            "    @patch(\"streamlit._is_running_with_streamlit\", new=True)",
            "    def test_inside_form(self):",
            "        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"",
            "",
            "        with st.form(\"foo\"):",
            "            self.test_component()",
            "",
            "        # 2 elements will be created: form block, widget",
            "        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)",
            "",
            "        form_proto = self.get_delta_from_queue(0).add_block",
            "        component_instance_proto = self.get_delta_from_queue(",
            "            1",
            "        ).new_element.component_instance",
            "        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)",
            "",
            "",
            "class ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):",
            "    \"\"\"Test /component endpoint.\"\"\"",
            "",
            "    def tearDown(self) -> None:",
            "        ComponentRegistry._instance = None",
            "",
            "    def get_app(self):",
            "        self.registry = ComponentRegistry()",
            "        return tornado.web.Application(",
            "            [",
            "                (",
            "                    \"/component/(.*)\",",
            "                    ComponentRequestHandler,",
            "                    dict(registry=self.registry.instance()),",
            "                )",
            "            ]",
            "        )",
            "",
            "    def _request_component(self, path):",
            "        return self.fetch(\"/component/%s\" % path, method=\"GET\")",
            "",
            "    def test_success_request(self):",
            "        \"\"\"Test request success when valid parameters are provided.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            # We don't need the return value in this case.",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.open\",",
            "            mock.mock_open(read_data=\"Test Content\"),",
            "        ):",
            "            response = self._request_component(\"components_test.test\")",
            "",
            "        self.assertEqual(200, response.code)",
            "        self.assertEqual(b\"Test Content\", response.body)",
            "",
            "    def test_outside_component_root_request(self):",
            "        \"\"\"Tests to ensure a path based on the root directory (and therefore",
            "        outside of the component root) is disallowed.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            # We don't need the return value in this case.",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        response = self._request_component(",
            "            \"components_test.test//etc/hosts\"",
            "        )",
            "",
            "        self.assertEqual(403, response.code)",
            "        self.assertEqual(b\"forbidden\", response.body)",
            "",
            "    def test_relative_outside_component_root_request(self):",
            "        \"\"\"Tests to ensure a path relative to the component root directory",
            "        (and specifically outside of the component root) is disallowed.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            # We don't need the return value in this case.",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        response = self._request_component(",
            "            \"components_test.test/../foo\"",
            "        )",
            "",
            "        self.assertEqual(403, response.code)",
            "        self.assertEqual(b\"forbidden\", response.body)",
            "",
            "    def test_symlink_outside_component_root_request(self):",
            "        \"\"\"Tests to ensure a path symlinked to a file outside the component",
            "        root directory is disallowed.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            # We don't need the return value in this case.",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        with mock.patch(",
            "            \"streamlit.components.v1.components.os.path.realpath\",",
            "            side_effect=[PATH, \"/etc/hosts\"],",
            "        ):",
            "            response = self._request_component(",
            "                \"components_test.test\"",
            "            )",
            "",
            "        self.assertEqual(403, response.code)",
            "        self.assertEqual(b\"forbidden\", response.body)",
            "",
            "    def test_invalid_component_request(self):",
            "        \"\"\"Test request failure when invalid component name is provided.\"\"\"",
            "",
            "        response = self._request_component(\"invalid_component\")",
            "        self.assertEqual(404, response.code)",
            "        self.assertEqual(b\"not found\", response.body)",
            "",
            "    def test_invalid_content_request(self):",
            "        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.open\") as m:",
            "            m.side_effect = OSError(\"Invalid content\")",
            "            response = self._request_component(\"components_test.test\")",
            "",
            "        self.assertEqual(404, response.code)",
            "        self.assertEqual(",
            "            b\"read error\",",
            "            response.body,",
            "        )",
            "",
            "    def test_support_binary_files_request(self):",
            "        \"\"\"Test support for binary files reads.\"\"\"",
            "",
            "        def _open_read(m, payload):",
            "            is_binary = False",
            "            args, kwargs = m.call_args",
            "            if len(args) > 1:",
            "                if \"b\" in args[1]:",
            "                    is_binary = True",
            "            encoding = \"utf-8\"",
            "            if \"encoding\" in kwargs:",
            "                encoding = kwargs[\"encoding\"]",
            "",
            "            if is_binary:",
            "                from io import BytesIO",
            "",
            "                return BytesIO(payload)",
            "            else:",
            "                from io import TextIOWrapper",
            "",
            "                return TextIOWrapper(str(payload, encoding=encoding))",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):",
            "            declare_component(\"test\", path=PATH)",
            "",
            "        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload",
            "",
            "        with mock.patch(\"streamlit.components.v1.components.open\") as m:",
            "            m.return_value.__enter__ = lambda _: _open_read(m, payload)",
            "            response = self._request_component(\"components_test.test\")",
            "",
            "        self.assertEqual(200, response.code)",
            "        self.assertEqual(",
            "            payload,",
            "            response.body,",
            "        )",
            "",
            "",
            "class IFrameTest(testutil.DeltaGeneratorTestCase):",
            "    def test_iframe(self):",
            "        \"\"\"Test components.iframe\"\"\"",
            "        components.iframe(\"http://not.a.url\", width=200, scrolling=True)",
            "",
            "        el = self.get_delta_from_queue().new_element",
            "        self.assertEqual(el.iframe.src, \"http://not.a.url\")",
            "        self.assertEqual(el.iframe.srcdoc, \"\")",
            "        self.assertEqual(el.iframe.width, 200)",
            "        self.assertTrue(el.iframe.has_width)",
            "        self.assertTrue(el.iframe.scrolling)",
            "",
            "    def test_html(self):",
            "        \"\"\"Test components.html\"\"\"",
            "        html = r\"<html><body>An HTML string!</body></html>\"",
            "        components.html(html, width=200, scrolling=True)",
            "",
            "        el = self.get_delta_from_queue().new_element",
            "        self.assertEqual(el.iframe.src, \"\")",
            "        self.assertEqual(el.iframe.srcdoc, html)",
            "        self.assertEqual(el.iframe.width, 200)",
            "        self.assertTrue(el.iframe.has_width)",
            "        self.assertTrue(el.iframe.scrolling)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.tests.streamlit.components_test.ComponentRequestHandlerTest.self",
            "src.pyload.core.database.user_database"
        ]
    }
}