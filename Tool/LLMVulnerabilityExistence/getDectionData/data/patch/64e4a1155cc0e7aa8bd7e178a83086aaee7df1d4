{
    "cps/MyLoginManager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from flask_login.utils import decode_cookie"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from flask_login.signals import user_loaded_from_cookie"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " class MyLoginManager(LoginManager):"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     def _session_protection_failed(self):"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         sess = session._get_current_object()"
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         ident = self._session_identifier_generator()"
            },
            "8": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         if(sess and not (len(sess) == 1"
            },
            "9": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                             and sess.get('csrf_token', None))) and ident != sess.get('_id', None):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+                         and sess.get('csrf_token', None))) and ident != sess.get('_id', None):"
            },
            "11": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "             return super(). _session_protection_failed()"
            },
            "12": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         return False"
            },
            "13": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "from flask_login import LoginManager, confirm_login",
            "from flask import session, current_app",
            "from flask_login.utils import decode_cookie",
            "from flask_login.signals import user_loaded_from_cookie",
            "",
            "class MyLoginManager(LoginManager):",
            "    def _session_protection_failed(self):",
            "        sess = session._get_current_object()",
            "        ident = self._session_identifier_generator()",
            "        if(sess and not (len(sess) == 1",
            "                             and sess.get('csrf_token', None))) and ident != sess.get('_id', None):",
            "            return super(). _session_protection_failed()",
            "        return False",
            "",
            "    def _load_user_from_remember_cookie(self, cookie):",
            "        user_id = decode_cookie(cookie)",
            "        if user_id is not None:",
            "            session[\"_user_id\"] = user_id",
            "            session[\"_fresh\"] = False",
            "            user = None",
            "            if self._user_callback:",
            "                user = self._user_callback(user_id)",
            "            if user is not None:",
            "                app = current_app._get_current_object()",
            "                user_loaded_from_cookie.send(app, user=user)",
            "                # if session was restored from remember me cookie make login valid",
            "                confirm_login()",
            "                return user",
            "        return None"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "",
            "from flask_login import LoginManager, confirm_login",
            "from flask import session, current_app",
            "from flask_login.utils import decode_cookie",
            "from flask_login.signals import user_loaded_from_cookie",
            "",
            "",
            "class MyLoginManager(LoginManager):",
            "    def _session_protection_failed(self):",
            "        sess = session._get_current_object()",
            "        ident = self._session_identifier_generator()",
            "        if(sess and not (len(sess) == 1",
            "                         and sess.get('csrf_token', None))) and ident != sess.get('_id', None):",
            "            return super(). _session_protection_failed()",
            "        return False",
            "",
            "    def _load_user_from_remember_cookie(self, cookie):",
            "        user_id = decode_cookie(cookie)",
            "        if user_id is not None:",
            "            session[\"_user_id\"] = user_id",
            "            session[\"_fresh\"] = False",
            "            user = None",
            "            if self._user_callback:",
            "                user = self._user_callback(user_id)",
            "            if user is not None:",
            "                app = current_app._get_current_object()",
            "                user_loaded_from_cookie.send(app, user=user)",
            "                # if session was restored from remember me cookie make login valid",
            "                confirm_login()",
            "                return user",
            "        return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "34": [
                "MyLoginManager",
                "_session_protection_failed"
            ]
        },
        "addLocation": []
    },
    "cps/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " else:"
            },
            "1": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     limiter = None"
            },
            "2": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " def create_app():"
            },
            "5": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     if csrf:"
            },
            "6": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         csrf.init_app(app)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "__package__ = \"cps\"",
            "",
            "import sys",
            "import os",
            "import mimetypes",
            "",
            "from flask import Flask",
            "from .MyLoginManager import MyLoginManager",
            "from flask_principal import Principal",
            "",
            "from . import logger",
            "from .cli import CliParameter",
            "from .constants import CONFIG_DIR",
            "from .reverseproxy import ReverseProxied",
            "from .server import WebServer",
            "from .dep_check import dependency_check",
            "from .updater import Updater",
            "from .babel import babel, get_locale",
            "from . import config_sql",
            "from . import cache_buster",
            "from . import ub, db",
            "",
            "try:",
            "    from flask_limiter import Limiter",
            "    limiter_present = True",
            "except ImportError:",
            "    limiter_present = False",
            "try:",
            "    from flask_wtf.csrf import CSRFProtect",
            "    wtf_present = True",
            "except ImportError:",
            "    wtf_present = False",
            "",
            "",
            "mimetypes.init()",
            "mimetypes.add_type('application/xhtml+xml', '.xhtml')",
            "mimetypes.add_type('application/epub+zip', '.epub')",
            "mimetypes.add_type('application/fb2+zip', '.fb2')",
            "mimetypes.add_type('application/x-mobipocket-ebook', '.mobi')",
            "mimetypes.add_type('application/x-mobipocket-ebook', '.prc')",
            "mimetypes.add_type('application/vnd.amazon.ebook', '.azw')",
            "mimetypes.add_type('application/x-mobi8-ebook', '.azw3')",
            "mimetypes.add_type('application/x-cbr', '.cbr')",
            "mimetypes.add_type('application/x-cbz', '.cbz')",
            "mimetypes.add_type('application/x-cbt', '.cbt')",
            "mimetypes.add_type('application/x-cb7', '.cb7')",
            "mimetypes.add_type('image/vnd.djv', '.djv')",
            "mimetypes.add_type('application/mpeg', '.mpeg')",
            "mimetypes.add_type('application/mpeg', '.mp3')",
            "mimetypes.add_type('application/mp4', '.m4a')",
            "mimetypes.add_type('application/mp4', '.m4b')",
            "mimetypes.add_type('application/ogg', '.ogg')",
            "mimetypes.add_type('application/ogg', '.oga')",
            "mimetypes.add_type('text/css', '.css')",
            "mimetypes.add_type('text/javascript; charset=UTF-8', '.js')",
            "",
            "log = logger.create()",
            "",
            "app = Flask(__name__)",
            "app.config.update(",
            "    SESSION_COOKIE_HTTPONLY=True,",
            "    SESSION_COOKIE_SAMESITE='Lax',",
            "    REMEMBER_COOKIE_SAMESITE='Lax',  # will be available in flask-login 0.5.1 earliest",
            "    WTF_CSRF_SSL_STRICT=False",
            ")",
            "",
            "lm = MyLoginManager()",
            "",
            "cli_param = CliParameter()",
            "",
            "config = config_sql.ConfigSQL()",
            "",
            "if wtf_present:",
            "    csrf = CSRFProtect()",
            "else:",
            "    csrf = None",
            "",
            "calibre_db = db.CalibreDB()",
            "",
            "web_server = WebServer()",
            "",
            "updater_thread = Updater()",
            "",
            "if limiter_present:",
            "    limiter = Limiter(key_func=True, headers_enabled=True, auto_check=False, swallow_errors=False)",
            "else:",
            "    limiter = None",
            "",
            "def create_app():",
            "    if csrf:",
            "        csrf.init_app(app)",
            "",
            "    cli_param.init()",
            "",
            "    ub.init_db(cli_param.settings_path)",
            "    # pylint: disable=no-member",
            "    encrypt_key, error = config_sql.get_encryption_key(os.path.dirname(cli_param.settings_path))",
            "",
            "    config_sql.load_configuration(ub.session, encrypt_key)",
            "    config.init_config(ub.session, encrypt_key, cli_param)",
            "",
            "    if error:",
            "        log.error(error)",
            "",
            "    ub.password_change(cli_param.user_credentials)",
            "",
            "    if sys.version_info < (3, 0):",
            "        log.info(",
            "            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, '",
            "            'please update your installation to Python3 ***')",
            "        print(",
            "            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, '",
            "            'please update your installation to Python3 ***')",
            "        web_server.stop(True)",
            "        sys.exit(5)",
            "",
            "    lm.login_view = 'web.login'",
            "    lm.anonymous_user = ub.Anonymous",
            "    lm.session_protection = 'strong' if config.config_session == 1 else \"basic\"",
            "",
            "    db.CalibreDB.update_config(config)",
            "    db.CalibreDB.setup_db(config.config_calibre_dir, cli_param.settings_path)",
            "    calibre_db.init_db()",
            "",
            "    updater_thread.init_updater(config, web_server)",
            "    # Perform dry run of updater and exit afterward",
            "    if cli_param.dry_run:",
            "        updater_thread.dry_run()",
            "        sys.exit(0)",
            "    updater_thread.start()",
            "    requirements = dependency_check()",
            "    for res in requirements:",
            "        if res['found'] == \"not installed\":",
            "            message = ('Cannot import {name} module, it is needed to run calibre-web, '",
            "                       'please install it using \"pip install {name}\"').format(name=res[\"name\"])",
            "            log.info(message)",
            "            print(\"*** \" + message + \" ***\")",
            "            web_server.stop(True)",
            "            sys.exit(8)",
            "    for res in requirements + dependency_check(True):",
            "        log.info('*** \"{}\" version does not meet the requirements. '",
            "                 'Should: {}, Found: {}, please consider installing required version ***'",
            "                 .format(res['name'],",
            "                         res['target'],",
            "                         res['found']))",
            "    app.wsgi_app = ReverseProxied(app.wsgi_app)",
            "",
            "    if os.environ.get('FLASK_DEBUG'):",
            "        cache_buster.init_cache_busting(app)",
            "    log.info('Starting Calibre Web...')",
            "    Principal(app)",
            "    lm.init_app(app)",
            "    app.secret_key = os.getenv('SECRET_KEY', config_sql.get_flask_session_key(ub.session))",
            "",
            "    web_server.init_app(app, config)",
            "    if hasattr(babel, \"localeselector\"):",
            "        babel.init_app(app)",
            "        babel.localeselector(get_locale)",
            "    else:",
            "        babel.init_app(app, locale_selector=get_locale)",
            "",
            "    from . import services",
            "",
            "    if services.ldap:",
            "        services.ldap.init_app(app, config)",
            "    if services.goodreads_support:",
            "        services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                           config.config_use_goodreads)",
            "    config.store_calibre_uuid(calibre_db, db.Library_Id)",
            "    # Configure rate limiter",
            "    # https://limits.readthedocs.io/en/stable/storage.html",
            "    app.config.update(RATELIMIT_ENABLED=config.config_ratelimiter)",
            "    if config.config_limiter_uri != \"\" and not cli_param.memory_backend:",
            "        app.config.update(RATELIMIT_STORAGE_URI=config.config_limiter_uri)",
            "        if config.config_limiter_options != \"\":",
            "            app.config.update(RATELIMIT_STORAGE_OPTIONS=config.config_limiter_options)",
            "    try:",
            "        limiter.init_app(app)",
            "    except Exception as e:",
            "        log.error('Wrong Flask Limiter configuration, falling back to default: {}'.format(e))",
            "        app.config.update(RATELIMIT_STORAGE_URI=None)",
            "        limiter.init_app(app)",
            "",
            "    # Register scheduled tasks",
            "    from .schedule import register_scheduled_tasks, register_startup_tasks",
            "    register_scheduled_tasks(config.schedule_reconnect)",
            "    register_startup_tasks()",
            "",
            "    return app"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "__package__ = \"cps\"",
            "",
            "import sys",
            "import os",
            "import mimetypes",
            "",
            "from flask import Flask",
            "from .MyLoginManager import MyLoginManager",
            "from flask_principal import Principal",
            "",
            "from . import logger",
            "from .cli import CliParameter",
            "from .constants import CONFIG_DIR",
            "from .reverseproxy import ReverseProxied",
            "from .server import WebServer",
            "from .dep_check import dependency_check",
            "from .updater import Updater",
            "from .babel import babel, get_locale",
            "from . import config_sql",
            "from . import cache_buster",
            "from . import ub, db",
            "",
            "try:",
            "    from flask_limiter import Limiter",
            "    limiter_present = True",
            "except ImportError:",
            "    limiter_present = False",
            "try:",
            "    from flask_wtf.csrf import CSRFProtect",
            "    wtf_present = True",
            "except ImportError:",
            "    wtf_present = False",
            "",
            "",
            "mimetypes.init()",
            "mimetypes.add_type('application/xhtml+xml', '.xhtml')",
            "mimetypes.add_type('application/epub+zip', '.epub')",
            "mimetypes.add_type('application/fb2+zip', '.fb2')",
            "mimetypes.add_type('application/x-mobipocket-ebook', '.mobi')",
            "mimetypes.add_type('application/x-mobipocket-ebook', '.prc')",
            "mimetypes.add_type('application/vnd.amazon.ebook', '.azw')",
            "mimetypes.add_type('application/x-mobi8-ebook', '.azw3')",
            "mimetypes.add_type('application/x-cbr', '.cbr')",
            "mimetypes.add_type('application/x-cbz', '.cbz')",
            "mimetypes.add_type('application/x-cbt', '.cbt')",
            "mimetypes.add_type('application/x-cb7', '.cb7')",
            "mimetypes.add_type('image/vnd.djv', '.djv')",
            "mimetypes.add_type('application/mpeg', '.mpeg')",
            "mimetypes.add_type('application/mpeg', '.mp3')",
            "mimetypes.add_type('application/mp4', '.m4a')",
            "mimetypes.add_type('application/mp4', '.m4b')",
            "mimetypes.add_type('application/ogg', '.ogg')",
            "mimetypes.add_type('application/ogg', '.oga')",
            "mimetypes.add_type('text/css', '.css')",
            "mimetypes.add_type('text/javascript; charset=UTF-8', '.js')",
            "",
            "log = logger.create()",
            "",
            "app = Flask(__name__)",
            "app.config.update(",
            "    SESSION_COOKIE_HTTPONLY=True,",
            "    SESSION_COOKIE_SAMESITE='Lax',",
            "    REMEMBER_COOKIE_SAMESITE='Lax',  # will be available in flask-login 0.5.1 earliest",
            "    WTF_CSRF_SSL_STRICT=False",
            ")",
            "",
            "lm = MyLoginManager()",
            "",
            "cli_param = CliParameter()",
            "",
            "config = config_sql.ConfigSQL()",
            "",
            "if wtf_present:",
            "    csrf = CSRFProtect()",
            "else:",
            "    csrf = None",
            "",
            "calibre_db = db.CalibreDB()",
            "",
            "web_server = WebServer()",
            "",
            "updater_thread = Updater()",
            "",
            "if limiter_present:",
            "    limiter = Limiter(key_func=True, headers_enabled=True, auto_check=False, swallow_errors=False)",
            "else:",
            "    limiter = None",
            "",
            "",
            "def create_app():",
            "    if csrf:",
            "        csrf.init_app(app)",
            "",
            "    cli_param.init()",
            "",
            "    ub.init_db(cli_param.settings_path)",
            "    # pylint: disable=no-member",
            "    encrypt_key, error = config_sql.get_encryption_key(os.path.dirname(cli_param.settings_path))",
            "",
            "    config_sql.load_configuration(ub.session, encrypt_key)",
            "    config.init_config(ub.session, encrypt_key, cli_param)",
            "",
            "    if error:",
            "        log.error(error)",
            "",
            "    ub.password_change(cli_param.user_credentials)",
            "",
            "    if sys.version_info < (3, 0):",
            "        log.info(",
            "            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, '",
            "            'please update your installation to Python3 ***')",
            "        print(",
            "            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, '",
            "            'please update your installation to Python3 ***')",
            "        web_server.stop(True)",
            "        sys.exit(5)",
            "",
            "    lm.login_view = 'web.login'",
            "    lm.anonymous_user = ub.Anonymous",
            "    lm.session_protection = 'strong' if config.config_session == 1 else \"basic\"",
            "",
            "    db.CalibreDB.update_config(config)",
            "    db.CalibreDB.setup_db(config.config_calibre_dir, cli_param.settings_path)",
            "    calibre_db.init_db()",
            "",
            "    updater_thread.init_updater(config, web_server)",
            "    # Perform dry run of updater and exit afterward",
            "    if cli_param.dry_run:",
            "        updater_thread.dry_run()",
            "        sys.exit(0)",
            "    updater_thread.start()",
            "    requirements = dependency_check()",
            "    for res in requirements:",
            "        if res['found'] == \"not installed\":",
            "            message = ('Cannot import {name} module, it is needed to run calibre-web, '",
            "                       'please install it using \"pip install {name}\"').format(name=res[\"name\"])",
            "            log.info(message)",
            "            print(\"*** \" + message + \" ***\")",
            "            web_server.stop(True)",
            "            sys.exit(8)",
            "    for res in requirements + dependency_check(True):",
            "        log.info('*** \"{}\" version does not meet the requirements. '",
            "                 'Should: {}, Found: {}, please consider installing required version ***'",
            "                 .format(res['name'],",
            "                         res['target'],",
            "                         res['found']))",
            "    app.wsgi_app = ReverseProxied(app.wsgi_app)",
            "",
            "    if os.environ.get('FLASK_DEBUG'):",
            "        cache_buster.init_cache_busting(app)",
            "    log.info('Starting Calibre Web...')",
            "    Principal(app)",
            "    lm.init_app(app)",
            "    app.secret_key = os.getenv('SECRET_KEY', config_sql.get_flask_session_key(ub.session))",
            "",
            "    web_server.init_app(app, config)",
            "    if hasattr(babel, \"localeselector\"):",
            "        babel.init_app(app)",
            "        babel.localeselector(get_locale)",
            "    else:",
            "        babel.init_app(app, locale_selector=get_locale)",
            "",
            "    from . import services",
            "",
            "    if services.ldap:",
            "        services.ldap.init_app(app, config)",
            "    if services.goodreads_support:",
            "        services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                           config.config_use_goodreads)",
            "    config.store_calibre_uuid(calibre_db, db.Library_Id)",
            "    # Configure rate limiter",
            "    # https://limits.readthedocs.io/en/stable/storage.html",
            "    app.config.update(RATELIMIT_ENABLED=config.config_ratelimiter)",
            "    if config.config_limiter_uri != \"\" and not cli_param.memory_backend:",
            "        app.config.update(RATELIMIT_STORAGE_URI=config.config_limiter_uri)",
            "        if config.config_limiter_options != \"\":",
            "            app.config.update(RATELIMIT_STORAGE_OPTIONS=config.config_limiter_options)",
            "    try:",
            "        limiter.init_app(app)",
            "    except Exception as e:",
            "        log.error('Wrong Flask Limiter configuration, falling back to default: {}'.format(e))",
            "        app.config.update(RATELIMIT_STORAGE_URI=None)",
            "        limiter.init_app(app)",
            "",
            "    # Register scheduled tasks",
            "    from .schedule import register_scheduled_tasks, register_startup_tasks",
            "    register_scheduled_tasks(config.schedule_reconnect)",
            "    register_startup_tasks()",
            "",
            "    return app"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "cps/admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 479,
                "afterPatchRowNumber": 479,
                "PatchRowcode": "                 elif param.endswith('role'):"
            },
            "1": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "                     value = int(vals['field_index'])"
            },
            "2": {
                "beforePatchRowNumber": 481,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "                     if user.name == \"Guest\" and value in \\"
            },
            "3": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+                      [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:"
            },
            "5": {
                "beforePatchRowNumber": 483,
                "afterPatchRowNumber": 483,
                "PatchRowcode": "                         raise Exception(_(\"Guest can't have this role\"))"
            },
            "6": {
                "beforePatchRowNumber": 484,
                "afterPatchRowNumber": 484,
                "PatchRowcode": "                     # check for valid value, last on checks for power of 2 value"
            },
            "7": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": 485,
                "PatchRowcode": "                     if value > 0 and value <= constants.ROLE_VIEWER and (value & value - 1 == 0 or value == 1):"
            },
            "8": {
                "beforePatchRowNumber": 945,
                "afterPatchRowNumber": 945,
                "PatchRowcode": " def check_valid_read_column(column):"
            },
            "9": {
                "beforePatchRowNumber": 946,
                "afterPatchRowNumber": 946,
                "PatchRowcode": "     if column != \"0\":"
            },
            "10": {
                "beforePatchRowNumber": 947,
                "afterPatchRowNumber": 947,
                "PatchRowcode": "         if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\"
            },
            "11": {
                "beforePatchRowNumber": 948,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 948,
                "PatchRowcode": "+          .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():"
            },
            "13": {
                "beforePatchRowNumber": 949,
                "afterPatchRowNumber": 949,
                "PatchRowcode": "             return False"
            },
            "14": {
                "beforePatchRowNumber": 950,
                "afterPatchRowNumber": 950,
                "PatchRowcode": "     return True"
            },
            "15": {
                "beforePatchRowNumber": 951,
                "afterPatchRowNumber": 951,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 952,
                "afterPatchRowNumber": 952,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 953,
                "afterPatchRowNumber": 953,
                "PatchRowcode": " def check_valid_restricted_column(column):"
            },
            "18": {
                "beforePatchRowNumber": 954,
                "afterPatchRowNumber": 954,
                "PatchRowcode": "     if column != \"0\":"
            },
            "19": {
                "beforePatchRowNumber": 955,
                "afterPatchRowNumber": 955,
                "PatchRowcode": "         if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\"
            },
            "20": {
                "beforePatchRowNumber": 956,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 956,
                "PatchRowcode": "+          .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():"
            },
            "22": {
                "beforePatchRowNumber": 957,
                "afterPatchRowNumber": 957,
                "PatchRowcode": "             return False"
            },
            "23": {
                "beforePatchRowNumber": 958,
                "afterPatchRowNumber": 958,
                "PatchRowcode": "     return True"
            },
            "24": {
                "beforePatchRowNumber": 959,
                "afterPatchRowNumber": 959,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 999,
                "afterPatchRowNumber": 999,
                "PatchRowcode": "     for d in string.ascii_uppercase:"
            },
            "26": {
                "beforePatchRowNumber": 1000,
                "afterPatchRowNumber": 1000,
                "PatchRowcode": "         if os.path.exists('{}:'.format(d)) and current[0].lower() != d.lower():"
            },
            "27": {
                "beforePatchRowNumber": 1001,
                "afterPatchRowNumber": 1001,
                "PatchRowcode": "             drive = \"{}:\\\\\".format(d)"
            },
            "28": {
                "beforePatchRowNumber": 1002,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data = {\"name\": drive, \"fullpath\": drive}"
            },
            "29": {
                "beforePatchRowNumber": 1003,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data[\"sort\"] = \"_\" + data[\"fullpath\"].lower()"
            },
            "30": {
                "beforePatchRowNumber": 1004,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data[\"type\"] = \"dir\""
            },
            "31": {
                "beforePatchRowNumber": 1005,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            data[\"size\"] = \"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1002,
                "PatchRowcode": "+            data = {\"name\": drive, \"fullpath\": drive, \"type\": \"dir\", \"size\": \"\", \"sort\": \"_\" + drive.lower()}"
            },
            "33": {
                "beforePatchRowNumber": 1006,
                "afterPatchRowNumber": 1003,
                "PatchRowcode": "             drive_letters.append(data)"
            },
            "34": {
                "beforePatchRowNumber": 1007,
                "afterPatchRowNumber": 1004,
                "PatchRowcode": "     return drive_letters"
            },
            "35": {
                "beforePatchRowNumber": 1008,
                "afterPatchRowNumber": 1005,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 1142,
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "     reboot_required = False"
            },
            "37": {
                "beforePatchRowNumber": 1143,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "     for element in oauthblueprints:"
            },
            "38": {
                "beforePatchRowNumber": 1144,
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "         if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\"
            },
            "39": {
                "beforePatchRowNumber": 1145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1142,
                "PatchRowcode": "+          or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:"
            },
            "41": {
                "beforePatchRowNumber": 1146,
                "afterPatchRowNumber": 1143,
                "PatchRowcode": "             reboot_required = True"
            },
            "42": {
                "beforePatchRowNumber": 1147,
                "afterPatchRowNumber": 1144,
                "PatchRowcode": "             element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]"
            },
            "43": {
                "beforePatchRowNumber": 1148,
                "afterPatchRowNumber": 1145,
                "PatchRowcode": "             element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]"
            },
            "44": {
                "beforePatchRowNumber": 1149,
                "afterPatchRowNumber": 1146,
                "PatchRowcode": "         if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\"
            },
            "45": {
                "beforePatchRowNumber": 1150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1147,
                "PatchRowcode": "+          and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:"
            },
            "47": {
                "beforePatchRowNumber": 1151,
                "afterPatchRowNumber": 1148,
                "PatchRowcode": "             active_oauths += 1"
            },
            "48": {
                "beforePatchRowNumber": 1152,
                "afterPatchRowNumber": 1149,
                "PatchRowcode": "             element[\"active\"] = 1"
            },
            "49": {
                "beforePatchRowNumber": 1153,
                "afterPatchRowNumber": 1150,
                "PatchRowcode": "         else:"
            },
            "50": {
                "beforePatchRowNumber": 1202,
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "     config.save()"
            },
            "51": {
                "beforePatchRowNumber": 1203,
                "afterPatchRowNumber": 1200,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 1204,
                "afterPatchRowNumber": 1201,
                "PatchRowcode": "     if not config.config_ldap_provider_url \\"
            },
            "53": {
                "beforePatchRowNumber": 1205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or not config.config_ldap_port \\"
            },
            "54": {
                "beforePatchRowNumber": 1206,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or not config.config_ldap_dn \\"
            },
            "55": {
                "beforePatchRowNumber": 1207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or not config.config_ldap_user_object:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1202,
                "PatchRowcode": "+      or not config.config_ldap_port \\"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1203,
                "PatchRowcode": "+      or not config.config_ldap_dn \\"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1204,
                "PatchRowcode": "+      or not config.config_ldap_user_object:"
            },
            "59": {
                "beforePatchRowNumber": 1208,
                "afterPatchRowNumber": 1205,
                "PatchRowcode": "         return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '"
            },
            "60": {
                "beforePatchRowNumber": 1209,
                "afterPatchRowNumber": 1206,
                "PatchRowcode": "                                                         'Port, DN and User Object Identifier'))"
            },
            "61": {
                "beforePatchRowNumber": 1210,
                "afterPatchRowNumber": 1207,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 1372,
                "afterPatchRowNumber": 1369,
                "PatchRowcode": "     error = False"
            },
            "63": {
                "beforePatchRowNumber": 1373,
                "afterPatchRowNumber": 1370,
                "PatchRowcode": "     to_save = request.form.to_dict()"
            },
            "64": {
                "beforePatchRowNumber": 1374,
                "afterPatchRowNumber": 1371,
                "PatchRowcode": "     if 0 <= int(to_save.get(\"schedule_start_time\")) <= 23:"
            },
            "65": {
                "beforePatchRowNumber": 1375,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _config_int( to_save, \"schedule_start_time\")"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1372,
                "PatchRowcode": "+        _config_int(to_save, \"schedule_start_time\")"
            },
            "67": {
                "beforePatchRowNumber": 1376,
                "afterPatchRowNumber": 1373,
                "PatchRowcode": "     else:"
            },
            "68": {
                "beforePatchRowNumber": 1377,
                "afterPatchRowNumber": 1374,
                "PatchRowcode": "         flash(_(\"Invalid start time for task specified\"), category=\"error\")"
            },
            "69": {
                "beforePatchRowNumber": 1378,
                "afterPatchRowNumber": 1375,
                "PatchRowcode": "         error = True"
            },
            "70": {
                "beforePatchRowNumber": 1720,
                "afterPatchRowNumber": 1717,
                "PatchRowcode": "         return _db_configuration_result('{}'.format(ex), gdrive_error)"
            },
            "71": {
                "beforePatchRowNumber": 1721,
                "afterPatchRowNumber": 1718,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 1722,
                "afterPatchRowNumber": 1719,
                "PatchRowcode": "     if db_change or not db_valid or not config.db_configured \\"
            },
            "73": {
                "beforePatchRowNumber": 1723,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1720,
                "PatchRowcode": "+      or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:"
            },
            "75": {
                "beforePatchRowNumber": 1724,
                "afterPatchRowNumber": 1721,
                "PatchRowcode": "         if not os.path.exists(metadata_db) or not to_save['config_calibre_dir']:"
            },
            "76": {
                "beforePatchRowNumber": 1725,
                "afterPatchRowNumber": 1722,
                "PatchRowcode": "             return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'), gdrive_error)"
            },
            "77": {
                "beforePatchRowNumber": 1726,
                "afterPatchRowNumber": 1723,
                "PatchRowcode": "         else:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "import json",
            "import operator",
            "import time",
            "import sys",
            "import string",
            "from datetime import datetime, timedelta",
            "from datetime import time as datetime_time",
            "from functools import wraps",
            "from urllib.parse import urlparse",
            "",
            "from flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response",
            "from markupsafe import Markup",
            "from flask_login import login_required, current_user, logout_user",
            "from flask_babel import gettext as _",
            "from flask_babel import get_locale, format_time, format_datetime, format_timedelta",
            "from flask import session as flask_session",
            "from sqlalchemy import and_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
            "from sqlalchemy.sql.expression import func, or_, text",
            "",
            "from . import constants, logger, helper, services, cli_param",
            "from . import db, calibre_db, ub, web_server, config, updater_thread, gdriveutils, \\",
            "    kobo_sync_status, schedule",
            "from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
            "    valid_email, check_username",
            "from .embed_helper import get_calibre_binarypath",
            "from .gdriveutils import is_gdrive_ready, gdrive_support",
            "from .render_template import render_title_template, get_sidebar_config",
            "from .services.worker import WorkerThread",
            "from .babel import get_available_translations, get_available_locale, get_user_locale_language",
            "from . import debug_info",
            "",
            "log = logger.create()",
            "",
            "feature_support = {",
            "    'ldap': bool(services.ldap),",
            "    'goodreads': bool(services.goodreads_support),",
            "    'kobo': bool(services.kobo),",
            "    'updater': constants.UPDATER_AVAILABLE,",
            "    'gmail': bool(services.gmail),",
            "    'scheduler': schedule.use_APScheduler,",
            "    'gdrive': gdrive_support",
            "}",
            "",
            "try:",
            "    import rarfile  # pylint: disable=unused-import",
            "",
            "    feature_support['rar'] = True",
            "except (ImportError, SyntaxError):",
            "    feature_support['rar'] = False",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, oauthblueprints",
            "",
            "    feature_support['oauth'] = True",
            "except ImportError as err:",
            "    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)",
            "    feature_support['oauth'] = False",
            "    oauthblueprints = []",
            "    oauth_check = {}",
            "",
            "admi = Blueprint('admin', __name__)",
            "",
            "",
            "def admin_required(f):",
            "    \"\"\"",
            "    Checks if current_user.role == 1",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "@admi.before_app_request",
            "def before_request():",
            "    try:",
            "        if not ub.check_user_session(current_user.id,",
            "                                     flask_session.get('_id')) and 'opds' not in request.path \\",
            "          and config.config_session == 1:",
            "            logout_user()",
            "    except AttributeError:",
            "        pass    # ? fails on requesting /ajax/emailstat during restart ?",
            "    g.constants = constants",
            "    g.google_site_verification = os.getenv('GOOGLE_SITE_VERIFICATION', '')",
            "    g.allow_registration = config.config_public_reg",
            "    g.allow_anonymous = config.config_anonbrowse",
            "    g.allow_upload = config.config_uploading",
            "    g.current_theme = config.config_theme",
            "    g.config_authors_max = config.config_authors_max",
            "    if '/static/' not in request.path and not config.db_configured and \\",
            "        request.endpoint not in ('admin.ajax_db_config',",
            "                                 'admin.simulatedbchange',",
            "                                 'admin.db_configuration',",
            "                                 'web.login',",
            "                                 'web.login_post',",
            "                                 'web.logout',",
            "                                 'admin.load_dialogtexts',",
            "                                 'admin.ajax_pathchooser'):",
            "        return redirect(url_for('admin.db_configuration'))",
            "",
            "",
            "@admi.route(\"/admin\")",
            "@login_required",
            "def admin_forbidden():",
            "    abort(403)",
            "",
            "",
            "@admi.route(\"/shutdown\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def shutdown():",
            "    task = request.get_json().get('parameter', -1)",
            "    show_text = {}",
            "    if task in (0, 1):  # valid commandos received",
            "        # close all database connections",
            "        calibre_db.dispose()",
            "        ub.dispose()",
            "",
            "        if task == 0:",
            "            show_text['text'] = _('Server restarted, please reload page.')",
            "        else:",
            "            show_text['text'] = _('Performing Server shutdown, please close window.')",
            "        # stop gevent/tornado server",
            "        web_server.stop(task == 0)",
            "        return json.dumps(show_text)",
            "",
            "    if task == 2:",
            "        log.warning(\"reconnecting to calibre database\")",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        show_text['text'] = _('Success! Database Reconnected')",
            "        return json.dumps(show_text)",
            "",
            "    show_text['text'] = _('Unknown command')",
            "    return json.dumps(show_text), 400",
            "",
            "",
            "@admi.route(\"/metadata_backup\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def queue_metadata_backup():",
            "    show_text = {}",
            "    log.warning(\"Queuing all books for metadata backup\")",
            "    helper.set_all_metadata_dirty()",
            "    show_text['text'] = _('Success! Books queued for Metadata Backup, please check Tasks for result')",
            "    return json.dumps(show_text)",
            "",
            "",
            "# method is available without login and not protected by CSRF to make it easy reachable, is per default switched off",
            "# needed for docker applications, as changes on metadata.db from host are not visible to application",
            "@admi.route(\"/reconnect\", methods=['GET'])",
            "def reconnect():",
            "    if cli_param.reconnect_enable:",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        return json.dumps({})",
            "    else:",
            "        log.debug(\"'/reconnect' was accessed but is not enabled\")",
            "        abort(404)",
            "",
            "",
            "@admi.route(\"/ajax/updateThumbnails\", methods=['POST'])",
            "@admin_required",
            "@login_required",
            "def update_thumbnails():",
            "    content = config.get_scheduled_task_settings()",
            "    if content['schedule_generate_book_covers']:",
            "        log.info(\"Update of Cover cache requested\")",
            "        helper.update_thumbnail_cache()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/view\")",
            "@login_required",
            "@admin_required",
            "def admin():",
            "    version = updater_thread.get_current_version_info()",
            "    if version is False:",
            "        commit = _('Unknown')",
            "    else:",
            "        if 'datetime' in version:",
            "            commit = version['datetime']",
            "",
            "            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)",
            "            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")",
            "            if len(commit) > 19:  # check if string has timezone",
            "                if commit[19] == '+':",
            "                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "                elif commit[19] == '-':",
            "                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "            commit = format_datetime(form_date - tz, format='short')",
            "        else:",
            "            commit = version['version'].replace(\"b\", \" Beta\")",
            "",
            "    all_user = ub.session.query(ub.User).all()",
            "    # email_settings = mail_config.get_mail_settings()",
            "    schedule_time = format_time(datetime_time(hour=config.schedule_start_time), format=\"short\")",
            "    t = timedelta(hours=config.schedule_duration // 60, minutes=config.schedule_duration % 60)",
            "    schedule_duration = format_timedelta(t, threshold=.99)",
            "",
            "    return render_title_template(\"admin.html\", allUser=all_user, config=config, commit=commit,",
            "                                 feature_support=feature_support, schedule_time=schedule_time,",
            "                                 schedule_duration=schedule_duration,",
            "                                 title=_(\"Admin page\"), page=\"admin\")",
            "",
            "",
            "@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def db_configuration():",
            "    if request.method == \"POST\":",
            "        return _db_configuration_update_helper()",
            "    return _db_configuration_result()",
            "",
            "",
            "@admi.route(\"/admin/config\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def configuration():",
            "    return render_title_template(\"config_edit.html\",",
            "                                 config=config,",
            "                                 provider=oauthblueprints,",
            "                                 feature_support=feature_support,",
            "                                 title=_(\"Basic Configuration\"), page=\"config\")",
            "",
            "",
            "@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_config():",
            "    return _configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_db_config():",
            "    return _db_configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/alive\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def calibreweb_alive():",
            "    return \"\", 200",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\")",
            "@login_required",
            "@admin_required",
            "def view_configuration():",
            "    read_column = calibre_db.session.query(db.CustomColumns) \\",
            "        .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all()",
            "    restrict_columns = calibre_db.session.query(db.CustomColumns) \\",
            "        .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all()",
            "    languages = calibre_db.speaking_language()",
            "    translations = get_available_locale()",
            "    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
            "                                 restrictColumns=restrict_columns,",
            "                                 languages=languages,",
            "                                 translations=translations,",
            "                                 title=_(\"UI Configuration\"), page=\"uiconfig\")",
            "",
            "",
            "@admi.route(\"/admin/usertable\")",
            "@login_required",
            "@admin_required",
            "def edit_user_table():",
            "    visibility = current_user.view_settings.get('useredit', {})",
            "    languages = calibre_db.speaking_language()",
            "    translations = get_available_locale()",
            "    all_user = ub.session.query(ub.User)",
            "    tags = calibre_db.session.query(db.Tags) \\",
            "        .join(db.books_tags_link) \\",
            "        .join(db.Books) \\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag')) \\",
            "        .order_by(db.Tags.name).all()",
            "    if config.config_restricted_column:",
            "        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()",
            "    else:",
            "        custom_values = []",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"user_table.html\",",
            "                                 users=all_user.all(),",
            "                                 tags=tags,",
            "                                 custom_values=custom_values,",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 visiblility=visibility,",
            "                                 all_roles=constants.ALL_ROLES,",
            "                                 kobo_support=kobo_support,",
            "                                 sidebar_settings=constants.sidebar_settings,",
            "                                 title=_(\"Edit Users\"),",
            "                                 page=\"usertable\")",
            "",
            "",
            "@admi.route(\"/ajax/listusers\")",
            "@login_required",
            "@admin_required",
            "def list_users():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or 10)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    state = None",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "    else:",
            "        if sort not in ub.User.__table__.columns.keys():",
            "            sort = \"id\"",
            "    order = request.args.get(\"order\", \"\").lower()",
            "",
            "    if sort != \"state\" and order:",
            "        order = text(sort + \" \" + order)",
            "    elif not state:",
            "        order = ub.User.id.asc()",
            "",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "",
            "    total_count = filtered_count = all_user.count()",
            "",
            "    if search:",
            "        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),",
            "                                       func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),",
            "                                       func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))",
            "    if state:",
            "        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())",
            "    else:",
            "        users = all_user.order_by(order).offset(off).limit(limit).all()",
            "    if search:",
            "        filtered_count = len(users)",
            "",
            "    for user in users:",
            "        if user.default_language == \"all\":",
            "            user.default = _(\"All\")",
            "        else:",
            "            user.default = get_user_locale_language(user.default_language)",
            "",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/deleteuser\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user():",
            "    user_ids = request.form.to_dict(flat=False)",
            "    users = None",
            "    message = \"\"",
            "    if \"userid[]\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()",
            "    elif \"userid\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()",
            "    count = 0",
            "    errors = list()",
            "    success = list()",
            "    if not users:",
            "        log.error(\"User not found\")",
            "        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')",
            "    for user in users:",
            "        try:",
            "            message = _delete_user(user)",
            "            count += 1",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            errors.append({'type': \"danger\", 'message': str(ex)})",
            "",
            "    if count == 1:",
            "        log.info(\"User {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': message}]",
            "    elif count > 1:",
            "        log.info(\"Users {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]",
            "    success.extend(errors)",
            "    return Response(json.dumps(success), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/ajax/getlocale\")",
            "@login_required",
            "@admin_required",
            "def table_get_locale():",
            "    locale = get_available_locale()",
            "    ret = list()",
            "    current_locale = get_locale()",
            "    for loc in locale:",
            "        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/getdefaultlanguage\")",
            "@login_required",
            "@admin_required",
            "def table_get_default_lang():",
            "    languages = calibre_db.speaking_language()",
            "    ret = list()",
            "    ret.append({'value': 'all', 'text': _('Show All')})",
            "    for lang in languages:",
            "        ret.append({'value': lang.lang_code, 'text': lang.name})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_list_user(param):",
            "    vals = request.form.to_dict(flat=False)",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    # only one user is posted",
            "    if \"pk\" in vals:",
            "        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]",
            "    else:",
            "        if \"pk[]\" in vals:",
            "            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()",
            "        else:",
            "            return _(\"Malformed request\"), 400",
            "    if 'field_index' in vals:",
            "        vals['field_index'] = vals['field_index'][0]",
            "    if 'value' in vals:",
            "        vals['value'] = vals['value'][0]",
            "    elif not ('value[]' in vals):",
            "        return _(\"Malformed request\"), 400",
            "    for user in users:",
            "        try:",
            "            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:",
            "                if 'value[]' in vals:",
            "                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))",
            "                else:",
            "                    setattr(user, param, vals['value'].strip())",
            "            else:",
            "                vals['value'] = vals['value'].strip()",
            "                if param == 'name':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest Name can't be changed\"))",
            "                    user.name = check_username(vals['value'])",
            "                elif param == 'email':",
            "                    user.email = check_email(vals['value'])",
            "                elif param == 'kobo_only_shelves_sync':",
            "                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')",
            "                elif param == 'kindle_mail':",
            "                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"",
            "                elif param.endswith('role'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value in \\",
            "                        [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:",
            "                        raise Exception(_(\"Guest can't have this role\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value - 1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.role |= value",
            "                        elif vals['value'] == 'false':",
            "                            if value == constants.ROLE_ADMIN:",
            "                                if not ub.session.query(ub.User). \\",
            "                                    filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                           ub.User.id != user.id).count():",
            "                                    return Response(",
            "                                        json.dumps([{'type': \"danger\",",
            "                                                     'message': _(\"No admin user remaining, can't remove admin role\",",
            "                                                                  nick=user.name)}]), mimetype='application/json')",
            "                            user.role &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid role\"))",
            "                elif param.startswith('sidebar'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:",
            "                        raise Exception(_(\"Guest can't have this view\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value - 1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.sidebar_view |= value",
            "                        elif vals['value'] == 'false':",
            "                            user.sidebar_view &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid view\"))",
            "                elif param == 'locale':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
            "                    if vals['value'] in get_available_translations():",
            "                        user.locale = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Locale Given\"))",
            "                elif param == 'default_language':",
            "                    languages = calibre_db.session.query(db.Languages) \\",
            "                        .join(db.books_languages_link) \\",
            "                        .join(db.Books) \\",
            "                        .filter(calibre_db.common_filters()) \\",
            "                        .group_by(text('books_languages_link.lang_code')).all()",
            "                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]",
            "                    if vals['value'] in lang_codes:",
            "                        user.default_language = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Book Language Given\"))",
            "                else:",
            "                    return _(\"Parameter not found\"), 400",
            "        except Exception as ex:",
            "            log.error_or_exception(ex)",
            "            return str(ex), 400",
            "    ub.session_commit()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/user_table_settings\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def update_table_settings():",
            "    current_user.view_settings['useredit'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: {}\".format(request))",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_view_configuration():",
            "    to_save = request.form.to_dict()",
            "",
            "    _config_string(to_save, \"config_calibre_web_title\")",
            "    _config_string(to_save, \"config_columns_to_ignore\")",
            "    if _config_string(to_save, \"config_title_regex\"):",
            "        calibre_db.update_title_sort(config)",
            "",
            "    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):",
            "        flash(_(\"Invalid Read Column\"), category=\"error\")",
            "        log.debug(\"Invalid Read column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_read_column\")",
            "",
            "    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):",
            "        flash(_(\"Invalid Restricted Column\"), category=\"error\")",
            "        log.debug(\"Invalid Restricted Column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_restricted_column\")",
            "",
            "    _config_int(to_save, \"config_theme\")",
            "    _config_int(to_save, \"config_random_books\")",
            "    _config_int(to_save, \"config_books_per_page\")",
            "    _config_int(to_save, \"config_authors_max\")",
            "    _config_string(to_save, \"config_default_language\")",
            "    _config_string(to_save, \"config_default_locale\")",
            "",
            "    config.config_default_role = constants.selected_roles(to_save)",
            "    config.config_default_role &= ~constants.ROLE_ANONYMOUS",
            "",
            "    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))",
            "    if \"Show_detail_random\" in to_save:",
            "        config.config_default_show |= constants.DETAIL_RANDOM",
            "",
            "    config.save()",
            "    flash(_(\"Calibre-Web configuration updated\"), category=\"success\")",
            "    log.debug(\"Calibre-Web configuration updated\")",
            "    before_request()",
            "",
            "    return view_configuration()",
            "",
            "",
            "@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])",
            "@login_required",
            "def load_dialogtexts(element_id):",
            "    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}",
            "    if element_id == \"config_delete_kobo_token\":",
            "        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')",
            "    elif element_id == \"btndeletedomain\":",
            "        texts[\"main\"] = _('Do you really want to delete this domain?')",
            "    elif element_id == \"btndeluser\":",
            "        texts[\"main\"] = _('Do you really want to delete this user?')",
            "    elif element_id == \"delete_shelf\":",
            "        texts[\"main\"] = _('Are you sure you want to delete this shelf?')",
            "    elif element_id == \"select_locale\":",
            "        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')",
            "    elif element_id == \"select_default_language\":",
            "        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')",
            "    elif element_id == \"role\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')",
            "    elif element_id == \"restrictions\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')",
            "    elif element_id == \"sidebar_view\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions '",
            "                          'for the selected user(s)?')",
            "    elif element_id == \"kobo_only_shelves_sync\":",
            "        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')",
            "    elif element_id == \"db_submit\":",
            "        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')",
            "    elif element_id == \"admin_refresh_cover_cache\":",
            "        texts[\"main\"] = _('Calibre-Web will search for updated Covers '",
            "                          'and update Cover Thumbnails, this may take a while?')",
            "    elif element_id == \"btnfullsync\":",
            "        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database \"",
            "                          \"to force a full sync with your Kobo Reader?\")",
            "    return json.dumps(texts)",
            "",
            "",
            "@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_domain(allow):",
            "    # POST /post",
            "    # name:  'username',  //name of field (column in db)",
            "    # pk:    1            //primary key (record id)",
            "    # value: 'superuser!' //new value",
            "    vals = request.form.to_dict()",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()",
            "    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()",
            "    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))",
            "",
            "",
            "@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_domain(allow):",
            "    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()",
            "    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name) \\",
            "        .filter(ub.Registration.allow == allow).first()",
            "    if not check:",
            "        new_domain = ub.Registration(domain=domain_name, allow=allow)",
            "        ub.session.add(new_domain)",
            "        ub.session_commit(\"Registering Domains added {}\".format(domain_name))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deletedomain\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_domain():",
            "    try:",
            "        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()",
            "        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()",
            "        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))",
            "        # If last domain was deleted, add all domains by default",
            "        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():",
            "            new_domain = ub.Registration(domain=\"%.%\", allow=1)",
            "            ub.session.add(new_domain)",
            "            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")",
            "    except KeyError:",
            "        pass",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/domainlist/<int:allow>\")",
            "@login_required",
            "@admin_required",
            "def list_domain(allow):",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()",
            "    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])",
            "    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')",
            "    response = make_response(js.replace(\"'\", '\"'))",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if element['id'].startswith('a'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))",
            "    if element['id'].startswith('d'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_user_0_restriction(res_type):",
            "    return add_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)",
            "            config.save()",
            "    if res_type == 1:  # CCustom as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)",
            "            config.save()",
            "    if res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))",
            "    if res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,",
            "                                                                                usr.list_allowed_column_values()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,",
            "                                                                               usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user_0_restriction(res_type):",
            "    return delete_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)",
            "            config.save()",
            "    elif res_type == 1:  # CustomC as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)",
            "            config.save()",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, element['Element']))",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Deleted denied tag of user {}: {}\".format(usr.name, element['Element']))",
            "    elif res_type == 3:  # Columns per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,",
            "                                                                              usr.list_allowed_column_values()))",
            "",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,",
            "                                                                             usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def list_restriction(res_type, user_id):",
            "    if res_type == 0:  # Tags as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(config.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(config.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 1:  # CustomC as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(config.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(usr.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    else:",
            "        json_dumps = \"\"",
            "    js = json.dumps(json_dumps)",
            "    response = make_response(js)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])",
            "@login_required",
            "def ajax_self_fullsync():",
            "    return do_full_kobo_sync(current_user.id)",
            "",
            "",
            "@admi.route(\"/ajax/fullsync/<int:userid>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_fullsync(userid):",
            "    return do_full_kobo_sync(userid)",
            "",
            "",
            "@admi.route(\"/ajax/pathchooser/\")",
            "@login_required",
            "@admin_required",
            "def ajax_pathchooser():",
            "    return pathchooser()",
            "",
            "",
            "def do_full_kobo_sync(userid):",
            "    count = ub.session.query(ub.KoboSyncedBooks).filter(userid == ub.KoboSyncedBooks.user_id).delete()",
            "    message = _(\"{} sync entries deleted\").format(count)",
            "    ub.session_commit(message)",
            "    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')",
            "",
            "",
            "def check_valid_read_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
            "            .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "def check_valid_restricted_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
            "            .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "def restriction_addition(element, list_func):",
            "    elementlist = list_func()",
            "    if elementlist == ['']:",
            "        elementlist = []",
            "    if not element['add_element'] in elementlist:",
            "        elementlist += [element['add_element']]",
            "    return ','.join(elementlist)",
            "",
            "",
            "def restriction_deletion(element, list_func):",
            "    elementlist = list_func()",
            "    if element['Element'] in elementlist:",
            "        elementlist.remove(element['Element'])",
            "    return ','.join(elementlist)",
            "",
            "",
            "def prepare_tags(user, action, tags_name, id_list):",
            "    if \"tags\" in tags_name:",
            "        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
            "        if not tags:",
            "            raise Exception(_(\"Tag not found\"))",
            "        new_tags_list = [x.name for x in tags]",
            "    else:",
            "        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column]) \\",
            "            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
            "        new_tags_list = [x.value for x in tags]",
            "    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
            "    if action == \"remove\":",
            "        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
            "    elif action == \"add\":",
            "        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
            "    else:",
            "        raise Exception(_(\"Invalid Action\"))",
            "    return \",\".join(saved_tags_list)",
            "",
            "",
            "def get_drives(current):",
            "    drive_letters = []",
            "    for d in string.ascii_uppercase:",
            "        if os.path.exists('{}:'.format(d)) and current[0].lower() != d.lower():",
            "            drive = \"{}:\\\\\".format(d)",
            "            data = {\"name\": drive, \"fullpath\": drive}",
            "            data[\"sort\"] = \"_\" + data[\"fullpath\"].lower()",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "            drive_letters.append(data)",
            "    return drive_letters",
            "",
            "",
            "def pathchooser():",
            "    browse_for = \"folder\"",
            "    folder_only = request.args.get('folder', False) == \"true\"",
            "    file_filter = request.args.get('filter', \"\")",
            "    path = os.path.normpath(request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        old_file = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        old_file = \"\"",
            "",
            "    absolute = False",
            "",
            "    if os.path.isdir(path):",
            "        cwd = os.path.realpath(path)",
            "        absolute = True",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parent_dir = os.path.dirname(cwd)",
            "    if not absolute:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parent_dir = os.path.relpath(parent_dir) + os.path.sep",
            "",
            "    files = []",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\") \\",
            "            or (sys.platform == \"win32\" and os.path.realpath(cwd)[1:] == os.path.realpath(\"/\")[1:]):",
            "        # we are in root",
            "        parent_dir = \"\"",
            "        if sys.platform == \"win32\":",
            "            files = get_drives(cwd)",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    for f in folders:",
            "        try:",
            "            sanitized_f = str(Markup.escape(f))",
            "            data = {\"name\": sanitized_f, \"fullpath\": os.path.join(cwd, sanitized_f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            if folder_only:",
            "                continue",
            "            if file_filter != \"\" and file_filter != f:",
            "                continue",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parent_dir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": old_file,",
            "        \"absolute\": absolute,",
            "    }",
            "    return json.dumps(context)",
            "",
            "",
            "def _config_int(to_save, x, func=int):",
            "    return config.set_from_dictionary(to_save, x, func)",
            "",
            "",
            "def _config_checkbox(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)",
            "",
            "",
            "def _config_checkbox_int(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)",
            "",
            "",
            "def _config_string(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y.strip().strip(u'\\u200B\\u200C\\u200D\\ufeff') if y else y)",
            "",
            "",
            "def _configuration_gdrive_helper(to_save):",
            "    gdrive_error = None",
            "    if to_save.get(\"config_use_google_drive\"):",
            "        gdrive_secrets = {}",
            "",
            "        if not os.path.isfile(gdriveutils.SETTINGS_YAML):",
            "            config.config_use_google_drive = False",
            "",
            "        if gdrive_support:",
            "            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)",
            "        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:",
            "            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:",
            "                gdrive_secrets = json.load(settings)['web']",
            "            if not gdrive_secrets:",
            "                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))",
            "            gdriveutils.update_settings(",
            "                gdrive_secrets['client_id'],",
            "                gdrive_secrets['client_secret'],",
            "                gdrive_secrets['redirect_uris'][0]",
            "            )",
            "",
            "    # always show Google Drive settings, but in case of error deny support",
            "    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)",
            "    if config.config_use_google_drive and not new_gdrive_value:",
            "        config.config_google_drive_watch_changes_response = {}",
            "    config.config_use_google_drive = new_gdrive_value",
            "    if _config_string(to_save, \"config_google_drive_folder\"):",
            "        gdriveutils.deleteDatabaseOnChange()",
            "    return gdrive_error",
            "",
            "",
            "def _configuration_oauth_helper(to_save):",
            "    active_oauths = 0",
            "    reboot_required = False",
            "    for element in oauthblueprints:",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\",
            "            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:",
            "            reboot_required = True",
            "            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]",
            "            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\",
            "            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:",
            "            active_oauths += 1",
            "            element[\"active\"] = 1",
            "        else:",
            "            element[\"active\"] = 0",
            "        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(",
            "            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],",
            "             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],",
            "             \"active\": element[\"active\"]})",
            "    return reboot_required",
            "",
            "",
            "def _configuration_logfile_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_log_level\")",
            "    reboot_required |= _config_string(to_save, \"config_logfile\")",
            "    if not logger.is_valid_logfile(config.config_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")",
            "    reboot_required |= _config_string(to_save, \"config_access_logfile\")",
            "    if not logger.is_valid_logfile(config.config_access_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "def _configuration_ldap_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_ldap_port\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_dn\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")",
            "    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")",
            "    _config_string(to_save, \"config_ldap_group_name\")",
            "",
            "    address = urlparse(to_save.get(\"config_ldap_provider_url\", \"\"))",
            "    to_save[\"config_ldap_provider_url\"] = (address.hostname or address.path).strip(\"/\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")",
            "",
            "    if to_save.get(\"config_ldap_serv_password_e\", \"\") != \"\":",
            "        reboot_required |= 1",
            "        config.set_from_dictionary(to_save, \"config_ldap_serv_password_e\")",
            "    config.save()",
            "",
            "    if not config.config_ldap_provider_url \\",
            "        or not config.config_ldap_port \\",
            "        or not config.config_ldap_dn \\",
            "        or not config.config_ldap_user_object:",
            "        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '",
            "                                                        'Port, DN and User Object Identifier'))",
            "",
            "    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:",
            "        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:",
            "            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password_e):",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))",
            "        else:",
            "            if not config.config_ldap_serv_username:",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))",
            "",
            "    if config.config_ldap_group_object_filter:",
            "        if config.config_ldap_group_object_filter.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_user_object.count(\"%s\") != 1:",
            "        return reboot_required, \\",
            "               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))",
            "    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):",
            "        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if to_save.get(\"ldap_import_user_filter\") == '0':",
            "        config.config_ldap_member_user_object = \"\"",
            "    else:",
            "        if config.config_ldap_member_user_object.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:",
            "        if not (os.path.isfile(config.config_ldap_cacert_path) and",
            "                os.path.isfile(config.config_ldap_cert_path) and",
            "                os.path.isfile(config.config_ldap_key_path)):",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '",
            "                                           'Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def simulatedbchange():",
            "    db_change, db_valid = _db_simulate_change()",
            "    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def new_user():",
            "    content = ub.User()",
            "    languages = calibre_db.speaking_language()",
            "    translations = get_available_locale()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        _handle_new_user(to_save, content, languages, translations, kobo_support)",
            "    else:",
            "        content.role = config.config_default_role",
            "        content.sidebar_view = config.config_default_show",
            "        content.locale = config.config_default_locale",
            "        content.default_language = config.config_default_language",
            "    return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                 config=config, translations=translations,",
            "                                 languages=languages, title=_(\"Add New User\"), page=\"newuser\",",
            "                                 kobo_support=kobo_support, registered_oauth=oauth_check)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def edit_mailsettings():",
            "    content = config.get_mail_settings()",
            "    return render_title_template(\"email_edit.html\", content=content, title=_(\"Edit Email Server Settings\"),",
            "                                 page=\"mailset\", feature_support=feature_support)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_mailsettings():",
            "    to_save = request.form.to_dict()",
            "    _config_int(to_save, \"mail_server_type\")",
            "    if to_save.get(\"invalidate\"):",
            "        config.mail_gmail_token = {}",
            "        try:",
            "            flag_modified(config, \"mail_gmail_token\")",
            "        except AttributeError:",
            "            pass",
            "    elif to_save.get(\"gmail\"):",
            "        try:",
            "            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
            "            flash(_(\"Success! Gmail Account Verified.\"), category=\"success\")",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            log.error(ex)",
            "            return edit_mailsettings()",
            "",
            "    else:",
            "        _config_int(to_save, \"mail_port\")",
            "        _config_int(to_save, \"mail_use_ssl\")",
            "        if to_save.get(\"mail_password_e\", \"\"):",
            "            _config_string(to_save, \"mail_password_e\")",
            "        _config_int(to_save, \"mail_size\", lambda y: int(y) * 1024 * 1024)",
            "        config.mail_server = to_save.get('mail_server', \"\").strip()",
            "        config.mail_from = to_save.get('mail_from', \"\").strip()",
            "        config.mail_login = to_save.get('mail_login', \"\").strip()",
            "    try:",
            "        config.save()",
            "    except (OperationalError, InvalidRequestError) as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "        return edit_mailsettings()",
            "    except Exception as e:",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "        return edit_mailsettings()",
            "",
            "    if to_save.get(\"test\"):",
            "        if current_user.email:",
            "            result = send_test_mail(current_user.email, current_user.name)",
            "            if result is None:",
            "                flash(_(\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
            "                        email=current_user.email), category=\"info\")",
            "            else:",
            "                flash(_(\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
            "        else:",
            "            flash(_(\"Please configure your e-mail address first...\"), category=\"error\")",
            "    else:",
            "        flash(_(\"Email Server Settings updated\"), category=\"success\")",
            "",
            "    return edit_mailsettings()",
            "",
            "",
            "@admi.route(\"/admin/scheduledtasks\")",
            "@login_required",
            "@admin_required",
            "def edit_scheduledtasks():",
            "    content = config.get_scheduled_task_settings()",
            "    time_field = list()",
            "    duration_field = list()",
            "",
            "    for n in range(24):",
            "        time_field.append((n, format_time(datetime_time(hour=n), format=\"short\", )))",
            "    for n in range(5, 65, 5):",
            "        t = timedelta(hours=n // 60, minutes=n % 60)",
            "        duration_field.append((n, format_timedelta(t, threshold=.97)))",
            "",
            "    return render_title_template(\"schedule_edit.html\",",
            "                                 config=content,",
            "                                 starttime=time_field,",
            "                                 duration=duration_field,",
            "                                 title=_(\"Edit Scheduled Tasks Settings\"))",
            "",
            "",
            "@admi.route(\"/admin/scheduledtasks\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_scheduledtasks():",
            "    error = False",
            "    to_save = request.form.to_dict()",
            "    if 0 <= int(to_save.get(\"schedule_start_time\")) <= 23:",
            "        _config_int( to_save, \"schedule_start_time\")",
            "    else:",
            "        flash(_(\"Invalid start time for task specified\"), category=\"error\")",
            "        error = True",
            "    if 0 < int(to_save.get(\"schedule_duration\")) <= 60:",
            "        _config_int(to_save, \"schedule_duration\")",
            "    else:",
            "        flash(_(\"Invalid duration for task specified\"), category=\"error\")",
            "        error = True",
            "    _config_checkbox(to_save, \"schedule_generate_book_covers\")",
            "    _config_checkbox(to_save, \"schedule_generate_series_covers\")",
            "    _config_checkbox(to_save, \"schedule_metadata_backup\")",
            "    _config_checkbox(to_save, \"schedule_reconnect\")",
            "",
            "    if not error:",
            "        try:",
            "            config.save()",
            "            flash(_(\"Scheduled tasks settings updated\"), category=\"success\")",
            "",
            "            # Cancel any running tasks",
            "            schedule.end_scheduled_tasks()",
            "",
            "            # Re-register tasks with new settings",
            "            schedule.register_scheduled_tasks(config.schedule_reconnect)",
            "        except IntegrityError:",
            "            ub.session.rollback()",
            "            log.error(\"An unknown error occurred while saving scheduled tasks settings\")",
            "            flash(_(\"Oops! An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        except OperationalError:",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "    return edit_scheduledtasks()",
            "",
            "",
            "@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def edit_user(user_id):",
            "    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
            "    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
            "        flash(_(\"User not found\"), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    languages = calibre_db.speaking_language(return_all_languages=True)",
            "    translations = get_available_locale()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
            "        if resp:",
            "            return resp",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 new_user=0,",
            "                                 content=content,",
            "                                 config=config,",
            "                                 registered_oauth=oauth_check,",
            "                                 mail_configured=config.get_mail_server_configured(),",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(\"Edit User %(nick)s\", nick=content.name),",
            "                                 page=\"edituser\")",
            "",
            "",
            "@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def reset_user_password(user_id):",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ret, message = reset_password(user_id)",
            "        if ret == 1:",
            "            log.debug(\"Password for user %s reset\", message)",
            "            flash(_(\"Success! Password for user %(user)s reset\", user=message), category=\"success\")",
            "        elif ret == 0:",
            "            log.error(\"An unknown error occurred. Please try again later.\")",
            "            flash(_(\"Oops! An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        else:",
            "            log.error(\"Please configure the SMTP mail settings.\")",
            "            flash(_(\"Oops! Please configure the SMTP mail settings.\"), category=\"error\")",
            "    return redirect(url_for('admin.admin'))",
            "",
            "",
            "@admi.route(\"/admin/logfile\")",
            "@login_required",
            "@admin_required",
            "def view_logfile():",
            "    logfiles = {0: logger.get_logfile(config.config_logfile),",
            "                1: logger.get_accesslogfile(config.config_access_logfile)}",
            "    return render_title_template(\"logviewer.html\",",
            "                                 title=_(\"Logfile viewer\"),",
            "                                 accesslog_enable=config.config_access_log,",
            "                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
            "                                 logfiles=logfiles,",
            "                                 page=\"logfile\")",
            "",
            "",
            "@admi.route(\"/ajax/log/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def send_logfile(logtype):",
            "    if logtype == 1:",
            "        logfile = logger.get_accesslogfile(config.config_access_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    if logtype == 0:",
            "        logfile = logger.get_logfile(config.config_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@admi.route(\"/admin/logdownload/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def download_log(logtype):",
            "    if logtype == 0:",
            "        file_name = logger.get_logfile(config.config_logfile)",
            "    elif logtype == 1:",
            "        file_name = logger.get_accesslogfile(config.config_access_logfile)",
            "    else:",
            "        abort(404)",
            "    if logger.is_valid_logfile(file_name):",
            "        return debug_info.assemble_logfiles(file_name)",
            "    abort(404)",
            "",
            "",
            "@admi.route(\"/admin/debug\")",
            "@login_required",
            "@admin_required",
            "def download_debug():",
            "    return debug_info.send_debug()",
            "",
            "",
            "@admi.route(\"/get_update_status\", methods=['GET'])",
            "@login_required",
            "@admin_required",
            "def get_update_status():",
            "    if feature_support['updater']:",
            "        log.info(\"Update status requested\")",
            "        return updater_thread.get_available_updates(request.method)",
            "    else:",
            "        return ''",
            "",
            "",
            "@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
            "@login_required",
            "@admin_required",
            "def get_updater_status():",
            "    status = {}",
            "    if feature_support['updater']:",
            "        if request.method == \"POST\":",
            "            commit = request.form.to_dict()",
            "            if \"start\" in commit and commit['start'] == 'True':",
            "                txt = {",
            "                    \"1\": _(u'Requesting update package'),",
            "                    \"2\": _(u'Downloading update package'),",
            "                    \"3\": _(u'Unzipping update package'),",
            "                    \"4\": _(u'Replacing files'),",
            "                    \"5\": _(u'Database connections are closed'),",
            "                    \"6\": _(u'Stopping server'),",
            "                    \"7\": _(u'Update finished, please press okay and reload page'),",
            "                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
            "                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
            "                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
            "                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
            "                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
            "                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
            "                }",
            "                status['text'] = txt",
            "                updater_thread.status = 0",
            "                updater_thread.resume()",
            "                status['status'] = updater_thread.get_update_status()",
            "        elif request.method == \"GET\":",
            "            try:",
            "                status['status'] = updater_thread.get_update_status()",
            "                if status['status'] == -1:",
            "                    status['status'] = 7",
            "            except Exception:",
            "                status['status'] = 11",
            "        return json.dumps(status)",
            "    return ''",
            "",
            "",
            "def ldap_import_create_user(user, user_data):",
            "    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
            "",
            "    try:",
            "        username = user_data[user_login_field][0].decode('utf-8')",
            "    except KeyError as ex:",
            "        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
            "        message = _(u'Failed to extract at least One LDAP User')",
            "        return 0, message",
            "",
            "    # check for duplicate username",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
            "        # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
            "        log.warning(\"LDAP User  %s Already in Database\", user_data)",
            "        return 0, None",
            "",
            "    ereader_mail = ''",
            "    if 'mail' in user_data:",
            "        useremail = user_data['mail'][0].decode('utf-8')",
            "        if len(user_data['mail']) > 1:",
            "            ereader_mail = user_data['mail'][1].decode('utf-8')",
            "",
            "    else:",
            "        log.debug('No Mail Field Found in LDAP Response')",
            "        useremail = username + '@email.com'",
            "",
            "    try:",
            "        # check for duplicate email",
            "        useremail = check_email(useremail)",
            "    except Exception as ex:",
            "        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
            "        return 0, None",
            "    content = ub.User()",
            "    content.name = username",
            "    content.password = ''  # dummy password which will be replaced by ldap one",
            "    content.email = useremail",
            "    content.kindle_mail = ereader_mail",
            "    content.default_language = config.config_default_language",
            "    content.locale = config.config_default_locale",
            "    content.role = config.config_default_role",
            "    content.sidebar_view = config.config_default_show",
            "    content.allowed_tags = config.config_allowed_tags",
            "    content.denied_tags = config.config_denied_tags",
            "    content.allowed_column_value = config.config_allowed_column_value",
            "    content.denied_column_value = config.config_denied_column_value",
            "    ub.session.add(content)",
            "    try:",
            "        ub.session.commit()",
            "        return 1, None  # increase no of users",
            "    except Exception as ex:",
            "        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
            "        ub.session.rollback()",
            "        message = _(u'Failed to Create at Least One LDAP User')",
            "        return 0, message",
            "",
            "",
            "@admi.route('/import_ldap_users', methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def import_ldap_users():",
            "    showtext = {}",
            "    try:",
            "        new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
            "    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
            "        log.error_or_exception(e)",
            "        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
            "        return json.dumps(showtext)",
            "    if not new_users:",
            "        log.debug('LDAP empty response')",
            "        showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
            "        return json.dumps(showtext)",
            "",
            "    imported = 0",
            "    for username in new_users:",
            "        if isinstance(username, bytes):",
            "            user = username.decode('utf-8')",
            "        else:",
            "            user = username",
            "        if '=' in user:",
            "            # if member object field is empty take user object as filter",
            "            if config.config_ldap_member_user_object:",
            "                query_filter = config.config_ldap_member_user_object",
            "            else:",
            "                query_filter = config.config_ldap_user_object",
            "            try:",
            "                user_identifier = extract_user_identifier(user, query_filter)",
            "            except Exception as ex:",
            "                log.warning(ex)",
            "                continue",
            "        else:",
            "            user_identifier = user",
            "            query_filter = None",
            "        try:",
            "            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
            "        except AttributeError as ex:",
            "            log.error_or_exception(ex)",
            "            continue",
            "        if user_data:",
            "            user_count, message = ldap_import_create_user(user, user_data)",
            "            if message:",
            "                showtext['text'] = message",
            "            else:",
            "                imported += user_count",
            "        else:",
            "            log.warning(\"LDAP User: %s Not Found\", user)",
            "            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
            "    if not showtext:",
            "        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
            "    return json.dumps(showtext)",
            "",
            "",
            "@admi.route(\"/ajax/canceltask\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def cancel_task():",
            "    task_id = request.get_json().get('task_id', None)",
            "    worker = WorkerThread.get_instance()",
            "    worker.end_task(task_id)",
            "    return \"\"",
            "",
            "",
            "def _db_simulate_change():",
            "    param = request.form.to_dict()",
            "    to_save = dict()",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           param['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE).strip()",
            "    db_valid, db_change = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"],",
            "                                                    ub.app_DB_path,",
            "                                                    config.config_calibre_uuid)",
            "    db_change = bool(db_change and config.config_calibre_dir)",
            "    return db_change, db_valid",
            "",
            "",
            "def _db_configuration_update_helper():",
            "    db_change = False",
            "    to_save = request.form.to_dict()",
            "    gdrive_error = None",
            "",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           to_save['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE)",
            "    db_valid = False",
            "    try:",
            "        db_change, db_valid = _db_simulate_change()",
            "",
            "        # gdrive_error drive setup",
            "        gdrive_error = _configuration_gdrive_helper(to_save)",
            "    except (OperationalError, InvalidRequestError) as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        _db_configuration_result(_(\"Oops! Database Error: %(error)s.\", error=e.orig), gdrive_error)",
            "    try:",
            "        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
            "        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
            "            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
            "            db_change = True",
            "    except Exception as ex:",
            "        return _db_configuration_result('{}'.format(ex), gdrive_error)",
            "",
            "    if db_change or not db_valid or not config.db_configured \\",
            "        or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:",
            "        if not os.path.exists(metadata_db) or not to_save['config_calibre_dir']:",
            "            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'), gdrive_error)",
            "        else:",
            "            calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path)",
            "        config.store_calibre_uuid(calibre_db, db.Library_Id)",
            "        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
            "        if db_change:",
            "            log.info(\"Calibre Database changed, all Calibre-Web info related to old Database gets deleted\")",
            "            ub.session.query(ub.Downloads).delete()",
            "            ub.session.query(ub.ArchivedBook).delete()",
            "            ub.session.query(ub.ReadBook).delete()",
            "            ub.session.query(ub.BookShelf).delete()",
            "            ub.session.query(ub.Bookmark).delete()",
            "            ub.session.query(ub.KoboReadingState).delete()",
            "            ub.session.query(ub.KoboStatistics).delete()",
            "            ub.session.query(ub.KoboSyncedBooks).delete()",
            "            helper.delete_thumbnail_cache()",
            "            ub.session_commit()",
            "        _config_string(to_save, \"config_calibre_dir\")",
            "        calibre_db.update_config(config)",
            "        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
            "            flash(_(\"DB is not Writeable\"), category=\"warning\")",
            "    _config_string(to_save, \"config_calibre_split_dir\")",
            "    config.config_calibre_split = to_save.get('config_calibre_split', 0) == \"on\"",
            "    calibre_db.update_config(config)",
            "    config.save()",
            "    return _db_configuration_result(None, gdrive_error)",
            "",
            "",
            "def _configuration_update_helper():",
            "    reboot_required = False",
            "    to_save = request.form.to_dict()",
            "    try:",
            "        reboot_required |= _config_int(to_save, \"config_port\")",
            "        reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
            "        reboot_required |= _config_string(to_save, \"config_keyfile\")",
            "        if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
            "            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        reboot_required |= _config_string(to_save, \"config_certfile\")",
            "        if config.config_certfile and not os.path.isfile(config.config_certfile):",
            "            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        _config_checkbox_int(to_save, \"config_uploading\")",
            "        _config_checkbox_int(to_save, \"config_unicode_filename\")",
            "        _config_checkbox_int(to_save, \"config_embed_metadata\")",
            "        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
            "        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
            "                            and config.config_login_type == constants.LOGIN_LDAP)",
            "        _config_checkbox_int(to_save, \"config_public_reg\")",
            "        _config_checkbox_int(to_save, \"config_register_email\")",
            "        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
            "        _config_int(to_save, \"config_external_port\")",
            "        _config_checkbox_int(to_save, \"config_kobo_proxy\")",
            "",
            "        if \"config_upload_formats\" in to_save:",
            "            to_save[\"config_upload_formats\"] = ','.join(",
            "                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
            "            _config_string(to_save, \"config_upload_formats\")",
            "            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
            "",
            "        _config_string(to_save, \"config_calibre\")",
            "        _config_string(to_save, \"config_binariesdir\")",
            "        _config_string(to_save, \"config_kepubifypath\")",
            "        if \"config_binariesdir\" in to_save:",
            "            calibre_status = helper.check_calibre(config.config_binariesdir)",
            "            if calibre_status:",
            "                return _configuration_result(calibre_status)",
            "            to_save[\"config_converterpath\"] = get_calibre_binarypath(\"ebook-convert\")",
            "            _config_string(to_save, \"config_converterpath\")",
            "",
            "        reboot_required |= _config_int(to_save, \"config_login_type\")",
            "",
            "        # LDAP configurator",
            "        if config.config_login_type == constants.LOGIN_LDAP:",
            "            reboot, message = _configuration_ldap_helper(to_save)",
            "            if message:",
            "                return message",
            "            reboot_required |= reboot",
            "",
            "        # Remote login configuration",
            "        _config_checkbox(to_save, \"config_remote_login\")",
            "        if not config.config_remote_login:",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
            "",
            "        # Goodreads configuration",
            "        _config_checkbox(to_save, \"config_use_goodreads\")",
            "        _config_string(to_save, \"config_goodreads_api_key\")",
            "        if services.goodreads_support:",
            "            services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                               config.config_use_goodreads)",
            "",
            "        _config_int(to_save, \"config_updatechannel\")",
            "",
            "        # Reverse proxy login configuration",
            "        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
            "        _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
            "",
            "        # OAuth configuration",
            "        if config.config_login_type == constants.LOGIN_OAUTH:",
            "            reboot_required |= _configuration_oauth_helper(to_save)",
            "",
            "        # logfile configuration",
            "        reboot, message = _configuration_logfile_helper(to_save)",
            "        if message:",
            "            return message",
            "        reboot_required |= reboot",
            "",
            "        # security configuration",
            "        _config_checkbox(to_save, \"config_password_policy\")",
            "        _config_checkbox(to_save, \"config_password_number\")",
            "        _config_checkbox(to_save, \"config_password_lower\")",
            "        _config_checkbox(to_save, \"config_password_upper\")",
            "        _config_checkbox(to_save, \"config_password_character\")",
            "        _config_checkbox(to_save, \"config_password_special\")",
            "        if 0 < int(to_save.get(\"config_password_min_length\", \"0\")) < 41:",
            "            _config_int(to_save, \"config_password_min_length\")",
            "        else:",
            "            return _configuration_result(_('Password length has to be between 1 and 40'))",
            "        reboot_required |= _config_int(to_save, \"config_session\")",
            "        reboot_required |= _config_checkbox(to_save, \"config_ratelimiter\")",
            "        reboot_required |= _config_string(to_save, \"config_limiter_uri\")",
            "        reboot_required |= _config_string(to_save, \"config_limiter_options\")",
            "",
            "        # Rarfile Content configuration",
            "        _config_string(to_save, \"config_rarfile_location\")",
            "        if \"config_rarfile_location\" in to_save:",
            "            unrar_status = helper.check_unrar(config.config_rarfile_location)",
            "            if unrar_status:",
            "                return _configuration_result(unrar_status)",
            "    except (OperationalError, InvalidRequestError) as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        _configuration_result(_(\"Oops! Database Error: %(error)s.\", error=e.orig))",
            "",
            "    config.save()",
            "    if reboot_required:",
            "        web_server.stop(True)",
            "",
            "    return _configuration_result(None, reboot_required)",
            "",
            "",
            "def _configuration_result(error_flash=None, reboot=False):",
            "    resp = {}",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
            "    else:",
            "        resp['result'] = [{'type': \"success\", 'message': _(\"Calibre-Web configuration updated\")}]",
            "    resp['reboot'] = reboot",
            "    resp['config_upload'] = config.config_upload_formats",
            "    return Response(json.dumps(resp), mimetype='application/json')",
            "",
            "",
            "def _db_configuration_result(error_flash=None, gdrive_error=None):",
            "    gdrive_authenticate = not is_gdrive_ready()",
            "    gdrivefolders = []",
            "    if not gdrive_error and config.config_use_google_drive:",
            "        gdrive_error = gdriveutils.get_error_text()",
            "    if gdrive_error and gdrive_support:",
            "        log.error(gdrive_error)",
            "        gdrive_error = _(gdrive_error)",
            "        flash(gdrive_error, category=\"error\")",
            "    else:",
            "        if not gdrive_authenticate and gdrive_support:",
            "            gdrivefolders = gdriveutils.listRootFolders()",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        flash(error_flash, category=\"error\")",
            "    elif request.method == \"POST\" and not gdrive_error:",
            "        flash(_(\"Database Settings updated\"), category=\"success\")",
            "",
            "    return render_title_template(\"config_db.html\",",
            "                                 config=config,",
            "                                 show_authenticate_google_drive=gdrive_authenticate,",
            "                                 gdriveError=gdrive_error,",
            "                                 gdrivefolders=gdrivefolders,",
            "                                 feature_support=feature_support,",
            "                                 title=_(\"Database Configuration\"), page=\"dbconfig\")",
            "",
            "",
            "def _handle_new_user(to_save, content, languages, translations, kobo_support):",
            "    content.default_language = to_save[\"default_language\"]",
            "    content.locale = to_save.get(\"locale\", content.locale)",
            "",
            "    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
            "    if \"show_detail_random\" in to_save:",
            "        content.sidebar_view |= constants.DETAIL_RANDOM",
            "",
            "    content.role = constants.selected_roles(to_save)",
            "    try:",
            "        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
            "            log.info(\"Missing entries on new user\")",
            "            raise Exception(_(\"Oops! Please complete all fields.\"))",
            "        content.password = generate_password_hash(helper.valid_password(to_save.get(\"password\", \"\")))",
            "        content.email = check_email(to_save[\"email\"])",
            "        # Query username, if not existing, change",
            "        content.name = check_username(to_save[\"name\"])",
            "        if to_save.get(\"kindle_mail\"):",
            "            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if config.config_public_reg and not check_valid_domain(content.email):",
            "            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
            "            raise Exception(_(\"E-mail is not from valid domain\"))",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                     config=config,",
            "                                     translations=translations,",
            "                                     languages=languages, title=_(\"Add new user\"), page=\"newuser\",",
            "                                     kobo_support=kobo_support, registered_oauth=oauth_check)",
            "    try:",
            "        content.allowed_tags = config.config_allowed_tags",
            "        content.denied_tags = config.config_denied_tags",
            "        content.allowed_column_value = config.config_allowed_column_value",
            "        content.denied_column_value = config.config_denied_column_value",
            "        # No default value for kobo sync shelf setting",
            "        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
            "        ub.session.add(content)",
            "        ub.session.commit()",
            "        flash(_(\"User '%(user)s' created\", user=content.name), category=\"success\")",
            "        log.debug(\"User {} created\".format(content.name))",
            "        return redirect(url_for('admin.admin'))",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
            "        flash(_(\"Oops! An account already exists for this Email. or name.\"), category=\"error\")",
            "    except OperationalError as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "",
            "",
            "def _delete_user(content):",
            "    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                        ub.User.id != content.id).count():",
            "        if content.name != \"Guest\":",
            "            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
            "            # and user itself",
            "            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
            "            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
            "            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
            "                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
            "            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
            "            ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()",
            "            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
            "            ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()",
            "            ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()",
            "            ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()",
            "            # delete KoboReadingState and all it's children",
            "            kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()",
            "            for kobo_entry in kobo_entries:",
            "                ub.session.delete(kobo_entry)",
            "            ub.session_commit()",
            "            log.info(\"User {} deleted\".format(content.name))",
            "            return _(\"User '%(nick)s' deleted\", nick=content.name)",
            "        else:",
            "            # log.warning(_(\"Can't delete Guest User\"))",
            "            raise Exception(_(\"Can't delete Guest User\"))",
            "    else:",
            "        # log.warning(\"No admin user remaining, can't delete user\")",
            "        raise Exception(_(\"No admin user remaining, can't delete user\"))",
            "",
            "",
            "def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
            "    if to_save.get(\"delete\"):",
            "        try:",
            "            flash(_delete_user(content), category=\"success\")",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    else:",
            "        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:",
            "            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
            "            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
            "            return redirect(url_for('admin.admin'))",
            "",
            "        val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
            "        sidebar, __ = get_sidebar_config()",
            "        for element in sidebar:",
            "            value = element['visibility']",
            "            if value in val and not content.check_visibility(value):",
            "                content.sidebar_view |= value",
            "            elif value not in val and content.check_visibility(value):",
            "                content.sidebar_view &= ~value",
            "",
            "        if to_save.get(\"Show_detail_random\"):",
            "            content.sidebar_view |= constants.DETAIL_RANDOM",
            "        else:",
            "            content.sidebar_view &= ~constants.DETAIL_RANDOM",
            "",
            "        old_state = content.kobo_only_shelves_sync",
            "        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
            "        # which don't have to be synced have to be removed (added to Shelf archive)",
            "        if old_state == 0 and content.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(content.id)",
            "        if to_save.get(\"default_language\"):",
            "            content.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            content.locale = to_save[\"locale\"]",
            "        try:",
            "            anonymous = content.is_anonymous",
            "            content.role = constants.selected_roles(to_save)",
            "            if anonymous:",
            "                content.role |= constants.ROLE_ANONYMOUS",
            "            else:",
            "                content.role &= ~constants.ROLE_ANONYMOUS",
            "                if to_save.get(\"password\", \"\"):",
            "                    content.password = generate_password_hash(helper.valid_password(to_save.get(\"password\", \"\")))",
            "",
            "            new_email = valid_email(to_save.get(\"email\", content.email))",
            "            if not new_email:",
            "                raise Exception(_(\"Email can't be empty and has to be a valid Email\"))",
            "            if new_email != content.email:",
            "                content.email = check_email(new_email)",
            "            # Query username, if not existing, change",
            "            if to_save.get(\"name\", content.name) != content.name:",
            "                if to_save.get(\"name\") == \"Guest\":",
            "                    raise Exception(_(\"Guest Name can't be changed\"))",
            "                content.name = check_username(to_save[\"name\"])",
            "            if to_save.get(\"kindle_mail\") != content.kindle_mail:",
            "                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template(\"user_edit.html\",",
            "                                         translations=translations,",
            "                                         languages=languages,",
            "                                         mail_configured=config.get_mail_server_configured(),",
            "                                         kobo_support=kobo_support,",
            "                                         new_user=0,",
            "                                         content=content,",
            "                                         config=config,",
            "                                         registered_oauth=oauth_check,",
            "                                         title=_(\"Edit User %(nick)s\", nick=content.name),",
            "                                         page=\"edituser\")",
            "    try:",
            "        ub.session_commit()",
            "        flash(_(\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
            "    except IntegrityError as ex:",
            "        ub.session.rollback()",
            "        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
            "        flash(_(\"Oops! An unknown error occurred. Please try again later.\"), category=\"error\")",
            "    except OperationalError as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "    return \"\"",
            "",
            "",
            "def extract_user_data_from_field(user, field):",
            "    match = re.search(field + r\"=([@\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))",
            "",
            "",
            "def extract_dynamic_field_from_filter(user, filtr):",
            "    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)",
            "",
            "",
            "def extract_user_identifier(user, filtr):",
            "    dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
            "    return extract_user_data_from_field(user, dynamic_field)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,",
            "#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,",
            "#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,",
            "#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,",
            "#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import re",
            "import json",
            "import operator",
            "import time",
            "import sys",
            "import string",
            "from datetime import datetime, timedelta",
            "from datetime import time as datetime_time",
            "from functools import wraps",
            "from urllib.parse import urlparse",
            "",
            "from flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response",
            "from markupsafe import Markup",
            "from flask_login import login_required, current_user, logout_user",
            "from flask_babel import gettext as _",
            "from flask_babel import get_locale, format_time, format_datetime, format_timedelta",
            "from flask import session as flask_session",
            "from sqlalchemy import and_",
            "from sqlalchemy.orm.attributes import flag_modified",
            "from sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError",
            "from sqlalchemy.sql.expression import func, or_, text",
            "",
            "from . import constants, logger, helper, services, cli_param",
            "from . import db, calibre_db, ub, web_server, config, updater_thread, gdriveutils, \\",
            "    kobo_sync_status, schedule",
            "from .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\",
            "    valid_email, check_username",
            "from .embed_helper import get_calibre_binarypath",
            "from .gdriveutils import is_gdrive_ready, gdrive_support",
            "from .render_template import render_title_template, get_sidebar_config",
            "from .services.worker import WorkerThread",
            "from .babel import get_available_translations, get_available_locale, get_user_locale_language",
            "from . import debug_info",
            "",
            "log = logger.create()",
            "",
            "feature_support = {",
            "    'ldap': bool(services.ldap),",
            "    'goodreads': bool(services.goodreads_support),",
            "    'kobo': bool(services.kobo),",
            "    'updater': constants.UPDATER_AVAILABLE,",
            "    'gmail': bool(services.gmail),",
            "    'scheduler': schedule.use_APScheduler,",
            "    'gdrive': gdrive_support",
            "}",
            "",
            "try:",
            "    import rarfile  # pylint: disable=unused-import",
            "",
            "    feature_support['rar'] = True",
            "except (ImportError, SyntaxError):",
            "    feature_support['rar'] = False",
            "",
            "try:",
            "    from .oauth_bb import oauth_check, oauthblueprints",
            "",
            "    feature_support['oauth'] = True",
            "except ImportError as err:",
            "    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)",
            "    feature_support['oauth'] = False",
            "    oauthblueprints = []",
            "    oauth_check = {}",
            "",
            "admi = Blueprint('admin', __name__)",
            "",
            "",
            "def admin_required(f):",
            "    \"\"\"",
            "    Checks if current_user.role == 1",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def inner(*args, **kwargs):",
            "        if current_user.role_admin():",
            "            return f(*args, **kwargs)",
            "        abort(403)",
            "",
            "    return inner",
            "",
            "",
            "@admi.before_app_request",
            "def before_request():",
            "    try:",
            "        if not ub.check_user_session(current_user.id,",
            "                                     flask_session.get('_id')) and 'opds' not in request.path \\",
            "          and config.config_session == 1:",
            "            logout_user()",
            "    except AttributeError:",
            "        pass    # ? fails on requesting /ajax/emailstat during restart ?",
            "    g.constants = constants",
            "    g.google_site_verification = os.getenv('GOOGLE_SITE_VERIFICATION', '')",
            "    g.allow_registration = config.config_public_reg",
            "    g.allow_anonymous = config.config_anonbrowse",
            "    g.allow_upload = config.config_uploading",
            "    g.current_theme = config.config_theme",
            "    g.config_authors_max = config.config_authors_max",
            "    if '/static/' not in request.path and not config.db_configured and \\",
            "        request.endpoint not in ('admin.ajax_db_config',",
            "                                 'admin.simulatedbchange',",
            "                                 'admin.db_configuration',",
            "                                 'web.login',",
            "                                 'web.login_post',",
            "                                 'web.logout',",
            "                                 'admin.load_dialogtexts',",
            "                                 'admin.ajax_pathchooser'):",
            "        return redirect(url_for('admin.db_configuration'))",
            "",
            "",
            "@admi.route(\"/admin\")",
            "@login_required",
            "def admin_forbidden():",
            "    abort(403)",
            "",
            "",
            "@admi.route(\"/shutdown\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def shutdown():",
            "    task = request.get_json().get('parameter', -1)",
            "    show_text = {}",
            "    if task in (0, 1):  # valid commandos received",
            "        # close all database connections",
            "        calibre_db.dispose()",
            "        ub.dispose()",
            "",
            "        if task == 0:",
            "            show_text['text'] = _('Server restarted, please reload page.')",
            "        else:",
            "            show_text['text'] = _('Performing Server shutdown, please close window.')",
            "        # stop gevent/tornado server",
            "        web_server.stop(task == 0)",
            "        return json.dumps(show_text)",
            "",
            "    if task == 2:",
            "        log.warning(\"reconnecting to calibre database\")",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        show_text['text'] = _('Success! Database Reconnected')",
            "        return json.dumps(show_text)",
            "",
            "    show_text['text'] = _('Unknown command')",
            "    return json.dumps(show_text), 400",
            "",
            "",
            "@admi.route(\"/metadata_backup\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def queue_metadata_backup():",
            "    show_text = {}",
            "    log.warning(\"Queuing all books for metadata backup\")",
            "    helper.set_all_metadata_dirty()",
            "    show_text['text'] = _('Success! Books queued for Metadata Backup, please check Tasks for result')",
            "    return json.dumps(show_text)",
            "",
            "",
            "# method is available without login and not protected by CSRF to make it easy reachable, is per default switched off",
            "# needed for docker applications, as changes on metadata.db from host are not visible to application",
            "@admi.route(\"/reconnect\", methods=['GET'])",
            "def reconnect():",
            "    if cli_param.reconnect_enable:",
            "        calibre_db.reconnect_db(config, ub.app_DB_path)",
            "        return json.dumps({})",
            "    else:",
            "        log.debug(\"'/reconnect' was accessed but is not enabled\")",
            "        abort(404)",
            "",
            "",
            "@admi.route(\"/ajax/updateThumbnails\", methods=['POST'])",
            "@admin_required",
            "@login_required",
            "def update_thumbnails():",
            "    content = config.get_scheduled_task_settings()",
            "    if content['schedule_generate_book_covers']:",
            "        log.info(\"Update of Cover cache requested\")",
            "        helper.update_thumbnail_cache()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/view\")",
            "@login_required",
            "@admin_required",
            "def admin():",
            "    version = updater_thread.get_current_version_info()",
            "    if version is False:",
            "        commit = _('Unknown')",
            "    else:",
            "        if 'datetime' in version:",
            "            commit = version['datetime']",
            "",
            "            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)",
            "            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")",
            "            if len(commit) > 19:  # check if string has timezone",
            "                if commit[19] == '+':",
            "                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "                elif commit[19] == '-':",
            "                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))",
            "            commit = format_datetime(form_date - tz, format='short')",
            "        else:",
            "            commit = version['version'].replace(\"b\", \" Beta\")",
            "",
            "    all_user = ub.session.query(ub.User).all()",
            "    # email_settings = mail_config.get_mail_settings()",
            "    schedule_time = format_time(datetime_time(hour=config.schedule_start_time), format=\"short\")",
            "    t = timedelta(hours=config.schedule_duration // 60, minutes=config.schedule_duration % 60)",
            "    schedule_duration = format_timedelta(t, threshold=.99)",
            "",
            "    return render_title_template(\"admin.html\", allUser=all_user, config=config, commit=commit,",
            "                                 feature_support=feature_support, schedule_time=schedule_time,",
            "                                 schedule_duration=schedule_duration,",
            "                                 title=_(\"Admin page\"), page=\"admin\")",
            "",
            "",
            "@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def db_configuration():",
            "    if request.method == \"POST\":",
            "        return _db_configuration_update_helper()",
            "    return _db_configuration_result()",
            "",
            "",
            "@admi.route(\"/admin/config\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def configuration():",
            "    return render_title_template(\"config_edit.html\",",
            "                                 config=config,",
            "                                 provider=oauthblueprints,",
            "                                 feature_support=feature_support,",
            "                                 title=_(\"Basic Configuration\"), page=\"config\")",
            "",
            "",
            "@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_config():",
            "    return _configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_db_config():",
            "    return _db_configuration_update_helper()",
            "",
            "",
            "@admi.route(\"/admin/alive\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def calibreweb_alive():",
            "    return \"\", 200",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\")",
            "@login_required",
            "@admin_required",
            "def view_configuration():",
            "    read_column = calibre_db.session.query(db.CustomColumns) \\",
            "        .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all()",
            "    restrict_columns = calibre_db.session.query(db.CustomColumns) \\",
            "        .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all()",
            "    languages = calibre_db.speaking_language()",
            "    translations = get_available_locale()",
            "    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,",
            "                                 restrictColumns=restrict_columns,",
            "                                 languages=languages,",
            "                                 translations=translations,",
            "                                 title=_(\"UI Configuration\"), page=\"uiconfig\")",
            "",
            "",
            "@admi.route(\"/admin/usertable\")",
            "@login_required",
            "@admin_required",
            "def edit_user_table():",
            "    visibility = current_user.view_settings.get('useredit', {})",
            "    languages = calibre_db.speaking_language()",
            "    translations = get_available_locale()",
            "    all_user = ub.session.query(ub.User)",
            "    tags = calibre_db.session.query(db.Tags) \\",
            "        .join(db.books_tags_link) \\",
            "        .join(db.Books) \\",
            "        .filter(calibre_db.common_filters()) \\",
            "        .group_by(text('books_tags_link.tag')) \\",
            "        .order_by(db.Tags.name).all()",
            "    if config.config_restricted_column:",
            "        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()",
            "    else:",
            "        custom_values = []",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    return render_title_template(\"user_table.html\",",
            "                                 users=all_user.all(),",
            "                                 tags=tags,",
            "                                 custom_values=custom_values,",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 visiblility=visibility,",
            "                                 all_roles=constants.ALL_ROLES,",
            "                                 kobo_support=kobo_support,",
            "                                 sidebar_settings=constants.sidebar_settings,",
            "                                 title=_(\"Edit Users\"),",
            "                                 page=\"usertable\")",
            "",
            "",
            "@admi.route(\"/ajax/listusers\")",
            "@login_required",
            "@admin_required",
            "def list_users():",
            "    off = int(request.args.get(\"offset\") or 0)",
            "    limit = int(request.args.get(\"limit\") or 10)",
            "    search = request.args.get(\"search\")",
            "    sort = request.args.get(\"sort\", \"id\")",
            "    state = None",
            "    if sort == \"state\":",
            "        state = json.loads(request.args.get(\"state\", \"[]\"))",
            "    else:",
            "        if sort not in ub.User.__table__.columns.keys():",
            "            sort = \"id\"",
            "    order = request.args.get(\"order\", \"\").lower()",
            "",
            "    if sort != \"state\" and order:",
            "        order = text(sort + \" \" + order)",
            "    elif not state:",
            "        order = ub.User.id.asc()",
            "",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "",
            "    total_count = filtered_count = all_user.count()",
            "",
            "    if search:",
            "        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),",
            "                                       func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),",
            "                                       func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))",
            "    if state:",
            "        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())",
            "    else:",
            "        users = all_user.order_by(order).offset(off).limit(limit).all()",
            "    if search:",
            "        filtered_count = len(users)",
            "",
            "    for user in users:",
            "        if user.default_language == \"all\":",
            "            user.default = _(\"All\")",
            "        else:",
            "            user.default = get_user_locale_language(user.default_language)",
            "",
            "    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}",
            "    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)",
            "    response = make_response(js_list)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/deleteuser\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user():",
            "    user_ids = request.form.to_dict(flat=False)",
            "    users = None",
            "    message = \"\"",
            "    if \"userid[]\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()",
            "    elif \"userid\" in user_ids:",
            "        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()",
            "    count = 0",
            "    errors = list()",
            "    success = list()",
            "    if not users:",
            "        log.error(\"User not found\")",
            "        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')",
            "    for user in users:",
            "        try:",
            "            message = _delete_user(user)",
            "            count += 1",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            errors.append({'type': \"danger\", 'message': str(ex)})",
            "",
            "    if count == 1:",
            "        log.info(\"User {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': message}]",
            "    elif count > 1:",
            "        log.info(\"Users {} deleted\".format(user_ids))",
            "        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]",
            "    success.extend(errors)",
            "    return Response(json.dumps(success), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/ajax/getlocale\")",
            "@login_required",
            "@admin_required",
            "def table_get_locale():",
            "    locale = get_available_locale()",
            "    ret = list()",
            "    current_locale = get_locale()",
            "    for loc in locale:",
            "        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/getdefaultlanguage\")",
            "@login_required",
            "@admin_required",
            "def table_get_default_lang():",
            "    languages = calibre_db.speaking_language()",
            "    ret = list()",
            "    ret.append({'value': 'all', 'text': _('Show All')})",
            "    for lang in languages:",
            "        ret.append({'value': lang.lang_code, 'text': lang.name})",
            "    return json.dumps(ret)",
            "",
            "",
            "@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_list_user(param):",
            "    vals = request.form.to_dict(flat=False)",
            "    all_user = ub.session.query(ub.User)",
            "    if not config.config_anonbrowse:",
            "        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)",
            "    # only one user is posted",
            "    if \"pk\" in vals:",
            "        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]",
            "    else:",
            "        if \"pk[]\" in vals:",
            "            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()",
            "        else:",
            "            return _(\"Malformed request\"), 400",
            "    if 'field_index' in vals:",
            "        vals['field_index'] = vals['field_index'][0]",
            "    if 'value' in vals:",
            "        vals['value'] = vals['value'][0]",
            "    elif not ('value[]' in vals):",
            "        return _(\"Malformed request\"), 400",
            "    for user in users:",
            "        try:",
            "            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:",
            "                if 'value[]' in vals:",
            "                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))",
            "                else:",
            "                    setattr(user, param, vals['value'].strip())",
            "            else:",
            "                vals['value'] = vals['value'].strip()",
            "                if param == 'name':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest Name can't be changed\"))",
            "                    user.name = check_username(vals['value'])",
            "                elif param == 'email':",
            "                    user.email = check_email(vals['value'])",
            "                elif param == 'kobo_only_shelves_sync':",
            "                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')",
            "                elif param == 'kindle_mail':",
            "                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"",
            "                elif param.endswith('role'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value in \\",
            "                      [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:",
            "                        raise Exception(_(\"Guest can't have this role\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value - 1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.role |= value",
            "                        elif vals['value'] == 'false':",
            "                            if value == constants.ROLE_ADMIN:",
            "                                if not ub.session.query(ub.User). \\",
            "                                    filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                           ub.User.id != user.id).count():",
            "                                    return Response(",
            "                                        json.dumps([{'type': \"danger\",",
            "                                                     'message': _(\"No admin user remaining, can't remove admin role\",",
            "                                                                  nick=user.name)}]), mimetype='application/json')",
            "                            user.role &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid role\"))",
            "                elif param.startswith('sidebar'):",
            "                    value = int(vals['field_index'])",
            "                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:",
            "                        raise Exception(_(\"Guest can't have this view\"))",
            "                    # check for valid value, last on checks for power of 2 value",
            "                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value - 1 == 0 or value == 1):",
            "                        if vals['value'] == 'true':",
            "                            user.sidebar_view |= value",
            "                        elif vals['value'] == 'false':",
            "                            user.sidebar_view &= ~value",
            "                        else:",
            "                            raise Exception(_(\"Value has to be true or false\"))",
            "                    else:",
            "                        raise Exception(_(\"Invalid view\"))",
            "                elif param == 'locale':",
            "                    if user.name == \"Guest\":",
            "                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))",
            "                    if vals['value'] in get_available_translations():",
            "                        user.locale = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Locale Given\"))",
            "                elif param == 'default_language':",
            "                    languages = calibre_db.session.query(db.Languages) \\",
            "                        .join(db.books_languages_link) \\",
            "                        .join(db.Books) \\",
            "                        .filter(calibre_db.common_filters()) \\",
            "                        .group_by(text('books_languages_link.lang_code')).all()",
            "                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]",
            "                    if vals['value'] in lang_codes:",
            "                        user.default_language = vals['value']",
            "                    else:",
            "                        raise Exception(_(\"No Valid Book Language Given\"))",
            "                else:",
            "                    return _(\"Parameter not found\"), 400",
            "        except Exception as ex:",
            "            log.error_or_exception(ex)",
            "            return str(ex), 400",
            "    ub.session_commit()",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/user_table_settings\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def update_table_settings():",
            "    current_user.view_settings['useredit'] = json.loads(request.data)",
            "    try:",
            "        try:",
            "            flag_modified(current_user, \"view_settings\")",
            "        except AttributeError:",
            "            pass",
            "        ub.session.commit()",
            "    except (InvalidRequestError, OperationalError):",
            "        log.error(\"Invalid request received: {}\".format(request))",
            "        return \"Invalid request\", 400",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_view_configuration():",
            "    to_save = request.form.to_dict()",
            "",
            "    _config_string(to_save, \"config_calibre_web_title\")",
            "    _config_string(to_save, \"config_columns_to_ignore\")",
            "    if _config_string(to_save, \"config_title_regex\"):",
            "        calibre_db.update_title_sort(config)",
            "",
            "    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):",
            "        flash(_(\"Invalid Read Column\"), category=\"error\")",
            "        log.debug(\"Invalid Read column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_read_column\")",
            "",
            "    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):",
            "        flash(_(\"Invalid Restricted Column\"), category=\"error\")",
            "        log.debug(\"Invalid Restricted Column\")",
            "        return view_configuration()",
            "    _config_int(to_save, \"config_restricted_column\")",
            "",
            "    _config_int(to_save, \"config_theme\")",
            "    _config_int(to_save, \"config_random_books\")",
            "    _config_int(to_save, \"config_books_per_page\")",
            "    _config_int(to_save, \"config_authors_max\")",
            "    _config_string(to_save, \"config_default_language\")",
            "    _config_string(to_save, \"config_default_locale\")",
            "",
            "    config.config_default_role = constants.selected_roles(to_save)",
            "    config.config_default_role &= ~constants.ROLE_ANONYMOUS",
            "",
            "    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))",
            "    if \"Show_detail_random\" in to_save:",
            "        config.config_default_show |= constants.DETAIL_RANDOM",
            "",
            "    config.save()",
            "    flash(_(\"Calibre-Web configuration updated\"), category=\"success\")",
            "    log.debug(\"Calibre-Web configuration updated\")",
            "    before_request()",
            "",
            "    return view_configuration()",
            "",
            "",
            "@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])",
            "@login_required",
            "def load_dialogtexts(element_id):",
            "    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}",
            "    if element_id == \"config_delete_kobo_token\":",
            "        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')",
            "    elif element_id == \"btndeletedomain\":",
            "        texts[\"main\"] = _('Do you really want to delete this domain?')",
            "    elif element_id == \"btndeluser\":",
            "        texts[\"main\"] = _('Do you really want to delete this user?')",
            "    elif element_id == \"delete_shelf\":",
            "        texts[\"main\"] = _('Are you sure you want to delete this shelf?')",
            "    elif element_id == \"select_locale\":",
            "        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')",
            "    elif element_id == \"select_default_language\":",
            "        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')",
            "    elif element_id == \"role\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')",
            "    elif element_id == \"restrictions\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')",
            "    elif element_id == \"sidebar_view\":",
            "        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions '",
            "                          'for the selected user(s)?')",
            "    elif element_id == \"kobo_only_shelves_sync\":",
            "        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')",
            "    elif element_id == \"db_submit\":",
            "        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')",
            "    elif element_id == \"admin_refresh_cover_cache\":",
            "        texts[\"main\"] = _('Calibre-Web will search for updated Covers '",
            "                          'and update Cover Thumbnails, this may take a while?')",
            "    elif element_id == \"btnfullsync\":",
            "        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database \"",
            "                          \"to force a full sync with your Kobo Reader?\")",
            "    return json.dumps(texts)",
            "",
            "",
            "@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_domain(allow):",
            "    # POST /post",
            "    # name:  'username',  //name of field (column in db)",
            "    # pk:    1            //primary key (record id)",
            "    # value: 'superuser!' //new value",
            "    vals = request.form.to_dict()",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()",
            "    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()",
            "    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))",
            "",
            "",
            "@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_domain(allow):",
            "    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()",
            "    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name) \\",
            "        .filter(ub.Registration.allow == allow).first()",
            "    if not check:",
            "        new_domain = ub.Registration(domain=domain_name, allow=allow)",
            "        ub.session.add(new_domain)",
            "        ub.session_commit(\"Registering Domains added {}\".format(domain_name))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deletedomain\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_domain():",
            "    try:",
            "        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()",
            "        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()",
            "        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))",
            "        # If last domain was deleted, add all domains by default",
            "        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():",
            "            new_domain = ub.Registration(domain=\"%.%\", allow=1)",
            "            ub.session.add(new_domain)",
            "            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")",
            "    except KeyError:",
            "        pass",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/domainlist/<int:allow>\")",
            "@login_required",
            "@admin_required",
            "def list_domain(allow):",
            "    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()",
            "    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])",
            "    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')",
            "    response = make_response(js.replace(\"'\", '\"'))",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])",
            "@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def edit_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if element['id'].startswith('a'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_allowed_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_allowed_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.allowed_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))",
            "    if element['id'].startswith('d'):",
            "        if res_type == 0:  # Tags as template",
            "            elementlist = config.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_tags = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 1:  # CustomC",
            "            elementlist = config.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            config.config_denied_column_value = ','.join(elementlist)",
            "            config.save()",
            "        if res_type == 2:  # Tags per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_tags()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_tags = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))",
            "        if res_type == 3:  # CColumn per user",
            "            if isinstance(user_id, int):",
            "                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "            else:",
            "                usr = current_user",
            "            elementlist = usr.list_denied_column_values()",
            "            elementlist[int(element['id'][1:])] = element['Element']",
            "            usr.denied_column_value = ','.join(elementlist)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_user_0_restriction(res_type):",
            "    return add_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def add_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)",
            "            config.save()",
            "    if res_type == 1:  # CCustom as template",
            "        if 'submit_allow' in element:",
            "            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)",
            "            config.save()",
            "        elif 'submit_deny' in element:",
            "            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)",
            "            config.save()",
            "    if res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))",
            "    if res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if 'submit_allow' in element:",
            "            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,",
            "                                                                                usr.list_allowed_column_values()))",
            "        elif 'submit_deny' in element:",
            "            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,",
            "                                                                               usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_user_0_restriction(res_type):",
            "    return delete_restriction(res_type, 0)",
            "",
            "",
            "@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def delete_restriction(res_type, user_id):",
            "    element = request.form.to_dict()",
            "    if res_type == 0:  # Tags as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)",
            "            config.save()",
            "    elif res_type == 1:  # CustomC as template",
            "        if element['id'].startswith('a'):",
            "            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)",
            "            config.save()",
            "        elif element['id'].startswith('d'):",
            "            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)",
            "            config.save()",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)",
            "            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, element['Element']))",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)",
            "            ub.session_commit(\"Deleted denied tag of user {}: {}\".format(usr.name, element['Element']))",
            "    elif res_type == 3:  # Columns per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()",
            "        else:",
            "            usr = current_user",
            "        if element['id'].startswith('a'):",
            "            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)",
            "            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,",
            "                                                                              usr.list_allowed_column_values()))",
            "",
            "        elif element['id'].startswith('d'):",
            "            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)",
            "            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,",
            "                                                                             usr.list_denied_column_values()))",
            "    return \"\"",
            "",
            "",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})",
            "@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")",
            "@login_required",
            "@admin_required",
            "def list_restriction(res_type, user_id):",
            "    if res_type == 0:  # Tags as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(config.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(config.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 1:  # CustomC as template",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(config.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 2:  # Tags per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(usr.list_denied_tags()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']",
            "        json_dumps = restrict + allow",
            "    elif res_type == 3:  # CustomC per user",
            "        if isinstance(user_id, int):",
            "            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()",
            "        else:",
            "            usr = current_user",
            "        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd' + str(i)}",
            "                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']",
            "        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a' + str(i)}",
            "                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']",
            "        json_dumps = restrict + allow",
            "    else:",
            "        json_dumps = \"\"",
            "    js = json.dumps(json_dumps)",
            "    response = make_response(js)",
            "    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"",
            "    return response",
            "",
            "",
            "@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])",
            "@login_required",
            "def ajax_self_fullsync():",
            "    return do_full_kobo_sync(current_user.id)",
            "",
            "",
            "@admi.route(\"/ajax/fullsync/<int:userid>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def ajax_fullsync(userid):",
            "    return do_full_kobo_sync(userid)",
            "",
            "",
            "@admi.route(\"/ajax/pathchooser/\")",
            "@login_required",
            "@admin_required",
            "def ajax_pathchooser():",
            "    return pathchooser()",
            "",
            "",
            "def do_full_kobo_sync(userid):",
            "    count = ub.session.query(ub.KoboSyncedBooks).filter(userid == ub.KoboSyncedBooks.user_id).delete()",
            "    message = _(\"{} sync entries deleted\").format(count)",
            "    ub.session_commit(message)",
            "    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')",
            "",
            "",
            "def check_valid_read_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
            "          .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "def check_valid_restricted_column(column):",
            "    if column != \"0\":",
            "        if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\",
            "          .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():",
            "            return False",
            "    return True",
            "",
            "",
            "def restriction_addition(element, list_func):",
            "    elementlist = list_func()",
            "    if elementlist == ['']:",
            "        elementlist = []",
            "    if not element['add_element'] in elementlist:",
            "        elementlist += [element['add_element']]",
            "    return ','.join(elementlist)",
            "",
            "",
            "def restriction_deletion(element, list_func):",
            "    elementlist = list_func()",
            "    if element['Element'] in elementlist:",
            "        elementlist.remove(element['Element'])",
            "    return ','.join(elementlist)",
            "",
            "",
            "def prepare_tags(user, action, tags_name, id_list):",
            "    if \"tags\" in tags_name:",
            "        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()",
            "        if not tags:",
            "            raise Exception(_(\"Tag not found\"))",
            "        new_tags_list = [x.name for x in tags]",
            "    else:",
            "        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column]) \\",
            "            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()",
            "        new_tags_list = [x.value for x in tags]",
            "    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []",
            "    if action == \"remove\":",
            "        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]",
            "    elif action == \"add\":",
            "        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)",
            "    else:",
            "        raise Exception(_(\"Invalid Action\"))",
            "    return \",\".join(saved_tags_list)",
            "",
            "",
            "def get_drives(current):",
            "    drive_letters = []",
            "    for d in string.ascii_uppercase:",
            "        if os.path.exists('{}:'.format(d)) and current[0].lower() != d.lower():",
            "            drive = \"{}:\\\\\".format(d)",
            "            data = {\"name\": drive, \"fullpath\": drive, \"type\": \"dir\", \"size\": \"\", \"sort\": \"_\" + drive.lower()}",
            "            drive_letters.append(data)",
            "    return drive_letters",
            "",
            "",
            "def pathchooser():",
            "    browse_for = \"folder\"",
            "    folder_only = request.args.get('folder', False) == \"true\"",
            "    file_filter = request.args.get('filter', \"\")",
            "    path = os.path.normpath(request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        old_file = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        old_file = \"\"",
            "",
            "    absolute = False",
            "",
            "    if os.path.isdir(path):",
            "        cwd = os.path.realpath(path)",
            "        absolute = True",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parent_dir = os.path.dirname(cwd)",
            "    if not absolute:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parent_dir = os.path.relpath(parent_dir) + os.path.sep",
            "",
            "    files = []",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\") \\",
            "            or (sys.platform == \"win32\" and os.path.realpath(cwd)[1:] == os.path.realpath(\"/\")[1:]):",
            "        # we are in root",
            "        parent_dir = \"\"",
            "        if sys.platform == \"win32\":",
            "            files = get_drives(cwd)",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    for f in folders:",
            "        try:",
            "            sanitized_f = str(Markup.escape(f))",
            "            data = {\"name\": sanitized_f, \"fullpath\": os.path.join(cwd, sanitized_f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            if folder_only:",
            "                continue",
            "            if file_filter != \"\" and file_filter != f:",
            "                continue",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parent_dir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": old_file,",
            "        \"absolute\": absolute,",
            "    }",
            "    return json.dumps(context)",
            "",
            "",
            "def _config_int(to_save, x, func=int):",
            "    return config.set_from_dictionary(to_save, x, func)",
            "",
            "",
            "def _config_checkbox(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)",
            "",
            "",
            "def _config_checkbox_int(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)",
            "",
            "",
            "def _config_string(to_save, x):",
            "    return config.set_from_dictionary(to_save, x, lambda y: y.strip().strip(u'\\u200B\\u200C\\u200D\\ufeff') if y else y)",
            "",
            "",
            "def _configuration_gdrive_helper(to_save):",
            "    gdrive_error = None",
            "    if to_save.get(\"config_use_google_drive\"):",
            "        gdrive_secrets = {}",
            "",
            "        if not os.path.isfile(gdriveutils.SETTINGS_YAML):",
            "            config.config_use_google_drive = False",
            "",
            "        if gdrive_support:",
            "            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)",
            "        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:",
            "            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:",
            "                gdrive_secrets = json.load(settings)['web']",
            "            if not gdrive_secrets:",
            "                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))",
            "            gdriveutils.update_settings(",
            "                gdrive_secrets['client_id'],",
            "                gdrive_secrets['client_secret'],",
            "                gdrive_secrets['redirect_uris'][0]",
            "            )",
            "",
            "    # always show Google Drive settings, but in case of error deny support",
            "    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)",
            "    if config.config_use_google_drive and not new_gdrive_value:",
            "        config.config_google_drive_watch_changes_response = {}",
            "    config.config_use_google_drive = new_gdrive_value",
            "    if _config_string(to_save, \"config_google_drive_folder\"):",
            "        gdriveutils.deleteDatabaseOnChange()",
            "    return gdrive_error",
            "",
            "",
            "def _configuration_oauth_helper(to_save):",
            "    active_oauths = 0",
            "    reboot_required = False",
            "    for element in oauthblueprints:",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\",
            "          or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:",
            "            reboot_required = True",
            "            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]",
            "            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]",
            "        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\",
            "          and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:",
            "            active_oauths += 1",
            "            element[\"active\"] = 1",
            "        else:",
            "            element[\"active\"] = 0",
            "        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(",
            "            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],",
            "             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],",
            "             \"active\": element[\"active\"]})",
            "    return reboot_required",
            "",
            "",
            "def _configuration_logfile_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_log_level\")",
            "    reboot_required |= _config_string(to_save, \"config_logfile\")",
            "    if not logger.is_valid_logfile(config.config_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")",
            "    reboot_required |= _config_string(to_save, \"config_access_logfile\")",
            "    if not logger.is_valid_logfile(config.config_access_logfile):",
            "        return reboot_required, \\",
            "               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "def _configuration_ldap_helper(to_save):",
            "    reboot_required = False",
            "    reboot_required |= _config_int(to_save, \"config_ldap_port\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_dn\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")",
            "    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")",
            "    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")",
            "    _config_string(to_save, \"config_ldap_group_name\")",
            "",
            "    address = urlparse(to_save.get(\"config_ldap_provider_url\", \"\"))",
            "    to_save[\"config_ldap_provider_url\"] = (address.hostname or address.path).strip(\"/\")",
            "    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")",
            "",
            "    if to_save.get(\"config_ldap_serv_password_e\", \"\") != \"\":",
            "        reboot_required |= 1",
            "        config.set_from_dictionary(to_save, \"config_ldap_serv_password_e\")",
            "    config.save()",
            "",
            "    if not config.config_ldap_provider_url \\",
            "      or not config.config_ldap_port \\",
            "      or not config.config_ldap_dn \\",
            "      or not config.config_ldap_user_object:",
            "        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '",
            "                                                        'Port, DN and User Object Identifier'))",
            "",
            "    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:",
            "        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:",
            "            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password_e):",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))",
            "        else:",
            "            if not config.config_ldap_serv_username:",
            "                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))",
            "",
            "    if config.config_ldap_group_object_filter:",
            "        if config.config_ldap_group_object_filter.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_user_object.count(\"%s\") != 1:",
            "        return reboot_required, \\",
            "               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))",
            "    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):",
            "        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))",
            "",
            "    if to_save.get(\"ldap_import_user_filter\") == '0':",
            "        config.config_ldap_member_user_object = \"\"",
            "    else:",
            "        if config.config_ldap_member_user_object.count(\"%s\") != 1:",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))",
            "        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):",
            "            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))",
            "",
            "    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:",
            "        if not (os.path.isfile(config.config_ldap_cacert_path) and",
            "                os.path.isfile(config.config_ldap_cert_path) and",
            "                os.path.isfile(config.config_ldap_key_path)):",
            "            return reboot_required, \\",
            "                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '",
            "                                           'Please Enter Correct Path'))",
            "    return reboot_required, None",
            "",
            "",
            "@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def simulatedbchange():",
            "    db_change, db_valid = _db_simulate_change()",
            "    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')",
            "",
            "",
            "@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def new_user():",
            "    content = ub.User()",
            "    languages = calibre_db.speaking_language()",
            "    translations = get_available_locale()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        _handle_new_user(to_save, content, languages, translations, kobo_support)",
            "    else:",
            "        content.role = config.config_default_role",
            "        content.sidebar_view = config.config_default_show",
            "        content.locale = config.config_default_locale",
            "        content.default_language = config.config_default_language",
            "    return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                 config=config, translations=translations,",
            "                                 languages=languages, title=_(\"Add New User\"), page=\"newuser\",",
            "                                 kobo_support=kobo_support, registered_oauth=oauth_check)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"GET\"])",
            "@login_required",
            "@admin_required",
            "def edit_mailsettings():",
            "    content = config.get_mail_settings()",
            "    return render_title_template(\"email_edit.html\", content=content, title=_(\"Edit Email Server Settings\"),",
            "                                 page=\"mailset\", feature_support=feature_support)",
            "",
            "",
            "@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_mailsettings():",
            "    to_save = request.form.to_dict()",
            "    _config_int(to_save, \"mail_server_type\")",
            "    if to_save.get(\"invalidate\"):",
            "        config.mail_gmail_token = {}",
            "        try:",
            "            flag_modified(config, \"mail_gmail_token\")",
            "        except AttributeError:",
            "            pass",
            "    elif to_save.get(\"gmail\"):",
            "        try:",
            "            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)",
            "            flash(_(\"Success! Gmail Account Verified.\"), category=\"success\")",
            "        except Exception as ex:",
            "            flash(str(ex), category=\"error\")",
            "            log.error(ex)",
            "            return edit_mailsettings()",
            "",
            "    else:",
            "        _config_int(to_save, \"mail_port\")",
            "        _config_int(to_save, \"mail_use_ssl\")",
            "        if to_save.get(\"mail_password_e\", \"\"):",
            "            _config_string(to_save, \"mail_password_e\")",
            "        _config_int(to_save, \"mail_size\", lambda y: int(y) * 1024 * 1024)",
            "        config.mail_server = to_save.get('mail_server', \"\").strip()",
            "        config.mail_from = to_save.get('mail_from', \"\").strip()",
            "        config.mail_login = to_save.get('mail_login', \"\").strip()",
            "    try:",
            "        config.save()",
            "    except (OperationalError, InvalidRequestError) as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "        return edit_mailsettings()",
            "    except Exception as e:",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "        return edit_mailsettings()",
            "",
            "    if to_save.get(\"test\"):",
            "        if current_user.email:",
            "            result = send_test_mail(current_user.email, current_user.name)",
            "            if result is None:",
            "                flash(_(\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",",
            "                        email=current_user.email), category=\"info\")",
            "            else:",
            "                flash(_(\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")",
            "        else:",
            "            flash(_(\"Please configure your e-mail address first...\"), category=\"error\")",
            "    else:",
            "        flash(_(\"Email Server Settings updated\"), category=\"success\")",
            "",
            "    return edit_mailsettings()",
            "",
            "",
            "@admi.route(\"/admin/scheduledtasks\")",
            "@login_required",
            "@admin_required",
            "def edit_scheduledtasks():",
            "    content = config.get_scheduled_task_settings()",
            "    time_field = list()",
            "    duration_field = list()",
            "",
            "    for n in range(24):",
            "        time_field.append((n, format_time(datetime_time(hour=n), format=\"short\", )))",
            "    for n in range(5, 65, 5):",
            "        t = timedelta(hours=n // 60, minutes=n % 60)",
            "        duration_field.append((n, format_timedelta(t, threshold=.97)))",
            "",
            "    return render_title_template(\"schedule_edit.html\",",
            "                                 config=content,",
            "                                 starttime=time_field,",
            "                                 duration=duration_field,",
            "                                 title=_(\"Edit Scheduled Tasks Settings\"))",
            "",
            "",
            "@admi.route(\"/admin/scheduledtasks\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def update_scheduledtasks():",
            "    error = False",
            "    to_save = request.form.to_dict()",
            "    if 0 <= int(to_save.get(\"schedule_start_time\")) <= 23:",
            "        _config_int(to_save, \"schedule_start_time\")",
            "    else:",
            "        flash(_(\"Invalid start time for task specified\"), category=\"error\")",
            "        error = True",
            "    if 0 < int(to_save.get(\"schedule_duration\")) <= 60:",
            "        _config_int(to_save, \"schedule_duration\")",
            "    else:",
            "        flash(_(\"Invalid duration for task specified\"), category=\"error\")",
            "        error = True",
            "    _config_checkbox(to_save, \"schedule_generate_book_covers\")",
            "    _config_checkbox(to_save, \"schedule_generate_series_covers\")",
            "    _config_checkbox(to_save, \"schedule_metadata_backup\")",
            "    _config_checkbox(to_save, \"schedule_reconnect\")",
            "",
            "    if not error:",
            "        try:",
            "            config.save()",
            "            flash(_(\"Scheduled tasks settings updated\"), category=\"success\")",
            "",
            "            # Cancel any running tasks",
            "            schedule.end_scheduled_tasks()",
            "",
            "            # Re-register tasks with new settings",
            "            schedule.register_scheduled_tasks(config.schedule_reconnect)",
            "        except IntegrityError:",
            "            ub.session.rollback()",
            "            log.error(\"An unknown error occurred while saving scheduled tasks settings\")",
            "            flash(_(\"Oops! An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        except OperationalError:",
            "            ub.session.rollback()",
            "            log.error(\"Settings DB is not Writeable\")",
            "            flash(_(\"Settings DB is not Writeable\"), category=\"error\")",
            "",
            "    return edit_scheduledtasks()",
            "",
            "",
            "@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])",
            "@login_required",
            "@admin_required",
            "def edit_user(user_id):",
            "    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User",
            "    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):",
            "        flash(_(\"User not found\"), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    languages = calibre_db.speaking_language(return_all_languages=True)",
            "    translations = get_available_locale()",
            "    kobo_support = feature_support['kobo'] and config.config_kobo_sync",
            "    if request.method == \"POST\":",
            "        to_save = request.form.to_dict()",
            "        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)",
            "        if resp:",
            "            return resp",
            "    return render_title_template(\"user_edit.html\",",
            "                                 translations=translations,",
            "                                 languages=languages,",
            "                                 new_user=0,",
            "                                 content=content,",
            "                                 config=config,",
            "                                 registered_oauth=oauth_check,",
            "                                 mail_configured=config.get_mail_server_configured(),",
            "                                 kobo_support=kobo_support,",
            "                                 title=_(\"Edit User %(nick)s\", nick=content.name),",
            "                                 page=\"edituser\")",
            "",
            "",
            "@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def reset_user_password(user_id):",
            "    if current_user is not None and current_user.is_authenticated:",
            "        ret, message = reset_password(user_id)",
            "        if ret == 1:",
            "            log.debug(\"Password for user %s reset\", message)",
            "            flash(_(\"Success! Password for user %(user)s reset\", user=message), category=\"success\")",
            "        elif ret == 0:",
            "            log.error(\"An unknown error occurred. Please try again later.\")",
            "            flash(_(\"Oops! An unknown error occurred. Please try again later.\"), category=\"error\")",
            "        else:",
            "            log.error(\"Please configure the SMTP mail settings.\")",
            "            flash(_(\"Oops! Please configure the SMTP mail settings.\"), category=\"error\")",
            "    return redirect(url_for('admin.admin'))",
            "",
            "",
            "@admi.route(\"/admin/logfile\")",
            "@login_required",
            "@admin_required",
            "def view_logfile():",
            "    logfiles = {0: logger.get_logfile(config.config_logfile),",
            "                1: logger.get_accesslogfile(config.config_access_logfile)}",
            "    return render_title_template(\"logviewer.html\",",
            "                                 title=_(\"Logfile viewer\"),",
            "                                 accesslog_enable=config.config_access_log,",
            "                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),",
            "                                 logfiles=logfiles,",
            "                                 page=\"logfile\")",
            "",
            "",
            "@admi.route(\"/ajax/log/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def send_logfile(logtype):",
            "    if logtype == 1:",
            "        logfile = logger.get_accesslogfile(config.config_access_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    if logtype == 0:",
            "        logfile = logger.get_logfile(config.config_logfile)",
            "        return send_from_directory(os.path.dirname(logfile),",
            "                                   os.path.basename(logfile))",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@admi.route(\"/admin/logdownload/<int:logtype>\")",
            "@login_required",
            "@admin_required",
            "def download_log(logtype):",
            "    if logtype == 0:",
            "        file_name = logger.get_logfile(config.config_logfile)",
            "    elif logtype == 1:",
            "        file_name = logger.get_accesslogfile(config.config_access_logfile)",
            "    else:",
            "        abort(404)",
            "    if logger.is_valid_logfile(file_name):",
            "        return debug_info.assemble_logfiles(file_name)",
            "    abort(404)",
            "",
            "",
            "@admi.route(\"/admin/debug\")",
            "@login_required",
            "@admin_required",
            "def download_debug():",
            "    return debug_info.send_debug()",
            "",
            "",
            "@admi.route(\"/get_update_status\", methods=['GET'])",
            "@login_required",
            "@admin_required",
            "def get_update_status():",
            "    if feature_support['updater']:",
            "        log.info(\"Update status requested\")",
            "        return updater_thread.get_available_updates(request.method)",
            "    else:",
            "        return ''",
            "",
            "",
            "@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])",
            "@login_required",
            "@admin_required",
            "def get_updater_status():",
            "    status = {}",
            "    if feature_support['updater']:",
            "        if request.method == \"POST\":",
            "            commit = request.form.to_dict()",
            "            if \"start\" in commit and commit['start'] == 'True':",
            "                txt = {",
            "                    \"1\": _(u'Requesting update package'),",
            "                    \"2\": _(u'Downloading update package'),",
            "                    \"3\": _(u'Unzipping update package'),",
            "                    \"4\": _(u'Replacing files'),",
            "                    \"5\": _(u'Database connections are closed'),",
            "                    \"6\": _(u'Stopping server'),",
            "                    \"7\": _(u'Update finished, please press okay and reload page'),",
            "                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),",
            "                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),",
            "                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),",
            "                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),",
            "                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),",
            "                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')",
            "                }",
            "                status['text'] = txt",
            "                updater_thread.status = 0",
            "                updater_thread.resume()",
            "                status['status'] = updater_thread.get_update_status()",
            "        elif request.method == \"GET\":",
            "            try:",
            "                status['status'] = updater_thread.get_update_status()",
            "                if status['status'] == -1:",
            "                    status['status'] = 7",
            "            except Exception:",
            "                status['status'] = 11",
            "        return json.dumps(status)",
            "    return ''",
            "",
            "",
            "def ldap_import_create_user(user, user_data):",
            "    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)",
            "",
            "    try:",
            "        username = user_data[user_login_field][0].decode('utf-8')",
            "    except KeyError as ex:",
            "        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)",
            "        message = _(u'Failed to extract at least One LDAP User')",
            "        return 0, message",
            "",
            "    # check for duplicate username",
            "    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():",
            "        # if ub.session.query(ub.User).filter(ub.User.name == username).first():",
            "        log.warning(\"LDAP User  %s Already in Database\", user_data)",
            "        return 0, None",
            "",
            "    ereader_mail = ''",
            "    if 'mail' in user_data:",
            "        useremail = user_data['mail'][0].decode('utf-8')",
            "        if len(user_data['mail']) > 1:",
            "            ereader_mail = user_data['mail'][1].decode('utf-8')",
            "",
            "    else:",
            "        log.debug('No Mail Field Found in LDAP Response')",
            "        useremail = username + '@email.com'",
            "",
            "    try:",
            "        # check for duplicate email",
            "        useremail = check_email(useremail)",
            "    except Exception as ex:",
            "        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))",
            "        return 0, None",
            "    content = ub.User()",
            "    content.name = username",
            "    content.password = ''  # dummy password which will be replaced by ldap one",
            "    content.email = useremail",
            "    content.kindle_mail = ereader_mail",
            "    content.default_language = config.config_default_language",
            "    content.locale = config.config_default_locale",
            "    content.role = config.config_default_role",
            "    content.sidebar_view = config.config_default_show",
            "    content.allowed_tags = config.config_allowed_tags",
            "    content.denied_tags = config.config_denied_tags",
            "    content.allowed_column_value = config.config_allowed_column_value",
            "    content.denied_column_value = config.config_denied_column_value",
            "    ub.session.add(content)",
            "    try:",
            "        ub.session.commit()",
            "        return 1, None  # increase no of users",
            "    except Exception as ex:",
            "        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)",
            "        ub.session.rollback()",
            "        message = _(u'Failed to Create at Least One LDAP User')",
            "        return 0, message",
            "",
            "",
            "@admi.route('/import_ldap_users', methods=[\"POST\"])",
            "@login_required",
            "@admin_required",
            "def import_ldap_users():",
            "    showtext = {}",
            "    try:",
            "        new_users = services.ldap.get_group_members(config.config_ldap_group_name)",
            "    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:",
            "        log.error_or_exception(e)",
            "        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)",
            "        return json.dumps(showtext)",
            "    if not new_users:",
            "        log.debug('LDAP empty response')",
            "        showtext['text'] = _(u'Error: No user returned in response of LDAP server')",
            "        return json.dumps(showtext)",
            "",
            "    imported = 0",
            "    for username in new_users:",
            "        if isinstance(username, bytes):",
            "            user = username.decode('utf-8')",
            "        else:",
            "            user = username",
            "        if '=' in user:",
            "            # if member object field is empty take user object as filter",
            "            if config.config_ldap_member_user_object:",
            "                query_filter = config.config_ldap_member_user_object",
            "            else:",
            "                query_filter = config.config_ldap_user_object",
            "            try:",
            "                user_identifier = extract_user_identifier(user, query_filter)",
            "            except Exception as ex:",
            "                log.warning(ex)",
            "                continue",
            "        else:",
            "            user_identifier = user",
            "            query_filter = None",
            "        try:",
            "            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)",
            "        except AttributeError as ex:",
            "            log.error_or_exception(ex)",
            "            continue",
            "        if user_data:",
            "            user_count, message = ldap_import_create_user(user, user_data)",
            "            if message:",
            "                showtext['text'] = message",
            "            else:",
            "                imported += user_count",
            "        else:",
            "            log.warning(\"LDAP User: %s Not Found\", user)",
            "            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')",
            "    if not showtext:",
            "        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))",
            "    return json.dumps(showtext)",
            "",
            "",
            "@admi.route(\"/ajax/canceltask\", methods=['POST'])",
            "@login_required",
            "@admin_required",
            "def cancel_task():",
            "    task_id = request.get_json().get('task_id', None)",
            "    worker = WorkerThread.get_instance()",
            "    worker.end_task(task_id)",
            "    return \"\"",
            "",
            "",
            "def _db_simulate_change():",
            "    param = request.form.to_dict()",
            "    to_save = dict()",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           param['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE).strip()",
            "    db_valid, db_change = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"],",
            "                                                    ub.app_DB_path,",
            "                                                    config.config_calibre_uuid)",
            "    db_change = bool(db_change and config.config_calibre_dir)",
            "    return db_change, db_valid",
            "",
            "",
            "def _db_configuration_update_helper():",
            "    db_change = False",
            "    to_save = request.form.to_dict()",
            "    gdrive_error = None",
            "",
            "    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',",
            "                                           '',",
            "                                           to_save['config_calibre_dir'],",
            "                                           flags=re.IGNORECASE)",
            "    db_valid = False",
            "    try:",
            "        db_change, db_valid = _db_simulate_change()",
            "",
            "        # gdrive_error drive setup",
            "        gdrive_error = _configuration_gdrive_helper(to_save)",
            "    except (OperationalError, InvalidRequestError) as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        _db_configuration_result(_(\"Oops! Database Error: %(error)s.\", error=e.orig), gdrive_error)",
            "    try:",
            "        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")",
            "        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):",
            "            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)",
            "            db_change = True",
            "    except Exception as ex:",
            "        return _db_configuration_result('{}'.format(ex), gdrive_error)",
            "",
            "    if db_change or not db_valid or not config.db_configured \\",
            "      or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:",
            "        if not os.path.exists(metadata_db) or not to_save['config_calibre_dir']:",
            "            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'), gdrive_error)",
            "        else:",
            "            calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path)",
            "        config.store_calibre_uuid(calibre_db, db.Library_Id)",
            "        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...",
            "        if db_change:",
            "            log.info(\"Calibre Database changed, all Calibre-Web info related to old Database gets deleted\")",
            "            ub.session.query(ub.Downloads).delete()",
            "            ub.session.query(ub.ArchivedBook).delete()",
            "            ub.session.query(ub.ReadBook).delete()",
            "            ub.session.query(ub.BookShelf).delete()",
            "            ub.session.query(ub.Bookmark).delete()",
            "            ub.session.query(ub.KoboReadingState).delete()",
            "            ub.session.query(ub.KoboStatistics).delete()",
            "            ub.session.query(ub.KoboSyncedBooks).delete()",
            "            helper.delete_thumbnail_cache()",
            "            ub.session_commit()",
            "        _config_string(to_save, \"config_calibre_dir\")",
            "        calibre_db.update_config(config)",
            "        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):",
            "            flash(_(\"DB is not Writeable\"), category=\"warning\")",
            "    _config_string(to_save, \"config_calibre_split_dir\")",
            "    config.config_calibre_split = to_save.get('config_calibre_split', 0) == \"on\"",
            "    calibre_db.update_config(config)",
            "    config.save()",
            "    return _db_configuration_result(None, gdrive_error)",
            "",
            "",
            "def _configuration_update_helper():",
            "    reboot_required = False",
            "    to_save = request.form.to_dict()",
            "    try:",
            "        reboot_required |= _config_int(to_save, \"config_port\")",
            "        reboot_required |= _config_string(to_save, \"config_trustedhosts\")",
            "        reboot_required |= _config_string(to_save, \"config_keyfile\")",
            "        if config.config_keyfile and not os.path.isfile(config.config_keyfile):",
            "            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        reboot_required |= _config_string(to_save, \"config_certfile\")",
            "        if config.config_certfile and not os.path.isfile(config.config_certfile):",
            "            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))",
            "",
            "        _config_checkbox_int(to_save, \"config_uploading\")",
            "        _config_checkbox_int(to_save, \"config_unicode_filename\")",
            "        _config_checkbox_int(to_save, \"config_embed_metadata\")",
            "        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case",
            "        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")",
            "                            and config.config_login_type == constants.LOGIN_LDAP)",
            "        _config_checkbox_int(to_save, \"config_public_reg\")",
            "        _config_checkbox_int(to_save, \"config_register_email\")",
            "        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")",
            "        _config_int(to_save, \"config_external_port\")",
            "        _config_checkbox_int(to_save, \"config_kobo_proxy\")",
            "",
            "        if \"config_upload_formats\" in to_save:",
            "            to_save[\"config_upload_formats\"] = ','.join(",
            "                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))",
            "            _config_string(to_save, \"config_upload_formats\")",
            "            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')",
            "",
            "        _config_string(to_save, \"config_calibre\")",
            "        _config_string(to_save, \"config_binariesdir\")",
            "        _config_string(to_save, \"config_kepubifypath\")",
            "        if \"config_binariesdir\" in to_save:",
            "            calibre_status = helper.check_calibre(config.config_binariesdir)",
            "            if calibre_status:",
            "                return _configuration_result(calibre_status)",
            "            to_save[\"config_converterpath\"] = get_calibre_binarypath(\"ebook-convert\")",
            "            _config_string(to_save, \"config_converterpath\")",
            "",
            "        reboot_required |= _config_int(to_save, \"config_login_type\")",
            "",
            "        # LDAP configurator",
            "        if config.config_login_type == constants.LOGIN_LDAP:",
            "            reboot, message = _configuration_ldap_helper(to_save)",
            "            if message:",
            "                return message",
            "            reboot_required |= reboot",
            "",
            "        # Remote login configuration",
            "        _config_checkbox(to_save, \"config_remote_login\")",
            "        if not config.config_remote_login:",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()",
            "",
            "        # Goodreads configuration",
            "        _config_checkbox(to_save, \"config_use_goodreads\")",
            "        _config_string(to_save, \"config_goodreads_api_key\")",
            "        if services.goodreads_support:",
            "            services.goodreads_support.connect(config.config_goodreads_api_key,",
            "                                               config.config_use_goodreads)",
            "",
            "        _config_int(to_save, \"config_updatechannel\")",
            "",
            "        # Reverse proxy login configuration",
            "        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")",
            "        _config_string(to_save, \"config_reverse_proxy_login_header_name\")",
            "",
            "        # OAuth configuration",
            "        if config.config_login_type == constants.LOGIN_OAUTH:",
            "            reboot_required |= _configuration_oauth_helper(to_save)",
            "",
            "        # logfile configuration",
            "        reboot, message = _configuration_logfile_helper(to_save)",
            "        if message:",
            "            return message",
            "        reboot_required |= reboot",
            "",
            "        # security configuration",
            "        _config_checkbox(to_save, \"config_password_policy\")",
            "        _config_checkbox(to_save, \"config_password_number\")",
            "        _config_checkbox(to_save, \"config_password_lower\")",
            "        _config_checkbox(to_save, \"config_password_upper\")",
            "        _config_checkbox(to_save, \"config_password_character\")",
            "        _config_checkbox(to_save, \"config_password_special\")",
            "        if 0 < int(to_save.get(\"config_password_min_length\", \"0\")) < 41:",
            "            _config_int(to_save, \"config_password_min_length\")",
            "        else:",
            "            return _configuration_result(_('Password length has to be between 1 and 40'))",
            "        reboot_required |= _config_int(to_save, \"config_session\")",
            "        reboot_required |= _config_checkbox(to_save, \"config_ratelimiter\")",
            "        reboot_required |= _config_string(to_save, \"config_limiter_uri\")",
            "        reboot_required |= _config_string(to_save, \"config_limiter_options\")",
            "",
            "        # Rarfile Content configuration",
            "        _config_string(to_save, \"config_rarfile_location\")",
            "        if \"config_rarfile_location\" in to_save:",
            "            unrar_status = helper.check_unrar(config.config_rarfile_location)",
            "            if unrar_status:",
            "                return _configuration_result(unrar_status)",
            "    except (OperationalError, InvalidRequestError) as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        _configuration_result(_(\"Oops! Database Error: %(error)s.\", error=e.orig))",
            "",
            "    config.save()",
            "    if reboot_required:",
            "        web_server.stop(True)",
            "",
            "    return _configuration_result(None, reboot_required)",
            "",
            "",
            "def _configuration_result(error_flash=None, reboot=False):",
            "    resp = {}",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        resp['result'] = [{'type': \"danger\", 'message': error_flash}]",
            "    else:",
            "        resp['result'] = [{'type': \"success\", 'message': _(\"Calibre-Web configuration updated\")}]",
            "    resp['reboot'] = reboot",
            "    resp['config_upload'] = config.config_upload_formats",
            "    return Response(json.dumps(resp), mimetype='application/json')",
            "",
            "",
            "def _db_configuration_result(error_flash=None, gdrive_error=None):",
            "    gdrive_authenticate = not is_gdrive_ready()",
            "    gdrivefolders = []",
            "    if not gdrive_error and config.config_use_google_drive:",
            "        gdrive_error = gdriveutils.get_error_text()",
            "    if gdrive_error and gdrive_support:",
            "        log.error(gdrive_error)",
            "        gdrive_error = _(gdrive_error)",
            "        flash(gdrive_error, category=\"error\")",
            "    else:",
            "        if not gdrive_authenticate and gdrive_support:",
            "            gdrivefolders = gdriveutils.listRootFolders()",
            "    if error_flash:",
            "        log.error(error_flash)",
            "        config.load()",
            "        flash(error_flash, category=\"error\")",
            "    elif request.method == \"POST\" and not gdrive_error:",
            "        flash(_(\"Database Settings updated\"), category=\"success\")",
            "",
            "    return render_title_template(\"config_db.html\",",
            "                                 config=config,",
            "                                 show_authenticate_google_drive=gdrive_authenticate,",
            "                                 gdriveError=gdrive_error,",
            "                                 gdrivefolders=gdrivefolders,",
            "                                 feature_support=feature_support,",
            "                                 title=_(\"Database Configuration\"), page=\"dbconfig\")",
            "",
            "",
            "def _handle_new_user(to_save, content, languages, translations, kobo_support):",
            "    content.default_language = to_save[\"default_language\"]",
            "    content.locale = to_save.get(\"locale\", content.locale)",
            "",
            "    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))",
            "    if \"show_detail_random\" in to_save:",
            "        content.sidebar_view |= constants.DETAIL_RANDOM",
            "",
            "    content.role = constants.selected_roles(to_save)",
            "    try:",
            "        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:",
            "            log.info(\"Missing entries on new user\")",
            "            raise Exception(_(\"Oops! Please complete all fields.\"))",
            "        content.password = generate_password_hash(helper.valid_password(to_save.get(\"password\", \"\")))",
            "        content.email = check_email(to_save[\"email\"])",
            "        # Query username, if not existing, change",
            "        content.name = check_username(to_save[\"name\"])",
            "        if to_save.get(\"kindle_mail\"):",
            "            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])",
            "        if config.config_public_reg and not check_valid_domain(content.email):",
            "            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))",
            "            raise Exception(_(\"E-mail is not from valid domain\"))",
            "    except Exception as ex:",
            "        flash(str(ex), category=\"error\")",
            "        return render_title_template(\"user_edit.html\", new_user=1, content=content,",
            "                                     config=config,",
            "                                     translations=translations,",
            "                                     languages=languages, title=_(\"Add new user\"), page=\"newuser\",",
            "                                     kobo_support=kobo_support, registered_oauth=oauth_check)",
            "    try:",
            "        content.allowed_tags = config.config_allowed_tags",
            "        content.denied_tags = config.config_denied_tags",
            "        content.allowed_column_value = config.config_allowed_column_value",
            "        content.denied_column_value = config.config_denied_column_value",
            "        # No default value for kobo sync shelf setting",
            "        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"",
            "        ub.session.add(content)",
            "        ub.session.commit()",
            "        flash(_(\"User '%(user)s' created\", user=content.name), category=\"success\")",
            "        log.debug(\"User {} created\".format(content.name))",
            "        return redirect(url_for('admin.admin'))",
            "    except IntegrityError:",
            "        ub.session.rollback()",
            "        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))",
            "        flash(_(\"Oops! An account already exists for this Email. or name.\"), category=\"error\")",
            "    except OperationalError as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "",
            "",
            "def _delete_user(content):",
            "    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                        ub.User.id != content.id).count():",
            "        if content.name != \"Guest\":",
            "            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status",
            "            # and user itself",
            "            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()",
            "            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()",
            "            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):",
            "                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()",
            "            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()",
            "            ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()",
            "            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()",
            "            ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()",
            "            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()",
            "            ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()",
            "            ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()",
            "            # delete KoboReadingState and all it's children",
            "            kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()",
            "            for kobo_entry in kobo_entries:",
            "                ub.session.delete(kobo_entry)",
            "            ub.session_commit()",
            "            log.info(\"User {} deleted\".format(content.name))",
            "            return _(\"User '%(nick)s' deleted\", nick=content.name)",
            "        else:",
            "            # log.warning(_(\"Can't delete Guest User\"))",
            "            raise Exception(_(\"Can't delete Guest User\"))",
            "    else:",
            "        # log.warning(\"No admin user remaining, can't delete user\")",
            "        raise Exception(_(\"No admin user remaining, can't delete user\"))",
            "",
            "",
            "def _handle_edit_user(to_save, content, languages, translations, kobo_support):",
            "    if to_save.get(\"delete\"):",
            "        try:",
            "            flash(_delete_user(content), category=\"success\")",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "        return redirect(url_for('admin.admin'))",
            "    else:",
            "        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,",
            "                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:",
            "            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))",
            "            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")",
            "            return redirect(url_for('admin.admin'))",
            "",
            "        val = [int(k[5:]) for k in to_save if k.startswith('show_')]",
            "        sidebar, __ = get_sidebar_config()",
            "        for element in sidebar:",
            "            value = element['visibility']",
            "            if value in val and not content.check_visibility(value):",
            "                content.sidebar_view |= value",
            "            elif value not in val and content.check_visibility(value):",
            "                content.sidebar_view &= ~value",
            "",
            "        if to_save.get(\"Show_detail_random\"):",
            "            content.sidebar_view |= constants.DETAIL_RANDOM",
            "        else:",
            "            content.sidebar_view &= ~constants.DETAIL_RANDOM",
            "",
            "        old_state = content.kobo_only_shelves_sync",
            "        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0",
            "        # 1 -> 0: nothing has to be done",
            "        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs",
            "        # which don't have to be synced have to be removed (added to Shelf archive)",
            "        if old_state == 0 and content.kobo_only_shelves_sync == 1:",
            "            kobo_sync_status.update_on_sync_shelfs(content.id)",
            "        if to_save.get(\"default_language\"):",
            "            content.default_language = to_save[\"default_language\"]",
            "        if to_save.get(\"locale\"):",
            "            content.locale = to_save[\"locale\"]",
            "        try:",
            "            anonymous = content.is_anonymous",
            "            content.role = constants.selected_roles(to_save)",
            "            if anonymous:",
            "                content.role |= constants.ROLE_ANONYMOUS",
            "            else:",
            "                content.role &= ~constants.ROLE_ANONYMOUS",
            "                if to_save.get(\"password\", \"\"):",
            "                    content.password = generate_password_hash(helper.valid_password(to_save.get(\"password\", \"\")))",
            "",
            "            new_email = valid_email(to_save.get(\"email\", content.email))",
            "            if not new_email:",
            "                raise Exception(_(\"Email can't be empty and has to be a valid Email\"))",
            "            if new_email != content.email:",
            "                content.email = check_email(new_email)",
            "            # Query username, if not existing, change",
            "            if to_save.get(\"name\", content.name) != content.name:",
            "                if to_save.get(\"name\") == \"Guest\":",
            "                    raise Exception(_(\"Guest Name can't be changed\"))",
            "                content.name = check_username(to_save[\"name\"])",
            "            if to_save.get(\"kindle_mail\") != content.kindle_mail:",
            "                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"",
            "        except Exception as ex:",
            "            log.error(ex)",
            "            flash(str(ex), category=\"error\")",
            "            return render_title_template(\"user_edit.html\",",
            "                                         translations=translations,",
            "                                         languages=languages,",
            "                                         mail_configured=config.get_mail_server_configured(),",
            "                                         kobo_support=kobo_support,",
            "                                         new_user=0,",
            "                                         content=content,",
            "                                         config=config,",
            "                                         registered_oauth=oauth_check,",
            "                                         title=_(\"Edit User %(nick)s\", nick=content.name),",
            "                                         page=\"edituser\")",
            "    try:",
            "        ub.session_commit()",
            "        flash(_(\"User '%(nick)s' updated\", nick=content.name), category=\"success\")",
            "    except IntegrityError as ex:",
            "        ub.session.rollback()",
            "        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))",
            "        flash(_(\"Oops! An unknown error occurred. Please try again later.\"), category=\"error\")",
            "    except OperationalError as e:",
            "        ub.session.rollback()",
            "        log.error_or_exception(\"Settings Database error: {}\".format(e))",
            "        flash(_(\"Oops! Database Error: %(error)s.\", error=e.orig), category=\"error\")",
            "    return \"\"",
            "",
            "",
            "def extract_user_data_from_field(user, field):",
            "    match = re.search(field + r\"=([@\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))",
            "",
            "",
            "def extract_dynamic_field_from_filter(user, filtr):",
            "    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)",
            "    if match:",
            "        return match.group(1)",
            "    else:",
            "        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)",
            "",
            "",
            "def extract_user_identifier(user, filtr):",
            "    dynamic_field = extract_dynamic_field_from_filter(user, filtr)",
            "    return extract_user_data_from_field(user, dynamic_field)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "482": [
                "edit_list_user"
            ],
            "948": [
                "check_valid_read_column"
            ],
            "956": [
                "check_valid_restricted_column"
            ],
            "1002": [
                "get_drives"
            ],
            "1003": [
                "get_drives"
            ],
            "1004": [
                "get_drives"
            ],
            "1005": [
                "get_drives"
            ],
            "1145": [
                "_configuration_oauth_helper"
            ],
            "1150": [
                "_configuration_oauth_helper"
            ],
            "1205": [
                "_configuration_ldap_helper"
            ],
            "1206": [
                "_configuration_ldap_helper"
            ],
            "1207": [
                "_configuration_ldap_helper"
            ],
            "1375": [
                "update_scheduledtasks"
            ],
            "1723": [
                "_db_configuration_update_helper"
            ]
        },
        "addLocation": []
    },
    "cps/babel.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " babel = Babel()"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " def get_locale():"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     # if a user is logged in, use the locale from the user settings"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     if current_user is not None and hasattr(current_user, \"locale\"):"
            }
        },
        "frontPatchFile": [
            "from babel import negotiate_locale",
            "from flask_babel import Babel, Locale",
            "from babel.core import UnknownLocaleError",
            "from flask import request",
            "from flask_login import current_user",
            "",
            "from . import logger",
            "",
            "log = logger.create()",
            "",
            "babel = Babel()",
            "",
            "def get_locale():",
            "    # if a user is logged in, use the locale from the user settings",
            "    if current_user is not None and hasattr(current_user, \"locale\"):",
            "        # if the account is the guest account bypass the config lang settings",
            "        if current_user.name != 'Guest':",
            "            return current_user.locale",
            "",
            "    preferred = list()",
            "    if request.accept_languages:",
            "        for x in request.accept_languages.values():",
            "            try:",
            "                preferred.append(str(Locale.parse(x.replace('-', '_'))))",
            "            except (UnknownLocaleError, ValueError) as e:",
            "                log.debug('Could not parse locale \"%s\": %s', x, e)",
            "",
            "    return negotiate_locale(preferred or ['en'], get_available_translations())",
            "",
            "",
            "def get_user_locale_language(user_language):",
            "    return Locale.parse(user_language).get_language_name(get_locale())",
            "",
            "",
            "def get_available_locale():",
            "    return [Locale('en')] + babel.list_translations()",
            "",
            "",
            "def get_available_translations():",
            "    return set(str(item) for item in get_available_locale())"
        ],
        "afterPatchFile": [
            "from babel import negotiate_locale",
            "from flask_babel import Babel, Locale",
            "from babel.core import UnknownLocaleError",
            "from flask import request",
            "from flask_login import current_user",
            "",
            "from . import logger",
            "",
            "log = logger.create()",
            "",
            "babel = Babel()",
            "",
            "",
            "def get_locale():",
            "    # if a user is logged in, use the locale from the user settings",
            "    if current_user is not None and hasattr(current_user, \"locale\"):",
            "        # if the account is the guest account bypass the config lang settings",
            "        if current_user.name != 'Guest':",
            "            return current_user.locale",
            "",
            "    preferred = list()",
            "    if request.accept_languages:",
            "        for x in request.accept_languages.values():",
            "            try:",
            "                preferred.append(str(Locale.parse(x.replace('-', '_'))))",
            "            except (UnknownLocaleError, ValueError) as e:",
            "                log.debug('Could not parse locale \"%s\": %s', x, e)",
            "",
            "    return negotiate_locale(preferred or ['en'], get_available_translations())",
            "",
            "",
            "def get_user_locale_language(user_language):",
            "    return Locale.parse(user_language).get_language_name(get_locale())",
            "",
            "",
            "def get_available_locale():",
            "    return [Locale('en')] + babel.list_translations()",
            "",
            "",
            "def get_available_translations():",
            "    return set(str(item) for item in get_available_locale())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "cps/clean_html.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " try:"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     # at least bleach 6.0 is needed -> incomplatible change from list arguments to set arguments"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     from bleach import clean as clean_html"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    from bleach.sanitizer import ALLOWED_TAGS"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    bleach = True"
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " except ImportError:"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     from nh3 import clean as clean_html"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    bleach = False"
            },
            "8": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " def clean_string(unsafe_text, book_id=0):"
            },
            "11": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     try:"
            },
            "12": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        safe_text = clean_html(unsafe_text)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        if bleach:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            allowed_tags = list(ALLOWED_TAGS)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            allowed_tags.extend(['p', 'span', 'div', 'pre'])"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            safe_text = clean_html(unsafe_text, tags=set(allowed_tags))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        else:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+            safe_text = clean_html(unsafe_text)"
            },
            "19": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     except ParserError as e:"
            },
            "20": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         log.error(\"Comments of book {} are corrupted: {}\".format(book_id, e))"
            },
            "21": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         safe_text = \"\""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from . import logger",
            "from lxml.etree import ParserError",
            "",
            "log = logger.create()",
            "",
            "try:",
            "    # at least bleach 6.0 is needed -> incomplatible change from list arguments to set arguments",
            "    from bleach import clean as clean_html",
            "except ImportError:",
            "    from nh3 import clean as clean_html",
            "",
            "",
            "def clean_string(unsafe_text, book_id=0):",
            "    try:",
            "        safe_text = clean_html(unsafe_text)",
            "    except ParserError as e:",
            "        log.error(\"Comments of book {} are corrupted: {}\".format(book_id, e))",
            "        safe_text = \"\"",
            "    except TypeError as e:",
            "        log.error(\"Comments can't be parsed, maybe 'lxml' is too new, try installing 'bleach': {}\".format(e))",
            "        safe_text = \"\"",
            "    return safe_text"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#    Copyright (C) 2018-2019 OzzieIsaacs",
            "#",
            "#  This program is free software: you can redistribute it and/or modify",
            "#  it under the terms of the GNU General Public License as published by",
            "#  the Free Software Foundation, either version 3 of the License, or",
            "#  (at your option) any later version.",
            "#",
            "#  This program is distributed in the hope that it will be useful,",
            "#  but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#  GNU General Public License for more details.",
            "#",
            "#  You should have received a copy of the GNU General Public License",
            "#  along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from . import logger",
            "from lxml.etree import ParserError",
            "",
            "log = logger.create()",
            "",
            "try:",
            "    # at least bleach 6.0 is needed -> incomplatible change from list arguments to set arguments",
            "    from bleach import clean as clean_html",
            "    from bleach.sanitizer import ALLOWED_TAGS",
            "    bleach = True",
            "except ImportError:",
            "    from nh3 import clean as clean_html",
            "    bleach = False",
            "",
            "",
            "def clean_string(unsafe_text, book_id=0):",
            "    try:",
            "        if bleach:",
            "            allowed_tags = list(ALLOWED_TAGS)",
            "            allowed_tags.extend(['p', 'span', 'div', 'pre'])",
            "            safe_text = clean_html(unsafe_text, tags=set(allowed_tags))",
            "        else:",
            "            safe_text = clean_html(unsafe_text)",
            "    except ParserError as e:",
            "        log.error(\"Comments of book {} are corrupted: {}\".format(book_id, e))",
            "        safe_text = \"\"",
            "    except TypeError as e:",
            "        log.error(\"Comments can't be parsed, maybe 'lxml' is too new, try installing 'bleach': {}\".format(e))",
            "        safe_text = \"\"",
            "    return safe_text"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [
                "clean_string"
            ]
        },
        "addLocation": []
    },
    "cps/cli.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " class CliParameter(object):"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    def __init__(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        self.user_credentials = None"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        self.ip_address = None"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        self.allow_localhost = None"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        self.reconnect_enable = None"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        self.memory_backend = None"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        self.dry_run = None"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        self.certfilepath = None"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        self.keyfilepath = None"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        self.gd_path = None"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        self.settings_path = None"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        self.logpath = None"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     def init(self):"
            },
            "17": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         self.arg_parser()"
            },
            "18": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "                                          prog='cps.py')"
            },
            "20": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         parser.add_argument('-p', metavar='path', help='path and name to settings db, e.g. /opt/cw.db')"
            },
            "21": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         parser.add_argument('-g', metavar='path', help='path and name to gdrive db, e.g. /opt/gd.db')"
            },
            "22": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser.add_argument('-c', metavar='path', help='path and name to SSL certfile, e.g. /opt/test.cert, '"
            },
            "23": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                       'works only in combination with keyfile')"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        parser.add_argument('-c', metavar='path', help='path and name to SSL certfile, '"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                                                       'e.g. /opt/test.cert, works only in combination with keyfile')"
            },
            "26": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         parser.add_argument('-k', metavar='path', help='path and name to SSL keyfile, e.g. /opt/test.key, '"
            },
            "27": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "                                                        'works only in combination with certfile')"
            },
            "28": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         parser.add_argument('-o', metavar='path', help='path and name Calibre-Web logfile')"
            },
            "29": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser.add_argument('-v', '--version', action='version', help='Shows version number and exits Calibre-Web',"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        parser.add_argument('-v', '--version', action='version', help='Shows version number '"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+                                                                      'and exits Calibre-Web',"
            },
            "32": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "                             version=version_info())"
            },
            "33": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         parser.add_argument('-i', metavar='ip-address', help='Server IP-Address to listen')"
            },
            "34": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser.add_argument('-m', action='store_true', help='Use Memory-backend as limiter backend, use this parameter in case of miss configured backend')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        parser.add_argument('-m', action='store_true',"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                            help='Use Memory-backend as limiter backend, use this parameter '"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                                 'in case of miss configured backend')"
            },
            "38": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         parser.add_argument('-s', metavar='user:pass',"
            },
            "39": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "                             help='Sets specific username to new password and exits Calibre-Web')"
            },
            "40": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser.add_argument('-f', action='store_true', help='Flag is depreciated and will be removed in next version')"
            },
            "41": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         parser.add_argument('-l', action='store_true', help='Allow loading covers from localhost')"
            },
            "42": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser.add_argument('-d', action='store_true', help='Dry run of updater to check file permissions in advance '"
            },
            "43": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                            'and exits Calibre-Web')"
            },
            "44": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser.add_argument('-r', action='store_true', help='Enable public database reconnect route under /reconnect')"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        parser.add_argument('-d', action='store_true', help='Dry run of updater to check file permissions '"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                                                            'in advance and exits Calibre-Web')"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        parser.add_argument('-r', action='store_true', help='Enable public database reconnect '"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                                                            'route under /reconnect')"
            },
            "49": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         args = parser.parse_args()"
            },
            "50": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.logpath = args.o or \"\""
            },
            "52": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         if self.user_credentials and \":\" not in self.user_credentials:"
            },
            "53": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             print(\"No valid 'username:password' format\")"
            },
            "54": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             sys.exit(3)"
            },
            "55": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "56": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if args.f:"
            },
            "57": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            print(\"Warning: -f flag is depreciated and will be removed in next version\")"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#   This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#     Copyright (C) 2018 OzzieIsaacs",
            "#",
            "#   This program is free software: you can redistribute it and/or modify",
            "#   it under the terms of the GNU General Public License as published by",
            "#   the Free Software Foundation, either version 3 of the License, or",
            "#   (at your option) any later version.",
            "#",
            "#   This program is distributed in the hope that it will be useful,",
            "#   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#   GNU General Public License for more details.",
            "#",
            "#   You should have received a copy of the GNU General Public License",
            "#   along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "import os",
            "import argparse",
            "import socket",
            "",
            "from .constants import CONFIG_DIR as _CONFIG_DIR",
            "from .constants import STABLE_VERSION as _STABLE_VERSION",
            "from .constants import NIGHTLY_VERSION as _NIGHTLY_VERSION",
            "from .constants import DEFAULT_SETTINGS_FILE, DEFAULT_GDRIVE_FILE",
            "",
            "",
            "def version_info():",
            "    if _NIGHTLY_VERSION[1].startswith('$Format'):",
            "        return \"Calibre-Web version: %s - unknown git-clone\" % _STABLE_VERSION['version'].replace(\"b\", \" Beta\")",
            "    return \"Calibre-Web version: %s -%s\" % (_STABLE_VERSION['version'].replace(\"b\", \" Beta\"), _NIGHTLY_VERSION[1])",
            "",
            "",
            "class CliParameter(object):",
            "",
            "    def init(self):",
            "        self.arg_parser()",
            "",
            "    def arg_parser(self):",
            "        parser = argparse.ArgumentParser(description='Calibre Web is a web app providing '",
            "                                                     'a interface for browsing, reading and downloading eBooks\\n',",
            "                                         prog='cps.py')",
            "        parser.add_argument('-p', metavar='path', help='path and name to settings db, e.g. /opt/cw.db')",
            "        parser.add_argument('-g', metavar='path', help='path and name to gdrive db, e.g. /opt/gd.db')",
            "        parser.add_argument('-c', metavar='path', help='path and name to SSL certfile, e.g. /opt/test.cert, '",
            "                                                       'works only in combination with keyfile')",
            "        parser.add_argument('-k', metavar='path', help='path and name to SSL keyfile, e.g. /opt/test.key, '",
            "                                                       'works only in combination with certfile')",
            "        parser.add_argument('-o', metavar='path', help='path and name Calibre-Web logfile')",
            "        parser.add_argument('-v', '--version', action='version', help='Shows version number and exits Calibre-Web',",
            "                            version=version_info())",
            "        parser.add_argument('-i', metavar='ip-address', help='Server IP-Address to listen')",
            "        parser.add_argument('-m', action='store_true', help='Use Memory-backend as limiter backend, use this parameter in case of miss configured backend')",
            "        parser.add_argument('-s', metavar='user:pass',",
            "                            help='Sets specific username to new password and exits Calibre-Web')",
            "        parser.add_argument('-f', action='store_true', help='Flag is depreciated and will be removed in next version')",
            "        parser.add_argument('-l', action='store_true', help='Allow loading covers from localhost')",
            "        parser.add_argument('-d', action='store_true', help='Dry run of updater to check file permissions in advance '",
            "                                                            'and exits Calibre-Web')",
            "        parser.add_argument('-r', action='store_true', help='Enable public database reconnect route under /reconnect')",
            "        args = parser.parse_args()",
            "",
            "        self.logpath = args.o or \"\"",
            "        self.settings_path = args.p or os.path.join(_CONFIG_DIR, DEFAULT_SETTINGS_FILE)",
            "        self.gd_path = args.g or os.path.join(_CONFIG_DIR, DEFAULT_GDRIVE_FILE)",
            "",
            "        if os.path.isdir(self.settings_path):",
            "            self.settings_path = os.path.join(self.settings_path, DEFAULT_SETTINGS_FILE)",
            "",
            "        if os.path.isdir(self.gd_path):",
            "            self.gd_path = os.path.join(self.gd_path, DEFAULT_GDRIVE_FILE)",
            "",
            "        # handle and check parameter for ssl encryption",
            "        self.certfilepath = None",
            "        self.keyfilepath = None",
            "        if args.c:",
            "            if os.path.isfile(args.c):",
            "                self.certfilepath = args.c",
            "            else:",
            "                print(\"Certfile path is invalid. Exiting...\")",
            "                sys.exit(1)",
            "",
            "        if args.c == \"\":",
            "            self.certfilepath = \"\"",
            "",
            "        if args.k:",
            "            if os.path.isfile(args.k):",
            "                self.keyfilepath = args.k",
            "            else:",
            "                print(\"Keyfile path is invalid. Exiting...\")",
            "                sys.exit(1)",
            "",
            "        if (args.k and not args.c) or (not args.k and args.c):",
            "            print(\"Certfile and Keyfile have to be used together. Exiting...\")",
            "            sys.exit(1)",
            "",
            "        if args.k == \"\":",
            "            self.keyfilepath = \"\"",
            "",
            "        # overwrite limiter backend",
            "        self.memory_backend = args.m or None",
            "        # dry run updater",
            "        self.dry_run = args.d or None",
            "        # enable reconnect endpoint for docker database reconnect",
            "        self.reconnect_enable = args.r or os.environ.get(\"CALIBRE_RECONNECT\", None)",
            "        # load covers from localhost",
            "        self.allow_localhost = args.l or os.environ.get(\"CALIBRE_LOCALHOST\", None)",
            "        # handle and check ip address argument",
            "        self.ip_address = args.i or None",
            "        if self.ip_address:",
            "            try:",
            "                # try to parse the given ip address with socket",
            "                if hasattr(socket, 'inet_pton'):",
            "                    if ':' in self.ip_address:",
            "                        socket.inet_pton(socket.AF_INET6, self.ip_address)",
            "                    else:",
            "                        socket.inet_pton(socket.AF_INET, self.ip_address)",
            "                else:",
            "                    # on Windows python < 3.4, inet_pton is not available",
            "                    # inet_atom only handles IPv4 addresses",
            "                    socket.inet_aton(self.ip_address)",
            "            except socket.error as err:",
            "                print(self.ip_address, ':', err)",
            "                sys.exit(1)",
            "",
            "        # handle and check user password argument",
            "        self.user_credentials = args.s or None",
            "        if self.user_credentials and \":\" not in self.user_credentials:",
            "            print(\"No valid 'username:password' format\")",
            "            sys.exit(3)",
            "",
            "        if args.f:",
            "            print(\"Warning: -f flag is depreciated and will be removed in next version\")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#   This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#     Copyright (C) 2018 OzzieIsaacs",
            "#",
            "#   This program is free software: you can redistribute it and/or modify",
            "#   it under the terms of the GNU General Public License as published by",
            "#   the Free Software Foundation, either version 3 of the License, or",
            "#   (at your option) any later version.",
            "#",
            "#   This program is distributed in the hope that it will be useful,",
            "#   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#   GNU General Public License for more details.",
            "#",
            "#   You should have received a copy of the GNU General Public License",
            "#   along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "import os",
            "import argparse",
            "import socket",
            "",
            "from .constants import CONFIG_DIR as _CONFIG_DIR",
            "from .constants import STABLE_VERSION as _STABLE_VERSION",
            "from .constants import NIGHTLY_VERSION as _NIGHTLY_VERSION",
            "from .constants import DEFAULT_SETTINGS_FILE, DEFAULT_GDRIVE_FILE",
            "",
            "",
            "def version_info():",
            "    if _NIGHTLY_VERSION[1].startswith('$Format'):",
            "        return \"Calibre-Web version: %s - unknown git-clone\" % _STABLE_VERSION['version'].replace(\"b\", \" Beta\")",
            "    return \"Calibre-Web version: %s -%s\" % (_STABLE_VERSION['version'].replace(\"b\", \" Beta\"), _NIGHTLY_VERSION[1])",
            "",
            "",
            "class CliParameter(object):",
            "",
            "    def __init__(self):",
            "        self.user_credentials = None",
            "        self.ip_address = None",
            "        self.allow_localhost = None",
            "        self.reconnect_enable = None",
            "        self.memory_backend = None",
            "        self.dry_run = None",
            "        self.certfilepath = None",
            "        self.keyfilepath = None",
            "        self.gd_path = None",
            "        self.settings_path = None",
            "        self.logpath = None",
            "",
            "    def init(self):",
            "        self.arg_parser()",
            "",
            "    def arg_parser(self):",
            "        parser = argparse.ArgumentParser(description='Calibre Web is a web app providing '",
            "                                                     'a interface for browsing, reading and downloading eBooks\\n',",
            "                                         prog='cps.py')",
            "        parser.add_argument('-p', metavar='path', help='path and name to settings db, e.g. /opt/cw.db')",
            "        parser.add_argument('-g', metavar='path', help='path and name to gdrive db, e.g. /opt/gd.db')",
            "        parser.add_argument('-c', metavar='path', help='path and name to SSL certfile, '",
            "                                                       'e.g. /opt/test.cert, works only in combination with keyfile')",
            "        parser.add_argument('-k', metavar='path', help='path and name to SSL keyfile, e.g. /opt/test.key, '",
            "                                                       'works only in combination with certfile')",
            "        parser.add_argument('-o', metavar='path', help='path and name Calibre-Web logfile')",
            "        parser.add_argument('-v', '--version', action='version', help='Shows version number '",
            "                                                                      'and exits Calibre-Web',",
            "                            version=version_info())",
            "        parser.add_argument('-i', metavar='ip-address', help='Server IP-Address to listen')",
            "        parser.add_argument('-m', action='store_true',",
            "                            help='Use Memory-backend as limiter backend, use this parameter '",
            "                                 'in case of miss configured backend')",
            "        parser.add_argument('-s', metavar='user:pass',",
            "                            help='Sets specific username to new password and exits Calibre-Web')",
            "        parser.add_argument('-l', action='store_true', help='Allow loading covers from localhost')",
            "        parser.add_argument('-d', action='store_true', help='Dry run of updater to check file permissions '",
            "                                                            'in advance and exits Calibre-Web')",
            "        parser.add_argument('-r', action='store_true', help='Enable public database reconnect '",
            "                                                            'route under /reconnect')",
            "        args = parser.parse_args()",
            "",
            "        self.logpath = args.o or \"\"",
            "        self.settings_path = args.p or os.path.join(_CONFIG_DIR, DEFAULT_SETTINGS_FILE)",
            "        self.gd_path = args.g or os.path.join(_CONFIG_DIR, DEFAULT_GDRIVE_FILE)",
            "",
            "        if os.path.isdir(self.settings_path):",
            "            self.settings_path = os.path.join(self.settings_path, DEFAULT_SETTINGS_FILE)",
            "",
            "        if os.path.isdir(self.gd_path):",
            "            self.gd_path = os.path.join(self.gd_path, DEFAULT_GDRIVE_FILE)",
            "",
            "        # handle and check parameter for ssl encryption",
            "        self.certfilepath = None",
            "        self.keyfilepath = None",
            "        if args.c:",
            "            if os.path.isfile(args.c):",
            "                self.certfilepath = args.c",
            "            else:",
            "                print(\"Certfile path is invalid. Exiting...\")",
            "                sys.exit(1)",
            "",
            "        if args.c == \"\":",
            "            self.certfilepath = \"\"",
            "",
            "        if args.k:",
            "            if os.path.isfile(args.k):",
            "                self.keyfilepath = args.k",
            "            else:",
            "                print(\"Keyfile path is invalid. Exiting...\")",
            "                sys.exit(1)",
            "",
            "        if (args.k and not args.c) or (not args.k and args.c):",
            "            print(\"Certfile and Keyfile have to be used together. Exiting...\")",
            "            sys.exit(1)",
            "",
            "        if args.k == \"\":",
            "            self.keyfilepath = \"\"",
            "",
            "        # overwrite limiter backend",
            "        self.memory_backend = args.m or None",
            "        # dry run updater",
            "        self.dry_run = args.d or None",
            "        # enable reconnect endpoint for docker database reconnect",
            "        self.reconnect_enable = args.r or os.environ.get(\"CALIBRE_RECONNECT\", None)",
            "        # load covers from localhost",
            "        self.allow_localhost = args.l or os.environ.get(\"CALIBRE_LOCALHOST\", None)",
            "        # handle and check ip address argument",
            "        self.ip_address = args.i or None",
            "        if self.ip_address:",
            "            try:",
            "                # try to parse the given ip address with socket",
            "                if hasattr(socket, 'inet_pton'):",
            "                    if ':' in self.ip_address:",
            "                        socket.inet_pton(socket.AF_INET6, self.ip_address)",
            "                    else:",
            "                        socket.inet_pton(socket.AF_INET, self.ip_address)",
            "                else:",
            "                    # on Windows python < 3.4, inet_pton is not available",
            "                    # inet_atom only handles IPv4 addresses",
            "                    socket.inet_aton(self.ip_address)",
            "            except socket.error as err:",
            "                print(self.ip_address, ':', err)",
            "                sys.exit(1)",
            "",
            "        # handle and check user password argument",
            "        self.user_credentials = args.s or None",
            "        if self.user_credentials and \":\" not in self.user_credentials:",
            "            print(\"No valid 'username:password' format\")",
            "            sys.exit(3)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "47": [
                "CliParameter",
                "arg_parser"
            ],
            "48": [
                "CliParameter",
                "arg_parser"
            ],
            "52": [
                "CliParameter",
                "arg_parser"
            ],
            "55": [
                "CliParameter",
                "arg_parser"
            ],
            "58": [
                "CliParameter",
                "arg_parser"
            ],
            "60": [
                "CliParameter",
                "arg_parser"
            ],
            "61": [
                "CliParameter",
                "arg_parser"
            ],
            "62": [
                "CliParameter",
                "arg_parser"
            ],
            "133": [
                "CliParameter",
                "arg_parser"
            ],
            "134": [
                "CliParameter",
                "arg_parser"
            ],
            "135": [
                "CliParameter",
                "arg_parser"
            ]
        },
        "addLocation": [
            "cps.admin",
            "cps.cli.CliParameter.self",
            "cps.cli.CliParameter"
        ]
    },
    "cps/config_sql.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     flask_session_key = Column(BLOB, default=b\"\")"
            },
            "1": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     def __init__(self, key):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        super().__init__()"
            },
            "4": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         self.flask_session_key = key"
            },
            "5": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     config_random_books = Column(Integer, default=4)"
            },
            "8": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     config_authors_max = Column(Integer, default=0)"
            },
            "9": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     config_read_column = Column(Integer, default=0)"
            },
            "10": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    config_title_regex = Column(String, default=r'^(A|The|An|Der|Die|Das|Den|Ein|Eine|Einen|Dem|Des|Einem|Eines|Le|La|Les|L\\'|Un|Une)\\s+')    "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    config_title_regex = Column(String,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                                default=r'^(A|The|An|Der|Die|Das|Den|Ein|Eine'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                                        r'|Einen|Dem|Des|Einem|Eines|Le|La|Les|L\\'|Un|Une)\\s+')"
            },
            "14": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     config_theme = Column(Integer, default=0)"
            },
            "15": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     config_log_level = Column(SmallInteger, default=logger.DEFAULT_LOG_LEVEL)"
            },
            "17": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " class ConfigSQL(object):"
            },
            "18": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "     # pylint: disable=no-member"
            },
            "19": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "     def __init__(self):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        '''self.config_calibre_uuid = None"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        self.config_calibre_split_dir = None"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        self.dirty = None"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        self.config_logfile = None"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        self.config_upload_formats = None"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        self.mail_gmail_token = None"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        self.mail_server_type = None"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        self.mail_server = None"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        self.config_log_level = None"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        self.config_allowed_column_value = None"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        self.config_denied_column_value = None"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        self.config_allowed_tags = None"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        self.config_denied_tags = None"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        self.config_default_show = None"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        self.config_default_role = None"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        self.config_keyfile = None"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        self.config_certfile = None"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        self.config_rarfile_location = None"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+        self.config_kepubifypath = None"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        self.config_binariesdir = None'''"
            },
            "40": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         self.__dict__[\"dirty\"] = list()"
            },
            "41": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 205,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "     def init_config(self, session, secret_key, cli):"
            },
            "43": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 214,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         change = False"
            },
            "45": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 216,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.config_binariesdir == None: # pylint: disable=access-member-before-definition"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        if self.config_binariesdir is None:"
            },
            "48": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             change = True"
            },
            "49": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "             self.config_binariesdir = autodetect_calibre_binaries()"
            },
            "50": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "             self.config_converterpath = autodetect_converter_binary(self.config_binariesdir)"
            },
            "51": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.config_kepubifypath == None:  # pylint: disable=access-member-before-definition"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        if self.config_kepubifypath is None:"
            },
            "54": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "             change = True"
            },
            "55": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "             self.config_kepubifypath = autodetect_kepubify_binary()"
            },
            "56": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.config_rarfile_location == None:  # pylint: disable=access-member-before-definition"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        if self.config_rarfile_location is None:"
            },
            "59": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "             change = True"
            },
            "60": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "             self.config_rarfile_location = autodetect_unrar_binary()"
            },
            "61": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         if change:"
            },
            "62": {
                "beforePatchRowNumber": 429,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "                 {_Settings.mail_password_e: crypter.encrypt(settings.mail_password.encode())})"
            },
            "63": {
                "beforePatchRowNumber": 430,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "         if settings.config_ldap_serv_password:"
            },
            "64": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "             session.query(_Settings).update("
            },
            "65": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                {_Settings.config_ldap_serv_password_e:"
            },
            "66": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     crypter.encrypt(settings.config_ldap_serv_password.encode())})"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+                {_Settings.config_ldap_serv_password_e: crypter.encrypt(settings.config_ldap_serv_password.encode())})"
            },
            "68": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "         session.commit()"
            },
            "69": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 457,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 458,
                "PatchRowcode": " "
            },
            "71": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 568,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 569,
                "PatchRowcode": " def get_flask_session_key(_session):"
            },
            "73": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 570,
                "PatchRowcode": "     flask_settings = _session.query(_Flask_Settings).one_or_none()"
            },
            "74": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if flask_settings == None:"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 571,
                "PatchRowcode": "+    if flask_settings is None:"
            },
            "76": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "         flask_settings = _Flask_Settings(os.urandom(32))"
            },
            "77": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "         _session.add(flask_settings)"
            },
            "78": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "         _session.commit()"
            },
            "79": {
                "beforePatchRowNumber": 557,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "     key_file = os.path.join(key_path, \".key\")"
            },
            "80": {
                "beforePatchRowNumber": 558,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "     generate = True"
            },
            "81": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "     error = \"\""
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 582,
                "PatchRowcode": "+    key = None"
            },
            "83": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": 583,
                "PatchRowcode": "     if os.path.exists(key_file) and os.path.getsize(key_file) > 32:"
            },
            "84": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 584,
                "PatchRowcode": "         with open(key_file, \"rb\") as f:"
            },
            "85": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "             key = f.read()"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#   This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#     Copyright (C) 2019 OzzieIsaacs, pwr",
            "#",
            "#   This program is free software: you can redistribute it and/or modify",
            "#   it under the terms of the GNU General Public License as published by",
            "#   the Free Software Foundation, either version 3 of the License, or",
            "#   (at your option) any later version.",
            "#",
            "#   This program is distributed in the hope that it will be useful,",
            "#   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#   GNU General Public License for more details.",
            "#",
            "#   You should have received a copy of the GNU General Public License",
            "#   along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import sys",
            "import json",
            "",
            "from sqlalchemy import Column, String, Integer, SmallInteger, Boolean, BLOB, JSON",
            "from sqlalchemy.exc import OperationalError",
            "from sqlalchemy.sql.expression import text",
            "from sqlalchemy import exists",
            "from cryptography.fernet import Fernet",
            "import cryptography.exceptions",
            "from base64 import urlsafe_b64decode",
            "try:",
            "    # Compatibility with sqlalchemy 2.0",
            "    from sqlalchemy.orm import declarative_base",
            "except ImportError:",
            "    from sqlalchemy.ext.declarative import declarative_base",
            "",
            "from . import constants, logger",
            "from .subproc_wrapper import process_wait",
            "",
            "",
            "log = logger.create()",
            "_Base = declarative_base()",
            "",
            "",
            "class _Flask_Settings(_Base):",
            "    __tablename__ = 'flask_settings'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    flask_session_key = Column(BLOB, default=b\"\")",
            "",
            "    def __init__(self, key):",
            "        self.flask_session_key = key",
            "",
            "",
            "# Baseclass for representing settings in app.db with email server settings and Calibre database settings",
            "# (application settings)",
            "class _Settings(_Base):",
            "    __tablename__ = 'settings'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    mail_server = Column(String, default=constants.DEFAULT_MAIL_SERVER)",
            "    mail_port = Column(Integer, default=25)",
            "    mail_use_ssl = Column(SmallInteger, default=0)",
            "    mail_login = Column(String, default='mail@example.com')",
            "    mail_password_e = Column(String)",
            "    mail_password = Column(String)",
            "    mail_from = Column(String, default='automailer <mail@example.com>')",
            "    mail_size = Column(Integer, default=25*1024*1024)",
            "    mail_server_type = Column(SmallInteger, default=0)",
            "    mail_gmail_token = Column(JSON, default={})",
            "",
            "    config_calibre_dir = Column(String)",
            "    config_calibre_uuid = Column(String)",
            "    config_calibre_split = Column(Boolean, default=False)",
            "    config_calibre_split_dir = Column(String)",
            "    config_port = Column(Integer, default=constants.DEFAULT_PORT)",
            "    config_external_port = Column(Integer, default=constants.DEFAULT_PORT)",
            "    config_certfile = Column(String)",
            "    config_keyfile = Column(String)",
            "    config_trustedhosts = Column(String, default='')",
            "    config_calibre_web_title = Column(String, default='Calibre-Web')",
            "    config_books_per_page = Column(Integer, default=60)",
            "    config_random_books = Column(Integer, default=4)",
            "    config_authors_max = Column(Integer, default=0)",
            "    config_read_column = Column(Integer, default=0)",
            "    config_title_regex = Column(String, default=r'^(A|The|An|Der|Die|Das|Den|Ein|Eine|Einen|Dem|Des|Einem|Eines|Le|La|Les|L\\'|Un|Une)\\s+')    ",
            "    config_theme = Column(Integer, default=0)",
            "",
            "    config_log_level = Column(SmallInteger, default=logger.DEFAULT_LOG_LEVEL)",
            "    config_logfile = Column(String, default=logger.DEFAULT_LOG_FILE)",
            "    config_access_log = Column(SmallInteger, default=0)",
            "    config_access_logfile = Column(String, default=logger.DEFAULT_ACCESS_LOG)",
            "",
            "    config_uploading = Column(SmallInteger, default=0)",
            "    config_anonbrowse = Column(SmallInteger, default=0)",
            "    config_public_reg = Column(SmallInteger, default=0)",
            "    config_remote_login = Column(Boolean, default=False)",
            "    config_kobo_sync = Column(Boolean, default=False)",
            "",
            "    config_default_role = Column(SmallInteger, default=0)",
            "    config_default_show = Column(SmallInteger, default=constants.ADMIN_USER_SIDEBAR)",
            "    config_default_language = Column(String(3), default=\"all\")",
            "    config_default_locale = Column(String(2), default=\"en\")",
            "    config_columns_to_ignore = Column(String)",
            "",
            "    config_denied_tags = Column(String, default=\"\")",
            "    config_allowed_tags = Column(String, default=\"\")",
            "    config_restricted_column = Column(SmallInteger, default=0)",
            "    config_denied_column_value = Column(String, default=\"\")",
            "    config_allowed_column_value = Column(String, default=\"\")",
            "",
            "    config_use_google_drive = Column(Boolean, default=False)",
            "    config_google_drive_folder = Column(String)",
            "    config_google_drive_watch_changes_response = Column(JSON, default={})",
            "",
            "    config_use_goodreads = Column(Boolean, default=False)",
            "    config_goodreads_api_key = Column(String)",
            "    config_register_email = Column(Boolean, default=False)",
            "    config_login_type = Column(Integer, default=0)",
            "",
            "    config_kobo_proxy = Column(Boolean, default=False)",
            "",
            "    config_ldap_provider_url = Column(String, default='example.org')",
            "    config_ldap_port = Column(SmallInteger, default=389)",
            "    config_ldap_authentication = Column(SmallInteger, default=constants.LDAP_AUTH_SIMPLE)",
            "    config_ldap_serv_username = Column(String, default='cn=admin,dc=example,dc=org')",
            "    config_ldap_serv_password_e = Column(String)",
            "    config_ldap_serv_password = Column(String)",
            "    config_ldap_encryption = Column(SmallInteger, default=0)",
            "    config_ldap_cacert_path = Column(String, default=\"\")",
            "    config_ldap_cert_path = Column(String, default=\"\")",
            "    config_ldap_key_path = Column(String, default=\"\")",
            "    config_ldap_dn = Column(String, default='dc=example,dc=org')",
            "    config_ldap_user_object = Column(String, default='uid=%s')",
            "    config_ldap_member_user_object = Column(String, default='')",
            "    config_ldap_openldap = Column(Boolean, default=True)",
            "    config_ldap_group_object_filter = Column(String, default='(&(objectclass=posixGroup)(cn=%s))')",
            "    config_ldap_group_members_field = Column(String, default='memberUid')",
            "    config_ldap_group_name = Column(String, default='calibreweb')",
            "",
            "    config_kepubifypath = Column(String, default=None)",
            "    config_converterpath = Column(String, default=None)",
            "    config_binariesdir = Column(String, default=None)",
            "    config_calibre = Column(String)",
            "    config_rarfile_location = Column(String, default=None)",
            "    config_upload_formats = Column(String, default=','.join(constants.EXTENSIONS_UPLOAD))",
            "    config_unicode_filename = Column(Boolean, default=False)",
            "    config_embed_metadata = Column(Boolean, default=True)",
            "",
            "    config_updatechannel = Column(Integer, default=constants.UPDATE_STABLE)",
            "",
            "    config_reverse_proxy_login_header_name = Column(String)",
            "    config_allow_reverse_proxy_header_login = Column(Boolean, default=False)",
            "",
            "    schedule_start_time = Column(Integer, default=4)",
            "    schedule_duration = Column(Integer, default=10)",
            "    schedule_generate_book_covers = Column(Boolean, default=False)",
            "    schedule_generate_series_covers = Column(Boolean, default=False)",
            "    schedule_reconnect = Column(Boolean, default=False)",
            "    schedule_metadata_backup = Column(Boolean, default=False)",
            "",
            "    config_password_policy = Column(Boolean, default=True)",
            "    config_password_min_length = Column(Integer, default=8)",
            "    config_password_number = Column(Boolean, default=True)",
            "    config_password_lower = Column(Boolean, default=True)",
            "    config_password_upper = Column(Boolean, default=True)",
            "    config_password_character = Column(Boolean, default=True)",
            "    config_password_special = Column(Boolean, default=True)",
            "    config_session = Column(Integer, default=1)",
            "    config_ratelimiter = Column(Boolean, default=True)",
            "    config_limiter_uri = Column(String, default=\"\")",
            "    config_limiter_options = Column(String, default=\"\")",
            "",
            "    def __repr__(self):",
            "        return self.__class__.__name__",
            "",
            "",
            "# Class holds all application specific settings in calibre-web",
            "class ConfigSQL(object):",
            "    # pylint: disable=no-member",
            "    def __init__(self):",
            "        self.__dict__[\"dirty\"] = list()",
            "",
            "    def init_config(self, session, secret_key, cli):",
            "        self._session = session",
            "        self._settings = None",
            "        self.db_configured = None",
            "        self.config_calibre_dir = None",
            "        self._fernet = Fernet(secret_key)",
            "        self.cli = cli",
            "        self.load()",
            "",
            "        change = False",
            "",
            "        if self.config_binariesdir == None: # pylint: disable=access-member-before-definition",
            "            change = True",
            "            self.config_binariesdir = autodetect_calibre_binaries()",
            "            self.config_converterpath = autodetect_converter_binary(self.config_binariesdir)",
            "",
            "        if self.config_kepubifypath == None:  # pylint: disable=access-member-before-definition",
            "            change = True",
            "            self.config_kepubifypath = autodetect_kepubify_binary()",
            "",
            "        if self.config_rarfile_location == None:  # pylint: disable=access-member-before-definition",
            "            change = True",
            "            self.config_rarfile_location = autodetect_unrar_binary()",
            "        if change:",
            "            self.save()",
            "",
            "    def _read_from_storage(self):",
            "        if self._settings is None:",
            "            log.debug(\"_ConfigSQL._read_from_storage\")",
            "            self._settings = self._session.query(_Settings).first()",
            "        return self._settings",
            "",
            "    def get_config_certfile(self):",
            "        if self.cli.certfilepath:",
            "            return self.cli.certfilepath",
            "        if self.cli.certfilepath == \"\":",
            "            return None",
            "        return self.config_certfile",
            "",
            "    def get_config_keyfile(self):",
            "        if self.cli.keyfilepath:",
            "            return self.cli.keyfilepath",
            "        if self.cli.certfilepath == \"\":",
            "            return None",
            "        return self.config_keyfile",
            "",
            "    def get_config_ipaddress(self):",
            "        return self.cli.ip_address or \"\"",
            "",
            "    def _has_role(self, role_flag):",
            "        return constants.has_flag(self.config_default_role, role_flag)",
            "",
            "    def role_admin(self):",
            "        return self._has_role(constants.ROLE_ADMIN)",
            "",
            "    def role_download(self):",
            "        return self._has_role(constants.ROLE_DOWNLOAD)",
            "",
            "    def role_viewer(self):",
            "        return self._has_role(constants.ROLE_VIEWER)",
            "",
            "    def role_upload(self):",
            "        return self._has_role(constants.ROLE_UPLOAD)",
            "",
            "    def role_edit(self):",
            "        return self._has_role(constants.ROLE_EDIT)",
            "",
            "    def role_passwd(self):",
            "        return self._has_role(constants.ROLE_PASSWD)",
            "",
            "    def role_edit_shelfs(self):",
            "        return self._has_role(constants.ROLE_EDIT_SHELFS)",
            "",
            "    def role_delete_books(self):",
            "        return self._has_role(constants.ROLE_DELETE_BOOKS)",
            "",
            "    def show_element_new_user(self, value):",
            "        return constants.has_flag(self.config_default_show, value)",
            "",
            "    def show_detail_random(self):",
            "        return self.show_element_new_user(constants.DETAIL_RANDOM)",
            "",
            "    def list_denied_tags(self):",
            "        mct = self.config_denied_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_tags(self):",
            "        mct = self.config_allowed_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_denied_column_values(self):",
            "        mct = self.config_denied_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_column_values(self):",
            "        mct = self.config_allowed_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def get_log_level(self):",
            "        return logger.get_level_name(self.config_log_level)",
            "",
            "    def get_mail_settings(self):",
            "        return {k: v for k, v in self.__dict__.items() if k.startswith('mail_')}",
            "",
            "    def get_mail_server_configured(self):",
            "        return bool((self.mail_server != constants.DEFAULT_MAIL_SERVER and self.mail_server_type == 0)",
            "                    or (self.mail_gmail_token != {} and self.mail_server_type == 1))",
            "",
            "    def get_scheduled_task_settings(self):",
            "        return {k: v for k, v in self.__dict__.items() if k.startswith('schedule_')}",
            "",
            "    def set_from_dictionary(self, dictionary, field, convertor=None, default=None, encode=None):",
            "        \"\"\"Possibly updates a field of this object.",
            "        The new value, if present, is grabbed from the given dictionary, and optionally passed through a convertor.",
            "",
            "        :returns: `True` if the field has changed value",
            "        \"\"\"",
            "        new_value = dictionary.get(field, default)",
            "        if new_value is None:",
            "            return False",
            "",
            "        if field not in self.__dict__:",
            "            log.warning(\"_ConfigSQL trying to set unknown field '%s' = %r\", field, new_value)",
            "            return False",
            "",
            "        if convertor is not None:",
            "            if encode:",
            "                new_value = convertor(new_value.encode(encode))",
            "            else:",
            "                new_value = convertor(new_value)",
            "",
            "        current_value = self.__dict__.get(field)",
            "        if current_value == new_value:",
            "            return False",
            "",
            "        setattr(self, field, new_value)",
            "        return True",
            "",
            "    def to_dict(self):",
            "        storage = {}",
            "        for k, v in self.__dict__.items():",
            "            if k[0] != '_' and not k.endswith(\"_e\") and not k == \"cli\":",
            "                storage[k] = v",
            "        return storage",
            "",
            "    def load(self):",
            "        \"\"\"Load all configuration values from the underlying storage.\"\"\"",
            "        s = self._read_from_storage()  # type: _Settings",
            "        for k, v in s.__dict__.items():",
            "            if k[0] != '_':",
            "                if v is None:",
            "                    # if the storage column has no value, apply the (possible) default",
            "                    column = s.__class__.__dict__.get(k)",
            "                    if column.default is not None:",
            "                        v = column.default.arg",
            "                if k.endswith(\"_e\") and v is not None:",
            "                    try:",
            "                        setattr(self, k, self._fernet.decrypt(v).decode())",
            "                    except cryptography.fernet.InvalidToken:",
            "                        setattr(self, k, \"\")",
            "                else:",
            "                    setattr(self, k, v)",
            "",
            "        have_metadata_db = bool(self.config_calibre_dir)",
            "        if have_metadata_db:",
            "            db_file = os.path.join(self.config_calibre_dir, 'metadata.db')",
            "            have_metadata_db = os.path.isfile(db_file)",
            "        self.db_configured = have_metadata_db",
            "        constants.EXTENSIONS_UPLOAD = [x.lstrip().rstrip().lower() for x in self.config_upload_formats.split(',')]",
            "        from . import cli_param",
            "        if os.environ.get('FLASK_DEBUG'):",
            "            logfile = logger.setup(logger.LOG_TO_STDOUT, logger.logging.DEBUG)",
            "        else:",
            "            # pylint: disable=access-member-before-definition",
            "            logfile = logger.setup(cli_param.logpath or self.config_logfile, self.config_log_level)",
            "        if logfile != os.path.abspath(self.config_logfile):",
            "            if logfile != os.path.abspath(cli_param.logpath):",
            "                log.warning(\"Log path %s not valid, falling back to default\", self.config_logfile)",
            "            self.config_logfile = logfile",
            "            s.config_logfile = logfile",
            "            self._session.merge(s)",
            "            try:",
            "                self._session.commit()",
            "            except OperationalError as e:",
            "                log.error('Database error: %s', e)",
            "                self._session.rollback()",
            "        self.__dict__[\"dirty\"] = list()",
            "",
            "    def save(self):",
            "        \"\"\"Apply all configuration values to the underlying storage.\"\"\"",
            "        s = self._read_from_storage()  # type: _Settings",
            "",
            "        for k in self.dirty:",
            "            if k[0] == '_':",
            "                continue",
            "            if hasattr(s, k):",
            "                if k.endswith(\"_e\"):",
            "                    setattr(s, k, self._fernet.encrypt(self.__dict__[k].encode()))",
            "                else:",
            "                    setattr(s, k, self.__dict__[k])",
            "",
            "        log.debug(\"_ConfigSQL updating storage\")",
            "        self._session.merge(s)",
            "        try:",
            "            self._session.commit()",
            "        except OperationalError as e:",
            "            log.error('Database error: %s', e)",
            "            self._session.rollback()",
            "        self.load()",
            "",
            "    def invalidate(self, error=None):",
            "        if error:",
            "            log.error(error)",
            "        log.warning(\"invalidating configuration\")",
            "        self.db_configured = False",
            "        self.save()",
            "",
            "    def get_book_path(self):",
            "        return self.config_calibre_split_dir if self.config_calibre_split_dir else self.config_calibre_dir",
            "",
            "    def store_calibre_uuid(self, calibre_db, Library_table):",
            "        try:",
            "            calibre_uuid = calibre_db.session.query(Library_table).one_or_none()",
            "            if self.config_calibre_uuid != calibre_uuid.uuid:",
            "                self.config_calibre_uuid = calibre_uuid.uuid",
            "                self.save()",
            "        except AttributeError:",
            "            pass",
            "",
            "    def __setattr__(self, attr_name, attr_value):",
            "        super().__setattr__(attr_name, attr_value)",
            "        self.__dict__[\"dirty\"].append(attr_name)",
            "",
            "",
            "def _encrypt_fields(session, secret_key):",
            "    try:",
            "        session.query(exists().where(_Settings.mail_password_e)).scalar()",
            "    except OperationalError:",
            "        with session.bind.connect() as conn:",
            "            conn.execute(text(\"ALTER TABLE settings ADD column 'mail_password_e' String\"))",
            "            conn.execute(text(\"ALTER TABLE settings ADD column 'config_ldap_serv_password_e' String\"))",
            "        session.commit()",
            "        crypter = Fernet(secret_key)",
            "        settings = session.query(_Settings.mail_password, _Settings.config_ldap_serv_password).first()",
            "        if settings.mail_password:",
            "            session.query(_Settings).update(",
            "                {_Settings.mail_password_e: crypter.encrypt(settings.mail_password.encode())})",
            "        if settings.config_ldap_serv_password:",
            "            session.query(_Settings).update(",
            "                {_Settings.config_ldap_serv_password_e:",
            "                     crypter.encrypt(settings.config_ldap_serv_password.encode())})",
            "        session.commit()",
            "",
            "",
            "def _migrate_table(session, orm_class, secret_key=None):",
            "    if secret_key:",
            "        _encrypt_fields(session, secret_key)",
            "    changed = False",
            "",
            "    for column_name, column in orm_class.__dict__.items():",
            "        if column_name[0] != '_':",
            "            try:",
            "                session.query(column).first()",
            "            except OperationalError as err:",
            "                log.debug(\"%s: %s\", column_name, err.args[0])",
            "                if column.default is None:",
            "                    column_default = \"\"",
            "                else:",
            "                    if isinstance(column.default.arg, bool):",
            "                        column_default = \"DEFAULT {}\".format(int(column.default.arg))",
            "                    else:",
            "                        column_default = \"DEFAULT `{}`\".format(column.default.arg)",
            "                if isinstance(column.type, JSON):",
            "                    column_type = \"JSON\"",
            "                else:",
            "                    column_type = column.type",
            "                alter_table = text(\"ALTER TABLE %s ADD COLUMN `%s` %s %s\" % (orm_class.__tablename__,",
            "                                                                             column_name,",
            "                                                                             column_type,",
            "                                                                             column_default))",
            "                log.debug(alter_table)",
            "                session.execute(alter_table)",
            "                changed = True",
            "            except json.decoder.JSONDecodeError as e:",
            "                log.error(\"Database corrupt column: {}\".format(column_name))",
            "                log.debug(e)",
            "",
            "    if changed:",
            "        try:",
            "            session.commit()",
            "        except OperationalError:",
            "            session.rollback()",
            "",
            "",
            "def autodetect_calibre_binaries():",
            "    if sys.platform == \"win32\":",
            "        calibre_path = [\"C:\\\\program files\\\\calibre\\\\\",",
            "                        \"C:\\\\program files(x86)\\\\calibre\\\\\",",
            "                        \"C:\\\\program files(x86)\\\\calibre2\\\\\",",
            "                        \"C:\\\\program files\\\\calibre2\\\\\"]",
            "    else:",
            "        calibre_path = [\"/opt/calibre/\"]",
            "    for element in calibre_path:",
            "        supported_binary_paths = [os.path.join(element, binary)",
            "                                  for binary in constants.SUPPORTED_CALIBRE_BINARIES.values()]",
            "        if all(os.path.isfile(binary_path) and os.access(binary_path, os.X_OK)",
            "               for binary_path in supported_binary_paths):",
            "            values = [process_wait([binary_path, \"--version\"],",
            "                                   pattern=r'\\(calibre (.*)\\)') for binary_path in supported_binary_paths]",
            "            if all(values):",
            "                version = values[0].group(1)",
            "                log.debug(\"calibre version %s\", version)",
            "                return element ",
            "    return \"\"",
            "",
            "",
            "def autodetect_converter_binary(calibre_path):",
            "    if sys.platform == \"win32\":",
            "        converter_path = os.path.join(calibre_path, \"ebook-convert.exe\")",
            "    else:",
            "        converter_path = os.path.join(calibre_path, \"ebook-convert\")",
            "    if calibre_path and os.path.isfile(converter_path) and os.access(converter_path, os.X_OK):",
            "        return converter_path",
            "    return \"\"",
            "",
            "",
            "def autodetect_unrar_binary():",
            "    if sys.platform == \"win32\":",
            "        calibre_path = [\"C:\\\\program files\\\\WinRar\\\\unRAR.exe\",",
            "                        \"C:\\\\program files(x86)\\\\WinRar\\\\unRAR.exe\"]",
            "    else:",
            "        calibre_path = [\"/usr/bin/unrar\"]",
            "    for element in calibre_path:",
            "        if os.path.isfile(element) and os.access(element, os.X_OK):",
            "            return element",
            "    return \"\"",
            "",
            "",
            "def autodetect_kepubify_binary():",
            "    if sys.platform == \"win32\":",
            "        calibre_path = [\"C:\\\\program files\\\\kepubify\\\\kepubify-windows-64Bit.exe\",",
            "                        \"C:\\\\program files(x86)\\\\kepubify\\\\kepubify-windows-64Bit.exe\"]",
            "    else:",
            "        calibre_path = [\"/opt/kepubify/kepubify-linux-64bit\", \"/opt/kepubify/kepubify-linux-32bit\"]",
            "    for element in calibre_path:",
            "        if os.path.isfile(element) and os.access(element, os.X_OK):",
            "            return element",
            "    return \"\"",
            "",
            "",
            "def _migrate_database(session, secret_key):",
            "    # make sure the table is created, if it does not exist",
            "    _Base.metadata.create_all(session.bind)",
            "    _migrate_table(session, _Settings, secret_key)",
            "    _migrate_table(session, _Flask_Settings)",
            "",
            "",
            "def load_configuration(session, secret_key):",
            "    _migrate_database(session, secret_key)",
            "    if not session.query(_Settings).count():",
            "        session.add(_Settings())",
            "        session.commit()",
            "",
            "",
            "def get_flask_session_key(_session):",
            "    flask_settings = _session.query(_Flask_Settings).one_or_none()",
            "    if flask_settings == None:",
            "        flask_settings = _Flask_Settings(os.urandom(32))",
            "        _session.add(flask_settings)",
            "        _session.commit()",
            "    return flask_settings.flask_session_key",
            "",
            "",
            "def get_encryption_key(key_path):",
            "    key_file = os.path.join(key_path, \".key\")",
            "    generate = True",
            "    error = \"\"",
            "    if os.path.exists(key_file) and os.path.getsize(key_file) > 32:",
            "        with open(key_file, \"rb\") as f:",
            "            key = f.read()",
            "        try:",
            "            urlsafe_b64decode(key)",
            "            generate = False",
            "        except ValueError:",
            "            pass",
            "    if generate:",
            "        key = Fernet.generate_key()",
            "        try:",
            "            with open(key_file, \"wb\") as f:",
            "                f.write(key)",
            "        except PermissionError as e:",
            "            error = e",
            "    return key, error"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#   This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#     Copyright (C) 2019 OzzieIsaacs, pwr",
            "#",
            "#   This program is free software: you can redistribute it and/or modify",
            "#   it under the terms of the GNU General Public License as published by",
            "#   the Free Software Foundation, either version 3 of the License, or",
            "#   (at your option) any later version.",
            "#",
            "#   This program is distributed in the hope that it will be useful,",
            "#   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#   GNU General Public License for more details.",
            "#",
            "#   You should have received a copy of the GNU General Public License",
            "#   along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import os",
            "import sys",
            "import json",
            "",
            "from sqlalchemy import Column, String, Integer, SmallInteger, Boolean, BLOB, JSON",
            "from sqlalchemy.exc import OperationalError",
            "from sqlalchemy.sql.expression import text",
            "from sqlalchemy import exists",
            "from cryptography.fernet import Fernet",
            "import cryptography.exceptions",
            "from base64 import urlsafe_b64decode",
            "try:",
            "    # Compatibility with sqlalchemy 2.0",
            "    from sqlalchemy.orm import declarative_base",
            "except ImportError:",
            "    from sqlalchemy.ext.declarative import declarative_base",
            "",
            "from . import constants, logger",
            "from .subproc_wrapper import process_wait",
            "",
            "",
            "log = logger.create()",
            "_Base = declarative_base()",
            "",
            "",
            "class _Flask_Settings(_Base):",
            "    __tablename__ = 'flask_settings'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    flask_session_key = Column(BLOB, default=b\"\")",
            "",
            "    def __init__(self, key):",
            "        super().__init__()",
            "        self.flask_session_key = key",
            "",
            "",
            "# Baseclass for representing settings in app.db with email server settings and Calibre database settings",
            "# (application settings)",
            "class _Settings(_Base):",
            "    __tablename__ = 'settings'",
            "",
            "    id = Column(Integer, primary_key=True)",
            "    mail_server = Column(String, default=constants.DEFAULT_MAIL_SERVER)",
            "    mail_port = Column(Integer, default=25)",
            "    mail_use_ssl = Column(SmallInteger, default=0)",
            "    mail_login = Column(String, default='mail@example.com')",
            "    mail_password_e = Column(String)",
            "    mail_password = Column(String)",
            "    mail_from = Column(String, default='automailer <mail@example.com>')",
            "    mail_size = Column(Integer, default=25*1024*1024)",
            "    mail_server_type = Column(SmallInteger, default=0)",
            "    mail_gmail_token = Column(JSON, default={})",
            "",
            "    config_calibre_dir = Column(String)",
            "    config_calibre_uuid = Column(String)",
            "    config_calibre_split = Column(Boolean, default=False)",
            "    config_calibre_split_dir = Column(String)",
            "    config_port = Column(Integer, default=constants.DEFAULT_PORT)",
            "    config_external_port = Column(Integer, default=constants.DEFAULT_PORT)",
            "    config_certfile = Column(String)",
            "    config_keyfile = Column(String)",
            "    config_trustedhosts = Column(String, default='')",
            "    config_calibre_web_title = Column(String, default='Calibre-Web')",
            "    config_books_per_page = Column(Integer, default=60)",
            "    config_random_books = Column(Integer, default=4)",
            "    config_authors_max = Column(Integer, default=0)",
            "    config_read_column = Column(Integer, default=0)",
            "    config_title_regex = Column(String,",
            "                                default=r'^(A|The|An|Der|Die|Das|Den|Ein|Eine'",
            "                                        r'|Einen|Dem|Des|Einem|Eines|Le|La|Les|L\\'|Un|Une)\\s+')",
            "    config_theme = Column(Integer, default=0)",
            "",
            "    config_log_level = Column(SmallInteger, default=logger.DEFAULT_LOG_LEVEL)",
            "    config_logfile = Column(String, default=logger.DEFAULT_LOG_FILE)",
            "    config_access_log = Column(SmallInteger, default=0)",
            "    config_access_logfile = Column(String, default=logger.DEFAULT_ACCESS_LOG)",
            "",
            "    config_uploading = Column(SmallInteger, default=0)",
            "    config_anonbrowse = Column(SmallInteger, default=0)",
            "    config_public_reg = Column(SmallInteger, default=0)",
            "    config_remote_login = Column(Boolean, default=False)",
            "    config_kobo_sync = Column(Boolean, default=False)",
            "",
            "    config_default_role = Column(SmallInteger, default=0)",
            "    config_default_show = Column(SmallInteger, default=constants.ADMIN_USER_SIDEBAR)",
            "    config_default_language = Column(String(3), default=\"all\")",
            "    config_default_locale = Column(String(2), default=\"en\")",
            "    config_columns_to_ignore = Column(String)",
            "",
            "    config_denied_tags = Column(String, default=\"\")",
            "    config_allowed_tags = Column(String, default=\"\")",
            "    config_restricted_column = Column(SmallInteger, default=0)",
            "    config_denied_column_value = Column(String, default=\"\")",
            "    config_allowed_column_value = Column(String, default=\"\")",
            "",
            "    config_use_google_drive = Column(Boolean, default=False)",
            "    config_google_drive_folder = Column(String)",
            "    config_google_drive_watch_changes_response = Column(JSON, default={})",
            "",
            "    config_use_goodreads = Column(Boolean, default=False)",
            "    config_goodreads_api_key = Column(String)",
            "    config_register_email = Column(Boolean, default=False)",
            "    config_login_type = Column(Integer, default=0)",
            "",
            "    config_kobo_proxy = Column(Boolean, default=False)",
            "",
            "    config_ldap_provider_url = Column(String, default='example.org')",
            "    config_ldap_port = Column(SmallInteger, default=389)",
            "    config_ldap_authentication = Column(SmallInteger, default=constants.LDAP_AUTH_SIMPLE)",
            "    config_ldap_serv_username = Column(String, default='cn=admin,dc=example,dc=org')",
            "    config_ldap_serv_password_e = Column(String)",
            "    config_ldap_serv_password = Column(String)",
            "    config_ldap_encryption = Column(SmallInteger, default=0)",
            "    config_ldap_cacert_path = Column(String, default=\"\")",
            "    config_ldap_cert_path = Column(String, default=\"\")",
            "    config_ldap_key_path = Column(String, default=\"\")",
            "    config_ldap_dn = Column(String, default='dc=example,dc=org')",
            "    config_ldap_user_object = Column(String, default='uid=%s')",
            "    config_ldap_member_user_object = Column(String, default='')",
            "    config_ldap_openldap = Column(Boolean, default=True)",
            "    config_ldap_group_object_filter = Column(String, default='(&(objectclass=posixGroup)(cn=%s))')",
            "    config_ldap_group_members_field = Column(String, default='memberUid')",
            "    config_ldap_group_name = Column(String, default='calibreweb')",
            "",
            "    config_kepubifypath = Column(String, default=None)",
            "    config_converterpath = Column(String, default=None)",
            "    config_binariesdir = Column(String, default=None)",
            "    config_calibre = Column(String)",
            "    config_rarfile_location = Column(String, default=None)",
            "    config_upload_formats = Column(String, default=','.join(constants.EXTENSIONS_UPLOAD))",
            "    config_unicode_filename = Column(Boolean, default=False)",
            "    config_embed_metadata = Column(Boolean, default=True)",
            "",
            "    config_updatechannel = Column(Integer, default=constants.UPDATE_STABLE)",
            "",
            "    config_reverse_proxy_login_header_name = Column(String)",
            "    config_allow_reverse_proxy_header_login = Column(Boolean, default=False)",
            "",
            "    schedule_start_time = Column(Integer, default=4)",
            "    schedule_duration = Column(Integer, default=10)",
            "    schedule_generate_book_covers = Column(Boolean, default=False)",
            "    schedule_generate_series_covers = Column(Boolean, default=False)",
            "    schedule_reconnect = Column(Boolean, default=False)",
            "    schedule_metadata_backup = Column(Boolean, default=False)",
            "",
            "    config_password_policy = Column(Boolean, default=True)",
            "    config_password_min_length = Column(Integer, default=8)",
            "    config_password_number = Column(Boolean, default=True)",
            "    config_password_lower = Column(Boolean, default=True)",
            "    config_password_upper = Column(Boolean, default=True)",
            "    config_password_character = Column(Boolean, default=True)",
            "    config_password_special = Column(Boolean, default=True)",
            "    config_session = Column(Integer, default=1)",
            "    config_ratelimiter = Column(Boolean, default=True)",
            "    config_limiter_uri = Column(String, default=\"\")",
            "    config_limiter_options = Column(String, default=\"\")",
            "",
            "    def __repr__(self):",
            "        return self.__class__.__name__",
            "",
            "",
            "# Class holds all application specific settings in calibre-web",
            "class ConfigSQL(object):",
            "    # pylint: disable=no-member",
            "    def __init__(self):",
            "        '''self.config_calibre_uuid = None",
            "        self.config_calibre_split_dir = None",
            "        self.dirty = None",
            "        self.config_logfile = None",
            "        self.config_upload_formats = None",
            "        self.mail_gmail_token = None",
            "        self.mail_server_type = None",
            "        self.mail_server = None",
            "        self.config_log_level = None",
            "        self.config_allowed_column_value = None",
            "        self.config_denied_column_value = None",
            "        self.config_allowed_tags = None",
            "        self.config_denied_tags = None",
            "        self.config_default_show = None",
            "        self.config_default_role = None",
            "        self.config_keyfile = None",
            "        self.config_certfile = None",
            "        self.config_rarfile_location = None",
            "        self.config_kepubifypath = None",
            "        self.config_binariesdir = None'''",
            "        self.__dict__[\"dirty\"] = list()",
            "",
            "    def init_config(self, session, secret_key, cli):",
            "        self._session = session",
            "        self._settings = None",
            "        self.db_configured = None",
            "        self.config_calibre_dir = None",
            "        self._fernet = Fernet(secret_key)",
            "        self.cli = cli",
            "        self.load()",
            "",
            "        change = False",
            "",
            "        if self.config_binariesdir is None:",
            "            change = True",
            "            self.config_binariesdir = autodetect_calibre_binaries()",
            "            self.config_converterpath = autodetect_converter_binary(self.config_binariesdir)",
            "",
            "        if self.config_kepubifypath is None:",
            "            change = True",
            "            self.config_kepubifypath = autodetect_kepubify_binary()",
            "",
            "        if self.config_rarfile_location is None:",
            "            change = True",
            "            self.config_rarfile_location = autodetect_unrar_binary()",
            "        if change:",
            "            self.save()",
            "",
            "    def _read_from_storage(self):",
            "        if self._settings is None:",
            "            log.debug(\"_ConfigSQL._read_from_storage\")",
            "            self._settings = self._session.query(_Settings).first()",
            "        return self._settings",
            "",
            "    def get_config_certfile(self):",
            "        if self.cli.certfilepath:",
            "            return self.cli.certfilepath",
            "        if self.cli.certfilepath == \"\":",
            "            return None",
            "        return self.config_certfile",
            "",
            "    def get_config_keyfile(self):",
            "        if self.cli.keyfilepath:",
            "            return self.cli.keyfilepath",
            "        if self.cli.certfilepath == \"\":",
            "            return None",
            "        return self.config_keyfile",
            "",
            "    def get_config_ipaddress(self):",
            "        return self.cli.ip_address or \"\"",
            "",
            "    def _has_role(self, role_flag):",
            "        return constants.has_flag(self.config_default_role, role_flag)",
            "",
            "    def role_admin(self):",
            "        return self._has_role(constants.ROLE_ADMIN)",
            "",
            "    def role_download(self):",
            "        return self._has_role(constants.ROLE_DOWNLOAD)",
            "",
            "    def role_viewer(self):",
            "        return self._has_role(constants.ROLE_VIEWER)",
            "",
            "    def role_upload(self):",
            "        return self._has_role(constants.ROLE_UPLOAD)",
            "",
            "    def role_edit(self):",
            "        return self._has_role(constants.ROLE_EDIT)",
            "",
            "    def role_passwd(self):",
            "        return self._has_role(constants.ROLE_PASSWD)",
            "",
            "    def role_edit_shelfs(self):",
            "        return self._has_role(constants.ROLE_EDIT_SHELFS)",
            "",
            "    def role_delete_books(self):",
            "        return self._has_role(constants.ROLE_DELETE_BOOKS)",
            "",
            "    def show_element_new_user(self, value):",
            "        return constants.has_flag(self.config_default_show, value)",
            "",
            "    def show_detail_random(self):",
            "        return self.show_element_new_user(constants.DETAIL_RANDOM)",
            "",
            "    def list_denied_tags(self):",
            "        mct = self.config_denied_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_tags(self):",
            "        mct = self.config_allowed_tags or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_denied_column_values(self):",
            "        mct = self.config_denied_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def list_allowed_column_values(self):",
            "        mct = self.config_allowed_column_value or \"\"",
            "        return [t.strip() for t in mct.split(\",\")]",
            "",
            "    def get_log_level(self):",
            "        return logger.get_level_name(self.config_log_level)",
            "",
            "    def get_mail_settings(self):",
            "        return {k: v for k, v in self.__dict__.items() if k.startswith('mail_')}",
            "",
            "    def get_mail_server_configured(self):",
            "        return bool((self.mail_server != constants.DEFAULT_MAIL_SERVER and self.mail_server_type == 0)",
            "                    or (self.mail_gmail_token != {} and self.mail_server_type == 1))",
            "",
            "    def get_scheduled_task_settings(self):",
            "        return {k: v for k, v in self.__dict__.items() if k.startswith('schedule_')}",
            "",
            "    def set_from_dictionary(self, dictionary, field, convertor=None, default=None, encode=None):",
            "        \"\"\"Possibly updates a field of this object.",
            "        The new value, if present, is grabbed from the given dictionary, and optionally passed through a convertor.",
            "",
            "        :returns: `True` if the field has changed value",
            "        \"\"\"",
            "        new_value = dictionary.get(field, default)",
            "        if new_value is None:",
            "            return False",
            "",
            "        if field not in self.__dict__:",
            "            log.warning(\"_ConfigSQL trying to set unknown field '%s' = %r\", field, new_value)",
            "            return False",
            "",
            "        if convertor is not None:",
            "            if encode:",
            "                new_value = convertor(new_value.encode(encode))",
            "            else:",
            "                new_value = convertor(new_value)",
            "",
            "        current_value = self.__dict__.get(field)",
            "        if current_value == new_value:",
            "            return False",
            "",
            "        setattr(self, field, new_value)",
            "        return True",
            "",
            "    def to_dict(self):",
            "        storage = {}",
            "        for k, v in self.__dict__.items():",
            "            if k[0] != '_' and not k.endswith(\"_e\") and not k == \"cli\":",
            "                storage[k] = v",
            "        return storage",
            "",
            "    def load(self):",
            "        \"\"\"Load all configuration values from the underlying storage.\"\"\"",
            "        s = self._read_from_storage()  # type: _Settings",
            "        for k, v in s.__dict__.items():",
            "            if k[0] != '_':",
            "                if v is None:",
            "                    # if the storage column has no value, apply the (possible) default",
            "                    column = s.__class__.__dict__.get(k)",
            "                    if column.default is not None:",
            "                        v = column.default.arg",
            "                if k.endswith(\"_e\") and v is not None:",
            "                    try:",
            "                        setattr(self, k, self._fernet.decrypt(v).decode())",
            "                    except cryptography.fernet.InvalidToken:",
            "                        setattr(self, k, \"\")",
            "                else:",
            "                    setattr(self, k, v)",
            "",
            "        have_metadata_db = bool(self.config_calibre_dir)",
            "        if have_metadata_db:",
            "            db_file = os.path.join(self.config_calibre_dir, 'metadata.db')",
            "            have_metadata_db = os.path.isfile(db_file)",
            "        self.db_configured = have_metadata_db",
            "        constants.EXTENSIONS_UPLOAD = [x.lstrip().rstrip().lower() for x in self.config_upload_formats.split(',')]",
            "        from . import cli_param",
            "        if os.environ.get('FLASK_DEBUG'):",
            "            logfile = logger.setup(logger.LOG_TO_STDOUT, logger.logging.DEBUG)",
            "        else:",
            "            # pylint: disable=access-member-before-definition",
            "            logfile = logger.setup(cli_param.logpath or self.config_logfile, self.config_log_level)",
            "        if logfile != os.path.abspath(self.config_logfile):",
            "            if logfile != os.path.abspath(cli_param.logpath):",
            "                log.warning(\"Log path %s not valid, falling back to default\", self.config_logfile)",
            "            self.config_logfile = logfile",
            "            s.config_logfile = logfile",
            "            self._session.merge(s)",
            "            try:",
            "                self._session.commit()",
            "            except OperationalError as e:",
            "                log.error('Database error: %s', e)",
            "                self._session.rollback()",
            "        self.__dict__[\"dirty\"] = list()",
            "",
            "    def save(self):",
            "        \"\"\"Apply all configuration values to the underlying storage.\"\"\"",
            "        s = self._read_from_storage()  # type: _Settings",
            "",
            "        for k in self.dirty:",
            "            if k[0] == '_':",
            "                continue",
            "            if hasattr(s, k):",
            "                if k.endswith(\"_e\"):",
            "                    setattr(s, k, self._fernet.encrypt(self.__dict__[k].encode()))",
            "                else:",
            "                    setattr(s, k, self.__dict__[k])",
            "",
            "        log.debug(\"_ConfigSQL updating storage\")",
            "        self._session.merge(s)",
            "        try:",
            "            self._session.commit()",
            "        except OperationalError as e:",
            "            log.error('Database error: %s', e)",
            "            self._session.rollback()",
            "        self.load()",
            "",
            "    def invalidate(self, error=None):",
            "        if error:",
            "            log.error(error)",
            "        log.warning(\"invalidating configuration\")",
            "        self.db_configured = False",
            "        self.save()",
            "",
            "    def get_book_path(self):",
            "        return self.config_calibre_split_dir if self.config_calibre_split_dir else self.config_calibre_dir",
            "",
            "    def store_calibre_uuid(self, calibre_db, Library_table):",
            "        try:",
            "            calibre_uuid = calibre_db.session.query(Library_table).one_or_none()",
            "            if self.config_calibre_uuid != calibre_uuid.uuid:",
            "                self.config_calibre_uuid = calibre_uuid.uuid",
            "                self.save()",
            "        except AttributeError:",
            "            pass",
            "",
            "    def __setattr__(self, attr_name, attr_value):",
            "        super().__setattr__(attr_name, attr_value)",
            "        self.__dict__[\"dirty\"].append(attr_name)",
            "",
            "",
            "def _encrypt_fields(session, secret_key):",
            "    try:",
            "        session.query(exists().where(_Settings.mail_password_e)).scalar()",
            "    except OperationalError:",
            "        with session.bind.connect() as conn:",
            "            conn.execute(text(\"ALTER TABLE settings ADD column 'mail_password_e' String\"))",
            "            conn.execute(text(\"ALTER TABLE settings ADD column 'config_ldap_serv_password_e' String\"))",
            "        session.commit()",
            "        crypter = Fernet(secret_key)",
            "        settings = session.query(_Settings.mail_password, _Settings.config_ldap_serv_password).first()",
            "        if settings.mail_password:",
            "            session.query(_Settings).update(",
            "                {_Settings.mail_password_e: crypter.encrypt(settings.mail_password.encode())})",
            "        if settings.config_ldap_serv_password:",
            "            session.query(_Settings).update(",
            "                {_Settings.config_ldap_serv_password_e: crypter.encrypt(settings.config_ldap_serv_password.encode())})",
            "        session.commit()",
            "",
            "",
            "def _migrate_table(session, orm_class, secret_key=None):",
            "    if secret_key:",
            "        _encrypt_fields(session, secret_key)",
            "    changed = False",
            "",
            "    for column_name, column in orm_class.__dict__.items():",
            "        if column_name[0] != '_':",
            "            try:",
            "                session.query(column).first()",
            "            except OperationalError as err:",
            "                log.debug(\"%s: %s\", column_name, err.args[0])",
            "                if column.default is None:",
            "                    column_default = \"\"",
            "                else:",
            "                    if isinstance(column.default.arg, bool):",
            "                        column_default = \"DEFAULT {}\".format(int(column.default.arg))",
            "                    else:",
            "                        column_default = \"DEFAULT `{}`\".format(column.default.arg)",
            "                if isinstance(column.type, JSON):",
            "                    column_type = \"JSON\"",
            "                else:",
            "                    column_type = column.type",
            "                alter_table = text(\"ALTER TABLE %s ADD COLUMN `%s` %s %s\" % (orm_class.__tablename__,",
            "                                                                             column_name,",
            "                                                                             column_type,",
            "                                                                             column_default))",
            "                log.debug(alter_table)",
            "                session.execute(alter_table)",
            "                changed = True",
            "            except json.decoder.JSONDecodeError as e:",
            "                log.error(\"Database corrupt column: {}\".format(column_name))",
            "                log.debug(e)",
            "",
            "    if changed:",
            "        try:",
            "            session.commit()",
            "        except OperationalError:",
            "            session.rollback()",
            "",
            "",
            "def autodetect_calibre_binaries():",
            "    if sys.platform == \"win32\":",
            "        calibre_path = [\"C:\\\\program files\\\\calibre\\\\\",",
            "                        \"C:\\\\program files(x86)\\\\calibre\\\\\",",
            "                        \"C:\\\\program files(x86)\\\\calibre2\\\\\",",
            "                        \"C:\\\\program files\\\\calibre2\\\\\"]",
            "    else:",
            "        calibre_path = [\"/opt/calibre/\"]",
            "    for element in calibre_path:",
            "        supported_binary_paths = [os.path.join(element, binary)",
            "                                  for binary in constants.SUPPORTED_CALIBRE_BINARIES.values()]",
            "        if all(os.path.isfile(binary_path) and os.access(binary_path, os.X_OK)",
            "               for binary_path in supported_binary_paths):",
            "            values = [process_wait([binary_path, \"--version\"],",
            "                                   pattern=r'\\(calibre (.*)\\)') for binary_path in supported_binary_paths]",
            "            if all(values):",
            "                version = values[0].group(1)",
            "                log.debug(\"calibre version %s\", version)",
            "                return element ",
            "    return \"\"",
            "",
            "",
            "def autodetect_converter_binary(calibre_path):",
            "    if sys.platform == \"win32\":",
            "        converter_path = os.path.join(calibre_path, \"ebook-convert.exe\")",
            "    else:",
            "        converter_path = os.path.join(calibre_path, \"ebook-convert\")",
            "    if calibre_path and os.path.isfile(converter_path) and os.access(converter_path, os.X_OK):",
            "        return converter_path",
            "    return \"\"",
            "",
            "",
            "def autodetect_unrar_binary():",
            "    if sys.platform == \"win32\":",
            "        calibre_path = [\"C:\\\\program files\\\\WinRar\\\\unRAR.exe\",",
            "                        \"C:\\\\program files(x86)\\\\WinRar\\\\unRAR.exe\"]",
            "    else:",
            "        calibre_path = [\"/usr/bin/unrar\"]",
            "    for element in calibre_path:",
            "        if os.path.isfile(element) and os.access(element, os.X_OK):",
            "            return element",
            "    return \"\"",
            "",
            "",
            "def autodetect_kepubify_binary():",
            "    if sys.platform == \"win32\":",
            "        calibre_path = [\"C:\\\\program files\\\\kepubify\\\\kepubify-windows-64Bit.exe\",",
            "                        \"C:\\\\program files(x86)\\\\kepubify\\\\kepubify-windows-64Bit.exe\"]",
            "    else:",
            "        calibre_path = [\"/opt/kepubify/kepubify-linux-64bit\", \"/opt/kepubify/kepubify-linux-32bit\"]",
            "    for element in calibre_path:",
            "        if os.path.isfile(element) and os.access(element, os.X_OK):",
            "            return element",
            "    return \"\"",
            "",
            "",
            "def _migrate_database(session, secret_key):",
            "    # make sure the table is created, if it does not exist",
            "    _Base.metadata.create_all(session.bind)",
            "    _migrate_table(session, _Settings, secret_key)",
            "    _migrate_table(session, _Flask_Settings)",
            "",
            "",
            "def load_configuration(session, secret_key):",
            "    _migrate_database(session, secret_key)",
            "    if not session.query(_Settings).count():",
            "        session.add(_Settings())",
            "        session.commit()",
            "",
            "",
            "def get_flask_session_key(_session):",
            "    flask_settings = _session.query(_Flask_Settings).one_or_none()",
            "    if flask_settings is None:",
            "        flask_settings = _Flask_Settings(os.urandom(32))",
            "        _session.add(flask_settings)",
            "        _session.commit()",
            "    return flask_settings.flask_session_key",
            "",
            "",
            "def get_encryption_key(key_path):",
            "    key_file = os.path.join(key_path, \".key\")",
            "    generate = True",
            "    error = \"\"",
            "    key = None",
            "    if os.path.exists(key_file) and os.path.getsize(key_file) > 32:",
            "        with open(key_file, \"rb\") as f:",
            "            key = f.read()",
            "        try:",
            "            urlsafe_b64decode(key)",
            "            generate = False",
            "        except ValueError:",
            "            pass",
            "    if generate:",
            "        key = Fernet.generate_key()",
            "        try:",
            "            with open(key_file, \"wb\") as f:",
            "                f.write(key)",
            "        except PermissionError as e:",
            "            error = e",
            "    return key, error"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "85": [
                "_Settings"
            ],
            "194": [
                "ConfigSQL",
                "init_config"
            ],
            "199": [
                "ConfigSQL",
                "init_config"
            ],
            "203": [
                "ConfigSQL",
                "init_config"
            ],
            "432": [
                "_encrypt_fields"
            ],
            "433": [
                "_encrypt_fields"
            ],
            "549": [
                "get_flask_session_key"
            ]
        },
        "addLocation": [
            "cps.admin",
            "cps.config_sql._Flask_Settings",
            "cps.config_sql.get_flask_session_key"
        ]
    },
    "cps/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " _extension = \"\""
            },
            "1": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " if sys.platform == \"win32\":"
            },
            "2": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     _extension = \".exe\""
            },
            "3": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-SUPPORTED_CALIBRE_BINARIES = {binary:binary + _extension for binary in [\"ebook-convert\", \"calibredb\"]}"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+SUPPORTED_CALIBRE_BINARIES = {binary: binary + _extension for binary in [\"ebook-convert\", \"calibredb\"]}"
            },
            "5": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " def has_flag(value, bit_flag):"
            },
            "8": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     return bit_flag == (bit_flag & (value or 0))"
            },
            "9": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " def selected_roles(dictionary):"
            },
            "12": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     return sum(v for k, v in ALL_ROLES.items() if k in dictionary)"
            },
            "13": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#   This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#     Copyright (C) 2019 OzzieIsaacs, pwr",
            "#",
            "#   This program is free software: you can redistribute it and/or modify",
            "#   it under the terms of the GNU General Public License as published by",
            "#   the Free Software Foundation, either version 3 of the License, or",
            "#   (at your option) any later version.",
            "#",
            "#   This program is distributed in the hope that it will be useful,",
            "#   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#   GNU General Public License for more details.",
            "#",
            "#   You should have received a copy of the GNU General Public License",
            "#   along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "import os",
            "from collections import namedtuple",
            "from sqlalchemy import __version__ as sql_version",
            "",
            "sqlalchemy_version2 = ([int(x) for x in sql_version.split('.')] >= [2, 0, 0])",
            "",
            "# APP_MODE - production, development, or test",
            "APP_MODE             = os.environ.get('APP_MODE', 'production')",
            "",
            "# if installed via pip this variable is set to true (empty file with name .HOMEDIR present)",
            "HOME_CONFIG = os.path.isfile(os.path.join(os.path.dirname(os.path.abspath(__file__)), '.HOMEDIR'))",
            "",
            "# In executables updater is not available, so variable is set to False there",
            "UPDATER_AVAILABLE = True",
            "",
            "# Base dir is parent of current file, necessary if called from different folder",
            "BASE_DIR            = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))",
            "# if executable file the files should be placed in the parent dir (parallel to the exe file)",
            "",
            "STATIC_DIR          = os.path.join(BASE_DIR, 'cps', 'static')",
            "TEMPLATES_DIR       = os.path.join(BASE_DIR, 'cps', 'templates')",
            "TRANSLATIONS_DIR    = os.path.join(BASE_DIR, 'cps', 'translations')",
            "",
            "# Cache dir - use CACHE_DIR environment variable, otherwise use the default directory: cps/cache",
            "DEFAULT_CACHE_DIR   = os.path.join(BASE_DIR, 'cps', 'cache')",
            "CACHE_DIR           = os.environ.get('CACHE_DIR', DEFAULT_CACHE_DIR)",
            "",
            "if HOME_CONFIG:",
            "    home_dir = os.path.join(os.path.expanduser(\"~\"), \".calibre-web\")",
            "    if not os.path.exists(home_dir):",
            "        os.makedirs(home_dir)",
            "    CONFIG_DIR = os.environ.get('CALIBRE_DBPATH', home_dir)",
            "else:",
            "    CONFIG_DIR = os.environ.get('CALIBRE_DBPATH', BASE_DIR)",
            "    if getattr(sys, 'frozen', False):",
            "        CONFIG_DIR = os.path.abspath(os.path.join(CONFIG_DIR, os.pardir))",
            "",
            "",
            "DEFAULT_SETTINGS_FILE = \"app.db\"",
            "DEFAULT_GDRIVE_FILE = \"gdrive.db\"",
            "",
            "ROLE_USER               = 0 << 0",
            "ROLE_ADMIN              = 1 << 0",
            "ROLE_DOWNLOAD           = 1 << 1",
            "ROLE_UPLOAD             = 1 << 2",
            "ROLE_EDIT               = 1 << 3",
            "ROLE_PASSWD             = 1 << 4",
            "ROLE_ANONYMOUS          = 1 << 5",
            "ROLE_EDIT_SHELFS        = 1 << 6",
            "ROLE_DELETE_BOOKS       = 1 << 7",
            "ROLE_VIEWER             = 1 << 8",
            "",
            "ALL_ROLES = {",
            "                \"admin_role\": ROLE_ADMIN,",
            "                \"download_role\": ROLE_DOWNLOAD,",
            "                \"upload_role\": ROLE_UPLOAD,",
            "                \"edit_role\": ROLE_EDIT,",
            "                \"passwd_role\": ROLE_PASSWD,",
            "                \"edit_shelf_role\": ROLE_EDIT_SHELFS,",
            "                \"delete_role\": ROLE_DELETE_BOOKS,",
            "                \"viewer_role\": ROLE_VIEWER,",
            "            }",
            "",
            "DETAIL_RANDOM           = 1 <<  0",
            "SIDEBAR_LANGUAGE        = 1 <<  1",
            "SIDEBAR_SERIES          = 1 <<  2",
            "SIDEBAR_CATEGORY        = 1 <<  3",
            "SIDEBAR_HOT             = 1 <<  4",
            "SIDEBAR_RANDOM          = 1 <<  5",
            "SIDEBAR_AUTHOR          = 1 <<  6",
            "SIDEBAR_BEST_RATED      = 1 <<  7",
            "SIDEBAR_READ_AND_UNREAD = 1 <<  8",
            "SIDEBAR_RECENT          = 1 <<  9",
            "SIDEBAR_SORTED          = 1 << 10",
            "MATURE_CONTENT          = 1 << 11",
            "SIDEBAR_PUBLISHER       = 1 << 12",
            "SIDEBAR_RATING          = 1 << 13",
            "SIDEBAR_FORMAT          = 1 << 14",
            "SIDEBAR_ARCHIVED        = 1 << 15",
            "SIDEBAR_DOWNLOAD        = 1 << 16",
            "SIDEBAR_LIST            = 1 << 17",
            "",
            "sidebar_settings = {",
            "                \"detail_random\": DETAIL_RANDOM,",
            "                \"sidebar_language\": SIDEBAR_LANGUAGE,",
            "                \"sidebar_series\": SIDEBAR_SERIES,",
            "                \"sidebar_category\": SIDEBAR_CATEGORY,",
            "                \"sidebar_random\": SIDEBAR_RANDOM,",
            "                \"sidebar_author\": SIDEBAR_AUTHOR,",
            "                \"sidebar_best_rated\": SIDEBAR_BEST_RATED,",
            "                \"sidebar_read_and_unread\": SIDEBAR_READ_AND_UNREAD,",
            "                \"sidebar_recent\": SIDEBAR_RECENT,",
            "                \"sidebar_sorted\": SIDEBAR_SORTED,",
            "                \"sidebar_publisher\": SIDEBAR_PUBLISHER,",
            "                \"sidebar_rating\": SIDEBAR_RATING,",
            "                \"sidebar_format\": SIDEBAR_FORMAT,",
            "                \"sidebar_archived\": SIDEBAR_ARCHIVED,",
            "                \"sidebar_download\": SIDEBAR_DOWNLOAD,",
            "                \"sidebar_list\": SIDEBAR_LIST,",
            "            }",
            "",
            "",
            "ADMIN_USER_ROLES        = sum(r for r in ALL_ROLES.values()) & ~ROLE_ANONYMOUS",
            "ADMIN_USER_SIDEBAR      = (SIDEBAR_LIST << 1) - 1",
            "",
            "UPDATE_STABLE       = 0 << 0",
            "AUTO_UPDATE_STABLE  = 1 << 0",
            "UPDATE_NIGHTLY      = 1 << 1",
            "AUTO_UPDATE_NIGHTLY = 1 << 2",
            "",
            "LOGIN_STANDARD      = 0",
            "LOGIN_LDAP          = 1",
            "LOGIN_OAUTH         = 2",
            "",
            "LDAP_AUTH_ANONYMOUS      = 0",
            "LDAP_AUTH_UNAUTHENTICATE = 1",
            "LDAP_AUTH_SIMPLE         = 0",
            "",
            "DEFAULT_MAIL_SERVER = \"mail.example.org\"",
            "",
            "DEFAULT_PASSWORD    = \"admin123\"  # nosec",
            "DEFAULT_PORT        = 8083",
            "env_CALIBRE_PORT = os.environ.get(\"CALIBRE_PORT\", DEFAULT_PORT)",
            "try:",
            "    DEFAULT_PORT = int(env_CALIBRE_PORT)",
            "except ValueError:",
            "    print('Environment variable CALIBRE_PORT has invalid value (%s), faling back to default (8083)' % env_CALIBRE_PORT)",
            "del env_CALIBRE_PORT",
            "",
            "",
            "EXTENSIONS_AUDIO = {'mp3', 'mp4', 'ogg', 'opus', 'wav', 'flac', 'm4a', 'm4b'}",
            "EXTENSIONS_CONVERT_FROM = ['pdf', 'epub', 'mobi', 'azw3', 'docx', 'rtf', 'fb2', 'lit', 'lrf',",
            "                           'txt', 'htmlz', 'rtf', 'odt', 'cbz', 'cbr', 'prc']",
            "EXTENSIONS_CONVERT_TO = ['pdf', 'epub', 'mobi', 'azw3', 'docx', 'rtf', 'fb2',",
            "                         'lit', 'lrf', 'txt', 'htmlz', 'rtf', 'odt']",
            "EXTENSIONS_UPLOAD = {'txt', 'pdf', 'epub', 'kepub', 'mobi', 'azw', 'azw3', 'cbr', 'cbz', 'cbt', 'cb7', 'djvu', 'djv',",
            "                     'prc', 'doc', 'docx', 'fb2', 'html', 'rtf', 'lit', 'odt', 'mp3', 'mp4', 'ogg',",
            "                     'opus', 'wav', 'flac', 'm4a', 'm4b'}",
            "",
            "_extension = \"\"",
            "if sys.platform == \"win32\":",
            "    _extension = \".exe\"",
            "SUPPORTED_CALIBRE_BINARIES = {binary:binary + _extension for binary in [\"ebook-convert\", \"calibredb\"]}",
            "",
            "",
            "def has_flag(value, bit_flag):",
            "    return bit_flag == (bit_flag & (value or 0))",
            "",
            "def selected_roles(dictionary):",
            "    return sum(v for k, v in ALL_ROLES.items() if k in dictionary)",
            "",
            "",
            "# :rtype: BookMeta",
            "BookMeta = namedtuple('BookMeta', 'file_path, extension, title, author, cover, description, tags, series, '",
            "                                  'series_id, languages, publisher, pubdate, identifiers')",
            "",
            "# python build process likes to have x.y.zbw -> b for beta and w a counting number",
            "STABLE_VERSION = {'version': '0.6.22b'}",
            "",
            "NIGHTLY_VERSION = dict()",
            "NIGHTLY_VERSION[0] = '$Format:%H$'",
            "NIGHTLY_VERSION[1] = '$Format:%cI$'",
            "",
            "# CACHE",
            "CACHE_TYPE_THUMBNAILS    = 'thumbnails'",
            "",
            "# Thumbnail Types",
            "THUMBNAIL_TYPE_COVER     = 1",
            "THUMBNAIL_TYPE_SERIES    = 2",
            "THUMBNAIL_TYPE_AUTHOR    = 3",
            "",
            "# Thumbnails Sizes",
            "COVER_THUMBNAIL_ORIGINAL = 0",
            "COVER_THUMBNAIL_SMALL    = 1",
            "COVER_THUMBNAIL_MEDIUM   = 2",
            "COVER_THUMBNAIL_LARGE    = 3",
            "",
            "# clean-up the module namespace",
            "del sys, os, namedtuple"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#   This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)",
            "#     Copyright (C) 2019 OzzieIsaacs, pwr",
            "#",
            "#   This program is free software: you can redistribute it and/or modify",
            "#   it under the terms of the GNU General Public License as published by",
            "#   the Free Software Foundation, either version 3 of the License, or",
            "#   (at your option) any later version.",
            "#",
            "#   This program is distributed in the hope that it will be useful,",
            "#   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "#   GNU General Public License for more details.",
            "#",
            "#   You should have received a copy of the GNU General Public License",
            "#   along with this program. If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import sys",
            "import os",
            "from collections import namedtuple",
            "from sqlalchemy import __version__ as sql_version",
            "",
            "sqlalchemy_version2 = ([int(x) for x in sql_version.split('.')] >= [2, 0, 0])",
            "",
            "# APP_MODE - production, development, or test",
            "APP_MODE             = os.environ.get('APP_MODE', 'production')",
            "",
            "# if installed via pip this variable is set to true (empty file with name .HOMEDIR present)",
            "HOME_CONFIG = os.path.isfile(os.path.join(os.path.dirname(os.path.abspath(__file__)), '.HOMEDIR'))",
            "",
            "# In executables updater is not available, so variable is set to False there",
            "UPDATER_AVAILABLE = True",
            "",
            "# Base dir is parent of current file, necessary if called from different folder",
            "BASE_DIR            = os.path.abspath(os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir))",
            "# if executable file the files should be placed in the parent dir (parallel to the exe file)",
            "",
            "STATIC_DIR          = os.path.join(BASE_DIR, 'cps', 'static')",
            "TEMPLATES_DIR       = os.path.join(BASE_DIR, 'cps', 'templates')",
            "TRANSLATIONS_DIR    = os.path.join(BASE_DIR, 'cps', 'translations')",
            "",
            "# Cache dir - use CACHE_DIR environment variable, otherwise use the default directory: cps/cache",
            "DEFAULT_CACHE_DIR   = os.path.join(BASE_DIR, 'cps', 'cache')",
            "CACHE_DIR           = os.environ.get('CACHE_DIR', DEFAULT_CACHE_DIR)",
            "",
            "if HOME_CONFIG:",
            "    home_dir = os.path.join(os.path.expanduser(\"~\"), \".calibre-web\")",
            "    if not os.path.exists(home_dir):",
            "        os.makedirs(home_dir)",
            "    CONFIG_DIR = os.environ.get('CALIBRE_DBPATH', home_dir)",
            "else:",
            "    CONFIG_DIR = os.environ.get('CALIBRE_DBPATH', BASE_DIR)",
            "    if getattr(sys, 'frozen', False):",
            "        CONFIG_DIR = os.path.abspath(os.path.join(CONFIG_DIR, os.pardir))",
            "",
            "",
            "DEFAULT_SETTINGS_FILE = \"app.db\"",
            "DEFAULT_GDRIVE_FILE = \"gdrive.db\"",
            "",
            "ROLE_USER               = 0 << 0",
            "ROLE_ADMIN              = 1 << 0",
            "ROLE_DOWNLOAD           = 1 << 1",
            "ROLE_UPLOAD             = 1 << 2",
            "ROLE_EDIT               = 1 << 3",
            "ROLE_PASSWD             = 1 << 4",
            "ROLE_ANONYMOUS          = 1 << 5",
            "ROLE_EDIT_SHELFS        = 1 << 6",
            "ROLE_DELETE_BOOKS       = 1 << 7",
            "ROLE_VIEWER             = 1 << 8",
            "",
            "ALL_ROLES = {",
            "                \"admin_role\": ROLE_ADMIN,",
            "                \"download_role\": ROLE_DOWNLOAD,",
            "                \"upload_role\": ROLE_UPLOAD,",
            "                \"edit_role\": ROLE_EDIT,",
            "                \"passwd_role\": ROLE_PASSWD,",
            "                \"edit_shelf_role\": ROLE_EDIT_SHELFS,",
            "                \"delete_role\": ROLE_DELETE_BOOKS,",
            "                \"viewer_role\": ROLE_VIEWER,",
            "            }",
            "",
            "DETAIL_RANDOM           = 1 <<  0",
            "SIDEBAR_LANGUAGE        = 1 <<  1",
            "SIDEBAR_SERIES          = 1 <<  2",
            "SIDEBAR_CATEGORY        = 1 <<  3",
            "SIDEBAR_HOT             = 1 <<  4",
            "SIDEBAR_RANDOM          = 1 <<  5",
            "SIDEBAR_AUTHOR          = 1 <<  6",
            "SIDEBAR_BEST_RATED      = 1 <<  7",
            "SIDEBAR_READ_AND_UNREAD = 1 <<  8",
            "SIDEBAR_RECENT          = 1 <<  9",
            "SIDEBAR_SORTED          = 1 << 10",
            "MATURE_CONTENT          = 1 << 11",
            "SIDEBAR_PUBLISHER       = 1 << 12",
            "SIDEBAR_RATING          = 1 << 13",
            "SIDEBAR_FORMAT          = 1 << 14",
            "SIDEBAR_ARCHIVED        = 1 << 15",
            "SIDEBAR_DOWNLOAD        = 1 << 16",
            "SIDEBAR_LIST            = 1 << 17",
            "",
            "sidebar_settings = {",
            "                \"detail_random\": DETAIL_RANDOM,",
            "                \"sidebar_language\": SIDEBAR_LANGUAGE,",
            "                \"sidebar_series\": SIDEBAR_SERIES,",
            "                \"sidebar_category\": SIDEBAR_CATEGORY,",
            "                \"sidebar_random\": SIDEBAR_RANDOM,",
            "                \"sidebar_author\": SIDEBAR_AUTHOR,",
            "                \"sidebar_best_rated\": SIDEBAR_BEST_RATED,",
            "                \"sidebar_read_and_unread\": SIDEBAR_READ_AND_UNREAD,",
            "                \"sidebar_recent\": SIDEBAR_RECENT,",
            "                \"sidebar_sorted\": SIDEBAR_SORTED,",
            "                \"sidebar_publisher\": SIDEBAR_PUBLISHER,",
            "                \"sidebar_rating\": SIDEBAR_RATING,",
            "                \"sidebar_format\": SIDEBAR_FORMAT,",
            "                \"sidebar_archived\": SIDEBAR_ARCHIVED,",
            "                \"sidebar_download\": SIDEBAR_DOWNLOAD,",
            "                \"sidebar_list\": SIDEBAR_LIST,",
            "            }",
            "",
            "",
            "ADMIN_USER_ROLES        = sum(r for r in ALL_ROLES.values()) & ~ROLE_ANONYMOUS",
            "ADMIN_USER_SIDEBAR      = (SIDEBAR_LIST << 1) - 1",
            "",
            "UPDATE_STABLE       = 0 << 0",
            "AUTO_UPDATE_STABLE  = 1 << 0",
            "UPDATE_NIGHTLY      = 1 << 1",
            "AUTO_UPDATE_NIGHTLY = 1 << 2",
            "",
            "LOGIN_STANDARD      = 0",
            "LOGIN_LDAP          = 1",
            "LOGIN_OAUTH         = 2",
            "",
            "LDAP_AUTH_ANONYMOUS      = 0",
            "LDAP_AUTH_UNAUTHENTICATE = 1",
            "LDAP_AUTH_SIMPLE         = 0",
            "",
            "DEFAULT_MAIL_SERVER = \"mail.example.org\"",
            "",
            "DEFAULT_PASSWORD    = \"admin123\"  # nosec",
            "DEFAULT_PORT        = 8083",
            "env_CALIBRE_PORT = os.environ.get(\"CALIBRE_PORT\", DEFAULT_PORT)",
            "try:",
            "    DEFAULT_PORT = int(env_CALIBRE_PORT)",
            "except ValueError:",
            "    print('Environment variable CALIBRE_PORT has invalid value (%s), faling back to default (8083)' % env_CALIBRE_PORT)",
            "del env_CALIBRE_PORT",
            "",
            "",
            "EXTENSIONS_AUDIO = {'mp3', 'mp4', 'ogg', 'opus', 'wav', 'flac', 'm4a', 'm4b'}",
            "EXTENSIONS_CONVERT_FROM = ['pdf', 'epub', 'mobi', 'azw3', 'docx', 'rtf', 'fb2', 'lit', 'lrf',",
            "                           'txt', 'htmlz', 'rtf', 'odt', 'cbz', 'cbr', 'prc']",
            "EXTENSIONS_CONVERT_TO = ['pdf', 'epub', 'mobi', 'azw3', 'docx', 'rtf', 'fb2',",
            "                         'lit', 'lrf', 'txt', 'htmlz', 'rtf', 'odt']",
            "EXTENSIONS_UPLOAD = {'txt', 'pdf', 'epub', 'kepub', 'mobi', 'azw', 'azw3', 'cbr', 'cbz', 'cbt', 'cb7', 'djvu', 'djv',",
            "                     'prc', 'doc', 'docx', 'fb2', 'html', 'rtf', 'lit', 'odt', 'mp3', 'mp4', 'ogg',",
            "                     'opus', 'wav', 'flac', 'm4a', 'm4b'}",
            "",
            "_extension = \"\"",
            "if sys.platform == \"win32\":",
            "    _extension = \".exe\"",
            "SUPPORTED_CALIBRE_BINARIES = {binary: binary + _extension for binary in [\"ebook-convert\", \"calibredb\"]}",
            "",
            "",
            "def has_flag(value, bit_flag):",
            "    return bit_flag == (bit_flag & (value or 0))",
            "",
            "",
            "def selected_roles(dictionary):",
            "    return sum(v for k, v in ALL_ROLES.items() if k in dictionary)",
            "",
            "",
            "# :rtype: BookMeta",
            "BookMeta = namedtuple('BookMeta', 'file_path, extension, title, author, cover, description, tags, series, '",
            "                                  'series_id, languages, publisher, pubdate, identifiers')",
            "",
            "# python build process likes to have x.y.zbw -> b for beta and w a counting number",
            "STABLE_VERSION = {'version': '0.6.22b'}",
            "",
            "NIGHTLY_VERSION = dict()",
            "NIGHTLY_VERSION[0] = '$Format:%H$'",
            "NIGHTLY_VERSION[1] = '$Format:%cI$'",
            "",
            "# CACHE",
            "CACHE_TYPE_THUMBNAILS    = 'thumbnails'",
            "",
            "# Thumbnail Types",
            "THUMBNAIL_TYPE_COVER     = 1",
            "THUMBNAIL_TYPE_SERIES    = 2",
            "THUMBNAIL_TYPE_AUTHOR    = 3",
            "",
            "# Thumbnails Sizes",
            "COVER_THUMBNAIL_ORIGINAL = 0",
            "COVER_THUMBNAIL_SMALL    = 1",
            "COVER_THUMBNAIL_MEDIUM   = 2",
            "COVER_THUMBNAIL_LARGE    = 3",
            "",
            "# clean-up the module namespace",
            "del sys, os, namedtuple"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "162": [
                "SUPPORTED_CALIBRE_BINARIES"
            ]
        },
        "addLocation": []
    }
}