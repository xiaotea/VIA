{
    "keystone/api/credentials.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         # If the request was filtered, make sure to return only the"
            },
            "1": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         # credentials specific to that user. This makes it so that users with"
            },
            "2": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         # roles on projects can't see credentials that aren't theirs."
            },
            "3": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if (not self.oslo_context.system_scope and"
            },
            "4": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                CONF.oslo_policy.enforce_scope):"
            },
            "5": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            filtered_refs = []"
            },
            "6": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for ref in refs:"
            },
            "7": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if ref['user_id'] == target['credential']['user_id']:"
            },
            "8": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    filtered_refs.append(ref)"
            },
            "9": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            refs = filtered_refs"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        filtered_refs = []"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        for ref in refs:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+            # Check each credential again to make sure the user has access to"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            # it, either by owning it, being a project admin with"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            # enforce_scope=false, being a system user, or having some other"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            # custom policy that allows access."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+            try:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+                cred = PROVIDERS.credential_api.get_credential(ref['id'])"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+                ENFORCER.enforce_call("
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+                    action='identity:get_credential',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+                    target_attr={'credential': cred}"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                )"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+                filtered_refs.append(ref)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            except exception.Forbidden:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+                pass"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        refs = filtered_refs"
            },
            "26": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         refs = [self._blob_to_json(r) for r in refs]"
            },
            "27": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         return self.wrap_collection(refs, hints=hints)"
            },
            "28": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# This file handles all flask-restful resources for /v3/credentials",
            "",
            "import hashlib",
            "",
            "import flask",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import rbac_enforcer",
            "from keystone.common import validation",
            "import keystone.conf",
            "from keystone.credential import schema",
            "from keystone import exception",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "ENFORCER = rbac_enforcer.RBACEnforcer",
            "",
            "",
            "def _build_target_enforcement():",
            "    target = {}",
            "    try:",
            "        target['credential'] = PROVIDERS.credential_api.get_credential(",
            "            flask.request.view_args.get('credential_id')",
            "        )",
            "    except exception.NotFound:  # nosec",
            "        # Defer existance in the event the credential doesn't exist, we'll",
            "        # check this later anyway.",
            "        pass",
            "",
            "    return target",
            "",
            "",
            "class CredentialResource(ks_flask.ResourceBase):",
            "    collection_key = 'credentials'",
            "    member_key = 'credential'",
            "",
            "    @staticmethod",
            "    def _blob_to_json(ref):",
            "        # credentials stored via ec2tokens before the fix for #1259584",
            "        # need json_serailzing, as that's the documented API format",
            "        blob = ref.get('blob')",
            "        if isinstance(blob, dict):",
            "            ref = ref.copy()",
            "            ref['blob'] = jsonutils.dumps(blob)",
            "        return ref",
            "",
            "    def _assign_unique_id(self, ref, trust_id=None):",
            "        # Generates an assigns a unique identifier to a credential reference.",
            "        if ref.get('type', '').lower() == 'ec2':",
            "            try:",
            "                blob = jsonutils.loads(ref.get('blob'))",
            "            except (ValueError, TabError):",
            "                raise exception.ValidationError(",
            "                    message=_('Invalid blob in credential'))",
            "            if not blob or not isinstance(blob, dict):",
            "                raise exception.ValidationError(attribute='blob',",
            "                                                target='credential')",
            "            if blob.get('access') is None:",
            "                raise exception.ValidationError(attribute='access',",
            "                                                target='credential')",
            "",
            "            ref = ref.copy()",
            "            ref['id'] = hashlib.sha256(",
            "                blob['access'].encode('utf8')).hexdigest()",
            "            # update the blob with the trust_id, so credentials created with",
            "            # a trust scoped token will result in trust scoped tokens when",
            "            # authentication via ec2tokens happens",
            "            if trust_id is not None:",
            "                blob['trust_id'] = trust_id",
            "                ref['blob'] = jsonutils.dumps(blob)",
            "            return ref",
            "        else:",
            "            return super(CredentialResource, self)._assign_unique_id(ref)",
            "",
            "    def _list_credentials(self):",
            "        filters = ['user_id', 'type']",
            "        if not self.oslo_context.system_scope:",
            "            target = {'credential': {'user_id': self.oslo_context.user_id}}",
            "        else:",
            "            target = None",
            "        ENFORCER.enforce_call(action='identity:list_credentials',",
            "                              filters=filters, target_attr=target)",
            "        hints = self.build_driver_hints(filters)",
            "        refs = PROVIDERS.credential_api.list_credentials(hints)",
            "        # If the request was filtered, make sure to return only the",
            "        # credentials specific to that user. This makes it so that users with",
            "        # roles on projects can't see credentials that aren't theirs.",
            "        if (not self.oslo_context.system_scope and",
            "                CONF.oslo_policy.enforce_scope):",
            "            filtered_refs = []",
            "            for ref in refs:",
            "                if ref['user_id'] == target['credential']['user_id']:",
            "                    filtered_refs.append(ref)",
            "            refs = filtered_refs",
            "        refs = [self._blob_to_json(r) for r in refs]",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "    def _get_credential(self, credential_id):",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        credential = PROVIDERS.credential_api.get_credential(credential_id)",
            "        return self.wrap_member(self._blob_to_json(credential))",
            "",
            "    def get(self, credential_id=None):",
            "        # Get Credential or List of credentials.",
            "        if credential_id is None:",
            "            # No Parameter passed means that we're doing a LIST action.",
            "            return self._list_credentials()",
            "        else:",
            "            return self._get_credential(credential_id)",
            "",
            "    def post(self):",
            "        # Create a new credential",
            "        credential = self.request_body_json.get('credential', {})",
            "        target = {}",
            "        target['credential'] = credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:create_credential', target_attr=target",
            "        )",
            "        validation.lazy_validate(schema.credential_create, credential)",
            "        trust_id = getattr(self.oslo_context, 'trust_id', None)",
            "        ref = self._assign_unique_id(",
            "            self._normalize_dict(credential), trust_id=trust_id)",
            "        ref = PROVIDERS.credential_api.create_credential(ref['id'], ref)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "    def patch(self, credential_id):",
            "        # Update Credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        PROVIDERS.credential_api.get_credential(credential_id)",
            "",
            "        credential = self.request_body_json.get('credential', {})",
            "        validation.lazy_validate(schema.credential_update, credential)",
            "        self._require_matching_id(credential)",
            "        ref = PROVIDERS.credential_api.update_credential(",
            "            credential_id, credential)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, credential_id):",
            "        # Delete credentials",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "",
            "        return (PROVIDERS.credential_api.delete_credential(credential_id),",
            "                http_client.NO_CONTENT)",
            "",
            "",
            "class CredentialAPI(ks_flask.APIBase):",
            "",
            "    _name = 'credentials'",
            "    _import_name = __name__",
            "    resource_mapping = []",
            "    resources = [CredentialResource]",
            "",
            "",
            "APIs = (CredentialAPI,)"
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# This file handles all flask-restful resources for /v3/credentials",
            "",
            "import hashlib",
            "",
            "import flask",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import rbac_enforcer",
            "from keystone.common import validation",
            "import keystone.conf",
            "from keystone.credential import schema",
            "from keystone import exception",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "ENFORCER = rbac_enforcer.RBACEnforcer",
            "",
            "",
            "def _build_target_enforcement():",
            "    target = {}",
            "    try:",
            "        target['credential'] = PROVIDERS.credential_api.get_credential(",
            "            flask.request.view_args.get('credential_id')",
            "        )",
            "    except exception.NotFound:  # nosec",
            "        # Defer existance in the event the credential doesn't exist, we'll",
            "        # check this later anyway.",
            "        pass",
            "",
            "    return target",
            "",
            "",
            "class CredentialResource(ks_flask.ResourceBase):",
            "    collection_key = 'credentials'",
            "    member_key = 'credential'",
            "",
            "    @staticmethod",
            "    def _blob_to_json(ref):",
            "        # credentials stored via ec2tokens before the fix for #1259584",
            "        # need json_serailzing, as that's the documented API format",
            "        blob = ref.get('blob')",
            "        if isinstance(blob, dict):",
            "            ref = ref.copy()",
            "            ref['blob'] = jsonutils.dumps(blob)",
            "        return ref",
            "",
            "    def _assign_unique_id(self, ref, trust_id=None):",
            "        # Generates an assigns a unique identifier to a credential reference.",
            "        if ref.get('type', '').lower() == 'ec2':",
            "            try:",
            "                blob = jsonutils.loads(ref.get('blob'))",
            "            except (ValueError, TabError):",
            "                raise exception.ValidationError(",
            "                    message=_('Invalid blob in credential'))",
            "            if not blob or not isinstance(blob, dict):",
            "                raise exception.ValidationError(attribute='blob',",
            "                                                target='credential')",
            "            if blob.get('access') is None:",
            "                raise exception.ValidationError(attribute='access',",
            "                                                target='credential')",
            "",
            "            ref = ref.copy()",
            "            ref['id'] = hashlib.sha256(",
            "                blob['access'].encode('utf8')).hexdigest()",
            "            # update the blob with the trust_id, so credentials created with",
            "            # a trust scoped token will result in trust scoped tokens when",
            "            # authentication via ec2tokens happens",
            "            if trust_id is not None:",
            "                blob['trust_id'] = trust_id",
            "                ref['blob'] = jsonutils.dumps(blob)",
            "            return ref",
            "        else:",
            "            return super(CredentialResource, self)._assign_unique_id(ref)",
            "",
            "    def _list_credentials(self):",
            "        filters = ['user_id', 'type']",
            "        if not self.oslo_context.system_scope:",
            "            target = {'credential': {'user_id': self.oslo_context.user_id}}",
            "        else:",
            "            target = None",
            "        ENFORCER.enforce_call(action='identity:list_credentials',",
            "                              filters=filters, target_attr=target)",
            "        hints = self.build_driver_hints(filters)",
            "        refs = PROVIDERS.credential_api.list_credentials(hints)",
            "        # If the request was filtered, make sure to return only the",
            "        # credentials specific to that user. This makes it so that users with",
            "        # roles on projects can't see credentials that aren't theirs.",
            "        filtered_refs = []",
            "        for ref in refs:",
            "            # Check each credential again to make sure the user has access to",
            "            # it, either by owning it, being a project admin with",
            "            # enforce_scope=false, being a system user, or having some other",
            "            # custom policy that allows access.",
            "            try:",
            "                cred = PROVIDERS.credential_api.get_credential(ref['id'])",
            "                ENFORCER.enforce_call(",
            "                    action='identity:get_credential',",
            "                    target_attr={'credential': cred}",
            "                )",
            "                filtered_refs.append(ref)",
            "            except exception.Forbidden:",
            "                pass",
            "        refs = filtered_refs",
            "        refs = [self._blob_to_json(r) for r in refs]",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "    def _get_credential(self, credential_id):",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        credential = PROVIDERS.credential_api.get_credential(credential_id)",
            "        return self.wrap_member(self._blob_to_json(credential))",
            "",
            "    def get(self, credential_id=None):",
            "        # Get Credential or List of credentials.",
            "        if credential_id is None:",
            "            # No Parameter passed means that we're doing a LIST action.",
            "            return self._list_credentials()",
            "        else:",
            "            return self._get_credential(credential_id)",
            "",
            "    def post(self):",
            "        # Create a new credential",
            "        credential = self.request_body_json.get('credential', {})",
            "        target = {}",
            "        target['credential'] = credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:create_credential', target_attr=target",
            "        )",
            "        validation.lazy_validate(schema.credential_create, credential)",
            "        trust_id = getattr(self.oslo_context, 'trust_id', None)",
            "        ref = self._assign_unique_id(",
            "            self._normalize_dict(credential), trust_id=trust_id)",
            "        ref = PROVIDERS.credential_api.create_credential(ref['id'], ref)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "    def patch(self, credential_id):",
            "        # Update Credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        PROVIDERS.credential_api.get_credential(credential_id)",
            "",
            "        credential = self.request_body_json.get('credential', {})",
            "        validation.lazy_validate(schema.credential_update, credential)",
            "        self._require_matching_id(credential)",
            "        ref = PROVIDERS.credential_api.update_credential(",
            "            credential_id, credential)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, credential_id):",
            "        # Delete credentials",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "",
            "        return (PROVIDERS.credential_api.delete_credential(credential_id),",
            "                http_client.NO_CONTENT)",
            "",
            "",
            "class CredentialAPI(ks_flask.APIBase):",
            "",
            "    _name = 'credentials'",
            "    _import_name = __name__",
            "    resource_mapping = []",
            "    resources = [CredentialResource]",
            "",
            "",
            "APIs = (CredentialAPI,)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "104": [
                "CredentialResource",
                "_list_credentials"
            ],
            "105": [
                "CredentialResource",
                "_list_credentials"
            ],
            "106": [
                "CredentialResource",
                "_list_credentials"
            ],
            "107": [
                "CredentialResource",
                "_list_credentials"
            ],
            "108": [
                "CredentialResource",
                "_list_credentials"
            ],
            "109": [
                "CredentialResource",
                "_list_credentials"
            ],
            "110": [
                "CredentialResource",
                "_list_credentials"
            ]
        },
        "addLocation": []
    },
    "keystone/tests/unit/protection/v3/test_credentials.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1138,
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "                 'identity:delete_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER"
            },
            "1": {
                "beforePatchRowNumber": 1139,
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "             }"
            },
            "2": {
                "beforePatchRowNumber": 1140,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "             f.write(jsonutils.dumps(overridden_policies))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1142,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1143,
                "PatchRowcode": "+class ProjectReaderTestsEnforceScopeFalse(base_classes.TestCaseWithBootstrap,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1144,
                "PatchRowcode": "+                                          common_auth.AuthTestMixin,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1145,
                "PatchRowcode": "+                                          _UserCredentialTests,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1146,
                "PatchRowcode": "+                                          _ProjectUsersTests):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1147,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1148,
                "PatchRowcode": "+    def setUp(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1149,
                "PatchRowcode": "+        super(ProjectReaderTestsEnforceScopeFalse, self).setUp()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1150,
                "PatchRowcode": "+        self.loadapp()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1151,
                "PatchRowcode": "+        self.useFixture(ksfixtures.Policy(self.config_fixture))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1152,
                "PatchRowcode": "+        self.config_fixture.config(group='oslo_policy', enforce_scope=False)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1153,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1154,
                "PatchRowcode": "+        project_reader = unit.new_user_ref("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1155,
                "PatchRowcode": "+            domain_id=CONF.identity.default_domain_id"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1156,
                "PatchRowcode": "+        )"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1157,
                "PatchRowcode": "+        self.user_id = PROVIDERS.identity_api.create_user("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1158,
                "PatchRowcode": "+            project_reader"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1159,
                "PatchRowcode": "+        )['id']"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1160,
                "PatchRowcode": "+        project = unit.new_project_ref("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1161,
                "PatchRowcode": "+            domain_id=CONF.identity.default_domain_id"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1162,
                "PatchRowcode": "+        )"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1163,
                "PatchRowcode": "+        self.project_id = PROVIDERS.resource_api.create_project("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1164,
                "PatchRowcode": "+            project['id'], project"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1165,
                "PatchRowcode": "+        )['id']"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1166,
                "PatchRowcode": "+        PROVIDERS.assignment_api.create_grant("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1167,
                "PatchRowcode": "+            self.bootstrapper.reader_role_id, user_id=self.user_id,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1168,
                "PatchRowcode": "+            project_id=self.project_id"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1169,
                "PatchRowcode": "+        )"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1170,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1171,
                "PatchRowcode": "+        auth = self.build_authentication_request("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1172,
                "PatchRowcode": "+            user_id=self.user_id,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1173,
                "PatchRowcode": "+            password=project_reader['password'],"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1174,
                "PatchRowcode": "+            project_id=self.project_id"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1175,
                "PatchRowcode": "+        )"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1176,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1177,
                "PatchRowcode": "+        # Grab a token using the persona we're testing and prepare headers"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1178,
                "PatchRowcode": "+        # for requests we'll be making in the tests."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1179,
                "PatchRowcode": "+        with self.test_client() as c:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1180,
                "PatchRowcode": "+            r = c.post('/v3/auth/tokens', json=auth)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1181,
                "PatchRowcode": "+            self.token_id = r.headers['X-Subject-Token']"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1182,
                "PatchRowcode": "+            self.headers = {'X-Auth-Token': self.token_id}"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1183,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1184,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1185,
                "PatchRowcode": "+class ProjectMemberTestsEnforceScopeFalse(base_classes.TestCaseWithBootstrap,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1186,
                "PatchRowcode": "+                                          common_auth.AuthTestMixin,"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1187,
                "PatchRowcode": "+                                          _UserCredentialTests,"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1188,
                "PatchRowcode": "+                                          _ProjectUsersTests):"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1189,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1190,
                "PatchRowcode": "+    def setUp(self):"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1191,
                "PatchRowcode": "+        super(ProjectMemberTestsEnforceScopeFalse, self).setUp()"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1192,
                "PatchRowcode": "+        self.loadapp()"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1193,
                "PatchRowcode": "+        self.useFixture(ksfixtures.Policy(self.config_fixture))"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1194,
                "PatchRowcode": "+        self.config_fixture.config(group='oslo_policy', enforce_scope=False)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1195,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1196,
                "PatchRowcode": "+        project_member = unit.new_user_ref("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1197,
                "PatchRowcode": "+            domain_id=CONF.identity.default_domain_id"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1198,
                "PatchRowcode": "+        )"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "+        self.user_id = PROVIDERS.identity_api.create_user("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1200,
                "PatchRowcode": "+            project_member"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1201,
                "PatchRowcode": "+        )['id']"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1202,
                "PatchRowcode": "+        project = unit.new_project_ref("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1203,
                "PatchRowcode": "+            domain_id=CONF.identity.default_domain_id"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1204,
                "PatchRowcode": "+        )"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1205,
                "PatchRowcode": "+        self.project_id = PROVIDERS.resource_api.create_project("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1206,
                "PatchRowcode": "+            project['id'], project"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1207,
                "PatchRowcode": "+        )['id']"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1208,
                "PatchRowcode": "+        PROVIDERS.assignment_api.create_grant("
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1209,
                "PatchRowcode": "+            self.bootstrapper.member_role_id, user_id=self.user_id,"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1210,
                "PatchRowcode": "+            project_id=self.project_id"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1211,
                "PatchRowcode": "+        )"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1212,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1213,
                "PatchRowcode": "+        auth = self.build_authentication_request("
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1214,
                "PatchRowcode": "+            user_id=self.user_id,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1215,
                "PatchRowcode": "+            password=project_member['password'],"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1216,
                "PatchRowcode": "+            project_id=self.project_id"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1217,
                "PatchRowcode": "+        )"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1218,
                "PatchRowcode": "+"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1219,
                "PatchRowcode": "+        # Grab a token using the persona we're testing and prepare headers"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1220,
                "PatchRowcode": "+        # for requests we'll be making in the tests."
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1221,
                "PatchRowcode": "+        with self.test_client() as c:"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1222,
                "PatchRowcode": "+            r = c.post('/v3/auth/tokens', json=auth)"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1223,
                "PatchRowcode": "+            self.token_id = r.headers['X-Subject-Token']"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1224,
                "PatchRowcode": "+            self.headers = {'X-Auth-Token': self.token_id}"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1225,
                "PatchRowcode": "+"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1226,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1227,
                "PatchRowcode": "+class ProjectAdminTestsEnforceScopeFalse(base_classes.TestCaseWithBootstrap,"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1228,
                "PatchRowcode": "+                                         common_auth.AuthTestMixin,"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1229,
                "PatchRowcode": "+                                         _UserCredentialTests,"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1230,
                "PatchRowcode": "+                                         _SystemUserCredentialTests):"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1231,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1232,
                "PatchRowcode": "+    def setUp(self):"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1233,
                "PatchRowcode": "+        super(ProjectAdminTestsEnforceScopeFalse, self).setUp()"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1234,
                "PatchRowcode": "+        self.loadapp()"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1235,
                "PatchRowcode": "+        self.useFixture(ksfixtures.Policy(self.config_fixture))"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1236,
                "PatchRowcode": "+        self.config_fixture.config(group='oslo_policy', enforce_scope=False)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1237,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1238,
                "PatchRowcode": "+        # Reuse the system administrator account created during"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1239,
                "PatchRowcode": "+        # ``keystone-manage bootstrap``"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1240,
                "PatchRowcode": "+        self.user_id = self.bootstrapper.admin_user_id"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1241,
                "PatchRowcode": "+        auth = self.build_authentication_request("
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1242,
                "PatchRowcode": "+            user_id=self.user_id,"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1243,
                "PatchRowcode": "+            password=self.bootstrapper.admin_password,"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1244,
                "PatchRowcode": "+            project_id=self.bootstrapper.project_id"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1245,
                "PatchRowcode": "+        )"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1246,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1247,
                "PatchRowcode": "+        # Grab a token using the persona we're testing and prepare headers"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1248,
                "PatchRowcode": "+        # for requests we'll be making in the tests."
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1249,
                "PatchRowcode": "+        with self.test_client() as c:"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1250,
                "PatchRowcode": "+            r = c.post('/v3/auth/tokens', json=auth)"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1251,
                "PatchRowcode": "+            self.token_id = r.headers['X-Subject-Token']"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1252,
                "PatchRowcode": "+            self.headers = {'X-Auth-Token': self.token_id}"
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import uuid",
            "",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "",
            "from keystone.common.policies import credential as cp",
            "from keystone.common import provider_api",
            "import keystone.conf",
            "from keystone.tests.common import auth as common_auth",
            "from keystone.tests import unit",
            "from keystone.tests.unit import base_classes",
            "from keystone.tests.unit import ksfixtures",
            "from keystone.tests.unit.ksfixtures import temporaryfile",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "",
            "class _UserCredentialTests(object):",
            "    \"\"\"Test cases for anyone that has a valid user token.\"\"\"",
            "",
            "    def test_user_can_create_credentials_for_themselves(self):",
            "        create = {",
            "            'credential': {",
            "                'blob': uuid.uuid4().hex,",
            "                'user_id': self.user_id,",
            "                'type': uuid.uuid4().hex",
            "            }",
            "        }",
            "        with self.test_client() as c:",
            "            c.post('/v3/credentials', json=create, headers=self.headers)",
            "",
            "    def test_user_can_get_their_credentials(self):",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=self.headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            path = '/v3/credentials/%s' % credential_id",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(",
            "                self.user_id, r.json['credential']['user_id']",
            "            )",
            "",
            "    def test_user_can_list_their_credentials(self):",
            "        with self.test_client() as c:",
            "            expected = []",
            "            for _ in range(2):",
            "                create = {",
            "                    'credential': {",
            "                        'blob': uuid.uuid4().hex,",
            "                        'type': uuid.uuid4().hex,",
            "                        'user_id': self.user_id",
            "                    }",
            "                }",
            "                r = c.post(",
            "                    '/v3/credentials', json=create, headers=self.headers",
            "                )",
            "                expected.append(r.json['credential'])",
            "",
            "            r = c.get('/v3/credentials', headers=self.headers)",
            "            for credential in expected:",
            "                self.assertIn(credential, r.json['credentials'])",
            "",
            "    def test_user_can_filter_their_credentials_by_type_and_user(self):",
            "        with self.test_client() as c:",
            "            credential_type = uuid.uuid4().hex",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': credential_type,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post(",
            "                '/v3/credentials', json=create, headers=self.headers",
            "            )",
            "            expected_credential_id = r.json['credential']['id']",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post(",
            "                '/v3/credentials', json=create, headers=self.headers",
            "            )",
            "",
            "            path = '/v3/credentials?type=%s' % credential_type",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(",
            "                expected_credential_id, r.json['credentials'][0]['id']",
            "            )",
            "",
            "            path = '/v3/credentials?user=%s' % self.user_id",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(",
            "                expected_credential_id, r.json['credentials'][0]['id']",
            "            )",
            "",
            "    def test_user_can_update_their_credential(self):",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "",
            "            r = c.post('/v3/credentials', json=create, headers=self.headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            updated_blob = uuid.uuid4().hex",
            "            update = {'credential': {'blob': updated_blob}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            r = c.patch(path, json=update, headers=self.headers)",
            "            self.assertEqual(updated_blob, r.json['credential']['blob'])",
            "",
            "    def test_user_can_delete_their_credentials(self):",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=self.headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(path, headers=self.headers)",
            "",
            "",
            "class _ProjectUsersTests(object):",
            "    \"\"\"Users who have project role authorization observe the same behavior.\"\"\"",
            "",
            "    def test_user_cannot_get_credentials_for_other_users(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.get(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_get_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.get(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_list_credentials_for_other_users(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=headers)",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?user_id=%s' % user['id']",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual([], r.json['credentials'])",
            "",
            "    def test_user_cannot_filter_credentials_by_type_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        credential_type = uuid.uuid4().hex",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': credential_type,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=headers)",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?type=%s' % credential_type",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(0, len(r.json['credentials']))",
            "",
            "    def test_user_cannot_filter_credentials_by_user_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            expected_cred_ids = []",
            "            for _ in range(2):",
            "                create = {",
            "                    'credential': {",
            "                        'blob': uuid.uuid4().hex,",
            "                        'type': uuid.uuid4().hex,",
            "                        'user_id': user['id']",
            "                    }",
            "                }",
            "                r = c.post('/v3/credentials', json=create, headers=headers)",
            "                expected_cred_ids.append(r.json['credential']['id'])",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?user_id=%s' % user['id']",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual([], r.json['credentials'])",
            "",
            "    def test_user_cannot_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.patch(",
            "                path, json=update, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post(",
            "                '/v3/credentials', json=create, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "",
            "class _SystemUserCredentialTests(object):",
            "    \"\"\"Tests that are common across all system users.\"\"\"",
            "",
            "    def test_user_can_list_credentials_for_other_users(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            r = c.get('/v3/credentials', headers=self.headers)",
            "            self.assertEqual(1, len(r.json['credentials']))",
            "            self.assertEqual(credential_id, r.json['credentials'][0]['id'])",
            "            self.assertEqual(user['id'], r.json['credentials'][0]['user_id'])",
            "",
            "    def test_user_cannot_get_non_existant_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            c.get(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.NOT_FOUND",
            "            )",
            "",
            "    def test_user_can_filter_credentials_by_type_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        credential_type = uuid.uuid4().hex",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': credential_type,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=headers)",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?type=%s' % credential_type",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(1, len(r.json['credentials']))",
            "            self.assertEqual(credential_id, r.json['credentials'][0]['id'])",
            "            self.assertEqual(user['id'], r.json['credentials'][0]['user_id'])",
            "",
            "    def test_user_can_filter_credentials_by_user_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            expected_cred_ids = []",
            "            for _ in range(2):",
            "                create = {",
            "                    'credential': {",
            "                        'blob': uuid.uuid4().hex,",
            "                        'type': uuid.uuid4().hex,",
            "                        'user_id': user['id']",
            "                    }",
            "                }",
            "                r = c.post('/v3/credentials', json=create, headers=headers)",
            "                expected_cred_ids.append(r.json['credential']['id'])",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?user_id=%s' % user['id']",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(2, len(r.json['credentials']))",
            "            for credential in r.json['credentials']:",
            "                self.assertIn(credential['id'], expected_cred_ids)",
            "                self.assertEqual(user['id'], credential['user_id'])",
            "",
            "",
            "class SystemReaderTests(base_classes.TestCaseWithBootstrap,",
            "                        common_auth.AuthTestMixin,",
            "                        _UserCredentialTests,",
            "                        _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(SystemReaderTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        system_reader = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            system_reader",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_system_grant_for_user(",
            "            self.user_id, self.bootstrapper.reader_role_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id, password=system_reader['password'],",
            "            system=True",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def test_user_cannot_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post(",
            "                '/v3/credentials', json=create, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.patch(",
            "                path, json=update, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "",
            "class SystemMemberTests(base_classes.TestCaseWithBootstrap,",
            "                        common_auth.AuthTestMixin,",
            "                        _UserCredentialTests,",
            "                        _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(SystemMemberTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        system_member = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            system_member",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_system_grant_for_user(",
            "            self.user_id, self.bootstrapper.member_role_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id, password=system_member['password'],",
            "            system=True",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def test_user_cannot_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post(",
            "                '/v3/credentials', json=create, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.patch(",
            "                path, json=update, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "",
            "class SystemAdminTests(base_classes.TestCaseWithBootstrap,",
            "                       common_auth.AuthTestMixin,",
            "                       _UserCredentialTests,",
            "                       _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(SystemAdminTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        # Reuse the system administrator account created during",
            "        # ``keystone-manage bootstrap``",
            "        self.user_id = self.bootstrapper.admin_user_id",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.bootstrapper.admin_password,",
            "            system=True",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def test_user_can_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=self.headers)",
            "",
            "    def test_user_can_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            updated_blob = uuid.uuid4().hex",
            "            update = {'credential': {'blob': updated_blob}}",
            "            r = c.patch(path, json=update, headers=self.headers)",
            "            self.assertEqual(updated_blob, r.json['credential']['blob'])",
            "            self.assertEqual(user['id'], r.json['credential']['user_id'])",
            "",
            "    def test_user_cannot_update_non_existant_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.NOT_FOUND",
            "            )",
            "",
            "    def test_user_can_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(path, headers=self.headers)",
            "",
            "    def test_user_cannot_delete_non_existant_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.NOT_FOUND",
            "            )",
            "",
            "",
            "class ProjectReaderTests(base_classes.TestCaseWithBootstrap,",
            "                         common_auth.AuthTestMixin,",
            "                         _UserCredentialTests,",
            "                         _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectReaderTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        project_reader = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            project_reader",
            "        )['id']",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.project_id = PROVIDERS.resource_api.create_project(",
            "            project['id'], project",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.reader_role_id, user_id=self.user_id,",
            "            project_id=self.project_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=project_reader['password'],",
            "            project_id=self.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "",
            "class ProjectMemberTests(base_classes.TestCaseWithBootstrap,",
            "                         common_auth.AuthTestMixin,",
            "                         _UserCredentialTests,",
            "                         _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectMemberTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        project_member = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            project_member",
            "        )['id']",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.project_id = PROVIDERS.resource_api.create_project(",
            "            project['id'], project",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=self.user_id,",
            "            project_id=self.project_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=project_member['password'],",
            "            project_id=self.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "",
            "class ProjectAdminTests(base_classes.TestCaseWithBootstrap,",
            "                        common_auth.AuthTestMixin,",
            "                        _UserCredentialTests,",
            "                        _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectAdminTests, self).setUp()",
            "        self.loadapp()",
            "",
            "        self.policy_file = self.useFixture(temporaryfile.SecureTempFile())",
            "        self.policy_file_name = self.policy_file.file_name",
            "        self.useFixture(",
            "            ksfixtures.Policy(",
            "                self.config_fixture, policy_file=self.policy_file_name",
            "            )",
            "        )",
            "        self._override_policy()",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        # Reuse the system administrator account created during",
            "        # ``keystone-manage bootstrap``",
            "        self.user_id = self.bootstrapper.admin_user_id",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.bootstrapper.admin_password,",
            "            project_id=self.bootstrapper.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def _override_policy(self):",
            "        # TODO(lbragstad): Remove this once the deprecated policies in",
            "        # keystone.common.policies.credentials have been removed. This is only",
            "        # here to make sure we test the new policies instead of the deprecated",
            "        # ones. Oslo.policy will OR deprecated policies with new policies to",
            "        # maintain compatibility and give operators a chance to update",
            "        # permissions or update policies without breaking users. This will",
            "        # cause these specific tests to fail since we're trying to correct this",
            "        # broken behavior with better scope checking.",
            "        with open(self.policy_file_name, 'w') as f:",
            "            overridden_policies = {",
            "                'identity:get_credential': cp.SYSTEM_READER_OR_CRED_OWNER,",
            "                'identity:list_credentials': cp.SYSTEM_READER_OR_CRED_OWNER,",
            "                'identity:create_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER,",
            "                'identity:update_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER,",
            "                'identity:delete_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER",
            "            }",
            "            f.write(jsonutils.dumps(overridden_policies))"
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import uuid",
            "",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "",
            "from keystone.common.policies import credential as cp",
            "from keystone.common import provider_api",
            "import keystone.conf",
            "from keystone.tests.common import auth as common_auth",
            "from keystone.tests import unit",
            "from keystone.tests.unit import base_classes",
            "from keystone.tests.unit import ksfixtures",
            "from keystone.tests.unit.ksfixtures import temporaryfile",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "",
            "class _UserCredentialTests(object):",
            "    \"\"\"Test cases for anyone that has a valid user token.\"\"\"",
            "",
            "    def test_user_can_create_credentials_for_themselves(self):",
            "        create = {",
            "            'credential': {",
            "                'blob': uuid.uuid4().hex,",
            "                'user_id': self.user_id,",
            "                'type': uuid.uuid4().hex",
            "            }",
            "        }",
            "        with self.test_client() as c:",
            "            c.post('/v3/credentials', json=create, headers=self.headers)",
            "",
            "    def test_user_can_get_their_credentials(self):",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=self.headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            path = '/v3/credentials/%s' % credential_id",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(",
            "                self.user_id, r.json['credential']['user_id']",
            "            )",
            "",
            "    def test_user_can_list_their_credentials(self):",
            "        with self.test_client() as c:",
            "            expected = []",
            "            for _ in range(2):",
            "                create = {",
            "                    'credential': {",
            "                        'blob': uuid.uuid4().hex,",
            "                        'type': uuid.uuid4().hex,",
            "                        'user_id': self.user_id",
            "                    }",
            "                }",
            "                r = c.post(",
            "                    '/v3/credentials', json=create, headers=self.headers",
            "                )",
            "                expected.append(r.json['credential'])",
            "",
            "            r = c.get('/v3/credentials', headers=self.headers)",
            "            for credential in expected:",
            "                self.assertIn(credential, r.json['credentials'])",
            "",
            "    def test_user_can_filter_their_credentials_by_type_and_user(self):",
            "        with self.test_client() as c:",
            "            credential_type = uuid.uuid4().hex",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': credential_type,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post(",
            "                '/v3/credentials', json=create, headers=self.headers",
            "            )",
            "            expected_credential_id = r.json['credential']['id']",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post(",
            "                '/v3/credentials', json=create, headers=self.headers",
            "            )",
            "",
            "            path = '/v3/credentials?type=%s' % credential_type",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(",
            "                expected_credential_id, r.json['credentials'][0]['id']",
            "            )",
            "",
            "            path = '/v3/credentials?user=%s' % self.user_id",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(",
            "                expected_credential_id, r.json['credentials'][0]['id']",
            "            )",
            "",
            "    def test_user_can_update_their_credential(self):",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "",
            "            r = c.post('/v3/credentials', json=create, headers=self.headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            updated_blob = uuid.uuid4().hex",
            "            update = {'credential': {'blob': updated_blob}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            r = c.patch(path, json=update, headers=self.headers)",
            "            self.assertEqual(updated_blob, r.json['credential']['blob'])",
            "",
            "    def test_user_can_delete_their_credentials(self):",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': self.user_id",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=self.headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(path, headers=self.headers)",
            "",
            "",
            "class _ProjectUsersTests(object):",
            "    \"\"\"Users who have project role authorization observe the same behavior.\"\"\"",
            "",
            "    def test_user_cannot_get_credentials_for_other_users(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.get(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_get_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.get(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_list_credentials_for_other_users(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=headers)",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?user_id=%s' % user['id']",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual([], r.json['credentials'])",
            "",
            "    def test_user_cannot_filter_credentials_by_type_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        credential_type = uuid.uuid4().hex",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': credential_type,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=headers)",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?type=%s' % credential_type",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(0, len(r.json['credentials']))",
            "",
            "    def test_user_cannot_filter_credentials_by_user_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            expected_cred_ids = []",
            "            for _ in range(2):",
            "                create = {",
            "                    'credential': {",
            "                        'blob': uuid.uuid4().hex,",
            "                        'type': uuid.uuid4().hex,",
            "                        'user_id': user['id']",
            "                    }",
            "                }",
            "                r = c.post('/v3/credentials', json=create, headers=headers)",
            "                expected_cred_ids.append(r.json['credential']['id'])",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?user_id=%s' % user['id']",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual([], r.json['credentials'])",
            "",
            "    def test_user_cannot_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.patch(",
            "                path, json=update, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post(",
            "                '/v3/credentials', json=create, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "",
            "class _SystemUserCredentialTests(object):",
            "    \"\"\"Tests that are common across all system users.\"\"\"",
            "",
            "    def test_user_can_list_credentials_for_other_users(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            r = c.get('/v3/credentials', headers=self.headers)",
            "            self.assertEqual(1, len(r.json['credentials']))",
            "            self.assertEqual(credential_id, r.json['credentials'][0]['id'])",
            "            self.assertEqual(user['id'], r.json['credentials'][0]['user_id'])",
            "",
            "    def test_user_cannot_get_non_existant_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            c.get(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.NOT_FOUND",
            "            )",
            "",
            "    def test_user_can_filter_credentials_by_type_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        credential_type = uuid.uuid4().hex",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': credential_type,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=headers)",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?type=%s' % credential_type",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(1, len(r.json['credentials']))",
            "            self.assertEqual(credential_id, r.json['credentials'][0]['id'])",
            "            self.assertEqual(user['id'], r.json['credentials'][0]['user_id'])",
            "",
            "    def test_user_can_filter_credentials_by_user_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            expected_cred_ids = []",
            "            for _ in range(2):",
            "                create = {",
            "                    'credential': {",
            "                        'blob': uuid.uuid4().hex,",
            "                        'type': uuid.uuid4().hex,",
            "                        'user_id': user['id']",
            "                    }",
            "                }",
            "                r = c.post('/v3/credentials', json=create, headers=headers)",
            "                expected_cred_ids.append(r.json['credential']['id'])",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials?user_id=%s' % user['id']",
            "            r = c.get(path, headers=self.headers)",
            "            self.assertEqual(2, len(r.json['credentials']))",
            "            for credential in r.json['credentials']:",
            "                self.assertIn(credential['id'], expected_cred_ids)",
            "                self.assertEqual(user['id'], credential['user_id'])",
            "",
            "",
            "class SystemReaderTests(base_classes.TestCaseWithBootstrap,",
            "                        common_auth.AuthTestMixin,",
            "                        _UserCredentialTests,",
            "                        _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(SystemReaderTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        system_reader = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            system_reader",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_system_grant_for_user(",
            "            self.user_id, self.bootstrapper.reader_role_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id, password=system_reader['password'],",
            "            system=True",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def test_user_cannot_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post(",
            "                '/v3/credentials', json=create, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.patch(",
            "                path, json=update, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "",
            "class SystemMemberTests(base_classes.TestCaseWithBootstrap,",
            "                        common_auth.AuthTestMixin,",
            "                        _UserCredentialTests,",
            "                        _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(SystemMemberTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        system_member = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            system_member",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_system_grant_for_user(",
            "            self.user_id, self.bootstrapper.member_role_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id, password=system_member['password'],",
            "            system=True",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def test_user_cannot_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post(",
            "                '/v3/credentials', json=create, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.patch(",
            "                path, json=update, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_update_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(",
            "                path, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "    def test_user_cannot_delete_non_existant_credential_forbidden(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.FORBIDDEN",
            "            )",
            "",
            "",
            "class SystemAdminTests(base_classes.TestCaseWithBootstrap,",
            "                       common_auth.AuthTestMixin,",
            "                       _UserCredentialTests,",
            "                       _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(SystemAdminTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        # Reuse the system administrator account created during",
            "        # ``keystone-manage bootstrap``",
            "        self.user_id = self.bootstrapper.admin_user_id",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.bootstrapper.admin_password,",
            "            system=True",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def test_user_can_create_credentials_for_other_users(self):",
            "        user = PROVIDERS.identity_api.create_user(",
            "            unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            c.post('/v3/credentials', json=create, headers=self.headers)",
            "",
            "    def test_user_can_update_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            updated_blob = uuid.uuid4().hex",
            "            update = {'credential': {'blob': updated_blob}}",
            "            r = c.patch(path, json=update, headers=self.headers)",
            "            self.assertEqual(updated_blob, r.json['credential']['blob'])",
            "            self.assertEqual(user['id'], r.json['credential']['user_id'])",
            "",
            "    def test_user_cannot_update_non_existant_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            update = {'credential': {'blob': uuid.uuid4().hex}}",
            "",
            "            c.patch(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, json=update,",
            "                headers=self.headers,",
            "                expected_status_code=http_client.NOT_FOUND",
            "            )",
            "",
            "    def test_user_can_delete_credentials_for_others(self):",
            "        user = unit.new_user_ref(domain_id=CONF.identity.default_domain_id)",
            "        user_password = user['password']",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        project = PROVIDERS.resource_api.create_project(project['id'], project)",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=user['id'],",
            "            project_id=project['id']",
            "        )",
            "        user_auth = self.build_authentication_request(",
            "            user_id=user['id'], password=user_password,",
            "            project_id=project['id']",
            "        )",
            "",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=user_auth)",
            "            token_id = r.headers['X-Subject-Token']",
            "            headers = {'X-Auth-Token': token_id}",
            "",
            "            create = {",
            "                'credential': {",
            "                    'blob': uuid.uuid4().hex,",
            "                    'type': uuid.uuid4().hex,",
            "                    'user_id': user['id']",
            "                }",
            "            }",
            "            r = c.post('/v3/credentials', json=create, headers=headers)",
            "            credential_id = r.json['credential']['id']",
            "",
            "        with self.test_client() as c:",
            "            path = '/v3/credentials/%s' % credential_id",
            "            c.delete(path, headers=self.headers)",
            "",
            "    def test_user_cannot_delete_non_existant_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            c.delete(",
            "                '/v3/credentials/%s' % uuid.uuid4().hex, headers=self.headers,",
            "                expected_status_code=http_client.NOT_FOUND",
            "            )",
            "",
            "",
            "class ProjectReaderTests(base_classes.TestCaseWithBootstrap,",
            "                         common_auth.AuthTestMixin,",
            "                         _UserCredentialTests,",
            "                         _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectReaderTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        project_reader = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            project_reader",
            "        )['id']",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.project_id = PROVIDERS.resource_api.create_project(",
            "            project['id'], project",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.reader_role_id, user_id=self.user_id,",
            "            project_id=self.project_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=project_reader['password'],",
            "            project_id=self.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "",
            "class ProjectMemberTests(base_classes.TestCaseWithBootstrap,",
            "                         common_auth.AuthTestMixin,",
            "                         _UserCredentialTests,",
            "                         _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectMemberTests, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        project_member = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            project_member",
            "        )['id']",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.project_id = PROVIDERS.resource_api.create_project(",
            "            project['id'], project",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=self.user_id,",
            "            project_id=self.project_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=project_member['password'],",
            "            project_id=self.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "",
            "class ProjectAdminTests(base_classes.TestCaseWithBootstrap,",
            "                        common_auth.AuthTestMixin,",
            "                        _UserCredentialTests,",
            "                        _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectAdminTests, self).setUp()",
            "        self.loadapp()",
            "",
            "        self.policy_file = self.useFixture(temporaryfile.SecureTempFile())",
            "        self.policy_file_name = self.policy_file.file_name",
            "        self.useFixture(",
            "            ksfixtures.Policy(",
            "                self.config_fixture, policy_file=self.policy_file_name",
            "            )",
            "        )",
            "        self._override_policy()",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=True)",
            "",
            "        # Reuse the system administrator account created during",
            "        # ``keystone-manage bootstrap``",
            "        self.user_id = self.bootstrapper.admin_user_id",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.bootstrapper.admin_password,",
            "            project_id=self.bootstrapper.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "    def _override_policy(self):",
            "        # TODO(lbragstad): Remove this once the deprecated policies in",
            "        # keystone.common.policies.credentials have been removed. This is only",
            "        # here to make sure we test the new policies instead of the deprecated",
            "        # ones. Oslo.policy will OR deprecated policies with new policies to",
            "        # maintain compatibility and give operators a chance to update",
            "        # permissions or update policies without breaking users. This will",
            "        # cause these specific tests to fail since we're trying to correct this",
            "        # broken behavior with better scope checking.",
            "        with open(self.policy_file_name, 'w') as f:",
            "            overridden_policies = {",
            "                'identity:get_credential': cp.SYSTEM_READER_OR_CRED_OWNER,",
            "                'identity:list_credentials': cp.SYSTEM_READER_OR_CRED_OWNER,",
            "                'identity:create_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER,",
            "                'identity:update_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER,",
            "                'identity:delete_credential': cp.SYSTEM_ADMIN_OR_CRED_OWNER",
            "            }",
            "            f.write(jsonutils.dumps(overridden_policies))",
            "",
            "",
            "class ProjectReaderTestsEnforceScopeFalse(base_classes.TestCaseWithBootstrap,",
            "                                          common_auth.AuthTestMixin,",
            "                                          _UserCredentialTests,",
            "                                          _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectReaderTestsEnforceScopeFalse, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=False)",
            "",
            "        project_reader = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            project_reader",
            "        )['id']",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.project_id = PROVIDERS.resource_api.create_project(",
            "            project['id'], project",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.reader_role_id, user_id=self.user_id,",
            "            project_id=self.project_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=project_reader['password'],",
            "            project_id=self.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "",
            "class ProjectMemberTestsEnforceScopeFalse(base_classes.TestCaseWithBootstrap,",
            "                                          common_auth.AuthTestMixin,",
            "                                          _UserCredentialTests,",
            "                                          _ProjectUsersTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectMemberTestsEnforceScopeFalse, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=False)",
            "",
            "        project_member = unit.new_user_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.user_id = PROVIDERS.identity_api.create_user(",
            "            project_member",
            "        )['id']",
            "        project = unit.new_project_ref(",
            "            domain_id=CONF.identity.default_domain_id",
            "        )",
            "        self.project_id = PROVIDERS.resource_api.create_project(",
            "            project['id'], project",
            "        )['id']",
            "        PROVIDERS.assignment_api.create_grant(",
            "            self.bootstrapper.member_role_id, user_id=self.user_id,",
            "            project_id=self.project_id",
            "        )",
            "",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=project_member['password'],",
            "            project_id=self.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}",
            "",
            "",
            "class ProjectAdminTestsEnforceScopeFalse(base_classes.TestCaseWithBootstrap,",
            "                                         common_auth.AuthTestMixin,",
            "                                         _UserCredentialTests,",
            "                                         _SystemUserCredentialTests):",
            "",
            "    def setUp(self):",
            "        super(ProjectAdminTestsEnforceScopeFalse, self).setUp()",
            "        self.loadapp()",
            "        self.useFixture(ksfixtures.Policy(self.config_fixture))",
            "        self.config_fixture.config(group='oslo_policy', enforce_scope=False)",
            "",
            "        # Reuse the system administrator account created during",
            "        # ``keystone-manage bootstrap``",
            "        self.user_id = self.bootstrapper.admin_user_id",
            "        auth = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.bootstrapper.admin_password,",
            "            project_id=self.bootstrapper.project_id",
            "        )",
            "",
            "        # Grab a token using the persona we're testing and prepare headers",
            "        # for requests we'll be making in the tests.",
            "        with self.test_client() as c:",
            "            r = c.post('/v3/auth/tokens', json=auth)",
            "            self.token_id = r.headers['X-Subject-Token']",
            "            self.headers = {'X-Auth-Token': self.token_id}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "numpy.lib.tests.test_io.TestFromTxt"
        ]
    }
}