{
    "tensorflow/python/ops/bincount_ops_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from tensorflow.python.framework import errors"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from tensorflow.python.framework import ops"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from tensorflow.python.framework import sparse_tensor"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from tensorflow.python.framework import test_util"
            },
            "4": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from tensorflow.python.ops import bincount_ops"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+from tensorflow.python.ops import gen_count_ops"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from tensorflow.python.ops import sparse_ops"
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from tensorflow.python.ops.ragged import ragged_factory_ops"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from tensorflow.python.ops.ragged import ragged_tensor"
            },
            "9": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": 836,
                "PatchRowcode": "       self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))"
            },
            "10": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": 837,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 836,
                "afterPatchRowNumber": 838,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 839,
                "PatchRowcode": "+@test_util.run_all_in_graph_and_eager_modes"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+@test_util.disable_tfrt"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 841,
                "PatchRowcode": "+class RawOpsTest(test.TestCase, parameterized.TestCase):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 843,
                "PatchRowcode": "+  def testSparseCountSparseOutputBadIndicesShape(self):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 844,
                "PatchRowcode": "+    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 845,
                "PatchRowcode": "+    values = [1, 1, 1, 10]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 846,
                "PatchRowcode": "+    weights = [1, 2, 4, 6]"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 847,
                "PatchRowcode": "+    dense_shape = [2, 3]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 848,
                "PatchRowcode": "+    with self.assertRaisesRegex(errors.InvalidArgumentError,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 849,
                "PatchRowcode": "+                                \"Input indices must be a 2-dimensional tensor\"):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 850,
                "PatchRowcode": "+      self.evaluate("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 851,
                "PatchRowcode": "+          gen_count_ops.SparseCountSparseOutput("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 852,
                "PatchRowcode": "+              indices=indices,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 853,
                "PatchRowcode": "+              values=values,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 854,
                "PatchRowcode": "+              dense_shape=dense_shape,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 855,
                "PatchRowcode": "+              weights=weights,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 856,
                "PatchRowcode": "+              binary_output=False))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 857,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 858,
                "PatchRowcode": "+  def testSparseCountSparseOutputBadWeightsShape(self):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 859,
                "PatchRowcode": "+    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 860,
                "PatchRowcode": "+    values = [1, 1, 1, 10]"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 861,
                "PatchRowcode": "+    weights = [1, 2, 4]"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 862,
                "PatchRowcode": "+    dense_shape = [2, 3]"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 863,
                "PatchRowcode": "+    with self.assertRaisesRegex(errors.InvalidArgumentError,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+                                \"Weights and values must have the same shape\"):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 865,
                "PatchRowcode": "+      self.evaluate("
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 866,
                "PatchRowcode": "+          gen_count_ops.SparseCountSparseOutput("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 867,
                "PatchRowcode": "+              indices=indices,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 868,
                "PatchRowcode": "+              values=values,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 869,
                "PatchRowcode": "+              dense_shape=dense_shape,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 870,
                "PatchRowcode": "+              weights=weights,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 871,
                "PatchRowcode": "+              binary_output=False))"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 872,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 873,
                "PatchRowcode": "+  def testSparseCountSparseOutputBadNumberOfValues(self):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 874,
                "PatchRowcode": "+    indices = [[0, 0], [0, 1], [1, 0]]"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 875,
                "PatchRowcode": "+    values = [1, 1, 1, 10]"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+    weights = [1, 2, 4, 6]"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 877,
                "PatchRowcode": "+    dense_shape = [2, 3]"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 878,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 879,
                "PatchRowcode": "+        errors.InvalidArgumentError,"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 880,
                "PatchRowcode": "+        \"Number of values must match first dimension of indices\"):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 881,
                "PatchRowcode": "+      self.evaluate("
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 882,
                "PatchRowcode": "+          gen_count_ops.SparseCountSparseOutput("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 883,
                "PatchRowcode": "+              indices=indices,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 884,
                "PatchRowcode": "+              values=values,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 885,
                "PatchRowcode": "+              dense_shape=dense_shape,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 886,
                "PatchRowcode": "+              weights=weights,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+              binary_output=False))"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 888,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 889,
                "PatchRowcode": "+  def testRaggedCountSparseOutput(self):"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 890,
                "PatchRowcode": "+    splits = [0, 4, 7]"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 891,
                "PatchRowcode": "+    values = [1, 1, 2, 1, 2, 10, 5]"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 892,
                "PatchRowcode": "+    weights = [1, 2, 3, 4, 5, 6, 7]"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 893,
                "PatchRowcode": "+    output_indices, output_values, output_shape = self.evaluate("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 894,
                "PatchRowcode": "+        gen_count_ops.RaggedCountSparseOutput("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 895,
                "PatchRowcode": "+            splits=splits, values=values, weights=weights, binary_output=False))"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 896,
                "PatchRowcode": "+    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 897,
                "PatchRowcode": "+                        output_indices)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 898,
                "PatchRowcode": "+    self.assertAllEqual([7, 3, 5, 7, 6], output_values)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 899,
                "PatchRowcode": "+    self.assertAllEqual([2, 11], output_shape)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 900,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 901,
                "PatchRowcode": "+  def testRaggedCountSparseOutputBadWeightsShape(self):"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 902,
                "PatchRowcode": "+    splits = [0, 4, 7]"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 903,
                "PatchRowcode": "+    values = [1, 1, 2, 1, 2, 10, 5]"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 904,
                "PatchRowcode": "+    weights = [1, 2, 3, 4, 5, 6]"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 905,
                "PatchRowcode": "+    with self.assertRaisesRegex(errors.InvalidArgumentError,"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 906,
                "PatchRowcode": "+                                \"Weights and values must have the same shape\"):"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 907,
                "PatchRowcode": "+      self.evaluate("
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 908,
                "PatchRowcode": "+          gen_count_ops.RaggedCountSparseOutput("
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 909,
                "PatchRowcode": "+              splits=splits,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 910,
                "PatchRowcode": "+              values=values,"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 911,
                "PatchRowcode": "+              weights=weights,"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 912,
                "PatchRowcode": "+              binary_output=False))"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 913,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 914,
                "PatchRowcode": "+  def testRaggedCountSparseOutputEmptySplits(self):"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 915,
                "PatchRowcode": "+    splits = []"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 916,
                "PatchRowcode": "+    values = [1, 1, 2, 1, 2, 10, 5]"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 917,
                "PatchRowcode": "+    weights = [1, 2, 3, 4, 5, 6, 7]"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 918,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 919,
                "PatchRowcode": "+        errors.InvalidArgumentError,"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 920,
                "PatchRowcode": "+        \"Must provide at least 2 elements for the splits argument\"):"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 921,
                "PatchRowcode": "+      self.evaluate("
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 922,
                "PatchRowcode": "+          gen_count_ops.RaggedCountSparseOutput("
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 923,
                "PatchRowcode": "+              splits=splits,"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 924,
                "PatchRowcode": "+              values=values,"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 925,
                "PatchRowcode": "+              weights=weights,"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 926,
                "PatchRowcode": "+              binary_output=False))"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 927,
                "PatchRowcode": "+"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 928,
                "PatchRowcode": "+  def testRaggedCountSparseOutputBadSplitsStart(self):"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 929,
                "PatchRowcode": "+    splits = [1, 7]"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 930,
                "PatchRowcode": "+    values = [1, 1, 2, 1, 2, 10, 5]"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 931,
                "PatchRowcode": "+    weights = [1, 2, 3, 4, 5, 6, 7]"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 932,
                "PatchRowcode": "+    with self.assertRaisesRegex(errors.InvalidArgumentError,"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 933,
                "PatchRowcode": "+                                \"Splits must start with 0\"):"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 934,
                "PatchRowcode": "+      self.evaluate("
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 935,
                "PatchRowcode": "+          gen_count_ops.RaggedCountSparseOutput("
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 936,
                "PatchRowcode": "+              splits=splits,"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 937,
                "PatchRowcode": "+              values=values,"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 938,
                "PatchRowcode": "+              weights=weights,"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 939,
                "PatchRowcode": "+              binary_output=False))"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 940,
                "PatchRowcode": "+"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 941,
                "PatchRowcode": "+  def testRaggedCountSparseOutputBadSplitsEnd(self):"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 942,
                "PatchRowcode": "+    splits = [0, 5]"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 943,
                "PatchRowcode": "+    values = [1, 1, 2, 1, 2, 10, 5]"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 944,
                "PatchRowcode": "+    weights = [1, 2, 3, 4, 5, 6, 7]"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 945,
                "PatchRowcode": "+    with self.assertRaisesRegex(errors.InvalidArgumentError,"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 946,
                "PatchRowcode": "+                                \"Splits must end with the number of values\"):"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 947,
                "PatchRowcode": "+      self.evaluate("
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 948,
                "PatchRowcode": "+          gen_count_ops.RaggedCountSparseOutput("
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 949,
                "PatchRowcode": "+              splits=splits,"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 950,
                "PatchRowcode": "+              values=values,"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 951,
                "PatchRowcode": "+              weights=weights,"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 952,
                "PatchRowcode": "+              binary_output=False))"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 953,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 954,
                "PatchRowcode": "+"
            },
            "128": {
                "beforePatchRowNumber": 837,
                "afterPatchRowNumber": 955,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "129": {
                "beforePatchRowNumber": 838,
                "afterPatchRowNumber": 956,
                "PatchRowcode": "   test.main()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# maxlengthations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for bincount ops.\"\"\"",
            "",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import print_function",
            "",
            "from absl.testing import parameterized",
            "import numpy as np",
            "",
            "from tensorflow.python.eager import context",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.ops import bincount_ops",
            "from tensorflow.python.ops import sparse_ops",
            "from tensorflow.python.ops.ragged import ragged_factory_ops",
            "from tensorflow.python.ops.ragged import ragged_tensor",
            "from tensorflow.python.platform import test",
            "",
            "",
            "class TestSparseCount(test.TestCase, parameterized.TestCase):",
            "",
            "  @parameterized.named_parameters(",
            "      {",
            "          \"testcase_name\": \"_no_maxlength\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [2, 6]",
            "      }, {",
            "          \"testcase_name\": \"_maxlength\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
            "          \"expected_values\": [1, 1, 1, 1, 2],",
            "          \"expected_shape\": [2, 7]",
            "      }, {",
            "          \"testcase_name\": \"_minlength\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [2, 9]",
            "      }, {",
            "          \"testcase_name\": \"_minlength_larger_values\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [2, 8]",
            "      }, {",
            "          \"testcase_name\": \"_no_maxlength_binary\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 6],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_maxlength_binary\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 7],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_minlength_binary\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 9],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_minlength_larger_values_binary\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 8],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_no_maxlength_weights\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
            "          \"expected_values\": [2, 1, 0.5, 9, 3],",
            "          \"expected_shape\": [2, 6],",
            "          \"weights\": [[0.5, 1, 2], [3, 4, 5]]",
            "      }, {",
            "          \"testcase_name\": \"_maxlength_weights\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
            "          \"expected_values\": [2, 1, 0.5, 3, 9],",
            "          \"expected_shape\": [2, 7],",
            "          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]",
            "      }, {",
            "          \"testcase_name\": \"_minlength_weights\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],",
            "          \"expected_shape\": [2, 9],",
            "          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]",
            "      }, {",
            "          \"testcase_name\": \"_minlength_larger_values_weights\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],",
            "          \"expected_shape\": [2, 8],",
            "          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]",
            "      }, {",
            "          \"testcase_name\": \"_1d\",",
            "          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),",
            "          \"expected_indices\": [[1], [2], [3]],",
            "          \"expected_values\": [2, 1, 1],",
            "          \"expected_shape\": [4]",
            "      }, {",
            "          \"testcase_name\": \"_all_axes\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[1], [2], [3], [4], [5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [6],",
            "          \"axis\": None",
            "      })",
            "  def test_dense_input(self,",
            "                       x,",
            "                       expected_indices,",
            "                       expected_values,",
            "                       expected_shape,",
            "                       minlength=None,",
            "                       maxlength=None,",
            "                       binary_output=False,",
            "                       weights=None,",
            "                       axis=-1):",
            "    y = bincount_ops.sparse_bincount(",
            "        x,",
            "        weights=weights,",
            "        minlength=minlength,",
            "        maxlength=maxlength,",
            "        binary_output=binary_output,",
            "        axis=axis)",
            "    self.assertAllEqual(expected_indices, y.indices)",
            "    self.assertAllEqual(expected_values, y.values)",
            "    self.assertAllEqual(expected_shape, y.dense_shape)",
            "",
            "  @parameterized.named_parameters(",
            "      {",
            "          \"testcase_name\":",
            "              \"_no_maxlength\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 2, 1],",
            "          \"expected_shape\": [3, 6],",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_maxlength\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 2, 1],",
            "          \"expected_shape\": [3, 7],",
            "          \"maxlength\":",
            "              7,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [3, 9],",
            "          \"minlength\":",
            "              9,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_larger_values\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [3, 8],",
            "          \"minlength\":",
            "              3,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_no_maxlength_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1],",
            "          \"expected_shape\": [3, 6],",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_maxlength_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1],",
            "          \"expected_shape\": [3, 7],",
            "          \"maxlength\":",
            "              7,",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [3, 9],",
            "          \"minlength\":",
            "              9,",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_larger_values_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [3, 8],",
            "          \"minlength\":",
            "              3,",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_no_maxlength_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 7, 10],",
            "          \"expected_shape\": [3, 6],",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_maxlength_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 7, 10],",
            "          \"expected_shape\": [3, 7],",
            "          \"maxlength\":",
            "              7,",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 14, 6.5, 10],",
            "          \"expected_shape\": [3, 9],",
            "          \"minlength\":",
            "              9,",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_larger_values_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 14, 6.5, 10],",
            "          \"expected_shape\": [3, 8],",
            "          \"minlength\":",
            "              3,",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\": \"_1d\",",
            "          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),",
            "          \"expected_indices\": [[1], [3]],",
            "          \"expected_values\": [2, 1],",
            "          \"expected_shape\": [4],",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_all_axes\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[1], [3], [4], [5]],",
            "          \"expected_values\": [1, 1, 2, 1],",
            "          \"expected_shape\": [6],",
            "          \"axis\":",
            "              None,",
            "      },",
            "  )",
            "  def test_sparse_input(self,",
            "                        x,",
            "                        expected_indices,",
            "                        expected_values,",
            "                        expected_shape,",
            "                        maxlength=None,",
            "                        minlength=None,",
            "                        binary_output=False,",
            "                        weights=None,",
            "                        axis=-1):",
            "    x_sparse = sparse_ops.from_dense(x)",
            "    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None",
            "    y = bincount_ops.sparse_bincount(",
            "        x_sparse,",
            "        weights=w_sparse,",
            "        minlength=minlength,",
            "        maxlength=maxlength,",
            "        binary_output=binary_output,",
            "        axis=axis)",
            "    self.assertAllEqual(expected_indices, y.indices)",
            "    self.assertAllEqual(expected_values, y.values)",
            "    self.assertAllEqual(expected_shape, y.dense_shape)",
            "",
            "  @parameterized.named_parameters(",
            "      {",
            "          \"testcase_name\": \"_no_maxlength\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 6],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_maxlength\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 7],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 9],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_larger_values\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 8],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_no_maxlength_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 6],",
            "          \"binary_output\": True,",
            "      },",
            "      {",
            "          \"testcase_name\": \"_maxlength_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 7],",
            "          \"binary_output\": True,",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 9],",
            "          \"binary_output\": True,",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_larger_values_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 3,",
            "          \"binary_output\": True,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 8],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_no_maxlength_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 6],",
            "          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_maxlength_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 7],",
            "          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 9],",
            "          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_larger_values_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 8],",
            "          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_1d\",",
            "          \"x\": [3, 0, 1, 1],",
            "          \"expected_indices\": [[0], [1], [3]],",
            "          \"expected_values\": [1, 2, 1],",
            "          \"expected_shape\": [4],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_all_axes\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[0], [1], [3], [4], [5]],",
            "          \"expected_values\": [2, 1, 1, 2, 1],",
            "          \"expected_shape\": [6],",
            "          \"axis\": None,",
            "      },",
            "  )",
            "  def test_ragged_input(self,",
            "                        x,",
            "                        expected_indices,",
            "                        expected_values,",
            "                        expected_shape,",
            "                        maxlength=None,",
            "                        minlength=None,",
            "                        binary_output=False,",
            "                        weights=None,",
            "                        axis=-1):",
            "    x_ragged = ragged_factory_ops.constant(x)",
            "    w = ragged_factory_ops.constant(weights) if weights is not None else None",
            "    y = bincount_ops.sparse_bincount(",
            "        x_ragged,",
            "        weights=w,",
            "        minlength=minlength,",
            "        maxlength=maxlength,",
            "        binary_output=binary_output,",
            "        axis=axis)",
            "    self.assertAllEqual(expected_indices, y.indices)",
            "    self.assertAllEqual(expected_values, y.values)",
            "    self.assertAllEqual(expected_shape, y.dense_shape)",
            "",
            "",
            "class TestDenseBincount(test.TestCase, parameterized.TestCase):",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_all_count(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    size = 1000",
            "    n_elems = 4096",
            "    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
            "    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)",
            "    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
            "    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,",
            "                                            [num_rows, 1])",
            "",
            "    np_out = np.bincount(inp_vals, minlength=size)",
            "    self.assertAllEqual(",
            "        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_all_count_with_weights(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    size = 1000",
            "    n_elems = 4096",
            "    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
            "    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)",
            "    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
            "    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,",
            "                                            [num_rows, 1])",
            "    weight_vals = np.random.random((n_elems,))",
            "    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,",
            "                                                [num_rows, 1])",
            "",
            "    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(bincount_ops.bincount(",
            "            sparse_inp, sparse_weights, axis=0)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_all_binary(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    size = 10",
            "    n_elems = 4096",
            "    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
            "    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)",
            "    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
            "    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,",
            "                                            [num_rows, 1])",
            "",
            "    np_out = np.ones((size,))",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_col_reduce_count(self, dtype):",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 100",
            "    np.random.seed(42)",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_out = np.reshape(",
            "        np.concatenate(",
            "            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],",
            "            axis=0), (num_rows, size))",
            "    # from_dense will filter out 0s.",
            "    inp = inp + 1",
            "    # from_dense will cause OOM in GPU.",
            "    with ops.device(\"/CPU:0\"):",
            "      inp_sparse = sparse_ops.from_dense(inp)",
            "      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,",
            "                                              inp_sparse.values - 1,",
            "                                              inp_sparse.dense_shape)",
            "    self.assertAllEqual(",
            "        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_col_reduce_binary(self, dtype):",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 100",
            "    np.random.seed(42)",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_out = np.reshape(",
            "        np.concatenate([",
            "            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)",
            "            for j in range(num_rows)",
            "        ],",
            "                       axis=0), (num_rows, size))",
            "    # from_dense will filter out 0s.",
            "    inp = inp + 1",
            "    # from_dense will cause OOM in GPU.",
            "    with ops.device(\"/CPU:0\"):",
            "      inp_sparse = sparse_ops.from_dense(inp)",
            "      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,",
            "                                              inp_sparse.values - 1,",
            "                                              inp_sparse.dense_shape)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(",
            "            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count(self, dtype):",
            "    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "                                    dtype)",
            "    # pyformat: disable",
            "    expected_output = [",
            "        [0, 0, 0, 0, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 1, 0, 1, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 0, 0, 0, 2, 1]]",
            "    # pyformat: enable",
            "    self.assertAllEqual(expected_output,",
            "                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_binary(self, dtype):",
            "    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])",
            "    # pyformat: disable",
            "    expected_output = [",
            "        [0, 0, 0, 0, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 1, 0, 1, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 0, 0, 0, 1, 1]]",
            "    # pyformat: enable",
            "    self.assertAllEqual(",
            "        expected_output,",
            "        self.evaluate(",
            "            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count_with_weights(self, dtype):",
            "    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])",
            "    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],",
            "                                           [.2, .5, .6, .3]])",
            "    # pyformat: disable",
            "    expected_output = [",
            "        [0, 0, 0, 0, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [.2, .3, 0, .1, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [.5, 0, 0, 0, .9, .2]]",
            "    # pyformat: enable",
            "    self.assertAllClose(",
            "        expected_output,",
            "        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count_np(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 1000",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_out = np.reshape(",
            "        np.concatenate(",
            "            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],",
            "            axis=0), (num_rows, size))",
            "    x = ragged_tensor.RaggedTensor.from_tensor(inp)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count_np_with_weights(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 1000",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_weight = np.random.random((num_rows, num_cols))",
            "    np_out = np.reshape(",
            "        np.concatenate([",
            "            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)",
            "            for j in range(num_rows)",
            "        ],",
            "                       axis=0), (num_rows, size))",
            "    x = ragged_tensor.RaggedTensor.from_tensor(inp)",
            "    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(",
            "            bincount_ops.bincount(",
            "                arr=x, weights=weights, minlength=size, axis=-1)))",
            "",
            "",
            "class TestSparseCountFailureModes(test.TestCase):",
            "",
            "  def test_dense_input_sparse_weights_fails(self):",
            "    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_dense_input_ragged_weights_fails(self):",
            "    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])",
            "    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_dense_input_wrong_shape_fails(self):",
            "    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    weights = np.array([[3, 2], [5, 4], [4, 3]])",
            "    # Note: Eager mode and graph mode throw different errors here. Graph mode",
            "    # will fail with a ValueError from the shape checking logic, while Eager",
            "    # will fail with an InvalidArgumentError from the kernel itself.",
            "    if context.executing_eagerly():",
            "      with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                  \"must have the same shape\"):",
            "        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "    else:",
            "      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):",
            "        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_dense_weights_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_ragged_weights_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])",
            "    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_wrong_indices_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"must have the same indices\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_too_many_indices_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Incompatible shapes\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_wrong_shape_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],",
            "                 dtype=np.int32))",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"must have the same dense shape\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_ragged_input_dense_weights_fails(self):",
            "    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
            "    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_ragged_input_sparse_weights_fails(self):",
            "    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_ragged_input_different_shape_fails(self):",
            "    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
            "    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"must have the same row splits\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# maxlengthations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for bincount ops.\"\"\"",
            "",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import print_function",
            "",
            "from absl.testing import parameterized",
            "import numpy as np",
            "",
            "from tensorflow.python.eager import context",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import bincount_ops",
            "from tensorflow.python.ops import gen_count_ops",
            "from tensorflow.python.ops import sparse_ops",
            "from tensorflow.python.ops.ragged import ragged_factory_ops",
            "from tensorflow.python.ops.ragged import ragged_tensor",
            "from tensorflow.python.platform import test",
            "",
            "",
            "class TestSparseCount(test.TestCase, parameterized.TestCase):",
            "",
            "  @parameterized.named_parameters(",
            "      {",
            "          \"testcase_name\": \"_no_maxlength\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [2, 6]",
            "      }, {",
            "          \"testcase_name\": \"_maxlength\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
            "          \"expected_values\": [1, 1, 1, 1, 2],",
            "          \"expected_shape\": [2, 7]",
            "      }, {",
            "          \"testcase_name\": \"_minlength\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [2, 9]",
            "      }, {",
            "          \"testcase_name\": \"_minlength_larger_values\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [2, 8]",
            "      }, {",
            "          \"testcase_name\": \"_no_maxlength_binary\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 6],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_maxlength_binary\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 7],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_minlength_binary\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 9],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_minlength_larger_values_binary\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [2, 8],",
            "          \"binary_output\": True,",
            "      }, {",
            "          \"testcase_name\": \"_no_maxlength_weights\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],",
            "          \"expected_values\": [2, 1, 0.5, 9, 3],",
            "          \"expected_shape\": [2, 6],",
            "          \"weights\": [[0.5, 1, 2], [3, 4, 5]]",
            "      }, {",
            "          \"testcase_name\": \"_maxlength_weights\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],",
            "          \"expected_values\": [2, 1, 0.5, 3, 9],",
            "          \"expected_shape\": [2, 7],",
            "          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]",
            "      }, {",
            "          \"testcase_name\": \"_minlength_weights\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],",
            "          \"expected_shape\": [2, 9],",
            "          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]",
            "      }, {",
            "          \"testcase_name\": \"_minlength_larger_values_weights\",",
            "          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],",
            "                               [1, 7]],",
            "          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],",
            "          \"expected_shape\": [2, 8],",
            "          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]",
            "      }, {",
            "          \"testcase_name\": \"_1d\",",
            "          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),",
            "          \"expected_indices\": [[1], [2], [3]],",
            "          \"expected_values\": [2, 1, 1],",
            "          \"expected_shape\": [4]",
            "      }, {",
            "          \"testcase_name\": \"_all_axes\",",
            "          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),",
            "          \"expected_indices\": [[1], [2], [3], [4], [5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [6],",
            "          \"axis\": None",
            "      })",
            "  def test_dense_input(self,",
            "                       x,",
            "                       expected_indices,",
            "                       expected_values,",
            "                       expected_shape,",
            "                       minlength=None,",
            "                       maxlength=None,",
            "                       binary_output=False,",
            "                       weights=None,",
            "                       axis=-1):",
            "    y = bincount_ops.sparse_bincount(",
            "        x,",
            "        weights=weights,",
            "        minlength=minlength,",
            "        maxlength=maxlength,",
            "        binary_output=binary_output,",
            "        axis=axis)",
            "    self.assertAllEqual(expected_indices, y.indices)",
            "    self.assertAllEqual(expected_values, y.values)",
            "    self.assertAllEqual(expected_shape, y.dense_shape)",
            "",
            "  @parameterized.named_parameters(",
            "      {",
            "          \"testcase_name\":",
            "              \"_no_maxlength\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 2, 1],",
            "          \"expected_shape\": [3, 6],",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_maxlength\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 2, 1],",
            "          \"expected_shape\": [3, 7],",
            "          \"maxlength\":",
            "              7,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [3, 9],",
            "          \"minlength\":",
            "              9,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_larger_values\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 2, 1],",
            "          \"expected_shape\": [3, 8],",
            "          \"minlength\":",
            "              3,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_no_maxlength_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1],",
            "          \"expected_shape\": [3, 6],",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_maxlength_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1],",
            "          \"expected_shape\": [3, 7],",
            "          \"maxlength\":",
            "              7,",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [3, 9],",
            "          \"minlength\":",
            "              9,",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_larger_values_binary\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1],",
            "          \"expected_shape\": [3, 8],",
            "          \"minlength\":",
            "              3,",
            "          \"binary_output\":",
            "              True,",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_no_maxlength_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 7, 10],",
            "          \"expected_shape\": [3, 6],",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_maxlength_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 7, 10],",
            "          \"expected_shape\": [3, 7],",
            "          \"maxlength\":",
            "              7,",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 14, 6.5, 10],",
            "          \"expected_shape\": [3, 9],",
            "          \"minlength\":",
            "              9,",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_minlength_larger_values_weights\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],",
            "          \"expected_values\": [2, 6, 14, 6.5, 10],",
            "          \"expected_shape\": [3, 8],",
            "          \"minlength\":",
            "              3,",
            "          \"weights\":",
            "              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),",
            "      },",
            "      {",
            "          \"testcase_name\": \"_1d\",",
            "          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),",
            "          \"expected_indices\": [[1], [3]],",
            "          \"expected_values\": [2, 1],",
            "          \"expected_shape\": [4],",
            "      },",
            "      {",
            "          \"testcase_name\":",
            "              \"_all_axes\",",
            "          \"x\":",
            "              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],",
            "                       dtype=np.int32),",
            "          \"expected_indices\": [[1], [3], [4], [5]],",
            "          \"expected_values\": [1, 1, 2, 1],",
            "          \"expected_shape\": [6],",
            "          \"axis\":",
            "              None,",
            "      },",
            "  )",
            "  def test_sparse_input(self,",
            "                        x,",
            "                        expected_indices,",
            "                        expected_values,",
            "                        expected_shape,",
            "                        maxlength=None,",
            "                        minlength=None,",
            "                        binary_output=False,",
            "                        weights=None,",
            "                        axis=-1):",
            "    x_sparse = sparse_ops.from_dense(x)",
            "    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None",
            "    y = bincount_ops.sparse_bincount(",
            "        x_sparse,",
            "        weights=w_sparse,",
            "        minlength=minlength,",
            "        maxlength=maxlength,",
            "        binary_output=binary_output,",
            "        axis=axis)",
            "    self.assertAllEqual(expected_indices, y.indices)",
            "    self.assertAllEqual(expected_values, y.values)",
            "    self.assertAllEqual(expected_shape, y.dense_shape)",
            "",
            "  @parameterized.named_parameters(",
            "      {",
            "          \"testcase_name\": \"_no_maxlength\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 6],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_maxlength\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 7],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 9],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_larger_values\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],",
            "          \"expected_shape\": [5, 8],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_no_maxlength_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 6],",
            "          \"binary_output\": True,",
            "      },",
            "      {",
            "          \"testcase_name\": \"_maxlength_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 7],",
            "          \"binary_output\": True,",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 9],",
            "          \"binary_output\": True,",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_larger_values_binary\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 3,",
            "          \"binary_output\": True,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],",
            "          \"expected_shape\": [5, 8],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_no_maxlength_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 6],",
            "          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_maxlength_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"maxlength\": 7,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 7],",
            "          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 9,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 9],",
            "          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_minlength_larger_values_weights\",",
            "          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],",
            "          \"minlength\": 3,",
            "          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],",
            "                               [4, 5]],",
            "          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],",
            "          \"expected_shape\": [5, 8],",
            "          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_1d\",",
            "          \"x\": [3, 0, 1, 1],",
            "          \"expected_indices\": [[0], [1], [3]],",
            "          \"expected_values\": [1, 2, 1],",
            "          \"expected_shape\": [4],",
            "      },",
            "      {",
            "          \"testcase_name\": \"_all_axes\",",
            "          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "          \"expected_indices\": [[0], [1], [3], [4], [5]],",
            "          \"expected_values\": [2, 1, 1, 2, 1],",
            "          \"expected_shape\": [6],",
            "          \"axis\": None,",
            "      },",
            "  )",
            "  def test_ragged_input(self,",
            "                        x,",
            "                        expected_indices,",
            "                        expected_values,",
            "                        expected_shape,",
            "                        maxlength=None,",
            "                        minlength=None,",
            "                        binary_output=False,",
            "                        weights=None,",
            "                        axis=-1):",
            "    x_ragged = ragged_factory_ops.constant(x)",
            "    w = ragged_factory_ops.constant(weights) if weights is not None else None",
            "    y = bincount_ops.sparse_bincount(",
            "        x_ragged,",
            "        weights=w,",
            "        minlength=minlength,",
            "        maxlength=maxlength,",
            "        binary_output=binary_output,",
            "        axis=axis)",
            "    self.assertAllEqual(expected_indices, y.indices)",
            "    self.assertAllEqual(expected_values, y.values)",
            "    self.assertAllEqual(expected_shape, y.dense_shape)",
            "",
            "",
            "class TestDenseBincount(test.TestCase, parameterized.TestCase):",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_all_count(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    size = 1000",
            "    n_elems = 4096",
            "    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
            "    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)",
            "    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
            "    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,",
            "                                            [num_rows, 1])",
            "",
            "    np_out = np.bincount(inp_vals, minlength=size)",
            "    self.assertAllEqual(",
            "        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_all_count_with_weights(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    size = 1000",
            "    n_elems = 4096",
            "    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
            "    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)",
            "    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
            "    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,",
            "                                            [num_rows, 1])",
            "    weight_vals = np.random.random((n_elems,))",
            "    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,",
            "                                                [num_rows, 1])",
            "",
            "    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(bincount_ops.bincount(",
            "            sparse_inp, sparse_weights, axis=0)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_all_binary(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    size = 10",
            "    n_elems = 4096",
            "    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
            "    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)",
            "    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
            "    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,",
            "                                            [num_rows, 1])",
            "",
            "    np_out = np.ones((size,))",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_col_reduce_count(self, dtype):",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 100",
            "    np.random.seed(42)",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_out = np.reshape(",
            "        np.concatenate(",
            "            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],",
            "            axis=0), (num_rows, size))",
            "    # from_dense will filter out 0s.",
            "    inp = inp + 1",
            "    # from_dense will cause OOM in GPU.",
            "    with ops.device(\"/CPU:0\"):",
            "      inp_sparse = sparse_ops.from_dense(inp)",
            "      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,",
            "                                              inp_sparse.values - 1,",
            "                                              inp_sparse.dense_shape)",
            "    self.assertAllEqual(",
            "        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_sparse_input_col_reduce_binary(self, dtype):",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 100",
            "    np.random.seed(42)",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_out = np.reshape(",
            "        np.concatenate([",
            "            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)",
            "            for j in range(num_rows)",
            "        ],",
            "                       axis=0), (num_rows, size))",
            "    # from_dense will filter out 0s.",
            "    inp = inp + 1",
            "    # from_dense will cause OOM in GPU.",
            "    with ops.device(\"/CPU:0\"):",
            "      inp_sparse = sparse_ops.from_dense(inp)",
            "      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,",
            "                                              inp_sparse.values - 1,",
            "                                              inp_sparse.dense_shape)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(",
            "            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count(self, dtype):",
            "    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],",
            "                                    dtype)",
            "    # pyformat: disable",
            "    expected_output = [",
            "        [0, 0, 0, 0, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 1, 0, 1, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 0, 0, 0, 2, 1]]",
            "    # pyformat: enable",
            "    self.assertAllEqual(expected_output,",
            "                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_binary(self, dtype):",
            "    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])",
            "    # pyformat: disable",
            "    expected_output = [",
            "        [0, 0, 0, 0, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 1, 0, 1, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [1, 0, 0, 0, 1, 1]]",
            "    # pyformat: enable",
            "    self.assertAllEqual(",
            "        expected_output,",
            "        self.evaluate(",
            "            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count_with_weights(self, dtype):",
            "    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])",
            "    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],",
            "                                           [.2, .5, .6, .3]])",
            "    # pyformat: disable",
            "    expected_output = [",
            "        [0, 0, 0, 0, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [.2, .3, 0, .1, 0, 0],",
            "        [0, 0, 0, 0, 0, 0],",
            "        [.5, 0, 0, 0, .9, .2]]",
            "    # pyformat: enable",
            "    self.assertAllClose(",
            "        expected_output,",
            "        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count_np(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 1000",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_out = np.reshape(",
            "        np.concatenate(",
            "            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],",
            "            axis=0), (num_rows, size))",
            "    x = ragged_tensor.RaggedTensor.from_tensor(inp)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))",
            "",
            "  @parameterized.parameters([{",
            "      \"dtype\": np.int32,",
            "  }, {",
            "      \"dtype\": np.int64,",
            "  }])",
            "  def test_ragged_input_count_np_with_weights(self, dtype):",
            "    np.random.seed(42)",
            "    num_rows = 128",
            "    num_cols = 27",
            "    size = 1000",
            "    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)",
            "    np_weight = np.random.random((num_rows, num_cols))",
            "    np_out = np.reshape(",
            "        np.concatenate([",
            "            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)",
            "            for j in range(num_rows)",
            "        ],",
            "                       axis=0), (num_rows, size))",
            "    x = ragged_tensor.RaggedTensor.from_tensor(inp)",
            "    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)",
            "    self.assertAllEqual(",
            "        np_out,",
            "        self.evaluate(",
            "            bincount_ops.bincount(",
            "                arr=x, weights=weights, minlength=size, axis=-1)))",
            "",
            "",
            "class TestSparseCountFailureModes(test.TestCase):",
            "",
            "  def test_dense_input_sparse_weights_fails(self):",
            "    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_dense_input_ragged_weights_fails(self):",
            "    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])",
            "    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_dense_input_wrong_shape_fails(self):",
            "    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    weights = np.array([[3, 2], [5, 4], [4, 3]])",
            "    # Note: Eager mode and graph mode throw different errors here. Graph mode",
            "    # will fail with a ValueError from the shape checking logic, while Eager",
            "    # will fail with an InvalidArgumentError from the kernel itself.",
            "    if context.executing_eagerly():",
            "      with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                  \"must have the same shape\"):",
            "        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "    else:",
            "      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):",
            "        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_dense_weights_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_ragged_weights_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])",
            "    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_wrong_indices_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"must have the same indices\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_too_many_indices_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Incompatible shapes\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_sparse_input_wrong_shape_fails(self):",
            "    x = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],",
            "                 dtype=np.int32))",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"must have the same dense shape\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_ragged_input_dense_weights_fails(self):",
            "    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
            "    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)",
            "    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_ragged_input_sparse_weights_fails(self):",
            "    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
            "    weights = sparse_ops.from_dense(",
            "        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))",
            "    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "  def test_ragged_input_different_shape_fails(self):",
            "    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])",
            "    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"must have the same row splits\"):",
            "      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
            "",
            "",
            "@test_util.run_all_in_graph_and_eager_modes",
            "@test_util.disable_tfrt",
            "class RawOpsTest(test.TestCase, parameterized.TestCase):",
            "",
            "  def testSparseCountSparseOutputBadIndicesShape(self):",
            "    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]",
            "    values = [1, 1, 1, 10]",
            "    weights = [1, 2, 4, 6]",
            "    dense_shape = [2, 3]",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Input indices must be a 2-dimensional tensor\"):",
            "      self.evaluate(",
            "          gen_count_ops.SparseCountSparseOutput(",
            "              indices=indices,",
            "              values=values,",
            "              dense_shape=dense_shape,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "  def testSparseCountSparseOutputBadWeightsShape(self):",
            "    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]",
            "    values = [1, 1, 1, 10]",
            "    weights = [1, 2, 4]",
            "    dense_shape = [2, 3]",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Weights and values must have the same shape\"):",
            "      self.evaluate(",
            "          gen_count_ops.SparseCountSparseOutput(",
            "              indices=indices,",
            "              values=values,",
            "              dense_shape=dense_shape,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "  def testSparseCountSparseOutputBadNumberOfValues(self):",
            "    indices = [[0, 0], [0, 1], [1, 0]]",
            "    values = [1, 1, 1, 10]",
            "    weights = [1, 2, 4, 6]",
            "    dense_shape = [2, 3]",
            "    with self.assertRaisesRegex(",
            "        errors.InvalidArgumentError,",
            "        \"Number of values must match first dimension of indices\"):",
            "      self.evaluate(",
            "          gen_count_ops.SparseCountSparseOutput(",
            "              indices=indices,",
            "              values=values,",
            "              dense_shape=dense_shape,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "  def testRaggedCountSparseOutput(self):",
            "    splits = [0, 4, 7]",
            "    values = [1, 1, 2, 1, 2, 10, 5]",
            "    weights = [1, 2, 3, 4, 5, 6, 7]",
            "    output_indices, output_values, output_shape = self.evaluate(",
            "        gen_count_ops.RaggedCountSparseOutput(",
            "            splits=splits, values=values, weights=weights, binary_output=False))",
            "    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],",
            "                        output_indices)",
            "    self.assertAllEqual([7, 3, 5, 7, 6], output_values)",
            "    self.assertAllEqual([2, 11], output_shape)",
            "",
            "  def testRaggedCountSparseOutputBadWeightsShape(self):",
            "    splits = [0, 4, 7]",
            "    values = [1, 1, 2, 1, 2, 10, 5]",
            "    weights = [1, 2, 3, 4, 5, 6]",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Weights and values must have the same shape\"):",
            "      self.evaluate(",
            "          gen_count_ops.RaggedCountSparseOutput(",
            "              splits=splits,",
            "              values=values,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "  def testRaggedCountSparseOutputEmptySplits(self):",
            "    splits = []",
            "    values = [1, 1, 2, 1, 2, 10, 5]",
            "    weights = [1, 2, 3, 4, 5, 6, 7]",
            "    with self.assertRaisesRegex(",
            "        errors.InvalidArgumentError,",
            "        \"Must provide at least 2 elements for the splits argument\"):",
            "      self.evaluate(",
            "          gen_count_ops.RaggedCountSparseOutput(",
            "              splits=splits,",
            "              values=values,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "  def testRaggedCountSparseOutputBadSplitsStart(self):",
            "    splits = [1, 7]",
            "    values = [1, 1, 2, 1, 2, 10, 5]",
            "    weights = [1, 2, 3, 4, 5, 6, 7]",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Splits must start with 0\"):",
            "      self.evaluate(",
            "          gen_count_ops.RaggedCountSparseOutput(",
            "              splits=splits,",
            "              values=values,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "  def testRaggedCountSparseOutputBadSplitsEnd(self):",
            "    splits = [0, 5]",
            "    values = [1, 1, 2, 1, 2, 10, 5]",
            "    weights = [1, 2, 3, 4, 5, 6, 7]",
            "    with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                \"Splits must end with the number of values\"):",
            "      self.evaluate(",
            "          gen_count_ops.RaggedCountSparseOutput(",
            "              splits=splits,",
            "              values=values,",
            "              weights=weights,",
            "              binary_output=False))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}