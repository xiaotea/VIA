{
    "lib/ansible/cli/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from ansible.utils.collection_loader import AnsibleCollectionLoader, get_collection_name_from_path, set_collection_playbook_paths"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from ansible.utils.display import Display"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from ansible.utils.path import unfrackpath"
            },
            "3": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ansible.utils.unsafe_proxy import AnsibleUnsafeBytes"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from ansible.utils.unsafe_proxy import to_unsafe_text"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from ansible.vars.manager import VariableManager"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " try:"
            },
            "8": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "             if op['ask_pass']:"
            },
            "9": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                 sshpass = getpass.getpass(prompt=\"SSH password: \")"
            },
            "10": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                 become_prompt = \"%s password[defaults to SSH password]: \" % become_prompt_method"
            },
            "11": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if sshpass:"
            },
            "12": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    sshpass = to_bytes(sshpass, errors='strict', nonstring='simplerepr')"
            },
            "13": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "             else:"
            },
            "14": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "                 become_prompt = \"%s password: \" % become_prompt_method"
            },
            "15": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             if op['become_ask_pass']:"
            },
            "17": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "                 becomepass = getpass.getpass(prompt=become_prompt)"
            },
            "18": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "                 if op['ask_pass'] and becomepass == '':"
            },
            "19": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "                     becomepass = sshpass"
            },
            "20": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if becomepass:"
            },
            "21": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    becomepass = to_bytes(becomepass)"
            },
            "22": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         except EOFError:"
            },
            "23": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "             pass"
            },
            "24": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 252,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         # we 'wrap' the passwords to prevent templating as"
            },
            "26": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         # they can contain special chars and trigger it incorrectly"
            },
            "27": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         if sshpass:"
            },
            "28": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            sshpass = AnsibleUnsafeBytes(sshpass)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+            sshpass = to_unsafe_text(sshpass)"
            },
            "30": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         if becomepass:"
            },
            "31": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            becomepass = AnsibleUnsafeBytes(becomepass)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+            becomepass = to_unsafe_text(becomepass)"
            },
            "33": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         return (sshpass, becomepass)"
            },
            "35": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 261,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2016, Toshio Kuratomi <tkuratomi@ansible.com>",
            "# Copyright: (c) 2018, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import getpass",
            "import os",
            "import re",
            "import subprocess",
            "import sys",
            "",
            "from abc import ABCMeta, abstractmethod",
            "",
            "from ansible.cli.arguments import option_helpers as opt_help",
            "from ansible import constants as C",
            "from ansible import context",
            "from ansible.errors import AnsibleError",
            "from ansible.inventory.manager import InventoryManager",
            "from ansible.module_utils.six import with_metaclass, string_types",
            "from ansible.module_utils._text import to_bytes, to_text",
            "from ansible.parsing.dataloader import DataLoader",
            "from ansible.parsing.vault import PromptVaultSecret, get_file_vault_secret",
            "from ansible.plugins.loader import add_all_plugin_dirs",
            "from ansible.release import __version__",
            "from ansible.utils.collection_loader import AnsibleCollectionLoader, get_collection_name_from_path, set_collection_playbook_paths",
            "from ansible.utils.display import Display",
            "from ansible.utils.path import unfrackpath",
            "from ansible.utils.unsafe_proxy import AnsibleUnsafeBytes",
            "from ansible.vars.manager import VariableManager",
            "",
            "try:",
            "    import argcomplete",
            "    HAS_ARGCOMPLETE = True",
            "except ImportError:",
            "    HAS_ARGCOMPLETE = False",
            "",
            "",
            "display = Display()",
            "",
            "",
            "class CLI(with_metaclass(ABCMeta, object)):",
            "    ''' code behind bin/ansible* programs '''",
            "",
            "    _ITALIC = re.compile(r\"I\\(([^)]+)\\)\")",
            "    _BOLD = re.compile(r\"B\\(([^)]+)\\)\")",
            "    _MODULE = re.compile(r\"M\\(([^)]+)\\)\")",
            "    _URL = re.compile(r\"U\\(([^)]+)\\)\")",
            "    _CONST = re.compile(r\"C\\(([^)]+)\\)\")",
            "",
            "    PAGER = 'less'",
            "",
            "    # -F (quit-if-one-screen) -R (allow raw ansi control chars)",
            "    # -S (chop long lines) -X (disable termcap init and de-init)",
            "    LESS_OPTS = 'FRSX'",
            "    SKIP_INVENTORY_DEFAULTS = False",
            "",
            "    def __init__(self, args, callback=None):",
            "        \"\"\"",
            "        Base init method for all command line programs",
            "        \"\"\"",
            "",
            "        if not args:",
            "            raise ValueError('A non-empty list for args is required')",
            "",
            "        self.args = args",
            "        self.parser = None",
            "        self.callback = callback",
            "",
            "    @abstractmethod",
            "    def run(self):",
            "        \"\"\"Run the ansible command",
            "",
            "        Subclasses must implement this method.  It does the actual work of",
            "        running an Ansible command.",
            "        \"\"\"",
            "        self.parse()",
            "",
            "        display.vv(to_text(opt_help.version(self.parser.prog)))",
            "",
            "        if C.CONFIG_FILE:",
            "            display.v(u\"Using %s as config file\" % to_text(C.CONFIG_FILE))",
            "        else:",
            "            display.v(u\"No config file found; using defaults\")",
            "",
            "        # warn about deprecated config options",
            "        for deprecated in C.config.DEPRECATED:",
            "            name = deprecated[0]",
            "            why = deprecated[1]['why']",
            "            if 'alternatives' in deprecated[1]:",
            "                alt = ', use %s instead' % deprecated[1]['alternatives']",
            "            else:",
            "                alt = ''",
            "            ver = deprecated[1]['version']",
            "            display.deprecated(\"%s option, %s %s\" % (name, why, alt), version=ver)",
            "",
            "    @staticmethod",
            "    def split_vault_id(vault_id):",
            "        # return (before_@, after_@)",
            "        # if no @, return whole string as after_",
            "        if '@' not in vault_id:",
            "            return (None, vault_id)",
            "",
            "        parts = vault_id.split('@', 1)",
            "        ret = tuple(parts)",
            "        return ret",
            "",
            "    @staticmethod",
            "    def build_vault_ids(vault_ids, vault_password_files=None,",
            "                        ask_vault_pass=None, create_new_password=None,",
            "                        auto_prompt=True):",
            "        vault_password_files = vault_password_files or []",
            "        vault_ids = vault_ids or []",
            "",
            "        # convert vault_password_files into vault_ids slugs",
            "        for password_file in vault_password_files:",
            "            id_slug = u'%s@%s' % (C.DEFAULT_VAULT_IDENTITY, password_file)",
            "",
            "            # note this makes --vault-id higher precedence than --vault-password-file",
            "            # if we want to intertwingle them in order probably need a cli callback to populate vault_ids",
            "            # used by --vault-id and --vault-password-file",
            "            vault_ids.append(id_slug)",
            "",
            "        # if an action needs an encrypt password (create_new_password=True) and we dont",
            "        # have other secrets setup, then automatically add a password prompt as well.",
            "        # prompts cant/shouldnt work without a tty, so dont add prompt secrets",
            "        if ask_vault_pass or (not vault_ids and auto_prompt):",
            "",
            "            id_slug = u'%s@%s' % (C.DEFAULT_VAULT_IDENTITY, u'prompt_ask_vault_pass')",
            "            vault_ids.append(id_slug)",
            "",
            "        return vault_ids",
            "",
            "    # TODO: remove the now unused args",
            "    @staticmethod",
            "    def setup_vault_secrets(loader, vault_ids, vault_password_files=None,",
            "                            ask_vault_pass=None, create_new_password=False,",
            "                            auto_prompt=True):",
            "        # list of tuples",
            "        vault_secrets = []",
            "",
            "        # Depending on the vault_id value (including how --ask-vault-pass / --vault-password-file create a vault_id)",
            "        # we need to show different prompts. This is for compat with older Towers that expect a",
            "        # certain vault password prompt format, so 'promp_ask_vault_pass' vault_id gets the old format.",
            "        prompt_formats = {}",
            "",
            "        # If there are configured default vault identities, they are considered 'first'",
            "        # so we prepend them to vault_ids (from cli) here",
            "",
            "        vault_password_files = vault_password_files or []",
            "        if C.DEFAULT_VAULT_PASSWORD_FILE:",
            "            vault_password_files.append(C.DEFAULT_VAULT_PASSWORD_FILE)",
            "",
            "        if create_new_password:",
            "            prompt_formats['prompt'] = ['New vault password (%(vault_id)s): ',",
            "                                        'Confirm new vault password (%(vault_id)s): ']",
            "            # 2.3 format prompts for --ask-vault-pass",
            "            prompt_formats['prompt_ask_vault_pass'] = ['New Vault password: ',",
            "                                                       'Confirm New Vault password: ']",
            "        else:",
            "            prompt_formats['prompt'] = ['Vault password (%(vault_id)s): ']",
            "            # The format when we use just --ask-vault-pass needs to match 'Vault password:\\s*?$'",
            "            prompt_formats['prompt_ask_vault_pass'] = ['Vault password: ']",
            "",
            "        vault_ids = CLI.build_vault_ids(vault_ids,",
            "                                        vault_password_files,",
            "                                        ask_vault_pass,",
            "                                        create_new_password,",
            "                                        auto_prompt=auto_prompt)",
            "",
            "        for vault_id_slug in vault_ids:",
            "            vault_id_name, vault_id_value = CLI.split_vault_id(vault_id_slug)",
            "            if vault_id_value in ['prompt', 'prompt_ask_vault_pass']:",
            "",
            "                # --vault-id some_name@prompt_ask_vault_pass --vault-id other_name@prompt_ask_vault_pass will be a little",
            "                # confusing since it will use the old format without the vault id in the prompt",
            "                built_vault_id = vault_id_name or C.DEFAULT_VAULT_IDENTITY",
            "",
            "                # choose the prompt based on --vault-id=prompt or --ask-vault-pass. --ask-vault-pass",
            "                # always gets the old format for Tower compatibility.",
            "                # ie, we used --ask-vault-pass, so we need to use the old vault password prompt",
            "                # format since Tower needs to match on that format.",
            "                prompted_vault_secret = PromptVaultSecret(prompt_formats=prompt_formats[vault_id_value],",
            "                                                          vault_id=built_vault_id)",
            "",
            "                # a empty or invalid password from the prompt will warn and continue to the next",
            "                # without erroring globally",
            "                try:",
            "                    prompted_vault_secret.load()",
            "                except AnsibleError as exc:",
            "                    display.warning('Error in vault password prompt (%s): %s' % (vault_id_name, exc))",
            "                    raise",
            "",
            "                vault_secrets.append((built_vault_id, prompted_vault_secret))",
            "",
            "                # update loader with new secrets incrementally, so we can load a vault password",
            "                # that is encrypted with a vault secret provided earlier",
            "                loader.set_vault_secrets(vault_secrets)",
            "                continue",
            "",
            "            # assuming anything else is a password file",
            "            display.vvvvv('Reading vault password file: %s' % vault_id_value)",
            "            # read vault_pass from a file",
            "            file_vault_secret = get_file_vault_secret(filename=vault_id_value,",
            "                                                      vault_id=vault_id_name,",
            "                                                      loader=loader)",
            "",
            "            # an invalid password file will error globally",
            "            try:",
            "                file_vault_secret.load()",
            "            except AnsibleError as exc:",
            "                display.warning('Error in vault password file loading (%s): %s' % (vault_id_name, to_text(exc)))",
            "                raise",
            "",
            "            if vault_id_name:",
            "                vault_secrets.append((vault_id_name, file_vault_secret))",
            "            else:",
            "                vault_secrets.append((C.DEFAULT_VAULT_IDENTITY, file_vault_secret))",
            "",
            "            # update loader with as-yet-known vault secrets",
            "            loader.set_vault_secrets(vault_secrets)",
            "",
            "        return vault_secrets",
            "",
            "    @staticmethod",
            "    def ask_passwords():",
            "        ''' prompt for connection and become passwords if needed '''",
            "",
            "        op = context.CLIARGS",
            "        sshpass = None",
            "        becomepass = None",
            "        become_prompt = ''",
            "",
            "        become_prompt_method = \"BECOME\" if C.AGNOSTIC_BECOME_PROMPT else op['become_method'].upper()",
            "",
            "        try:",
            "            if op['ask_pass']:",
            "                sshpass = getpass.getpass(prompt=\"SSH password: \")",
            "                become_prompt = \"%s password[defaults to SSH password]: \" % become_prompt_method",
            "                if sshpass:",
            "                    sshpass = to_bytes(sshpass, errors='strict', nonstring='simplerepr')",
            "            else:",
            "                become_prompt = \"%s password: \" % become_prompt_method",
            "",
            "            if op['become_ask_pass']:",
            "                becomepass = getpass.getpass(prompt=become_prompt)",
            "                if op['ask_pass'] and becomepass == '':",
            "                    becomepass = sshpass",
            "                if becomepass:",
            "                    becomepass = to_bytes(becomepass)",
            "        except EOFError:",
            "            pass",
            "",
            "        # we 'wrap' the passwords to prevent templating as",
            "        # they can contain special chars and trigger it incorrectly",
            "        if sshpass:",
            "            sshpass = AnsibleUnsafeBytes(sshpass)",
            "        if becomepass:",
            "            becomepass = AnsibleUnsafeBytes(becomepass)",
            "",
            "        return (sshpass, becomepass)",
            "",
            "    def validate_conflicts(self, op, runas_opts=False, fork_opts=False):",
            "        ''' check for conflicting options '''",
            "",
            "        if fork_opts:",
            "            if op.forks < 1:",
            "                self.parser.error(\"The number of processes (--forks) must be >= 1\")",
            "",
            "        return op",
            "",
            "    @abstractmethod",
            "    def init_parser(self, usage=\"\", desc=None, epilog=None):",
            "        \"\"\"",
            "        Create an options parser for most ansible scripts",
            "",
            "        Subclasses need to implement this method.  They will usually call the base class's",
            "        init_parser to create a basic version and then add their own options on top of that.",
            "",
            "        An implementation will look something like this::",
            "",
            "            def init_parser(self):",
            "                super(MyCLI, self).init_parser(usage=\"My Ansible CLI\", inventory_opts=True)",
            "                ansible.arguments.option_helpers.add_runas_options(self.parser)",
            "                self.parser.add_option('--my-option', dest='my_option', action='store')",
            "        \"\"\"",
            "        self.parser = opt_help.create_base_parser(os.path.basename(self.args[0]), usage=usage, desc=desc, epilog=epilog, )",
            "",
            "    @abstractmethod",
            "    def post_process_args(self, options):",
            "        \"\"\"Process the command line args",
            "",
            "        Subclasses need to implement this method.  This method validates and transforms the command",
            "        line arguments.  It can be used to check whether conflicting values were given, whether filenames",
            "        exist, etc.",
            "",
            "        An implementation will look something like this::",
            "",
            "            def post_process_args(self, options):",
            "                options = super(MyCLI, self).post_process_args(options)",
            "                if options.addition and options.subtraction:",
            "                    raise AnsibleOptionsError('Only one of --addition and --subtraction can be specified')",
            "                if isinstance(options.listofhosts, string_types):",
            "                    options.listofhosts = string_types.split(',')",
            "                return options",
            "        \"\"\"",
            "",
            "        # process tags",
            "        if hasattr(options, 'tags') and not options.tags:",
            "            # optparse defaults does not do what's expected",
            "            options.tags = ['all']",
            "        if hasattr(options, 'tags') and options.tags:",
            "            tags = set()",
            "            for tag_set in options.tags:",
            "                for tag in tag_set.split(u','):",
            "                    tags.add(tag.strip())",
            "            options.tags = list(tags)",
            "",
            "        # process skip_tags",
            "        if hasattr(options, 'skip_tags') and options.skip_tags:",
            "            skip_tags = set()",
            "            for tag_set in options.skip_tags:",
            "                for tag in tag_set.split(u','):",
            "                    skip_tags.add(tag.strip())",
            "            options.skip_tags = list(skip_tags)",
            "",
            "        # process inventory options except for CLIs that require their own processing",
            "        if hasattr(options, 'inventory') and not self.SKIP_INVENTORY_DEFAULTS:",
            "",
            "            if options.inventory:",
            "",
            "                # should always be list",
            "                if isinstance(options.inventory, string_types):",
            "                    options.inventory = [options.inventory]",
            "",
            "                # Ensure full paths when needed",
            "                options.inventory = [unfrackpath(opt, follow=False) if ',' not in opt else opt for opt in options.inventory]",
            "            else:",
            "                options.inventory = C.DEFAULT_HOST_LIST",
            "",
            "        # Dup args set on the root parser and sub parsers results in the root parser ignoring the args. e.g. doing",
            "        # 'ansible-galaxy -vvv init' has no verbosity set but 'ansible-galaxy init -vvv' sets a level of 3. To preserve",
            "        # back compat with pre-argparse changes we manually scan and set verbosity based on the argv values.",
            "        if self.parser.prog in ['ansible-galaxy', 'ansible-vault'] and not options.verbosity:",
            "            verbosity_arg = next(iter([arg for arg in self.args if arg.startswith('-v')]), None)",
            "            if verbosity_arg:",
            "                display.deprecated(\"Setting verbosity before the arg sub command is deprecated, set the verbosity \"",
            "                                   \"after the sub command\", \"2.13\")",
            "                options.verbosity = verbosity_arg.count('v')",
            "",
            "        return options",
            "",
            "    def parse(self):",
            "        \"\"\"Parse the command line args",
            "",
            "        This method parses the command line arguments.  It uses the parser",
            "        stored in the self.parser attribute and saves the args and options in",
            "        context.CLIARGS.",
            "",
            "        Subclasses need to implement two helper methods, init_parser() and post_process_args() which",
            "        are called from this function before and after parsing the arguments.",
            "        \"\"\"",
            "        self.init_parser()",
            "",
            "        if HAS_ARGCOMPLETE:",
            "            argcomplete.autocomplete(self.parser)",
            "",
            "        options = self.parser.parse_args(self.args[1:])",
            "        options = self.post_process_args(options)",
            "        context._init_global_context(options)",
            "",
            "    @staticmethod",
            "    def version_info(gitinfo=False):",
            "        ''' return full ansible version info '''",
            "        if gitinfo:",
            "            # expensive call, user with care",
            "            ansible_version_string = opt_help.version()",
            "        else:",
            "            ansible_version_string = __version__",
            "        ansible_version = ansible_version_string.split()[0]",
            "        ansible_versions = ansible_version.split('.')",
            "        for counter in range(len(ansible_versions)):",
            "            if ansible_versions[counter] == \"\":",
            "                ansible_versions[counter] = 0",
            "            try:",
            "                ansible_versions[counter] = int(ansible_versions[counter])",
            "            except Exception:",
            "                pass",
            "        if len(ansible_versions) < 3:",
            "            for counter in range(len(ansible_versions), 3):",
            "                ansible_versions.append(0)",
            "        return {'string': ansible_version_string.strip(),",
            "                'full': ansible_version,",
            "                'major': ansible_versions[0],",
            "                'minor': ansible_versions[1],",
            "                'revision': ansible_versions[2]}",
            "",
            "    @staticmethod",
            "    def pager(text):",
            "        ''' find reasonable way to display text '''",
            "        # this is a much simpler form of what is in pydoc.py",
            "        if not sys.stdout.isatty():",
            "            display.display(text, screen_only=True)",
            "        elif 'PAGER' in os.environ:",
            "            if sys.platform == 'win32':",
            "                display.display(text, screen_only=True)",
            "            else:",
            "                CLI.pager_pipe(text, os.environ['PAGER'])",
            "        else:",
            "            p = subprocess.Popen('less --version', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "            p.communicate()",
            "            if p.returncode == 0:",
            "                CLI.pager_pipe(text, 'less')",
            "            else:",
            "                display.display(text, screen_only=True)",
            "",
            "    @staticmethod",
            "    def pager_pipe(text, cmd):",
            "        ''' pipe text through a pager '''",
            "        if 'LESS' not in os.environ:",
            "            os.environ['LESS'] = CLI.LESS_OPTS",
            "        try:",
            "            cmd = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=sys.stdout)",
            "            cmd.communicate(input=to_bytes(text))",
            "        except IOError:",
            "            pass",
            "        except KeyboardInterrupt:",
            "            pass",
            "",
            "    @classmethod",
            "    def tty_ify(cls, text):",
            "",
            "        t = cls._ITALIC.sub(\"`\" + r\"\\1\" + \"'\", text)    # I(word) => `word'",
            "        t = cls._BOLD.sub(\"*\" + r\"\\1\" + \"*\", t)         # B(word) => *word*",
            "        t = cls._MODULE.sub(\"[\" + r\"\\1\" + \"]\", t)       # M(word) => [word]",
            "        t = cls._URL.sub(r\"\\1\", t)                      # U(word) => word",
            "        t = cls._CONST.sub(\"`\" + r\"\\1\" + \"'\", t)        # C(word) => `word'",
            "",
            "        return t",
            "",
            "    @staticmethod",
            "    def _play_prereqs():",
            "        options = context.CLIARGS",
            "",
            "        # all needs loader",
            "        loader = DataLoader()",
            "",
            "        basedir = options.get('basedir', False)",
            "        if basedir:",
            "            loader.set_basedir(basedir)",
            "            add_all_plugin_dirs(basedir)",
            "            set_collection_playbook_paths(basedir)",
            "            default_collection = get_collection_name_from_path(basedir)",
            "            if default_collection:",
            "                display.warning(u'running with default collection {0}'.format(default_collection))",
            "                AnsibleCollectionLoader().set_default_collection(default_collection)",
            "",
            "        vault_ids = list(options['vault_ids'])",
            "        default_vault_ids = C.DEFAULT_VAULT_IDENTITY_LIST",
            "        vault_ids = default_vault_ids + vault_ids",
            "",
            "        vault_secrets = CLI.setup_vault_secrets(loader,",
            "                                                vault_ids=vault_ids,",
            "                                                vault_password_files=list(options['vault_password_files']),",
            "                                                ask_vault_pass=options['ask_vault_pass'],",
            "                                                auto_prompt=False)",
            "        loader.set_vault_secrets(vault_secrets)",
            "",
            "        # create the inventory, and filter it based on the subset specified (if any)",
            "        inventory = InventoryManager(loader=loader, sources=options['inventory'])",
            "",
            "        # create the variable manager, which will be shared throughout",
            "        # the code, ensuring a consistent view of global variables",
            "        variable_manager = VariableManager(loader=loader, inventory=inventory, version_info=CLI.version_info(gitinfo=False))",
            "",
            "        return loader, inventory, variable_manager",
            "",
            "    @staticmethod",
            "    def get_host_list(inventory, subset, pattern='all'):",
            "",
            "        no_hosts = False",
            "        if len(inventory.list_hosts()) == 0:",
            "            # Empty inventory",
            "            if C.LOCALHOST_WARNING and pattern not in C.LOCALHOST:",
            "                display.warning(\"provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'\")",
            "            no_hosts = True",
            "",
            "        inventory.subset(subset)",
            "",
            "        hosts = inventory.list_hosts(pattern)",
            "        if not hosts and no_hosts is False:",
            "            raise AnsibleError(\"Specified hosts and/or --limit does not match any hosts\")",
            "",
            "        return hosts"
        ],
        "afterPatchFile": [
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2016, Toshio Kuratomi <tkuratomi@ansible.com>",
            "# Copyright: (c) 2018, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import getpass",
            "import os",
            "import re",
            "import subprocess",
            "import sys",
            "",
            "from abc import ABCMeta, abstractmethod",
            "",
            "from ansible.cli.arguments import option_helpers as opt_help",
            "from ansible import constants as C",
            "from ansible import context",
            "from ansible.errors import AnsibleError",
            "from ansible.inventory.manager import InventoryManager",
            "from ansible.module_utils.six import with_metaclass, string_types",
            "from ansible.module_utils._text import to_bytes, to_text",
            "from ansible.parsing.dataloader import DataLoader",
            "from ansible.parsing.vault import PromptVaultSecret, get_file_vault_secret",
            "from ansible.plugins.loader import add_all_plugin_dirs",
            "from ansible.release import __version__",
            "from ansible.utils.collection_loader import AnsibleCollectionLoader, get_collection_name_from_path, set_collection_playbook_paths",
            "from ansible.utils.display import Display",
            "from ansible.utils.path import unfrackpath",
            "from ansible.utils.unsafe_proxy import to_unsafe_text",
            "from ansible.vars.manager import VariableManager",
            "",
            "try:",
            "    import argcomplete",
            "    HAS_ARGCOMPLETE = True",
            "except ImportError:",
            "    HAS_ARGCOMPLETE = False",
            "",
            "",
            "display = Display()",
            "",
            "",
            "class CLI(with_metaclass(ABCMeta, object)):",
            "    ''' code behind bin/ansible* programs '''",
            "",
            "    _ITALIC = re.compile(r\"I\\(([^)]+)\\)\")",
            "    _BOLD = re.compile(r\"B\\(([^)]+)\\)\")",
            "    _MODULE = re.compile(r\"M\\(([^)]+)\\)\")",
            "    _URL = re.compile(r\"U\\(([^)]+)\\)\")",
            "    _CONST = re.compile(r\"C\\(([^)]+)\\)\")",
            "",
            "    PAGER = 'less'",
            "",
            "    # -F (quit-if-one-screen) -R (allow raw ansi control chars)",
            "    # -S (chop long lines) -X (disable termcap init and de-init)",
            "    LESS_OPTS = 'FRSX'",
            "    SKIP_INVENTORY_DEFAULTS = False",
            "",
            "    def __init__(self, args, callback=None):",
            "        \"\"\"",
            "        Base init method for all command line programs",
            "        \"\"\"",
            "",
            "        if not args:",
            "            raise ValueError('A non-empty list for args is required')",
            "",
            "        self.args = args",
            "        self.parser = None",
            "        self.callback = callback",
            "",
            "    @abstractmethod",
            "    def run(self):",
            "        \"\"\"Run the ansible command",
            "",
            "        Subclasses must implement this method.  It does the actual work of",
            "        running an Ansible command.",
            "        \"\"\"",
            "        self.parse()",
            "",
            "        display.vv(to_text(opt_help.version(self.parser.prog)))",
            "",
            "        if C.CONFIG_FILE:",
            "            display.v(u\"Using %s as config file\" % to_text(C.CONFIG_FILE))",
            "        else:",
            "            display.v(u\"No config file found; using defaults\")",
            "",
            "        # warn about deprecated config options",
            "        for deprecated in C.config.DEPRECATED:",
            "            name = deprecated[0]",
            "            why = deprecated[1]['why']",
            "            if 'alternatives' in deprecated[1]:",
            "                alt = ', use %s instead' % deprecated[1]['alternatives']",
            "            else:",
            "                alt = ''",
            "            ver = deprecated[1]['version']",
            "            display.deprecated(\"%s option, %s %s\" % (name, why, alt), version=ver)",
            "",
            "    @staticmethod",
            "    def split_vault_id(vault_id):",
            "        # return (before_@, after_@)",
            "        # if no @, return whole string as after_",
            "        if '@' not in vault_id:",
            "            return (None, vault_id)",
            "",
            "        parts = vault_id.split('@', 1)",
            "        ret = tuple(parts)",
            "        return ret",
            "",
            "    @staticmethod",
            "    def build_vault_ids(vault_ids, vault_password_files=None,",
            "                        ask_vault_pass=None, create_new_password=None,",
            "                        auto_prompt=True):",
            "        vault_password_files = vault_password_files or []",
            "        vault_ids = vault_ids or []",
            "",
            "        # convert vault_password_files into vault_ids slugs",
            "        for password_file in vault_password_files:",
            "            id_slug = u'%s@%s' % (C.DEFAULT_VAULT_IDENTITY, password_file)",
            "",
            "            # note this makes --vault-id higher precedence than --vault-password-file",
            "            # if we want to intertwingle them in order probably need a cli callback to populate vault_ids",
            "            # used by --vault-id and --vault-password-file",
            "            vault_ids.append(id_slug)",
            "",
            "        # if an action needs an encrypt password (create_new_password=True) and we dont",
            "        # have other secrets setup, then automatically add a password prompt as well.",
            "        # prompts cant/shouldnt work without a tty, so dont add prompt secrets",
            "        if ask_vault_pass or (not vault_ids and auto_prompt):",
            "",
            "            id_slug = u'%s@%s' % (C.DEFAULT_VAULT_IDENTITY, u'prompt_ask_vault_pass')",
            "            vault_ids.append(id_slug)",
            "",
            "        return vault_ids",
            "",
            "    # TODO: remove the now unused args",
            "    @staticmethod",
            "    def setup_vault_secrets(loader, vault_ids, vault_password_files=None,",
            "                            ask_vault_pass=None, create_new_password=False,",
            "                            auto_prompt=True):",
            "        # list of tuples",
            "        vault_secrets = []",
            "",
            "        # Depending on the vault_id value (including how --ask-vault-pass / --vault-password-file create a vault_id)",
            "        # we need to show different prompts. This is for compat with older Towers that expect a",
            "        # certain vault password prompt format, so 'promp_ask_vault_pass' vault_id gets the old format.",
            "        prompt_formats = {}",
            "",
            "        # If there are configured default vault identities, they are considered 'first'",
            "        # so we prepend them to vault_ids (from cli) here",
            "",
            "        vault_password_files = vault_password_files or []",
            "        if C.DEFAULT_VAULT_PASSWORD_FILE:",
            "            vault_password_files.append(C.DEFAULT_VAULT_PASSWORD_FILE)",
            "",
            "        if create_new_password:",
            "            prompt_formats['prompt'] = ['New vault password (%(vault_id)s): ',",
            "                                        'Confirm new vault password (%(vault_id)s): ']",
            "            # 2.3 format prompts for --ask-vault-pass",
            "            prompt_formats['prompt_ask_vault_pass'] = ['New Vault password: ',",
            "                                                       'Confirm New Vault password: ']",
            "        else:",
            "            prompt_formats['prompt'] = ['Vault password (%(vault_id)s): ']",
            "            # The format when we use just --ask-vault-pass needs to match 'Vault password:\\s*?$'",
            "            prompt_formats['prompt_ask_vault_pass'] = ['Vault password: ']",
            "",
            "        vault_ids = CLI.build_vault_ids(vault_ids,",
            "                                        vault_password_files,",
            "                                        ask_vault_pass,",
            "                                        create_new_password,",
            "                                        auto_prompt=auto_prompt)",
            "",
            "        for vault_id_slug in vault_ids:",
            "            vault_id_name, vault_id_value = CLI.split_vault_id(vault_id_slug)",
            "            if vault_id_value in ['prompt', 'prompt_ask_vault_pass']:",
            "",
            "                # --vault-id some_name@prompt_ask_vault_pass --vault-id other_name@prompt_ask_vault_pass will be a little",
            "                # confusing since it will use the old format without the vault id in the prompt",
            "                built_vault_id = vault_id_name or C.DEFAULT_VAULT_IDENTITY",
            "",
            "                # choose the prompt based on --vault-id=prompt or --ask-vault-pass. --ask-vault-pass",
            "                # always gets the old format for Tower compatibility.",
            "                # ie, we used --ask-vault-pass, so we need to use the old vault password prompt",
            "                # format since Tower needs to match on that format.",
            "                prompted_vault_secret = PromptVaultSecret(prompt_formats=prompt_formats[vault_id_value],",
            "                                                          vault_id=built_vault_id)",
            "",
            "                # a empty or invalid password from the prompt will warn and continue to the next",
            "                # without erroring globally",
            "                try:",
            "                    prompted_vault_secret.load()",
            "                except AnsibleError as exc:",
            "                    display.warning('Error in vault password prompt (%s): %s' % (vault_id_name, exc))",
            "                    raise",
            "",
            "                vault_secrets.append((built_vault_id, prompted_vault_secret))",
            "",
            "                # update loader with new secrets incrementally, so we can load a vault password",
            "                # that is encrypted with a vault secret provided earlier",
            "                loader.set_vault_secrets(vault_secrets)",
            "                continue",
            "",
            "            # assuming anything else is a password file",
            "            display.vvvvv('Reading vault password file: %s' % vault_id_value)",
            "            # read vault_pass from a file",
            "            file_vault_secret = get_file_vault_secret(filename=vault_id_value,",
            "                                                      vault_id=vault_id_name,",
            "                                                      loader=loader)",
            "",
            "            # an invalid password file will error globally",
            "            try:",
            "                file_vault_secret.load()",
            "            except AnsibleError as exc:",
            "                display.warning('Error in vault password file loading (%s): %s' % (vault_id_name, to_text(exc)))",
            "                raise",
            "",
            "            if vault_id_name:",
            "                vault_secrets.append((vault_id_name, file_vault_secret))",
            "            else:",
            "                vault_secrets.append((C.DEFAULT_VAULT_IDENTITY, file_vault_secret))",
            "",
            "            # update loader with as-yet-known vault secrets",
            "            loader.set_vault_secrets(vault_secrets)",
            "",
            "        return vault_secrets",
            "",
            "    @staticmethod",
            "    def ask_passwords():",
            "        ''' prompt for connection and become passwords if needed '''",
            "",
            "        op = context.CLIARGS",
            "        sshpass = None",
            "        becomepass = None",
            "        become_prompt = ''",
            "",
            "        become_prompt_method = \"BECOME\" if C.AGNOSTIC_BECOME_PROMPT else op['become_method'].upper()",
            "",
            "        try:",
            "            if op['ask_pass']:",
            "                sshpass = getpass.getpass(prompt=\"SSH password: \")",
            "                become_prompt = \"%s password[defaults to SSH password]: \" % become_prompt_method",
            "            else:",
            "                become_prompt = \"%s password: \" % become_prompt_method",
            "",
            "            if op['become_ask_pass']:",
            "                becomepass = getpass.getpass(prompt=become_prompt)",
            "                if op['ask_pass'] and becomepass == '':",
            "                    becomepass = sshpass",
            "        except EOFError:",
            "            pass",
            "",
            "        # we 'wrap' the passwords to prevent templating as",
            "        # they can contain special chars and trigger it incorrectly",
            "        if sshpass:",
            "            sshpass = to_unsafe_text(sshpass)",
            "        if becomepass:",
            "            becomepass = to_unsafe_text(becomepass)",
            "",
            "        return (sshpass, becomepass)",
            "",
            "    def validate_conflicts(self, op, runas_opts=False, fork_opts=False):",
            "        ''' check for conflicting options '''",
            "",
            "        if fork_opts:",
            "            if op.forks < 1:",
            "                self.parser.error(\"The number of processes (--forks) must be >= 1\")",
            "",
            "        return op",
            "",
            "    @abstractmethod",
            "    def init_parser(self, usage=\"\", desc=None, epilog=None):",
            "        \"\"\"",
            "        Create an options parser for most ansible scripts",
            "",
            "        Subclasses need to implement this method.  They will usually call the base class's",
            "        init_parser to create a basic version and then add their own options on top of that.",
            "",
            "        An implementation will look something like this::",
            "",
            "            def init_parser(self):",
            "                super(MyCLI, self).init_parser(usage=\"My Ansible CLI\", inventory_opts=True)",
            "                ansible.arguments.option_helpers.add_runas_options(self.parser)",
            "                self.parser.add_option('--my-option', dest='my_option', action='store')",
            "        \"\"\"",
            "        self.parser = opt_help.create_base_parser(os.path.basename(self.args[0]), usage=usage, desc=desc, epilog=epilog, )",
            "",
            "    @abstractmethod",
            "    def post_process_args(self, options):",
            "        \"\"\"Process the command line args",
            "",
            "        Subclasses need to implement this method.  This method validates and transforms the command",
            "        line arguments.  It can be used to check whether conflicting values were given, whether filenames",
            "        exist, etc.",
            "",
            "        An implementation will look something like this::",
            "",
            "            def post_process_args(self, options):",
            "                options = super(MyCLI, self).post_process_args(options)",
            "                if options.addition and options.subtraction:",
            "                    raise AnsibleOptionsError('Only one of --addition and --subtraction can be specified')",
            "                if isinstance(options.listofhosts, string_types):",
            "                    options.listofhosts = string_types.split(',')",
            "                return options",
            "        \"\"\"",
            "",
            "        # process tags",
            "        if hasattr(options, 'tags') and not options.tags:",
            "            # optparse defaults does not do what's expected",
            "            options.tags = ['all']",
            "        if hasattr(options, 'tags') and options.tags:",
            "            tags = set()",
            "            for tag_set in options.tags:",
            "                for tag in tag_set.split(u','):",
            "                    tags.add(tag.strip())",
            "            options.tags = list(tags)",
            "",
            "        # process skip_tags",
            "        if hasattr(options, 'skip_tags') and options.skip_tags:",
            "            skip_tags = set()",
            "            for tag_set in options.skip_tags:",
            "                for tag in tag_set.split(u','):",
            "                    skip_tags.add(tag.strip())",
            "            options.skip_tags = list(skip_tags)",
            "",
            "        # process inventory options except for CLIs that require their own processing",
            "        if hasattr(options, 'inventory') and not self.SKIP_INVENTORY_DEFAULTS:",
            "",
            "            if options.inventory:",
            "",
            "                # should always be list",
            "                if isinstance(options.inventory, string_types):",
            "                    options.inventory = [options.inventory]",
            "",
            "                # Ensure full paths when needed",
            "                options.inventory = [unfrackpath(opt, follow=False) if ',' not in opt else opt for opt in options.inventory]",
            "            else:",
            "                options.inventory = C.DEFAULT_HOST_LIST",
            "",
            "        # Dup args set on the root parser and sub parsers results in the root parser ignoring the args. e.g. doing",
            "        # 'ansible-galaxy -vvv init' has no verbosity set but 'ansible-galaxy init -vvv' sets a level of 3. To preserve",
            "        # back compat with pre-argparse changes we manually scan and set verbosity based on the argv values.",
            "        if self.parser.prog in ['ansible-galaxy', 'ansible-vault'] and not options.verbosity:",
            "            verbosity_arg = next(iter([arg for arg in self.args if arg.startswith('-v')]), None)",
            "            if verbosity_arg:",
            "                display.deprecated(\"Setting verbosity before the arg sub command is deprecated, set the verbosity \"",
            "                                   \"after the sub command\", \"2.13\")",
            "                options.verbosity = verbosity_arg.count('v')",
            "",
            "        return options",
            "",
            "    def parse(self):",
            "        \"\"\"Parse the command line args",
            "",
            "        This method parses the command line arguments.  It uses the parser",
            "        stored in the self.parser attribute and saves the args and options in",
            "        context.CLIARGS.",
            "",
            "        Subclasses need to implement two helper methods, init_parser() and post_process_args() which",
            "        are called from this function before and after parsing the arguments.",
            "        \"\"\"",
            "        self.init_parser()",
            "",
            "        if HAS_ARGCOMPLETE:",
            "            argcomplete.autocomplete(self.parser)",
            "",
            "        options = self.parser.parse_args(self.args[1:])",
            "        options = self.post_process_args(options)",
            "        context._init_global_context(options)",
            "",
            "    @staticmethod",
            "    def version_info(gitinfo=False):",
            "        ''' return full ansible version info '''",
            "        if gitinfo:",
            "            # expensive call, user with care",
            "            ansible_version_string = opt_help.version()",
            "        else:",
            "            ansible_version_string = __version__",
            "        ansible_version = ansible_version_string.split()[0]",
            "        ansible_versions = ansible_version.split('.')",
            "        for counter in range(len(ansible_versions)):",
            "            if ansible_versions[counter] == \"\":",
            "                ansible_versions[counter] = 0",
            "            try:",
            "                ansible_versions[counter] = int(ansible_versions[counter])",
            "            except Exception:",
            "                pass",
            "        if len(ansible_versions) < 3:",
            "            for counter in range(len(ansible_versions), 3):",
            "                ansible_versions.append(0)",
            "        return {'string': ansible_version_string.strip(),",
            "                'full': ansible_version,",
            "                'major': ansible_versions[0],",
            "                'minor': ansible_versions[1],",
            "                'revision': ansible_versions[2]}",
            "",
            "    @staticmethod",
            "    def pager(text):",
            "        ''' find reasonable way to display text '''",
            "        # this is a much simpler form of what is in pydoc.py",
            "        if not sys.stdout.isatty():",
            "            display.display(text, screen_only=True)",
            "        elif 'PAGER' in os.environ:",
            "            if sys.platform == 'win32':",
            "                display.display(text, screen_only=True)",
            "            else:",
            "                CLI.pager_pipe(text, os.environ['PAGER'])",
            "        else:",
            "            p = subprocess.Popen('less --version', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "            p.communicate()",
            "            if p.returncode == 0:",
            "                CLI.pager_pipe(text, 'less')",
            "            else:",
            "                display.display(text, screen_only=True)",
            "",
            "    @staticmethod",
            "    def pager_pipe(text, cmd):",
            "        ''' pipe text through a pager '''",
            "        if 'LESS' not in os.environ:",
            "            os.environ['LESS'] = CLI.LESS_OPTS",
            "        try:",
            "            cmd = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=sys.stdout)",
            "            cmd.communicate(input=to_bytes(text))",
            "        except IOError:",
            "            pass",
            "        except KeyboardInterrupt:",
            "            pass",
            "",
            "    @classmethod",
            "    def tty_ify(cls, text):",
            "",
            "        t = cls._ITALIC.sub(\"`\" + r\"\\1\" + \"'\", text)    # I(word) => `word'",
            "        t = cls._BOLD.sub(\"*\" + r\"\\1\" + \"*\", t)         # B(word) => *word*",
            "        t = cls._MODULE.sub(\"[\" + r\"\\1\" + \"]\", t)       # M(word) => [word]",
            "        t = cls._URL.sub(r\"\\1\", t)                      # U(word) => word",
            "        t = cls._CONST.sub(\"`\" + r\"\\1\" + \"'\", t)        # C(word) => `word'",
            "",
            "        return t",
            "",
            "    @staticmethod",
            "    def _play_prereqs():",
            "        options = context.CLIARGS",
            "",
            "        # all needs loader",
            "        loader = DataLoader()",
            "",
            "        basedir = options.get('basedir', False)",
            "        if basedir:",
            "            loader.set_basedir(basedir)",
            "            add_all_plugin_dirs(basedir)",
            "            set_collection_playbook_paths(basedir)",
            "            default_collection = get_collection_name_from_path(basedir)",
            "            if default_collection:",
            "                display.warning(u'running with default collection {0}'.format(default_collection))",
            "                AnsibleCollectionLoader().set_default_collection(default_collection)",
            "",
            "        vault_ids = list(options['vault_ids'])",
            "        default_vault_ids = C.DEFAULT_VAULT_IDENTITY_LIST",
            "        vault_ids = default_vault_ids + vault_ids",
            "",
            "        vault_secrets = CLI.setup_vault_secrets(loader,",
            "                                                vault_ids=vault_ids,",
            "                                                vault_password_files=list(options['vault_password_files']),",
            "                                                ask_vault_pass=options['ask_vault_pass'],",
            "                                                auto_prompt=False)",
            "        loader.set_vault_secrets(vault_secrets)",
            "",
            "        # create the inventory, and filter it based on the subset specified (if any)",
            "        inventory = InventoryManager(loader=loader, sources=options['inventory'])",
            "",
            "        # create the variable manager, which will be shared throughout",
            "        # the code, ensuring a consistent view of global variables",
            "        variable_manager = VariableManager(loader=loader, inventory=inventory, version_info=CLI.version_info(gitinfo=False))",
            "",
            "        return loader, inventory, variable_manager",
            "",
            "    @staticmethod",
            "    def get_host_list(inventory, subset, pattern='all'):",
            "",
            "        no_hosts = False",
            "        if len(inventory.list_hosts()) == 0:",
            "            # Empty inventory",
            "            if C.LOCALHOST_WARNING and pattern not in C.LOCALHOST:",
            "                display.warning(\"provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'\")",
            "            no_hosts = True",
            "",
            "        inventory.subset(subset)",
            "",
            "        hosts = inventory.list_hosts(pattern)",
            "        if not hosts and no_hosts is False:",
            "            raise AnsibleError(\"Specified hosts and/or --limit does not match any hosts\")",
            "",
            "        return hosts"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "32": [],
            "243": [
                "CLI",
                "ask_passwords"
            ],
            "244": [
                "CLI",
                "ask_passwords"
            ],
            "252": [
                "CLI",
                "ask_passwords"
            ],
            "253": [
                "CLI",
                "ask_passwords"
            ],
            "260": [
                "CLI",
                "ask_passwords"
            ],
            "262": [
                "CLI",
                "ask_passwords"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/template/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "             for item in val:"
            },
            "1": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "                 if self._is_unsafe(item):"
            },
            "2": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "                     return True"
            },
            "3": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif isinstance(val, string_types) and hasattr(val, '__UNSAFE__'):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+        elif hasattr(val, '__UNSAFE__'):"
            },
            "5": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "             return True"
            },
            "6": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         return False"
            },
            "7": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import ast",
            "import datetime",
            "import os",
            "import pkgutil",
            "import pwd",
            "import re",
            "import time",
            "",
            "from numbers import Number",
            "",
            "try:",
            "    from hashlib import sha1",
            "except ImportError:",
            "    from sha import sha as sha1",
            "",
            "from jinja2.exceptions import TemplateSyntaxError, UndefinedError",
            "from jinja2.loaders import FileSystemLoader",
            "from jinja2.runtime import Context, StrictUndefined",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError, AnsibleFilterError, AnsibleUndefinedVariable, AnsibleAssertionError",
            "from ansible.module_utils.six import iteritems, string_types, text_type",
            "from ansible.module_utils._text import to_native, to_text, to_bytes",
            "from ansible.module_utils.common._collections_compat import Sequence, Mapping, MutableMapping",
            "from ansible.plugins.loader import filter_loader, lookup_loader, test_loader",
            "from ansible.template.safe_eval import safe_eval",
            "from ansible.template.template import AnsibleJ2Template",
            "from ansible.template.vars import AnsibleJ2Vars",
            "from ansible.utils.collection_loader import AnsibleCollectionRef",
            "from ansible.utils.display import Display",
            "from ansible.utils.unsafe_proxy import wrap_var",
            "",
            "# HACK: keep Python 2.6 controller tests happy in CI until they're properly split",
            "try:",
            "    from importlib import import_module",
            "except ImportError:",
            "    import_module = __import__",
            "",
            "display = Display()",
            "",
            "",
            "__all__ = ['Templar', 'generate_ansible_template_vars']",
            "",
            "# A regex for checking to see if a variable we're trying to",
            "# expand is just a single variable name.",
            "",
            "# Primitive Types which we don't want Jinja to convert to strings.",
            "NON_TEMPLATED_TYPES = (bool, Number)",
            "",
            "JINJA2_OVERRIDE = '#jinja2:'",
            "",
            "USE_JINJA2_NATIVE = False",
            "if C.DEFAULT_JINJA2_NATIVE:",
            "    try:",
            "        from jinja2.nativetypes import NativeEnvironment as Environment",
            "        from ansible.template.native_helpers import ansible_native_concat as j2_concat",
            "        USE_JINJA2_NATIVE = True",
            "    except ImportError:",
            "        from jinja2 import Environment",
            "        from jinja2.utils import concat as j2_concat",
            "        from jinja2 import __version__ as j2_version",
            "        display.warning(",
            "            'jinja2_native requires Jinja 2.10 and above. '",
            "            'Version detected: %s. Falling back to default.' % j2_version",
            "        )",
            "else:",
            "    from jinja2 import Environment",
            "    from jinja2.utils import concat as j2_concat",
            "",
            "",
            "JINJA2_BEGIN_TOKENS = frozenset(('variable_begin', 'block_begin', 'comment_begin', 'raw_begin'))",
            "JINJA2_END_TOKENS = frozenset(('variable_end', 'block_end', 'comment_end', 'raw_end'))",
            "",
            "",
            "def generate_ansible_template_vars(path, dest_path=None):",
            "    b_path = to_bytes(path)",
            "    try:",
            "        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name",
            "    except (KeyError, TypeError):",
            "        template_uid = os.stat(b_path).st_uid",
            "",
            "    temp_vars = {",
            "        'template_host': to_text(os.uname()[1]),",
            "        'template_path': path,",
            "        'template_mtime': datetime.datetime.fromtimestamp(os.path.getmtime(b_path)),",
            "        'template_uid': to_text(template_uid),",
            "        'template_fullpath': os.path.abspath(path),",
            "        'template_run_date': datetime.datetime.now(),",
            "        'template_destpath': to_native(dest_path) if dest_path else None,",
            "    }",
            "",
            "    managed_default = C.DEFAULT_MANAGED_STR",
            "    managed_str = managed_default.format(",
            "        host=temp_vars['template_host'],",
            "        uid=temp_vars['template_uid'],",
            "        file=temp_vars['template_path'],",
            "    )",
            "    temp_vars['ansible_managed'] = to_text(time.strftime(to_native(managed_str), time.localtime(os.path.getmtime(b_path))))",
            "",
            "    return temp_vars",
            "",
            "",
            "def _escape_backslashes(data, jinja_env):",
            "    \"\"\"Double backslashes within jinja2 expressions",
            "",
            "    A user may enter something like this in a playbook::",
            "",
            "      debug:",
            "        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"",
            "",
            "    The string inside of the {{ gets interpreted multiple times First by yaml.",
            "    Then by python.  And finally by jinja2 as part of it's variable.  Because",
            "    it is processed by both python and jinja2, the backslash escaped",
            "    characters get unescaped twice.  This means that we'd normally have to use",
            "    four backslashes to escape that.  This is painful for playbook authors as",
            "    they have to remember different rules for inside vs outside of a jinja2",
            "    expression (The backslashes outside of the \"{{ }}\" only get processed by",
            "    yaml and python.  So they only need to be escaped once).  The following",
            "    code fixes this by automatically performing the extra quoting of",
            "    backslashes inside of a jinja2 expression.",
            "",
            "    \"\"\"",
            "    if '\\\\' in data and '{{' in data:",
            "        new_data = []",
            "        d2 = jinja_env.preprocess(data)",
            "        in_var = False",
            "",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] == 'variable_begin':",
            "                in_var = True",
            "                new_data.append(token[2])",
            "            elif token[1] == 'variable_end':",
            "                in_var = False",
            "                new_data.append(token[2])",
            "            elif in_var and token[1] == 'string':",
            "                # Double backslashes only if we're inside of a jinja2 variable",
            "                new_data.append(token[2].replace('\\\\', '\\\\\\\\'))",
            "            else:",
            "                new_data.append(token[2])",
            "",
            "        data = ''.join(new_data)",
            "",
            "    return data",
            "",
            "",
            "def is_template(data, jinja_env):",
            "    \"\"\"This function attempts to quickly detect whether a value is a jinja2",
            "    template. To do so, we look for the first 2 matching jinja2 tokens for",
            "    start and end delimiters.",
            "    \"\"\"",
            "    found = None",
            "    start = True",
            "    comment = False",
            "    d2 = jinja_env.preprocess(data)",
            "",
            "    # This wraps a lot of code, but this is due to lex returing a generator",
            "    # so we may get an exception at any part of the loop",
            "    try:",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] in JINJA2_BEGIN_TOKENS:",
            "                if start and token[1] == 'comment_begin':",
            "                    # Comments can wrap other token types",
            "                    comment = True",
            "                start = False",
            "                # Example: variable_end -> variable",
            "                found = token[1].split('_')[0]",
            "            elif token[1] in JINJA2_END_TOKENS:",
            "                if token[1].split('_')[0] == found:",
            "                    return True",
            "                elif comment:",
            "                    continue",
            "                return False",
            "    except TemplateSyntaxError:",
            "        return False",
            "",
            "    return False",
            "",
            "",
            "def _count_newlines_from_end(in_str):",
            "    '''",
            "    Counts the number of newlines at the end of a string. This is used during",
            "    the jinja2 templating to ensure the count matches the input, since some newlines",
            "    may be thrown away during the templating.",
            "    '''",
            "",
            "    try:",
            "        i = len(in_str)",
            "        j = i - 1",
            "        while in_str[j] == '\\n':",
            "            j -= 1",
            "        return i - 1 - j",
            "    except IndexError:",
            "        # Uncommon cases: zero length string and string containing only newlines",
            "        return i",
            "",
            "",
            "def recursive_check_defined(item):",
            "    from jinja2.runtime import Undefined",
            "",
            "    if isinstance(item, MutableMapping):",
            "        for key in item:",
            "            recursive_check_defined(item[key])",
            "    elif isinstance(item, list):",
            "        for i in item:",
            "            recursive_check_defined(i)",
            "    else:",
            "        if isinstance(item, Undefined):",
            "            raise AnsibleFilterError(\"{0} is undefined\".format(item))",
            "",
            "",
            "class AnsibleUndefined(StrictUndefined):",
            "    '''",
            "    A custom Undefined class, which returns further Undefined objects on access,",
            "    rather than throwing an exception.",
            "    '''",
            "    def __getattr__(self, name):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __getitem__(self, key):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __repr__(self):",
            "        return 'AnsibleUndefined'",
            "",
            "",
            "class AnsibleContext(Context):",
            "    '''",
            "    A custom context, which intercepts resolve() calls and sets a flag",
            "    internally if any variable lookup returns an AnsibleUnsafe value. This",
            "    flag is checked post-templating, and (when set) will result in the",
            "    final templated result being wrapped in AnsibleUnsafe.",
            "    '''",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleContext, self).__init__(*args, **kwargs)",
            "        self.unsafe = False",
            "",
            "    def _is_unsafe(self, val):",
            "        '''",
            "        Our helper function, which will also recursively check dict and",
            "        list entries due to the fact that they may be repr'd and contain",
            "        a key or value which contains jinja2 syntax and would otherwise",
            "        lose the AnsibleUnsafe value.",
            "        '''",
            "        if isinstance(val, dict):",
            "            for key in val.keys():",
            "                if self._is_unsafe(val[key]):",
            "                    return True",
            "        elif isinstance(val, list):",
            "            for item in val:",
            "                if self._is_unsafe(item):",
            "                    return True",
            "        elif isinstance(val, string_types) and hasattr(val, '__UNSAFE__'):",
            "            return True",
            "        return False",
            "",
            "    def _update_unsafe(self, val):",
            "        if val is not None and not self.unsafe and self._is_unsafe(val):",
            "            self.unsafe = True",
            "",
            "    def resolve(self, key):",
            "        '''",
            "        The intercepted resolve(), which uses the helper above to set the",
            "        internal flag whenever an unsafe variable value is returned.",
            "        '''",
            "        val = super(AnsibleContext, self).resolve(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "    def resolve_or_missing(self, key):",
            "        val = super(AnsibleContext, self).resolve_or_missing(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "",
            "class JinjaPluginIntercept(MutableMapping):",
            "    def __init__(self, delegatee, pluginloader, *args, **kwargs):",
            "        super(JinjaPluginIntercept, self).__init__(*args, **kwargs)",
            "        self._delegatee = delegatee",
            "        self._pluginloader = pluginloader",
            "",
            "        if self._pluginloader.class_name == 'FilterModule':",
            "            self._method_map_name = 'filters'",
            "            self._dirname = 'filter'",
            "        elif self._pluginloader.class_name == 'TestModule':",
            "            self._method_map_name = 'tests'",
            "            self._dirname = 'test'",
            "",
            "        self._collection_jinja_func_cache = {}",
            "",
            "    # FUTURE: we can cache FQ filter/test calls for the entire duration of a run, since a given collection's impl's",
            "    # aren't supposed to change during a run",
            "    def __getitem__(self, key):",
            "        if not isinstance(key, string_types):",
            "            raise ValueError('key must be a string')",
            "",
            "        key = to_native(key)",
            "",
            "        if '.' not in key:  # might be a built-in value, delegate to base dict",
            "            return self._delegatee.__getitem__(key)",
            "",
            "        func = self._collection_jinja_func_cache.get(key)",
            "",
            "        if func:",
            "            return func",
            "",
            "        acr = AnsibleCollectionRef.try_parse_fqcr(key, self._dirname)",
            "",
            "        if not acr:",
            "            raise KeyError('invalid plugin name: {0}'.format(key))",
            "",
            "        # FIXME: error handling for bogus plugin name, bogus impl, bogus filter/test",
            "",
            "        pkg = import_module(acr.n_python_package_name)",
            "",
            "        parent_prefix = acr.collection",
            "",
            "        if acr.subdirs:",
            "            parent_prefix = '{0}.{1}'.format(parent_prefix, acr.subdirs)",
            "",
            "        for dummy, module_name, ispkg in pkgutil.iter_modules(pkg.__path__, prefix=parent_prefix + '.'):",
            "            if ispkg:",
            "                continue",
            "",
            "            plugin_impl = self._pluginloader.get(module_name)",
            "",
            "            method_map = getattr(plugin_impl, self._method_map_name)",
            "",
            "            for f in iteritems(method_map()):",
            "                fq_name = '.'.join((parent_prefix, f[0]))",
            "                # FIXME: detect/warn on intra-collection function name collisions",
            "                self._collection_jinja_func_cache[fq_name] = f[1]",
            "",
            "        function_impl = self._collection_jinja_func_cache[key]",
            "        return function_impl",
            "",
            "    def __setitem__(self, key, value):",
            "        return self._delegatee.__setitem__(key, value)",
            "",
            "    def __delitem__(self, key):",
            "        raise NotImplementedError()",
            "",
            "    def __iter__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return iter(self._delegatee)",
            "",
            "    def __len__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return len(self._delegatee)",
            "",
            "",
            "class AnsibleEnvironment(Environment):",
            "    '''",
            "    Our custom environment, which simply allows us to override the class-level",
            "    values for the Template and Context classes used by jinja2 internally.",
            "    '''",
            "    context_class = AnsibleContext",
            "    template_class = AnsibleJ2Template",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleEnvironment, self).__init__(*args, **kwargs)",
            "",
            "        self.filters = JinjaPluginIntercept(self.filters, filter_loader)",
            "        self.tests = JinjaPluginIntercept(self.tests, test_loader)",
            "",
            "",
            "class Templar:",
            "    '''",
            "    The main class for templating, with the main entry-point of template().",
            "    '''",
            "",
            "    def __init__(self, loader, shared_loader_obj=None, variables=None):",
            "        variables = {} if variables is None else variables",
            "",
            "        self._loader = loader",
            "        self._filters = None",
            "        self._tests = None",
            "        self._available_variables = variables",
            "        self._cached_result = {}",
            "",
            "        if loader:",
            "            self._basedir = loader.get_basedir()",
            "        else:",
            "            self._basedir = './'",
            "",
            "        if shared_loader_obj:",
            "            self._filter_loader = getattr(shared_loader_obj, 'filter_loader')",
            "            self._test_loader = getattr(shared_loader_obj, 'test_loader')",
            "            self._lookup_loader = getattr(shared_loader_obj, 'lookup_loader')",
            "        else:",
            "            self._filter_loader = filter_loader",
            "            self._test_loader = test_loader",
            "            self._lookup_loader = lookup_loader",
            "",
            "        # flags to determine whether certain failures during templating",
            "        # should result in fatal errors being raised",
            "        self._fail_on_lookup_errors = True",
            "        self._fail_on_filter_errors = True",
            "        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR",
            "",
            "        self.environment = AnsibleEnvironment(",
            "            trim_blocks=True,",
            "            undefined=AnsibleUndefined,",
            "            extensions=self._get_extensions(),",
            "            finalize=self._finalize,",
            "            loader=FileSystemLoader(self._basedir),",
            "        )",
            "",
            "        # the current rendering context under which the templar class is working",
            "        self.cur_context = None",
            "",
            "        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))",
            "",
            "        self._clean_regex = re.compile(r'(?:%s|%s|%s|%s)' % (",
            "            self.environment.variable_start_string,",
            "            self.environment.block_start_string,",
            "            self.environment.block_end_string,",
            "            self.environment.variable_end_string",
            "        ))",
            "        self._no_type_regex = re.compile(r'.*?\\|\\s*(?:%s)(?:\\([^\\|]*\\))?\\s*\\)?\\s*(?:%s)' %",
            "                                         ('|'.join(C.STRING_TYPE_FILTERS), self.environment.variable_end_string))",
            "",
            "    def _get_filters(self):",
            "        '''",
            "        Returns filter plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._filters is not None:",
            "            return self._filters.copy()",
            "",
            "        self._filters = dict()",
            "",
            "        for fp in self._filter_loader.all():",
            "            self._filters.update(fp.filters())",
            "",
            "        return self._filters.copy()",
            "",
            "    def _get_tests(self):",
            "        '''",
            "        Returns tests plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._tests is not None:",
            "            return self._tests.copy()",
            "",
            "        self._tests = dict()",
            "        for fp in self._test_loader.all():",
            "            self._tests.update(fp.tests())",
            "",
            "        return self._tests.copy()",
            "",
            "    def _get_extensions(self):",
            "        '''",
            "        Return jinja2 extensions to load.",
            "",
            "        If some extensions are set via jinja_extensions in ansible.cfg, we try",
            "        to load them with the jinja environment.",
            "        '''",
            "",
            "        jinja_exts = []",
            "        if C.DEFAULT_JINJA2_EXTENSIONS:",
            "            # make sure the configuration directive doesn't contain spaces",
            "            # and split extensions in an array",
            "            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')",
            "",
            "        return jinja_exts",
            "",
            "    @property",
            "    def available_variables(self):",
            "        return self._available_variables",
            "",
            "    @available_variables.setter",
            "    def available_variables(self, variables):",
            "        '''",
            "        Sets the list of template variables this Templar instance will use",
            "        to template things, so we don't have to pass them around between",
            "        internal methods. We also clear the template cache here, as the variables",
            "        are being changed.",
            "        '''",
            "",
            "        if not isinstance(variables, dict):",
            "            raise AnsibleAssertionError(\"the type of 'variables' should be a dict but was a %s\" % (type(variables)))",
            "        self._available_variables = variables",
            "        self._cached_result = {}",
            "",
            "    def set_available_variables(self, variables):",
            "        display.deprecated(",
            "            'set_available_variables is being deprecated. Use \"@available_variables.setter\" instead.',",
            "            version='2.13'",
            "        )",
            "        self.available_variables = variables",
            "",
            "    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None,",
            "                 convert_data=True, static_vars=None, cache=True, disable_lookups=False):",
            "        '''",
            "        Templates (possibly recursively) any given data as input. If convert_bare is",
            "        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')",
            "        before being sent through the template engine.",
            "        '''",
            "        static_vars = [''] if static_vars is None else static_vars",
            "",
            "        # Don't template unsafe variables, just return them.",
            "        if hasattr(variable, '__UNSAFE__'):",
            "            return variable",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            if convert_bare:",
            "                variable = self._convert_bare_variable(variable)",
            "",
            "            if isinstance(variable, string_types):",
            "                result = variable",
            "",
            "                if self.is_possibly_template(variable):",
            "                    # Check to see if the string we are trying to render is just referencing a single",
            "                    # var.  In this case we don't want to accidentally change the type of the variable",
            "                    # to a string by using the jinja template renderer. We just want to pass it.",
            "                    only_one = self.SINGLE_VAR.match(variable)",
            "                    if only_one:",
            "                        var_name = only_one.group(1)",
            "                        if var_name in self._available_variables:",
            "                            resolved_val = self._available_variables[var_name]",
            "                            if isinstance(resolved_val, NON_TEMPLATED_TYPES):",
            "                                return resolved_val",
            "                            elif resolved_val is None:",
            "                                return C.DEFAULT_NULL_REPRESENTATION",
            "",
            "                    # Using a cache in order to prevent template calls with already templated variables",
            "                    sha1_hash = None",
            "                    if cache:",
            "                        variable_hash = sha1(text_type(variable).encode('utf-8'))",
            "                        options_hash = sha1(",
            "                            (",
            "                                text_type(preserve_trailing_newlines) +",
            "                                text_type(escape_backslashes) +",
            "                                text_type(fail_on_undefined) +",
            "                                text_type(overrides)",
            "                            ).encode('utf-8')",
            "                        )",
            "                        sha1_hash = variable_hash.hexdigest() + options_hash.hexdigest()",
            "                    if cache and sha1_hash in self._cached_result:",
            "                        result = self._cached_result[sha1_hash]",
            "                    else:",
            "                        result = self.do_template(",
            "                            variable,",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            escape_backslashes=escape_backslashes,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                        )",
            "",
            "                        if not USE_JINJA2_NATIVE:",
            "                            unsafe = hasattr(result, '__UNSAFE__')",
            "                            if convert_data and not self._no_type_regex.match(variable):",
            "                                # if this looks like a dictionary or list, convert it to such using the safe_eval method",
            "                                if (result.startswith(\"{\") and not result.startswith(self.environment.variable_start_string)) or \\",
            "                                        result.startswith(\"[\") or result in (\"True\", \"False\"):",
            "                                    eval_results = safe_eval(result, include_exceptions=True)",
            "                                    if eval_results[1] is None:",
            "                                        result = eval_results[0]",
            "                                        if unsafe:",
            "                                            result = wrap_var(result)",
            "                                    else:",
            "                                        # FIXME: if the safe_eval raised an error, should we do something with it?",
            "                                        pass",
            "",
            "                        # we only cache in the case where we have a single variable",
            "                        # name, to make sure we're not putting things which may otherwise",
            "                        # be dynamic in the cache (filters, lookups, etc.)",
            "                        if cache:",
            "                            self._cached_result[sha1_hash] = result",
            "",
            "                return result",
            "",
            "            elif isinstance(variable, (list, tuple)):",
            "                return [self.template(",
            "                    v,",
            "                    preserve_trailing_newlines=preserve_trailing_newlines,",
            "                    fail_on_undefined=fail_on_undefined,",
            "                    overrides=overrides,",
            "                    disable_lookups=disable_lookups,",
            "                ) for v in variable]",
            "            elif isinstance(variable, (dict, Mapping)):",
            "                d = {}",
            "                # we don't use iteritems() here to avoid problems if the underlying dict",
            "                # changes sizes due to the templating, which can happen with hostvars",
            "                for k in variable.keys():",
            "                    if k not in static_vars:",
            "                        d[k] = self.template(",
            "                            variable[k],",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                        )",
            "                    else:",
            "                        d[k] = variable[k]",
            "                return d",
            "            else:",
            "                return variable",
            "",
            "        except AnsibleFilterError:",
            "            if self._fail_on_filter_errors:",
            "                raise",
            "            else:",
            "                return variable",
            "",
            "    def is_template(self, data):",
            "        '''lets us know if data has a template'''",
            "        if isinstance(data, string_types):",
            "            return is_template(data, self.environment)",
            "        elif isinstance(data, (list, tuple)):",
            "            for v in data:",
            "                if self.is_template(v):",
            "                    return True",
            "        elif isinstance(data, dict):",
            "            for k in data:",
            "                if self.is_template(k) or self.is_template(data[k]):",
            "                    return True",
            "        return False",
            "",
            "    templatable = is_template",
            "",
            "    def is_possibly_template(self, data):",
            "        '''Determines if a string looks like a template, by seeing if it",
            "        contains a jinja2 start delimiter. Does not guarantee that the string",
            "        is actually a template.",
            "",
            "        This is different than ``is_template`` which is more strict.",
            "        This method may return ``True`` on a string that is not templatable.",
            "",
            "        Useful when guarding passing a string for templating, but when",
            "        you want to allow the templating engine to make the final",
            "        assessment which may result in ``TemplateSyntaxError``.",
            "        '''",
            "        env = self.environment",
            "        if isinstance(data, string_types):",
            "            for marker in (env.block_start_string, env.variable_start_string, env.comment_start_string):",
            "                if marker in data:",
            "                    return True",
            "        return False",
            "",
            "    def _convert_bare_variable(self, variable):",
            "        '''",
            "        Wraps a bare string, which may have an attribute portion (ie. foo.bar)",
            "        in jinja2 variable braces so that it is evaluated properly.",
            "        '''",
            "",
            "        if isinstance(variable, string_types):",
            "            contains_filters = \"|\" in variable",
            "            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]",
            "            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:",
            "                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)",
            "",
            "        # the variable didn't meet the conditions to be converted,",
            "        # so just return it as-is",
            "        return variable",
            "",
            "    def _finalize(self, thing):",
            "        '''",
            "        A custom finalize method for jinja2, which prevents None from being returned. This",
            "        avoids a string of ``\"None\"`` as ``None`` has no importance in YAML.",
            "",
            "        If using ANSIBLE_JINJA2_NATIVE we bypass this and return the actual value always",
            "        '''",
            "        if USE_JINJA2_NATIVE:",
            "            return thing",
            "        return thing if thing is not None else ''",
            "",
            "    def _fail_lookup(self, name, *args, **kwargs):",
            "        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)",
            "",
            "    def _now_datetime(self, utc=False, fmt=None):",
            "        '''jinja2 global function to return current datetime, potentially formatted via strftime'''",
            "        if utc:",
            "            now = datetime.datetime.utcnow()",
            "        else:",
            "            now = datetime.datetime.now()",
            "",
            "        if fmt:",
            "            return now.strftime(fmt)",
            "",
            "        return now",
            "",
            "    def _query_lookup(self, name, *args, **kwargs):",
            "        ''' wrapper for lookup, force wantlist true'''",
            "        kwargs['wantlist'] = True",
            "        return self._lookup(name, *args, **kwargs)",
            "",
            "    def _lookup(self, name, *args, **kwargs):",
            "        instance = self._lookup_loader.get(name.lower(), loader=self._loader, templar=self)",
            "",
            "        if instance is not None:",
            "            wantlist = kwargs.pop('wantlist', False)",
            "            allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)",
            "            errors = kwargs.pop('errors', 'strict')",
            "",
            "            from ansible.utils.listify import listify_lookup_plugin_terms",
            "            loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)",
            "            # safely catch run failures per #5059",
            "            try:",
            "                ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)",
            "            except (AnsibleUndefinedVariable, UndefinedError) as e:",
            "                raise AnsibleUndefinedVariable(e)",
            "            except Exception as e:",
            "                if self._fail_on_lookup_errors:",
            "                    msg = u\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % \\",
            "                          (name, type(e), to_text(e))",
            "                    if errors == 'warn':",
            "                        display.warning(msg)",
            "                    elif errors == 'ignore':",
            "                        display.display(msg, log_only=True)",
            "                    else:",
            "                        raise AnsibleError(to_native(msg))",
            "                ran = [] if wantlist else None",
            "",
            "            if ran and not allow_unsafe:",
            "                if wantlist:",
            "                    ran = wrap_var(ran)",
            "                else:",
            "                    try:",
            "                        ran = wrap_var(\",\".join(ran))",
            "                    except TypeError:",
            "                        # Lookup Plugins should always return lists.  Throw an error if that's not",
            "                        # the case:",
            "                        if not isinstance(ran, Sequence):",
            "                            raise AnsibleError(\"The lookup plugin '%s' did not return a list.\"",
            "                                               % name)",
            "",
            "                        # The TypeError we can recover from is when the value *inside* of the list",
            "                        # is not a string",
            "                        if len(ran) == 1:",
            "                            ran = wrap_var(ran[0])",
            "                        else:",
            "                            ran = wrap_var(ran)",
            "",
            "                if self.cur_context:",
            "                    self.cur_context.unsafe = True",
            "            return ran",
            "        else:",
            "            raise AnsibleError(\"lookup plugin (%s) not found\" % name)",
            "",
            "    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False):",
            "        if USE_JINJA2_NATIVE and not isinstance(data, string_types):",
            "            return data",
            "",
            "        # For preserving the number of input newlines in the output (used",
            "        # later in this method)",
            "        data_newlines = _count_newlines_from_end(data)",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            # allows template header overrides to change jinja2 options.",
            "            if overrides is None:",
            "                myenv = self.environment.overlay()",
            "            else:",
            "                myenv = self.environment.overlay(overrides)",
            "",
            "            # Get jinja env overrides from template",
            "            if hasattr(data, 'startswith') and data.startswith(JINJA2_OVERRIDE):",
            "                eol = data.find('\\n')",
            "                line = data[len(JINJA2_OVERRIDE):eol]",
            "                data = data[eol + 1:]",
            "                for pair in line.split(','):",
            "                    (key, val) = pair.split(':')",
            "                    key = key.strip()",
            "                    setattr(myenv, key, ast.literal_eval(val.strip()))",
            "",
            "            # Adds Ansible custom filters and tests",
            "            myenv.filters.update(self._get_filters())",
            "            myenv.tests.update(self._get_tests())",
            "",
            "            if escape_backslashes:",
            "                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".",
            "                data = _escape_backslashes(data, myenv)",
            "",
            "            try:",
            "                t = myenv.from_string(data)",
            "            except TemplateSyntaxError as e:",
            "                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)))",
            "            except Exception as e:",
            "                if 'recursion' in to_native(e):",
            "                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data))",
            "                else:",
            "                    return data",
            "",
            "            # jinja2 global is inconsistent across versions, this normalizes them",
            "            t.globals['dict'] = dict",
            "",
            "            if disable_lookups:",
            "                t.globals['query'] = t.globals['q'] = t.globals['lookup'] = self._fail_lookup",
            "            else:",
            "                t.globals['lookup'] = self._lookup",
            "                t.globals['query'] = t.globals['q'] = self._query_lookup",
            "",
            "            t.globals['now'] = self._now_datetime",
            "",
            "            t.globals['finalize'] = self._finalize",
            "",
            "            jvars = AnsibleJ2Vars(self, t.globals)",
            "",
            "            self.cur_context = new_context = t.new_context(jvars, shared=True)",
            "            rf = t.root_render_func(new_context)",
            "",
            "            try:",
            "                res = j2_concat(rf)",
            "                if getattr(new_context, 'unsafe', False):",
            "                    res = wrap_var(res)",
            "            except TypeError as te:",
            "                if 'AnsibleUndefined' in to_native(te):",
            "                    errmsg = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)",
            "                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)",
            "                    raise AnsibleUndefinedVariable(errmsg)",
            "                else:",
            "                    display.debug(\"failing because of a type error, template data is: %s\" % to_text(data))",
            "                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data), to_native(te)))",
            "",
            "            if USE_JINJA2_NATIVE and not isinstance(res, string_types):",
            "                return res",
            "",
            "            if preserve_trailing_newlines:",
            "                # The low level calls above do not preserve the newline",
            "                # characters at the end of the input data, so we use the",
            "                # calculate the difference in newlines and append them",
            "                # to the resulting output for parity",
            "                #",
            "                # jinja2 added a keep_trailing_newline option in 2.7 when",
            "                # creating an Environment.  That would let us make this code",
            "                # better (remove a single newline if",
            "                # preserve_trailing_newlines is False).  Once we can depend on",
            "                # that version being present, modify our code to set that when",
            "                # initializing self.environment and remove a single trailing",
            "                # newline here if preserve_newlines is False.",
            "                res_newlines = _count_newlines_from_end(res)",
            "                if data_newlines > res_newlines:",
            "                    res += self.environment.newline_sequence * (data_newlines - res_newlines)",
            "            return res",
            "        except (UndefinedError, AnsibleUndefinedVariable) as e:",
            "            if fail_on_undefined:",
            "                raise AnsibleUndefinedVariable(e)",
            "            else:",
            "                display.debug(\"Ignoring undefined failure: %s\" % to_text(e))",
            "                return data",
            "",
            "    # for backwards compatibility in case anyone is using old private method directly",
            "    _do_template = do_template"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import ast",
            "import datetime",
            "import os",
            "import pkgutil",
            "import pwd",
            "import re",
            "import time",
            "",
            "from numbers import Number",
            "",
            "try:",
            "    from hashlib import sha1",
            "except ImportError:",
            "    from sha import sha as sha1",
            "",
            "from jinja2.exceptions import TemplateSyntaxError, UndefinedError",
            "from jinja2.loaders import FileSystemLoader",
            "from jinja2.runtime import Context, StrictUndefined",
            "",
            "from ansible import constants as C",
            "from ansible.errors import AnsibleError, AnsibleFilterError, AnsibleUndefinedVariable, AnsibleAssertionError",
            "from ansible.module_utils.six import iteritems, string_types, text_type",
            "from ansible.module_utils._text import to_native, to_text, to_bytes",
            "from ansible.module_utils.common._collections_compat import Sequence, Mapping, MutableMapping",
            "from ansible.plugins.loader import filter_loader, lookup_loader, test_loader",
            "from ansible.template.safe_eval import safe_eval",
            "from ansible.template.template import AnsibleJ2Template",
            "from ansible.template.vars import AnsibleJ2Vars",
            "from ansible.utils.collection_loader import AnsibleCollectionRef",
            "from ansible.utils.display import Display",
            "from ansible.utils.unsafe_proxy import wrap_var",
            "",
            "# HACK: keep Python 2.6 controller tests happy in CI until they're properly split",
            "try:",
            "    from importlib import import_module",
            "except ImportError:",
            "    import_module = __import__",
            "",
            "display = Display()",
            "",
            "",
            "__all__ = ['Templar', 'generate_ansible_template_vars']",
            "",
            "# A regex for checking to see if a variable we're trying to",
            "# expand is just a single variable name.",
            "",
            "# Primitive Types which we don't want Jinja to convert to strings.",
            "NON_TEMPLATED_TYPES = (bool, Number)",
            "",
            "JINJA2_OVERRIDE = '#jinja2:'",
            "",
            "USE_JINJA2_NATIVE = False",
            "if C.DEFAULT_JINJA2_NATIVE:",
            "    try:",
            "        from jinja2.nativetypes import NativeEnvironment as Environment",
            "        from ansible.template.native_helpers import ansible_native_concat as j2_concat",
            "        USE_JINJA2_NATIVE = True",
            "    except ImportError:",
            "        from jinja2 import Environment",
            "        from jinja2.utils import concat as j2_concat",
            "        from jinja2 import __version__ as j2_version",
            "        display.warning(",
            "            'jinja2_native requires Jinja 2.10 and above. '",
            "            'Version detected: %s. Falling back to default.' % j2_version",
            "        )",
            "else:",
            "    from jinja2 import Environment",
            "    from jinja2.utils import concat as j2_concat",
            "",
            "",
            "JINJA2_BEGIN_TOKENS = frozenset(('variable_begin', 'block_begin', 'comment_begin', 'raw_begin'))",
            "JINJA2_END_TOKENS = frozenset(('variable_end', 'block_end', 'comment_end', 'raw_end'))",
            "",
            "",
            "def generate_ansible_template_vars(path, dest_path=None):",
            "    b_path = to_bytes(path)",
            "    try:",
            "        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name",
            "    except (KeyError, TypeError):",
            "        template_uid = os.stat(b_path).st_uid",
            "",
            "    temp_vars = {",
            "        'template_host': to_text(os.uname()[1]),",
            "        'template_path': path,",
            "        'template_mtime': datetime.datetime.fromtimestamp(os.path.getmtime(b_path)),",
            "        'template_uid': to_text(template_uid),",
            "        'template_fullpath': os.path.abspath(path),",
            "        'template_run_date': datetime.datetime.now(),",
            "        'template_destpath': to_native(dest_path) if dest_path else None,",
            "    }",
            "",
            "    managed_default = C.DEFAULT_MANAGED_STR",
            "    managed_str = managed_default.format(",
            "        host=temp_vars['template_host'],",
            "        uid=temp_vars['template_uid'],",
            "        file=temp_vars['template_path'],",
            "    )",
            "    temp_vars['ansible_managed'] = to_text(time.strftime(to_native(managed_str), time.localtime(os.path.getmtime(b_path))))",
            "",
            "    return temp_vars",
            "",
            "",
            "def _escape_backslashes(data, jinja_env):",
            "    \"\"\"Double backslashes within jinja2 expressions",
            "",
            "    A user may enter something like this in a playbook::",
            "",
            "      debug:",
            "        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"",
            "",
            "    The string inside of the {{ gets interpreted multiple times First by yaml.",
            "    Then by python.  And finally by jinja2 as part of it's variable.  Because",
            "    it is processed by both python and jinja2, the backslash escaped",
            "    characters get unescaped twice.  This means that we'd normally have to use",
            "    four backslashes to escape that.  This is painful for playbook authors as",
            "    they have to remember different rules for inside vs outside of a jinja2",
            "    expression (The backslashes outside of the \"{{ }}\" only get processed by",
            "    yaml and python.  So they only need to be escaped once).  The following",
            "    code fixes this by automatically performing the extra quoting of",
            "    backslashes inside of a jinja2 expression.",
            "",
            "    \"\"\"",
            "    if '\\\\' in data and '{{' in data:",
            "        new_data = []",
            "        d2 = jinja_env.preprocess(data)",
            "        in_var = False",
            "",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] == 'variable_begin':",
            "                in_var = True",
            "                new_data.append(token[2])",
            "            elif token[1] == 'variable_end':",
            "                in_var = False",
            "                new_data.append(token[2])",
            "            elif in_var and token[1] == 'string':",
            "                # Double backslashes only if we're inside of a jinja2 variable",
            "                new_data.append(token[2].replace('\\\\', '\\\\\\\\'))",
            "            else:",
            "                new_data.append(token[2])",
            "",
            "        data = ''.join(new_data)",
            "",
            "    return data",
            "",
            "",
            "def is_template(data, jinja_env):",
            "    \"\"\"This function attempts to quickly detect whether a value is a jinja2",
            "    template. To do so, we look for the first 2 matching jinja2 tokens for",
            "    start and end delimiters.",
            "    \"\"\"",
            "    found = None",
            "    start = True",
            "    comment = False",
            "    d2 = jinja_env.preprocess(data)",
            "",
            "    # This wraps a lot of code, but this is due to lex returing a generator",
            "    # so we may get an exception at any part of the loop",
            "    try:",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] in JINJA2_BEGIN_TOKENS:",
            "                if start and token[1] == 'comment_begin':",
            "                    # Comments can wrap other token types",
            "                    comment = True",
            "                start = False",
            "                # Example: variable_end -> variable",
            "                found = token[1].split('_')[0]",
            "            elif token[1] in JINJA2_END_TOKENS:",
            "                if token[1].split('_')[0] == found:",
            "                    return True",
            "                elif comment:",
            "                    continue",
            "                return False",
            "    except TemplateSyntaxError:",
            "        return False",
            "",
            "    return False",
            "",
            "",
            "def _count_newlines_from_end(in_str):",
            "    '''",
            "    Counts the number of newlines at the end of a string. This is used during",
            "    the jinja2 templating to ensure the count matches the input, since some newlines",
            "    may be thrown away during the templating.",
            "    '''",
            "",
            "    try:",
            "        i = len(in_str)",
            "        j = i - 1",
            "        while in_str[j] == '\\n':",
            "            j -= 1",
            "        return i - 1 - j",
            "    except IndexError:",
            "        # Uncommon cases: zero length string and string containing only newlines",
            "        return i",
            "",
            "",
            "def recursive_check_defined(item):",
            "    from jinja2.runtime import Undefined",
            "",
            "    if isinstance(item, MutableMapping):",
            "        for key in item:",
            "            recursive_check_defined(item[key])",
            "    elif isinstance(item, list):",
            "        for i in item:",
            "            recursive_check_defined(i)",
            "    else:",
            "        if isinstance(item, Undefined):",
            "            raise AnsibleFilterError(\"{0} is undefined\".format(item))",
            "",
            "",
            "class AnsibleUndefined(StrictUndefined):",
            "    '''",
            "    A custom Undefined class, which returns further Undefined objects on access,",
            "    rather than throwing an exception.",
            "    '''",
            "    def __getattr__(self, name):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __getitem__(self, key):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __repr__(self):",
            "        return 'AnsibleUndefined'",
            "",
            "",
            "class AnsibleContext(Context):",
            "    '''",
            "    A custom context, which intercepts resolve() calls and sets a flag",
            "    internally if any variable lookup returns an AnsibleUnsafe value. This",
            "    flag is checked post-templating, and (when set) will result in the",
            "    final templated result being wrapped in AnsibleUnsafe.",
            "    '''",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleContext, self).__init__(*args, **kwargs)",
            "        self.unsafe = False",
            "",
            "    def _is_unsafe(self, val):",
            "        '''",
            "        Our helper function, which will also recursively check dict and",
            "        list entries due to the fact that they may be repr'd and contain",
            "        a key or value which contains jinja2 syntax and would otherwise",
            "        lose the AnsibleUnsafe value.",
            "        '''",
            "        if isinstance(val, dict):",
            "            for key in val.keys():",
            "                if self._is_unsafe(val[key]):",
            "                    return True",
            "        elif isinstance(val, list):",
            "            for item in val:",
            "                if self._is_unsafe(item):",
            "                    return True",
            "        elif hasattr(val, '__UNSAFE__'):",
            "            return True",
            "        return False",
            "",
            "    def _update_unsafe(self, val):",
            "        if val is not None and not self.unsafe and self._is_unsafe(val):",
            "            self.unsafe = True",
            "",
            "    def resolve(self, key):",
            "        '''",
            "        The intercepted resolve(), which uses the helper above to set the",
            "        internal flag whenever an unsafe variable value is returned.",
            "        '''",
            "        val = super(AnsibleContext, self).resolve(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "    def resolve_or_missing(self, key):",
            "        val = super(AnsibleContext, self).resolve_or_missing(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "",
            "class JinjaPluginIntercept(MutableMapping):",
            "    def __init__(self, delegatee, pluginloader, *args, **kwargs):",
            "        super(JinjaPluginIntercept, self).__init__(*args, **kwargs)",
            "        self._delegatee = delegatee",
            "        self._pluginloader = pluginloader",
            "",
            "        if self._pluginloader.class_name == 'FilterModule':",
            "            self._method_map_name = 'filters'",
            "            self._dirname = 'filter'",
            "        elif self._pluginloader.class_name == 'TestModule':",
            "            self._method_map_name = 'tests'",
            "            self._dirname = 'test'",
            "",
            "        self._collection_jinja_func_cache = {}",
            "",
            "    # FUTURE: we can cache FQ filter/test calls for the entire duration of a run, since a given collection's impl's",
            "    # aren't supposed to change during a run",
            "    def __getitem__(self, key):",
            "        if not isinstance(key, string_types):",
            "            raise ValueError('key must be a string')",
            "",
            "        key = to_native(key)",
            "",
            "        if '.' not in key:  # might be a built-in value, delegate to base dict",
            "            return self._delegatee.__getitem__(key)",
            "",
            "        func = self._collection_jinja_func_cache.get(key)",
            "",
            "        if func:",
            "            return func",
            "",
            "        acr = AnsibleCollectionRef.try_parse_fqcr(key, self._dirname)",
            "",
            "        if not acr:",
            "            raise KeyError('invalid plugin name: {0}'.format(key))",
            "",
            "        # FIXME: error handling for bogus plugin name, bogus impl, bogus filter/test",
            "",
            "        pkg = import_module(acr.n_python_package_name)",
            "",
            "        parent_prefix = acr.collection",
            "",
            "        if acr.subdirs:",
            "            parent_prefix = '{0}.{1}'.format(parent_prefix, acr.subdirs)",
            "",
            "        for dummy, module_name, ispkg in pkgutil.iter_modules(pkg.__path__, prefix=parent_prefix + '.'):",
            "            if ispkg:",
            "                continue",
            "",
            "            plugin_impl = self._pluginloader.get(module_name)",
            "",
            "            method_map = getattr(plugin_impl, self._method_map_name)",
            "",
            "            for f in iteritems(method_map()):",
            "                fq_name = '.'.join((parent_prefix, f[0]))",
            "                # FIXME: detect/warn on intra-collection function name collisions",
            "                self._collection_jinja_func_cache[fq_name] = f[1]",
            "",
            "        function_impl = self._collection_jinja_func_cache[key]",
            "        return function_impl",
            "",
            "    def __setitem__(self, key, value):",
            "        return self._delegatee.__setitem__(key, value)",
            "",
            "    def __delitem__(self, key):",
            "        raise NotImplementedError()",
            "",
            "    def __iter__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return iter(self._delegatee)",
            "",
            "    def __len__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return len(self._delegatee)",
            "",
            "",
            "class AnsibleEnvironment(Environment):",
            "    '''",
            "    Our custom environment, which simply allows us to override the class-level",
            "    values for the Template and Context classes used by jinja2 internally.",
            "    '''",
            "    context_class = AnsibleContext",
            "    template_class = AnsibleJ2Template",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleEnvironment, self).__init__(*args, **kwargs)",
            "",
            "        self.filters = JinjaPluginIntercept(self.filters, filter_loader)",
            "        self.tests = JinjaPluginIntercept(self.tests, test_loader)",
            "",
            "",
            "class Templar:",
            "    '''",
            "    The main class for templating, with the main entry-point of template().",
            "    '''",
            "",
            "    def __init__(self, loader, shared_loader_obj=None, variables=None):",
            "        variables = {} if variables is None else variables",
            "",
            "        self._loader = loader",
            "        self._filters = None",
            "        self._tests = None",
            "        self._available_variables = variables",
            "        self._cached_result = {}",
            "",
            "        if loader:",
            "            self._basedir = loader.get_basedir()",
            "        else:",
            "            self._basedir = './'",
            "",
            "        if shared_loader_obj:",
            "            self._filter_loader = getattr(shared_loader_obj, 'filter_loader')",
            "            self._test_loader = getattr(shared_loader_obj, 'test_loader')",
            "            self._lookup_loader = getattr(shared_loader_obj, 'lookup_loader')",
            "        else:",
            "            self._filter_loader = filter_loader",
            "            self._test_loader = test_loader",
            "            self._lookup_loader = lookup_loader",
            "",
            "        # flags to determine whether certain failures during templating",
            "        # should result in fatal errors being raised",
            "        self._fail_on_lookup_errors = True",
            "        self._fail_on_filter_errors = True",
            "        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR",
            "",
            "        self.environment = AnsibleEnvironment(",
            "            trim_blocks=True,",
            "            undefined=AnsibleUndefined,",
            "            extensions=self._get_extensions(),",
            "            finalize=self._finalize,",
            "            loader=FileSystemLoader(self._basedir),",
            "        )",
            "",
            "        # the current rendering context under which the templar class is working",
            "        self.cur_context = None",
            "",
            "        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))",
            "",
            "        self._clean_regex = re.compile(r'(?:%s|%s|%s|%s)' % (",
            "            self.environment.variable_start_string,",
            "            self.environment.block_start_string,",
            "            self.environment.block_end_string,",
            "            self.environment.variable_end_string",
            "        ))",
            "        self._no_type_regex = re.compile(r'.*?\\|\\s*(?:%s)(?:\\([^\\|]*\\))?\\s*\\)?\\s*(?:%s)' %",
            "                                         ('|'.join(C.STRING_TYPE_FILTERS), self.environment.variable_end_string))",
            "",
            "    def _get_filters(self):",
            "        '''",
            "        Returns filter plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._filters is not None:",
            "            return self._filters.copy()",
            "",
            "        self._filters = dict()",
            "",
            "        for fp in self._filter_loader.all():",
            "            self._filters.update(fp.filters())",
            "",
            "        return self._filters.copy()",
            "",
            "    def _get_tests(self):",
            "        '''",
            "        Returns tests plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._tests is not None:",
            "            return self._tests.copy()",
            "",
            "        self._tests = dict()",
            "        for fp in self._test_loader.all():",
            "            self._tests.update(fp.tests())",
            "",
            "        return self._tests.copy()",
            "",
            "    def _get_extensions(self):",
            "        '''",
            "        Return jinja2 extensions to load.",
            "",
            "        If some extensions are set via jinja_extensions in ansible.cfg, we try",
            "        to load them with the jinja environment.",
            "        '''",
            "",
            "        jinja_exts = []",
            "        if C.DEFAULT_JINJA2_EXTENSIONS:",
            "            # make sure the configuration directive doesn't contain spaces",
            "            # and split extensions in an array",
            "            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')",
            "",
            "        return jinja_exts",
            "",
            "    @property",
            "    def available_variables(self):",
            "        return self._available_variables",
            "",
            "    @available_variables.setter",
            "    def available_variables(self, variables):",
            "        '''",
            "        Sets the list of template variables this Templar instance will use",
            "        to template things, so we don't have to pass them around between",
            "        internal methods. We also clear the template cache here, as the variables",
            "        are being changed.",
            "        '''",
            "",
            "        if not isinstance(variables, dict):",
            "            raise AnsibleAssertionError(\"the type of 'variables' should be a dict but was a %s\" % (type(variables)))",
            "        self._available_variables = variables",
            "        self._cached_result = {}",
            "",
            "    def set_available_variables(self, variables):",
            "        display.deprecated(",
            "            'set_available_variables is being deprecated. Use \"@available_variables.setter\" instead.',",
            "            version='2.13'",
            "        )",
            "        self.available_variables = variables",
            "",
            "    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None,",
            "                 convert_data=True, static_vars=None, cache=True, disable_lookups=False):",
            "        '''",
            "        Templates (possibly recursively) any given data as input. If convert_bare is",
            "        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')",
            "        before being sent through the template engine.",
            "        '''",
            "        static_vars = [''] if static_vars is None else static_vars",
            "",
            "        # Don't template unsafe variables, just return them.",
            "        if hasattr(variable, '__UNSAFE__'):",
            "            return variable",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            if convert_bare:",
            "                variable = self._convert_bare_variable(variable)",
            "",
            "            if isinstance(variable, string_types):",
            "                result = variable",
            "",
            "                if self.is_possibly_template(variable):",
            "                    # Check to see if the string we are trying to render is just referencing a single",
            "                    # var.  In this case we don't want to accidentally change the type of the variable",
            "                    # to a string by using the jinja template renderer. We just want to pass it.",
            "                    only_one = self.SINGLE_VAR.match(variable)",
            "                    if only_one:",
            "                        var_name = only_one.group(1)",
            "                        if var_name in self._available_variables:",
            "                            resolved_val = self._available_variables[var_name]",
            "                            if isinstance(resolved_val, NON_TEMPLATED_TYPES):",
            "                                return resolved_val",
            "                            elif resolved_val is None:",
            "                                return C.DEFAULT_NULL_REPRESENTATION",
            "",
            "                    # Using a cache in order to prevent template calls with already templated variables",
            "                    sha1_hash = None",
            "                    if cache:",
            "                        variable_hash = sha1(text_type(variable).encode('utf-8'))",
            "                        options_hash = sha1(",
            "                            (",
            "                                text_type(preserve_trailing_newlines) +",
            "                                text_type(escape_backslashes) +",
            "                                text_type(fail_on_undefined) +",
            "                                text_type(overrides)",
            "                            ).encode('utf-8')",
            "                        )",
            "                        sha1_hash = variable_hash.hexdigest() + options_hash.hexdigest()",
            "                    if cache and sha1_hash in self._cached_result:",
            "                        result = self._cached_result[sha1_hash]",
            "                    else:",
            "                        result = self.do_template(",
            "                            variable,",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            escape_backslashes=escape_backslashes,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                        )",
            "",
            "                        if not USE_JINJA2_NATIVE:",
            "                            unsafe = hasattr(result, '__UNSAFE__')",
            "                            if convert_data and not self._no_type_regex.match(variable):",
            "                                # if this looks like a dictionary or list, convert it to such using the safe_eval method",
            "                                if (result.startswith(\"{\") and not result.startswith(self.environment.variable_start_string)) or \\",
            "                                        result.startswith(\"[\") or result in (\"True\", \"False\"):",
            "                                    eval_results = safe_eval(result, include_exceptions=True)",
            "                                    if eval_results[1] is None:",
            "                                        result = eval_results[0]",
            "                                        if unsafe:",
            "                                            result = wrap_var(result)",
            "                                    else:",
            "                                        # FIXME: if the safe_eval raised an error, should we do something with it?",
            "                                        pass",
            "",
            "                        # we only cache in the case where we have a single variable",
            "                        # name, to make sure we're not putting things which may otherwise",
            "                        # be dynamic in the cache (filters, lookups, etc.)",
            "                        if cache:",
            "                            self._cached_result[sha1_hash] = result",
            "",
            "                return result",
            "",
            "            elif isinstance(variable, (list, tuple)):",
            "                return [self.template(",
            "                    v,",
            "                    preserve_trailing_newlines=preserve_trailing_newlines,",
            "                    fail_on_undefined=fail_on_undefined,",
            "                    overrides=overrides,",
            "                    disable_lookups=disable_lookups,",
            "                ) for v in variable]",
            "            elif isinstance(variable, (dict, Mapping)):",
            "                d = {}",
            "                # we don't use iteritems() here to avoid problems if the underlying dict",
            "                # changes sizes due to the templating, which can happen with hostvars",
            "                for k in variable.keys():",
            "                    if k not in static_vars:",
            "                        d[k] = self.template(",
            "                            variable[k],",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                        )",
            "                    else:",
            "                        d[k] = variable[k]",
            "                return d",
            "            else:",
            "                return variable",
            "",
            "        except AnsibleFilterError:",
            "            if self._fail_on_filter_errors:",
            "                raise",
            "            else:",
            "                return variable",
            "",
            "    def is_template(self, data):",
            "        '''lets us know if data has a template'''",
            "        if isinstance(data, string_types):",
            "            return is_template(data, self.environment)",
            "        elif isinstance(data, (list, tuple)):",
            "            for v in data:",
            "                if self.is_template(v):",
            "                    return True",
            "        elif isinstance(data, dict):",
            "            for k in data:",
            "                if self.is_template(k) or self.is_template(data[k]):",
            "                    return True",
            "        return False",
            "",
            "    templatable = is_template",
            "",
            "    def is_possibly_template(self, data):",
            "        '''Determines if a string looks like a template, by seeing if it",
            "        contains a jinja2 start delimiter. Does not guarantee that the string",
            "        is actually a template.",
            "",
            "        This is different than ``is_template`` which is more strict.",
            "        This method may return ``True`` on a string that is not templatable.",
            "",
            "        Useful when guarding passing a string for templating, but when",
            "        you want to allow the templating engine to make the final",
            "        assessment which may result in ``TemplateSyntaxError``.",
            "        '''",
            "        env = self.environment",
            "        if isinstance(data, string_types):",
            "            for marker in (env.block_start_string, env.variable_start_string, env.comment_start_string):",
            "                if marker in data:",
            "                    return True",
            "        return False",
            "",
            "    def _convert_bare_variable(self, variable):",
            "        '''",
            "        Wraps a bare string, which may have an attribute portion (ie. foo.bar)",
            "        in jinja2 variable braces so that it is evaluated properly.",
            "        '''",
            "",
            "        if isinstance(variable, string_types):",
            "            contains_filters = \"|\" in variable",
            "            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]",
            "            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:",
            "                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)",
            "",
            "        # the variable didn't meet the conditions to be converted,",
            "        # so just return it as-is",
            "        return variable",
            "",
            "    def _finalize(self, thing):",
            "        '''",
            "        A custom finalize method for jinja2, which prevents None from being returned. This",
            "        avoids a string of ``\"None\"`` as ``None`` has no importance in YAML.",
            "",
            "        If using ANSIBLE_JINJA2_NATIVE we bypass this and return the actual value always",
            "        '''",
            "        if USE_JINJA2_NATIVE:",
            "            return thing",
            "        return thing if thing is not None else ''",
            "",
            "    def _fail_lookup(self, name, *args, **kwargs):",
            "        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)",
            "",
            "    def _now_datetime(self, utc=False, fmt=None):",
            "        '''jinja2 global function to return current datetime, potentially formatted via strftime'''",
            "        if utc:",
            "            now = datetime.datetime.utcnow()",
            "        else:",
            "            now = datetime.datetime.now()",
            "",
            "        if fmt:",
            "            return now.strftime(fmt)",
            "",
            "        return now",
            "",
            "    def _query_lookup(self, name, *args, **kwargs):",
            "        ''' wrapper for lookup, force wantlist true'''",
            "        kwargs['wantlist'] = True",
            "        return self._lookup(name, *args, **kwargs)",
            "",
            "    def _lookup(self, name, *args, **kwargs):",
            "        instance = self._lookup_loader.get(name.lower(), loader=self._loader, templar=self)",
            "",
            "        if instance is not None:",
            "            wantlist = kwargs.pop('wantlist', False)",
            "            allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)",
            "            errors = kwargs.pop('errors', 'strict')",
            "",
            "            from ansible.utils.listify import listify_lookup_plugin_terms",
            "            loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)",
            "            # safely catch run failures per #5059",
            "            try:",
            "                ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)",
            "            except (AnsibleUndefinedVariable, UndefinedError) as e:",
            "                raise AnsibleUndefinedVariable(e)",
            "            except Exception as e:",
            "                if self._fail_on_lookup_errors:",
            "                    msg = u\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % \\",
            "                          (name, type(e), to_text(e))",
            "                    if errors == 'warn':",
            "                        display.warning(msg)",
            "                    elif errors == 'ignore':",
            "                        display.display(msg, log_only=True)",
            "                    else:",
            "                        raise AnsibleError(to_native(msg))",
            "                ran = [] if wantlist else None",
            "",
            "            if ran and not allow_unsafe:",
            "                if wantlist:",
            "                    ran = wrap_var(ran)",
            "                else:",
            "                    try:",
            "                        ran = wrap_var(\",\".join(ran))",
            "                    except TypeError:",
            "                        # Lookup Plugins should always return lists.  Throw an error if that's not",
            "                        # the case:",
            "                        if not isinstance(ran, Sequence):",
            "                            raise AnsibleError(\"The lookup plugin '%s' did not return a list.\"",
            "                                               % name)",
            "",
            "                        # The TypeError we can recover from is when the value *inside* of the list",
            "                        # is not a string",
            "                        if len(ran) == 1:",
            "                            ran = wrap_var(ran[0])",
            "                        else:",
            "                            ran = wrap_var(ran)",
            "",
            "                if self.cur_context:",
            "                    self.cur_context.unsafe = True",
            "            return ran",
            "        else:",
            "            raise AnsibleError(\"lookup plugin (%s) not found\" % name)",
            "",
            "    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False):",
            "        if USE_JINJA2_NATIVE and not isinstance(data, string_types):",
            "            return data",
            "",
            "        # For preserving the number of input newlines in the output (used",
            "        # later in this method)",
            "        data_newlines = _count_newlines_from_end(data)",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            # allows template header overrides to change jinja2 options.",
            "            if overrides is None:",
            "                myenv = self.environment.overlay()",
            "            else:",
            "                myenv = self.environment.overlay(overrides)",
            "",
            "            # Get jinja env overrides from template",
            "            if hasattr(data, 'startswith') and data.startswith(JINJA2_OVERRIDE):",
            "                eol = data.find('\\n')",
            "                line = data[len(JINJA2_OVERRIDE):eol]",
            "                data = data[eol + 1:]",
            "                for pair in line.split(','):",
            "                    (key, val) = pair.split(':')",
            "                    key = key.strip()",
            "                    setattr(myenv, key, ast.literal_eval(val.strip()))",
            "",
            "            # Adds Ansible custom filters and tests",
            "            myenv.filters.update(self._get_filters())",
            "            myenv.tests.update(self._get_tests())",
            "",
            "            if escape_backslashes:",
            "                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".",
            "                data = _escape_backslashes(data, myenv)",
            "",
            "            try:",
            "                t = myenv.from_string(data)",
            "            except TemplateSyntaxError as e:",
            "                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)))",
            "            except Exception as e:",
            "                if 'recursion' in to_native(e):",
            "                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data))",
            "                else:",
            "                    return data",
            "",
            "            # jinja2 global is inconsistent across versions, this normalizes them",
            "            t.globals['dict'] = dict",
            "",
            "            if disable_lookups:",
            "                t.globals['query'] = t.globals['q'] = t.globals['lookup'] = self._fail_lookup",
            "            else:",
            "                t.globals['lookup'] = self._lookup",
            "                t.globals['query'] = t.globals['q'] = self._query_lookup",
            "",
            "            t.globals['now'] = self._now_datetime",
            "",
            "            t.globals['finalize'] = self._finalize",
            "",
            "            jvars = AnsibleJ2Vars(self, t.globals)",
            "",
            "            self.cur_context = new_context = t.new_context(jvars, shared=True)",
            "            rf = t.root_render_func(new_context)",
            "",
            "            try:",
            "                res = j2_concat(rf)",
            "                if getattr(new_context, 'unsafe', False):",
            "                    res = wrap_var(res)",
            "            except TypeError as te:",
            "                if 'AnsibleUndefined' in to_native(te):",
            "                    errmsg = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)",
            "                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)",
            "                    raise AnsibleUndefinedVariable(errmsg)",
            "                else:",
            "                    display.debug(\"failing because of a type error, template data is: %s\" % to_text(data))",
            "                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data), to_native(te)))",
            "",
            "            if USE_JINJA2_NATIVE and not isinstance(res, string_types):",
            "                return res",
            "",
            "            if preserve_trailing_newlines:",
            "                # The low level calls above do not preserve the newline",
            "                # characters at the end of the input data, so we use the",
            "                # calculate the difference in newlines and append them",
            "                # to the resulting output for parity",
            "                #",
            "                # jinja2 added a keep_trailing_newline option in 2.7 when",
            "                # creating an Environment.  That would let us make this code",
            "                # better (remove a single newline if",
            "                # preserve_trailing_newlines is False).  Once we can depend on",
            "                # that version being present, modify our code to set that when",
            "                # initializing self.environment and remove a single trailing",
            "                # newline here if preserve_newlines is False.",
            "                res_newlines = _count_newlines_from_end(res)",
            "                if data_newlines > res_newlines:",
            "                    res += self.environment.newline_sequence * (data_newlines - res_newlines)",
            "            return res",
            "        except (UndefinedError, AnsibleUndefinedVariable) as e:",
            "            if fail_on_undefined:",
            "                raise AnsibleUndefinedVariable(e)",
            "            else:",
            "                display.debug(\"Ignoring undefined failure: %s\" % to_text(e))",
            "                return data",
            "",
            "    # for backwards compatibility in case anyone is using old private method directly",
            "    _do_template = do_template"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "275": [
                "AnsibleContext",
                "_is_unsafe"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/utils/unsafe_proxy.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " class AnsibleUnsafeBytes(binary_type, AnsibleUnsafe):"
            },
            "3": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pass"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    def decode(self, *args, **kwargs):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        \"\"\"Wrapper method to ensure type conversions maintain unsafe context\"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        return AnsibleUnsafeText(super(AnsibleUnsafeBytes, self).decode(*args, **kwargs))"
            },
            "7": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " class AnsibleUnsafeText(text_type, AnsibleUnsafe):"
            },
            "10": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pass"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    def encode(self, *args, **kwargs):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        \"\"\"Wrapper method to ensure type conversions maintain unsafe context\"\"\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        return AnsibleUnsafeBytes(super(AnsibleUnsafeText, self).encode(*args, **kwargs))"
            },
            "14": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " class UnsafeProxy(object):"
            }
        },
        "frontPatchFile": [
            "# PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2",
            "# --------------------------------------------",
            "#",
            "# 1. This LICENSE AGREEMENT is between the Python Software Foundation",
            "# (\"PSF\"), and the Individual or Organization (\"Licensee\") accessing and",
            "# otherwise using this software (\"Python\") in source or binary form and",
            "# its associated documentation.",
            "#",
            "# 2. Subject to the terms and conditions of this License Agreement, PSF hereby",
            "# grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,",
            "# analyze, test, perform and/or display publicly, prepare derivative works,",
            "# distribute, and otherwise use Python alone or in any derivative version,",
            "# provided, however, that PSF's License Agreement and PSF's notice of copyright,",
            "# i.e., \"Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,",
            "# 2011, 2012, 2013, 2014 Python Software Foundation; All Rights Reserved\" are",
            "# retained in Python alone or in any derivative version prepared by Licensee.",
            "#",
            "# 3. In the event Licensee prepares a derivative work that is based on",
            "# or incorporates Python or any part thereof, and wants to make",
            "# the derivative work available to others as provided herein, then",
            "# Licensee hereby agrees to include in any such work a brief summary of",
            "# the changes made to Python.",
            "#",
            "# 4. PSF is making Python available to Licensee on an \"AS IS\"",
            "# basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR",
            "# IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND",
            "# DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS",
            "# FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT",
            "# INFRINGE ANY THIRD PARTY RIGHTS.",
            "#",
            "# 5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON",
            "# FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS",
            "# A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,",
            "# OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.",
            "#",
            "# 6. This License Agreement will automatically terminate upon a material",
            "# breach of its terms and conditions.",
            "#",
            "# 7. Nothing in this License Agreement shall be deemed to create any",
            "# relationship of agency, partnership, or joint venture between PSF and",
            "# Licensee.  This License Agreement does not grant permission to use PSF",
            "# trademarks or trade name in a trademark sense to endorse or promote",
            "# products or services of Licensee, or any third party.",
            "#",
            "# 8. By copying, installing or otherwise using Python, Licensee",
            "# agrees to be bound by the terms and conditions of this License",
            "# Agreement.",
            "#",
            "# Original Python Recipe for Proxy:",
            "# http://code.activestate.com/recipes/496741-object-proxying/",
            "# Author: Tomer Filiba",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "from ansible.module_utils._text import to_bytes, to_text",
            "from ansible.module_utils.common._collections_compat import Mapping, MutableSequence, Set",
            "from ansible.module_utils.six import string_types, binary_type, text_type",
            "",
            "",
            "__all__ = ['AnsibleUnsafe', 'wrap_var']",
            "",
            "",
            "class AnsibleUnsafe(object):",
            "    __UNSAFE__ = True",
            "",
            "",
            "class AnsibleUnsafeBytes(binary_type, AnsibleUnsafe):",
            "    pass",
            "",
            "",
            "class AnsibleUnsafeText(text_type, AnsibleUnsafe):",
            "    pass",
            "",
            "",
            "class UnsafeProxy(object):",
            "    def __new__(cls, obj, *args, **kwargs):",
            "        from ansible.utils.display import Display",
            "        Display().deprecated(",
            "            'UnsafeProxy is being deprecated. Use wrap_var or AnsibleUnsafeBytes/AnsibleUnsafeText directly instead',",
            "            version='2.13'",
            "        )",
            "        # In our usage we should only receive unicode strings.",
            "        # This conditional and conversion exists to sanity check the values",
            "        # we're given but we may want to take it out for testing and sanitize",
            "        # our input instead.",
            "        if isinstance(obj, AnsibleUnsafe):",
            "            return obj",
            "",
            "        if isinstance(obj, string_types):",
            "            obj = AnsibleUnsafeText(to_text(obj, errors='surrogate_or_strict'))",
            "        return obj",
            "",
            "",
            "def _wrap_dict(v):",
            "    for k in v.keys():",
            "        if v[k] is not None:",
            "            v[wrap_var(k)] = wrap_var(v[k])",
            "    return v",
            "",
            "",
            "def _wrap_list(v):",
            "    for idx, item in enumerate(v):",
            "        if item is not None:",
            "            v[idx] = wrap_var(item)",
            "    return v",
            "",
            "",
            "def _wrap_set(v):",
            "    return set(item if item is None else wrap_var(item) for item in v)",
            "",
            "",
            "def wrap_var(v):",
            "    if isinstance(v, AnsibleUnsafe):",
            "        return v",
            "",
            "    if isinstance(v, Mapping):",
            "        v = _wrap_dict(v)",
            "    elif isinstance(v, MutableSequence):",
            "        v = _wrap_list(v)",
            "    elif isinstance(v, Set):",
            "        v = _wrap_set(v)",
            "    elif isinstance(v, binary_type):",
            "        v = AnsibleUnsafeBytes(v)",
            "    elif isinstance(v, text_type):",
            "        v = AnsibleUnsafeText(v)",
            "",
            "    return v",
            "",
            "",
            "def to_unsafe_bytes(*args, **kwargs):",
            "    return wrap_var(to_bytes(*args, **kwargs))",
            "",
            "",
            "def to_unsafe_text(*args, **kwargs):",
            "    return wrap_var(to_text(*args, **kwargs))"
        ],
        "afterPatchFile": [
            "# PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2",
            "# --------------------------------------------",
            "#",
            "# 1. This LICENSE AGREEMENT is between the Python Software Foundation",
            "# (\"PSF\"), and the Individual or Organization (\"Licensee\") accessing and",
            "# otherwise using this software (\"Python\") in source or binary form and",
            "# its associated documentation.",
            "#",
            "# 2. Subject to the terms and conditions of this License Agreement, PSF hereby",
            "# grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,",
            "# analyze, test, perform and/or display publicly, prepare derivative works,",
            "# distribute, and otherwise use Python alone or in any derivative version,",
            "# provided, however, that PSF's License Agreement and PSF's notice of copyright,",
            "# i.e., \"Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,",
            "# 2011, 2012, 2013, 2014 Python Software Foundation; All Rights Reserved\" are",
            "# retained in Python alone or in any derivative version prepared by Licensee.",
            "#",
            "# 3. In the event Licensee prepares a derivative work that is based on",
            "# or incorporates Python or any part thereof, and wants to make",
            "# the derivative work available to others as provided herein, then",
            "# Licensee hereby agrees to include in any such work a brief summary of",
            "# the changes made to Python.",
            "#",
            "# 4. PSF is making Python available to Licensee on an \"AS IS\"",
            "# basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR",
            "# IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND",
            "# DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS",
            "# FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT",
            "# INFRINGE ANY THIRD PARTY RIGHTS.",
            "#",
            "# 5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON",
            "# FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS",
            "# A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON,",
            "# OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.",
            "#",
            "# 6. This License Agreement will automatically terminate upon a material",
            "# breach of its terms and conditions.",
            "#",
            "# 7. Nothing in this License Agreement shall be deemed to create any",
            "# relationship of agency, partnership, or joint venture between PSF and",
            "# Licensee.  This License Agreement does not grant permission to use PSF",
            "# trademarks or trade name in a trademark sense to endorse or promote",
            "# products or services of Licensee, or any third party.",
            "#",
            "# 8. By copying, installing or otherwise using Python, Licensee",
            "# agrees to be bound by the terms and conditions of this License",
            "# Agreement.",
            "#",
            "# Original Python Recipe for Proxy:",
            "# http://code.activestate.com/recipes/496741-object-proxying/",
            "# Author: Tomer Filiba",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "from ansible.module_utils._text import to_bytes, to_text",
            "from ansible.module_utils.common._collections_compat import Mapping, MutableSequence, Set",
            "from ansible.module_utils.six import string_types, binary_type, text_type",
            "",
            "",
            "__all__ = ['AnsibleUnsafe', 'wrap_var']",
            "",
            "",
            "class AnsibleUnsafe(object):",
            "    __UNSAFE__ = True",
            "",
            "",
            "class AnsibleUnsafeBytes(binary_type, AnsibleUnsafe):",
            "    def decode(self, *args, **kwargs):",
            "        \"\"\"Wrapper method to ensure type conversions maintain unsafe context\"\"\"",
            "        return AnsibleUnsafeText(super(AnsibleUnsafeBytes, self).decode(*args, **kwargs))",
            "",
            "",
            "class AnsibleUnsafeText(text_type, AnsibleUnsafe):",
            "    def encode(self, *args, **kwargs):",
            "        \"\"\"Wrapper method to ensure type conversions maintain unsafe context\"\"\"",
            "        return AnsibleUnsafeBytes(super(AnsibleUnsafeText, self).encode(*args, **kwargs))",
            "",
            "",
            "class UnsafeProxy(object):",
            "    def __new__(cls, obj, *args, **kwargs):",
            "        from ansible.utils.display import Display",
            "        Display().deprecated(",
            "            'UnsafeProxy is being deprecated. Use wrap_var or AnsibleUnsafeBytes/AnsibleUnsafeText directly instead',",
            "            version='2.13'",
            "        )",
            "        # In our usage we should only receive unicode strings.",
            "        # This conditional and conversion exists to sanity check the values",
            "        # we're given but we may want to take it out for testing and sanitize",
            "        # our input instead.",
            "        if isinstance(obj, AnsibleUnsafe):",
            "            return obj",
            "",
            "        if isinstance(obj, string_types):",
            "            obj = AnsibleUnsafeText(to_text(obj, errors='surrogate_or_strict'))",
            "        return obj",
            "",
            "",
            "def _wrap_dict(v):",
            "    for k in v.keys():",
            "        if v[k] is not None:",
            "            v[wrap_var(k)] = wrap_var(v[k])",
            "    return v",
            "",
            "",
            "def _wrap_list(v):",
            "    for idx, item in enumerate(v):",
            "        if item is not None:",
            "            v[idx] = wrap_var(item)",
            "    return v",
            "",
            "",
            "def _wrap_set(v):",
            "    return set(item if item is None else wrap_var(item) for item in v)",
            "",
            "",
            "def wrap_var(v):",
            "    if isinstance(v, AnsibleUnsafe):",
            "        return v",
            "",
            "    if isinstance(v, Mapping):",
            "        v = _wrap_dict(v)",
            "    elif isinstance(v, MutableSequence):",
            "        v = _wrap_list(v)",
            "    elif isinstance(v, Set):",
            "        v = _wrap_set(v)",
            "    elif isinstance(v, binary_type):",
            "        v = AnsibleUnsafeBytes(v)",
            "    elif isinstance(v, text_type):",
            "        v = AnsibleUnsafeText(v)",
            "",
            "    return v",
            "",
            "",
            "def to_unsafe_bytes(*args, **kwargs):",
            "    return wrap_var(to_bytes(*args, **kwargs))",
            "",
            "",
            "def to_unsafe_text(*args, **kwargs):",
            "    return wrap_var(to_text(*args, **kwargs))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "AnsibleUnsafeBytes"
            ],
            "73": [
                "AnsibleUnsafeText"
            ]
        },
        "addLocation": []
    }
}