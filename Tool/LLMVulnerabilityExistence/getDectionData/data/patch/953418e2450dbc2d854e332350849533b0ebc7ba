{
    "firstuseauthenticator/firstuseauthenticator.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " password for that account. It is hashed with bcrypt & stored"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " locally in a dbm file, and checked next time they log in."
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import dbm"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import os"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+import shutil"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+import bcrypt"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+import dbm"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from jinja2 import ChoiceLoader, FileSystemLoader"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from jupyterhub.auth import Authenticator"
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from jupyterhub.handlers import BaseHandler"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from tornado import web"
            },
            "13": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from traitlets.traitlets import Unicode, Bool, Integer"
            },
            "14": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import bcrypt"
            },
            "16": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "17": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " TEMPLATE_DIR = os.path.join(os.path.dirname(__file__), 'templates')"
            },
            "19": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         self._loaded = False"
            },
            "21": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         super().__init__(*args, **kwargs)"
            },
            "22": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "24": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     def _register_template_path(self):"
            },
            "25": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         if self._loaded:"
            },
            "26": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             return"
            },
            "27": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         self._loaded = True"
            },
            "29": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     @web.authenticated"
            },
            "32": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     async def get(self):"
            },
            "33": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         self._register_template_path()"
            },
            "34": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         html = await self.render_template('reset.html')"
            },
            "35": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         self.finish(html)"
            },
            "36": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "38": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     @web.authenticated"
            },
            "39": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     async def post(self):"
            },
            "40": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         user = self.current_user"
            },
            "41": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         \"\"\""
            },
            "42": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     )"
            },
            "43": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    check_passwords_on_startup = Bool("
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        True,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        config=True,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        help=\"\"\""
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        Check for non-normalized-username passwords on startup."
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        Prior to 1.0, multiple passwords could be set for the same username,"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        without normalization."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        When True, duplicate usernames will be detected and removed,"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        and ensure all usernames are normalized."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        If any duplicates are found, a backup of the original is created,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        which can be inspected manually."
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        Typically, this will only need to run once."
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        \"\"\","
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    )"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    def __init__(self, **kwargs):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        super().__init__(**kwargs)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        if self.check_passwords_on_startup:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            self._check_passwords()"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    def _check_passwords(self):"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        \"\"\"Validation checks on the password database at startup"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        Mainly checks for the presence of passwords for non-normalized usernames"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        If a username is present only in one non-normalized form,"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        it will be renamed to the normalized form."
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        If multiple forms of the same normalized username are present,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        ensure that at least the normalized form is also present."
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        It will continue to produce warnings until manual intervention removes the non-normalized entries."
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        Non-normalized entries will never be used during login."
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        \"\"\""
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        # it's nontrival to check for db existence, because there are so many extensions"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        # and you don't give dbm a path, you give it a *base* name,"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        # which may point to one or more paths."
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        # There's no way to retrieve the actual path(s) for a db"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        dbm_extensions = (\"\", \".db\", \".pag\", \".dir\", \".dat\", \".bak\")"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        dbm_files = list("
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            filter(os.path.isfile, (self.dbm_path + ext for ext in dbm_extensions))"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        )"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        if not dbm_files:"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            # no database, nothing to do"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            return"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        backup_path = self.dbm_path + \"-backup\""
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        backup_files = list("
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+            filter(os.path.isfile, (backup_path + ext for ext in dbm_extensions))"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        )"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        collision_warning = ("
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            f\"Duplicate password entries have been found, and stored in {backup_path!r}.\""
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            f\" Duplicate entries have been removed from {self.dbm_path!r}.\""
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            f\" If you are happy with the solution, you can delete the backup file(s): {' '.join(backup_files)}.\""
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            \" Or you can inspect the backup database with:\\n\""
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            \"    import dbm\\n\""
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            f\"    with dbm.open({backup_path!r}, 'r') as db:\\n\""
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+            \"        for username in db.keys():\\n\""
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+            \"            print(username, db[username])\\n\""
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        )"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        if backup_files:"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            self.log.warning(collision_warning)"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            return"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        # create a temporary backup of the passwords db"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        # to be retained only if collisions are detected"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        # or deleted if no collisions are detected"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        backup_files = []"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        for path in dbm_files:"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            base, ext = os.path.splitext(path)"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            if ext not in dbm_extensions:"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                # catch weird names with '.' and no .db extension"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                base = path"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                ext = \"\""
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            backup = f\"{base}-backup{ext}\""
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+            shutil.copyfile(path, backup)"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+            backup_files.append(backup)"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        collision_found = False"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        with dbm.open(self.dbm_path, \"w\") as db:"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            # load the username:hashed_password dict"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+            passwords = {}"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+            for key in db.keys():"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                passwords[key.decode(\"utf8\")] = db[key]"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+            # normalization map"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            # compute the full map before checking in case two non-normalized forms are used"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            # keys are normalized usernames,"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            # values are lists of all names present in the db"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+            # which normalize to the same user"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            normalized_usernames = {}"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            for username in passwords:"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+                normalized_username = self.normalize_username(username)"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+                normalized_usernames.setdefault(normalized_username, []).append("
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+                    username"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                )"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            # check if any non-normalized usernames are in the db"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+            for normalized_username, usernames in normalized_usernames.items():"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+                # case 1. only one form, make sure it's stored in the normalized username"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+                if len(usernames) == 1:"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+                    username = usernames[0]"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+                    # case 1.a only normalized form, nothing to do"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+                    if username == normalized_username:"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                        continue"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+                    # 1.b only one form, not normalized. Unambiguous to fix."
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+                    # move password from non-normalized to normalized."
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+                    self.log.warning("
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+                        f\"Normalizing username in password db {username}->{normalized_username}\""
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                    )"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                    db[normalized_username.encode(\"utf8\")] = passwords[username]"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+                    del db[username]"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+                else:"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+                    # collision! Multiple passwords for the same Hub user with different normalization"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+                    # do not clear these automatically because the 'right' answer is ambiguous,"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                    # but make sure the normalized_username is set,"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+                    # so that after upgrade, there is always a password set"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+                    # the non-normalized username passwords will never be used"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+                    # after jupyterhub-firstuseauthenticator 1.0"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+                    self.log.warning("
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+                        f\"{len(usernames)} variations of the username {normalized_username} present in password database: {usernames}.\""
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+                        f\" Only the password stored for the normalized {normalized_username} will be used.\""
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+                    )"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+                    collision_found = True"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+                    if normalized_username not in passwords:"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+                        # we choose usernames[0] as most likely to be the first entry"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+                        # this isn't guaranteed, but it's the best information we have"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+                        username = usernames[0]"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+                        self.log.warning("
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+                            f\"Normalizing username in password db {username}->{normalized_username}\""
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+                        )"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+                        db[normalized_username.encode(\"utf8\")] = passwords[username]"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+                    for username in usernames:"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+                        if username != normalized_username:"
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+                            self.log.warning("
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                                f\"Removing un-normalized username from password db {username}\""
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+                            )"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+                            del db[username]"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        if collision_found:"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            self.log.warning(collision_warning)"
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        else:"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            # remove backup files, if we didn't find anything to backup"
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+            self.log.debug(f\"No collisions found, removing backup files {backup_files}\")"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+            for path in backup_files:"
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+                try:"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+                    os.remove(path)"
            },
            "199": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+                except FileNotFoundError:"
            },
            "200": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+                    pass"
            },
            "201": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+"
            },
            "202": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "     def _user_exists(self, username):"
            },
            "203": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         \"\"\""
            },
            "204": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         Return true if given user already exists."
            },
            "205": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         return super().validate_username(name)"
            },
            "206": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 298,
                "PatchRowcode": " "
            },
            "207": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "     async def authenticate(self, handler, data):"
            },
            "208": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        username = self.normalize_username(data['username'])"
            },
            "209": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        password = data['password']"
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        username = self.normalize_username(data[\"username\"])"
            },
            "211": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+        password = data[\"password\"]"
            },
            "212": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 302,
                "PatchRowcode": " "
            },
            "213": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "         if not self.create_users:"
            },
            "214": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "             if not self._user_exists(username):"
            },
            "215": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "                 return None"
            },
            "216": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 306,
                "PatchRowcode": " "
            },
            "217": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "         with dbm.open(self.dbm_path, 'c', 0o600) as db:"
            },
            "218": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            stored_pw = db.get(username.encode(), None)"
            },
            "219": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+            stored_pw = db.get(username.encode(\"utf8\"), None)"
            },
            "220": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "221": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "             if stored_pw is not None:"
            },
            "222": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "                 # for existing passwords: ensure password hash match"
            },
            "223": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if bcrypt.hashpw(password.encode(), stored_pw) != stored_pw:"
            },
            "224": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+                if bcrypt.hashpw(password.encode(\"utf8\"), stored_pw) != stored_pw:"
            },
            "225": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "                     return None"
            },
            "226": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "             else:"
            },
            "227": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "                 # for new users: ensure password validity and store password hash"
            },
            "228": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "                     )"
            },
            "229": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "                     self.log.error(handler.custom_login_error)"
            },
            "230": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 322,
                "PatchRowcode": "                     return None"
            },
            "231": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                db[username] = bcrypt.hashpw(password.encode(), bcrypt.gensalt())"
            },
            "232": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+                db[username] = bcrypt.hashpw(password.encode(\"utf8\"), bcrypt.gensalt())"
            },
            "233": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 324,
                "PatchRowcode": " "
            },
            "234": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         return username"
            },
            "235": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 326,
                "PatchRowcode": " "
            },
            "236": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         except KeyError:"
            },
            "237": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "             pass"
            },
            "238": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 339,
                "PatchRowcode": " "
            },
            "239": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "240": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     def reset_password(self, username, new_password):"
            },
            "241": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 341,
                "PatchRowcode": "         \"\"\""
            },
            "242": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 342,
                "PatchRowcode": "         This allows changing the password of a logged user."
            },
            "243": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "             self.log.error(login_err)"
            },
            "244": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "             # Resetting the password will fail if the new password is too short."
            },
            "245": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "             return login_err"
            },
            "246": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with dbm.open(self.dbm_path, 'c', 0o600) as db:"
            },
            "247": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            db[username] = bcrypt.hashpw(new_password.encode(), bcrypt.gensalt())"
            },
            "248": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+        with dbm.open(self.dbm_path, \"c\", 0o600) as db:"
            },
            "249": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+            db[username] = bcrypt.hashpw(new_password.encode(\"utf8\"), bcrypt.gensalt())"
            },
            "250": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         login_msg = \"Your password has been changed successfully!\""
            },
            "251": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "         self.log.info(login_msg)"
            },
            "252": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         return login_msg"
            },
            "253": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 357,
                "PatchRowcode": " "
            },
            "254": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "255": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "     def get_handlers(self, app):"
            },
            "256": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return [(r'/login', CustomLoginHandler), (r'/auth/change-password', ResetPasswordHandler)]"
            },
            "257": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+        return ["
            },
            "258": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+            (r\"/login\", CustomLoginHandler),"
            },
            "259": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+            (r\"/auth/change-password\", ResetPasswordHandler),"
            },
            "260": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        ]"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "JupyterHub Authenticator that lets users set password on first use.",
            "",
            "When users first log in, the password they use becomes their",
            "password for that account. It is hashed with bcrypt & stored",
            "locally in a dbm file, and checked next time they log in.",
            "\"\"\"",
            "import dbm",
            "import os",
            "from jinja2 import ChoiceLoader, FileSystemLoader",
            "from jupyterhub.auth import Authenticator",
            "from jupyterhub.handlers import BaseHandler",
            "from jupyterhub.handlers import LoginHandler",
            "from jupyterhub.orm import User",
            "",
            "from tornado import web",
            "from traitlets.traitlets import Unicode, Bool, Integer",
            "",
            "import bcrypt",
            "",
            "",
            "TEMPLATE_DIR = os.path.join(os.path.dirname(__file__), 'templates')",
            "",
            "",
            "class CustomLoginHandler(LoginHandler):",
            "    \"\"\"",
            "    Render the login page.",
            "",
            "    Allows customising the login error when more specific",
            "    feedback is needed. Checkout",
            "    https://github.com/jupyterhub/firstuseauthenticator/pull/21#discussion_r364252009",
            "    for more details",
            "    \"\"\"",
            "    custom_login_error = ''",
            "",
            "    def _render(self, login_error=None, username=None):",
            "        if self.custom_login_error:",
            "            login_error = self.custom_login_error",
            "        return super()._render(login_error, username)",
            "",
            "",
            "class ResetPasswordHandler(BaseHandler):",
            "    \"\"\"Render the reset password page.\"\"\"",
            "    def __init__(self, *args, **kwargs):",
            "        self._loaded = False",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "    def _register_template_path(self):",
            "        if self._loaded:",
            "            return",
            "",
            "        self.log.debug('Adding %s to template path', TEMPLATE_DIR)",
            "        loader = FileSystemLoader([TEMPLATE_DIR])",
            "",
            "        env = self.settings['jinja2_env']",
            "        previous_loader = env.loader",
            "        env.loader = ChoiceLoader([previous_loader, loader])",
            "",
            "        self._loaded = True",
            "",
            "",
            "    @web.authenticated",
            "    async def get(self):",
            "        self._register_template_path()",
            "        html = await self.render_template('reset.html')",
            "        self.finish(html)",
            "",
            "",
            "    @web.authenticated",
            "    async def post(self):",
            "        user = self.current_user",
            "        new_password = self.get_body_argument('password', strip=False)",
            "        msg = self.authenticator.reset_password(user.name, new_password)",
            "",
            "        if \"success\" in msg:",
            "            alert = \"success\"",
            "        else:",
            "            alert = \"danger\"",
            "",
            "        html = await self.render_template(",
            "            'reset.html',",
            "            result=True,",
            "            alert=alert,",
            "            result_message=msg,",
            "        )",
            "        self.finish(html)",
            "",
            "",
            "class FirstUseAuthenticator(Authenticator):",
            "    \"\"\"",
            "    JupyterHub authenticator that lets users set password on first use.",
            "    \"\"\"",
            "    dbm_path = Unicode(",
            "        'passwords.dbm',",
            "        config=True,",
            "        help=\"\"\"",
            "        Path to store the db file with username / pwd hash in",
            "        \"\"\"",
            "    )",
            "",
            "    create_users = Bool(",
            "        True,",
            "        config=True,",
            "        help=\"\"\"",
            "        Create users if they do not exist already.",
            "",
            "        When set to false, users would have to be explicitly created before",
            "        they can log in. Users can be created via the admin panel or by setting",
            "        whitelist / admin list.",
            "        \"\"\"",
            "    )",
            "",
            "    min_password_length = Integer(",
            "        7,",
            "        config=True,",
            "        help=\"\"\"",
            "        The minimum length of the password when user is created.",
            "        When set to 0, users will be allowed to set 0 length passwords.",
            "        \"\"\"",
            "    )",
            "",
            "    def _user_exists(self, username):",
            "        \"\"\"",
            "        Return true if given user already exists.",
            "",
            "        Note: Depends on internal details of JupyterHub that might change",
            "        across versions. Tested with v0.9",
            "        \"\"\"",
            "        return self.db.query(User).filter_by(name=username).first() is not None",
            "",
            "",
            "    def _validate_password(self, password):",
            "        return len(password) >= self.min_password_length",
            "",
            "",
            "    def validate_username(self, name):",
            "        invalid_chars = [',', ' ']",
            "        if any((char in name) for char in invalid_chars):",
            "            return False",
            "        return super().validate_username(name)",
            "",
            "    async def authenticate(self, handler, data):",
            "        username = self.normalize_username(data['username'])",
            "        password = data['password']",
            "",
            "        if not self.create_users:",
            "            if not self._user_exists(username):",
            "                return None",
            "",
            "        with dbm.open(self.dbm_path, 'c', 0o600) as db:",
            "            stored_pw = db.get(username.encode(), None)",
            "",
            "            if stored_pw is not None:",
            "                # for existing passwords: ensure password hash match",
            "                if bcrypt.hashpw(password.encode(), stored_pw) != stored_pw:",
            "                    return None",
            "            else:",
            "                # for new users: ensure password validity and store password hash",
            "                if not self._validate_password(password):",
            "                    handler.custom_login_error = (",
            "                        'Password too short! Please choose a password at least %d characters long.'",
            "                        % self.min_password_length",
            "                    )",
            "                    self.log.error(handler.custom_login_error)",
            "                    return None",
            "                db[username] = bcrypt.hashpw(password.encode(), bcrypt.gensalt())",
            "",
            "        return username",
            "",
            "",
            "    def delete_user(self, user):",
            "        \"\"\"",
            "        When user is deleted, remove their entry from password db.",
            "",
            "        This lets passwords be reset by deleting users.",
            "        \"\"\"",
            "        try:",
            "            with dbm.open(self.dbm_path, 'c', 0o600) as db:",
            "                del db[user.name]",
            "        except KeyError:",
            "            pass",
            "",
            "",
            "    def reset_password(self, username, new_password):",
            "        \"\"\"",
            "        This allows changing the password of a logged user.",
            "        \"\"\"",
            "        if not self._validate_password(new_password):",
            "            login_err = (",
            "                'Password too short! Please choose a password at least %d characters long.'",
            "                % self.min_password_length",
            "            )",
            "            self.log.error(login_err)",
            "            # Resetting the password will fail if the new password is too short.",
            "            return login_err",
            "        with dbm.open(self.dbm_path, 'c', 0o600) as db:",
            "            db[username] = bcrypt.hashpw(new_password.encode(), bcrypt.gensalt())",
            "        login_msg = \"Your password has been changed successfully!\"",
            "        self.log.info(login_msg)",
            "        return login_msg",
            "",
            "",
            "    def get_handlers(self, app):",
            "        return [(r'/login', CustomLoginHandler), (r'/auth/change-password', ResetPasswordHandler)]"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "JupyterHub Authenticator that lets users set password on first use.",
            "",
            "When users first log in, the password they use becomes their",
            "password for that account. It is hashed with bcrypt & stored",
            "locally in a dbm file, and checked next time they log in.",
            "\"\"\"",
            "import os",
            "import shutil",
            "",
            "import bcrypt",
            "import dbm",
            "from jinja2 import ChoiceLoader, FileSystemLoader",
            "from jupyterhub.auth import Authenticator",
            "from jupyterhub.handlers import BaseHandler",
            "from jupyterhub.handlers import LoginHandler",
            "from jupyterhub.orm import User",
            "",
            "from tornado import web",
            "from traitlets.traitlets import Unicode, Bool, Integer",
            "",
            "",
            "TEMPLATE_DIR = os.path.join(os.path.dirname(__file__), 'templates')",
            "",
            "",
            "class CustomLoginHandler(LoginHandler):",
            "    \"\"\"",
            "    Render the login page.",
            "",
            "    Allows customising the login error when more specific",
            "    feedback is needed. Checkout",
            "    https://github.com/jupyterhub/firstuseauthenticator/pull/21#discussion_r364252009",
            "    for more details",
            "    \"\"\"",
            "    custom_login_error = ''",
            "",
            "    def _render(self, login_error=None, username=None):",
            "        if self.custom_login_error:",
            "            login_error = self.custom_login_error",
            "        return super()._render(login_error, username)",
            "",
            "",
            "class ResetPasswordHandler(BaseHandler):",
            "    \"\"\"Render the reset password page.\"\"\"",
            "    def __init__(self, *args, **kwargs):",
            "        self._loaded = False",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def _register_template_path(self):",
            "        if self._loaded:",
            "            return",
            "",
            "        self.log.debug('Adding %s to template path', TEMPLATE_DIR)",
            "        loader = FileSystemLoader([TEMPLATE_DIR])",
            "",
            "        env = self.settings['jinja2_env']",
            "        previous_loader = env.loader",
            "        env.loader = ChoiceLoader([previous_loader, loader])",
            "",
            "        self._loaded = True",
            "",
            "    @web.authenticated",
            "    async def get(self):",
            "        self._register_template_path()",
            "        html = await self.render_template('reset.html')",
            "        self.finish(html)",
            "",
            "    @web.authenticated",
            "    async def post(self):",
            "        user = self.current_user",
            "        new_password = self.get_body_argument('password', strip=False)",
            "        msg = self.authenticator.reset_password(user.name, new_password)",
            "",
            "        if \"success\" in msg:",
            "            alert = \"success\"",
            "        else:",
            "            alert = \"danger\"",
            "",
            "        html = await self.render_template(",
            "            'reset.html',",
            "            result=True,",
            "            alert=alert,",
            "            result_message=msg,",
            "        )",
            "        self.finish(html)",
            "",
            "",
            "class FirstUseAuthenticator(Authenticator):",
            "    \"\"\"",
            "    JupyterHub authenticator that lets users set password on first use.",
            "    \"\"\"",
            "    dbm_path = Unicode(",
            "        'passwords.dbm',",
            "        config=True,",
            "        help=\"\"\"",
            "        Path to store the db file with username / pwd hash in",
            "        \"\"\"",
            "    )",
            "",
            "    create_users = Bool(",
            "        True,",
            "        config=True,",
            "        help=\"\"\"",
            "        Create users if they do not exist already.",
            "",
            "        When set to false, users would have to be explicitly created before",
            "        they can log in. Users can be created via the admin panel or by setting",
            "        whitelist / admin list.",
            "        \"\"\"",
            "    )",
            "",
            "    min_password_length = Integer(",
            "        7,",
            "        config=True,",
            "        help=\"\"\"",
            "        The minimum length of the password when user is created.",
            "        When set to 0, users will be allowed to set 0 length passwords.",
            "        \"\"\"",
            "    )",
            "",
            "    check_passwords_on_startup = Bool(",
            "        True,",
            "        config=True,",
            "        help=\"\"\"",
            "        Check for non-normalized-username passwords on startup.",
            "",
            "        Prior to 1.0, multiple passwords could be set for the same username,",
            "        without normalization.",
            "",
            "        When True, duplicate usernames will be detected and removed,",
            "        and ensure all usernames are normalized.",
            "",
            "        If any duplicates are found, a backup of the original is created,",
            "        which can be inspected manually.",
            "",
            "        Typically, this will only need to run once.",
            "        \"\"\",",
            "    )",
            "",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "        if self.check_passwords_on_startup:",
            "            self._check_passwords()",
            "",
            "    def _check_passwords(self):",
            "        \"\"\"Validation checks on the password database at startup",
            "",
            "        Mainly checks for the presence of passwords for non-normalized usernames",
            "",
            "        If a username is present only in one non-normalized form,",
            "        it will be renamed to the normalized form.",
            "",
            "        If multiple forms of the same normalized username are present,",
            "        ensure that at least the normalized form is also present.",
            "        It will continue to produce warnings until manual intervention removes the non-normalized entries.",
            "",
            "        Non-normalized entries will never be used during login.",
            "        \"\"\"",
            "",
            "        # it's nontrival to check for db existence, because there are so many extensions",
            "        # and you don't give dbm a path, you give it a *base* name,",
            "        # which may point to one or more paths.",
            "        # There's no way to retrieve the actual path(s) for a db",
            "        dbm_extensions = (\"\", \".db\", \".pag\", \".dir\", \".dat\", \".bak\")",
            "        dbm_files = list(",
            "            filter(os.path.isfile, (self.dbm_path + ext for ext in dbm_extensions))",
            "        )",
            "        if not dbm_files:",
            "            # no database, nothing to do",
            "            return",
            "",
            "        backup_path = self.dbm_path + \"-backup\"",
            "        backup_files = list(",
            "            filter(os.path.isfile, (backup_path + ext for ext in dbm_extensions))",
            "        )",
            "",
            "        collision_warning = (",
            "            f\"Duplicate password entries have been found, and stored in {backup_path!r}.\"",
            "            f\" Duplicate entries have been removed from {self.dbm_path!r}.\"",
            "            f\" If you are happy with the solution, you can delete the backup file(s): {' '.join(backup_files)}.\"",
            "            \" Or you can inspect the backup database with:\\n\"",
            "            \"    import dbm\\n\"",
            "            f\"    with dbm.open({backup_path!r}, 'r') as db:\\n\"",
            "            \"        for username in db.keys():\\n\"",
            "            \"            print(username, db[username])\\n\"",
            "        )",
            "",
            "        if backup_files:",
            "            self.log.warning(collision_warning)",
            "            return",
            "",
            "        # create a temporary backup of the passwords db",
            "        # to be retained only if collisions are detected",
            "        # or deleted if no collisions are detected",
            "        backup_files = []",
            "        for path in dbm_files:",
            "            base, ext = os.path.splitext(path)",
            "            if ext not in dbm_extensions:",
            "                # catch weird names with '.' and no .db extension",
            "                base = path",
            "                ext = \"\"",
            "            backup = f\"{base}-backup{ext}\"",
            "            shutil.copyfile(path, backup)",
            "            backup_files.append(backup)",
            "",
            "        collision_found = False",
            "",
            "        with dbm.open(self.dbm_path, \"w\") as db:",
            "            # load the username:hashed_password dict",
            "            passwords = {}",
            "            for key in db.keys():",
            "                passwords[key.decode(\"utf8\")] = db[key]",
            "",
            "            # normalization map",
            "            # compute the full map before checking in case two non-normalized forms are used",
            "            # keys are normalized usernames,",
            "            # values are lists of all names present in the db",
            "            # which normalize to the same user",
            "            normalized_usernames = {}",
            "            for username in passwords:",
            "                normalized_username = self.normalize_username(username)",
            "                normalized_usernames.setdefault(normalized_username, []).append(",
            "                    username",
            "                )",
            "",
            "            # check if any non-normalized usernames are in the db",
            "            for normalized_username, usernames in normalized_usernames.items():",
            "                # case 1. only one form, make sure it's stored in the normalized username",
            "                if len(usernames) == 1:",
            "                    username = usernames[0]",
            "                    # case 1.a only normalized form, nothing to do",
            "                    if username == normalized_username:",
            "                        continue",
            "                    # 1.b only one form, not normalized. Unambiguous to fix.",
            "                    # move password from non-normalized to normalized.",
            "                    self.log.warning(",
            "                        f\"Normalizing username in password db {username}->{normalized_username}\"",
            "                    )",
            "                    db[normalized_username.encode(\"utf8\")] = passwords[username]",
            "                    del db[username]",
            "                else:",
            "                    # collision! Multiple passwords for the same Hub user with different normalization",
            "                    # do not clear these automatically because the 'right' answer is ambiguous,",
            "                    # but make sure the normalized_username is set,",
            "                    # so that after upgrade, there is always a password set",
            "                    # the non-normalized username passwords will never be used",
            "                    # after jupyterhub-firstuseauthenticator 1.0",
            "                    self.log.warning(",
            "                        f\"{len(usernames)} variations of the username {normalized_username} present in password database: {usernames}.\"",
            "                        f\" Only the password stored for the normalized {normalized_username} will be used.\"",
            "                    )",
            "                    collision_found = True",
            "                    if normalized_username not in passwords:",
            "                        # we choose usernames[0] as most likely to be the first entry",
            "                        # this isn't guaranteed, but it's the best information we have",
            "                        username = usernames[0]",
            "                        self.log.warning(",
            "                            f\"Normalizing username in password db {username}->{normalized_username}\"",
            "                        )",
            "                        db[normalized_username.encode(\"utf8\")] = passwords[username]",
            "                    for username in usernames:",
            "                        if username != normalized_username:",
            "                            self.log.warning(",
            "                                f\"Removing un-normalized username from password db {username}\"",
            "                            )",
            "                            del db[username]",
            "",
            "        if collision_found:",
            "            self.log.warning(collision_warning)",
            "        else:",
            "            # remove backup files, if we didn't find anything to backup",
            "            self.log.debug(f\"No collisions found, removing backup files {backup_files}\")",
            "            for path in backup_files:",
            "                try:",
            "                    os.remove(path)",
            "                except FileNotFoundError:",
            "                    pass",
            "",
            "    def _user_exists(self, username):",
            "        \"\"\"",
            "        Return true if given user already exists.",
            "",
            "        Note: Depends on internal details of JupyterHub that might change",
            "        across versions. Tested with v0.9",
            "        \"\"\"",
            "        return self.db.query(User).filter_by(name=username).first() is not None",
            "",
            "",
            "    def _validate_password(self, password):",
            "        return len(password) >= self.min_password_length",
            "",
            "",
            "    def validate_username(self, name):",
            "        invalid_chars = [',', ' ']",
            "        if any((char in name) for char in invalid_chars):",
            "            return False",
            "        return super().validate_username(name)",
            "",
            "    async def authenticate(self, handler, data):",
            "        username = self.normalize_username(data[\"username\"])",
            "        password = data[\"password\"]",
            "",
            "        if not self.create_users:",
            "            if not self._user_exists(username):",
            "                return None",
            "",
            "        with dbm.open(self.dbm_path, 'c', 0o600) as db:",
            "            stored_pw = db.get(username.encode(\"utf8\"), None)",
            "",
            "            if stored_pw is not None:",
            "                # for existing passwords: ensure password hash match",
            "                if bcrypt.hashpw(password.encode(\"utf8\"), stored_pw) != stored_pw:",
            "                    return None",
            "            else:",
            "                # for new users: ensure password validity and store password hash",
            "                if not self._validate_password(password):",
            "                    handler.custom_login_error = (",
            "                        'Password too short! Please choose a password at least %d characters long.'",
            "                        % self.min_password_length",
            "                    )",
            "                    self.log.error(handler.custom_login_error)",
            "                    return None",
            "                db[username] = bcrypt.hashpw(password.encode(\"utf8\"), bcrypt.gensalt())",
            "",
            "        return username",
            "",
            "",
            "    def delete_user(self, user):",
            "        \"\"\"",
            "        When user is deleted, remove their entry from password db.",
            "",
            "        This lets passwords be reset by deleting users.",
            "        \"\"\"",
            "        try:",
            "            with dbm.open(self.dbm_path, 'c', 0o600) as db:",
            "                del db[user.name]",
            "        except KeyError:",
            "            pass",
            "",
            "    def reset_password(self, username, new_password):",
            "        \"\"\"",
            "        This allows changing the password of a logged user.",
            "        \"\"\"",
            "        if not self._validate_password(new_password):",
            "            login_err = (",
            "                'Password too short! Please choose a password at least %d characters long.'",
            "                % self.min_password_length",
            "            )",
            "            self.log.error(login_err)",
            "            # Resetting the password will fail if the new password is too short.",
            "            return login_err",
            "        with dbm.open(self.dbm_path, \"c\", 0o600) as db:",
            "            db[username] = bcrypt.hashpw(new_password.encode(\"utf8\"), bcrypt.gensalt())",
            "        login_msg = \"Your password has been changed successfully!\"",
            "        self.log.info(login_msg)",
            "        return login_msg",
            "",
            "    def get_handlers(self, app):",
            "        return [",
            "            (r\"/login\", CustomLoginHandler),",
            "            (r\"/auth/change-password\", ResetPasswordHandler),",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "8": [],
            "19": [],
            "20": [],
            "48": [
                "ResetPasswordHandler"
            ],
            "62": [
                "ResetPasswordHandler"
            ],
            "69": [
                "ResetPasswordHandler"
            ],
            "144": [
                "FirstUseAuthenticator"
            ],
            "145": [
                "FirstUseAuthenticator"
            ],
            "152": [
                "FirstUseAuthenticator"
            ],
            "156": [
                "FirstUseAuthenticator"
            ],
            "167": [
                "FirstUseAuthenticator"
            ],
            "184": [
                "FirstUseAuthenticator"
            ],
            "197": [
                "FirstUseAuthenticator",
                "reset_password"
            ],
            "198": [
                "FirstUseAuthenticator",
                "reset_password"
            ],
            "203": [
                "FirstUseAuthenticator"
            ],
            "205": [
                "FirstUseAuthenticator",
                "get_handlers"
            ]
        },
        "addLocation": []
    }
}