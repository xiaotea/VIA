{
    "sap/xssec/jwt_audience_validator.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         if client_id:"
            },
            "1": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             self.trusted_clientids.add(client_id)"
            },
            "2": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def validate_token(self, clientId_from_token=None, audiences_from_token= [], scopes_from_token = []):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    def validate_token(self, clientId_from_token=None, audiences_from_token=[], scopes_from_token=[]):"
            },
            "5": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         self.is_foreign_mode = False"
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         allowed_audiences = self.extract_audiences_from_token(audiences_from_token, scopes_from_token, clientId_from_token)"
            },
            "7": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         if (self.validate_same_clientId(clientId_from_token) == True or"
            },
            "8": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             return False"
            },
            "9": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def extract_audiences_from_token(self, audiences_from_token= [], scopes_from_token= [], clientid_from_token=None):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    def extract_audiences_from_token(self, audiences_from_token=[], scopes_from_token=[], clientid_from_token=None):"
            },
            "13": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         '''"
            },
            "14": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         Extracts Audience From Token"
            },
            "15": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         '''"
            }
        },
        "frontPatchFile": [
            "class JwtAudienceValidator(object):",
            "    '''",
            "     Validates if the jwt access token is intended for the OAuth2 client of this",
            "     application. The aud (audience) claim identifies the recipients the JWT is",
            "    issued for.",
            "",
            "    Validates whether there is one audience that matches one of the configured",
            "    OAuth2 client ids.",
            "    '''",
            "",
            "    DOT = \".\"",
            "",
            "    def __init__(self, clientid):",
            "        self._clientid = clientid",
            "        self._trusted_clientids = set()",
            "        self.trusted_clientids = clientid",
            "        self._is_foreign_mode = False",
            "",
            "",
            "    @property",
            "    def trusted_clientids(self):",
            "        return self._trusted_clientids",
            "",
            "    @trusted_clientids.setter",
            "    def trusted_clientids(self, clientid):",
            "        if clientid:",
            "            self._trusted_clientids.add(clientid)",
            "",
            "    @property",
            "    def is_foreign_mode(self):",
            "        return False",
            "",
            "    @is_foreign_mode.setter",
            "    def is_foreign_mode(self, foreignmode):",
            "        self._is_foreign_mode = foreignmode",
            "",
            "    @property",
            "    def clientid(self):",
            "        return self._clientid",
            "",
            "    @clientid.setter",
            "    def clientid(self, clientId):",
            "        self._clientid = clientId",
            "",
            "    def configure_trusted_clientId(self, client_id):",
            "        if client_id:",
            "            self.trusted_clientids.add(client_id)",
            "",
            "    def validate_token(self, clientId_from_token=None, audiences_from_token= [], scopes_from_token = []):",
            "        self.is_foreign_mode = False",
            "        allowed_audiences = self.extract_audiences_from_token(audiences_from_token, scopes_from_token, clientId_from_token)",
            "        if (self.validate_same_clientId(clientId_from_token) == True or",
            "                self.validate_audience_of_xsuaabrokerclone(allowed_audiences) == True or",
            "                self.validate_default(allowed_audiences)==True):",
            "            return True",
            "        else:",
            "            return False",
            "",
            "",
            "    def extract_audiences_from_token(self, audiences_from_token= [], scopes_from_token= [], clientid_from_token=None):",
            "        '''",
            "        Extracts Audience From Token",
            "        '''",
            "        audiences = []",
            "        token_audiences = audiences_from_token",
            "        for audience in token_audiences:",
            "            if audience.find(self.DOT) > -1:",
            "         # CF UAA derives the audiences from the scopes.",
            "         # In case the scopes contains namespaces, these needs to be removed.",
            "             audience = audience[0:audience.find(self.DOT)].strip()",
            "             if audience and (audience not in audiences):",
            "                audiences.append(audience)",
            "            else:",
            "                audiences.append(audience)",
            "",
            "        if len(audiences) == 0:",
            "",
            "            for scope in scopes_from_token:",
            "",
            "                if scope.find(self.DOT) > -1:",
            "                  audience = scope[0 :scope.find(self.DOT)].strip()",
            "                  if audience :",
            "                    if (audience not in audiences):",
            "                        audiences.append(audience)",
            "",
            "            if (clientid_from_token and (clientid_from_token not in audiences)):",
            "                audiences.append(clientid_from_token)",
            "",
            "        return audiences",
            "",
            "    def validate_same_clientId(self, clientid_from_token):",
            "        if clientid_from_token == self.clientid:",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    def validate_audience_of_xsuaabrokerclone(self, allowed_audiences):",
            "        for configured_clientid in self.trusted_clientids:",
            "            if (\"!b\") in configured_clientid:",
            "             # isBrokerClientId",
            "                for audience in allowed_audiences:",
            "                    if (audience.endswith(\"|\" + configured_clientid)):",
            "                        return True",
            "        self.is_foreign_mode=True",
            "        return False",
            "",
            "    def validate_default(self, allowedAudiences):",
            "        for configuredClientId in self.trusted_clientids:",
            "            if configuredClientId in allowedAudiences:",
            "                return True",
            "",
            "        return False"
        ],
        "afterPatchFile": [
            "class JwtAudienceValidator(object):",
            "    '''",
            "     Validates if the jwt access token is intended for the OAuth2 client of this",
            "     application. The aud (audience) claim identifies the recipients the JWT is",
            "    issued for.",
            "",
            "    Validates whether there is one audience that matches one of the configured",
            "    OAuth2 client ids.",
            "    '''",
            "",
            "    DOT = \".\"",
            "",
            "    def __init__(self, clientid):",
            "        self._clientid = clientid",
            "        self._trusted_clientids = set()",
            "        self.trusted_clientids = clientid",
            "        self._is_foreign_mode = False",
            "",
            "",
            "    @property",
            "    def trusted_clientids(self):",
            "        return self._trusted_clientids",
            "",
            "    @trusted_clientids.setter",
            "    def trusted_clientids(self, clientid):",
            "        if clientid:",
            "            self._trusted_clientids.add(clientid)",
            "",
            "    @property",
            "    def is_foreign_mode(self):",
            "        return False",
            "",
            "    @is_foreign_mode.setter",
            "    def is_foreign_mode(self, foreignmode):",
            "        self._is_foreign_mode = foreignmode",
            "",
            "    @property",
            "    def clientid(self):",
            "        return self._clientid",
            "",
            "    @clientid.setter",
            "    def clientid(self, clientId):",
            "        self._clientid = clientId",
            "",
            "    def configure_trusted_clientId(self, client_id):",
            "        if client_id:",
            "            self.trusted_clientids.add(client_id)",
            "",
            "    def validate_token(self, clientId_from_token=None, audiences_from_token=[], scopes_from_token=[]):",
            "        self.is_foreign_mode = False",
            "        allowed_audiences = self.extract_audiences_from_token(audiences_from_token, scopes_from_token, clientId_from_token)",
            "        if (self.validate_same_clientId(clientId_from_token) == True or",
            "                self.validate_audience_of_xsuaabrokerclone(allowed_audiences) == True or",
            "                self.validate_default(allowed_audiences)==True):",
            "            return True",
            "        else:",
            "            return False",
            "",
            "",
            "    def extract_audiences_from_token(self, audiences_from_token=[], scopes_from_token=[], clientid_from_token=None):",
            "        '''",
            "        Extracts Audience From Token",
            "        '''",
            "        audiences = []",
            "        token_audiences = audiences_from_token",
            "        for audience in token_audiences:",
            "            if audience.find(self.DOT) > -1:",
            "         # CF UAA derives the audiences from the scopes.",
            "         # In case the scopes contains namespaces, these needs to be removed.",
            "             audience = audience[0:audience.find(self.DOT)].strip()",
            "             if audience and (audience not in audiences):",
            "                audiences.append(audience)",
            "            else:",
            "                audiences.append(audience)",
            "",
            "        if len(audiences) == 0:",
            "",
            "            for scope in scopes_from_token:",
            "",
            "                if scope.find(self.DOT) > -1:",
            "                  audience = scope[0 :scope.find(self.DOT)].strip()",
            "                  if audience :",
            "                    if (audience not in audiences):",
            "                        audiences.append(audience)",
            "",
            "            if (clientid_from_token and (clientid_from_token not in audiences)):",
            "                audiences.append(clientid_from_token)",
            "",
            "        return audiences",
            "",
            "    def validate_same_clientId(self, clientid_from_token):",
            "        if clientid_from_token == self.clientid:",
            "            return True",
            "        else:",
            "            return False",
            "",
            "    def validate_audience_of_xsuaabrokerclone(self, allowed_audiences):",
            "        for configured_clientid in self.trusted_clientids:",
            "            if (\"!b\") in configured_clientid:",
            "             # isBrokerClientId",
            "                for audience in allowed_audiences:",
            "                    if (audience.endswith(\"|\" + configured_clientid)):",
            "                        return True",
            "        self.is_foreign_mode=True",
            "        return False",
            "",
            "    def validate_default(self, allowedAudiences):",
            "        for configuredClientId in self.trusted_clientids:",
            "            if configuredClientId in allowedAudiences:",
            "                return True",
            "",
            "        return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "49": [
                "JwtAudienceValidator",
                "validate_token"
            ],
            "60": [
                "JwtAudienceValidator",
                "extract_audiences_from_token"
            ]
        },
        "addLocation": []
    },
    "sap/xssec/security_context_ias.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         check `aud` in jwt token"
            },
            "2": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validation_result = self.audience_validator.validate_token(audiences_from_token=self.token_payload[\"aud\"])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        # Make sure `aud` is a list"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        aud = [self.token_payload[\"aud\"]] if isinstance(self.token_payload[\"aud\"], str) else self.token_payload[\"aud\"]"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        validation_result = self.audience_validator.validate_token(audiences_from_token=aud)"
            },
            "9": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         if validation_result is False:"
            },
            "10": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             raise RuntimeError('Audience Validation Failed')"
            },
            "11": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         return self"
            }
        },
        "frontPatchFile": [
            "\"\"\" Security Context class for IAS support\"\"\"",
            "import logging",
            "from typing import List, Dict",
            "from urllib3.util import Url, parse_url  # type: ignore",
            "from sap.xssec.jwt_audience_validator import JwtAudienceValidator",
            "from sap.xssec.jwt_validation_facade import JwtValidationFacade, DecodeError",
            "from sap.xssec.key_cache import KeyCache",
            "from sap.xssec.key_cache_v2 import get_verification_key_ias",
            "",
            "",
            "class SecurityContextIAS(object):",
            "    \"\"\" SecurityContextIAS class \"\"\"",
            "",
            "    verificationKeyCache = KeyCache()",
            "",
            "    def __init__(self, token: str, service_credentials: Dict[str, str]):",
            "        self.token = token",
            "        self.service_credentials = service_credentials",
            "        self.logger = logging.getLogger(__name__)",
            "        self.jwt_validator = JwtValidationFacade()",
            "        self.audience_validator = JwtAudienceValidator(self.service_credentials[\"clientid\"])",
            "        try:",
            "            self.token_payload = self.jwt_validator.decode(token, False)",
            "            self.token_header = self.jwt_validator.get_unverified_header(token)",
            "            self.validate_issuer().validate_timestamp().validate_audience().validate_signature()",
            "        except DecodeError:",
            "            raise ValueError(\"Failed to decode provided token\")",
            "",
            "    def get_issuer(self):",
            "        return self.token_payload.get(\"ias_iss\") or self.token_payload[\"iss\"]",
            "",
            "    def validate_issuer(self):",
            "        \"\"\"",
            "        check `ias_iss` or `iss` in jwt token",
            "        \"\"\"",
            "        issuer_url: Url = parse_url(self.get_issuer())",
            "        if issuer_url.scheme != \"https\":",
            "            raise ValueError(\"Token's issuer has wrong protocol ({})\".format(issuer_url.scheme))",
            "",
            "        if issuer_url.query is not None:",
            "            raise ValueError(\"Token's issuer has unallowed query value ({})\".format(issuer_url.query))",
            "",
            "        if issuer_url.fragment is not None:",
            "            raise ValueError(\"Token's issuer has unallowed hash value ({})\".format(issuer_url.fragment))",
            "",
            "        domains: List[str] = self.service_credentials.get(\"domains\") or (",
            "            [self.service_credentials[\"domain\"]] if \"domain\" in self.service_credentials else [])",
            "        if not any(map(lambda d: issuer_url.host.endswith(d), domains)):",
            "            raise ValueError(\"Token's issuer is not found in domain list {}\".format(\", \".join(domains)))",
            "",
            "        return self",
            "",
            "    def validate_timestamp(self):",
            "        \"\"\"",
            "        check `exp` in jwt token",
            "        \"\"\"",
            "        if self.jwt_validator.has_token_expired(self.token):",
            "            raise ValueError(\"Token has expired\")",
            "        return self",
            "",
            "    def validate_audience(self):",
            "        \"\"\"",
            "        check `aud` in jwt token",
            "        \"\"\"",
            "        validation_result = self.audience_validator.validate_token(audiences_from_token=self.token_payload[\"aud\"])",
            "        if validation_result is False:",
            "            raise RuntimeError('Audience Validation Failed')",
            "        return self",
            "",
            "    def validate_signature(self):",
            "        \"\"\"",
            "        check signature in jwt token",
            "        \"\"\"",
            "        verification_key: str = get_verification_key_ias(",
            "            self.get_issuer(), self.token_payload.get(\"zone_uuid\"), self.token_header[\"kid\"])",
            "",
            "        result_code = self.jwt_validator.loadPEM(verification_key)",
            "        if result_code != 0:",
            "            raise RuntimeError('Invalid verification key, result code {0}'.format(result_code))",
            "",
            "        self.jwt_validator.checkToken(self.token)",
            "        error_description = self.jwt_validator.getErrorDescription()",
            "        if error_description != '':",
            "            raise RuntimeError(",
            "                'Error in validation of access token: {0}, result code {1}'.format(",
            "                    error_description, self.jwt_validator.getErrorRC()))",
            "",
            "        return self"
        ],
        "afterPatchFile": [
            "\"\"\" Security Context class for IAS support\"\"\"",
            "import logging",
            "from typing import List, Dict",
            "from urllib3.util import Url, parse_url  # type: ignore",
            "from sap.xssec.jwt_audience_validator import JwtAudienceValidator",
            "from sap.xssec.jwt_validation_facade import JwtValidationFacade, DecodeError",
            "from sap.xssec.key_cache import KeyCache",
            "from sap.xssec.key_cache_v2 import get_verification_key_ias",
            "",
            "",
            "class SecurityContextIAS(object):",
            "    \"\"\" SecurityContextIAS class \"\"\"",
            "",
            "    verificationKeyCache = KeyCache()",
            "",
            "    def __init__(self, token: str, service_credentials: Dict[str, str]):",
            "        self.token = token",
            "        self.service_credentials = service_credentials",
            "        self.logger = logging.getLogger(__name__)",
            "        self.jwt_validator = JwtValidationFacade()",
            "        self.audience_validator = JwtAudienceValidator(self.service_credentials[\"clientid\"])",
            "        try:",
            "            self.token_payload = self.jwt_validator.decode(token, False)",
            "            self.token_header = self.jwt_validator.get_unverified_header(token)",
            "            self.validate_issuer().validate_timestamp().validate_audience().validate_signature()",
            "        except DecodeError:",
            "            raise ValueError(\"Failed to decode provided token\")",
            "",
            "    def get_issuer(self):",
            "        return self.token_payload.get(\"ias_iss\") or self.token_payload[\"iss\"]",
            "",
            "    def validate_issuer(self):",
            "        \"\"\"",
            "        check `ias_iss` or `iss` in jwt token",
            "        \"\"\"",
            "        issuer_url: Url = parse_url(self.get_issuer())",
            "        if issuer_url.scheme != \"https\":",
            "            raise ValueError(\"Token's issuer has wrong protocol ({})\".format(issuer_url.scheme))",
            "",
            "        if issuer_url.query is not None:",
            "            raise ValueError(\"Token's issuer has unallowed query value ({})\".format(issuer_url.query))",
            "",
            "        if issuer_url.fragment is not None:",
            "            raise ValueError(\"Token's issuer has unallowed hash value ({})\".format(issuer_url.fragment))",
            "",
            "        domains: List[str] = self.service_credentials.get(\"domains\") or (",
            "            [self.service_credentials[\"domain\"]] if \"domain\" in self.service_credentials else [])",
            "        if not any(map(lambda d: issuer_url.host.endswith(d), domains)):",
            "            raise ValueError(\"Token's issuer is not found in domain list {}\".format(\", \".join(domains)))",
            "",
            "        return self",
            "",
            "    def validate_timestamp(self):",
            "        \"\"\"",
            "        check `exp` in jwt token",
            "        \"\"\"",
            "        if self.jwt_validator.has_token_expired(self.token):",
            "            raise ValueError(\"Token has expired\")",
            "        return self",
            "",
            "    def validate_audience(self):",
            "        \"\"\"",
            "        check `aud` in jwt token",
            "        \"\"\"",
            "",
            "        # Make sure `aud` is a list",
            "        aud = [self.token_payload[\"aud\"]] if isinstance(self.token_payload[\"aud\"], str) else self.token_payload[\"aud\"]",
            "        ",
            "        validation_result = self.audience_validator.validate_token(audiences_from_token=aud)",
            "        if validation_result is False:",
            "            raise RuntimeError('Audience Validation Failed')",
            "        return self",
            "",
            "    def validate_signature(self):",
            "        \"\"\"",
            "        check signature in jwt token",
            "        \"\"\"",
            "        verification_key: str = get_verification_key_ias(",
            "            self.get_issuer(), self.token_payload.get(\"zone_uuid\"), self.token_header[\"kid\"])",
            "",
            "        result_code = self.jwt_validator.loadPEM(verification_key)",
            "        if result_code != 0:",
            "            raise RuntimeError('Invalid verification key, result code {0}'.format(result_code))",
            "",
            "        self.jwt_validator.checkToken(self.token)",
            "        error_description = self.jwt_validator.getErrorDescription()",
            "        if error_description != '':",
            "            raise RuntimeError(",
            "                'Error in validation of access token: {0}, result code {1}'.format(",
            "                    error_description, self.jwt_validator.getErrorRC()))",
            "",
            "        return self"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "65": [
                "SecurityContextIAS",
                "validate_audience"
            ]
        },
        "addLocation": []
    }
}