{
    "libcloud/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " __all__ = ['__version__', 'enable_debug']"
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = '0.11.0'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+__version__ = '0.11.1'"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " try:"
            },
            "7": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     import paramiko"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one or more",
            "# contributor license agreements.  See the NOTICE file distributed with",
            "# this work for additional information regarding copyright ownership.",
            "# The ASF licenses this file to You under the Apache License, Version 2.0",
            "# (the \"License\"); you may not use this file except in compliance with",
            "# the License.  You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"",
            "libcloud provides a unified interface to the cloud computing resources.",
            "",
            "@var __version__: Current version of libcloud",
            "\"\"\"",
            "",
            "__all__ = ['__version__', 'enable_debug']",
            "__version__ = '0.11.0'",
            "",
            "try:",
            "    import paramiko",
            "    have_paramiko = True",
            "except ImportError:",
            "    have_paramiko = False",
            "",
            "",
            "def enable_debug(fo):",
            "    \"\"\"",
            "    Enable library wide debugging to a file-like object.",
            "",
            "    @param fo: Where to append debugging information",
            "    @type fo: File like object, only write operations are used.",
            "    \"\"\"",
            "    from libcloud.common.base import (Connection,",
            "                               LoggingHTTPConnection,",
            "                               LoggingHTTPSConnection)",
            "    LoggingHTTPSConnection.log = fo",
            "    LoggingHTTPConnection.log = fo",
            "    Connection.conn_classes = (LoggingHTTPConnection,",
            "                                  LoggingHTTPSConnection)",
            "",
            "",
            "def _init_once():",
            "    \"\"\"",
            "    Utility function that is ran once on Library import.",
            "",
            "    This checks for the LIBCLOUD_DEBUG enviroment variable, which if it exists",
            "    is where we will log debug information about the provider transports.",
            "    \"\"\"",
            "    import os",
            "    path = os.getenv('LIBCLOUD_DEBUG')",
            "    if path:",
            "        fo = open(path, 'a')",
            "        enable_debug(fo)",
            "",
            "        if have_paramiko:",
            "            paramiko.common.logging.basicConfig(level=paramiko.common.DEBUG)",
            "",
            "_init_once()"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one or more",
            "# contributor license agreements.  See the NOTICE file distributed with",
            "# this work for additional information regarding copyright ownership.",
            "# The ASF licenses this file to You under the Apache License, Version 2.0",
            "# (the \"License\"); you may not use this file except in compliance with",
            "# the License.  You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "\"\"\"",
            "libcloud provides a unified interface to the cloud computing resources.",
            "",
            "@var __version__: Current version of libcloud",
            "\"\"\"",
            "",
            "__all__ = ['__version__', 'enable_debug']",
            "__version__ = '0.11.1'",
            "",
            "try:",
            "    import paramiko",
            "    have_paramiko = True",
            "except ImportError:",
            "    have_paramiko = False",
            "",
            "",
            "def enable_debug(fo):",
            "    \"\"\"",
            "    Enable library wide debugging to a file-like object.",
            "",
            "    @param fo: Where to append debugging information",
            "    @type fo: File like object, only write operations are used.",
            "    \"\"\"",
            "    from libcloud.common.base import (Connection,",
            "                               LoggingHTTPConnection,",
            "                               LoggingHTTPSConnection)",
            "    LoggingHTTPSConnection.log = fo",
            "    LoggingHTTPConnection.log = fo",
            "    Connection.conn_classes = (LoggingHTTPConnection,",
            "                                  LoggingHTTPSConnection)",
            "",
            "",
            "def _init_once():",
            "    \"\"\"",
            "    Utility function that is ran once on Library import.",
            "",
            "    This checks for the LIBCLOUD_DEBUG enviroment variable, which if it exists",
            "    is where we will log debug information about the provider transports.",
            "    \"\"\"",
            "    import os",
            "    path = os.getenv('LIBCLOUD_DEBUG')",
            "    if path:",
            "        fo = open(path, 'a')",
            "        enable_debug(fo)",
            "",
            "        if have_paramiko:",
            "            paramiko.common.logging.basicConfig(level=paramiko.common.DEBUG)",
            "",
            "_init_once()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [
                "__version__"
            ]
        },
        "addLocation": []
    },
    "libcloud/httplib_ssl.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         # replace * with alphanumeric and dash"
            },
            "1": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         # replace . with literal ."
            },
            "2": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         valid_patterns = ["
            },
            "3": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            re.compile("
            },
            "4": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                pattern.replace("
            },
            "5": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    r\".\", r\"\\.\""
            },
            "6": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                ).replace("
            },
            "7": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    r\"*\", r\"[0-9A-Za-z]+\""
            },
            "8": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "9": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            re.compile('^' + pattern.replace(r\".\", r\"\\.\") \\"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+                                    .replace(r\"*\", r\"[0-9A-Za-z]+\") + '$')"
            },
            "12": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "             for pattern in (set(common_name) | set(alt_names))]"
            },
            "13": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         return any("
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one or more",
            "# contributor license agreements.  See the NOTICE file distributed with",
            "# this work for additional information regarding copyright ownership.",
            "# The ASF licenses this file to You under the Apache License, Version 2.0",
            "# (the \"License\"); you may not use this file except in compliance with",
            "# the License.  You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "\"\"\"",
            "Subclass for httplib.HTTPSConnection with optional certificate name",
            "verification, depending on libcloud.security settings.",
            "\"\"\"",
            "import os",
            "import re",
            "import socket",
            "import ssl",
            "import warnings",
            "",
            "import libcloud.security",
            "from libcloud.utils.py3 import httplib",
            "",
            "",
            "class LibcloudHTTPSConnection(httplib.HTTPSConnection):",
            "    \"\"\"LibcloudHTTPSConnection",
            "",
            "    Subclass of HTTPSConnection which verifies certificate names",
            "    if and only if CA certificates are available.",
            "    \"\"\"",
            "    verify = False        # does not verify",
            "    ca_cert = None        # no default CA Certificate",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"Constructor",
            "        \"\"\"",
            "        self._setup_verify()",
            "        httplib.HTTPSConnection.__init__(self, *args, **kwargs)",
            "",
            "    def _setup_verify(self):",
            "        \"\"\"Setup Verify SSL or not",
            "",
            "        Reads security module's VERIFY_SSL_CERT and toggles whether",
            "        the class overrides the connect() class method or runs the",
            "        inherited httplib.HTTPSConnection connect()",
            "        \"\"\"",
            "        self.verify = libcloud.security.VERIFY_SSL_CERT",
            "        self.strict = libcloud.security.VERIFY_SSL_CERT_STRICT",
            "",
            "        if self.verify:",
            "            self._setup_ca_cert()",
            "        else:",
            "            warnings.warn(libcloud.security.VERIFY_SSL_DISABLED_MSG)",
            "",
            "    def _setup_ca_cert(self):",
            "        \"\"\"Setup CA Certs",
            "",
            "        Search in CA_CERTS_PATH for valid candidates and",
            "        return first match.  Otherwise, complain about certs",
            "        not being available.",
            "        \"\"\"",
            "        if not self.verify:",
            "            return",
            "",
            "        ca_certs_available = [cert",
            "                              for cert in libcloud.security.CA_CERTS_PATH",
            "                              if os.path.exists(cert)]",
            "        if ca_certs_available:",
            "            # use first available certificate",
            "            self.ca_cert = ca_certs_available[0]",
            "        else:",
            "            if self.strict:",
            "                raise RuntimeError(",
            "                    libcloud.security.CA_CERTS_UNAVAILABLE_ERROR_MSG)",
            "            else:",
            "                # no certificates found; toggle verify to False",
            "                warnings.warn(",
            "                    libcloud.security.CA_CERTS_UNAVAILABLE_WARNING_MSG)",
            "                self.ca_cert = None",
            "                self.verify = False",
            "",
            "    def connect(self):",
            "        \"\"\"Connect",
            "",
            "        Checks if verification is toggled; if not, just call",
            "        httplib.HTTPSConnection's connect",
            "        \"\"\"",
            "        if not self.verify:",
            "            return httplib.HTTPSConnection.connect(self)",
            "",
            "        # otherwise, create a connection and verify the hostname",
            "        # use socket.create_connection (in 2.6+) if possible",
            "        if getattr(socket, 'create_connection', None):",
            "            sock = socket.create_connection((self.host, self.port),",
            "                                            self.timeout)",
            "        else:",
            "            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "            sock.connect((self.host, self.port))",
            "        self.sock = ssl.wrap_socket(sock,",
            "                                    self.key_file,",
            "                                    self.cert_file,",
            "                                    cert_reqs=ssl.CERT_REQUIRED,",
            "                                    ca_certs=self.ca_cert,",
            "                                    ssl_version=ssl.PROTOCOL_TLSv1)",
            "        cert = self.sock.getpeercert()",
            "        if not self._verify_hostname(self.host, cert):",
            "            raise ssl.SSLError('Failed to verify hostname')",
            "",
            "    def _verify_hostname(self, hostname, cert):",
            "        \"\"\"Verify hostname against peer cert",
            "",
            "        Check both commonName and entries in subjectAltName, using a",
            "        rudimentary glob to dns regex check to find matches",
            "        \"\"\"",
            "        common_name = self._get_common_name(cert)",
            "        alt_names = self._get_subject_alt_names(cert)",
            "",
            "        # replace * with alphanumeric and dash",
            "        # replace . with literal .",
            "        valid_patterns = [",
            "            re.compile(",
            "                pattern.replace(",
            "                    r\".\", r\"\\.\"",
            "                ).replace(",
            "                    r\"*\", r\"[0-9A-Za-z]+\"",
            "                )",
            "            )",
            "            for pattern in (set(common_name) | set(alt_names))]",
            "",
            "        return any(",
            "            pattern.search(hostname)",
            "            for pattern in valid_patterns",
            "        )",
            "",
            "    def _get_subject_alt_names(self, cert):",
            "        \"\"\"Get SubjectAltNames",
            "",
            "        Retrieve 'subjectAltName' attributes from cert data structure",
            "        \"\"\"",
            "        if 'subjectAltName' not in cert:",
            "            values = []",
            "        else:",
            "            values = [value",
            "                      for field, value in cert['subjectAltName']",
            "                      if field == 'DNS']",
            "        return values",
            "",
            "    def _get_common_name(self, cert):",
            "        \"\"\"Get Common Name",
            "",
            "        Retrieve 'commonName' attribute from cert data structure",
            "        \"\"\"",
            "        if 'subject' not in cert:",
            "            return None",
            "        values = [value[0][1]",
            "                  for value in cert['subject']",
            "                  if value[0][0] == 'commonName']",
            "        return values"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one or more",
            "# contributor license agreements.  See the NOTICE file distributed with",
            "# this work for additional information regarding copyright ownership.",
            "# The ASF licenses this file to You under the Apache License, Version 2.0",
            "# (the \"License\"); you may not use this file except in compliance with",
            "# the License.  You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "\"\"\"",
            "Subclass for httplib.HTTPSConnection with optional certificate name",
            "verification, depending on libcloud.security settings.",
            "\"\"\"",
            "import os",
            "import re",
            "import socket",
            "import ssl",
            "import warnings",
            "",
            "import libcloud.security",
            "from libcloud.utils.py3 import httplib",
            "",
            "",
            "class LibcloudHTTPSConnection(httplib.HTTPSConnection):",
            "    \"\"\"LibcloudHTTPSConnection",
            "",
            "    Subclass of HTTPSConnection which verifies certificate names",
            "    if and only if CA certificates are available.",
            "    \"\"\"",
            "    verify = False        # does not verify",
            "    ca_cert = None        # no default CA Certificate",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"Constructor",
            "        \"\"\"",
            "        self._setup_verify()",
            "        httplib.HTTPSConnection.__init__(self, *args, **kwargs)",
            "",
            "    def _setup_verify(self):",
            "        \"\"\"Setup Verify SSL or not",
            "",
            "        Reads security module's VERIFY_SSL_CERT and toggles whether",
            "        the class overrides the connect() class method or runs the",
            "        inherited httplib.HTTPSConnection connect()",
            "        \"\"\"",
            "        self.verify = libcloud.security.VERIFY_SSL_CERT",
            "        self.strict = libcloud.security.VERIFY_SSL_CERT_STRICT",
            "",
            "        if self.verify:",
            "            self._setup_ca_cert()",
            "        else:",
            "            warnings.warn(libcloud.security.VERIFY_SSL_DISABLED_MSG)",
            "",
            "    def _setup_ca_cert(self):",
            "        \"\"\"Setup CA Certs",
            "",
            "        Search in CA_CERTS_PATH for valid candidates and",
            "        return first match.  Otherwise, complain about certs",
            "        not being available.",
            "        \"\"\"",
            "        if not self.verify:",
            "            return",
            "",
            "        ca_certs_available = [cert",
            "                              for cert in libcloud.security.CA_CERTS_PATH",
            "                              if os.path.exists(cert)]",
            "        if ca_certs_available:",
            "            # use first available certificate",
            "            self.ca_cert = ca_certs_available[0]",
            "        else:",
            "            if self.strict:",
            "                raise RuntimeError(",
            "                    libcloud.security.CA_CERTS_UNAVAILABLE_ERROR_MSG)",
            "            else:",
            "                # no certificates found; toggle verify to False",
            "                warnings.warn(",
            "                    libcloud.security.CA_CERTS_UNAVAILABLE_WARNING_MSG)",
            "                self.ca_cert = None",
            "                self.verify = False",
            "",
            "    def connect(self):",
            "        \"\"\"Connect",
            "",
            "        Checks if verification is toggled; if not, just call",
            "        httplib.HTTPSConnection's connect",
            "        \"\"\"",
            "        if not self.verify:",
            "            return httplib.HTTPSConnection.connect(self)",
            "",
            "        # otherwise, create a connection and verify the hostname",
            "        # use socket.create_connection (in 2.6+) if possible",
            "        if getattr(socket, 'create_connection', None):",
            "            sock = socket.create_connection((self.host, self.port),",
            "                                            self.timeout)",
            "        else:",
            "            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "            sock.connect((self.host, self.port))",
            "        self.sock = ssl.wrap_socket(sock,",
            "                                    self.key_file,",
            "                                    self.cert_file,",
            "                                    cert_reqs=ssl.CERT_REQUIRED,",
            "                                    ca_certs=self.ca_cert,",
            "                                    ssl_version=ssl.PROTOCOL_TLSv1)",
            "        cert = self.sock.getpeercert()",
            "        if not self._verify_hostname(self.host, cert):",
            "            raise ssl.SSLError('Failed to verify hostname')",
            "",
            "    def _verify_hostname(self, hostname, cert):",
            "        \"\"\"Verify hostname against peer cert",
            "",
            "        Check both commonName and entries in subjectAltName, using a",
            "        rudimentary glob to dns regex check to find matches",
            "        \"\"\"",
            "        common_name = self._get_common_name(cert)",
            "        alt_names = self._get_subject_alt_names(cert)",
            "",
            "        # replace * with alphanumeric and dash",
            "        # replace . with literal .",
            "        valid_patterns = [",
            "            re.compile('^' + pattern.replace(r\".\", r\"\\.\") \\",
            "                                    .replace(r\"*\", r\"[0-9A-Za-z]+\") + '$')",
            "            for pattern in (set(common_name) | set(alt_names))]",
            "",
            "        return any(",
            "            pattern.search(hostname)",
            "            for pattern in valid_patterns",
            "        )",
            "",
            "    def _get_subject_alt_names(self, cert):",
            "        \"\"\"Get SubjectAltNames",
            "",
            "        Retrieve 'subjectAltName' attributes from cert data structure",
            "        \"\"\"",
            "        if 'subjectAltName' not in cert:",
            "            values = []",
            "        else:",
            "            values = [value",
            "                      for field, value in cert['subjectAltName']",
            "                      if field == 'DNS']",
            "        return values",
            "",
            "    def _get_common_name(self, cert):",
            "        \"\"\"Get Common Name",
            "",
            "        Retrieve 'commonName' attribute from cert data structure",
            "        \"\"\"",
            "        if 'subject' not in cert:",
            "            return None",
            "        values = [value[0][1]",
            "                  for value in cert['subject']",
            "                  if value[0][0] == 'commonName']",
            "        return values"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "125": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ],
            "126": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ],
            "127": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ],
            "128": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ],
            "129": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ],
            "130": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ],
            "131": [
                "LibcloudHTTPSConnection",
                "_verify_hostname"
            ]
        },
        "addLocation": []
    },
    "libcloud/test/test_httplib_ssl.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "          'subjectAltName': ((('DNS', 'foo.alt.name')),"
            },
            "1": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "                            (('DNS', 'foo.alt.name.1')))}"
            },
            "2": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        cert3 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+         'subject': ((('countryName', 'US'),),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                     (('stateOrProvinceName', 'Delaware'),),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+                     (('localityName', 'Wilmington'),),"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                     (('organizationName', 'Python Software Foundation'),),"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                     (('organizationalUnitName', 'SSL'),),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                     (('commonName', 'python.org'),))}"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         self.assertFalse(self.httplib_object._verify_hostname("
            },
            "12": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "                          hostname='invalid', cert=cert1))"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                         hostname='machine.python.org', cert=cert1))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                         hostname='foomachine.python.org', cert=cert1))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+                        hostname='somesomemachine.python.org', cert=cert1))"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                        hostname='somemachine.python.orga', cert=cert1))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                        hostname='somemachine.python.org.org', cert=cert1))"
            },
            "23": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         self.assertTrue(self.httplib_object._verify_hostname("
            },
            "24": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                         hostname='somemachine.python.org', cert=cert1))"
            },
            "25": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         self.assertFalse(self.httplib_object._verify_hostname("
            },
            "27": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "                          hostname='invalid', cert=cert2))"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                        hostname='afoo.alt.name.1', cert=cert2))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                        hostname='a.foo.alt.name.1', cert=cert2))"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                        hostname='foo.alt.name.1.2', cert=cert2))"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                        hostname='afoo.alt.name.1.2', cert=cert2))"
            },
            "36": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.assertTrue(self.httplib_object._verify_hostname("
            },
            "37": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "                         hostname='foo.alt.name.1', cert=cert2))"
            },
            "38": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        self.assertTrue(self.httplib_object._verify_hostname("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                        hostname='python.org', cert=cert3))"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                        hostname='opython.org', cert=cert3))"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        self.assertFalse(self.httplib_object._verify_hostname("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                        hostname='ython.org', cert=cert3))"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     def test_get_subject_alt_names(self):"
            },
            "47": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         cert1 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',"
            },
            "48": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "          'subject': ((('countryName', 'US'),),"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one or more",
            "# contributor license agreements.  See the NOTICE file distributed with",
            "# this work for additional information regarding copyright ownership.",
            "# The ASF licenses this file to You under the Apache License, Version 2.0",
            "# (the \"License\"); you may not use this file except in compliance with",
            "# the License.  You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import sys",
            "import unittest",
            "import os.path",
            "",
            "import libcloud.security",
            "from libcloud.httplib_ssl import LibcloudHTTPSConnection",
            "",
            "class TestHttpLibSSLTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        libcloud.security.VERIFY_SSL_CERT = False",
            "        self.httplib_object = LibcloudHTTPSConnection('foo.bar')",
            "",
            "    def test_verify_hostname(self):",
            "        cert1 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),))}",
            "",
            "        cert2 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),)),",
            "         'subjectAltName': ((('DNS', 'foo.alt.name')),",
            "                           (('DNS', 'foo.alt.name.1')))}",
            "",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                         hostname='invalid', cert=cert1))",
            "        self.assertTrue(self.httplib_object._verify_hostname(",
            "                        hostname='somemachine.python.org', cert=cert1))",
            "",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                         hostname='invalid', cert=cert2))",
            "        self.assertTrue(self.httplib_object._verify_hostname(",
            "                        hostname='foo.alt.name.1', cert=cert2))",
            "",
            "    def test_get_subject_alt_names(self):",
            "        cert1 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),))}",
            "",
            "        cert2 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),)),",
            "         'subjectAltName': ((('DNS', 'foo.alt.name')),",
            "                           (('DNS', 'foo.alt.name.1')))}",
            "",
            "        self.assertEqual(self.httplib_object._get_subject_alt_names(cert=cert1),",
            "                         [])",
            "",
            "        alt_names = self.httplib_object._get_subject_alt_names(cert=cert2)",
            "        self.assertEqual(len(alt_names), 2)",
            "        self.assertTrue('foo.alt.name' in alt_names)",
            "        self.assertTrue('foo.alt.name.1' in alt_names)",
            "",
            "    def test_get_common_name(self):",
            "        cert = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),))}",
            "",
            "        self.assertEqual(self.httplib_object._get_common_name(cert)[0],",
            "                         'somemachine.python.org')",
            "        self.assertEqual(self.httplib_object._get_common_name({}),",
            "                         None)",
            "",
            "    def test_setup_verify(self):",
            "        # @TODO: catch warnings",
            "        # non-strict mode,s hould just emit a warning",
            "        libcloud.security.VERIFY_SSL_CERT = True",
            "        libcloud.security.VERIFY_SSL_CERT_STRICT = False",
            "        self.httplib_object._setup_verify()",
            "",
            "        # strict mode, should throw a runtime error",
            "        libcloud.security.VERIFY_SSL_CERT = True",
            "        libcloud.security.VERIFY_SSL_CERT_STRICT = True",
            "        try:",
            "            self.httplib_object._setup_verify()",
            "        except:",
            "            pass",
            "        else:",
            "            self.fail('Exception not thrown')",
            "",
            "        libcloud.security.VERIFY_SSL_CERT = False",
            "        libcloud.security.VERIFY_SSL_CERT_STRICT = False",
            "        self.httplib_object._setup_verify()",
            "",
            "    def test_setup_ca_cert(self):",
            "        # @TODO: catch warnings",
            "        self.httplib_object.verify = False",
            "        self.httplib_object.strict = False",
            "        self.httplib_object._setup_ca_cert()",
            "",
            "        self.assertEqual(self.httplib_object.ca_cert, None)",
            "",
            "        self.httplib_object.verify = True",
            "",
            "        libcloud.security.CA_CERTS_PATH = [os.path.abspath(__file__)]",
            "        self.httplib_object._setup_ca_cert()",
            "        self.assertTrue(self.httplib_object.ca_cert is not None)",
            "",
            "        libcloud.security.CA_CERTS_PATH = []",
            "        self.httplib_object._setup_ca_cert()",
            "        self.assertFalse(self.httplib_object.ca_cert)",
            "        self.assertFalse(self.httplib_object.verify)",
            "",
            "if __name__ == '__main__':",
            "    sys.exit(unittest.main())"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one or more",
            "# contributor license agreements.  See the NOTICE file distributed with",
            "# this work for additional information regarding copyright ownership.",
            "# The ASF licenses this file to You under the Apache License, Version 2.0",
            "# (the \"License\"); you may not use this file except in compliance with",
            "# the License.  You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import sys",
            "import unittest",
            "import os.path",
            "",
            "import libcloud.security",
            "from libcloud.httplib_ssl import LibcloudHTTPSConnection",
            "",
            "class TestHttpLibSSLTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        libcloud.security.VERIFY_SSL_CERT = False",
            "        self.httplib_object = LibcloudHTTPSConnection('foo.bar')",
            "",
            "    def test_verify_hostname(self):",
            "        cert1 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),))}",
            "",
            "        cert2 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),)),",
            "         'subjectAltName': ((('DNS', 'foo.alt.name')),",
            "                           (('DNS', 'foo.alt.name.1')))}",
            "",
            "        cert3 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'python.org'),))}",
            "",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                         hostname='invalid', cert=cert1))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                         hostname='machine.python.org', cert=cert1))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                         hostname='foomachine.python.org', cert=cert1))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='somesomemachine.python.org', cert=cert1))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='somemachine.python.orga', cert=cert1))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='somemachine.python.org.org', cert=cert1))",
            "        self.assertTrue(self.httplib_object._verify_hostname(",
            "                        hostname='somemachine.python.org', cert=cert1))",
            "",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                         hostname='invalid', cert=cert2))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='afoo.alt.name.1', cert=cert2))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='a.foo.alt.name.1', cert=cert2))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='foo.alt.name.1.2', cert=cert2))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='afoo.alt.name.1.2', cert=cert2))",
            "        self.assertTrue(self.httplib_object._verify_hostname(",
            "                        hostname='foo.alt.name.1', cert=cert2))",
            "",
            "        self.assertTrue(self.httplib_object._verify_hostname(",
            "                        hostname='python.org', cert=cert3))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='opython.org', cert=cert3))",
            "        self.assertFalse(self.httplib_object._verify_hostname(",
            "                        hostname='ython.org', cert=cert3))",
            "",
            "    def test_get_subject_alt_names(self):",
            "        cert1 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),))}",
            "",
            "        cert2 = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),)),",
            "         'subjectAltName': ((('DNS', 'foo.alt.name')),",
            "                           (('DNS', 'foo.alt.name.1')))}",
            "",
            "        self.assertEqual(self.httplib_object._get_subject_alt_names(cert=cert1),",
            "                         [])",
            "",
            "        alt_names = self.httplib_object._get_subject_alt_names(cert=cert2)",
            "        self.assertEqual(len(alt_names), 2)",
            "        self.assertTrue('foo.alt.name' in alt_names)",
            "        self.assertTrue('foo.alt.name.1' in alt_names)",
            "",
            "    def test_get_common_name(self):",
            "        cert = {'notAfter': 'Feb 16 16:54:50 2013 GMT',",
            "         'subject': ((('countryName', 'US'),),",
            "                     (('stateOrProvinceName', 'Delaware'),),",
            "                     (('localityName', 'Wilmington'),),",
            "                     (('organizationName', 'Python Software Foundation'),),",
            "                     (('organizationalUnitName', 'SSL'),),",
            "                     (('commonName', 'somemachine.python.org'),))}",
            "",
            "        self.assertEqual(self.httplib_object._get_common_name(cert)[0],",
            "                         'somemachine.python.org')",
            "        self.assertEqual(self.httplib_object._get_common_name({}),",
            "                         None)",
            "",
            "    def test_setup_verify(self):",
            "        # @TODO: catch warnings",
            "        # non-strict mode,s hould just emit a warning",
            "        libcloud.security.VERIFY_SSL_CERT = True",
            "        libcloud.security.VERIFY_SSL_CERT_STRICT = False",
            "        self.httplib_object._setup_verify()",
            "",
            "        # strict mode, should throw a runtime error",
            "        libcloud.security.VERIFY_SSL_CERT = True",
            "        libcloud.security.VERIFY_SSL_CERT_STRICT = True",
            "        try:",
            "            self.httplib_object._setup_verify()",
            "        except:",
            "            pass",
            "        else:",
            "            self.fail('Exception not thrown')",
            "",
            "        libcloud.security.VERIFY_SSL_CERT = False",
            "        libcloud.security.VERIFY_SSL_CERT_STRICT = False",
            "        self.httplib_object._setup_verify()",
            "",
            "    def test_setup_ca_cert(self):",
            "        # @TODO: catch warnings",
            "        self.httplib_object.verify = False",
            "        self.httplib_object.strict = False",
            "        self.httplib_object._setup_ca_cert()",
            "",
            "        self.assertEqual(self.httplib_object.ca_cert, None)",
            "",
            "        self.httplib_object.verify = True",
            "",
            "        libcloud.security.CA_CERTS_PATH = [os.path.abspath(__file__)]",
            "        self.httplib_object._setup_ca_cert()",
            "        self.assertTrue(self.httplib_object.ca_cert is not None)",
            "",
            "        libcloud.security.CA_CERTS_PATH = []",
            "        self.httplib_object._setup_ca_cert()",
            "        self.assertFalse(self.httplib_object.ca_cert)",
            "        self.assertFalse(self.httplib_object.verify)",
            "",
            "if __name__ == '__main__':",
            "    sys.exit(unittest.main())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "libcloud.test.test_httplib_ssl.TestHttpLibSSLTests.test_verify_hostname.cert2",
            "libcloud.test.test_httplib_ssl.TestHttpLibSSLTests.test_verify_hostname.cert1",
            "libcloud.test.test_httplib_ssl.TestHttpLibSSLTests.self",
            "django.db.models.sql.query.Query"
        ]
    }
}