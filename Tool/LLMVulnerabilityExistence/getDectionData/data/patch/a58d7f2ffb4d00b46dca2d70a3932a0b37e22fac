{
    "src/requests/adapters.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import os.path"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import socket  # noqa: F401"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+import typing"
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from urllib3.exceptions import HTTPError as _HTTPError"
            },
            "7": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         raise InvalidSchema(\"Missing dependencies for SOCKS support.\")"
            },
            "8": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+if typing.TYPE_CHECKING:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    from .models import PreparedRequest"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " DEFAULT_POOLBLOCK = False"
            },
            "15": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " DEFAULT_POOLSIZE = 10"
            },
            "16": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " DEFAULT_RETRIES = 0"
            },
            "17": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " DEFAULT_POOL_TIMEOUT = None"
            },
            "18": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+def _urllib3_request_context("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    request: \"PreparedRequest\", verify: \"bool | str | None\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+) -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    host_params = {}"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    pool_kwargs = {}"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    parsed_request_url = urlparse(request.url)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    scheme = parsed_request_url.scheme.lower()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    port = parsed_request_url.port"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    cert_reqs = \"CERT_REQUIRED\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    if verify is False:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        cert_reqs = \"CERT_NONE\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    if isinstance(verify, str):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        pool_kwargs[\"ca_certs\"] = verify"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+    pool_kwargs[\"cert_reqs\"] = cert_reqs"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    host_params = {"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        \"scheme\": scheme,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        \"host\": parsed_request_url.hostname,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        \"port\": port,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    }"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+    return host_params, pool_kwargs"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " class BaseAdapter:"
            },
            "43": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     \"\"\"The Base Transport Adapter\"\"\""
            },
            "44": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 354,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "         return response"
            },
            "47": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 356,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+    def _get_connection(self, request, verify, proxies=None):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        # Replace the existing get_connection without breaking things and"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+        # ensure that TLS settings are considered when we interact with"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        # urllib3 HTTP Pools"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        proxy = select_proxy(request.url, proxies)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        try:"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+            host_params, pool_kwargs = _urllib3_request_context(request, verify)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        except ValueError as e:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+            raise InvalidURL(e, request=request)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+        if proxy:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+            proxy = prepend_scheme_if_needed(proxy, \"http\")"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+            proxy_url = parse_url(proxy)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+            if not proxy_url.host:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+                raise InvalidProxyURL("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+                    \"Please check proxy URL. It is malformed \""
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+                    \"and could be missing the host.\""
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+                )"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+            proxy_manager = self.proxy_manager_for(proxy)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+            conn = proxy_manager.connection_from_host("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+                **host_params, pool_kwargs=pool_kwargs"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+            )"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        else:"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+            # Only scheme should be lower case"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+            conn = self.poolmanager.connection_from_host("
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+                **host_params, pool_kwargs=pool_kwargs"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+            )"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+        return conn"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "     def get_connection(self, url, proxies=None):"
            },
            "78": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "         \"\"\"Returns a urllib3 connection for the given URL. This should not be"
            },
            "79": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         called from user code, and is only exposed for use when subclassing the"
            },
            "80": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 509,
                "PatchRowcode": "         \"\"\""
            },
            "81": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 510,
                "PatchRowcode": " "
            },
            "82": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "         try:"
            },
            "83": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            conn = self.get_connection(request.url, proxies)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+            conn = self._get_connection(request, verify, proxies)"
            },
            "85": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 513,
                "PatchRowcode": "         except LocationValueError as e:"
            },
            "86": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "             raise InvalidURL(e, request=request)"
            },
            "87": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 515,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "requests.adapters",
            "~~~~~~~~~~~~~~~~~",
            "",
            "This module contains the transport adapters that Requests uses to define",
            "and maintain connections.",
            "\"\"\"",
            "",
            "import os.path",
            "import socket  # noqa: F401",
            "",
            "from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError",
            "from urllib3.exceptions import HTTPError as _HTTPError",
            "from urllib3.exceptions import InvalidHeader as _InvalidHeader",
            "from urllib3.exceptions import (",
            "    LocationValueError,",
            "    MaxRetryError,",
            "    NewConnectionError,",
            "    ProtocolError,",
            ")",
            "from urllib3.exceptions import ProxyError as _ProxyError",
            "from urllib3.exceptions import ReadTimeoutError, ResponseError",
            "from urllib3.exceptions import SSLError as _SSLError",
            "from urllib3.poolmanager import PoolManager, proxy_from_url",
            "from urllib3.util import Timeout as TimeoutSauce",
            "from urllib3.util import parse_url",
            "from urllib3.util.retry import Retry",
            "",
            "from .auth import _basic_auth_str",
            "from .compat import basestring, urlparse",
            "from .cookies import extract_cookies_to_jar",
            "from .exceptions import (",
            "    ConnectionError,",
            "    ConnectTimeout,",
            "    InvalidHeader,",
            "    InvalidProxyURL,",
            "    InvalidSchema,",
            "    InvalidURL,",
            "    ProxyError,",
            "    ReadTimeout,",
            "    RetryError,",
            "    SSLError,",
            ")",
            "from .models import Response",
            "from .structures import CaseInsensitiveDict",
            "from .utils import (",
            "    DEFAULT_CA_BUNDLE_PATH,",
            "    extract_zipped_paths,",
            "    get_auth_from_url,",
            "    get_encoding_from_headers,",
            "    prepend_scheme_if_needed,",
            "    select_proxy,",
            "    urldefragauth,",
            ")",
            "",
            "try:",
            "    from urllib3.contrib.socks import SOCKSProxyManager",
            "except ImportError:",
            "",
            "    def SOCKSProxyManager(*args, **kwargs):",
            "        raise InvalidSchema(\"Missing dependencies for SOCKS support.\")",
            "",
            "",
            "DEFAULT_POOLBLOCK = False",
            "DEFAULT_POOLSIZE = 10",
            "DEFAULT_RETRIES = 0",
            "DEFAULT_POOL_TIMEOUT = None",
            "",
            "",
            "class BaseAdapter:",
            "    \"\"\"The Base Transport Adapter\"\"\"",
            "",
            "    def __init__(self):",
            "        super().__init__()",
            "",
            "    def send(",
            "        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None",
            "    ):",
            "        \"\"\"Sends PreparedRequest object. Returns Response object.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.",
            "        :param stream: (optional) Whether to stream the request content.",
            "        :param timeout: (optional) How long to wait for the server to send",
            "            data before giving up, as a float, or a :ref:`(connect timeout,",
            "            read timeout) <timeouts>` tuple.",
            "        :type timeout: float or tuple",
            "        :param verify: (optional) Either a boolean, in which case it controls whether we verify",
            "            the server's TLS certificate, or a string, in which case it must be a path",
            "            to a CA bundle to use",
            "        :param cert: (optional) Any user-provided SSL certificate to be trusted.",
            "        :param proxies: (optional) The proxies dictionary to apply to the request.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def close(self):",
            "        \"\"\"Cleans up adapter specific items.\"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class HTTPAdapter(BaseAdapter):",
            "    \"\"\"The built-in HTTP Adapter for urllib3.",
            "",
            "    Provides a general-case interface for Requests sessions to contact HTTP and",
            "    HTTPS urls by implementing the Transport Adapter interface. This class will",
            "    usually be created by the :class:`Session <Session>` class under the",
            "    covers.",
            "",
            "    :param pool_connections: The number of urllib3 connection pools to cache.",
            "    :param pool_maxsize: The maximum number of connections to save in the pool.",
            "    :param max_retries: The maximum number of retries each connection",
            "        should attempt. Note, this applies only to failed DNS lookups, socket",
            "        connections and connection timeouts, never to requests where data has",
            "        made it to the server. By default, Requests does not retry failed",
            "        connections. If you need granular control over the conditions under",
            "        which we retry a request, import urllib3's ``Retry`` class and pass",
            "        that instead.",
            "    :param pool_block: Whether the connection pool should block for connections.",
            "",
            "    Usage::",
            "",
            "      >>> import requests",
            "      >>> s = requests.Session()",
            "      >>> a = requests.adapters.HTTPAdapter(max_retries=3)",
            "      >>> s.mount('http://', a)",
            "    \"\"\"",
            "",
            "    __attrs__ = [",
            "        \"max_retries\",",
            "        \"config\",",
            "        \"_pool_connections\",",
            "        \"_pool_maxsize\",",
            "        \"_pool_block\",",
            "    ]",
            "",
            "    def __init__(",
            "        self,",
            "        pool_connections=DEFAULT_POOLSIZE,",
            "        pool_maxsize=DEFAULT_POOLSIZE,",
            "        max_retries=DEFAULT_RETRIES,",
            "        pool_block=DEFAULT_POOLBLOCK,",
            "    ):",
            "        if max_retries == DEFAULT_RETRIES:",
            "            self.max_retries = Retry(0, read=False)",
            "        else:",
            "            self.max_retries = Retry.from_int(max_retries)",
            "        self.config = {}",
            "        self.proxy_manager = {}",
            "",
            "        super().__init__()",
            "",
            "        self._pool_connections = pool_connections",
            "        self._pool_maxsize = pool_maxsize",
            "        self._pool_block = pool_block",
            "",
            "        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)",
            "",
            "    def __getstate__(self):",
            "        return {attr: getattr(self, attr, None) for attr in self.__attrs__}",
            "",
            "    def __setstate__(self, state):",
            "        # Can't handle by adding 'proxy_manager' to self.__attrs__ because",
            "        # self.poolmanager uses a lambda function, which isn't pickleable.",
            "        self.proxy_manager = {}",
            "        self.config = {}",
            "",
            "        for attr, value in state.items():",
            "            setattr(self, attr, value)",
            "",
            "        self.init_poolmanager(",
            "            self._pool_connections, self._pool_maxsize, block=self._pool_block",
            "        )",
            "",
            "    def init_poolmanager(",
            "        self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs",
            "    ):",
            "        \"\"\"Initializes a urllib3 PoolManager.",
            "",
            "        This method should not be called from user code, and is only",
            "        exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param connections: The number of urllib3 connection pools to cache.",
            "        :param maxsize: The maximum number of connections to save in the pool.",
            "        :param block: Block when no free connections are available.",
            "        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.",
            "        \"\"\"",
            "        # save these values for pickling",
            "        self._pool_connections = connections",
            "        self._pool_maxsize = maxsize",
            "        self._pool_block = block",
            "",
            "        self.poolmanager = PoolManager(",
            "            num_pools=connections,",
            "            maxsize=maxsize,",
            "            block=block,",
            "            **pool_kwargs,",
            "        )",
            "",
            "    def proxy_manager_for(self, proxy, **proxy_kwargs):",
            "        \"\"\"Return urllib3 ProxyManager for the given proxy.",
            "",
            "        This method should not be called from user code, and is only",
            "        exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param proxy: The proxy to return a urllib3 ProxyManager for.",
            "        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.",
            "        :returns: ProxyManager",
            "        :rtype: urllib3.ProxyManager",
            "        \"\"\"",
            "        if proxy in self.proxy_manager:",
            "            manager = self.proxy_manager[proxy]",
            "        elif proxy.lower().startswith(\"socks\"):",
            "            username, password = get_auth_from_url(proxy)",
            "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(",
            "                proxy,",
            "                username=username,",
            "                password=password,",
            "                num_pools=self._pool_connections,",
            "                maxsize=self._pool_maxsize,",
            "                block=self._pool_block,",
            "                **proxy_kwargs,",
            "            )",
            "        else:",
            "            proxy_headers = self.proxy_headers(proxy)",
            "            manager = self.proxy_manager[proxy] = proxy_from_url(",
            "                proxy,",
            "                proxy_headers=proxy_headers,",
            "                num_pools=self._pool_connections,",
            "                maxsize=self._pool_maxsize,",
            "                block=self._pool_block,",
            "                **proxy_kwargs,",
            "            )",
            "",
            "        return manager",
            "",
            "    def cert_verify(self, conn, url, verify, cert):",
            "        \"\"\"Verify a SSL certificate. This method should not be called from user",
            "        code, and is only exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param conn: The urllib3 connection object associated with the cert.",
            "        :param url: The requested URL.",
            "        :param verify: Either a boolean, in which case it controls whether we verify",
            "            the server's TLS certificate, or a string, in which case it must be a path",
            "            to a CA bundle to use",
            "        :param cert: The SSL certificate to verify.",
            "        \"\"\"",
            "        if url.lower().startswith(\"https\") and verify:",
            "            cert_loc = None",
            "",
            "            # Allow self-specified cert location.",
            "            if verify is not True:",
            "                cert_loc = verify",
            "",
            "            if not cert_loc:",
            "                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)",
            "",
            "            if not cert_loc or not os.path.exists(cert_loc):",
            "                raise OSError(",
            "                    f\"Could not find a suitable TLS CA certificate bundle, \"",
            "                    f\"invalid path: {cert_loc}\"",
            "                )",
            "",
            "            conn.cert_reqs = \"CERT_REQUIRED\"",
            "",
            "            if not os.path.isdir(cert_loc):",
            "                conn.ca_certs = cert_loc",
            "            else:",
            "                conn.ca_cert_dir = cert_loc",
            "        else:",
            "            conn.cert_reqs = \"CERT_NONE\"",
            "            conn.ca_certs = None",
            "            conn.ca_cert_dir = None",
            "",
            "        if cert:",
            "            if not isinstance(cert, basestring):",
            "                conn.cert_file = cert[0]",
            "                conn.key_file = cert[1]",
            "            else:",
            "                conn.cert_file = cert",
            "                conn.key_file = None",
            "            if conn.cert_file and not os.path.exists(conn.cert_file):",
            "                raise OSError(",
            "                    f\"Could not find the TLS certificate file, \"",
            "                    f\"invalid path: {conn.cert_file}\"",
            "                )",
            "            if conn.key_file and not os.path.exists(conn.key_file):",
            "                raise OSError(",
            "                    f\"Could not find the TLS key file, invalid path: {conn.key_file}\"",
            "                )",
            "",
            "    def build_response(self, req, resp):",
            "        \"\"\"Builds a :class:`Response <requests.Response>` object from a urllib3",
            "        response. This should not be called from user code, and is only exposed",
            "        for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`",
            "",
            "        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.",
            "        :param resp: The urllib3 response object.",
            "        :rtype: requests.Response",
            "        \"\"\"",
            "        response = Response()",
            "",
            "        # Fallback to None if there's no status_code, for whatever reason.",
            "        response.status_code = getattr(resp, \"status\", None)",
            "",
            "        # Make headers case-insensitive.",
            "        response.headers = CaseInsensitiveDict(getattr(resp, \"headers\", {}))",
            "",
            "        # Set encoding.",
            "        response.encoding = get_encoding_from_headers(response.headers)",
            "        response.raw = resp",
            "        response.reason = response.raw.reason",
            "",
            "        if isinstance(req.url, bytes):",
            "            response.url = req.url.decode(\"utf-8\")",
            "        else:",
            "            response.url = req.url",
            "",
            "        # Add new cookies from the server.",
            "        extract_cookies_to_jar(response.cookies, req, resp)",
            "",
            "        # Give the Response some context.",
            "        response.request = req",
            "        response.connection = self",
            "",
            "        return response",
            "",
            "    def get_connection(self, url, proxies=None):",
            "        \"\"\"Returns a urllib3 connection for the given URL. This should not be",
            "        called from user code, and is only exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param url: The URL to connect to.",
            "        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.",
            "        :rtype: urllib3.ConnectionPool",
            "        \"\"\"",
            "        proxy = select_proxy(url, proxies)",
            "",
            "        if proxy:",
            "            proxy = prepend_scheme_if_needed(proxy, \"http\")",
            "            proxy_url = parse_url(proxy)",
            "            if not proxy_url.host:",
            "                raise InvalidProxyURL(",
            "                    \"Please check proxy URL. It is malformed \"",
            "                    \"and could be missing the host.\"",
            "                )",
            "            proxy_manager = self.proxy_manager_for(proxy)",
            "            conn = proxy_manager.connection_from_url(url)",
            "        else:",
            "            # Only scheme should be lower case",
            "            parsed = urlparse(url)",
            "            url = parsed.geturl()",
            "            conn = self.poolmanager.connection_from_url(url)",
            "",
            "        return conn",
            "",
            "    def close(self):",
            "        \"\"\"Disposes of any internal state.",
            "",
            "        Currently, this closes the PoolManager and any active ProxyManager,",
            "        which closes any pooled connections.",
            "        \"\"\"",
            "        self.poolmanager.clear()",
            "        for proxy in self.proxy_manager.values():",
            "            proxy.clear()",
            "",
            "    def request_url(self, request, proxies):",
            "        \"\"\"Obtain the url to use when making the final request.",
            "",
            "        If the message is being sent through a HTTP proxy, the full URL has to",
            "        be used. Otherwise, we should only use the path portion of the URL.",
            "",
            "        This should not be called from user code, and is only exposed for use",
            "        when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.",
            "        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.",
            "        :rtype: str",
            "        \"\"\"",
            "        proxy = select_proxy(request.url, proxies)",
            "        scheme = urlparse(request.url).scheme",
            "",
            "        is_proxied_http_request = proxy and scheme != \"https\"",
            "        using_socks_proxy = False",
            "        if proxy:",
            "            proxy_scheme = urlparse(proxy).scheme.lower()",
            "            using_socks_proxy = proxy_scheme.startswith(\"socks\")",
            "",
            "        url = request.path_url",
            "        if url.startswith(\"//\"):  # Don't confuse urllib3",
            "            url = f\"/{url.lstrip('/')}\"",
            "",
            "        if is_proxied_http_request and not using_socks_proxy:",
            "            url = urldefragauth(request.url)",
            "",
            "        return url",
            "",
            "    def add_headers(self, request, **kwargs):",
            "        \"\"\"Add any headers needed by the connection. As of v2.0 this does",
            "        nothing by default, but is left for overriding by users that subclass",
            "        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        This should not be called from user code, and is only exposed for use",
            "        when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.",
            "        :param kwargs: The keyword arguments from the call to send().",
            "        \"\"\"",
            "        pass",
            "",
            "    def proxy_headers(self, proxy):",
            "        \"\"\"Returns a dictionary of the headers to add to any request sent",
            "        through a proxy. This works with urllib3 magic to ensure that they are",
            "        correctly sent to the proxy, rather than in a tunnelled request if",
            "        CONNECT is being used.",
            "",
            "        This should not be called from user code, and is only exposed for use",
            "        when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param proxy: The url of the proxy being used for this request.",
            "        :rtype: dict",
            "        \"\"\"",
            "        headers = {}",
            "        username, password = get_auth_from_url(proxy)",
            "",
            "        if username:",
            "            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)",
            "",
            "        return headers",
            "",
            "    def send(",
            "        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None",
            "    ):",
            "        \"\"\"Sends PreparedRequest object. Returns Response object.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.",
            "        :param stream: (optional) Whether to stream the request content.",
            "        :param timeout: (optional) How long to wait for the server to send",
            "            data before giving up, as a float, or a :ref:`(connect timeout,",
            "            read timeout) <timeouts>` tuple.",
            "        :type timeout: float or tuple or urllib3 Timeout object",
            "        :param verify: (optional) Either a boolean, in which case it controls whether",
            "            we verify the server's TLS certificate, or a string, in which case it",
            "            must be a path to a CA bundle to use",
            "        :param cert: (optional) Any user-provided SSL certificate to be trusted.",
            "        :param proxies: (optional) The proxies dictionary to apply to the request.",
            "        :rtype: requests.Response",
            "        \"\"\"",
            "",
            "        try:",
            "            conn = self.get_connection(request.url, proxies)",
            "        except LocationValueError as e:",
            "            raise InvalidURL(e, request=request)",
            "",
            "        self.cert_verify(conn, request.url, verify, cert)",
            "        url = self.request_url(request, proxies)",
            "        self.add_headers(",
            "            request,",
            "            stream=stream,",
            "            timeout=timeout,",
            "            verify=verify,",
            "            cert=cert,",
            "            proxies=proxies,",
            "        )",
            "",
            "        chunked = not (request.body is None or \"Content-Length\" in request.headers)",
            "",
            "        if isinstance(timeout, tuple):",
            "            try:",
            "                connect, read = timeout",
            "                timeout = TimeoutSauce(connect=connect, read=read)",
            "            except ValueError:",
            "                raise ValueError(",
            "                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"",
            "                    f\"or a single float to set both timeouts to the same value.\"",
            "                )",
            "        elif isinstance(timeout, TimeoutSauce):",
            "            pass",
            "        else:",
            "            timeout = TimeoutSauce(connect=timeout, read=timeout)",
            "",
            "        try:",
            "            resp = conn.urlopen(",
            "                method=request.method,",
            "                url=url,",
            "                body=request.body,",
            "                headers=request.headers,",
            "                redirect=False,",
            "                assert_same_host=False,",
            "                preload_content=False,",
            "                decode_content=False,",
            "                retries=self.max_retries,",
            "                timeout=timeout,",
            "                chunked=chunked,",
            "            )",
            "",
            "        except (ProtocolError, OSError) as err:",
            "            raise ConnectionError(err, request=request)",
            "",
            "        except MaxRetryError as e:",
            "            if isinstance(e.reason, ConnectTimeoutError):",
            "                # TODO: Remove this in 3.0.0: see #2811",
            "                if not isinstance(e.reason, NewConnectionError):",
            "                    raise ConnectTimeout(e, request=request)",
            "",
            "            if isinstance(e.reason, ResponseError):",
            "                raise RetryError(e, request=request)",
            "",
            "            if isinstance(e.reason, _ProxyError):",
            "                raise ProxyError(e, request=request)",
            "",
            "            if isinstance(e.reason, _SSLError):",
            "                # This branch is for urllib3 v1.22 and later.",
            "                raise SSLError(e, request=request)",
            "",
            "            raise ConnectionError(e, request=request)",
            "",
            "        except ClosedPoolError as e:",
            "            raise ConnectionError(e, request=request)",
            "",
            "        except _ProxyError as e:",
            "            raise ProxyError(e)",
            "",
            "        except (_SSLError, _HTTPError) as e:",
            "            if isinstance(e, _SSLError):",
            "                # This branch is for urllib3 versions earlier than v1.22",
            "                raise SSLError(e, request=request)",
            "            elif isinstance(e, ReadTimeoutError):",
            "                raise ReadTimeout(e, request=request)",
            "            elif isinstance(e, _InvalidHeader):",
            "                raise InvalidHeader(e, request=request)",
            "            else:",
            "                raise",
            "",
            "        return self.build_response(request, resp)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "requests.adapters",
            "~~~~~~~~~~~~~~~~~",
            "",
            "This module contains the transport adapters that Requests uses to define",
            "and maintain connections.",
            "\"\"\"",
            "",
            "import os.path",
            "import socket  # noqa: F401",
            "import typing",
            "",
            "from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError",
            "from urllib3.exceptions import HTTPError as _HTTPError",
            "from urllib3.exceptions import InvalidHeader as _InvalidHeader",
            "from urllib3.exceptions import (",
            "    LocationValueError,",
            "    MaxRetryError,",
            "    NewConnectionError,",
            "    ProtocolError,",
            ")",
            "from urllib3.exceptions import ProxyError as _ProxyError",
            "from urllib3.exceptions import ReadTimeoutError, ResponseError",
            "from urllib3.exceptions import SSLError as _SSLError",
            "from urllib3.poolmanager import PoolManager, proxy_from_url",
            "from urllib3.util import Timeout as TimeoutSauce",
            "from urllib3.util import parse_url",
            "from urllib3.util.retry import Retry",
            "",
            "from .auth import _basic_auth_str",
            "from .compat import basestring, urlparse",
            "from .cookies import extract_cookies_to_jar",
            "from .exceptions import (",
            "    ConnectionError,",
            "    ConnectTimeout,",
            "    InvalidHeader,",
            "    InvalidProxyURL,",
            "    InvalidSchema,",
            "    InvalidURL,",
            "    ProxyError,",
            "    ReadTimeout,",
            "    RetryError,",
            "    SSLError,",
            ")",
            "from .models import Response",
            "from .structures import CaseInsensitiveDict",
            "from .utils import (",
            "    DEFAULT_CA_BUNDLE_PATH,",
            "    extract_zipped_paths,",
            "    get_auth_from_url,",
            "    get_encoding_from_headers,",
            "    prepend_scheme_if_needed,",
            "    select_proxy,",
            "    urldefragauth,",
            ")",
            "",
            "try:",
            "    from urllib3.contrib.socks import SOCKSProxyManager",
            "except ImportError:",
            "",
            "    def SOCKSProxyManager(*args, **kwargs):",
            "        raise InvalidSchema(\"Missing dependencies for SOCKS support.\")",
            "",
            "",
            "if typing.TYPE_CHECKING:",
            "    from .models import PreparedRequest",
            "",
            "",
            "DEFAULT_POOLBLOCK = False",
            "DEFAULT_POOLSIZE = 10",
            "DEFAULT_RETRIES = 0",
            "DEFAULT_POOL_TIMEOUT = None",
            "",
            "",
            "def _urllib3_request_context(",
            "    request: \"PreparedRequest\", verify: \"bool | str | None\"",
            ") -> \"(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])\":",
            "    host_params = {}",
            "    pool_kwargs = {}",
            "    parsed_request_url = urlparse(request.url)",
            "    scheme = parsed_request_url.scheme.lower()",
            "    port = parsed_request_url.port",
            "    cert_reqs = \"CERT_REQUIRED\"",
            "    if verify is False:",
            "        cert_reqs = \"CERT_NONE\"",
            "    if isinstance(verify, str):",
            "        pool_kwargs[\"ca_certs\"] = verify",
            "    pool_kwargs[\"cert_reqs\"] = cert_reqs",
            "    host_params = {",
            "        \"scheme\": scheme,",
            "        \"host\": parsed_request_url.hostname,",
            "        \"port\": port,",
            "    }",
            "    return host_params, pool_kwargs",
            "",
            "",
            "class BaseAdapter:",
            "    \"\"\"The Base Transport Adapter\"\"\"",
            "",
            "    def __init__(self):",
            "        super().__init__()",
            "",
            "    def send(",
            "        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None",
            "    ):",
            "        \"\"\"Sends PreparedRequest object. Returns Response object.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.",
            "        :param stream: (optional) Whether to stream the request content.",
            "        :param timeout: (optional) How long to wait for the server to send",
            "            data before giving up, as a float, or a :ref:`(connect timeout,",
            "            read timeout) <timeouts>` tuple.",
            "        :type timeout: float or tuple",
            "        :param verify: (optional) Either a boolean, in which case it controls whether we verify",
            "            the server's TLS certificate, or a string, in which case it must be a path",
            "            to a CA bundle to use",
            "        :param cert: (optional) Any user-provided SSL certificate to be trusted.",
            "        :param proxies: (optional) The proxies dictionary to apply to the request.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    def close(self):",
            "        \"\"\"Cleans up adapter specific items.\"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class HTTPAdapter(BaseAdapter):",
            "    \"\"\"The built-in HTTP Adapter for urllib3.",
            "",
            "    Provides a general-case interface for Requests sessions to contact HTTP and",
            "    HTTPS urls by implementing the Transport Adapter interface. This class will",
            "    usually be created by the :class:`Session <Session>` class under the",
            "    covers.",
            "",
            "    :param pool_connections: The number of urllib3 connection pools to cache.",
            "    :param pool_maxsize: The maximum number of connections to save in the pool.",
            "    :param max_retries: The maximum number of retries each connection",
            "        should attempt. Note, this applies only to failed DNS lookups, socket",
            "        connections and connection timeouts, never to requests where data has",
            "        made it to the server. By default, Requests does not retry failed",
            "        connections. If you need granular control over the conditions under",
            "        which we retry a request, import urllib3's ``Retry`` class and pass",
            "        that instead.",
            "    :param pool_block: Whether the connection pool should block for connections.",
            "",
            "    Usage::",
            "",
            "      >>> import requests",
            "      >>> s = requests.Session()",
            "      >>> a = requests.adapters.HTTPAdapter(max_retries=3)",
            "      >>> s.mount('http://', a)",
            "    \"\"\"",
            "",
            "    __attrs__ = [",
            "        \"max_retries\",",
            "        \"config\",",
            "        \"_pool_connections\",",
            "        \"_pool_maxsize\",",
            "        \"_pool_block\",",
            "    ]",
            "",
            "    def __init__(",
            "        self,",
            "        pool_connections=DEFAULT_POOLSIZE,",
            "        pool_maxsize=DEFAULT_POOLSIZE,",
            "        max_retries=DEFAULT_RETRIES,",
            "        pool_block=DEFAULT_POOLBLOCK,",
            "    ):",
            "        if max_retries == DEFAULT_RETRIES:",
            "            self.max_retries = Retry(0, read=False)",
            "        else:",
            "            self.max_retries = Retry.from_int(max_retries)",
            "        self.config = {}",
            "        self.proxy_manager = {}",
            "",
            "        super().__init__()",
            "",
            "        self._pool_connections = pool_connections",
            "        self._pool_maxsize = pool_maxsize",
            "        self._pool_block = pool_block",
            "",
            "        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)",
            "",
            "    def __getstate__(self):",
            "        return {attr: getattr(self, attr, None) for attr in self.__attrs__}",
            "",
            "    def __setstate__(self, state):",
            "        # Can't handle by adding 'proxy_manager' to self.__attrs__ because",
            "        # self.poolmanager uses a lambda function, which isn't pickleable.",
            "        self.proxy_manager = {}",
            "        self.config = {}",
            "",
            "        for attr, value in state.items():",
            "            setattr(self, attr, value)",
            "",
            "        self.init_poolmanager(",
            "            self._pool_connections, self._pool_maxsize, block=self._pool_block",
            "        )",
            "",
            "    def init_poolmanager(",
            "        self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs",
            "    ):",
            "        \"\"\"Initializes a urllib3 PoolManager.",
            "",
            "        This method should not be called from user code, and is only",
            "        exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param connections: The number of urllib3 connection pools to cache.",
            "        :param maxsize: The maximum number of connections to save in the pool.",
            "        :param block: Block when no free connections are available.",
            "        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.",
            "        \"\"\"",
            "        # save these values for pickling",
            "        self._pool_connections = connections",
            "        self._pool_maxsize = maxsize",
            "        self._pool_block = block",
            "",
            "        self.poolmanager = PoolManager(",
            "            num_pools=connections,",
            "            maxsize=maxsize,",
            "            block=block,",
            "            **pool_kwargs,",
            "        )",
            "",
            "    def proxy_manager_for(self, proxy, **proxy_kwargs):",
            "        \"\"\"Return urllib3 ProxyManager for the given proxy.",
            "",
            "        This method should not be called from user code, and is only",
            "        exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param proxy: The proxy to return a urllib3 ProxyManager for.",
            "        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.",
            "        :returns: ProxyManager",
            "        :rtype: urllib3.ProxyManager",
            "        \"\"\"",
            "        if proxy in self.proxy_manager:",
            "            manager = self.proxy_manager[proxy]",
            "        elif proxy.lower().startswith(\"socks\"):",
            "            username, password = get_auth_from_url(proxy)",
            "            manager = self.proxy_manager[proxy] = SOCKSProxyManager(",
            "                proxy,",
            "                username=username,",
            "                password=password,",
            "                num_pools=self._pool_connections,",
            "                maxsize=self._pool_maxsize,",
            "                block=self._pool_block,",
            "                **proxy_kwargs,",
            "            )",
            "        else:",
            "            proxy_headers = self.proxy_headers(proxy)",
            "            manager = self.proxy_manager[proxy] = proxy_from_url(",
            "                proxy,",
            "                proxy_headers=proxy_headers,",
            "                num_pools=self._pool_connections,",
            "                maxsize=self._pool_maxsize,",
            "                block=self._pool_block,",
            "                **proxy_kwargs,",
            "            )",
            "",
            "        return manager",
            "",
            "    def cert_verify(self, conn, url, verify, cert):",
            "        \"\"\"Verify a SSL certificate. This method should not be called from user",
            "        code, and is only exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param conn: The urllib3 connection object associated with the cert.",
            "        :param url: The requested URL.",
            "        :param verify: Either a boolean, in which case it controls whether we verify",
            "            the server's TLS certificate, or a string, in which case it must be a path",
            "            to a CA bundle to use",
            "        :param cert: The SSL certificate to verify.",
            "        \"\"\"",
            "        if url.lower().startswith(\"https\") and verify:",
            "            cert_loc = None",
            "",
            "            # Allow self-specified cert location.",
            "            if verify is not True:",
            "                cert_loc = verify",
            "",
            "            if not cert_loc:",
            "                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)",
            "",
            "            if not cert_loc or not os.path.exists(cert_loc):",
            "                raise OSError(",
            "                    f\"Could not find a suitable TLS CA certificate bundle, \"",
            "                    f\"invalid path: {cert_loc}\"",
            "                )",
            "",
            "            conn.cert_reqs = \"CERT_REQUIRED\"",
            "",
            "            if not os.path.isdir(cert_loc):",
            "                conn.ca_certs = cert_loc",
            "            else:",
            "                conn.ca_cert_dir = cert_loc",
            "        else:",
            "            conn.cert_reqs = \"CERT_NONE\"",
            "            conn.ca_certs = None",
            "            conn.ca_cert_dir = None",
            "",
            "        if cert:",
            "            if not isinstance(cert, basestring):",
            "                conn.cert_file = cert[0]",
            "                conn.key_file = cert[1]",
            "            else:",
            "                conn.cert_file = cert",
            "                conn.key_file = None",
            "            if conn.cert_file and not os.path.exists(conn.cert_file):",
            "                raise OSError(",
            "                    f\"Could not find the TLS certificate file, \"",
            "                    f\"invalid path: {conn.cert_file}\"",
            "                )",
            "            if conn.key_file and not os.path.exists(conn.key_file):",
            "                raise OSError(",
            "                    f\"Could not find the TLS key file, invalid path: {conn.key_file}\"",
            "                )",
            "",
            "    def build_response(self, req, resp):",
            "        \"\"\"Builds a :class:`Response <requests.Response>` object from a urllib3",
            "        response. This should not be called from user code, and is only exposed",
            "        for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`",
            "",
            "        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.",
            "        :param resp: The urllib3 response object.",
            "        :rtype: requests.Response",
            "        \"\"\"",
            "        response = Response()",
            "",
            "        # Fallback to None if there's no status_code, for whatever reason.",
            "        response.status_code = getattr(resp, \"status\", None)",
            "",
            "        # Make headers case-insensitive.",
            "        response.headers = CaseInsensitiveDict(getattr(resp, \"headers\", {}))",
            "",
            "        # Set encoding.",
            "        response.encoding = get_encoding_from_headers(response.headers)",
            "        response.raw = resp",
            "        response.reason = response.raw.reason",
            "",
            "        if isinstance(req.url, bytes):",
            "            response.url = req.url.decode(\"utf-8\")",
            "        else:",
            "            response.url = req.url",
            "",
            "        # Add new cookies from the server.",
            "        extract_cookies_to_jar(response.cookies, req, resp)",
            "",
            "        # Give the Response some context.",
            "        response.request = req",
            "        response.connection = self",
            "",
            "        return response",
            "",
            "    def _get_connection(self, request, verify, proxies=None):",
            "        # Replace the existing get_connection without breaking things and",
            "        # ensure that TLS settings are considered when we interact with",
            "        # urllib3 HTTP Pools",
            "        proxy = select_proxy(request.url, proxies)",
            "        try:",
            "            host_params, pool_kwargs = _urllib3_request_context(request, verify)",
            "        except ValueError as e:",
            "            raise InvalidURL(e, request=request)",
            "        if proxy:",
            "            proxy = prepend_scheme_if_needed(proxy, \"http\")",
            "            proxy_url = parse_url(proxy)",
            "            if not proxy_url.host:",
            "                raise InvalidProxyURL(",
            "                    \"Please check proxy URL. It is malformed \"",
            "                    \"and could be missing the host.\"",
            "                )",
            "            proxy_manager = self.proxy_manager_for(proxy)",
            "            conn = proxy_manager.connection_from_host(",
            "                **host_params, pool_kwargs=pool_kwargs",
            "            )",
            "        else:",
            "            # Only scheme should be lower case",
            "            conn = self.poolmanager.connection_from_host(",
            "                **host_params, pool_kwargs=pool_kwargs",
            "            )",
            "",
            "        return conn",
            "",
            "    def get_connection(self, url, proxies=None):",
            "        \"\"\"Returns a urllib3 connection for the given URL. This should not be",
            "        called from user code, and is only exposed for use when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param url: The URL to connect to.",
            "        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.",
            "        :rtype: urllib3.ConnectionPool",
            "        \"\"\"",
            "        proxy = select_proxy(url, proxies)",
            "",
            "        if proxy:",
            "            proxy = prepend_scheme_if_needed(proxy, \"http\")",
            "            proxy_url = parse_url(proxy)",
            "            if not proxy_url.host:",
            "                raise InvalidProxyURL(",
            "                    \"Please check proxy URL. It is malformed \"",
            "                    \"and could be missing the host.\"",
            "                )",
            "            proxy_manager = self.proxy_manager_for(proxy)",
            "            conn = proxy_manager.connection_from_url(url)",
            "        else:",
            "            # Only scheme should be lower case",
            "            parsed = urlparse(url)",
            "            url = parsed.geturl()",
            "            conn = self.poolmanager.connection_from_url(url)",
            "",
            "        return conn",
            "",
            "    def close(self):",
            "        \"\"\"Disposes of any internal state.",
            "",
            "        Currently, this closes the PoolManager and any active ProxyManager,",
            "        which closes any pooled connections.",
            "        \"\"\"",
            "        self.poolmanager.clear()",
            "        for proxy in self.proxy_manager.values():",
            "            proxy.clear()",
            "",
            "    def request_url(self, request, proxies):",
            "        \"\"\"Obtain the url to use when making the final request.",
            "",
            "        If the message is being sent through a HTTP proxy, the full URL has to",
            "        be used. Otherwise, we should only use the path portion of the URL.",
            "",
            "        This should not be called from user code, and is only exposed for use",
            "        when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.",
            "        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.",
            "        :rtype: str",
            "        \"\"\"",
            "        proxy = select_proxy(request.url, proxies)",
            "        scheme = urlparse(request.url).scheme",
            "",
            "        is_proxied_http_request = proxy and scheme != \"https\"",
            "        using_socks_proxy = False",
            "        if proxy:",
            "            proxy_scheme = urlparse(proxy).scheme.lower()",
            "            using_socks_proxy = proxy_scheme.startswith(\"socks\")",
            "",
            "        url = request.path_url",
            "        if url.startswith(\"//\"):  # Don't confuse urllib3",
            "            url = f\"/{url.lstrip('/')}\"",
            "",
            "        if is_proxied_http_request and not using_socks_proxy:",
            "            url = urldefragauth(request.url)",
            "",
            "        return url",
            "",
            "    def add_headers(self, request, **kwargs):",
            "        \"\"\"Add any headers needed by the connection. As of v2.0 this does",
            "        nothing by default, but is left for overriding by users that subclass",
            "        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        This should not be called from user code, and is only exposed for use",
            "        when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.",
            "        :param kwargs: The keyword arguments from the call to send().",
            "        \"\"\"",
            "        pass",
            "",
            "    def proxy_headers(self, proxy):",
            "        \"\"\"Returns a dictionary of the headers to add to any request sent",
            "        through a proxy. This works with urllib3 magic to ensure that they are",
            "        correctly sent to the proxy, rather than in a tunnelled request if",
            "        CONNECT is being used.",
            "",
            "        This should not be called from user code, and is only exposed for use",
            "        when subclassing the",
            "        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.",
            "",
            "        :param proxy: The url of the proxy being used for this request.",
            "        :rtype: dict",
            "        \"\"\"",
            "        headers = {}",
            "        username, password = get_auth_from_url(proxy)",
            "",
            "        if username:",
            "            headers[\"Proxy-Authorization\"] = _basic_auth_str(username, password)",
            "",
            "        return headers",
            "",
            "    def send(",
            "        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None",
            "    ):",
            "        \"\"\"Sends PreparedRequest object. Returns Response object.",
            "",
            "        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.",
            "        :param stream: (optional) Whether to stream the request content.",
            "        :param timeout: (optional) How long to wait for the server to send",
            "            data before giving up, as a float, or a :ref:`(connect timeout,",
            "            read timeout) <timeouts>` tuple.",
            "        :type timeout: float or tuple or urllib3 Timeout object",
            "        :param verify: (optional) Either a boolean, in which case it controls whether",
            "            we verify the server's TLS certificate, or a string, in which case it",
            "            must be a path to a CA bundle to use",
            "        :param cert: (optional) Any user-provided SSL certificate to be trusted.",
            "        :param proxies: (optional) The proxies dictionary to apply to the request.",
            "        :rtype: requests.Response",
            "        \"\"\"",
            "",
            "        try:",
            "            conn = self._get_connection(request, verify, proxies)",
            "        except LocationValueError as e:",
            "            raise InvalidURL(e, request=request)",
            "",
            "        self.cert_verify(conn, request.url, verify, cert)",
            "        url = self.request_url(request, proxies)",
            "        self.add_headers(",
            "            request,",
            "            stream=stream,",
            "            timeout=timeout,",
            "            verify=verify,",
            "            cert=cert,",
            "            proxies=proxies,",
            "        )",
            "",
            "        chunked = not (request.body is None or \"Content-Length\" in request.headers)",
            "",
            "        if isinstance(timeout, tuple):",
            "            try:",
            "                connect, read = timeout",
            "                timeout = TimeoutSauce(connect=connect, read=read)",
            "            except ValueError:",
            "                raise ValueError(",
            "                    f\"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, \"",
            "                    f\"or a single float to set both timeouts to the same value.\"",
            "                )",
            "        elif isinstance(timeout, TimeoutSauce):",
            "            pass",
            "        else:",
            "            timeout = TimeoutSauce(connect=timeout, read=timeout)",
            "",
            "        try:",
            "            resp = conn.urlopen(",
            "                method=request.method,",
            "                url=url,",
            "                body=request.body,",
            "                headers=request.headers,",
            "                redirect=False,",
            "                assert_same_host=False,",
            "                preload_content=False,",
            "                decode_content=False,",
            "                retries=self.max_retries,",
            "                timeout=timeout,",
            "                chunked=chunked,",
            "            )",
            "",
            "        except (ProtocolError, OSError) as err:",
            "            raise ConnectionError(err, request=request)",
            "",
            "        except MaxRetryError as e:",
            "            if isinstance(e.reason, ConnectTimeoutError):",
            "                # TODO: Remove this in 3.0.0: see #2811",
            "                if not isinstance(e.reason, NewConnectionError):",
            "                    raise ConnectTimeout(e, request=request)",
            "",
            "            if isinstance(e.reason, ResponseError):",
            "                raise RetryError(e, request=request)",
            "",
            "            if isinstance(e.reason, _ProxyError):",
            "                raise ProxyError(e, request=request)",
            "",
            "            if isinstance(e.reason, _SSLError):",
            "                # This branch is for urllib3 v1.22 and later.",
            "                raise SSLError(e, request=request)",
            "",
            "            raise ConnectionError(e, request=request)",
            "",
            "        except ClosedPoolError as e:",
            "            raise ConnectionError(e, request=request)",
            "",
            "        except _ProxyError as e:",
            "            raise ProxyError(e)",
            "",
            "        except (_SSLError, _HTTPError) as e:",
            "            if isinstance(e, _SSLError):",
            "                # This branch is for urllib3 versions earlier than v1.22",
            "                raise SSLError(e, request=request)",
            "            elif isinstance(e, ReadTimeoutError):",
            "                raise ReadTimeout(e, request=request)",
            "            elif isinstance(e, _InvalidHeader):",
            "                raise InvalidHeader(e, request=request)",
            "            else:",
            "                raise",
            "",
            "        return self.build_response(request, resp)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "456": [
                "HTTPAdapter",
                "send"
            ]
        },
        "addLocation": [
            "src.requests.adapters.HTTPAdapter.__attrs__",
            "src.requests.adapters.HTTPAdapter.self",
            "src.requests.adapters.HTTPAdapter.send",
            "web.pgadmin.tools.import_export.create_import_export_job"
        ]
    }
}