{
    "scrapy/downloadermiddlewares/redirect.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     has_cookie_header = \"Cookie\" in redirect_request.headers"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     has_authorization_header = \"Authorization\" in redirect_request.headers"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     if has_cookie_header or has_authorization_header:"
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        source_request_netloc = urlparse_cached(source_request).netloc"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        redirect_request_netloc = urlparse_cached(redirect_request).netloc"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if source_request_netloc != redirect_request_netloc:"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if has_cookie_header:"
            },
            "7": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                del redirect_request.headers[\"Cookie\"]"
            },
            "8": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name"
            },
            "9": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if has_authorization_header:"
            },
            "10": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                del redirect_request.headers[\"Authorization\"]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+        default_ports = {\"http\": 80, \"https\": 443}"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+        parsed_source_request = urlparse_cached(source_request)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        source_scheme, source_host, source_port = ("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+            parsed_source_request.scheme,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+            parsed_source_request.hostname,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            parsed_source_request.port"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            or default_ports.get(parsed_source_request.scheme),"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        )"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        parsed_redirect_request = urlparse_cached(redirect_request)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        redirect_scheme, redirect_host, redirect_port = ("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            parsed_redirect_request.scheme,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+            parsed_redirect_request.hostname,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            parsed_redirect_request.port"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            or default_ports.get(parsed_redirect_request.scheme),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        )"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        if has_cookie_header and ("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            (source_scheme != redirect_scheme and redirect_scheme != \"https\")"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+            or source_host != redirect_host"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        ):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            del redirect_request.headers[\"Cookie\"]"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        if has_authorization_header and ("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            source_scheme != redirect_scheme"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            or source_host != redirect_host"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            or source_port != redirect_port"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        ):"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            del redirect_request.headers[\"Authorization\"]"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     return redirect_request"
            },
            "44": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import logging",
            "from urllib.parse import urljoin, urlparse",
            "",
            "from w3lib.url import safe_url_string",
            "",
            "from scrapy.exceptions import IgnoreRequest, NotConfigured",
            "from scrapy.http import HtmlResponse",
            "from scrapy.utils.httpobj import urlparse_cached",
            "from scrapy.utils.response import get_meta_refresh",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _build_redirect_request(source_request, *, url, **kwargs):",
            "    redirect_request = source_request.replace(",
            "        url=url,",
            "        **kwargs,",
            "        cookies=None,",
            "    )",
            "    has_cookie_header = \"Cookie\" in redirect_request.headers",
            "    has_authorization_header = \"Authorization\" in redirect_request.headers",
            "    if has_cookie_header or has_authorization_header:",
            "        source_request_netloc = urlparse_cached(source_request).netloc",
            "        redirect_request_netloc = urlparse_cached(redirect_request).netloc",
            "        if source_request_netloc != redirect_request_netloc:",
            "            if has_cookie_header:",
            "                del redirect_request.headers[\"Cookie\"]",
            "            # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name",
            "            if has_authorization_header:",
            "                del redirect_request.headers[\"Authorization\"]",
            "    return redirect_request",
            "",
            "",
            "class BaseRedirectMiddleware:",
            "    enabled_setting = \"REDIRECT_ENABLED\"",
            "",
            "    def __init__(self, settings):",
            "        if not settings.getbool(self.enabled_setting):",
            "            raise NotConfigured",
            "",
            "        self.max_redirect_times = settings.getint(\"REDIRECT_MAX_TIMES\")",
            "        self.priority_adjust = settings.getint(\"REDIRECT_PRIORITY_ADJUST\")",
            "",
            "    @classmethod",
            "    def from_crawler(cls, crawler):",
            "        return cls(crawler.settings)",
            "",
            "    def _redirect(self, redirected, request, spider, reason):",
            "        ttl = request.meta.setdefault(\"redirect_ttl\", self.max_redirect_times)",
            "        redirects = request.meta.get(\"redirect_times\", 0) + 1",
            "",
            "        if ttl and redirects <= self.max_redirect_times:",
            "            redirected.meta[\"redirect_times\"] = redirects",
            "            redirected.meta[\"redirect_ttl\"] = ttl - 1",
            "            redirected.meta[\"redirect_urls\"] = request.meta.get(\"redirect_urls\", []) + [",
            "                request.url",
            "            ]",
            "            redirected.meta[\"redirect_reasons\"] = request.meta.get(",
            "                \"redirect_reasons\", []",
            "            ) + [reason]",
            "            redirected.dont_filter = request.dont_filter",
            "            redirected.priority = request.priority + self.priority_adjust",
            "            logger.debug(",
            "                \"Redirecting (%(reason)s) to %(redirected)s from %(request)s\",",
            "                {\"reason\": reason, \"redirected\": redirected, \"request\": request},",
            "                extra={\"spider\": spider},",
            "            )",
            "            return redirected",
            "        logger.debug(",
            "            \"Discarding %(request)s: max redirections reached\",",
            "            {\"request\": request},",
            "            extra={\"spider\": spider},",
            "        )",
            "        raise IgnoreRequest(\"max redirections reached\")",
            "",
            "    def _redirect_request_using_get(self, request, redirect_url):",
            "        redirect_request = _build_redirect_request(",
            "            request,",
            "            url=redirect_url,",
            "            method=\"GET\",",
            "            body=\"\",",
            "        )",
            "        redirect_request.headers.pop(\"Content-Type\", None)",
            "        redirect_request.headers.pop(\"Content-Length\", None)",
            "        return redirect_request",
            "",
            "",
            "class RedirectMiddleware(BaseRedirectMiddleware):",
            "    \"\"\"",
            "    Handle redirection of requests based on response status",
            "    and meta-refresh html tag.",
            "    \"\"\"",
            "",
            "    def process_response(self, request, response, spider):",
            "        if (",
            "            request.meta.get(\"dont_redirect\", False)",
            "            or response.status in getattr(spider, \"handle_httpstatus_list\", [])",
            "            or response.status in request.meta.get(\"handle_httpstatus_list\", [])",
            "            or request.meta.get(\"handle_httpstatus_all\", False)",
            "        ):",
            "            return response",
            "",
            "        allowed_status = (301, 302, 303, 307, 308)",
            "        if \"Location\" not in response.headers or response.status not in allowed_status:",
            "            return response",
            "",
            "        location = safe_url_string(response.headers[\"Location\"])",
            "        if response.headers[\"Location\"].startswith(b\"//\"):",
            "            request_scheme = urlparse(request.url).scheme",
            "            location = request_scheme + \"://\" + location.lstrip(\"/\")",
            "",
            "        redirected_url = urljoin(request.url, location)",
            "",
            "        if response.status in (301, 307, 308) or request.method == \"HEAD\":",
            "            redirected = _build_redirect_request(request, url=redirected_url)",
            "            return self._redirect(redirected, request, spider, response.status)",
            "",
            "        redirected = self._redirect_request_using_get(request, redirected_url)",
            "        return self._redirect(redirected, request, spider, response.status)",
            "",
            "",
            "class MetaRefreshMiddleware(BaseRedirectMiddleware):",
            "    enabled_setting = \"METAREFRESH_ENABLED\"",
            "",
            "    def __init__(self, settings):",
            "        super().__init__(settings)",
            "        self._ignore_tags = settings.getlist(\"METAREFRESH_IGNORE_TAGS\")",
            "        self._maxdelay = settings.getint(\"METAREFRESH_MAXDELAY\")",
            "",
            "    def process_response(self, request, response, spider):",
            "        if (",
            "            request.meta.get(\"dont_redirect\", False)",
            "            or request.method == \"HEAD\"",
            "            or not isinstance(response, HtmlResponse)",
            "        ):",
            "            return response",
            "",
            "        interval, url = get_meta_refresh(response, ignore_tags=self._ignore_tags)",
            "        if url and interval < self._maxdelay:",
            "            redirected = self._redirect_request_using_get(request, url)",
            "            return self._redirect(redirected, request, spider, \"meta refresh\")",
            "",
            "        return response"
        ],
        "afterPatchFile": [
            "import logging",
            "from urllib.parse import urljoin, urlparse",
            "",
            "from w3lib.url import safe_url_string",
            "",
            "from scrapy.exceptions import IgnoreRequest, NotConfigured",
            "from scrapy.http import HtmlResponse",
            "from scrapy.utils.httpobj import urlparse_cached",
            "from scrapy.utils.response import get_meta_refresh",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _build_redirect_request(source_request, *, url, **kwargs):",
            "    redirect_request = source_request.replace(",
            "        url=url,",
            "        **kwargs,",
            "        cookies=None,",
            "    )",
            "    has_cookie_header = \"Cookie\" in redirect_request.headers",
            "    has_authorization_header = \"Authorization\" in redirect_request.headers",
            "    if has_cookie_header or has_authorization_header:",
            "        default_ports = {\"http\": 80, \"https\": 443}",
            "",
            "        parsed_source_request = urlparse_cached(source_request)",
            "        source_scheme, source_host, source_port = (",
            "            parsed_source_request.scheme,",
            "            parsed_source_request.hostname,",
            "            parsed_source_request.port",
            "            or default_ports.get(parsed_source_request.scheme),",
            "        )",
            "",
            "        parsed_redirect_request = urlparse_cached(redirect_request)",
            "        redirect_scheme, redirect_host, redirect_port = (",
            "            parsed_redirect_request.scheme,",
            "            parsed_redirect_request.hostname,",
            "            parsed_redirect_request.port",
            "            or default_ports.get(parsed_redirect_request.scheme),",
            "        )",
            "",
            "        if has_cookie_header and (",
            "            (source_scheme != redirect_scheme and redirect_scheme != \"https\")",
            "            or source_host != redirect_host",
            "        ):",
            "            del redirect_request.headers[\"Cookie\"]",
            "",
            "        # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name",
            "        if has_authorization_header and (",
            "            source_scheme != redirect_scheme",
            "            or source_host != redirect_host",
            "            or source_port != redirect_port",
            "        ):",
            "            del redirect_request.headers[\"Authorization\"]",
            "",
            "    return redirect_request",
            "",
            "",
            "class BaseRedirectMiddleware:",
            "    enabled_setting = \"REDIRECT_ENABLED\"",
            "",
            "    def __init__(self, settings):",
            "        if not settings.getbool(self.enabled_setting):",
            "            raise NotConfigured",
            "",
            "        self.max_redirect_times = settings.getint(\"REDIRECT_MAX_TIMES\")",
            "        self.priority_adjust = settings.getint(\"REDIRECT_PRIORITY_ADJUST\")",
            "",
            "    @classmethod",
            "    def from_crawler(cls, crawler):",
            "        return cls(crawler.settings)",
            "",
            "    def _redirect(self, redirected, request, spider, reason):",
            "        ttl = request.meta.setdefault(\"redirect_ttl\", self.max_redirect_times)",
            "        redirects = request.meta.get(\"redirect_times\", 0) + 1",
            "",
            "        if ttl and redirects <= self.max_redirect_times:",
            "            redirected.meta[\"redirect_times\"] = redirects",
            "            redirected.meta[\"redirect_ttl\"] = ttl - 1",
            "            redirected.meta[\"redirect_urls\"] = request.meta.get(\"redirect_urls\", []) + [",
            "                request.url",
            "            ]",
            "            redirected.meta[\"redirect_reasons\"] = request.meta.get(",
            "                \"redirect_reasons\", []",
            "            ) + [reason]",
            "            redirected.dont_filter = request.dont_filter",
            "            redirected.priority = request.priority + self.priority_adjust",
            "            logger.debug(",
            "                \"Redirecting (%(reason)s) to %(redirected)s from %(request)s\",",
            "                {\"reason\": reason, \"redirected\": redirected, \"request\": request},",
            "                extra={\"spider\": spider},",
            "            )",
            "            return redirected",
            "        logger.debug(",
            "            \"Discarding %(request)s: max redirections reached\",",
            "            {\"request\": request},",
            "            extra={\"spider\": spider},",
            "        )",
            "        raise IgnoreRequest(\"max redirections reached\")",
            "",
            "    def _redirect_request_using_get(self, request, redirect_url):",
            "        redirect_request = _build_redirect_request(",
            "            request,",
            "            url=redirect_url,",
            "            method=\"GET\",",
            "            body=\"\",",
            "        )",
            "        redirect_request.headers.pop(\"Content-Type\", None)",
            "        redirect_request.headers.pop(\"Content-Length\", None)",
            "        return redirect_request",
            "",
            "",
            "class RedirectMiddleware(BaseRedirectMiddleware):",
            "    \"\"\"",
            "    Handle redirection of requests based on response status",
            "    and meta-refresh html tag.",
            "    \"\"\"",
            "",
            "    def process_response(self, request, response, spider):",
            "        if (",
            "            request.meta.get(\"dont_redirect\", False)",
            "            or response.status in getattr(spider, \"handle_httpstatus_list\", [])",
            "            or response.status in request.meta.get(\"handle_httpstatus_list\", [])",
            "            or request.meta.get(\"handle_httpstatus_all\", False)",
            "        ):",
            "            return response",
            "",
            "        allowed_status = (301, 302, 303, 307, 308)",
            "        if \"Location\" not in response.headers or response.status not in allowed_status:",
            "            return response",
            "",
            "        location = safe_url_string(response.headers[\"Location\"])",
            "        if response.headers[\"Location\"].startswith(b\"//\"):",
            "            request_scheme = urlparse(request.url).scheme",
            "            location = request_scheme + \"://\" + location.lstrip(\"/\")",
            "",
            "        redirected_url = urljoin(request.url, location)",
            "",
            "        if response.status in (301, 307, 308) or request.method == \"HEAD\":",
            "            redirected = _build_redirect_request(request, url=redirected_url)",
            "            return self._redirect(redirected, request, spider, response.status)",
            "",
            "        redirected = self._redirect_request_using_get(request, redirected_url)",
            "        return self._redirect(redirected, request, spider, response.status)",
            "",
            "",
            "class MetaRefreshMiddleware(BaseRedirectMiddleware):",
            "    enabled_setting = \"METAREFRESH_ENABLED\"",
            "",
            "    def __init__(self, settings):",
            "        super().__init__(settings)",
            "        self._ignore_tags = settings.getlist(\"METAREFRESH_IGNORE_TAGS\")",
            "        self._maxdelay = settings.getint(\"METAREFRESH_MAXDELAY\")",
            "",
            "    def process_response(self, request, response, spider):",
            "        if (",
            "            request.meta.get(\"dont_redirect\", False)",
            "            or request.method == \"HEAD\"",
            "            or not isinstance(response, HtmlResponse)",
            "        ):",
            "            return response",
            "",
            "        interval, url = get_meta_refresh(response, ignore_tags=self._ignore_tags)",
            "        if url and interval < self._maxdelay:",
            "            redirected = self._redirect_request_using_get(request, url)",
            "            return self._redirect(redirected, request, spider, \"meta refresh\")",
            "",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [
                "_build_redirect_request"
            ],
            "24": [
                "_build_redirect_request"
            ],
            "25": [
                "_build_redirect_request"
            ],
            "26": [
                "_build_redirect_request"
            ],
            "27": [
                "_build_redirect_request"
            ],
            "28": [
                "_build_redirect_request"
            ],
            "29": [
                "_build_redirect_request"
            ],
            "30": [
                "_build_redirect_request"
            ]
        },
        "addLocation": []
    }
}