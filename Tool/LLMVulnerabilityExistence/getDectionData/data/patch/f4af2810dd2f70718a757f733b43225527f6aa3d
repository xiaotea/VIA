{
    "django_celery_results/backends/database.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "                 return True"
            },
            "1": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         return False"
            },
            "2": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    def _get_extended_properties(self, request, traceback, using):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        properties = getattr(request, 'properties', {}) or {}"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        extended_props = {"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            'periodic_task_name': None,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            'task_args': None,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            'task_kwargs': None,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            'task_name': None,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            'traceback': None,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            'using': None,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            'worker': None,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        }"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        if request and self.app.conf.find_value_for_key('extended', 'result'):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            if getattr(request, 'argsrepr', None) is not None:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                # task protocol 2"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                task_args = request.argsrepr"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            else:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                # task protocol 1"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                task_args = getattr(request, 'args', None)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            if getattr(request, 'kwargsrepr', None) is not None:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                # task protocol 2"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                task_kwargs = request.kwargsrepr"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            else:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+                # task protocol 1"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                task_kwargs = getattr(request, 'kwargs', None)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            # Encode input arguments"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            if task_args is not None:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                _, _, task_args = self.encode_content(task_args)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            if task_kwargs is not None:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                _, _, task_kwargs = self.encode_content(task_kwargs)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            "
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            extended_props.update({"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                'periodic_task_name': properties.get('periodic_task_name', None),"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                'task_args': task_kwargs,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                'task_kwargs': task_args,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                'task_name': getattr(request, 'task', None),"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                'traceback': traceback,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                'using': using,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                'worker': getattr(request, 'hostname', None),"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            })"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        "
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        return extended_props"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     def _store_result("
            },
            "50": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             self,"
            },
            "51": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "             task_id,"
            },
            "52": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             {'children': self.current_task_children(request)}"
            },
            "53": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         )"
            },
            "54": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        task_name = getattr(request, 'task', None)"
            },
            "56": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        properties = getattr(request, 'properties', {}) or {}"
            },
            "57": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        periodic_task_name = properties.get('periodic_task_name', None)"
            },
            "58": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        worker = getattr(request, 'hostname', None)"
            },
            "59": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "60": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Get input arguments"
            },
            "61": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if getattr(request, 'argsrepr', None) is not None:"
            },
            "62": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # task protocol 2"
            },
            "63": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_args = request.argsrepr"
            },
            "64": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "65": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # task protocol 1"
            },
            "66": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_args = getattr(request, 'args', None)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        task_props = {"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            'content_encoding': content_encoding,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            'content_type' : content_type,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            'meta': meta,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+            'result': result,"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            'status': status, "
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+            'task_id': task_id,"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            'traceback': traceback,"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        }"
            },
            "76": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if getattr(request, 'kwargsrepr', None) is not None:"
            },
            "78": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # task protocol 2"
            },
            "79": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_kwargs = request.kwargsrepr"
            },
            "80": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "81": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # task protocol 1"
            },
            "82": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_kwargs = getattr(request, 'kwargs', None)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        task_props.update(self._get_extended_properties(request, traceback, using))"
            },
            "84": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "85": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Encode input arguments"
            },
            "86": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if task_args is not None:"
            },
            "87": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            _, _, task_args = self.encode_content(task_args)"
            },
            "88": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "89": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if task_kwargs is not None:"
            },
            "90": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            _, _, task_kwargs = self.encode_content(task_kwargs)"
            },
            "91": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "92": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.TaskModel._default_manager.store_result("
            },
            "93": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content_type,"
            },
            "94": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content_encoding,"
            },
            "95": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_id,"
            },
            "96": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result,"
            },
            "97": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            status,"
            },
            "98": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            traceback=traceback,"
            },
            "99": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            meta=meta,"
            },
            "100": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            periodic_task_name=periodic_task_name,"
            },
            "101": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_name=task_name,"
            },
            "102": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_args=task_args,"
            },
            "103": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            task_kwargs=task_kwargs,"
            },
            "104": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            worker=worker,"
            },
            "105": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            using=using,"
            },
            "106": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        self.TaskModel._default_manager.store_result(**task_props)"
            },
            "108": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         return result"
            },
            "109": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "110": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     def _get_task_meta_for(self, task_id):"
            }
        },
        "frontPatchFile": [
            "import binascii",
            "import json",
            "",
            "from celery import maybe_signature",
            "from celery.backends.base import BaseDictBackend",
            "from celery.exceptions import ChordError",
            "from celery.result import GroupResult, allow_join_result, result_from_tuple",
            "from celery.utils.log import get_logger",
            "from celery.utils.serialization import b64decode, b64encode",
            "from django.db import connection, transaction",
            "from django.db.utils import InterfaceError",
            "from kombu.exceptions import DecodeError",
            "",
            "from ..models import ChordCounter",
            "from ..models import GroupResult as GroupResultModel",
            "from ..models import TaskResult",
            "",
            "EXCEPTIONS_TO_CATCH = (InterfaceError,)",
            "",
            "try:",
            "    from psycopg2 import InterfaceError as Psycopg2InterfaceError",
            "    EXCEPTIONS_TO_CATCH += (Psycopg2InterfaceError,)",
            "except ImportError:",
            "    pass",
            "",
            "logger = get_logger(__name__)",
            "",
            "",
            "class DatabaseBackend(BaseDictBackend):",
            "    \"\"\"The Django database backend, using models to store task state.\"\"\"",
            "",
            "    TaskModel = TaskResult",
            "    GroupModel = GroupResultModel",
            "    subpolling_interval = 0.5",
            "",
            "    def exception_safe_to_retry(self, exc):",
            "        \"\"\"Check if an exception is safe to retry.",
            "",
            "        Backends have to overload this method with correct predicates",
            "        dealing with their exceptions.",
            "",
            "        By default no exception is safe to retry, it's up to",
            "        backend implementation to define which exceptions are safe.",
            "",
            "        For Celery / django-celery-results, retry Django / Psycopg2",
            "        InterfaceErrors, like \"Connection already closed\", with new connection.",
            "",
            "        Set result_backend_always_retry to True in order to enable retries.",
            "        \"\"\"",
            "        for exc_type in EXCEPTIONS_TO_CATCH:",
            "            if isinstance(exc, exc_type):",
            "                # Only called if InterfaceError occurs and always_retry is True",
            "                connection.close()",
            "                return True",
            "        return False",
            "",
            "    def _store_result(",
            "            self,",
            "            task_id,",
            "            result,",
            "            status,",
            "            traceback=None,",
            "            request=None,",
            "            using=None",
            "    ):",
            "        \"\"\"Store return value and status of an executed task.\"\"\"",
            "        content_type, content_encoding, result = self.encode_content(result)",
            "        _, _, meta = self.encode_content(",
            "            {'children': self.current_task_children(request)}",
            "        )",
            "",
            "        task_name = getattr(request, 'task', None)",
            "        properties = getattr(request, 'properties', {}) or {}",
            "        periodic_task_name = properties.get('periodic_task_name', None)",
            "        worker = getattr(request, 'hostname', None)",
            "",
            "        # Get input arguments",
            "        if getattr(request, 'argsrepr', None) is not None:",
            "            # task protocol 2",
            "            task_args = request.argsrepr",
            "        else:",
            "            # task protocol 1",
            "            task_args = getattr(request, 'args', None)",
            "",
            "        if getattr(request, 'kwargsrepr', None) is not None:",
            "            # task protocol 2",
            "            task_kwargs = request.kwargsrepr",
            "        else:",
            "            # task protocol 1",
            "            task_kwargs = getattr(request, 'kwargs', None)",
            "",
            "        # Encode input arguments",
            "        if task_args is not None:",
            "            _, _, task_args = self.encode_content(task_args)",
            "",
            "        if task_kwargs is not None:",
            "            _, _, task_kwargs = self.encode_content(task_kwargs)",
            "",
            "        self.TaskModel._default_manager.store_result(",
            "            content_type,",
            "            content_encoding,",
            "            task_id,",
            "            result,",
            "            status,",
            "            traceback=traceback,",
            "            meta=meta,",
            "            periodic_task_name=periodic_task_name,",
            "            task_name=task_name,",
            "            task_args=task_args,",
            "            task_kwargs=task_kwargs,",
            "            worker=worker,",
            "            using=using,",
            "        )",
            "        return result",
            "",
            "    def _get_task_meta_for(self, task_id):",
            "        \"\"\"Get task metadata for a task by id.\"\"\"",
            "        obj = self.TaskModel._default_manager.get_task(task_id)",
            "        res = obj.as_dict()",
            "        meta = self.decode_content(obj, res.pop('meta', None)) or {}",
            "        result = self.decode_content(obj, res.get('result'))",
            "",
            "        task_args = res.get('task_args')",
            "        task_kwargs = res.get('task_kwargs')",
            "        try:",
            "            task_args = self.decode_content(obj, task_args)",
            "            task_kwargs = self.decode_content(obj, task_kwargs)",
            "        except (DecodeError, binascii.Error):",
            "            pass",
            "",
            "        # the right names are args/kwargs, not task_args/task_kwargs,",
            "        # keep both for backward compatibility",
            "        res.update(",
            "            meta,",
            "            result=result,",
            "            task_args=task_args,",
            "            task_kwargs=task_kwargs,",
            "            args=task_args,",
            "            kwargs=task_kwargs,",
            "        )",
            "        return self.meta_from_decoded(res)",
            "",
            "    def encode_content(self, data):",
            "        content_type, content_encoding, content = self._encode(data)",
            "        if content_encoding == 'binary':",
            "            content = b64encode(content)",
            "        return content_type, content_encoding, content",
            "",
            "    def decode_content(self, obj, content):",
            "        if content:",
            "            if obj.content_encoding == 'binary':",
            "                content = b64decode(content)",
            "            return self.decode(content)",
            "",
            "    def _forget(self, task_id):",
            "        try:",
            "            self.TaskModel._default_manager.get(task_id=task_id).delete()",
            "        except self.TaskModel.DoesNotExist:",
            "            pass",
            "",
            "    def cleanup(self):",
            "        \"\"\"Delete expired metadata.\"\"\"",
            "        self.TaskModel._default_manager.delete_expired(self.expires)",
            "        self.GroupModel._default_manager.delete_expired(self.expires)",
            "",
            "    def _restore_group(self, group_id):",
            "        \"\"\"return result value for a group by id.\"\"\"",
            "        group_result = self.GroupModel._default_manager.get_group(group_id)",
            "",
            "        if group_result:",
            "            res = group_result.as_dict()",
            "            decoded_result = self.decode_content(group_result, res[\"result\"])",
            "            res[\"result\"] = None",
            "            if decoded_result:",
            "                res[\"result\"] = result_from_tuple(decoded_result, app=self.app)",
            "            return res",
            "",
            "    def _save_group(self, group_id, group_result):",
            "        \"\"\"Store return value of group\"\"\"",
            "        content_type, content_encoding, result = self.encode_content(",
            "            group_result.as_tuple()",
            "        )",
            "        self.GroupModel._default_manager.store_group_result(",
            "            content_type, content_encoding, group_id, result",
            "        )",
            "        return group_result",
            "",
            "    def _delete_group(self, group_id):",
            "        try:",
            "            self.GroupModel._default_manager.get_group(group_id).delete()",
            "        except self.TaskModel.DoesNotExist:",
            "            pass",
            "",
            "    def apply_chord(self, header_result_args, body, **kwargs):",
            "        \"\"\"Add a ChordCounter with the expected number of results\"\"\"",
            "        if not isinstance(header_result_args, GroupResult):",
            "            # Celery 5.1 provides the GroupResult args",
            "            header_result = self.app.GroupResult(*header_result_args)",
            "        else:",
            "            # celery <5.1 will pass a GroupResult object",
            "            header_result = header_result_args",
            "        results = [r.as_tuple() for r in header_result]",
            "        chord_size = body.get(\"chord_size\", None) or len(results)",
            "        data = json.dumps(results)",
            "        ChordCounter.objects.create(",
            "            group_id=header_result.id, sub_tasks=data, count=chord_size",
            "        )",
            "",
            "    def on_chord_part_return(self, request, state, result, **kwargs):",
            "        \"\"\"Called on finishing each part of a Chord header\"\"\"",
            "        tid, gid = request.id, request.group",
            "        if not gid or not tid:",
            "            return",
            "        call_callback = False",
            "        with transaction.atomic():",
            "            # We need to know if `count` hits 0.",
            "            # wrap the update in a transaction",
            "            # with a `select_for_update` lock to prevent race conditions.",
            "            # SELECT FOR UPDATE is not supported on all databases",
            "            chord_counter = (",
            "                ChordCounter.objects.select_for_update()",
            "                .filter(group_id=gid).first()",
            "            )",
            "            if chord_counter is None:",
            "                logger.warning(\"Can't find ChordCounter for Group %s\", gid)",
            "                return",
            "            chord_counter.count -= 1",
            "            if chord_counter.count != 0:",
            "                chord_counter.save()",
            "            else:",
            "                # Last task in the chord header has finished",
            "                call_callback = True",
            "                chord_counter.delete()",
            "",
            "        if call_callback:",
            "            deps = chord_counter.group_result(app=self.app)",
            "            if deps.ready():",
            "                callback = maybe_signature(request.chord, app=self.app)",
            "                trigger_callback(",
            "                    app=self.app,",
            "                    callback=callback,",
            "                    group_result=deps",
            "                )",
            "",
            "",
            "def trigger_callback(app, callback, group_result):",
            "    \"\"\"Add the callback to the queue or mark the callback as failed",
            "    Implementation borrowed from `celery.app.builtins.unlock_chord`",
            "    \"\"\"",
            "    if group_result.supports_native_join:",
            "        j = group_result.join_native",
            "    else:",
            "        j = group_result.join",
            "",
            "    try:",
            "        with allow_join_result():",
            "            ret = j(timeout=app.conf.result_chord_join_timeout, propagate=True)",
            "    except Exception as exc:  # pylint: disable=broad-except",
            "        try:",
            "            culprit = next(group_result._failed_join_report())",
            "            reason = f\"Dependency {culprit.id} raised {exc!r}\"",
            "        except StopIteration:",
            "            reason = repr(exc)",
            "        logger.exception(\"Chord %r raised: %r\", group_result.id, exc)",
            "        app.backend.chord_error_from_stack(callback, ChordError(reason))",
            "    else:",
            "        try:",
            "            callback.delay(ret)",
            "        except Exception as exc:  # pylint: disable=broad-except",
            "            logger.exception(\"Chord %r raised: %r\", group_result.id, exc)",
            "            app.backend.chord_error_from_stack(",
            "                callback, exc=ChordError(f\"Callback error: {exc!r}\")",
            "            )"
        ],
        "afterPatchFile": [
            "import binascii",
            "import json",
            "",
            "from celery import maybe_signature",
            "from celery.backends.base import BaseDictBackend",
            "from celery.exceptions import ChordError",
            "from celery.result import GroupResult, allow_join_result, result_from_tuple",
            "from celery.utils.log import get_logger",
            "from celery.utils.serialization import b64decode, b64encode",
            "from django.db import connection, transaction",
            "from django.db.utils import InterfaceError",
            "from kombu.exceptions import DecodeError",
            "",
            "from ..models import ChordCounter",
            "from ..models import GroupResult as GroupResultModel",
            "from ..models import TaskResult",
            "",
            "EXCEPTIONS_TO_CATCH = (InterfaceError,)",
            "",
            "try:",
            "    from psycopg2 import InterfaceError as Psycopg2InterfaceError",
            "    EXCEPTIONS_TO_CATCH += (Psycopg2InterfaceError,)",
            "except ImportError:",
            "    pass",
            "",
            "logger = get_logger(__name__)",
            "",
            "",
            "class DatabaseBackend(BaseDictBackend):",
            "    \"\"\"The Django database backend, using models to store task state.\"\"\"",
            "",
            "    TaskModel = TaskResult",
            "    GroupModel = GroupResultModel",
            "    subpolling_interval = 0.5",
            "",
            "    def exception_safe_to_retry(self, exc):",
            "        \"\"\"Check if an exception is safe to retry.",
            "",
            "        Backends have to overload this method with correct predicates",
            "        dealing with their exceptions.",
            "",
            "        By default no exception is safe to retry, it's up to",
            "        backend implementation to define which exceptions are safe.",
            "",
            "        For Celery / django-celery-results, retry Django / Psycopg2",
            "        InterfaceErrors, like \"Connection already closed\", with new connection.",
            "",
            "        Set result_backend_always_retry to True in order to enable retries.",
            "        \"\"\"",
            "        for exc_type in EXCEPTIONS_TO_CATCH:",
            "            if isinstance(exc, exc_type):",
            "                # Only called if InterfaceError occurs and always_retry is True",
            "                connection.close()",
            "                return True",
            "        return False",
            "",
            "    def _get_extended_properties(self, request, traceback, using):",
            "        properties = getattr(request, 'properties', {}) or {}",
            "        extended_props = {",
            "            'periodic_task_name': None,",
            "            'task_args': None,",
            "            'task_kwargs': None,",
            "            'task_name': None,",
            "            'traceback': None,",
            "            'using': None,",
            "            'worker': None,",
            "        }",
            "        if request and self.app.conf.find_value_for_key('extended', 'result'):",
            "            ",
            "            if getattr(request, 'argsrepr', None) is not None:",
            "                # task protocol 2",
            "                task_args = request.argsrepr",
            "            else:",
            "                # task protocol 1",
            "                task_args = getattr(request, 'args', None)",
            "",
            "            if getattr(request, 'kwargsrepr', None) is not None:",
            "                # task protocol 2",
            "                task_kwargs = request.kwargsrepr",
            "            else:",
            "                # task protocol 1",
            "                task_kwargs = getattr(request, 'kwargs', None)",
            "",
            "            # Encode input arguments",
            "            if task_args is not None:",
            "                _, _, task_args = self.encode_content(task_args)",
            "",
            "            if task_kwargs is not None:",
            "                _, _, task_kwargs = self.encode_content(task_kwargs)",
            "            ",
            "            extended_props.update({",
            "                'periodic_task_name': properties.get('periodic_task_name', None),",
            "                'task_args': task_kwargs,",
            "                'task_kwargs': task_args,",
            "                'task_name': getattr(request, 'task', None),",
            "                'traceback': traceback,",
            "                'using': using,",
            "                'worker': getattr(request, 'hostname', None),",
            "            })",
            "        ",
            "        return extended_props",
            "",
            "    def _store_result(",
            "            self,",
            "            task_id,",
            "            result,",
            "            status,",
            "            traceback=None,",
            "            request=None,",
            "            using=None",
            "    ):",
            "        \"\"\"Store return value and status of an executed task.\"\"\"",
            "        content_type, content_encoding, result = self.encode_content(result)",
            "        _, _, meta = self.encode_content(",
            "            {'children': self.current_task_children(request)}",
            "        )",
            "",
            "        task_props = {",
            "            'content_encoding': content_encoding,",
            "            'content_type' : content_type,",
            "            'meta': meta,",
            "            'result': result,",
            "            'status': status, ",
            "            'task_id': task_id,",
            "            'traceback': traceback,",
            "        }",
            "",
            "        task_props.update(self._get_extended_properties(request, traceback, using))",
            "",
            "        self.TaskModel._default_manager.store_result(**task_props)",
            "        return result",
            "",
            "    def _get_task_meta_for(self, task_id):",
            "        \"\"\"Get task metadata for a task by id.\"\"\"",
            "        obj = self.TaskModel._default_manager.get_task(task_id)",
            "        res = obj.as_dict()",
            "        meta = self.decode_content(obj, res.pop('meta', None)) or {}",
            "        result = self.decode_content(obj, res.get('result'))",
            "",
            "        task_args = res.get('task_args')",
            "        task_kwargs = res.get('task_kwargs')",
            "        try:",
            "            task_args = self.decode_content(obj, task_args)",
            "            task_kwargs = self.decode_content(obj, task_kwargs)",
            "        except (DecodeError, binascii.Error):",
            "            pass",
            "",
            "        # the right names are args/kwargs, not task_args/task_kwargs,",
            "        # keep both for backward compatibility",
            "        res.update(",
            "            meta,",
            "            result=result,",
            "            task_args=task_args,",
            "            task_kwargs=task_kwargs,",
            "            args=task_args,",
            "            kwargs=task_kwargs,",
            "        )",
            "        return self.meta_from_decoded(res)",
            "",
            "    def encode_content(self, data):",
            "        content_type, content_encoding, content = self._encode(data)",
            "        if content_encoding == 'binary':",
            "            content = b64encode(content)",
            "        return content_type, content_encoding, content",
            "",
            "    def decode_content(self, obj, content):",
            "        if content:",
            "            if obj.content_encoding == 'binary':",
            "                content = b64decode(content)",
            "            return self.decode(content)",
            "",
            "    def _forget(self, task_id):",
            "        try:",
            "            self.TaskModel._default_manager.get(task_id=task_id).delete()",
            "        except self.TaskModel.DoesNotExist:",
            "            pass",
            "",
            "    def cleanup(self):",
            "        \"\"\"Delete expired metadata.\"\"\"",
            "        self.TaskModel._default_manager.delete_expired(self.expires)",
            "        self.GroupModel._default_manager.delete_expired(self.expires)",
            "",
            "    def _restore_group(self, group_id):",
            "        \"\"\"return result value for a group by id.\"\"\"",
            "        group_result = self.GroupModel._default_manager.get_group(group_id)",
            "",
            "        if group_result:",
            "            res = group_result.as_dict()",
            "            decoded_result = self.decode_content(group_result, res[\"result\"])",
            "            res[\"result\"] = None",
            "            if decoded_result:",
            "                res[\"result\"] = result_from_tuple(decoded_result, app=self.app)",
            "            return res",
            "",
            "    def _save_group(self, group_id, group_result):",
            "        \"\"\"Store return value of group\"\"\"",
            "        content_type, content_encoding, result = self.encode_content(",
            "            group_result.as_tuple()",
            "        )",
            "        self.GroupModel._default_manager.store_group_result(",
            "            content_type, content_encoding, group_id, result",
            "        )",
            "        return group_result",
            "",
            "    def _delete_group(self, group_id):",
            "        try:",
            "            self.GroupModel._default_manager.get_group(group_id).delete()",
            "        except self.TaskModel.DoesNotExist:",
            "            pass",
            "",
            "    def apply_chord(self, header_result_args, body, **kwargs):",
            "        \"\"\"Add a ChordCounter with the expected number of results\"\"\"",
            "        if not isinstance(header_result_args, GroupResult):",
            "            # Celery 5.1 provides the GroupResult args",
            "            header_result = self.app.GroupResult(*header_result_args)",
            "        else:",
            "            # celery <5.1 will pass a GroupResult object",
            "            header_result = header_result_args",
            "        results = [r.as_tuple() for r in header_result]",
            "        chord_size = body.get(\"chord_size\", None) or len(results)",
            "        data = json.dumps(results)",
            "        ChordCounter.objects.create(",
            "            group_id=header_result.id, sub_tasks=data, count=chord_size",
            "        )",
            "",
            "    def on_chord_part_return(self, request, state, result, **kwargs):",
            "        \"\"\"Called on finishing each part of a Chord header\"\"\"",
            "        tid, gid = request.id, request.group",
            "        if not gid or not tid:",
            "            return",
            "        call_callback = False",
            "        with transaction.atomic():",
            "            # We need to know if `count` hits 0.",
            "            # wrap the update in a transaction",
            "            # with a `select_for_update` lock to prevent race conditions.",
            "            # SELECT FOR UPDATE is not supported on all databases",
            "            chord_counter = (",
            "                ChordCounter.objects.select_for_update()",
            "                .filter(group_id=gid).first()",
            "            )",
            "            if chord_counter is None:",
            "                logger.warning(\"Can't find ChordCounter for Group %s\", gid)",
            "                return",
            "            chord_counter.count -= 1",
            "            if chord_counter.count != 0:",
            "                chord_counter.save()",
            "            else:",
            "                # Last task in the chord header has finished",
            "                call_callback = True",
            "                chord_counter.delete()",
            "",
            "        if call_callback:",
            "            deps = chord_counter.group_result(app=self.app)",
            "            if deps.ready():",
            "                callback = maybe_signature(request.chord, app=self.app)",
            "                trigger_callback(",
            "                    app=self.app,",
            "                    callback=callback,",
            "                    group_result=deps",
            "                )",
            "",
            "",
            "def trigger_callback(app, callback, group_result):",
            "    \"\"\"Add the callback to the queue or mark the callback as failed",
            "    Implementation borrowed from `celery.app.builtins.unlock_chord`",
            "    \"\"\"",
            "    if group_result.supports_native_join:",
            "        j = group_result.join_native",
            "    else:",
            "        j = group_result.join",
            "",
            "    try:",
            "        with allow_join_result():",
            "            ret = j(timeout=app.conf.result_chord_join_timeout, propagate=True)",
            "    except Exception as exc:  # pylint: disable=broad-except",
            "        try:",
            "            culprit = next(group_result._failed_join_report())",
            "            reason = f\"Dependency {culprit.id} raised {exc!r}\"",
            "        except StopIteration:",
            "            reason = repr(exc)",
            "        logger.exception(\"Chord %r raised: %r\", group_result.id, exc)",
            "        app.backend.chord_error_from_stack(callback, ChordError(reason))",
            "    else:",
            "        try:",
            "            callback.delay(ret)",
            "        except Exception as exc:  # pylint: disable=broad-except",
            "            logger.exception(\"Chord %r raised: %r\", group_result.id, exc)",
            "            app.backend.chord_error_from_stack(",
            "                callback, exc=ChordError(f\"Callback error: {exc!r}\")",
            "            )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "72": [
                "DatabaseBackend",
                "_store_result"
            ],
            "73": [
                "DatabaseBackend",
                "_store_result"
            ],
            "74": [
                "DatabaseBackend",
                "_store_result"
            ],
            "75": [
                "DatabaseBackend",
                "_store_result"
            ],
            "76": [
                "DatabaseBackend",
                "_store_result"
            ],
            "77": [
                "DatabaseBackend",
                "_store_result"
            ],
            "78": [
                "DatabaseBackend",
                "_store_result"
            ],
            "79": [
                "DatabaseBackend",
                "_store_result"
            ],
            "80": [
                "DatabaseBackend",
                "_store_result"
            ],
            "81": [
                "DatabaseBackend",
                "_store_result"
            ],
            "82": [
                "DatabaseBackend",
                "_store_result"
            ],
            "83": [
                "DatabaseBackend",
                "_store_result"
            ],
            "85": [
                "DatabaseBackend",
                "_store_result"
            ],
            "86": [
                "DatabaseBackend",
                "_store_result"
            ],
            "87": [
                "DatabaseBackend",
                "_store_result"
            ],
            "88": [
                "DatabaseBackend",
                "_store_result"
            ],
            "89": [
                "DatabaseBackend",
                "_store_result"
            ],
            "90": [
                "DatabaseBackend",
                "_store_result"
            ],
            "92": [
                "DatabaseBackend",
                "_store_result"
            ],
            "93": [
                "DatabaseBackend",
                "_store_result"
            ],
            "94": [
                "DatabaseBackend",
                "_store_result"
            ],
            "95": [
                "DatabaseBackend",
                "_store_result"
            ],
            "96": [
                "DatabaseBackend",
                "_store_result"
            ],
            "97": [
                "DatabaseBackend",
                "_store_result"
            ],
            "98": [
                "DatabaseBackend",
                "_store_result"
            ],
            "99": [
                "DatabaseBackend",
                "_store_result"
            ],
            "100": [
                "DatabaseBackend",
                "_store_result"
            ],
            "101": [
                "DatabaseBackend",
                "_store_result"
            ],
            "102": [
                "DatabaseBackend",
                "_store_result"
            ],
            "103": [
                "DatabaseBackend",
                "_store_result"
            ],
            "104": [
                "DatabaseBackend",
                "_store_result"
            ],
            "105": [
                "DatabaseBackend",
                "_store_result"
            ],
            "106": [
                "DatabaseBackend",
                "_store_result"
            ],
            "107": [
                "DatabaseBackend",
                "_store_result"
            ],
            "108": [
                "DatabaseBackend",
                "_store_result"
            ],
            "109": [
                "DatabaseBackend",
                "_store_result"
            ],
            "110": [
                "DatabaseBackend",
                "_store_result"
            ],
            "111": [
                "DatabaseBackend",
                "_store_result"
            ],
            "112": [
                "DatabaseBackend",
                "_store_result"
            ],
            "113": [
                "DatabaseBackend",
                "_store_result"
            ]
        },
        "addLocation": []
    }
}