{
    "nova/api/metadata/handler.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     def _handle_instance_id_request(self, req):"
            },
            "2": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         instance_id = req.headers.get('X-Instance-ID')"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        tenant_id = req.headers.get('X-Tenant-ID')"
            },
            "4": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         signature = req.headers.get('X-Instance-ID-Signature')"
            },
            "5": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         remote_address = req.headers.get('X-Forwarded-For')"
            },
            "6": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         # Ensure that only one header was passed"
            },
            "8": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         if instance_id is None:"
            },
            "10": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "             msg = _('X-Instance-ID header is missing from request.')"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        elif tenant_id is None:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            msg = _('X-Tenant-ID header is missing from request.')"
            },
            "13": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         elif not isinstance(instance_id, basestring):"
            },
            "14": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             msg = _('Multiple X-Instance-ID headers found within request.')"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        elif not isinstance(tenant_id, basestring):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            msg = _('Multiple X-Tenant-ID headers found within request.')"
            },
            "17": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         else:"
            },
            "18": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "             msg = None"
            },
            "19": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "             LOG.error(_('Failed to get metadata for instance id: %s'),"
            },
            "21": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "                       instance_id)"
            },
            "22": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        if meta_data.instance['project_id'] != tenant_id:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            LOG.warning(_(\"Tenant_id %(tenant_id)s does not match tenant_id \""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                          \"of instance %(instance_id)s.\"),"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                        {'tenant_id': tenant_id,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                         'instance_id': instance_id})"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            # causes a 404 to be raised"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            meta_data = None"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         return meta_data"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Metadata request handler.\"\"\"",
            "import hashlib",
            "import hmac",
            "import os",
            "",
            "from oslo.config import cfg",
            "import webob.dec",
            "import webob.exc",
            "",
            "from nova.api.metadata import base",
            "from nova import conductor",
            "from nova import exception",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import memorycache",
            "from nova import wsgi",
            "",
            "CACHE_EXPIRATION = 15  # in seconds",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('use_forwarded_for', 'nova.api.auth')",
            "",
            "metadata_proxy_opts = [",
            "    cfg.BoolOpt(",
            "        'service_quantum_metadata_proxy',",
            "        default=False,",
            "        help='Set flag to indicate Quantum will proxy metadata requests and '",
            "             'resolve instance ids.'),",
            "     cfg.StrOpt(",
            "         'quantum_metadata_proxy_shared_secret',",
            "         default='',",
            "         help='Shared secret to validate proxies Quantum metadata requests')",
            "]",
            "",
            "CONF.register_opts(metadata_proxy_opts)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class MetadataRequestHandler(wsgi.Application):",
            "    \"\"\"Serve metadata.\"\"\"",
            "",
            "    def __init__(self):",
            "        self._cache = memorycache.get_client()",
            "        self.conductor_api = conductor.API()",
            "",
            "    def get_metadata_by_remote_address(self, address):",
            "        if not address:",
            "            raise exception.FixedIpNotFoundForAddress(address=address)",
            "",
            "        cache_key = 'metadata-%s' % address",
            "        data = self._cache.get(cache_key)",
            "        if data:",
            "            return data",
            "",
            "        try:",
            "            data = base.get_metadata_by_address(self.conductor_api, address)",
            "        except exception.NotFound:",
            "            return None",
            "",
            "        self._cache.set(cache_key, data, CACHE_EXPIRATION)",
            "",
            "        return data",
            "",
            "    def get_metadata_by_instance_id(self, instance_id, address):",
            "        cache_key = 'metadata-%s' % instance_id",
            "        data = self._cache.get(cache_key)",
            "        if data:",
            "            return data",
            "",
            "        try:",
            "            data = base.get_metadata_by_instance_id(self.conductor_api,",
            "                                                    instance_id, address)",
            "        except exception.NotFound:",
            "            return None",
            "",
            "        self._cache.set(cache_key, data, CACHE_EXPIRATION)",
            "",
            "        return data",
            "",
            "    @webob.dec.wsgify(RequestClass=wsgi.Request)",
            "    def __call__(self, req):",
            "        if os.path.normpath(\"/\" + req.path_info) == \"/\":",
            "            return(base.ec2_md_print(base.VERSIONS + [\"latest\"]))",
            "",
            "        if CONF.service_quantum_metadata_proxy:",
            "            meta_data = self._handle_instance_id_request(req)",
            "        else:",
            "            if req.headers.get('X-Instance-ID'):",
            "                LOG.warn(",
            "                    _(\"X-Instance-ID present in request headers. The \"",
            "                      \"'service_quantum_metadata_proxy' option must be enabled\"",
            "                      \" to process this header.\"))",
            "            meta_data = self._handle_remote_ip_request(req)",
            "",
            "        if meta_data is None:",
            "            raise webob.exc.HTTPNotFound()",
            "",
            "        try:",
            "            data = meta_data.lookup(req.path_info)",
            "        except base.InvalidMetadataPath:",
            "            raise webob.exc.HTTPNotFound()",
            "",
            "        if callable(data):",
            "            return data(req, meta_data)",
            "",
            "        return base.ec2_md_print(data)",
            "",
            "    def _handle_remote_ip_request(self, req):",
            "        remote_address = req.remote_addr",
            "        if CONF.use_forwarded_for:",
            "            remote_address = req.headers.get('X-Forwarded-For', remote_address)",
            "",
            "        try:",
            "            meta_data = self.get_metadata_by_remote_address(remote_address)",
            "        except Exception:",
            "            LOG.exception(_('Failed to get metadata for ip: %s'),",
            "                          remote_address)",
            "            msg = _('An unknown error has occurred. '",
            "                    'Please try your request again.')",
            "            raise webob.exc.HTTPInternalServerError(explanation=unicode(msg))",
            "",
            "        if meta_data is None:",
            "            LOG.error(_('Failed to get metadata for ip: %s'), remote_address)",
            "",
            "        return meta_data",
            "",
            "    def _handle_instance_id_request(self, req):",
            "        instance_id = req.headers.get('X-Instance-ID')",
            "        signature = req.headers.get('X-Instance-ID-Signature')",
            "        remote_address = req.headers.get('X-Forwarded-For')",
            "",
            "        # Ensure that only one header was passed",
            "",
            "        if instance_id is None:",
            "            msg = _('X-Instance-ID header is missing from request.')",
            "        elif not isinstance(instance_id, basestring):",
            "            msg = _('Multiple X-Instance-ID headers found within request.')",
            "        else:",
            "            msg = None",
            "",
            "        if msg:",
            "            raise webob.exc.HTTPBadRequest(explanation=msg)",
            "",
            "        expected_signature = hmac.new(",
            "            CONF.quantum_metadata_proxy_shared_secret,",
            "            instance_id,",
            "            hashlib.sha256).hexdigest()",
            "",
            "        if expected_signature != signature:",
            "            if instance_id:",
            "                w = _('X-Instance-ID-Signature: %(signature)s does not match '",
            "                      'the expected value: %(expected_signature)s for id: '",
            "                      '%(instance_id)s.  Request From: %(remote_address)s')",
            "                LOG.warn(w % locals())",
            "",
            "            msg = _('Invalid proxy request signature.')",
            "            raise webob.exc.HTTPForbidden(explanation=msg)",
            "",
            "        try:",
            "            meta_data = self.get_metadata_by_instance_id(instance_id,",
            "                                                         remote_address)",
            "        except Exception:",
            "            LOG.exception(_('Failed to get metadata for instance id: %s'),",
            "                          instance_id)",
            "            msg = _('An unknown error has occurred. '",
            "                    'Please try your request again.')",
            "            raise webob.exc.HTTPInternalServerError(explanation=unicode(msg))",
            "",
            "        if meta_data is None:",
            "            LOG.error(_('Failed to get metadata for instance id: %s'),",
            "                      instance_id)",
            "",
            "        return meta_data"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Metadata request handler.\"\"\"",
            "import hashlib",
            "import hmac",
            "import os",
            "",
            "from oslo.config import cfg",
            "import webob.dec",
            "import webob.exc",
            "",
            "from nova.api.metadata import base",
            "from nova import conductor",
            "from nova import exception",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common import memorycache",
            "from nova import wsgi",
            "",
            "CACHE_EXPIRATION = 15  # in seconds",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('use_forwarded_for', 'nova.api.auth')",
            "",
            "metadata_proxy_opts = [",
            "    cfg.BoolOpt(",
            "        'service_quantum_metadata_proxy',",
            "        default=False,",
            "        help='Set flag to indicate Quantum will proxy metadata requests and '",
            "             'resolve instance ids.'),",
            "     cfg.StrOpt(",
            "         'quantum_metadata_proxy_shared_secret',",
            "         default='',",
            "         help='Shared secret to validate proxies Quantum metadata requests')",
            "]",
            "",
            "CONF.register_opts(metadata_proxy_opts)",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class MetadataRequestHandler(wsgi.Application):",
            "    \"\"\"Serve metadata.\"\"\"",
            "",
            "    def __init__(self):",
            "        self._cache = memorycache.get_client()",
            "        self.conductor_api = conductor.API()",
            "",
            "    def get_metadata_by_remote_address(self, address):",
            "        if not address:",
            "            raise exception.FixedIpNotFoundForAddress(address=address)",
            "",
            "        cache_key = 'metadata-%s' % address",
            "        data = self._cache.get(cache_key)",
            "        if data:",
            "            return data",
            "",
            "        try:",
            "            data = base.get_metadata_by_address(self.conductor_api, address)",
            "        except exception.NotFound:",
            "            return None",
            "",
            "        self._cache.set(cache_key, data, CACHE_EXPIRATION)",
            "",
            "        return data",
            "",
            "    def get_metadata_by_instance_id(self, instance_id, address):",
            "        cache_key = 'metadata-%s' % instance_id",
            "        data = self._cache.get(cache_key)",
            "        if data:",
            "            return data",
            "",
            "        try:",
            "            data = base.get_metadata_by_instance_id(self.conductor_api,",
            "                                                    instance_id, address)",
            "        except exception.NotFound:",
            "            return None",
            "",
            "        self._cache.set(cache_key, data, CACHE_EXPIRATION)",
            "",
            "        return data",
            "",
            "    @webob.dec.wsgify(RequestClass=wsgi.Request)",
            "    def __call__(self, req):",
            "        if os.path.normpath(\"/\" + req.path_info) == \"/\":",
            "            return(base.ec2_md_print(base.VERSIONS + [\"latest\"]))",
            "",
            "        if CONF.service_quantum_metadata_proxy:",
            "            meta_data = self._handle_instance_id_request(req)",
            "        else:",
            "            if req.headers.get('X-Instance-ID'):",
            "                LOG.warn(",
            "                    _(\"X-Instance-ID present in request headers. The \"",
            "                      \"'service_quantum_metadata_proxy' option must be enabled\"",
            "                      \" to process this header.\"))",
            "            meta_data = self._handle_remote_ip_request(req)",
            "",
            "        if meta_data is None:",
            "            raise webob.exc.HTTPNotFound()",
            "",
            "        try:",
            "            data = meta_data.lookup(req.path_info)",
            "        except base.InvalidMetadataPath:",
            "            raise webob.exc.HTTPNotFound()",
            "",
            "        if callable(data):",
            "            return data(req, meta_data)",
            "",
            "        return base.ec2_md_print(data)",
            "",
            "    def _handle_remote_ip_request(self, req):",
            "        remote_address = req.remote_addr",
            "        if CONF.use_forwarded_for:",
            "            remote_address = req.headers.get('X-Forwarded-For', remote_address)",
            "",
            "        try:",
            "            meta_data = self.get_metadata_by_remote_address(remote_address)",
            "        except Exception:",
            "            LOG.exception(_('Failed to get metadata for ip: %s'),",
            "                          remote_address)",
            "            msg = _('An unknown error has occurred. '",
            "                    'Please try your request again.')",
            "            raise webob.exc.HTTPInternalServerError(explanation=unicode(msg))",
            "",
            "        if meta_data is None:",
            "            LOG.error(_('Failed to get metadata for ip: %s'), remote_address)",
            "",
            "        return meta_data",
            "",
            "    def _handle_instance_id_request(self, req):",
            "        instance_id = req.headers.get('X-Instance-ID')",
            "        tenant_id = req.headers.get('X-Tenant-ID')",
            "        signature = req.headers.get('X-Instance-ID-Signature')",
            "        remote_address = req.headers.get('X-Forwarded-For')",
            "",
            "        # Ensure that only one header was passed",
            "",
            "        if instance_id is None:",
            "            msg = _('X-Instance-ID header is missing from request.')",
            "        elif tenant_id is None:",
            "            msg = _('X-Tenant-ID header is missing from request.')",
            "        elif not isinstance(instance_id, basestring):",
            "            msg = _('Multiple X-Instance-ID headers found within request.')",
            "        elif not isinstance(tenant_id, basestring):",
            "            msg = _('Multiple X-Tenant-ID headers found within request.')",
            "        else:",
            "            msg = None",
            "",
            "        if msg:",
            "            raise webob.exc.HTTPBadRequest(explanation=msg)",
            "",
            "        expected_signature = hmac.new(",
            "            CONF.quantum_metadata_proxy_shared_secret,",
            "            instance_id,",
            "            hashlib.sha256).hexdigest()",
            "",
            "        if expected_signature != signature:",
            "            if instance_id:",
            "                w = _('X-Instance-ID-Signature: %(signature)s does not match '",
            "                      'the expected value: %(expected_signature)s for id: '",
            "                      '%(instance_id)s.  Request From: %(remote_address)s')",
            "                LOG.warn(w % locals())",
            "",
            "            msg = _('Invalid proxy request signature.')",
            "            raise webob.exc.HTTPForbidden(explanation=msg)",
            "",
            "        try:",
            "            meta_data = self.get_metadata_by_instance_id(instance_id,",
            "                                                         remote_address)",
            "        except Exception:",
            "            LOG.exception(_('Failed to get metadata for instance id: %s'),",
            "                          instance_id)",
            "            msg = _('An unknown error has occurred. '",
            "                    'Please try your request again.')",
            "            raise webob.exc.HTTPInternalServerError(explanation=unicode(msg))",
            "",
            "        if meta_data is None:",
            "            LOG.error(_('Failed to get metadata for instance id: %s'),",
            "                      instance_id)",
            "",
            "        if meta_data.instance['project_id'] != tenant_id:",
            "            LOG.warning(_(\"Tenant_id %(tenant_id)s does not match tenant_id \"",
            "                          \"of instance %(instance_id)s.\"),",
            "                        {'tenant_id': tenant_id,",
            "                         'instance_id': instance_id})",
            "            # causes a 404 to be raised",
            "            meta_data = None",
            "",
            "        return meta_data"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.api.metadata.handler.MetadataRequestHandler.__call__"
        ]
    },
    "nova/tests/test_metadata.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "             relpath=\"/2009-04-04/user-data\","
            },
            "1": {
                "beforePatchRowNumber": 511,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "             address=\"192.192.192.2\","
            },
            "2": {
                "beforePatchRowNumber": 512,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "             headers={'X-Instance-ID': 'a-b-c-d',"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+                     'X-Tenant-ID': 'test',"
            },
            "4": {
                "beforePatchRowNumber": 513,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "                      'X-Instance-ID-Signature': signed})"
            },
            "5": {
                "beforePatchRowNumber": 514,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "         self.assertEqual(response.status_int, 200)"
            },
            "6": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 516,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": 523,
                "PatchRowcode": "             fake_get_metadata_by_instance_id=fake_get_metadata,"
            },
            "8": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 524,
                "PatchRowcode": "             headers={'X-Forwarded-For': '192.192.192.2',"
            },
            "9": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 525,
                "PatchRowcode": "                      'X-Instance-ID': 'a-b-c-d',"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+                     'X-Tenant-ID': 'test',"
            },
            "11": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 527,
                "PatchRowcode": "                      'X-Instance-ID-Signature': signed})"
            },
            "12": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": 528,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 527,
                "afterPatchRowNumber": 529,
                "PatchRowcode": "         self.assertEqual(response.status_int, 200)"
            },
            "14": {
                "beforePatchRowNumber": 536,
                "afterPatchRowNumber": 538,
                "PatchRowcode": "             fake_get_metadata_by_instance_id=fake_get_metadata,"
            },
            "15": {
                "beforePatchRowNumber": 537,
                "afterPatchRowNumber": 539,
                "PatchRowcode": "             headers={'X-Forwarded-For': '192.192.192.2',"
            },
            "16": {
                "beforePatchRowNumber": 538,
                "afterPatchRowNumber": 540,
                "PatchRowcode": "                      'X-Instance-ID': 'a-b-c-d',"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 541,
                "PatchRowcode": "+                     'X-Tenant-ID': 'test',"
            },
            "18": {
                "beforePatchRowNumber": 539,
                "afterPatchRowNumber": 542,
                "PatchRowcode": "                      'X-Instance-ID-Signature': ''})"
            },
            "19": {
                "beforePatchRowNumber": 540,
                "afterPatchRowNumber": 543,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "         self.assertEqual(response.status_int, 403)"
            },
            "21": {
                "beforePatchRowNumber": 542,
                "afterPatchRowNumber": 545,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 546,
                "PatchRowcode": "+        # missing X-Tenant-ID from request"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 547,
                "PatchRowcode": "+        response = fake_request("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+            self.stubs, self.mdinst,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+            relpath=\"/2009-04-04/user-data\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 550,
                "PatchRowcode": "+            address=\"192.192.192.2\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 551,
                "PatchRowcode": "+            fake_get_metadata_by_instance_id=fake_get_metadata,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 552,
                "PatchRowcode": "+            headers={'X-Forwarded-For': '192.192.192.2',"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 553,
                "PatchRowcode": "+                     'X-Instance-ID': 'a-b-c-d',"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 554,
                "PatchRowcode": "+                     'X-Instance-ID-Signature': signed})"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 555,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 556,
                "PatchRowcode": "+        self.assertEqual(response.status_int, 400)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 557,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 558,
                "PatchRowcode": "+        # mismatched X-Tenant-ID"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 559,
                "PatchRowcode": "+        response = fake_request("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 560,
                "PatchRowcode": "+            self.stubs, self.mdinst,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 561,
                "PatchRowcode": "+            relpath=\"/2009-04-04/user-data\","
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 562,
                "PatchRowcode": "+            address=\"192.192.192.2\","
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 563,
                "PatchRowcode": "+            fake_get_metadata_by_instance_id=fake_get_metadata,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 564,
                "PatchRowcode": "+            headers={'X-Forwarded-For': '192.192.192.2',"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+                     'X-Instance-ID': 'a-b-c-d',"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 566,
                "PatchRowcode": "+                     'X-Tenant-ID': 'FAKE',"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+                     'X-Instance-ID-Signature': signed})"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 569,
                "PatchRowcode": "+        self.assertEqual(response.status_int, 404)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 571,
                "PatchRowcode": "         # without X-Forwarded-For"
            },
            "48": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "         response = fake_request("
            },
            "49": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "             self.stubs, self.mdinst,"
            },
            "50": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 574,
                "PatchRowcode": "             relpath=\"/2009-04-04/user-data\","
            },
            "51": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 575,
                "PatchRowcode": "             address=\"192.192.192.2\","
            },
            "52": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 576,
                "PatchRowcode": "             fake_get_metadata_by_instance_id=fake_get_metadata,"
            },
            "53": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 577,
                "PatchRowcode": "             headers={'X-Instance-ID': 'a-b-c-d',"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+                     'X-Tenant-ID': 'test',"
            },
            "55": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "                      'X-Instance-ID-Signature': signed})"
            },
            "56": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 580,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "         self.assertEqual(response.status_int, 500)"
            },
            "58": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 593,
                "PatchRowcode": "             fake_get_metadata_by_instance_id=fake_get_metadata,"
            },
            "59": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "             headers={'X-Forwarded-For': '192.192.192.2',"
            },
            "60": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 595,
                "PatchRowcode": "                      'X-Instance-ID': 'z-z-z-z',"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+                     'X-Tenant-ID': 'test',"
            },
            "62": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 597,
                "PatchRowcode": "                      'X-Instance-ID-Signature': signed})"
            },
            "63": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "         self.assertEqual(response.status_int, 500)"
            },
            "64": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": 599,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Tests for metadata service.\"\"\"",
            "",
            "import base64",
            "import copy",
            "import hashlib",
            "import hmac",
            "import json",
            "import re",
            "",
            "try:",
            "    import cPickle as pickle",
            "except ImportError:",
            "    import pickle",
            "",
            "from oslo.config import cfg",
            "import webob",
            "",
            "from nova.api.metadata import base",
            "from nova.api.metadata import handler",
            "from nova.api.metadata import password",
            "from nova import block_device",
            "from nova.compute import instance_types",
            "from nova.conductor import api as conductor_api",
            "from nova import db",
            "from nova.db.sqlalchemy import api",
            "from nova import exception",
            "from nova.network import api as network_api",
            "from nova import test",
            "from nova.tests import fake_network",
            "from nova import utils",
            "",
            "CONF = cfg.CONF",
            "",
            "USER_DATA_STRING = (\"This is an encoded string\")",
            "ENCODE_USER_DATA_STRING = base64.b64encode(USER_DATA_STRING)",
            "",
            "INSTANCES = (",
            "    {'id': 1,",
            "     'uuid': 'b65cee2f-8c69-4aeb-be2f-f79742548fc2',",
            "     'name': 'fake',",
            "     'project_id': 'test',",
            "     'key_name': \"mykey\",",
            "     'key_data': \"ssh-rsa AAAAB3Nzai....N3NtHw== someuser@somehost\",",
            "     'host': 'test',",
            "     'launch_index': 1,",
            "     'instance_type': {'name': 'm1.tiny'},",
            "     'reservation_id': 'r-xxxxxxxx',",
            "     'user_data': ENCODE_USER_DATA_STRING,",
            "     'image_ref': 7,",
            "     'vcpus': 1,",
            "     'fixed_ips': [],",
            "     'root_device_name': '/dev/sda1',",
            "     'info_cache': {'network_info': []},",
            "     'hostname': 'test.novadomain',",
            "     'display_name': 'my_displayname',",
            "    },",
            ")",
            "",
            "",
            "def get_default_sys_meta():",
            "    return utils.dict_to_metadata(",
            "        instance_types.save_instance_type_info(",
            "            {}, instance_types.get_default_instance_type()))",
            "",
            "",
            "def return_non_existing_address(*args, **kwarg):",
            "    raise exception.NotFound()",
            "",
            "",
            "def fake_InstanceMetadata(stubs, inst_data, address=None,",
            "    sgroups=None, content=[], extra_md={}):",
            "",
            "    if sgroups is None:",
            "        sgroups = [{'name': 'default'}]",
            "",
            "    def sg_get(*args, **kwargs):",
            "        return sgroups",
            "",
            "    stubs.Set(api, 'security_group_get_by_instance', sg_get)",
            "    return base.InstanceMetadata(inst_data, address=address,",
            "        content=content, extra_md=extra_md)",
            "",
            "",
            "def fake_request(stubs, mdinst, relpath, address=\"127.0.0.1\",",
            "                 fake_get_metadata=None, headers=None,",
            "                 fake_get_metadata_by_instance_id=None):",
            "",
            "    def get_metadata_by_remote_address(address):",
            "        return mdinst",
            "",
            "    app = handler.MetadataRequestHandler()",
            "",
            "    if fake_get_metadata is None:",
            "        fake_get_metadata = get_metadata_by_remote_address",
            "",
            "    if stubs:",
            "        stubs.Set(app, 'get_metadata_by_remote_address', fake_get_metadata)",
            "",
            "        if fake_get_metadata_by_instance_id:",
            "            stubs.Set(app, 'get_metadata_by_instance_id',",
            "                      fake_get_metadata_by_instance_id)",
            "",
            "    request = webob.Request.blank(relpath)",
            "    request.remote_addr = address",
            "",
            "    if headers is not None:",
            "        request.headers.update(headers)",
            "",
            "    response = request.get_response(app)",
            "    return response",
            "",
            "",
            "class MetadataTestCase(test.TestCase):",
            "    def setUp(self):",
            "        super(MetadataTestCase, self).setUp()",
            "        self.instance = INSTANCES[0]",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "    def test_can_pickle_metadata(self):",
            "        # Make sure that InstanceMetadata is possible to pickle. This is",
            "        # required for memcache backend to work correctly.",
            "        md = fake_InstanceMetadata(self.stubs, copy.copy(self.instance))",
            "        pickle.dumps(md, protocol=0)",
            "",
            "    def test_user_data(self):",
            "        inst = copy.copy(self.instance)",
            "        inst['user_data'] = base64.b64encode(\"happy\")",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        self.assertEqual(",
            "            md.get_ec2_metadata(version='2009-04-04')['user-data'], \"happy\")",
            "",
            "    def test_no_user_data(self):",
            "        inst = copy.copy(self.instance)",
            "        del inst['user_data']",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        obj = object()",
            "        self.assertEqual(",
            "            md.get_ec2_metadata(version='2009-04-04').get('user-data', obj),",
            "            obj)",
            "",
            "    def test_security_groups(self):",
            "        inst = copy.copy(self.instance)",
            "        sgroups = [{'name': 'default'}, {'name': 'other'}]",
            "        expected = ['default', 'other']",
            "",
            "        md = fake_InstanceMetadata(self.stubs, inst, sgroups=sgroups)",
            "        data = md.get_ec2_metadata(version='2009-04-04')",
            "        self.assertEqual(data['meta-data']['security-groups'], expected)",
            "",
            "    def test_local_hostname_fqdn(self):",
            "        md = fake_InstanceMetadata(self.stubs, copy.copy(self.instance))",
            "        data = md.get_ec2_metadata(version='2009-04-04')",
            "        self.assertEqual(data['meta-data']['local-hostname'],",
            "            \"%s.%s\" % (self.instance['hostname'], CONF.dhcp_domain))",
            "",
            "    def test_format_instance_mapping(self):",
            "        # Make sure that _format_instance_mappings works.",
            "        ctxt = None",
            "        instance_ref0 = {'id': 0,",
            "                         'uuid': 'e5fe5518-0288-4fa3-b0c4-c79764101b85',",
            "                         'root_device_name': None}",
            "        instance_ref1 = {'id': 0,",
            "                         'uuid': 'b65cee2f-8c69-4aeb-be2f-f79742548fc2',",
            "                         'root_device_name': '/dev/sda1'}",
            "",
            "        def fake_bdm_get(ctxt, uuid):",
            "            return [{'volume_id': 87654321,",
            "                     'snapshot_id': None,",
            "                     'no_device': None,",
            "                     'virtual_name': None,",
            "                     'delete_on_termination': True,",
            "                     'device_name': '/dev/sdh'},",
            "                    {'volume_id': None,",
            "                     'snapshot_id': None,",
            "                     'no_device': None,",
            "                     'virtual_name': 'swap',",
            "                     'delete_on_termination': None,",
            "                     'device_name': '/dev/sdc'},",
            "                    {'volume_id': None,",
            "                     'snapshot_id': None,",
            "                     'no_device': None,",
            "                     'virtual_name': 'ephemeral0',",
            "                     'delete_on_termination': None,",
            "                     'device_name': '/dev/sdb'}]",
            "",
            "        self.stubs.Set(db, 'block_device_mapping_get_all_by_instance',",
            "                       fake_bdm_get)",
            "",
            "        expected = {'ami': 'sda1',",
            "                    'root': '/dev/sda1',",
            "                    'ephemeral0': '/dev/sdb',",
            "                    'swap': '/dev/sdc',",
            "                    'ebs0': '/dev/sdh'}",
            "",
            "        capi = conductor_api.LocalAPI()",
            "        self.assertEqual(base._format_instance_mapping(capi, ctxt,",
            "                         instance_ref0), block_device._DEFAULT_MAPPINGS)",
            "        self.assertEqual(base._format_instance_mapping(capi, ctxt,",
            "                         instance_ref1), expected)",
            "",
            "    def test_pubkey(self):",
            "        md = fake_InstanceMetadata(self.stubs, copy.copy(self.instance))",
            "        pubkey_ent = md.lookup(\"/2009-04-04/meta-data/public-keys\")",
            "",
            "        self.assertEqual(base.ec2_md_print(pubkey_ent),",
            "            \"0=%s\" % self.instance['key_name'])",
            "        self.assertEqual(base.ec2_md_print(pubkey_ent['0']['openssh-key']),",
            "            self.instance['key_data'])",
            "",
            "    def test_image_type_ramdisk(self):",
            "        inst = copy.copy(self.instance)",
            "        inst['ramdisk_id'] = 'ari-853667c0'",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        data = md.lookup(\"/latest/meta-data/ramdisk-id\")",
            "",
            "        self.assertTrue(data is not None)",
            "        self.assertTrue(re.match('ari-[0-9a-f]{8}', data))",
            "",
            "    def test_image_type_kernel(self):",
            "        inst = copy.copy(self.instance)",
            "        inst['kernel_id'] = 'aki-c2e26ff2'",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        data = md.lookup(\"/2009-04-04/meta-data/kernel-id\")",
            "",
            "        self.assertTrue(re.match('aki-[0-9a-f]{8}', data))",
            "",
            "        self.assertEqual(",
            "            md.lookup(\"/ec2/2009-04-04/meta-data/kernel-id\"), data)",
            "",
            "        del inst['kernel_id']",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        self.assertRaises(base.InvalidMetadataPath,",
            "            md.lookup, \"/2009-04-04/meta-data/kernel-id\")",
            "",
            "    def test_check_version(self):",
            "        inst = copy.copy(self.instance)",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        self.assertTrue(md._check_version('1.0', '2009-04-04'))",
            "        self.assertFalse(md._check_version('2009-04-04', '1.0'))",
            "",
            "        self.assertFalse(md._check_version('2009-04-04', '2008-09-01'))",
            "        self.assertTrue(md._check_version('2008-09-01', '2009-04-04'))",
            "",
            "        self.assertTrue(md._check_version('2009-04-04', '2009-04-04'))",
            "",
            "",
            "class OpenStackMetadataTestCase(test.TestCase):",
            "    def setUp(self):",
            "        super(OpenStackMetadataTestCase, self).setUp()",
            "        self.instance = INSTANCES[0]",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "    def test_top_level_listing(self):",
            "        # request for /openstack/<version>/ should show metadata.json",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        listing = mdinst.lookup(\"/openstack/\")",
            "",
            "        result = mdinst.lookup(\"/openstack\")",
            "",
            "        # trailing / should not affect anything",
            "        self.assertEqual(result, mdinst.lookup(\"/openstack\"))",
            "",
            "        # the 'content' should not show up in directory listing",
            "        self.assertTrue(base.CONTENT_DIR not in result)",
            "        self.assertTrue('2012-08-10' in result)",
            "        self.assertTrue('latest' in result)",
            "",
            "    def test_version_content_listing(self):",
            "        # request for /openstack/<version>/ should show metadata.json",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        listing = mdinst.lookup(\"/openstack/2012-08-10\")",
            "        self.assertTrue(\"meta_data.json\" in listing)",
            "",
            "    def test_metadata_json(self):",
            "        inst = copy.copy(self.instance)",
            "        content = [",
            "            ('/etc/my.conf', \"content of my.conf\"),",
            "            ('/root/hello', \"content of /root/hello\"),",
            "        ]",
            "",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst,",
            "            content=content)",
            "        mdjson = mdinst.lookup(\"/openstack/2012-08-10/meta_data.json\")",
            "        mdjson = mdinst.lookup(\"/openstack/latest/meta_data.json\")",
            "",
            "        mddict = json.loads(mdjson)",
            "",
            "        self.assertEqual(mddict['uuid'], self.instance['uuid'])",
            "        self.assertTrue('files' in mddict)",
            "",
            "        self.assertTrue('public_keys' in mddict)",
            "        self.assertEqual(mddict['public_keys'][self.instance['key_name']],",
            "            self.instance['key_data'])",
            "",
            "        self.assertTrue('launch_index' in mddict)",
            "        self.assertEqual(mddict['launch_index'], self.instance['launch_index'])",
            "",
            "        # verify that each of the things we put in content",
            "        # resulted in an entry in 'files', that their content",
            "        # there is as expected, and that /content lists them.",
            "        for (path, content) in content:",
            "            fent = [f for f in mddict['files'] if f['path'] == path]",
            "            self.assertTrue((len(fent) == 1))",
            "            fent = fent[0]",
            "            found = mdinst.lookup(\"/openstack%s\" % fent['content_path'])",
            "            self.assertEqual(found, content)",
            "",
            "    def test_extra_md(self):",
            "        # make sure extra_md makes it through to metadata",
            "        inst = copy.copy(self.instance)",
            "        extra = {'foo': 'bar', 'mylist': [1, 2, 3],",
            "                 'mydict': {\"one\": 1, \"two\": 2}}",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst, extra_md=extra)",
            "",
            "        mdjson = mdinst.lookup(\"/openstack/2012-08-10/meta_data.json\")",
            "        mddict = json.loads(mdjson)",
            "",
            "        for key, val in extra.iteritems():",
            "            self.assertEqual(mddict[key], val)",
            "",
            "    def test_password(self):",
            "        # make sure extra_md makes it through to metadata",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        result = mdinst.lookup(\"/openstack/latest/password\")",
            "        self.assertEqual(result, password.handle_password)",
            "",
            "    def test_userdata(self):",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        userdata_found = mdinst.lookup(\"/openstack/2012-08-10/user_data\")",
            "        self.assertEqual(USER_DATA_STRING, userdata_found)",
            "",
            "        # since we had user-data in this instance, it should be in listing",
            "        self.assertTrue('user_data' in mdinst.lookup(\"/openstack/2012-08-10\"))",
            "",
            "        del inst['user_data']",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        # since this instance had no user-data it should not be there.",
            "        self.assertFalse('user_data' in mdinst.lookup(\"/openstack/2012-08-10\"))",
            "",
            "        self.assertRaises(base.InvalidMetadataPath,",
            "            mdinst.lookup, \"/openstack/2012-08-10/user_data\")",
            "",
            "    def test_random_seed(self):",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        # verify that 2013-04-04 has the 'random' field",
            "        mdjson = mdinst.lookup(\"/openstack/2013-04-04/meta_data.json\")",
            "        mddict = json.loads(mdjson)",
            "",
            "        self.assertTrue(\"random_seed\" in mddict)",
            "        self.assertEqual(len(base64.b64decode(mddict[\"random_seed\"])), 512)",
            "",
            "        # verify that older version do not have it",
            "        mdjson = mdinst.lookup(\"/openstack/2012-08-10/meta_data.json\")",
            "        self.assertFalse(\"random_seed\" in json.loads(mdjson))",
            "",
            "    def test_no_dashes_in_metadata(self):",
            "        # top level entries in meta_data should not contain '-' in their name",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "        mdjson = json.loads(mdinst.lookup(\"/openstack/latest/meta_data.json\"))",
            "",
            "        self.assertEqual([], [k for k in mdjson.keys() if k.find(\"-\") != -1])",
            "",
            "",
            "class MetadataHandlerTestCase(test.TestCase):",
            "    \"\"\"Test that metadata is returning proper values.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(MetadataHandlerTestCase, self).setUp()",
            "",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "        self.instance = INSTANCES[0]",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        self.mdinst = fake_InstanceMetadata(self.stubs, self.instance,",
            "            address=None, sgroups=None)",
            "",
            "    def test_callable(self):",
            "",
            "        def verify(req, meta_data):",
            "            self.assertTrue(isinstance(meta_data, CallableMD))",
            "            return \"foo\"",
            "",
            "        class CallableMD(object):",
            "            def lookup(self, path_info):",
            "                return verify",
            "",
            "        response = fake_request(self.stubs, CallableMD(), \"/bar\")",
            "        self.assertEqual(response.status_int, 200)",
            "        self.assertEqual(response.body, \"foo\")",
            "",
            "    def test_root(self):",
            "        expected = \"\\n\".join(base.VERSIONS) + \"\\nlatest\"",
            "        response = fake_request(self.stubs, self.mdinst, \"/\")",
            "        self.assertEqual(response.body, expected)",
            "",
            "        response = fake_request(self.stubs, self.mdinst, \"/foo/../\")",
            "        self.assertEqual(response.body, expected)",
            "",
            "    def test_version_root(self):",
            "        response = fake_request(self.stubs, self.mdinst, \"/2009-04-04\")",
            "        self.assertEqual(response.body, 'meta-data/\\nuser-data')",
            "",
            "        response = fake_request(self.stubs, self.mdinst, \"/9999-99-99\")",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "    def test_user_data_non_existing_fixed_address(self):",
            "        self.stubs.Set(network_api.API, 'get_fixed_ip_by_address',",
            "                       return_non_existing_address)",
            "        response = fake_request(None, self.mdinst, \"/2009-04-04/user-data\",",
            "                                \"127.1.1.1\")",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "    def test_fixed_address_none(self):",
            "        response = fake_request(None, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data\", address=None)",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "    def test_invalid_path_is_404(self):",
            "        response = fake_request(self.stubs, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data-invalid\")",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "    def test_user_data_with_use_forwarded_header(self):",
            "        expected_addr = \"192.192.192.2\"",
            "",
            "        def fake_get_metadata(address):",
            "            if address == expected_addr:",
            "                return self.mdinst",
            "            else:",
            "                raise Exception(\"Expected addr of %s, got %s\" %",
            "                                (expected_addr, address))",
            "",
            "        self.flags(use_forwarded_for=True)",
            "        response = fake_request(self.stubs, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data\",",
            "                                address=\"168.168.168.1\",",
            "                                fake_get_metadata=fake_get_metadata,",
            "                                headers={'X-Forwarded-For': expected_addr})",
            "",
            "        self.assertEqual(response.status_int, 200)",
            "        self.assertEqual(response.body,",
            "                         base64.b64decode(self.instance['user_data']))",
            "",
            "        response = fake_request(self.stubs, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data\",",
            "                                address=\"168.168.168.1\",",
            "                                fake_get_metadata=fake_get_metadata,",
            "                                headers=None)",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "    def test_user_data_with_quantum_instance_id(self):",
            "        expected_instance_id = 'a-b-c-d'",
            "",
            "        def fake_get_metadata(instance_id, remote_address):",
            "            if remote_address is None:",
            "                raise Exception('Expected X-Forwared-For header')",
            "            elif instance_id == expected_instance_id:",
            "                return self.mdinst",
            "            else:",
            "                # raise the exception to aid with 500 response code test",
            "                raise Exception(\"Expected instance_id of %s, got %s\" %",
            "                                (expected_instance_id, instance_id))",
            "",
            "        signed = hmac.new(",
            "            CONF.quantum_metadata_proxy_shared_secret,",
            "            expected_instance_id,",
            "            hashlib.sha256).hexdigest()",
            "",
            "        # try a request with service disabled",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            headers={'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Instance-ID-Signature': signed})",
            "        self.assertEqual(response.status_int, 200)",
            "",
            "        # now enable the service",
            "        self.flags(service_quantum_metadata_proxy=True)",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Instance-ID-Signature': signed})",
            "",
            "        self.assertEqual(response.status_int, 200)",
            "        self.assertEqual(response.body,",
            "                         base64.b64decode(self.instance['user_data']))",
            "",
            "        # mismatched signature",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Instance-ID-Signature': ''})",
            "",
            "        self.assertEqual(response.status_int, 403)",
            "",
            "        # without X-Forwarded-For",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Instance-ID-Signature': signed})",
            "",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "        # unexpected Instance-ID",
            "        signed = hmac.new(",
            "            CONF.quantum_metadata_proxy_shared_secret,",
            "           'z-z-z-z',",
            "           hashlib.sha256).hexdigest()",
            "",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'z-z-z-z',",
            "                     'X-Instance-ID-Signature': signed})",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "",
            "class MetadataPasswordTestCase(test.TestCase):",
            "    def setUp(self):",
            "        super(MetadataPasswordTestCase, self).setUp()",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "        self.instance = copy.copy(INSTANCES[0])",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        self.mdinst = fake_InstanceMetadata(self.stubs, self.instance,",
            "            address=None, sgroups=None)",
            "        self.flags(use_local=True, group='conductor')",
            "",
            "    def test_get_password(self):",
            "        request = webob.Request.blank('')",
            "        self.mdinst.password = 'foo'",
            "        result = password.handle_password(request, self.mdinst)",
            "        self.assertEqual(result, 'foo')",
            "",
            "    def test_bad_method(self):",
            "        request = webob.Request.blank('')",
            "        request.method = 'PUT'",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          password.handle_password, request, self.mdinst)",
            "",
            "    def _try_set_password(self, val='bar'):",
            "        request = webob.Request.blank('')",
            "        request.method = 'POST'",
            "        request.body = val",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       lambda *a, **kw: {'system_metadata': []})",
            "",
            "        def fake_instance_update(context, uuid, updates):",
            "            self.assertIn('system_metadata', updates)",
            "            self.assertIn('password_0', updates['system_metadata'])",
            "            return self.instance, self.instance",
            "",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       fake_instance_update)",
            "        password.handle_password(request, self.mdinst)",
            "",
            "    def test_set_password(self):",
            "        self.mdinst.password = ''",
            "        self._try_set_password()",
            "",
            "    def test_conflict(self):",
            "        self.mdinst.password = 'foo'",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "                          self._try_set_password)",
            "",
            "    def test_too_large(self):",
            "        self.mdinst.password = ''",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._try_set_password,",
            "                          'a' * (password.MAX_SIZE + 1))"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Tests for metadata service.\"\"\"",
            "",
            "import base64",
            "import copy",
            "import hashlib",
            "import hmac",
            "import json",
            "import re",
            "",
            "try:",
            "    import cPickle as pickle",
            "except ImportError:",
            "    import pickle",
            "",
            "from oslo.config import cfg",
            "import webob",
            "",
            "from nova.api.metadata import base",
            "from nova.api.metadata import handler",
            "from nova.api.metadata import password",
            "from nova import block_device",
            "from nova.compute import instance_types",
            "from nova.conductor import api as conductor_api",
            "from nova import db",
            "from nova.db.sqlalchemy import api",
            "from nova import exception",
            "from nova.network import api as network_api",
            "from nova import test",
            "from nova.tests import fake_network",
            "from nova import utils",
            "",
            "CONF = cfg.CONF",
            "",
            "USER_DATA_STRING = (\"This is an encoded string\")",
            "ENCODE_USER_DATA_STRING = base64.b64encode(USER_DATA_STRING)",
            "",
            "INSTANCES = (",
            "    {'id': 1,",
            "     'uuid': 'b65cee2f-8c69-4aeb-be2f-f79742548fc2',",
            "     'name': 'fake',",
            "     'project_id': 'test',",
            "     'key_name': \"mykey\",",
            "     'key_data': \"ssh-rsa AAAAB3Nzai....N3NtHw== someuser@somehost\",",
            "     'host': 'test',",
            "     'launch_index': 1,",
            "     'instance_type': {'name': 'm1.tiny'},",
            "     'reservation_id': 'r-xxxxxxxx',",
            "     'user_data': ENCODE_USER_DATA_STRING,",
            "     'image_ref': 7,",
            "     'vcpus': 1,",
            "     'fixed_ips': [],",
            "     'root_device_name': '/dev/sda1',",
            "     'info_cache': {'network_info': []},",
            "     'hostname': 'test.novadomain',",
            "     'display_name': 'my_displayname',",
            "    },",
            ")",
            "",
            "",
            "def get_default_sys_meta():",
            "    return utils.dict_to_metadata(",
            "        instance_types.save_instance_type_info(",
            "            {}, instance_types.get_default_instance_type()))",
            "",
            "",
            "def return_non_existing_address(*args, **kwarg):",
            "    raise exception.NotFound()",
            "",
            "",
            "def fake_InstanceMetadata(stubs, inst_data, address=None,",
            "    sgroups=None, content=[], extra_md={}):",
            "",
            "    if sgroups is None:",
            "        sgroups = [{'name': 'default'}]",
            "",
            "    def sg_get(*args, **kwargs):",
            "        return sgroups",
            "",
            "    stubs.Set(api, 'security_group_get_by_instance', sg_get)",
            "    return base.InstanceMetadata(inst_data, address=address,",
            "        content=content, extra_md=extra_md)",
            "",
            "",
            "def fake_request(stubs, mdinst, relpath, address=\"127.0.0.1\",",
            "                 fake_get_metadata=None, headers=None,",
            "                 fake_get_metadata_by_instance_id=None):",
            "",
            "    def get_metadata_by_remote_address(address):",
            "        return mdinst",
            "",
            "    app = handler.MetadataRequestHandler()",
            "",
            "    if fake_get_metadata is None:",
            "        fake_get_metadata = get_metadata_by_remote_address",
            "",
            "    if stubs:",
            "        stubs.Set(app, 'get_metadata_by_remote_address', fake_get_metadata)",
            "",
            "        if fake_get_metadata_by_instance_id:",
            "            stubs.Set(app, 'get_metadata_by_instance_id',",
            "                      fake_get_metadata_by_instance_id)",
            "",
            "    request = webob.Request.blank(relpath)",
            "    request.remote_addr = address",
            "",
            "    if headers is not None:",
            "        request.headers.update(headers)",
            "",
            "    response = request.get_response(app)",
            "    return response",
            "",
            "",
            "class MetadataTestCase(test.TestCase):",
            "    def setUp(self):",
            "        super(MetadataTestCase, self).setUp()",
            "        self.instance = INSTANCES[0]",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "    def test_can_pickle_metadata(self):",
            "        # Make sure that InstanceMetadata is possible to pickle. This is",
            "        # required for memcache backend to work correctly.",
            "        md = fake_InstanceMetadata(self.stubs, copy.copy(self.instance))",
            "        pickle.dumps(md, protocol=0)",
            "",
            "    def test_user_data(self):",
            "        inst = copy.copy(self.instance)",
            "        inst['user_data'] = base64.b64encode(\"happy\")",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        self.assertEqual(",
            "            md.get_ec2_metadata(version='2009-04-04')['user-data'], \"happy\")",
            "",
            "    def test_no_user_data(self):",
            "        inst = copy.copy(self.instance)",
            "        del inst['user_data']",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        obj = object()",
            "        self.assertEqual(",
            "            md.get_ec2_metadata(version='2009-04-04').get('user-data', obj),",
            "            obj)",
            "",
            "    def test_security_groups(self):",
            "        inst = copy.copy(self.instance)",
            "        sgroups = [{'name': 'default'}, {'name': 'other'}]",
            "        expected = ['default', 'other']",
            "",
            "        md = fake_InstanceMetadata(self.stubs, inst, sgroups=sgroups)",
            "        data = md.get_ec2_metadata(version='2009-04-04')",
            "        self.assertEqual(data['meta-data']['security-groups'], expected)",
            "",
            "    def test_local_hostname_fqdn(self):",
            "        md = fake_InstanceMetadata(self.stubs, copy.copy(self.instance))",
            "        data = md.get_ec2_metadata(version='2009-04-04')",
            "        self.assertEqual(data['meta-data']['local-hostname'],",
            "            \"%s.%s\" % (self.instance['hostname'], CONF.dhcp_domain))",
            "",
            "    def test_format_instance_mapping(self):",
            "        # Make sure that _format_instance_mappings works.",
            "        ctxt = None",
            "        instance_ref0 = {'id': 0,",
            "                         'uuid': 'e5fe5518-0288-4fa3-b0c4-c79764101b85',",
            "                         'root_device_name': None}",
            "        instance_ref1 = {'id': 0,",
            "                         'uuid': 'b65cee2f-8c69-4aeb-be2f-f79742548fc2',",
            "                         'root_device_name': '/dev/sda1'}",
            "",
            "        def fake_bdm_get(ctxt, uuid):",
            "            return [{'volume_id': 87654321,",
            "                     'snapshot_id': None,",
            "                     'no_device': None,",
            "                     'virtual_name': None,",
            "                     'delete_on_termination': True,",
            "                     'device_name': '/dev/sdh'},",
            "                    {'volume_id': None,",
            "                     'snapshot_id': None,",
            "                     'no_device': None,",
            "                     'virtual_name': 'swap',",
            "                     'delete_on_termination': None,",
            "                     'device_name': '/dev/sdc'},",
            "                    {'volume_id': None,",
            "                     'snapshot_id': None,",
            "                     'no_device': None,",
            "                     'virtual_name': 'ephemeral0',",
            "                     'delete_on_termination': None,",
            "                     'device_name': '/dev/sdb'}]",
            "",
            "        self.stubs.Set(db, 'block_device_mapping_get_all_by_instance',",
            "                       fake_bdm_get)",
            "",
            "        expected = {'ami': 'sda1',",
            "                    'root': '/dev/sda1',",
            "                    'ephemeral0': '/dev/sdb',",
            "                    'swap': '/dev/sdc',",
            "                    'ebs0': '/dev/sdh'}",
            "",
            "        capi = conductor_api.LocalAPI()",
            "        self.assertEqual(base._format_instance_mapping(capi, ctxt,",
            "                         instance_ref0), block_device._DEFAULT_MAPPINGS)",
            "        self.assertEqual(base._format_instance_mapping(capi, ctxt,",
            "                         instance_ref1), expected)",
            "",
            "    def test_pubkey(self):",
            "        md = fake_InstanceMetadata(self.stubs, copy.copy(self.instance))",
            "        pubkey_ent = md.lookup(\"/2009-04-04/meta-data/public-keys\")",
            "",
            "        self.assertEqual(base.ec2_md_print(pubkey_ent),",
            "            \"0=%s\" % self.instance['key_name'])",
            "        self.assertEqual(base.ec2_md_print(pubkey_ent['0']['openssh-key']),",
            "            self.instance['key_data'])",
            "",
            "    def test_image_type_ramdisk(self):",
            "        inst = copy.copy(self.instance)",
            "        inst['ramdisk_id'] = 'ari-853667c0'",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        data = md.lookup(\"/latest/meta-data/ramdisk-id\")",
            "",
            "        self.assertTrue(data is not None)",
            "        self.assertTrue(re.match('ari-[0-9a-f]{8}', data))",
            "",
            "    def test_image_type_kernel(self):",
            "        inst = copy.copy(self.instance)",
            "        inst['kernel_id'] = 'aki-c2e26ff2'",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        data = md.lookup(\"/2009-04-04/meta-data/kernel-id\")",
            "",
            "        self.assertTrue(re.match('aki-[0-9a-f]{8}', data))",
            "",
            "        self.assertEqual(",
            "            md.lookup(\"/ec2/2009-04-04/meta-data/kernel-id\"), data)",
            "",
            "        del inst['kernel_id']",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "        self.assertRaises(base.InvalidMetadataPath,",
            "            md.lookup, \"/2009-04-04/meta-data/kernel-id\")",
            "",
            "    def test_check_version(self):",
            "        inst = copy.copy(self.instance)",
            "        md = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        self.assertTrue(md._check_version('1.0', '2009-04-04'))",
            "        self.assertFalse(md._check_version('2009-04-04', '1.0'))",
            "",
            "        self.assertFalse(md._check_version('2009-04-04', '2008-09-01'))",
            "        self.assertTrue(md._check_version('2008-09-01', '2009-04-04'))",
            "",
            "        self.assertTrue(md._check_version('2009-04-04', '2009-04-04'))",
            "",
            "",
            "class OpenStackMetadataTestCase(test.TestCase):",
            "    def setUp(self):",
            "        super(OpenStackMetadataTestCase, self).setUp()",
            "        self.instance = INSTANCES[0]",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "    def test_top_level_listing(self):",
            "        # request for /openstack/<version>/ should show metadata.json",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        listing = mdinst.lookup(\"/openstack/\")",
            "",
            "        result = mdinst.lookup(\"/openstack\")",
            "",
            "        # trailing / should not affect anything",
            "        self.assertEqual(result, mdinst.lookup(\"/openstack\"))",
            "",
            "        # the 'content' should not show up in directory listing",
            "        self.assertTrue(base.CONTENT_DIR not in result)",
            "        self.assertTrue('2012-08-10' in result)",
            "        self.assertTrue('latest' in result)",
            "",
            "    def test_version_content_listing(self):",
            "        # request for /openstack/<version>/ should show metadata.json",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        listing = mdinst.lookup(\"/openstack/2012-08-10\")",
            "        self.assertTrue(\"meta_data.json\" in listing)",
            "",
            "    def test_metadata_json(self):",
            "        inst = copy.copy(self.instance)",
            "        content = [",
            "            ('/etc/my.conf', \"content of my.conf\"),",
            "            ('/root/hello', \"content of /root/hello\"),",
            "        ]",
            "",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst,",
            "            content=content)",
            "        mdjson = mdinst.lookup(\"/openstack/2012-08-10/meta_data.json\")",
            "        mdjson = mdinst.lookup(\"/openstack/latest/meta_data.json\")",
            "",
            "        mddict = json.loads(mdjson)",
            "",
            "        self.assertEqual(mddict['uuid'], self.instance['uuid'])",
            "        self.assertTrue('files' in mddict)",
            "",
            "        self.assertTrue('public_keys' in mddict)",
            "        self.assertEqual(mddict['public_keys'][self.instance['key_name']],",
            "            self.instance['key_data'])",
            "",
            "        self.assertTrue('launch_index' in mddict)",
            "        self.assertEqual(mddict['launch_index'], self.instance['launch_index'])",
            "",
            "        # verify that each of the things we put in content",
            "        # resulted in an entry in 'files', that their content",
            "        # there is as expected, and that /content lists them.",
            "        for (path, content) in content:",
            "            fent = [f for f in mddict['files'] if f['path'] == path]",
            "            self.assertTrue((len(fent) == 1))",
            "            fent = fent[0]",
            "            found = mdinst.lookup(\"/openstack%s\" % fent['content_path'])",
            "            self.assertEqual(found, content)",
            "",
            "    def test_extra_md(self):",
            "        # make sure extra_md makes it through to metadata",
            "        inst = copy.copy(self.instance)",
            "        extra = {'foo': 'bar', 'mylist': [1, 2, 3],",
            "                 'mydict': {\"one\": 1, \"two\": 2}}",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst, extra_md=extra)",
            "",
            "        mdjson = mdinst.lookup(\"/openstack/2012-08-10/meta_data.json\")",
            "        mddict = json.loads(mdjson)",
            "",
            "        for key, val in extra.iteritems():",
            "            self.assertEqual(mddict[key], val)",
            "",
            "    def test_password(self):",
            "        # make sure extra_md makes it through to metadata",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        result = mdinst.lookup(\"/openstack/latest/password\")",
            "        self.assertEqual(result, password.handle_password)",
            "",
            "    def test_userdata(self):",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        userdata_found = mdinst.lookup(\"/openstack/2012-08-10/user_data\")",
            "        self.assertEqual(USER_DATA_STRING, userdata_found)",
            "",
            "        # since we had user-data in this instance, it should be in listing",
            "        self.assertTrue('user_data' in mdinst.lookup(\"/openstack/2012-08-10\"))",
            "",
            "        del inst['user_data']",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        # since this instance had no user-data it should not be there.",
            "        self.assertFalse('user_data' in mdinst.lookup(\"/openstack/2012-08-10\"))",
            "",
            "        self.assertRaises(base.InvalidMetadataPath,",
            "            mdinst.lookup, \"/openstack/2012-08-10/user_data\")",
            "",
            "    def test_random_seed(self):",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "",
            "        # verify that 2013-04-04 has the 'random' field",
            "        mdjson = mdinst.lookup(\"/openstack/2013-04-04/meta_data.json\")",
            "        mddict = json.loads(mdjson)",
            "",
            "        self.assertTrue(\"random_seed\" in mddict)",
            "        self.assertEqual(len(base64.b64decode(mddict[\"random_seed\"])), 512)",
            "",
            "        # verify that older version do not have it",
            "        mdjson = mdinst.lookup(\"/openstack/2012-08-10/meta_data.json\")",
            "        self.assertFalse(\"random_seed\" in json.loads(mdjson))",
            "",
            "    def test_no_dashes_in_metadata(self):",
            "        # top level entries in meta_data should not contain '-' in their name",
            "        inst = copy.copy(self.instance)",
            "        mdinst = fake_InstanceMetadata(self.stubs, inst)",
            "        mdjson = json.loads(mdinst.lookup(\"/openstack/latest/meta_data.json\"))",
            "",
            "        self.assertEqual([], [k for k in mdjson.keys() if k.find(\"-\") != -1])",
            "",
            "",
            "class MetadataHandlerTestCase(test.TestCase):",
            "    \"\"\"Test that metadata is returning proper values.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(MetadataHandlerTestCase, self).setUp()",
            "",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "        self.instance = INSTANCES[0]",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        self.mdinst = fake_InstanceMetadata(self.stubs, self.instance,",
            "            address=None, sgroups=None)",
            "",
            "    def test_callable(self):",
            "",
            "        def verify(req, meta_data):",
            "            self.assertTrue(isinstance(meta_data, CallableMD))",
            "            return \"foo\"",
            "",
            "        class CallableMD(object):",
            "            def lookup(self, path_info):",
            "                return verify",
            "",
            "        response = fake_request(self.stubs, CallableMD(), \"/bar\")",
            "        self.assertEqual(response.status_int, 200)",
            "        self.assertEqual(response.body, \"foo\")",
            "",
            "    def test_root(self):",
            "        expected = \"\\n\".join(base.VERSIONS) + \"\\nlatest\"",
            "        response = fake_request(self.stubs, self.mdinst, \"/\")",
            "        self.assertEqual(response.body, expected)",
            "",
            "        response = fake_request(self.stubs, self.mdinst, \"/foo/../\")",
            "        self.assertEqual(response.body, expected)",
            "",
            "    def test_version_root(self):",
            "        response = fake_request(self.stubs, self.mdinst, \"/2009-04-04\")",
            "        self.assertEqual(response.body, 'meta-data/\\nuser-data')",
            "",
            "        response = fake_request(self.stubs, self.mdinst, \"/9999-99-99\")",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "    def test_user_data_non_existing_fixed_address(self):",
            "        self.stubs.Set(network_api.API, 'get_fixed_ip_by_address',",
            "                       return_non_existing_address)",
            "        response = fake_request(None, self.mdinst, \"/2009-04-04/user-data\",",
            "                                \"127.1.1.1\")",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "    def test_fixed_address_none(self):",
            "        response = fake_request(None, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data\", address=None)",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "    def test_invalid_path_is_404(self):",
            "        response = fake_request(self.stubs, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data-invalid\")",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "    def test_user_data_with_use_forwarded_header(self):",
            "        expected_addr = \"192.192.192.2\"",
            "",
            "        def fake_get_metadata(address):",
            "            if address == expected_addr:",
            "                return self.mdinst",
            "            else:",
            "                raise Exception(\"Expected addr of %s, got %s\" %",
            "                                (expected_addr, address))",
            "",
            "        self.flags(use_forwarded_for=True)",
            "        response = fake_request(self.stubs, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data\",",
            "                                address=\"168.168.168.1\",",
            "                                fake_get_metadata=fake_get_metadata,",
            "                                headers={'X-Forwarded-For': expected_addr})",
            "",
            "        self.assertEqual(response.status_int, 200)",
            "        self.assertEqual(response.body,",
            "                         base64.b64decode(self.instance['user_data']))",
            "",
            "        response = fake_request(self.stubs, self.mdinst,",
            "                                relpath=\"/2009-04-04/user-data\",",
            "                                address=\"168.168.168.1\",",
            "                                fake_get_metadata=fake_get_metadata,",
            "                                headers=None)",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "    def test_user_data_with_quantum_instance_id(self):",
            "        expected_instance_id = 'a-b-c-d'",
            "",
            "        def fake_get_metadata(instance_id, remote_address):",
            "            if remote_address is None:",
            "                raise Exception('Expected X-Forwared-For header')",
            "            elif instance_id == expected_instance_id:",
            "                return self.mdinst",
            "            else:",
            "                # raise the exception to aid with 500 response code test",
            "                raise Exception(\"Expected instance_id of %s, got %s\" %",
            "                                (expected_instance_id, instance_id))",
            "",
            "        signed = hmac.new(",
            "            CONF.quantum_metadata_proxy_shared_secret,",
            "            expected_instance_id,",
            "            hashlib.sha256).hexdigest()",
            "",
            "        # try a request with service disabled",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            headers={'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Tenant-ID': 'test',",
            "                     'X-Instance-ID-Signature': signed})",
            "        self.assertEqual(response.status_int, 200)",
            "",
            "        # now enable the service",
            "        self.flags(service_quantum_metadata_proxy=True)",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Tenant-ID': 'test',",
            "                     'X-Instance-ID-Signature': signed})",
            "",
            "        self.assertEqual(response.status_int, 200)",
            "        self.assertEqual(response.body,",
            "                         base64.b64decode(self.instance['user_data']))",
            "",
            "        # mismatched signature",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Tenant-ID': 'test',",
            "                     'X-Instance-ID-Signature': ''})",
            "",
            "        self.assertEqual(response.status_int, 403)",
            "",
            "        # missing X-Tenant-ID from request",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Instance-ID-Signature': signed})",
            "",
            "        self.assertEqual(response.status_int, 400)",
            "",
            "        # mismatched X-Tenant-ID",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Tenant-ID': 'FAKE',",
            "                     'X-Instance-ID-Signature': signed})",
            "",
            "        self.assertEqual(response.status_int, 404)",
            "",
            "        # without X-Forwarded-For",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Instance-ID': 'a-b-c-d',",
            "                     'X-Tenant-ID': 'test',",
            "                     'X-Instance-ID-Signature': signed})",
            "",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "        # unexpected Instance-ID",
            "        signed = hmac.new(",
            "            CONF.quantum_metadata_proxy_shared_secret,",
            "           'z-z-z-z',",
            "           hashlib.sha256).hexdigest()",
            "",
            "        response = fake_request(",
            "            self.stubs, self.mdinst,",
            "            relpath=\"/2009-04-04/user-data\",",
            "            address=\"192.192.192.2\",",
            "            fake_get_metadata_by_instance_id=fake_get_metadata,",
            "            headers={'X-Forwarded-For': '192.192.192.2',",
            "                     'X-Instance-ID': 'z-z-z-z',",
            "                     'X-Tenant-ID': 'test',",
            "                     'X-Instance-ID-Signature': signed})",
            "        self.assertEqual(response.status_int, 500)",
            "",
            "",
            "class MetadataPasswordTestCase(test.TestCase):",
            "    def setUp(self):",
            "        super(MetadataPasswordTestCase, self).setUp()",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "        self.instance = copy.copy(INSTANCES[0])",
            "        self.instance['system_metadata'] = get_default_sys_meta()",
            "        self.flags(use_local=True, group='conductor')",
            "        self.mdinst = fake_InstanceMetadata(self.stubs, self.instance,",
            "            address=None, sgroups=None)",
            "        self.flags(use_local=True, group='conductor')",
            "",
            "    def test_get_password(self):",
            "        request = webob.Request.blank('')",
            "        self.mdinst.password = 'foo'",
            "        result = password.handle_password(request, self.mdinst)",
            "        self.assertEqual(result, 'foo')",
            "",
            "    def test_bad_method(self):",
            "        request = webob.Request.blank('')",
            "        request.method = 'PUT'",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          password.handle_password, request, self.mdinst)",
            "",
            "    def _try_set_password(self, val='bar'):",
            "        request = webob.Request.blank('')",
            "        request.method = 'POST'",
            "        request.body = val",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       lambda *a, **kw: {'system_metadata': []})",
            "",
            "        def fake_instance_update(context, uuid, updates):",
            "            self.assertIn('system_metadata', updates)",
            "            self.assertIn('password_0', updates['system_metadata'])",
            "            return self.instance, self.instance",
            "",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       fake_instance_update)",
            "        password.handle_password(request, self.mdinst)",
            "",
            "    def test_set_password(self):",
            "        self.mdinst.password = ''",
            "        self._try_set_password()",
            "",
            "    def test_conflict(self):",
            "        self.mdinst.password = 'foo'",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "                          self._try_set_password)",
            "",
            "    def test_too_large(self):",
            "        self.mdinst.password = ''",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._try_set_password,",
            "                          'a' * (password.MAX_SIZE + 1))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.test_metadata.fake_request.headers"
        ]
    }
}