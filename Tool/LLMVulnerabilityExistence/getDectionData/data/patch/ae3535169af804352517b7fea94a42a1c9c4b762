{
    "django/contrib/auth/tests/test_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "         for bad_url in ('http://example.com',"
            },
            "1": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "                         'https://example.com',"
            },
            "2": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "                         'ftp://exampel.com',"
            },
            "3": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '//example.com'):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+                        '//example.com',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+                        'javascript:alert(\"XSS\")'):"
            },
            "6": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 451,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {"
            },
            "8": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "                 'url': login_url,"
            },
            "9": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "                          '/view?param=ftp://exampel.com',"
            },
            "10": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "                          'view/?param=//example.com',"
            },
            "11": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "                          'https:///',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+                         'HTTPS:///',"
            },
            "13": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "                          '//testserver/',"
            },
            "14": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 473,
                "PatchRowcode": "                          '/url%20with%20spaces/'):  # see ticket #12534"
            },
            "15": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 474,
                "PatchRowcode": "             safe_url = '%(url)s?%(next)s=%(good_url)s' % {"
            },
            "16": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": 663,
                "PatchRowcode": "         for bad_url in ('http://example.com',"
            },
            "17": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": 664,
                "PatchRowcode": "                         'https://example.com',"
            },
            "18": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": 665,
                "PatchRowcode": "                         'ftp://exampel.com',"
            },
            "19": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '//example.com'):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 666,
                "PatchRowcode": "+                        '//example.com',"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 667,
                "PatchRowcode": "+                        'javascript:alert(\"XSS\")'):"
            },
            "22": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 668,
                "PatchRowcode": "             nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {"
            },
            "23": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": 669,
                "PatchRowcode": "                 'url': logout_url,"
            },
            "24": {
                "beforePatchRowNumber": 667,
                "afterPatchRowNumber": 670,
                "PatchRowcode": "                 'next': REDIRECT_FIELD_NAME,"
            },
            "25": {
                "beforePatchRowNumber": 680,
                "afterPatchRowNumber": 683,
                "PatchRowcode": "                          '/view?param=ftp://exampel.com',"
            },
            "26": {
                "beforePatchRowNumber": 681,
                "afterPatchRowNumber": 684,
                "PatchRowcode": "                          'view/?param=//example.com',"
            },
            "27": {
                "beforePatchRowNumber": 682,
                "afterPatchRowNumber": 685,
                "PatchRowcode": "                          'https:///',"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 686,
                "PatchRowcode": "+                         'HTTPS:///',"
            },
            "29": {
                "beforePatchRowNumber": 683,
                "afterPatchRowNumber": 687,
                "PatchRowcode": "                          '//testserver/',"
            },
            "30": {
                "beforePatchRowNumber": 684,
                "afterPatchRowNumber": 688,
                "PatchRowcode": "                          '/url%20with%20spaces/'):  # see ticket #12534"
            },
            "31": {
                "beforePatchRowNumber": 685,
                "afterPatchRowNumber": 689,
                "PatchRowcode": "             safe_url = '%(url)s?%(next)s=%(good_url)s' % {"
            }
        },
        "frontPatchFile": [
            "import itertools",
            "import os",
            "import re",
            "try:",
            "    from urllib.parse import urlparse, ParseResult",
            "except ImportError:     # Python 2",
            "    from urlparse import urlparse, ParseResult",
            "",
            "from django.conf import global_settings, settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.admin.models import LogEntry",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict, HttpRequest",
            "from django.utils.encoding import force_text",
            "from django.utils.http import urlquote",
            "from django.utils._os import upath",
            "from django.test import TestCase",
            "from django.test.utils import override_settings, patch_logger",
            "from django.middleware.csrf import CsrfViewMiddleware",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm)",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "from django.contrib.auth.views import login as login_view",
            "",
            "",
            "@override_settings(",
            "    LANGUAGES=(",
            "        ('en', 'English'),",
            "    ),",
            "    LANGUAGE_CODE='en',",
            "    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,",
            "    TEMPLATE_DIRS=(",
            "        os.path.join(os.path.dirname(upath(__file__)), 'templates'),",
            "    ),",
            "    USE_TZ=False,",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "        return response",
            "",
            "    def logout(self):",
            "        response = self.client.get('/admin/logout/')",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def assertFormError(self, response, error):",
            "        \"\"\"Assert that error is found in response.context['form'] errors\"\"\"",
            "        form_errors = list(itertools.chain(*response.context['form'].errors.values()))",
            "        self.assertIn(force_text(error), form_errors)",
            "",
            "    def assertURLEqual(self, url, expected, parse_qs=False):",
            "        \"\"\"",
            "        Given two URLs, make sure all their components (the ones given by",
            "        urlparse) are equal, only comparing components that are present in both",
            "        URLs.",
            "        If `parse_qs` is True, then the querystrings are parsed with QueryDict.",
            "        This is useful if you don't want the order of parameters to matter.",
            "        Otherwise, the query strings are compared as-is.",
            "        \"\"\"",
            "        fields = ParseResult._fields",
            "",
            "        for attr, x, y in zip(fields, urlparse(url), urlparse(expected)):",
            "            if parse_qs and attr == 'query':",
            "                x, y = QueryDict(x), QueryDict(y)",
            "            if x and y and x != y:",
            "                self.fail(\"%r != %r (%s doesn't match)\" % (url, expected, attr))",
            "",
            "",
            "@skipIfCustomUser",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb64': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "@skipIfCustomUser",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"\"\"If the provided email is not registered, don't raise any error but",
            "        also don't send any email.\"\"\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "        # optional multipart text/html email has been added.  Make sure original,",
            "        # default functionality is 100% the same",
            "        self.assertFalse(mail.outbox[0].message().is_multipart())",
            "",
            "    def test_html_mail_template(self):",
            "        \"\"\"",
            "        A multipart email with text/plain and text/html is sent",
            "        if the html_email_template parameter is passed to the view",
            "        \"\"\"",
            "        response = self.client.post('/password_reset/html_email_template/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        message = mail.outbox[0].message()",
            "        self.assertEqual(len(message.get_payload()), 2)",
            "        self.assertTrue(message.is_multipart())",
            "        self.assertEqual(message.get_payload(0).get_content_type(), 'text/plain')",
            "        self.assertEqual(message.get_payload(1).get_content_type(), 'text/html')",
            "        self.assertTrue('<html>' not in message.get_payload(0).get_payload())",
            "        self.assertTrue('<html>' in message.get_payload(1).get_payload())",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    @override_settings(ALLOWED_HOSTS=['adminsite.com'])",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with patch_logger('django.security.DisallowedHost', 'error') as logger_calls:",
            "            response = self.client.post('/password_reset/',",
            "                    {'email': 'staffmember@example.com'},",
            "                    HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "                )",
            "            self.assertEqual(response.status_code, 400)",
            "            self.assertEqual(len(mail.outbox), 0)",
            "            self.assertEqual(len(logger_calls), 1)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with patch_logger('django.security.DisallowedHost', 'error') as logger_calls:",
            "            response = self.client.post('/admin_password_reset/',",
            "                    {'email': 'staffmember@example.com'},",
            "                    HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "                )",
            "            self.assertEqual(response.status_code, 400)",
            "            self.assertEqual(len(mail.outbox), 0)",
            "            self.assertEqual(len(logger_calls), 1)",
            "",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456/1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz/1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertFormError(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_reset_redirect_default(self):",
            "        response = self.client.post('/password_reset/',",
            "            {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/done/')",
            "",
            "    def test_reset_custom_redirect(self):",
            "        response = self.client.post('/password_reset/custom_redirect/',",
            "            {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/custom/')",
            "",
            "    def test_reset_custom_redirect_named(self):",
            "        response = self.client.post('/password_reset/custom_redirect/named/',",
            "            {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "",
            "    def test_confirm_redirect_default(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/reset/done/')",
            "",
            "    def test_confirm_redirect_custom(self):",
            "        url, path = self._test_confirm_start()",
            "        path = path.replace('/reset/', '/reset/custom/')",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/custom/')",
            "",
            "    def test_confirm_redirect_custom_named(self):",
            "        url, path = self._test_confirm_start()",
            "        path = path.replace('/reset/', '/reset/custom/named/')",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "",
            "",
            "@override_settings(AUTH_USER_MODEL='auth.CustomUser')",
            "class CustomUserPasswordResetTest(AuthViewsTestCase):",
            "    fixtures = ['custom_user.json']",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid_custom_user(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "",
            "@skipIfCustomUser",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertFormError(response, AuthenticationForm.error_messages['invalid_login'] % {",
            "                'username': User._meta.get_field('username').verbose_name",
            "            })",
            "",
            "    def logout(self):",
            "        self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertFormError(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertFormError(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_change/done/')",
            "",
            "    @override_settings(LOGIN_URL='/login/')",
            "    def test_password_change_done_fails(self):",
            "        response = self.client.get('/password_change/done/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/login/?next=/password_change/done/')",
            "",
            "    def test_password_change_redirect_default(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_change/done/')",
            "",
            "    def test_password_change_redirect_custom(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/custom/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/custom/')",
            "",
            "    def test_password_change_redirect_custom_named(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/custom/named/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response.url,",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response.url,",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "    def test_login_form_contains_request(self):",
            "        # 15198",
            "        self.client.post('/custom_requestauth_login/', {",
            "            'username': 'testclient',",
            "            'password': 'password',",
            "        }, follow=True)",
            "        # the custom authentication form used by this login asserts",
            "        # that a request is passed to the form successfully.",
            "",
            "    def test_login_csrf_rotate(self, password='password'):",
            "        \"\"\"",
            "        Makes sure that a login rotates the currently-used CSRF token.",
            "        \"\"\"",
            "        # Do a GET to establish a CSRF token",
            "        # TestClient isn't used here as we're testing middleware, essentially.",
            "        req = HttpRequest()",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token1 = csrf_cookie.coded_value",
            "",
            "        # Prepare the POST request",
            "        req = HttpRequest()",
            "        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1",
            "        req.method = \"POST\"",
            "        req.POST = {'username': 'testclient', 'password': password, 'csrfmiddlewaretoken': token1}",
            "        req.REQUEST = req.POST",
            "",
            "        # Use POST request to log in",
            "        SessionMiddleware().process_request(req)",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"SERVER_NAME\"] = \"testserver\"  # Required to have redirect work in login view",
            "        req.META[\"SERVER_PORT\"] = 80",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token2 = csrf_cookie.coded_value",
            "",
            "        # Check the CSRF token switched",
            "        self.assertNotEqual(token1, token2)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginURLSettings(AuthViewsTestCase):",
            "    \"\"\"Tests for settings.LOGIN_URL.\"\"\"",
            "    def assertLoginURLEquals(self, url, parse_qs=False):",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, url, parse_qs=parse_qs)",
            "",
            "    @override_settings(LOGIN_URL='/login/')",
            "    def test_standard_login_url(self):",
            "        self.assertLoginURLEquals('/login/?next=/login_required/')",
            "",
            "    @override_settings(LOGIN_URL='login')",
            "    def test_named_login_url(self):",
            "        self.assertLoginURLEquals('/login/?next=/login_required/')",
            "",
            "    @override_settings(LOGIN_URL='http://remote.example.com/login')",
            "    def test_remote_login_url(self):",
            "        quoted_next = urlquote('http://testserver/login_required/')",
            "        expected = 'http://remote.example.com/login?next=%s' % quoted_next",
            "        self.assertLoginURLEquals(expected)",
            "",
            "    @override_settings(LOGIN_URL='https:///login/')",
            "    def test_https_login_url(self):",
            "        quoted_next = urlquote('http://testserver/login_required/')",
            "        expected = 'https:///login/?next=%s' % quoted_next",
            "        self.assertLoginURLEquals(expected)",
            "",
            "    @override_settings(LOGIN_URL='/login/?pretty=1')",
            "    def test_login_url_with_querystring(self):",
            "        self.assertLoginURLEquals('/login/?pretty=1&next=/login_required/', parse_qs=True)",
            "",
            "    @override_settings(LOGIN_URL='http://remote.example.com/login/?next=/default/')",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        quoted_next = urlquote('http://testserver/login_required/')",
            "        expected = 'http://remote.example.com/login/?next=%s' % quoted_next",
            "        self.assertLoginURLEquals(expected)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginRedirectUrlTest(AuthViewsTestCase):",
            "    \"\"\"Tests for settings.LOGIN_REDIRECT_URL.\"\"\"",
            "    def assertLoginRedirectURLEqual(self, url):",
            "        response = self.login()",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, url)",
            "",
            "    def test_default(self):",
            "        self.assertLoginRedirectURLEqual('/accounts/profile/')",
            "",
            "    @override_settings(LOGIN_REDIRECT_URL='/custom/')",
            "    def test_custom(self):",
            "        self.assertLoginRedirectURLEqual('/custom/')",
            "",
            "    @override_settings(LOGIN_REDIRECT_URL='password_reset')",
            "    def test_named(self):",
            "        self.assertLoginRedirectURLEqual('/password_reset/')",
            "",
            "    @override_settings(LOGIN_REDIRECT_URL='http://remote.example.com/welcome/')",
            "    def test_remote(self):",
            "        self.assertLoginRedirectURLEqual('http://remote.example.com/welcome/')",
            "",
            "",
            "@skipIfCustomUser",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertContains(response, 'Logged out')",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/somewhere/')",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/login/')",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/somewhere/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/login/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/somewhere/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_named_redirect(self):",
            "        \"Logout resolves names or URLs passed as next_page.\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/named/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response.url,",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response.url,",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()",
            "",
            "@skipIfCustomUser",
            "@override_settings(",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class ChangelistTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.tests.urls_admin'",
            "",
            "    def setUp(self):",
            "        # Make me a superuser before logging in.",
            "        User.objects.filter(username='testclient').update(is_staff=True, is_superuser=True)",
            "        self.login()",
            "        self.admin = User.objects.get(pk=1)",
            "",
            "    def get_user_data(self, user):",
            "        return {",
            "            'username': user.username,",
            "            'password': user.password,",
            "            'email': user.email,",
            "            'is_active': user.is_active,",
            "            'is_staff': user.is_staff,",
            "            'is_superuser': user.is_superuser,",
            "            'last_login_0': user.last_login.strftime('%Y-%m-%d'),",
            "            'last_login_1': user.last_login.strftime('%H:%M:%S'),",
            "            'initial-last_login_0': user.last_login.strftime('%Y-%m-%d'),",
            "            'initial-last_login_1': user.last_login.strftime('%H:%M:%S'),",
            "            'date_joined_0': user.date_joined.strftime('%Y-%m-%d'),",
            "            'date_joined_1': user.date_joined.strftime('%H:%M:%S'),",
            "            'initial-date_joined_0': user.date_joined.strftime('%Y-%m-%d'),",
            "            'initial-date_joined_1': user.date_joined.strftime('%H:%M:%S'),",
            "            'first_name': user.first_name,",
            "            'last_name': user.last_name,",
            "        }",
            "",
            "    # #20078 - users shouldn't be allowed to guess password hashes via",
            "    # repeated password__startswith queries.",
            "    def test_changelist_disallows_password_lookups(self):",
            "        # A lookup that tries to filter on password isn't OK",
            "        with patch_logger('django.security.DisallowedModelAdminLookup', 'error') as logger_calls:",
            "            response = self.client.get('/admin/auth/user/?password__startswith=sha1$')",
            "            self.assertEqual(response.status_code, 400)",
            "            self.assertEqual(len(logger_calls), 1)",
            "",
            "    def test_user_change_email(self):",
            "        data = self.get_user_data(self.admin)",
            "        data['email'] = 'new_' + data['email']",
            "        response = self.client.post('/admin/auth/user/%s/' % self.admin.pk, data)",
            "        self.assertRedirects(response, '/admin/auth/user/')",
            "        row = LogEntry.objects.latest('id')",
            "        self.assertEqual(row.change_message, 'Changed email.')",
            "",
            "    def test_user_not_change(self):",
            "        response = self.client.post('/admin/auth/user/%s/' % self.admin.pk,",
            "            self.get_user_data(self.admin)",
            "        )",
            "        self.assertRedirects(response, '/admin/auth/user/')",
            "        row = LogEntry.objects.latest('id')",
            "        self.assertEqual(row.change_message, 'No fields changed.')",
            "",
            "    def test_user_change_password(self):",
            "        response = self.client.post('/admin/auth/user/%s/password/' % self.admin.pk, {",
            "            'password1': 'password1',",
            "            'password2': 'password1',",
            "        })",
            "        self.assertRedirects(response, '/admin/auth/user/%s/' % self.admin.pk)",
            "        row = LogEntry.objects.latest('id')",
            "        self.assertEqual(row.change_message, 'Changed password.')",
            "        self.logout()",
            "        self.login(password='password1')"
        ],
        "afterPatchFile": [
            "import itertools",
            "import os",
            "import re",
            "try:",
            "    from urllib.parse import urlparse, ParseResult",
            "except ImportError:     # Python 2",
            "    from urlparse import urlparse, ParseResult",
            "",
            "from django.conf import global_settings, settings",
            "from django.contrib.sites.models import Site, RequestSite",
            "from django.contrib.admin.models import LogEntry",
            "from django.contrib.auth.models import User",
            "from django.core import mail",
            "from django.core.urlresolvers import reverse, NoReverseMatch",
            "from django.http import QueryDict, HttpRequest",
            "from django.utils.encoding import force_text",
            "from django.utils.http import urlquote",
            "from django.utils._os import upath",
            "from django.test import TestCase",
            "from django.test.utils import override_settings, patch_logger",
            "from django.middleware.csrf import CsrfViewMiddleware",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "",
            "from django.contrib.auth import SESSION_KEY, REDIRECT_FIELD_NAME",
            "from django.contrib.auth.forms import (AuthenticationForm, PasswordChangeForm,",
            "                SetPasswordForm)",
            "from django.contrib.auth.tests.utils import skipIfCustomUser",
            "from django.contrib.auth.views import login as login_view",
            "",
            "",
            "@override_settings(",
            "    LANGUAGES=(",
            "        ('en', 'English'),",
            "    ),",
            "    LANGUAGE_CODE='en',",
            "    TEMPLATE_LOADERS=global_settings.TEMPLATE_LOADERS,",
            "    TEMPLATE_DIRS=(",
            "        os.path.join(os.path.dirname(upath(__file__)), 'templates'),",
            "    ),",
            "    USE_TZ=False,",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class AuthViewsTestCase(TestCase):",
            "    \"\"\"",
            "    Helper base class for all the follow test cases.",
            "    \"\"\"",
            "    fixtures = ['authtestdata.json']",
            "    urls = 'django.contrib.auth.tests.urls'",
            "",
            "    def login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "            })",
            "        self.assertTrue(SESSION_KEY in self.client.session)",
            "        return response",
            "",
            "    def logout(self):",
            "        response = self.client.get('/admin/logout/')",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def assertFormError(self, response, error):",
            "        \"\"\"Assert that error is found in response.context['form'] errors\"\"\"",
            "        form_errors = list(itertools.chain(*response.context['form'].errors.values()))",
            "        self.assertIn(force_text(error), form_errors)",
            "",
            "    def assertURLEqual(self, url, expected, parse_qs=False):",
            "        \"\"\"",
            "        Given two URLs, make sure all their components (the ones given by",
            "        urlparse) are equal, only comparing components that are present in both",
            "        URLs.",
            "        If `parse_qs` is True, then the querystrings are parsed with QueryDict.",
            "        This is useful if you don't want the order of parameters to matter.",
            "        Otherwise, the query strings are compared as-is.",
            "        \"\"\"",
            "        fields = ParseResult._fields",
            "",
            "        for attr, x, y in zip(fields, urlparse(url), urlparse(expected)):",
            "            if parse_qs and attr == 'query':",
            "                x, y = QueryDict(x), QueryDict(y)",
            "            if x and y and x != y:",
            "                self.fail(\"%r != %r (%s doesn't match)\" % (url, expected, attr))",
            "",
            "",
            "@skipIfCustomUser",
            "class AuthViewNamedURLTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.urls'",
            "",
            "    def test_named_urls(self):",
            "        \"Named URLs should be reversible\"",
            "        expected_named_urls = [",
            "            ('login', [], {}),",
            "            ('logout', [], {}),",
            "            ('password_change', [], {}),",
            "            ('password_change_done', [], {}),",
            "            ('password_reset', [], {}),",
            "            ('password_reset_done', [], {}),",
            "            ('password_reset_confirm', [], {",
            "                'uidb64': 'aaaaaaa',",
            "                'token': '1111-aaaaa',",
            "            }),",
            "            ('password_reset_complete', [], {}),",
            "        ]",
            "        for name, args, kwargs in expected_named_urls:",
            "            try:",
            "                reverse(name, args=args, kwargs=kwargs)",
            "            except NoReverseMatch:",
            "                self.fail(\"Reversal of url named '%s' failed with NoReverseMatch\" % name)",
            "",
            "",
            "@skipIfCustomUser",
            "class PasswordResetTest(AuthViewsTestCase):",
            "",
            "    def test_email_not_found(self):",
            "        \"\"\"If the provided email is not registered, don't raise any error but",
            "        also don't send any email.\"\"\"",
            "        response = self.client.get('/password_reset/')",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.post('/password_reset/', {'email': 'not_a_real_email@email.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 0)",
            "",
            "    def test_email_found(self):",
            "        \"Email is sent if a valid email address is provided for password reset\"",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "        # optional multipart text/html email has been added.  Make sure original,",
            "        # default functionality is 100% the same",
            "        self.assertFalse(mail.outbox[0].message().is_multipart())",
            "",
            "    def test_html_mail_template(self):",
            "        \"\"\"",
            "        A multipart email with text/plain and text/html is sent",
            "        if the html_email_template parameter is passed to the view",
            "        \"\"\"",
            "        response = self.client.post('/password_reset/html_email_template/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        message = mail.outbox[0].message()",
            "        self.assertEqual(len(message.get_payload()), 2)",
            "        self.assertTrue(message.is_multipart())",
            "        self.assertEqual(message.get_payload(0).get_content_type(), 'text/plain')",
            "        self.assertEqual(message.get_payload(1).get_content_type(), 'text/html')",
            "        self.assertTrue('<html>' not in message.get_payload(0).get_payload())",
            "        self.assertTrue('<html>' in message.get_payload(1).get_payload())",
            "",
            "    def test_email_found_custom_from(self):",
            "        \"Email is sent if a valid email address is provided for password reset when a custom from_email is provided.\"",
            "        response = self.client.post('/password_reset_from_email/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertEqual(\"staffmember@example.com\", mail.outbox[0].from_email)",
            "",
            "    @override_settings(ALLOWED_HOSTS=['adminsite.com'])",
            "    def test_admin_reset(self):",
            "        \"If the reset view is marked as being for admin, the HTTP_HOST header is used for a domain override.\"",
            "        response = self.client.post('/admin_password_reset/',",
            "            {'email': 'staffmember@example.com'},",
            "            HTTP_HOST='adminsite.com'",
            "        )",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        self.assertTrue(\"http://adminsite.com\" in mail.outbox[0].body)",
            "        self.assertEqual(settings.DEFAULT_FROM_EMAIL, mail.outbox[0].from_email)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails\"",
            "        # This attack is based on the way browsers handle URLs. The colon",
            "        # should be used to separate the port, but if the URL contains an @,",
            "        # the colon is interpreted as part of a username for login purposes,",
            "        # making 'evil.com' the request domain. Since HTTP_HOST is used to",
            "        # produce a meaningful reset URL, we need to be certain that the",
            "        # HTTP_HOST header isn't poisoned. This is done as a check when get_host()",
            "        # is invoked, but we check here as a practical consequence.",
            "        with patch_logger('django.security.DisallowedHost', 'error') as logger_calls:",
            "            response = self.client.post('/password_reset/',",
            "                    {'email': 'staffmember@example.com'},",
            "                    HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "                )",
            "            self.assertEqual(response.status_code, 400)",
            "            self.assertEqual(len(mail.outbox), 0)",
            "            self.assertEqual(len(logger_calls), 1)",
            "",
            "    # Skip any 500 handler action (like sending more mail...)",
            "    @override_settings(DEBUG_PROPAGATE_EXCEPTIONS=True)",
            "    def test_poisoned_http_host_admin_site(self):",
            "        \"Poisoned HTTP_HOST headers can't be used for reset emails on admin views\"",
            "        with patch_logger('django.security.DisallowedHost', 'error') as logger_calls:",
            "            response = self.client.post('/admin_password_reset/',",
            "                    {'email': 'staffmember@example.com'},",
            "                    HTTP_HOST='www.example:dr.frankenstein@evil.tld'",
            "                )",
            "            self.assertEqual(response.status_code, 400)",
            "            self.assertEqual(len(mail.outbox), 0)",
            "            self.assertEqual(len(logger_calls), 1)",
            "",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "    def test_confirm_invalid(self):",
            "        url, path = self._test_confirm_start()",
            "        # Let's munge the token in the path, but keep the same length,",
            "        # in case the URLconf will reject a different length.",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_user(self):",
            "        # Ensure that we get a 200 response for a non-existant user, not a 404",
            "        response = self.client.get('/reset/123456/1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_overflow_user(self):",
            "        # Ensure that we get a 200 response for a base36 user id that overflows int",
            "        response = self.client.get('/reset/zzzzzzzzzzzzz/1-1/')",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_invalid_post(self):",
            "        # Same as test_confirm_invalid, but trying",
            "        # to do a POST instead.",
            "        url, path = self._test_confirm_start()",
            "        path = path[:-5] + (\"0\" * 4) + path[-1]",
            "",
            "        self.client.post(path, {",
            "            'new_password1': 'anewpassword',",
            "            'new_password2': ' anewpassword',",
            "        })",
            "        # Check the password has not been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(not u.check_password(\"anewpassword\"))",
            "",
            "    def test_confirm_complete(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        # Check the password has been changed",
            "        u = User.objects.get(email='staffmember@example.com')",
            "        self.assertTrue(u.check_password(\"anewpassword\"))",
            "",
            "        # Check we can't use the link again",
            "        response = self.client.get(path)",
            "        self.assertContains(response, \"The password reset link was invalid\")",
            "",
            "    def test_confirm_different_passwords(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'x'})",
            "        self.assertFormError(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_reset_redirect_default(self):",
            "        response = self.client.post('/password_reset/',",
            "            {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/done/')",
            "",
            "    def test_reset_custom_redirect(self):",
            "        response = self.client.post('/password_reset/custom_redirect/',",
            "            {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/custom/')",
            "",
            "    def test_reset_custom_redirect_named(self):",
            "        response = self.client.post('/password_reset/custom_redirect/named/',",
            "            {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "",
            "    def test_confirm_redirect_default(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/reset/done/')",
            "",
            "    def test_confirm_redirect_custom(self):",
            "        url, path = self._test_confirm_start()",
            "        path = path.replace('/reset/', '/reset/custom/')",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/custom/')",
            "",
            "    def test_confirm_redirect_custom_named(self):",
            "        url, path = self._test_confirm_start()",
            "        path = path.replace('/reset/', '/reset/custom/named/')",
            "        response = self.client.post(path, {'new_password1': 'anewpassword',",
            "                                           'new_password2': 'anewpassword'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "",
            "",
            "@override_settings(AUTH_USER_MODEL='auth.CustomUser')",
            "class CustomUserPasswordResetTest(AuthViewsTestCase):",
            "    fixtures = ['custom_user.json']",
            "",
            "    def _test_confirm_start(self):",
            "        # Start by creating the email",
            "        response = self.client.post('/password_reset/', {'email': 'staffmember@example.com'})",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertEqual(len(mail.outbox), 1)",
            "        return self._read_signup_email(mail.outbox[0])",
            "",
            "    def _read_signup_email(self, email):",
            "        urlmatch = re.search(r\"https?://[^/]*(/.*reset/\\S*)\", email.body)",
            "        self.assertTrue(urlmatch is not None, \"No URL found in sent email\")",
            "        return urlmatch.group(), urlmatch.groups()[0]",
            "",
            "    def test_confirm_valid_custom_user(self):",
            "        url, path = self._test_confirm_start()",
            "        response = self.client.get(path)",
            "        # redirect to a 'complete' page:",
            "        self.assertContains(response, \"Please enter your new password\")",
            "",
            "",
            "@skipIfCustomUser",
            "class ChangePasswordTest(AuthViewsTestCase):",
            "",
            "    def fail_login(self, password='password'):",
            "        response = self.client.post('/login/', {",
            "            'username': 'testclient',",
            "            'password': password,",
            "        })",
            "        self.assertFormError(response, AuthenticationForm.error_messages['invalid_login'] % {",
            "                'username': User._meta.get_field('username').verbose_name",
            "            })",
            "",
            "    def logout(self):",
            "        self.client.get('/logout/')",
            "",
            "    def test_password_change_fails_with_invalid_old_password(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'donuts',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertFormError(response, PasswordChangeForm.error_messages['password_incorrect'])",
            "",
            "    def test_password_change_fails_with_mismatched_passwords(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'donuts',",
            "        })",
            "        self.assertFormError(response, SetPasswordForm.error_messages['password_mismatch'])",
            "",
            "    def test_password_change_succeeds(self):",
            "        self.login()",
            "        self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.fail_login()",
            "        self.login(password='password1')",
            "",
            "    def test_password_change_done_succeeds(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_change/done/')",
            "",
            "    @override_settings(LOGIN_URL='/login/')",
            "    def test_password_change_done_fails(self):",
            "        response = self.client.get('/password_change/done/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/login/?next=/password_change/done/')",
            "",
            "    def test_password_change_redirect_default(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_change/done/')",
            "",
            "    def test_password_change_redirect_custom(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/custom/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/custom/')",
            "",
            "    def test_password_change_redirect_custom_named(self):",
            "        self.login()",
            "        response = self.client.post('/password_change/custom/named/', {",
            "            'old_password': 'password',",
            "            'new_password1': 'password1',",
            "            'new_password2': 'password1',",
            "        })",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginTest(AuthViewsTestCase):",
            "",
            "    def test_current_site_in_context_after_login(self):",
            "        response = self.client.get(reverse('login'))",
            "        self.assertEqual(response.status_code, 200)",
            "        if Site._meta.installed:",
            "            site = Site.objects.get_current()",
            "            self.assertEqual(response.context['site'], site)",
            "            self.assertEqual(response.context['site_name'], site.name)",
            "        else:",
            "            self.assertIsInstance(response.context['site'], RequestSite)",
            "        self.assertTrue(isinstance(response.context['form'], AuthenticationForm),",
            "                     'Login form is not an AuthenticationForm')",
            "",
            "    def test_security_check(self, password='password'):",
            "        login_url = reverse('login')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com',",
            "                        'javascript:alert(\"XSS\")'):",
            "",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            response = self.client.post(nasty_url, {",
            "                'username': 'testclient',",
            "                'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response.url,",
            "                             \"%s should be blocked\" % bad_url)",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         'HTTPS:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': login_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            response = self.client.post(safe_url, {",
            "                    'username': 'testclient',",
            "                    'password': password,",
            "            })",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response.url,",
            "                            \"%s should be allowed\" % good_url)",
            "",
            "    def test_login_form_contains_request(self):",
            "        # 15198",
            "        self.client.post('/custom_requestauth_login/', {",
            "            'username': 'testclient',",
            "            'password': 'password',",
            "        }, follow=True)",
            "        # the custom authentication form used by this login asserts",
            "        # that a request is passed to the form successfully.",
            "",
            "    def test_login_csrf_rotate(self, password='password'):",
            "        \"\"\"",
            "        Makes sure that a login rotates the currently-used CSRF token.",
            "        \"\"\"",
            "        # Do a GET to establish a CSRF token",
            "        # TestClient isn't used here as we're testing middleware, essentially.",
            "        req = HttpRequest()",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token1 = csrf_cookie.coded_value",
            "",
            "        # Prepare the POST request",
            "        req = HttpRequest()",
            "        req.COOKIES[settings.CSRF_COOKIE_NAME] = token1",
            "        req.method = \"POST\"",
            "        req.POST = {'username': 'testclient', 'password': password, 'csrfmiddlewaretoken': token1}",
            "        req.REQUEST = req.POST",
            "",
            "        # Use POST request to log in",
            "        SessionMiddleware().process_request(req)",
            "        CsrfViewMiddleware().process_view(req, login_view, (), {})",
            "        req.META[\"SERVER_NAME\"] = \"testserver\"  # Required to have redirect work in login view",
            "        req.META[\"SERVER_PORT\"] = 80",
            "        req.META[\"CSRF_COOKIE_USED\"] = True",
            "        resp = login_view(req)",
            "        resp2 = CsrfViewMiddleware().process_response(req, resp)",
            "        csrf_cookie = resp2.cookies.get(settings.CSRF_COOKIE_NAME, None)",
            "        token2 = csrf_cookie.coded_value",
            "",
            "        # Check the CSRF token switched",
            "        self.assertNotEqual(token1, token2)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginURLSettings(AuthViewsTestCase):",
            "    \"\"\"Tests for settings.LOGIN_URL.\"\"\"",
            "    def assertLoginURLEquals(self, url, parse_qs=False):",
            "        response = self.client.get('/login_required/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, url, parse_qs=parse_qs)",
            "",
            "    @override_settings(LOGIN_URL='/login/')",
            "    def test_standard_login_url(self):",
            "        self.assertLoginURLEquals('/login/?next=/login_required/')",
            "",
            "    @override_settings(LOGIN_URL='login')",
            "    def test_named_login_url(self):",
            "        self.assertLoginURLEquals('/login/?next=/login_required/')",
            "",
            "    @override_settings(LOGIN_URL='http://remote.example.com/login')",
            "    def test_remote_login_url(self):",
            "        quoted_next = urlquote('http://testserver/login_required/')",
            "        expected = 'http://remote.example.com/login?next=%s' % quoted_next",
            "        self.assertLoginURLEquals(expected)",
            "",
            "    @override_settings(LOGIN_URL='https:///login/')",
            "    def test_https_login_url(self):",
            "        quoted_next = urlquote('http://testserver/login_required/')",
            "        expected = 'https:///login/?next=%s' % quoted_next",
            "        self.assertLoginURLEquals(expected)",
            "",
            "    @override_settings(LOGIN_URL='/login/?pretty=1')",
            "    def test_login_url_with_querystring(self):",
            "        self.assertLoginURLEquals('/login/?pretty=1&next=/login_required/', parse_qs=True)",
            "",
            "    @override_settings(LOGIN_URL='http://remote.example.com/login/?next=/default/')",
            "    def test_remote_login_url_with_next_querystring(self):",
            "        quoted_next = urlquote('http://testserver/login_required/')",
            "        expected = 'http://remote.example.com/login/?next=%s' % quoted_next",
            "        self.assertLoginURLEquals(expected)",
            "",
            "",
            "@skipIfCustomUser",
            "class LoginRedirectUrlTest(AuthViewsTestCase):",
            "    \"\"\"Tests for settings.LOGIN_REDIRECT_URL.\"\"\"",
            "    def assertLoginRedirectURLEqual(self, url):",
            "        response = self.login()",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, url)",
            "",
            "    def test_default(self):",
            "        self.assertLoginRedirectURLEqual('/accounts/profile/')",
            "",
            "    @override_settings(LOGIN_REDIRECT_URL='/custom/')",
            "    def test_custom(self):",
            "        self.assertLoginRedirectURLEqual('/custom/')",
            "",
            "    @override_settings(LOGIN_REDIRECT_URL='password_reset')",
            "    def test_named(self):",
            "        self.assertLoginRedirectURLEqual('/password_reset/')",
            "",
            "    @override_settings(LOGIN_REDIRECT_URL='http://remote.example.com/welcome/')",
            "    def test_remote(self):",
            "        self.assertLoginRedirectURLEqual('http://remote.example.com/welcome/')",
            "",
            "",
            "@skipIfCustomUser",
            "class LogoutTest(AuthViewsTestCase):",
            "",
            "    def confirm_logged_out(self):",
            "        self.assertTrue(SESSION_KEY not in self.client.session)",
            "",
            "    def test_logout_default(self):",
            "        \"Logout without next_page option renders the default template\"",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertContains(response, 'Logged out')",
            "        self.confirm_logged_out()",
            "",
            "    def test_14377(self):",
            "        # Bug 14377",
            "        self.login()",
            "        response = self.client.get('/logout/')",
            "        self.assertTrue('site' in response.context)",
            "",
            "    def test_logout_with_overridden_redirect_url(self):",
            "        # Bug 11223",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/somewhere/')",
            "",
            "        response = self.client.get('/logout/next_page/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/login/')",
            "",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_next_page_specified(self):",
            "        \"Logout with next_page option given redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/somewhere/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_redirect_argument(self):",
            "        \"Logout with query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/?next=/login/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/login/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_custom_redirect_argument(self):",
            "        \"Logout with custom query string redirects to specified resource\"",
            "        self.login()",
            "        response = self.client.get('/logout/custom_query/?follow=/somewhere/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/somewhere/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_logout_with_named_redirect(self):",
            "        \"Logout resolves names or URLs passed as next_page.\"",
            "        self.login()",
            "        response = self.client.get('/logout/next_page/named/')",
            "        self.assertEqual(response.status_code, 302)",
            "        self.assertURLEqual(response.url, '/password_reset/')",
            "        self.confirm_logged_out()",
            "",
            "    def test_security_check(self, password='password'):",
            "        logout_url = reverse('logout')",
            "",
            "        # Those URLs should not pass the security check",
            "        for bad_url in ('http://example.com',",
            "                        'https://example.com',",
            "                        'ftp://exampel.com',",
            "                        '//example.com',",
            "                        'javascript:alert(\"XSS\")'):",
            "            nasty_url = '%(url)s?%(next)s=%(bad_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'bad_url': urlquote(bad_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(nasty_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertFalse(bad_url in response.url,",
            "                             \"%s should be blocked\" % bad_url)",
            "            self.confirm_logged_out()",
            "",
            "        # These URLs *should* still pass the security check",
            "        for good_url in ('/view/?param=http://example.com',",
            "                         '/view/?param=https://example.com',",
            "                         '/view?param=ftp://exampel.com',",
            "                         'view/?param=//example.com',",
            "                         'https:///',",
            "                         'HTTPS:///',",
            "                         '//testserver/',",
            "                         '/url%20with%20spaces/'):  # see ticket #12534",
            "            safe_url = '%(url)s?%(next)s=%(good_url)s' % {",
            "                'url': logout_url,",
            "                'next': REDIRECT_FIELD_NAME,",
            "                'good_url': urlquote(good_url),",
            "            }",
            "            self.login()",
            "            response = self.client.get(safe_url)",
            "            self.assertEqual(response.status_code, 302)",
            "            self.assertTrue(good_url in response.url,",
            "                            \"%s should be allowed\" % good_url)",
            "            self.confirm_logged_out()",
            "",
            "@skipIfCustomUser",
            "@override_settings(",
            "    PASSWORD_HASHERS=('django.contrib.auth.hashers.SHA1PasswordHasher',),",
            ")",
            "class ChangelistTests(AuthViewsTestCase):",
            "    urls = 'django.contrib.auth.tests.urls_admin'",
            "",
            "    def setUp(self):",
            "        # Make me a superuser before logging in.",
            "        User.objects.filter(username='testclient').update(is_staff=True, is_superuser=True)",
            "        self.login()",
            "        self.admin = User.objects.get(pk=1)",
            "",
            "    def get_user_data(self, user):",
            "        return {",
            "            'username': user.username,",
            "            'password': user.password,",
            "            'email': user.email,",
            "            'is_active': user.is_active,",
            "            'is_staff': user.is_staff,",
            "            'is_superuser': user.is_superuser,",
            "            'last_login_0': user.last_login.strftime('%Y-%m-%d'),",
            "            'last_login_1': user.last_login.strftime('%H:%M:%S'),",
            "            'initial-last_login_0': user.last_login.strftime('%Y-%m-%d'),",
            "            'initial-last_login_1': user.last_login.strftime('%H:%M:%S'),",
            "            'date_joined_0': user.date_joined.strftime('%Y-%m-%d'),",
            "            'date_joined_1': user.date_joined.strftime('%H:%M:%S'),",
            "            'initial-date_joined_0': user.date_joined.strftime('%Y-%m-%d'),",
            "            'initial-date_joined_1': user.date_joined.strftime('%H:%M:%S'),",
            "            'first_name': user.first_name,",
            "            'last_name': user.last_name,",
            "        }",
            "",
            "    # #20078 - users shouldn't be allowed to guess password hashes via",
            "    # repeated password__startswith queries.",
            "    def test_changelist_disallows_password_lookups(self):",
            "        # A lookup that tries to filter on password isn't OK",
            "        with patch_logger('django.security.DisallowedModelAdminLookup', 'error') as logger_calls:",
            "            response = self.client.get('/admin/auth/user/?password__startswith=sha1$')",
            "            self.assertEqual(response.status_code, 400)",
            "            self.assertEqual(len(logger_calls), 1)",
            "",
            "    def test_user_change_email(self):",
            "        data = self.get_user_data(self.admin)",
            "        data['email'] = 'new_' + data['email']",
            "        response = self.client.post('/admin/auth/user/%s/' % self.admin.pk, data)",
            "        self.assertRedirects(response, '/admin/auth/user/')",
            "        row = LogEntry.objects.latest('id')",
            "        self.assertEqual(row.change_message, 'Changed email.')",
            "",
            "    def test_user_not_change(self):",
            "        response = self.client.post('/admin/auth/user/%s/' % self.admin.pk,",
            "            self.get_user_data(self.admin)",
            "        )",
            "        self.assertRedirects(response, '/admin/auth/user/')",
            "        row = LogEntry.objects.latest('id')",
            "        self.assertEqual(row.change_message, 'No fields changed.')",
            "",
            "    def test_user_change_password(self):",
            "        response = self.client.post('/admin/auth/user/%s/password/' % self.admin.pk, {",
            "            'password1': 'password1',",
            "            'password2': 'password1',",
            "        })",
            "        self.assertRedirects(response, '/admin/auth/user/%s/' % self.admin.pk)",
            "        row = LogEntry.objects.latest('id')",
            "        self.assertEqual(row.change_message, 'Changed password.')",
            "        self.logout()",
            "        self.login(password='password1')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "449": [
                "LoginTest",
                "test_security_check"
            ],
            "664": [
                "LogoutTest",
                "test_security_check"
            ]
        },
        "addLocation": []
    },
    "django/utils/http.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": " def is_safe_url(url, host=None):"
            },
            "1": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     Return ``True`` if the url is a safe redirection (i.e. it doesn't point to"
            },
            "3": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    a different host)."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+    a different host and uses a safe scheme)."
            },
            "5": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 256,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "     Always returns ``False`` on an empty url."
            },
            "7": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "     if not url:"
            },
            "9": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         return False"
            },
            "10": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    netloc = urllib_parse.urlparse(url)[1]"
            },
            "11": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return not netloc or netloc == host"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    url_info = urllib_parse.urlparse(url)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    return (not url_info.netloc or url_info.netloc == host) and \\"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+        (not url_info.scheme or url_info.scheme in ['http', 'https'])"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "import calendar",
            "import datetime",
            "import re",
            "import sys",
            "try:",
            "    from urllib import parse as urllib_parse",
            "except ImportError:     # Python 2",
            "    import urllib as urllib_parse",
            "    import urlparse",
            "    urllib_parse.urlparse = urlparse.urlparse",
            "",
            "from binascii import Error as BinasciiError",
            "from email.utils import formatdate",
            "",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.encoding import force_str, force_text",
            "from django.utils.functional import allow_lazy",
            "from django.utils import six",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote(force_str(url), force_str(safe)))",
            "urlquote = allow_lazy(urlquote, six.text_type)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote_plus(force_str(url), force_str(safe)))",
            "urlquote_plus = allow_lazy(urlquote_plus, six.text_type)",
            "",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote() function that can operate on",
            "    the result of django.utils.http.urlquote().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote(force_str(quoted_url)))",
            "urlunquote = allow_lazy(urlunquote, six.text_type)",
            "",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote_plus() function that can operate on",
            "    the result of django.utils.http.urlquote_plus().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote_plus(force_str(quoted_url)))",
            "urlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first cast to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib_parse.urlencode(",
            "        [(force_str(k),",
            "         [force_str(i) for i in v] if isinstance(v, (list,tuple)) else force_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    return formatdate(epoch_seconds, usegmt=True)",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parses a date format as specified by HTTP RFC2616 section 3.3.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Returns an integer expressed in seconds since the epoch, in UTC.",
            "    \"\"\"",
            "    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately",
            "    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception:",
            "        six.reraise(ValueError, ValueError(\"%r is not a valid date\" % date), sys.exc_info()[2])",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but returns None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. Raises ``ValueError` if the",
            "    input won't fit into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is long than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    value = int(s, 36)",
            "    # ... then do a final check that the value will fit into an int to avoid",
            "    # returning a long (#15067). The long type was removed in Python 3.",
            "    if not six.PY3 and value > sys.maxint:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return value",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    if i < 0:",
            "        raise ValueError(\"Negative base36 conversion input.\")",
            "    if not six.PY3:",
            "        if not isinstance(i, six.integer_types):",
            "            raise TypeError(\"Non-integer base36 conversion input.\")",
            "        if i > sys.maxint:",
            "            raise ValueError(\"Base36 conversion input too large.\")",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i // j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def urlsafe_base64_encode(s):",
            "    \"\"\"",
            "    Encodes a bytestring in base64 for use in URLs, stripping any trailing",
            "    equal signs.",
            "    \"\"\"",
            "    return base64.urlsafe_b64encode(s).rstrip(b'\\n=')",
            "",
            "def urlsafe_base64_decode(s):",
            "    \"\"\"",
            "    Decodes a base64 encoded string, adding back any trailing equal signs that",
            "    might have been stripped.",
            "    \"\"\"",
            "    s = s.encode('utf-8') # base64encode should only return ASCII.",
            "    try:",
            "        return base64.urlsafe_b64decode(s.ljust(len(s) + len(s) % 4, b'='))",
            "    except (LookupError, BinasciiError) as e:",
            "        raise ValueError(e)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.encode('ascii').decode('unicode_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necessary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')",
            "",
            "def same_origin(url1, url2):",
            "    \"\"\"",
            "    Checks if two URLs are 'same-origin'",
            "    \"\"\"",
            "    p1, p2 = urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)",
            "    try:",
            "        return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)",
            "    except ValueError:",
            "        return False",
            "",
            "def is_safe_url(url, host=None):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host).",
            "",
            "    Always returns ``False`` on an empty url.",
            "    \"\"\"",
            "    if not url:",
            "        return False",
            "    netloc = urllib_parse.urlparse(url)[1]",
            "    return not netloc or netloc == host"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "import calendar",
            "import datetime",
            "import re",
            "import sys",
            "try:",
            "    from urllib import parse as urllib_parse",
            "except ImportError:     # Python 2",
            "    import urllib as urllib_parse",
            "    import urlparse",
            "    urllib_parse.urlparse = urlparse.urlparse",
            "",
            "from binascii import Error as BinasciiError",
            "from email.utils import formatdate",
            "",
            "from django.utils.datastructures import MultiValueDict",
            "from django.utils.encoding import force_str, force_text",
            "from django.utils.functional import allow_lazy",
            "from django.utils import six",
            "",
            "ETAG_MATCH = re.compile(r'(?:W/)?\"((?:\\\\.|[^\"])*)\"')",
            "",
            "MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()",
            "__D = r'(?P<day>\\d{2})'",
            "__D2 = r'(?P<day>[ \\d]\\d)'",
            "__M = r'(?P<mon>\\w{3})'",
            "__Y = r'(?P<year>\\d{4})'",
            "__Y2 = r'(?P<year>\\d{2})'",
            "__T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'",
            "RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))",
            "RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))",
            "ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))",
            "",
            "def urlquote(url, safe='/'):",
            "    \"\"\"",
            "    A version of Python's urllib.quote() function that can operate on unicode",
            "    strings. The url is first UTF-8 encoded before quoting. The returned string",
            "    can safely be used as part of an argument to a subsequent iri_to_uri() call",
            "    without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote(force_str(url), force_str(safe)))",
            "urlquote = allow_lazy(urlquote, six.text_type)",
            "",
            "def urlquote_plus(url, safe=''):",
            "    \"\"\"",
            "    A version of Python's urllib.quote_plus() function that can operate on",
            "    unicode strings. The url is first UTF-8 encoded before quoting. The",
            "    returned string can safely be used as part of an argument to a subsequent",
            "    iri_to_uri() call without double-quoting occurring.",
            "    \"\"\"",
            "    return force_text(urllib_parse.quote_plus(force_str(url), force_str(safe)))",
            "urlquote_plus = allow_lazy(urlquote_plus, six.text_type)",
            "",
            "def urlunquote(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote() function that can operate on",
            "    the result of django.utils.http.urlquote().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote(force_str(quoted_url)))",
            "urlunquote = allow_lazy(urlunquote, six.text_type)",
            "",
            "def urlunquote_plus(quoted_url):",
            "    \"\"\"",
            "    A wrapper for Python's urllib.unquote_plus() function that can operate on",
            "    the result of django.utils.http.urlquote_plus().",
            "    \"\"\"",
            "    return force_text(urllib_parse.unquote_plus(force_str(quoted_url)))",
            "urlunquote_plus = allow_lazy(urlunquote_plus, six.text_type)",
            "",
            "def urlencode(query, doseq=0):",
            "    \"\"\"",
            "    A version of Python's urllib.urlencode() function that can operate on",
            "    unicode strings. The parameters are first cast to UTF-8 encoded strings and",
            "    then encoded as per normal.",
            "    \"\"\"",
            "    if isinstance(query, MultiValueDict):",
            "        query = query.lists()",
            "    elif hasattr(query, 'items'):",
            "        query = query.items()",
            "    return urllib_parse.urlencode(",
            "        [(force_str(k),",
            "         [force_str(i) for i in v] if isinstance(v, (list,tuple)) else force_str(v))",
            "            for k, v in query],",
            "        doseq)",
            "",
            "def cookie_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to ensure compatibility with Netscape's cookie standard.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD-Mon-YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    rfcdate = formatdate(epoch_seconds)",
            "    return '%s-%s-%s GMT' % (rfcdate[:7], rfcdate[8:11], rfcdate[12:25])",
            "",
            "def http_date(epoch_seconds=None):",
            "    \"\"\"",
            "    Formats the time to match the RFC1123 date format as specified by HTTP",
            "    RFC2616 section 3.3.1.",
            "",
            "    Accepts a floating point number expressed in seconds since the epoch, in",
            "    UTC - such as that outputted by time.time(). If set to None, defaults to",
            "    the current time.",
            "",
            "    Outputs a string in the format 'Wdy, DD Mon YYYY HH:MM:SS GMT'.",
            "    \"\"\"",
            "    return formatdate(epoch_seconds, usegmt=True)",
            "",
            "def parse_http_date(date):",
            "    \"\"\"",
            "    Parses a date format as specified by HTTP RFC2616 section 3.3.1.",
            "",
            "    The three formats allowed by the RFC are accepted, even if only the first",
            "    one is still in widespread use.",
            "",
            "    Returns an integer expressed in seconds since the epoch, in UTC.",
            "    \"\"\"",
            "    # emails.Util.parsedate does the job for RFC1123 dates; unfortunately",
            "    # RFC2616 makes it mandatory to support RFC850 dates too. So we roll",
            "    # our own RFC-compliant parsing.",
            "    for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:",
            "        m = regex.match(date)",
            "        if m is not None:",
            "            break",
            "    else:",
            "        raise ValueError(\"%r is not in a valid HTTP date format\" % date)",
            "    try:",
            "        year = int(m.group('year'))",
            "        if year < 100:",
            "            if year < 70:",
            "                year += 2000",
            "            else:",
            "                year += 1900",
            "        month = MONTHS.index(m.group('mon').lower()) + 1",
            "        day = int(m.group('day'))",
            "        hour = int(m.group('hour'))",
            "        min = int(m.group('min'))",
            "        sec = int(m.group('sec'))",
            "        result = datetime.datetime(year, month, day, hour, min, sec)",
            "        return calendar.timegm(result.utctimetuple())",
            "    except Exception:",
            "        six.reraise(ValueError, ValueError(\"%r is not a valid date\" % date), sys.exc_info()[2])",
            "",
            "def parse_http_date_safe(date):",
            "    \"\"\"",
            "    Same as parse_http_date, but returns None if the input is invalid.",
            "    \"\"\"",
            "    try:",
            "        return parse_http_date(date)",
            "    except Exception:",
            "        pass",
            "",
            "# Base 36 functions: useful for generating compact URLs",
            "",
            "def base36_to_int(s):",
            "    \"\"\"",
            "    Converts a base 36 string to an ``int``. Raises ``ValueError` if the",
            "    input won't fit into an int.",
            "    \"\"\"",
            "    # To prevent overconsumption of server resources, reject any",
            "    # base36 string that is long than 13 base36 digits (13 digits",
            "    # is sufficient to base36-encode any 64-bit integer)",
            "    if len(s) > 13:",
            "        raise ValueError(\"Base36 input too large\")",
            "    value = int(s, 36)",
            "    # ... then do a final check that the value will fit into an int to avoid",
            "    # returning a long (#15067). The long type was removed in Python 3.",
            "    if not six.PY3 and value > sys.maxint:",
            "        raise ValueError(\"Base36 input too large\")",
            "    return value",
            "",
            "def int_to_base36(i):",
            "    \"\"\"",
            "    Converts an integer to a base36 string",
            "    \"\"\"",
            "    digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"",
            "    factor = 0",
            "    if i < 0:",
            "        raise ValueError(\"Negative base36 conversion input.\")",
            "    if not six.PY3:",
            "        if not isinstance(i, six.integer_types):",
            "            raise TypeError(\"Non-integer base36 conversion input.\")",
            "        if i > sys.maxint:",
            "            raise ValueError(\"Base36 conversion input too large.\")",
            "    # Find starting factor",
            "    while True:",
            "        factor += 1",
            "        if i < 36 ** factor:",
            "            factor -= 1",
            "            break",
            "    base36 = []",
            "    # Construct base36 representation",
            "    while factor >= 0:",
            "        j = 36 ** factor",
            "        base36.append(digits[i // j])",
            "        i = i % j",
            "        factor -= 1",
            "    return ''.join(base36)",
            "",
            "def urlsafe_base64_encode(s):",
            "    \"\"\"",
            "    Encodes a bytestring in base64 for use in URLs, stripping any trailing",
            "    equal signs.",
            "    \"\"\"",
            "    return base64.urlsafe_b64encode(s).rstrip(b'\\n=')",
            "",
            "def urlsafe_base64_decode(s):",
            "    \"\"\"",
            "    Decodes a base64 encoded string, adding back any trailing equal signs that",
            "    might have been stripped.",
            "    \"\"\"",
            "    s = s.encode('utf-8') # base64encode should only return ASCII.",
            "    try:",
            "        return base64.urlsafe_b64decode(s.ljust(len(s) + len(s) % 4, b'='))",
            "    except (LookupError, BinasciiError) as e:",
            "        raise ValueError(e)",
            "",
            "def parse_etags(etag_str):",
            "    \"\"\"",
            "    Parses a string with one or several etags passed in If-None-Match and",
            "    If-Match headers by the rules in RFC 2616. Returns a list of etags",
            "    without surrounding double quotes (\") and unescaped from \\<CHAR>.",
            "    \"\"\"",
            "    etags = ETAG_MATCH.findall(etag_str)",
            "    if not etags:",
            "        # etag_str has wrong format, treat it as an opaque string then",
            "        return [etag_str]",
            "    etags = [e.encode('ascii').decode('unicode_escape') for e in etags]",
            "    return etags",
            "",
            "def quote_etag(etag):",
            "    \"\"\"",
            "    Wraps a string in double quotes escaping contents as necessary.",
            "    \"\"\"",
            "    return '\"%s\"' % etag.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')",
            "",
            "def same_origin(url1, url2):",
            "    \"\"\"",
            "    Checks if two URLs are 'same-origin'",
            "    \"\"\"",
            "    p1, p2 = urllib_parse.urlparse(url1), urllib_parse.urlparse(url2)",
            "    try:",
            "        return (p1.scheme, p1.hostname, p1.port) == (p2.scheme, p2.hostname, p2.port)",
            "    except ValueError:",
            "        return False",
            "",
            "def is_safe_url(url, host=None):",
            "    \"\"\"",
            "    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to",
            "    a different host and uses a safe scheme).",
            "",
            "    Always returns ``False`` on an empty url.",
            "    \"\"\"",
            "    if not url:",
            "        return False",
            "    url_info = urllib_parse.urlparse(url)",
            "    return (not url_info.netloc or url_info.netloc == host) and \\",
            "        (not url_info.scheme or url_info.scheme in ['http', 'https'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "255": [
                "is_safe_url"
            ],
            "261": [
                "is_safe_url"
            ],
            "262": [
                "is_safe_url"
            ]
        },
        "addLocation": []
    }
}