{
    "onnx/test/test_external_data.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         return tensor"
            },
            "1": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     def create_test_model(self) -> str:"
            },
            "3": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         constant_node = onnx.helper.make_node("
            },
            "5": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             'Constant',"
            },
            "6": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "             inputs=[],"
            },
            "7": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         model_file_path = self.get_temp_model_filename()"
            },
            "8": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         external_data_file = str(uuid.uuid4())"
            },
            "9": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True, location=external_data_file)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+                                       location=external_data_file)"
            },
            "13": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         onnx.save_model(self.model, model_file_path)"
            },
            "14": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 231,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "         self.assertTrue(Path.isfile(os.path.join(self.temp_dir, external_data_file)))"
            },
            "16": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     def test_convert_model_to_external_data_one_file_per_tensor_without_attribute(self) -> None:"
            },
            "17": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         model_file_path = self.get_temp_model_filename()"
            },
            "18": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False, convert_attribute=False)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+                                       convert_attribute=False)"
            },
            "22": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "         onnx.save_model(self.model, model_file_path)"
            },
            "23": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 266,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "         self.assertTrue(Path.isfile(model_file_path))"
            },
            "25": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "     def test_convert_model_to_external_data_one_file_per_tensor_with_attribute(self) -> None:"
            },
            "26": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         model_file_path = self.get_temp_model_filename()"
            },
            "27": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 273,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False, convert_attribute=True)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+                                       convert_attribute=True)"
            },
            "31": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         onnx.save_model(self.model, model_file_path)"
            },
            "32": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 277,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         self.assertTrue(Path.isfile(model_file_path))"
            },
            "34": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "     def test_convert_model_to_external_data_does_not_convert_attribute_values(self) -> None:"
            },
            "35": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         model_file_path = self.get_temp_model_filename()"
            },
            "36": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 284,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=False, all_tensors_to_one_file=False)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=False,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                                       all_tensors_to_one_file=False)"
            },
            "40": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         onnx.save_model(self.model, model_file_path)"
            },
            "41": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))"
            },
            "43": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "     def create_test_model(self) -> ModelProto:"
            },
            "44": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         X = helper.make_tensor_value_info('X', TensorProto.FLOAT, self.large_data.shape)"
            },
            "45": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "         input_init = helper.make_tensor(name='X', data_type=TensorProto.FLOAT,"
            },
            "46": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dims=self.large_data.shape, vals=self.large_data.tobytes(), raw=True)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+                                        dims=self.large_data.shape, vals=self.large_data.tobytes(), raw=True)"
            },
            "48": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 406,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         shape_data = np.array(self.small_data, np.int64)"
            },
            "50": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         shape_init = helper.make_tensor(name='Shape', data_type=TensorProto.INT64,"
            },
            "51": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            dims=shape_data.shape, vals=shape_data.tobytes(), raw=True)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+                                        dims=shape_data.shape, vals=shape_data.tobytes(), raw=True)"
            },
            "53": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "         C = helper.make_tensor_value_info('C', TensorProto.INT64, self.small_data)"
            },
            "54": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 411,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 412,
                "PatchRowcode": "         reshape = onnx.helper.make_node("
            },
            "56": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "         checker.check_model(self.model)"
            },
            "57": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 436,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "     def test_reshape_inference_with_external_data_fail(self) -> None:"
            },
            "59": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        onnx.save_model(self.model, self.model_file_path, save_as_external_data=True, all_tensors_to_one_file=False, size_threshold=0)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+        onnx.save_model(self.model, self.model_file_path, save_as_external_data=True, all_tensors_to_one_file=False,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+                        size_threshold=0)"
            },
            "62": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "         model_without_external_data = onnx.load(self.model_file_path, load_external_data=False)"
            },
            "63": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "         # Shape inference of Reshape uses ParseData"
            },
            "64": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "         # ParseData cannot handle external data and should throw the error as follows:"
            },
            "65": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "         # Cannot parse data from external tensors. Please load external data into raw data for tensor: Shape"
            },
            "66": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "         self.assertRaises(shape_inference.InferenceError, shape_inference.infer_shapes,"
            },
            "67": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            model_without_external_data, strict_mode=True)"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+                          model_without_external_data, strict_mode=True)"
            },
            "69": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 446,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "     def test_to_array_with_external_data(self) -> None:"
            },
            "71": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "         onnx.save_model(self.model,"
            },
            "72": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 496,
                "PatchRowcode": "         self.assertTrue(np.allclose(to_array(small_shape_tensor, self.temp_dir), self.small_data))"
            },
            "73": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 497,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 498,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+class TestNotAllowToLoadExternalDataOutsideModelDirectory(TestLoadExternalDataBase):"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+    \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+    directory. \"\"\""
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 502,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+    def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+        tensor = from_array(np.array(value))"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 505,
                "PatchRowcode": "+        tensor.name = tensor_name"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+        set_external_data(tensor, location=\"../../file.bin\")"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+        tensor.ClearField('raw_data')"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+        tensor.data_location = onnx.TensorProto.EXTERNAL"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+        return tensor"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+    def test_check_model(self) -> None:"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 514,
                "PatchRowcode": "+        \"\"\"We only test the model validation as onnxruntime uses this to load the model. \"\"\""
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 515,
                "PatchRowcode": "+        with self.assertRaises(onnx.checker.ValidationError):"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 516,
                "PatchRowcode": "+            checker.check_model(self.model_filename)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 517,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 519,
                "PatchRowcode": "+@pytest.mark.skipif(os.name != 'nt', reason='Skip Windows test')"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+class TestNotAllowToLoadExternalDataOutsideModelDirectoryOnWindows(TestLoadExternalDataBase):"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 521,
                "PatchRowcode": "+    \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 522,
                "PatchRowcode": "+    directory. \"\"\""
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 523,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 524,
                "PatchRowcode": "+    def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+        tensor = from_array(np.array(value))"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+        tensor.name = tensor_name"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 528,
                "PatchRowcode": "+        set_external_data(tensor, location=\"..\\\\..\\\\file.bin\")"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 529,
                "PatchRowcode": "+"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 530,
                "PatchRowcode": "+        tensor.ClearField('raw_data')"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 531,
                "PatchRowcode": "+        tensor.data_location = onnx.TensorProto.EXTERNAL"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 532,
                "PatchRowcode": "+        return tensor"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 533,
                "PatchRowcode": "+"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 534,
                "PatchRowcode": "+    def test_check_model(self) -> None:"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 535,
                "PatchRowcode": "+        \"\"\"We only test the model validation as onnxruntime uses this to load the model. \"\"\""
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 536,
                "PatchRowcode": "+        with self.assertRaises(onnx.checker.ValidationError):"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 537,
                "PatchRowcode": "+            checker.check_model(self.model_filename)"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 538,
                "PatchRowcode": "+"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 539,
                "PatchRowcode": "+"
            },
            "116": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 540,
                "PatchRowcode": " if __name__ == '__main__':"
            },
            "117": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 541,
                "PatchRowcode": "     unittest.main()"
            }
        },
        "frontPatchFile": [
            "# SPDX-License-Identifier: Apache-2.0",
            "import tempfile",
            "import unittest",
            "import uuid",
            "",
            "import numpy as np  # type: ignore",
            "import shutil",
            "",
            "import os",
            "import os.path as Path",
            "",
            "import onnx",
            "from onnx import checker, helper, shape_inference",
            "from onnx import ModelProto, TensorProto",
            "from onnx.external_data_helper import set_external_data",
            "from onnx.external_data_helper import convert_model_to_external_data",
            "from onnx.external_data_helper import convert_model_from_external_data",
            "from onnx.external_data_helper import load_external_data_for_model, load_external_data_for_tensor",
            "from onnx.numpy_helper import to_array, from_array",
            "from typing import Any, Tuple, List",
            "import pytest  # type: ignore",
            "import sys",
            "",
            "",
            "class TestLoadExternalDataBase(unittest.TestCase):",
            "",
            "    def setUp(self) -> None:",
            "        self.temp_dir: str = tempfile.mkdtemp()",
            "        self.initializer_value = np.arange(6).reshape(3, 2).astype(np.float32) + 512",
            "        self.attribute_value = np.arange(6).reshape(2, 3).astype(np.float32) + 256",
            "        self.model_filename = self.create_test_model()",
            "",
            "    def tearDown(self) -> None:",
            "        shutil.rmtree(self.temp_dir)",
            "",
            "    def get_temp_model_filename(self) -> str:",
            "        return os.path.join(self.temp_dir, str(uuid.uuid4()) + '.onnx')",
            "",
            "    def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:",
            "        tensor = from_array(np.array(value))",
            "        tensor.name = tensor_name",
            "        tensor_filename = f\"{tensor_name}.bin\"",
            "        set_external_data(tensor, location=tensor_filename)",
            "",
            "        with open(os.path.join(self.temp_dir, tensor_filename), 'wb') as data_file:",
            "            data_file.write(tensor.raw_data)",
            "        tensor.ClearField('raw_data')",
            "        tensor.data_location = onnx.TensorProto.EXTERNAL",
            "        return tensor",
            "",
            "    def create_test_model(self) -> str:",
            "",
            "        constant_node = onnx.helper.make_node(",
            "            'Constant',",
            "            inputs=[],",
            "            outputs=['values'],",
            "            value=self.create_external_data_tensor(self.attribute_value, \"attribute_value\")",
            "        )",
            "",
            "        initializers = [self.create_external_data_tensor(self.initializer_value, \"input_value\")]",
            "        inputs = [helper.make_tensor_value_info(\"input_value\",",
            "                                                onnx.TensorProto.FLOAT,",
            "                                                self.initializer_value.shape)]",
            "",
            "        graph = helper.make_graph([constant_node], \"test_graph\",",
            "                                  inputs=inputs, outputs=[],",
            "                                  initializer=initializers)",
            "        model = helper.make_model(graph)",
            "",
            "        model_filename = os.path.join(self.temp_dir, \"model.onnx\")",
            "        with open(model_filename, \"wb\") as model_file:",
            "            model_file.write(model.SerializeToString())",
            "",
            "        return model_filename",
            "",
            "    def test_check_model(self) -> None:",
            "        checker.check_model(self.model_filename)",
            "",
            "",
            "class TestLoadExternalData(TestLoadExternalDataBase):",
            "",
            "    def test_load_external_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_load_external_data_for_model(self) -> None:",
            "        model = onnx.load_model(self.model_filename, load_external_data=False)",
            "        load_external_data_for_model(model, self.temp_dir)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_external_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "",
            "        temp_dir = os.path.join(self.temp_dir, \"save_copy\")",
            "        os.mkdir(temp_dir)",
            "        new_model_filename = os.path.join(temp_dir, 'model.onnx')",
            "        onnx.save_model(model, new_model_filename)",
            "",
            "        new_model = onnx.load_model(new_model_filename)",
            "        initializer_tensor = new_model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = new_model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "",
            "class TestLoadExternalDataSingleFile(TestLoadExternalDataBase):",
            "",
            "    def create_external_data_tensors(self, tensors_data: List[Tuple[List[Any], Any]]) -> List[TensorProto]:",
            "        tensor_filename = \"tensors.bin\"",
            "        tensors = []",
            "",
            "        with open(os.path.join(self.temp_dir, tensor_filename), 'ab') as data_file:",
            "            for (value, tensor_name) in tensors_data:",
            "                tensor = from_array(np.array(value))",
            "                offset = data_file.tell()",
            "                if offset % 4096 != 0:",
            "                    data_file.write(b\"\\0\" * (4096 - offset % 4096))",
            "                    offset = offset + 4096 - offset % 4096",
            "",
            "                data_file.write(tensor.raw_data)",
            "                set_external_data(tensor, location=tensor_filename, offset=offset, length=data_file.tell() - offset)",
            "                tensor.name = tensor_name",
            "                tensor.ClearField(\"raw_data\")",
            "                tensor.data_location = onnx.TensorProto.EXTERNAL",
            "                tensors.append(tensor)",
            "",
            "        return tensors",
            "",
            "    def test_load_external_single_file_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_external_single_file_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "",
            "        temp_dir = os.path.join(self.temp_dir, \"save_copy\")",
            "        os.mkdir(temp_dir)",
            "        new_model_filename = os.path.join(temp_dir, 'model.onnx')",
            "        onnx.save_model(model, new_model_filename)",
            "",
            "        new_model = onnx.load_model(new_model_filename)",
            "        initializer_tensor = new_model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = new_model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "",
            "class TestSaveAllTensorsAsExternalData(TestLoadExternalDataBase):",
            "",
            "    def setUp(self) -> None:",
            "        self.temp_dir: str = tempfile.mkdtemp()",
            "        self.initializer_value = np.arange(6).reshape(3, 2).astype(np.float32) + 512",
            "        self.attribute_value = np.arange(6).reshape(2, 3).astype(np.float32) + 256",
            "        self.model = self.create_test_model_proto()",
            "",
            "    def create_data_tensors(self, tensors_data: List[Tuple[List[Any], Any]]) -> List[TensorProto]:",
            "        tensors = []",
            "        for (value, tensor_name) in tensors_data:",
            "            tensor = from_array(np.array(value))",
            "            tensor.name = tensor_name",
            "            tensors.append(tensor)",
            "",
            "        return tensors",
            "",
            "    def create_test_model_proto(self) -> ModelProto:",
            "        tensors = self.create_data_tensors([",
            "            (self.attribute_value, \"attribute_value\"),",
            "            (self.initializer_value, \"input_value\"),",
            "        ])",
            "",
            "        constant_node = onnx.helper.make_node(",
            "            'Constant',",
            "            inputs=[],",
            "            outputs=['values'],",
            "            value=tensors[0]",
            "        )",
            "",
            "        inputs = [helper.make_tensor_value_info(\"input_value\",",
            "                                                onnx.TensorProto.FLOAT,",
            "                                                self.initializer_value.shape)]",
            "",
            "        graph = helper.make_graph([constant_node], \"test_graph\",",
            "                                  inputs=inputs, outputs=[],",
            "                                  initializer=[tensors[1]])",
            "        return helper.make_model(graph)",
            "",
            "    def test_check_model(self) -> None:",
            "        checker.check_model(self.model)",
            "",
            "    def test_convert_model_to_external_data_with_size_threshold(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=1024)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertFalse(initializer_tensor.HasField(\"data_location\"))",
            "",
            "    def test_convert_model_to_external_data_without_size_threshold(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        convert_model_to_external_data(self.model, size_threshold=0)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "    def test_convert_model_to_external_data_from_one_file_with_location(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        external_data_file = str(uuid.uuid4())",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True, location=external_data_file)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, external_data_file)))",
            "",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        # test convert model from external data",
            "        convert_model_from_external_data(model)",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(model, model_file_path)",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertFalse(len(initializer_tensor.external_data))",
            "        self.assertEqual(initializer_tensor.data_location, TensorProto.DEFAULT)",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(len(attribute_tensor.external_data))",
            "        self.assertEqual(attribute_tensor.data_location, TensorProto.DEFAULT)",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_convert_model_to_external_data_from_one_file_without_location_uses_model_name(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, model_file_path)))",
            "",
            "    def test_convert_model_to_external_data_one_file_per_tensor_without_attribute(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False, convert_attribute=False)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
            "        self.assertFalse(Path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
            "",
            "    def test_convert_model_to_external_data_one_file_per_tensor_with_attribute(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False, convert_attribute=True)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
            "",
            "    def test_convert_model_to_external_data_does_not_convert_attribute_values(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=False, all_tensors_to_one_file=False)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
            "        self.assertFalse(Path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "",
            "    def test_convert_model_to_external_data_converts_attribute_values(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=True)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "        self.assertTrue(attribute_tensor.HasField(\"data_location\"))",
            "",
            "    def test_save_model_does_not_convert_to_external_data_and_saves_the_model(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(self.model, model_file_path, save_as_external_data=False)",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertFalse(initializer_tensor.HasField(\"data_location\"))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "",
            "    def test_save_model_does_convert_and_saves_the_model(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(self.model,",
            "                        model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=True,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=False)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_model_without_loading_external_data(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(self.model,",
            "                        model_file_path,",
            "                        save_as_external_data=True,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=False)",
            "        # Save without load_external_data",
            "        model = onnx.load_model(model_file_path, load_external_data=False)",
            "        onnx.save_model(model,",
            "                        model_file_path,",
            "                        save_as_external_data=True,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=False)",
            "        # Load the saved model again; Only works if the saved path is under the same directory",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_model_with_existing_raw_data_should_override(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        original_raw_data = self.model.graph.initializer[0].raw_data",
            "        onnx.save_model(self.model, model_file_path, save_as_external_data=True, size_threshold=0)",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "",
            "        model = onnx.load_model(model_file_path, load_external_data=False)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        initializer_tensor.raw_data = b'dummpy_raw_data'",
            "        # If raw_data and external tensor exist at the same time, override existing raw_data",
            "        load_external_data_for_tensor(initializer_tensor, self.temp_dir)",
            "        self.assertEqual(initializer_tensor.raw_data, original_raw_data)",
            "",
            "",
            "class TestExternalDataToArray(unittest.TestCase):",
            "    def setUp(self) -> None:",
            "        self.temp_dir: str = tempfile.mkdtemp()",
            "        self.model_file_path: str = os.path.join(self.temp_dir, 'model.onnx')",
            "        self.large_data = np.random.rand(10, 60, 100).astype(np.float32)",
            "        self.small_data = (200, 300)",
            "        self.model = self.create_test_model()",
            "",
            "    def tearDown(self) -> None:",
            "        shutil.rmtree(self.temp_dir)",
            "",
            "    def get_temp_model_filename(self) -> str:",
            "        return os.path.join(self.temp_dir, str(uuid.uuid4()) + '.onnx')",
            "",
            "    def create_test_model(self) -> ModelProto:",
            "        X = helper.make_tensor_value_info('X', TensorProto.FLOAT, self.large_data.shape)",
            "        input_init = helper.make_tensor(name='X', data_type=TensorProto.FLOAT,",
            "            dims=self.large_data.shape, vals=self.large_data.tobytes(), raw=True)",
            "",
            "        shape_data = np.array(self.small_data, np.int64)",
            "        shape_init = helper.make_tensor(name='Shape', data_type=TensorProto.INT64,",
            "            dims=shape_data.shape, vals=shape_data.tobytes(), raw=True)",
            "        C = helper.make_tensor_value_info('C', TensorProto.INT64, self.small_data)",
            "",
            "        reshape = onnx.helper.make_node(",
            "            'Reshape',",
            "            inputs=['X', 'Shape'],",
            "            outputs=['Y'],",
            "        )",
            "        cast = onnx.helper.make_node(",
            "            'Cast',",
            "            inputs=['Y'],",
            "            outputs=['C'],",
            "            to=getattr(TensorProto, 'INT64')",
            "        )",
            "",
            "        graph_def = helper.make_graph(",
            "            [reshape, cast],",
            "            'test-model',",
            "            [X],",
            "            [C],",
            "            initializer=[input_init, shape_init],",
            "        )",
            "        model = helper.make_model(graph_def, producer_name='onnx-example')",
            "        return model",
            "",
            "    def test_check_model(self) -> None:",
            "        checker.check_model(self.model)",
            "",
            "    def test_reshape_inference_with_external_data_fail(self) -> None:",
            "        onnx.save_model(self.model, self.model_file_path, save_as_external_data=True, all_tensors_to_one_file=False, size_threshold=0)",
            "        model_without_external_data = onnx.load(self.model_file_path, load_external_data=False)",
            "        # Shape inference of Reshape uses ParseData",
            "        # ParseData cannot handle external data and should throw the error as follows:",
            "        # Cannot parse data from external tensors. Please load external data into raw data for tensor: Shape",
            "        self.assertRaises(shape_inference.InferenceError, shape_inference.infer_shapes,",
            "            model_without_external_data, strict_mode=True)",
            "",
            "    def test_to_array_with_external_data(self) -> None:",
            "        onnx.save_model(self.model,",
            "                        self.model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=False,",
            "                        size_threshold=0)",
            "        # raw_data of external tensor is not loaded",
            "        model = onnx.load(self.model_file_path, load_external_data=False)",
            "        # Specify self.temp_dir to load external tensor",
            "        loaded_large_data = to_array(model.graph.initializer[0], self.temp_dir)",
            "        self.assertTrue(np.allclose(loaded_large_data, self.large_data))",
            "",
            "    def test_save_model_with_external_data_multiple_times(self) -> None:",
            "        # Test onnx.save should respectively handle typical tensor and external tensor properly",
            "        # 1st save: save two tensors which have raw_data",
            "        # Only w_large will be stored as external tensors since it's larger than 1024",
            "        onnx.save_model(self.model,",
            "                        self.model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=False,",
            "                        location=None,",
            "                        size_threshold=1024,",
            "                        convert_attribute=True)",
            "        model_without_loading_external = onnx.load(self.model_file_path, load_external_data=False)",
            "        large_input_tensor = model_without_loading_external.graph.initializer[0]",
            "        self.assertTrue(large_input_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(large_input_tensor, self.temp_dir), self.large_data))",
            "",
            "        small_shape_tensor = model_without_loading_external.graph.initializer[1]",
            "        self.assertTrue(not small_shape_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(small_shape_tensor), self.small_data))",
            "",
            "        # 2nd save: one tensor has raw_data (small); one external tensor (large)",
            "        # Save them both as external tensors this time",
            "        onnx.save_model(model_without_loading_external,",
            "                        self.model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=False,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=True)",
            "",
            "        model_without_loading_external = onnx.load(self.model_file_path, load_external_data=False)",
            "        large_input_tensor = model_without_loading_external.graph.initializer[0]",
            "        self.assertTrue(large_input_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(large_input_tensor, self.temp_dir), self.large_data))",
            "",
            "        small_shape_tensor = model_without_loading_external.graph.initializer[1]",
            "        self.assertTrue(small_shape_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(small_shape_tensor, self.temp_dir), self.small_data))",
            "",
            "",
            "if __name__ == '__main__':",
            "    unittest.main()"
        ],
        "afterPatchFile": [
            "# SPDX-License-Identifier: Apache-2.0",
            "import tempfile",
            "import unittest",
            "import uuid",
            "",
            "import numpy as np  # type: ignore",
            "import shutil",
            "",
            "import os",
            "import os.path as Path",
            "",
            "import onnx",
            "from onnx import checker, helper, shape_inference",
            "from onnx import ModelProto, TensorProto",
            "from onnx.external_data_helper import set_external_data",
            "from onnx.external_data_helper import convert_model_to_external_data",
            "from onnx.external_data_helper import convert_model_from_external_data",
            "from onnx.external_data_helper import load_external_data_for_model, load_external_data_for_tensor",
            "from onnx.numpy_helper import to_array, from_array",
            "from typing import Any, Tuple, List",
            "import pytest  # type: ignore",
            "import sys",
            "",
            "",
            "class TestLoadExternalDataBase(unittest.TestCase):",
            "",
            "    def setUp(self) -> None:",
            "        self.temp_dir: str = tempfile.mkdtemp()",
            "        self.initializer_value = np.arange(6).reshape(3, 2).astype(np.float32) + 512",
            "        self.attribute_value = np.arange(6).reshape(2, 3).astype(np.float32) + 256",
            "        self.model_filename = self.create_test_model()",
            "",
            "    def tearDown(self) -> None:",
            "        shutil.rmtree(self.temp_dir)",
            "",
            "    def get_temp_model_filename(self) -> str:",
            "        return os.path.join(self.temp_dir, str(uuid.uuid4()) + '.onnx')",
            "",
            "    def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:",
            "        tensor = from_array(np.array(value))",
            "        tensor.name = tensor_name",
            "        tensor_filename = f\"{tensor_name}.bin\"",
            "        set_external_data(tensor, location=tensor_filename)",
            "",
            "        with open(os.path.join(self.temp_dir, tensor_filename), 'wb') as data_file:",
            "            data_file.write(tensor.raw_data)",
            "        tensor.ClearField('raw_data')",
            "        tensor.data_location = onnx.TensorProto.EXTERNAL",
            "        return tensor",
            "",
            "    def create_test_model(self) -> str:",
            "        constant_node = onnx.helper.make_node(",
            "            'Constant',",
            "            inputs=[],",
            "            outputs=['values'],",
            "            value=self.create_external_data_tensor(self.attribute_value, \"attribute_value\")",
            "        )",
            "",
            "        initializers = [self.create_external_data_tensor(self.initializer_value, \"input_value\")]",
            "        inputs = [helper.make_tensor_value_info(\"input_value\",",
            "                                                onnx.TensorProto.FLOAT,",
            "                                                self.initializer_value.shape)]",
            "",
            "        graph = helper.make_graph([constant_node], \"test_graph\",",
            "                                  inputs=inputs, outputs=[],",
            "                                  initializer=initializers)",
            "        model = helper.make_model(graph)",
            "",
            "        model_filename = os.path.join(self.temp_dir, \"model.onnx\")",
            "        with open(model_filename, \"wb\") as model_file:",
            "            model_file.write(model.SerializeToString())",
            "",
            "        return model_filename",
            "",
            "    def test_check_model(self) -> None:",
            "        checker.check_model(self.model_filename)",
            "",
            "",
            "class TestLoadExternalData(TestLoadExternalDataBase):",
            "",
            "    def test_load_external_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_load_external_data_for_model(self) -> None:",
            "        model = onnx.load_model(self.model_filename, load_external_data=False)",
            "        load_external_data_for_model(model, self.temp_dir)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_external_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "",
            "        temp_dir = os.path.join(self.temp_dir, \"save_copy\")",
            "        os.mkdir(temp_dir)",
            "        new_model_filename = os.path.join(temp_dir, 'model.onnx')",
            "        onnx.save_model(model, new_model_filename)",
            "",
            "        new_model = onnx.load_model(new_model_filename)",
            "        initializer_tensor = new_model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = new_model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "",
            "class TestLoadExternalDataSingleFile(TestLoadExternalDataBase):",
            "",
            "    def create_external_data_tensors(self, tensors_data: List[Tuple[List[Any], Any]]) -> List[TensorProto]:",
            "        tensor_filename = \"tensors.bin\"",
            "        tensors = []",
            "",
            "        with open(os.path.join(self.temp_dir, tensor_filename), 'ab') as data_file:",
            "            for (value, tensor_name) in tensors_data:",
            "                tensor = from_array(np.array(value))",
            "                offset = data_file.tell()",
            "                if offset % 4096 != 0:",
            "                    data_file.write(b\"\\0\" * (4096 - offset % 4096))",
            "                    offset = offset + 4096 - offset % 4096",
            "",
            "                data_file.write(tensor.raw_data)",
            "                set_external_data(tensor, location=tensor_filename, offset=offset, length=data_file.tell() - offset)",
            "                tensor.name = tensor_name",
            "                tensor.ClearField(\"raw_data\")",
            "                tensor.data_location = onnx.TensorProto.EXTERNAL",
            "                tensors.append(tensor)",
            "",
            "        return tensors",
            "",
            "    def test_load_external_single_file_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_external_single_file_data(self) -> None:",
            "        model = onnx.load_model(self.model_filename)",
            "",
            "        temp_dir = os.path.join(self.temp_dir, \"save_copy\")",
            "        os.mkdir(temp_dir)",
            "        new_model_filename = os.path.join(temp_dir, 'model.onnx')",
            "        onnx.save_model(model, new_model_filename)",
            "",
            "        new_model = onnx.load_model(new_model_filename)",
            "        initializer_tensor = new_model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = new_model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "",
            "class TestSaveAllTensorsAsExternalData(TestLoadExternalDataBase):",
            "",
            "    def setUp(self) -> None:",
            "        self.temp_dir: str = tempfile.mkdtemp()",
            "        self.initializer_value = np.arange(6).reshape(3, 2).astype(np.float32) + 512",
            "        self.attribute_value = np.arange(6).reshape(2, 3).astype(np.float32) + 256",
            "        self.model = self.create_test_model_proto()",
            "",
            "    def create_data_tensors(self, tensors_data: List[Tuple[List[Any], Any]]) -> List[TensorProto]:",
            "        tensors = []",
            "        for (value, tensor_name) in tensors_data:",
            "            tensor = from_array(np.array(value))",
            "            tensor.name = tensor_name",
            "            tensors.append(tensor)",
            "",
            "        return tensors",
            "",
            "    def create_test_model_proto(self) -> ModelProto:",
            "        tensors = self.create_data_tensors([",
            "            (self.attribute_value, \"attribute_value\"),",
            "            (self.initializer_value, \"input_value\"),",
            "        ])",
            "",
            "        constant_node = onnx.helper.make_node(",
            "            'Constant',",
            "            inputs=[],",
            "            outputs=['values'],",
            "            value=tensors[0]",
            "        )",
            "",
            "        inputs = [helper.make_tensor_value_info(\"input_value\",",
            "                                                onnx.TensorProto.FLOAT,",
            "                                                self.initializer_value.shape)]",
            "",
            "        graph = helper.make_graph([constant_node], \"test_graph\",",
            "                                  inputs=inputs, outputs=[],",
            "                                  initializer=[tensors[1]])",
            "        return helper.make_model(graph)",
            "",
            "    def test_check_model(self) -> None:",
            "        checker.check_model(self.model)",
            "",
            "    def test_convert_model_to_external_data_with_size_threshold(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=1024)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertFalse(initializer_tensor.HasField(\"data_location\"))",
            "",
            "    def test_convert_model_to_external_data_without_size_threshold(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        convert_model_to_external_data(self.model, size_threshold=0)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "    def test_convert_model_to_external_data_from_one_file_with_location(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        external_data_file = str(uuid.uuid4())",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True,",
            "                                       location=external_data_file)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, external_data_file)))",
            "",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        # test convert model from external data",
            "        convert_model_from_external_data(model)",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(model, model_file_path)",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertFalse(len(initializer_tensor.external_data))",
            "        self.assertEqual(initializer_tensor.data_location, TensorProto.DEFAULT)",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(len(attribute_tensor.external_data))",
            "        self.assertEqual(attribute_tensor.data_location, TensorProto.DEFAULT)",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_convert_model_to_external_data_from_one_file_without_location_uses_model_name(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=True)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, model_file_path)))",
            "",
            "    def test_convert_model_to_external_data_one_file_per_tensor_without_attribute(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False,",
            "                                       convert_attribute=False)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
            "        self.assertFalse(Path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
            "",
            "    def test_convert_model_to_external_data_one_file_per_tensor_with_attribute(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, all_tensors_to_one_file=False,",
            "                                       convert_attribute=True)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
            "",
            "    def test_convert_model_to_external_data_does_not_convert_attribute_values(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=False,",
            "                                       all_tensors_to_one_file=False)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        self.assertTrue(Path.isfile(os.path.join(self.temp_dir, \"input_value\")))",
            "        self.assertFalse(Path.isfile(os.path.join(self.temp_dir, \"attribute_value\")))",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "",
            "    def test_convert_model_to_external_data_converts_attribute_values(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "",
            "        convert_model_to_external_data(self.model, size_threshold=0, convert_attribute=True)",
            "        onnx.save_model(self.model, model_file_path)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "        self.assertTrue(attribute_tensor.HasField(\"data_location\"))",
            "",
            "    def test_save_model_does_not_convert_to_external_data_and_saves_the_model(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(self.model, model_file_path, save_as_external_data=False)",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "",
            "        model = onnx.load_model(model_file_path)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertFalse(initializer_tensor.HasField(\"data_location\"))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "",
            "    def test_save_model_does_convert_and_saves_the_model(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(self.model,",
            "                        model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=True,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=False)",
            "",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_model_without_loading_external_data(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        onnx.save_model(self.model,",
            "                        model_file_path,",
            "                        save_as_external_data=True,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=False)",
            "        # Save without load_external_data",
            "        model = onnx.load_model(model_file_path, load_external_data=False)",
            "        onnx.save_model(model,",
            "                        model_file_path,",
            "                        save_as_external_data=True,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=False)",
            "        # Load the saved model again; Only works if the saved path is under the same directory",
            "        model = onnx.load_model(model_file_path)",
            "",
            "        initializer_tensor = model.graph.initializer[0]",
            "        self.assertTrue(initializer_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(initializer_tensor), self.initializer_value))",
            "",
            "        attribute_tensor = model.graph.node[0].attribute[0].t",
            "        self.assertFalse(attribute_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(attribute_tensor), self.attribute_value))",
            "",
            "    def test_save_model_with_existing_raw_data_should_override(self) -> None:",
            "        model_file_path = self.get_temp_model_filename()",
            "        original_raw_data = self.model.graph.initializer[0].raw_data",
            "        onnx.save_model(self.model, model_file_path, save_as_external_data=True, size_threshold=0)",
            "        self.assertTrue(Path.isfile(model_file_path))",
            "",
            "        model = onnx.load_model(model_file_path, load_external_data=False)",
            "        initializer_tensor = model.graph.initializer[0]",
            "        initializer_tensor.raw_data = b'dummpy_raw_data'",
            "        # If raw_data and external tensor exist at the same time, override existing raw_data",
            "        load_external_data_for_tensor(initializer_tensor, self.temp_dir)",
            "        self.assertEqual(initializer_tensor.raw_data, original_raw_data)",
            "",
            "",
            "class TestExternalDataToArray(unittest.TestCase):",
            "    def setUp(self) -> None:",
            "        self.temp_dir: str = tempfile.mkdtemp()",
            "        self.model_file_path: str = os.path.join(self.temp_dir, 'model.onnx')",
            "        self.large_data = np.random.rand(10, 60, 100).astype(np.float32)",
            "        self.small_data = (200, 300)",
            "        self.model = self.create_test_model()",
            "",
            "    def tearDown(self) -> None:",
            "        shutil.rmtree(self.temp_dir)",
            "",
            "    def get_temp_model_filename(self) -> str:",
            "        return os.path.join(self.temp_dir, str(uuid.uuid4()) + '.onnx')",
            "",
            "    def create_test_model(self) -> ModelProto:",
            "        X = helper.make_tensor_value_info('X', TensorProto.FLOAT, self.large_data.shape)",
            "        input_init = helper.make_tensor(name='X', data_type=TensorProto.FLOAT,",
            "                                        dims=self.large_data.shape, vals=self.large_data.tobytes(), raw=True)",
            "",
            "        shape_data = np.array(self.small_data, np.int64)",
            "        shape_init = helper.make_tensor(name='Shape', data_type=TensorProto.INT64,",
            "                                        dims=shape_data.shape, vals=shape_data.tobytes(), raw=True)",
            "        C = helper.make_tensor_value_info('C', TensorProto.INT64, self.small_data)",
            "",
            "        reshape = onnx.helper.make_node(",
            "            'Reshape',",
            "            inputs=['X', 'Shape'],",
            "            outputs=['Y'],",
            "        )",
            "        cast = onnx.helper.make_node(",
            "            'Cast',",
            "            inputs=['Y'],",
            "            outputs=['C'],",
            "            to=getattr(TensorProto, 'INT64')",
            "        )",
            "",
            "        graph_def = helper.make_graph(",
            "            [reshape, cast],",
            "            'test-model',",
            "            [X],",
            "            [C],",
            "            initializer=[input_init, shape_init],",
            "        )",
            "        model = helper.make_model(graph_def, producer_name='onnx-example')",
            "        return model",
            "",
            "    def test_check_model(self) -> None:",
            "        checker.check_model(self.model)",
            "",
            "    def test_reshape_inference_with_external_data_fail(self) -> None:",
            "        onnx.save_model(self.model, self.model_file_path, save_as_external_data=True, all_tensors_to_one_file=False,",
            "                        size_threshold=0)",
            "        model_without_external_data = onnx.load(self.model_file_path, load_external_data=False)",
            "        # Shape inference of Reshape uses ParseData",
            "        # ParseData cannot handle external data and should throw the error as follows:",
            "        # Cannot parse data from external tensors. Please load external data into raw data for tensor: Shape",
            "        self.assertRaises(shape_inference.InferenceError, shape_inference.infer_shapes,",
            "                          model_without_external_data, strict_mode=True)",
            "",
            "    def test_to_array_with_external_data(self) -> None:",
            "        onnx.save_model(self.model,",
            "                        self.model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=False,",
            "                        size_threshold=0)",
            "        # raw_data of external tensor is not loaded",
            "        model = onnx.load(self.model_file_path, load_external_data=False)",
            "        # Specify self.temp_dir to load external tensor",
            "        loaded_large_data = to_array(model.graph.initializer[0], self.temp_dir)",
            "        self.assertTrue(np.allclose(loaded_large_data, self.large_data))",
            "",
            "    def test_save_model_with_external_data_multiple_times(self) -> None:",
            "        # Test onnx.save should respectively handle typical tensor and external tensor properly",
            "        # 1st save: save two tensors which have raw_data",
            "        # Only w_large will be stored as external tensors since it's larger than 1024",
            "        onnx.save_model(self.model,",
            "                        self.model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=False,",
            "                        location=None,",
            "                        size_threshold=1024,",
            "                        convert_attribute=True)",
            "        model_without_loading_external = onnx.load(self.model_file_path, load_external_data=False)",
            "        large_input_tensor = model_without_loading_external.graph.initializer[0]",
            "        self.assertTrue(large_input_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(large_input_tensor, self.temp_dir), self.large_data))",
            "",
            "        small_shape_tensor = model_without_loading_external.graph.initializer[1]",
            "        self.assertTrue(not small_shape_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(small_shape_tensor), self.small_data))",
            "",
            "        # 2nd save: one tensor has raw_data (small); one external tensor (large)",
            "        # Save them both as external tensors this time",
            "        onnx.save_model(model_without_loading_external,",
            "                        self.model_file_path,",
            "                        save_as_external_data=True,",
            "                        all_tensors_to_one_file=False,",
            "                        location=None,",
            "                        size_threshold=0,",
            "                        convert_attribute=True)",
            "",
            "        model_without_loading_external = onnx.load(self.model_file_path, load_external_data=False)",
            "        large_input_tensor = model_without_loading_external.graph.initializer[0]",
            "        self.assertTrue(large_input_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(large_input_tensor, self.temp_dir), self.large_data))",
            "",
            "        small_shape_tensor = model_without_loading_external.graph.initializer[1]",
            "        self.assertTrue(small_shape_tensor.HasField(\"data_location\"))",
            "        self.assertTrue(np.allclose(to_array(small_shape_tensor, self.temp_dir), self.small_data))",
            "",
            "",
            "class TestNotAllowToLoadExternalDataOutsideModelDirectory(TestLoadExternalDataBase):",
            "    \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model",
            "    directory. \"\"\"",
            "",
            "    def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:",
            "        tensor = from_array(np.array(value))",
            "        tensor.name = tensor_name",
            "",
            "        set_external_data(tensor, location=\"../../file.bin\")",
            "",
            "        tensor.ClearField('raw_data')",
            "        tensor.data_location = onnx.TensorProto.EXTERNAL",
            "        return tensor",
            "",
            "    def test_check_model(self) -> None:",
            "        \"\"\"We only test the model validation as onnxruntime uses this to load the model. \"\"\"",
            "        with self.assertRaises(onnx.checker.ValidationError):",
            "            checker.check_model(self.model_filename)",
            "",
            "",
            "@pytest.mark.skipif(os.name != 'nt', reason='Skip Windows test')",
            "class TestNotAllowToLoadExternalDataOutsideModelDirectoryOnWindows(TestLoadExternalDataBase):",
            "    \"\"\"Essential test to check that onnx (validate) C++ code will not allow to load external_data outside the model",
            "    directory. \"\"\"",
            "",
            "    def create_external_data_tensor(self, value: List[Any], tensor_name: str) -> TensorProto:",
            "        tensor = from_array(np.array(value))",
            "        tensor.name = tensor_name",
            "",
            "        set_external_data(tensor, location=\"..\\\\..\\\\file.bin\")",
            "",
            "        tensor.ClearField('raw_data')",
            "        tensor.data_location = onnx.TensorProto.EXTERNAL",
            "        return tensor",
            "",
            "    def test_check_model(self) -> None:",
            "        \"\"\"We only test the model validation as onnxruntime uses this to load the model. \"\"\"",
            "        with self.assertRaises(onnx.checker.ValidationError):",
            "            checker.check_model(self.model_filename)",
            "",
            "",
            "if __name__ == '__main__':",
            "    unittest.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "52": [
                "TestLoadExternalDataBase",
                "create_test_model"
            ],
            "229": [
                "TestSaveAllTensorsAsExternalData",
                "test_convert_model_to_external_data_from_one_file_with_location"
            ],
            "263": [
                "TestSaveAllTensorsAsExternalData",
                "test_convert_model_to_external_data_one_file_per_tensor_without_attribute"
            ],
            "273": [
                "TestSaveAllTensorsAsExternalData",
                "test_convert_model_to_external_data_one_file_per_tensor_with_attribute"
            ],
            "283": [
                "TestSaveAllTensorsAsExternalData",
                "test_convert_model_to_external_data_does_not_convert_attribute_values"
            ],
            "402": [
                "TestExternalDataToArray",
                "create_test_model"
            ],
            "406": [
                "TestExternalDataToArray",
                "create_test_model"
            ],
            "435": [
                "TestExternalDataToArray",
                "test_reshape_inference_with_external_data_fail"
            ],
            "441": [
                "TestExternalDataToArray",
                "test_reshape_inference_with_external_data_fail"
            ]
        },
        "addLocation": []
    }
}