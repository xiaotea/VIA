{
    "vncap/tests/test_protocol.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     def loseConnection(self):"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "         self.lost = True"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    def pauseProducing(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+        pass"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " class TestVNCServerAuthenticator(unittest.TestCase):"
            },
            "7": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     def setUp(self):"
            },
            "9": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     def test_check_version(self):"
            },
            "10": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         self.t.buf = \"\""
            },
            "11": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         self.p.check_version(\"RFB 003.008\\n\")"
            },
            "12": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual(self.t.buf, \"\\x02\\x01\\x02\")"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        self.assertEqual(self.t.buf, \"\\x01\\x02\")"
            },
            "14": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     def test_check_invalid_version(self):"
            },
            "16": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         self.t.buf = \"\""
            },
            "17": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         self.p.check_version(\"RFB 002.000\\n\")"
            },
            "18": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         self.assertTrue(self.t.lost)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    def test_select_security_type_none(self):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        self.t.buf = \"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        self.p.select_security_type(\"\\x01\")"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        self.assertTrue(self.t.lost)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    def test_select_security_type_vnc_auth(self):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        self.t.buf = \"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        self.p.select_security_type(\"\\x02\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        self.assertFalse(self.t.lost)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        self.assertEqual(len(self.t.buf), 16)"
            }
        },
        "frontPatchFile": [
            "import unittest",
            "",
            "from vncap.vnc.protocol import VNCServerAuthenticator",
            "",
            "class DummyTransport(object):",
            "",
            "    buf = \"\"",
            "    lost = False",
            "",
            "    def write(self, data):",
            "        self.buf += data",
            "",
            "    def loseConnection(self):",
            "        self.lost = True",
            "",
            "class TestVNCServerAuthenticator(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.p = VNCServerAuthenticator(\"password\", {})",
            "        self.t = DummyTransport()",
            "        self.p.makeConnection(self.t)",
            "",
            "    def test_trivial(self):",
            "        pass",
            "",
            "    def test_connectionMade(self):",
            "        self.assertEqual(self.t.buf, \"RFB 003.008\\n\")",
            "",
            "    def test_check_version(self):",
            "        self.t.buf = \"\"",
            "        self.p.check_version(\"RFB 003.008\\n\")",
            "        self.assertEqual(self.t.buf, \"\\x02\\x01\\x02\")",
            "",
            "    def test_check_invalid_version(self):",
            "        self.t.buf = \"\"",
            "        self.p.check_version(\"RFB 002.000\\n\")",
            "        self.assertTrue(self.t.lost)"
        ],
        "afterPatchFile": [
            "import unittest",
            "",
            "from vncap.vnc.protocol import VNCServerAuthenticator",
            "",
            "class DummyTransport(object):",
            "",
            "    buf = \"\"",
            "    lost = False",
            "",
            "    def write(self, data):",
            "        self.buf += data",
            "",
            "    def loseConnection(self):",
            "        self.lost = True",
            "",
            "    def pauseProducing(self):",
            "        pass",
            "",
            "class TestVNCServerAuthenticator(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.p = VNCServerAuthenticator(\"password\", {})",
            "        self.t = DummyTransport()",
            "        self.p.makeConnection(self.t)",
            "",
            "    def test_trivial(self):",
            "        pass",
            "",
            "    def test_connectionMade(self):",
            "        self.assertEqual(self.t.buf, \"RFB 003.008\\n\")",
            "",
            "    def test_check_version(self):",
            "        self.t.buf = \"\"",
            "        self.p.check_version(\"RFB 003.008\\n\")",
            "        self.assertEqual(self.t.buf, \"\\x01\\x02\")",
            "",
            "    def test_check_invalid_version(self):",
            "        self.t.buf = \"\"",
            "        self.p.check_version(\"RFB 002.000\\n\")",
            "        self.assertTrue(self.t.lost)",
            "",
            "    def test_select_security_type_none(self):",
            "        self.t.buf = \"\"",
            "        self.p.select_security_type(\"\\x01\")",
            "        self.assertTrue(self.t.lost)",
            "",
            "    def test_select_security_type_vnc_auth(self):",
            "        self.t.buf = \"\"",
            "        self.p.select_security_type(\"\\x02\")",
            "        self.assertFalse(self.t.lost)",
            "        self.assertEqual(len(self.t.buf), 16)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "32": [
                "TestVNCServerAuthenticator",
                "test_check_version"
            ]
        },
        "addLocation": []
    },
    "vncap/vnc/protocol.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         if version == self.VERSION:"
            },
            "2": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "             log.msg(\"Client version %s is valid\" % version.strip())"
            },
            "3": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Hardcoded: 2 security types: None and VNC Auth."
            },
            "4": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.transport.write(\"\\x02\\x01\\x02\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            # Hardcoded: 1 security type: VNC Auth."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            self.transport.write(\"\\x01\\x02\")"
            },
            "7": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "             return self.select_security_type, 1"
            },
            "8": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         else:"
            },
            "9": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "             log.err(\"Can't handle VNC version %r\" % version)"
            },
            "10": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             self.transport.write(self.challenge)"
            },
            "11": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             return self.vnc_authentication_result, 16"
            },
            "13": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif security_type == 1:"
            },
            "14": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # No authentication. Just move to the SecurityResult."
            },
            "15": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.authenticated()"
            },
            "16": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         else:"
            },
            "17": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "             log.err(\"Couldn't agree on an authentication scheme!\")"
            },
            "18": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             self.transport.loseConnection()"
            }
        },
        "frontPatchFile": [
            "from os import urandom",
            "",
            "from twisted.internet import reactor",
            "from twisted.internet.defer import Deferred",
            "from twisted.protocols.stateful import StatefulProtocol",
            "from twisted.python import log",
            "",
            "from vncap.vnc.d3des import generate_response",
            "",
            "def check_password(challenge, response, password):",
            "    password = password.ljust(8, \"\\x00\")[:8]",
            "    return generate_response(password, challenge) == response",
            "",
            "(",
            "    STATE_VERSION,",
            "    STATE_SECURITY_TYPES,",
            "    STATE_AUTHENTICATION,",
            "    STATE_RESULT,",
            "    STATE_CONNECTED",
            ") = range(5)",
            "",
            "class VNCAuthenticator(StatefulProtocol):",
            "    \"\"\"",
            "    Base class for VNC protocols.",
            "",
            "    This protocol isn't interesting on its own; subclass it to make a server",
            "    or client.",
            "    \"\"\"",
            "",
            "    VERSION = \"RFB 003.008\\n\"",
            "",
            "    def __init__(self, password):",
            "        self.password = password",
            "        self.authentication_d = Deferred()",
            "",
            "    def authenticated(self):",
            "        \"\"\"",
            "        Switch to proxy mode.",
            "        \"\"\"",
            "",
            "        log.msg(\"Successfully authenticated %s!\" % self)",
            "        self.transport.pauseProducing()",
            "        reactor.callLater(0, self.authentication_d.callback, self)",
            "",
            "class VNCServerAuthenticator(VNCAuthenticator):",
            "    \"\"\"",
            "    Trivial server protocol which can authenticate VNC clients.",
            "",
            "    This protocol is lacking lots of things, like support for older VNC",
            "    protocols.",
            "    \"\"\"",
            "",
            "    def __init__(self, password, options):",
            "        VNCAuthenticator.__init__(self, password)",
            "        self.options = options",
            "",
            "        if 'password' in options:",
            "            self.password = options['password']",
            "",
            "    def connectionMade(self):",
            "        log.msg(\"Received incoming connection\")",
            "        self.transport.write(self.VERSION)",
            "",
            "    def getInitialState(self):",
            "        self.verify_ip()",
            "        return self.check_version, 12",
            "",
            "    def check_version(self, version):",
            "        \"\"\"",
            "        Determine the client's version and decide whether to continue the",
            "        handshake.",
            "        \"\"\"",
            "",
            "        if version == self.VERSION:",
            "            log.msg(\"Client version %s is valid\" % version.strip())",
            "            # Hardcoded: 2 security types: None and VNC Auth.",
            "            self.transport.write(\"\\x02\\x01\\x02\")",
            "            return self.select_security_type, 1",
            "        else:",
            "            log.err(\"Can't handle VNC version %r\" % version)",
            "            self.transport.loseConnection()",
            "",
            "    def select_security_type(self, security_type):",
            "        \"\"\"",
            "        Choose the security type that the client wants.",
            "        \"\"\"",
            "",
            "        security_type = ord(security_type)",
            "",
            "        if security_type == 2:",
            "            # VNC authentication. Issue our challenge.",
            "            self.challenge = urandom(16)",
            "            self.transport.write(self.challenge)",
            "",
            "            return self.vnc_authentication_result, 16",
            "        elif security_type == 1:",
            "            # No authentication. Just move to the SecurityResult.",
            "            self.authenticated()",
            "        else:",
            "            log.err(\"Couldn't agree on an authentication scheme!\")",
            "            self.transport.loseConnection()",
            "",
            "    def vnc_authentication_result(self, response):",
            "        log.msg(\"Doing VNC auth, buf %r\" % response)",
            "",
            "        if check_password(self.challenge, response, self.password):",
            "            self.authenticated()",
            "        else:",
            "            log.err(\"Failed VNC auth!\")",
            "            self.transport.loseConnection()",
            "",
            "    def verify_ip(self):",
            "        if 'ip' in self.options:",
            "            if self.options['ip'] != self.transport.getPeer().host:",
            "                log.err(\"Failed to verify client IP\")",
            "                self.transport.loseConnection()",
            "            else:",
            "                log.msg(\"Verified client IP\")",
            "",
            "    def authenticated(self):",
            "        log.msg(\"Successfully authenticated a client!\")",
            "        # Send a u32 0, for success.",
            "        self.transport.write(\"\\x00\\x00\\x00\\x00\")",
            "        VNCAuthenticator.authenticated(self)",
            "",
            "class VNCClientAuthenticator(VNCAuthenticator):",
            "    \"\"\"",
            "    Trivial client protocol which can authenticate itself to a VNC server.",
            "",
            "    This protocol is lacking lots of things, like support for older VNC",
            "    protocols.",
            "    \"\"\"",
            "",
            "    def getInitialState(self):",
            "        return self.check_version, 12",
            "",
            "    def check_version(self, version):",
            "        if version == self.VERSION:",
            "            log.msg(\"Server version %s is valid\" % version.strip())",
            "            self.transport.write(self.VERSION)",
            "            return self.count_security_types, 1",
            "        else:",
            "            log.err(\"Can't handle VNC version %r\" % version)",
            "            self.transport.loseConnection()",
            "",
            "    def count_security_types(self, data):",
            "        count = ord(data)",
            "",
            "        if not count:",
            "            log.err(\"Server wouldn't give us any security types!\")",
            "            self.transport.loseConnection()",
            "",
            "        return self.pick_security_type, count",
            "",
            "    def pick_security_type(self, data):",
            "        \"\"\"",
            "        Ascertain whether the server supports any security types we might",
            "        want.",
            "        \"\"\"",
            "",
            "        security_types = set(ord(i) for i in data)",
            "        log.msg(\"Available authentication methods: %s\"",
            "            % \", \".join(hex(i) for i in security_types))",
            "",
            "        if 2 in security_types:",
            "            log.msg(\"Choosing VNC authentication...\")",
            "            self.transport.write(\"\\x02\")",
            "            return self.vnc_authentication, 16",
            "        elif 1 in security_types:",
            "            log.msg(\"Choosing no authentication...\")",
            "            self.transport.write(\"\\x01\")",
            "            return self.security_result, 4",
            "        else:",
            "            log.err(\"Couldn't agree on an authentication scheme!\")",
            "            self.transport.loseConnection()",
            "",
            "    def vnc_authentication(self, challenge):",
            "        # Take in 16 bytes, encrypt with 3DES using the password as the key,",
            "        # and send the response.",
            "",
            "        response = generate_response(self.password, challenge)",
            "        self.transport.write(response)",
            "",
            "        return self.security_result, 4",
            "",
            "    def security_result(self, data):",
            "        if data == \"\\x00\\x00\\x00\\x00\":",
            "            # Success!",
            "            log.msg(\"Successfully authenticated to the server!\")",
            "            self.authenticated()",
            "        else:",
            "            log.err(\"Failed security result!\")",
            "            self.transport.loseConnection()"
        ],
        "afterPatchFile": [
            "from os import urandom",
            "",
            "from twisted.internet import reactor",
            "from twisted.internet.defer import Deferred",
            "from twisted.protocols.stateful import StatefulProtocol",
            "from twisted.python import log",
            "",
            "from vncap.vnc.d3des import generate_response",
            "",
            "def check_password(challenge, response, password):",
            "    password = password.ljust(8, \"\\x00\")[:8]",
            "    return generate_response(password, challenge) == response",
            "",
            "(",
            "    STATE_VERSION,",
            "    STATE_SECURITY_TYPES,",
            "    STATE_AUTHENTICATION,",
            "    STATE_RESULT,",
            "    STATE_CONNECTED",
            ") = range(5)",
            "",
            "class VNCAuthenticator(StatefulProtocol):",
            "    \"\"\"",
            "    Base class for VNC protocols.",
            "",
            "    This protocol isn't interesting on its own; subclass it to make a server",
            "    or client.",
            "    \"\"\"",
            "",
            "    VERSION = \"RFB 003.008\\n\"",
            "",
            "    def __init__(self, password):",
            "        self.password = password",
            "        self.authentication_d = Deferred()",
            "",
            "    def authenticated(self):",
            "        \"\"\"",
            "        Switch to proxy mode.",
            "        \"\"\"",
            "",
            "        log.msg(\"Successfully authenticated %s!\" % self)",
            "        self.transport.pauseProducing()",
            "        reactor.callLater(0, self.authentication_d.callback, self)",
            "",
            "class VNCServerAuthenticator(VNCAuthenticator):",
            "    \"\"\"",
            "    Trivial server protocol which can authenticate VNC clients.",
            "",
            "    This protocol is lacking lots of things, like support for older VNC",
            "    protocols.",
            "    \"\"\"",
            "",
            "    def __init__(self, password, options):",
            "        VNCAuthenticator.__init__(self, password)",
            "        self.options = options",
            "",
            "        if 'password' in options:",
            "            self.password = options['password']",
            "",
            "    def connectionMade(self):",
            "        log.msg(\"Received incoming connection\")",
            "        self.transport.write(self.VERSION)",
            "",
            "    def getInitialState(self):",
            "        self.verify_ip()",
            "        return self.check_version, 12",
            "",
            "    def check_version(self, version):",
            "        \"\"\"",
            "        Determine the client's version and decide whether to continue the",
            "        handshake.",
            "        \"\"\"",
            "",
            "        if version == self.VERSION:",
            "            log.msg(\"Client version %s is valid\" % version.strip())",
            "            # Hardcoded: 1 security type: VNC Auth.",
            "            self.transport.write(\"\\x01\\x02\")",
            "            return self.select_security_type, 1",
            "        else:",
            "            log.err(\"Can't handle VNC version %r\" % version)",
            "            self.transport.loseConnection()",
            "",
            "    def select_security_type(self, security_type):",
            "        \"\"\"",
            "        Choose the security type that the client wants.",
            "        \"\"\"",
            "",
            "        security_type = ord(security_type)",
            "",
            "        if security_type == 2:",
            "            # VNC authentication. Issue our challenge.",
            "            self.challenge = urandom(16)",
            "            self.transport.write(self.challenge)",
            "",
            "            return self.vnc_authentication_result, 16",
            "        else:",
            "            log.err(\"Couldn't agree on an authentication scheme!\")",
            "            self.transport.loseConnection()",
            "",
            "    def vnc_authentication_result(self, response):",
            "        log.msg(\"Doing VNC auth, buf %r\" % response)",
            "",
            "        if check_password(self.challenge, response, self.password):",
            "            self.authenticated()",
            "        else:",
            "            log.err(\"Failed VNC auth!\")",
            "            self.transport.loseConnection()",
            "",
            "    def verify_ip(self):",
            "        if 'ip' in self.options:",
            "            if self.options['ip'] != self.transport.getPeer().host:",
            "                log.err(\"Failed to verify client IP\")",
            "                self.transport.loseConnection()",
            "            else:",
            "                log.msg(\"Verified client IP\")",
            "",
            "    def authenticated(self):",
            "        log.msg(\"Successfully authenticated a client!\")",
            "        # Send a u32 0, for success.",
            "        self.transport.write(\"\\x00\\x00\\x00\\x00\")",
            "        VNCAuthenticator.authenticated(self)",
            "",
            "class VNCClientAuthenticator(VNCAuthenticator):",
            "    \"\"\"",
            "    Trivial client protocol which can authenticate itself to a VNC server.",
            "",
            "    This protocol is lacking lots of things, like support for older VNC",
            "    protocols.",
            "    \"\"\"",
            "",
            "    def getInitialState(self):",
            "        return self.check_version, 12",
            "",
            "    def check_version(self, version):",
            "        if version == self.VERSION:",
            "            log.msg(\"Server version %s is valid\" % version.strip())",
            "            self.transport.write(self.VERSION)",
            "            return self.count_security_types, 1",
            "        else:",
            "            log.err(\"Can't handle VNC version %r\" % version)",
            "            self.transport.loseConnection()",
            "",
            "    def count_security_types(self, data):",
            "        count = ord(data)",
            "",
            "        if not count:",
            "            log.err(\"Server wouldn't give us any security types!\")",
            "            self.transport.loseConnection()",
            "",
            "        return self.pick_security_type, count",
            "",
            "    def pick_security_type(self, data):",
            "        \"\"\"",
            "        Ascertain whether the server supports any security types we might",
            "        want.",
            "        \"\"\"",
            "",
            "        security_types = set(ord(i) for i in data)",
            "        log.msg(\"Available authentication methods: %s\"",
            "            % \", \".join(hex(i) for i in security_types))",
            "",
            "        if 2 in security_types:",
            "            log.msg(\"Choosing VNC authentication...\")",
            "            self.transport.write(\"\\x02\")",
            "            return self.vnc_authentication, 16",
            "        elif 1 in security_types:",
            "            log.msg(\"Choosing no authentication...\")",
            "            self.transport.write(\"\\x01\")",
            "            return self.security_result, 4",
            "        else:",
            "            log.err(\"Couldn't agree on an authentication scheme!\")",
            "            self.transport.loseConnection()",
            "",
            "    def vnc_authentication(self, challenge):",
            "        # Take in 16 bytes, encrypt with 3DES using the password as the key,",
            "        # and send the response.",
            "",
            "        response = generate_response(self.password, challenge)",
            "        self.transport.write(response)",
            "",
            "        return self.security_result, 4",
            "",
            "    def security_result(self, data):",
            "        if data == \"\\x00\\x00\\x00\\x00\":",
            "            # Success!",
            "            log.msg(\"Successfully authenticated to the server!\")",
            "            self.authenticated()",
            "        else:",
            "            log.err(\"Failed security result!\")",
            "            self.transport.loseConnection()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "76": [
                "VNCServerAuthenticator",
                "check_version"
            ],
            "77": [
                "VNCServerAuthenticator",
                "check_version"
            ],
            "96": [
                "VNCServerAuthenticator",
                "select_security_type"
            ],
            "97": [
                "VNCServerAuthenticator",
                "select_security_type"
            ],
            "98": [
                "VNCServerAuthenticator",
                "select_security_type"
            ]
        },
        "addLocation": []
    }
}