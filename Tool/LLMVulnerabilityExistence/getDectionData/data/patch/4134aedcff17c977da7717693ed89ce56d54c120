{
    "src/RestrictedPython/Guards.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/"
            },
            "1": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 247,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "     \"\"\""
            },
            "3": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if isinstance(object, str) and name == 'format':"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    if name in ('format', 'format_map') and ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+            isinstance(object, str) or"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            (isinstance(object, type) and issubclass(object, str))):"
            },
            "7": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         raise NotImplementedError("
            },
            "8": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'Using format() on a %s is not safe.' % object.__class__.__name__)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            'Using the format*() methods of `str` is not safe')"
            },
            "10": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     if name.startswith('_'):"
            },
            "11": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         raise AttributeError("
            },
            "12": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "             '\"{name}\" is an invalid attribute name because it '"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "# This tiny set of safe builtins is extended by users of the module.",
            "# AccessControl.ZopeGuards contains a large set of wrappers for builtins.",
            "# DocumentTemplate.DT_UTil contains a few.",
            "",
            "import builtins",
            "",
            "from RestrictedPython._compat import IS_PY311_OR_GREATER",
            "",
            "",
            "safe_builtins = {}",
            "",
            "_safe_names = [",
            "    '__build_class__',",
            "    'None',",
            "    'False',",
            "    'True',",
            "    'abs',",
            "    'bool',",
            "    'bytes',",
            "    'callable',",
            "    'chr',",
            "    'complex',",
            "    'divmod',",
            "    'float',",
            "    'hash',",
            "    'hex',",
            "    'id',",
            "    'int',",
            "    'isinstance',",
            "    'issubclass',",
            "    'len',",
            "    'oct',",
            "    'ord',",
            "    'pow',",
            "    'range',",
            "    'repr',",
            "    'round',",
            "    'slice',",
            "    'sorted',",
            "    'str',",
            "    'tuple',",
            "    'zip'",
            "]",
            "",
            "_safe_exceptions = [",
            "    'ArithmeticError',",
            "    'AssertionError',",
            "    'AttributeError',",
            "    'BaseException',",
            "    'BufferError',",
            "    'BytesWarning',",
            "    'DeprecationWarning',",
            "    'EOFError',",
            "    'EnvironmentError',",
            "    'Exception',",
            "    'FloatingPointError',",
            "    'FutureWarning',",
            "    'GeneratorExit',",
            "    'IOError',",
            "    'ImportError',",
            "    'ImportWarning',",
            "    'IndentationError',",
            "    'IndexError',",
            "    'KeyError',",
            "    'KeyboardInterrupt',",
            "    'LookupError',",
            "    'MemoryError',",
            "    'NameError',",
            "    'NotImplementedError',",
            "    'OSError',",
            "    'OverflowError',",
            "    'PendingDeprecationWarning',",
            "    'ReferenceError',",
            "    'RuntimeError',",
            "    'RuntimeWarning',",
            "    'StopIteration',",
            "    'SyntaxError',",
            "    'SyntaxWarning',",
            "    'SystemError',",
            "    'SystemExit',",
            "    'TabError',",
            "    'TypeError',",
            "    'UnboundLocalError',",
            "    'UnicodeDecodeError',",
            "    'UnicodeEncodeError',",
            "    'UnicodeError',",
            "    'UnicodeTranslateError',",
            "    'UnicodeWarning',",
            "    'UserWarning',",
            "    'ValueError',",
            "    'Warning',",
            "    'ZeroDivisionError',",
            "]",
            "",
            "if IS_PY311_OR_GREATER:",
            "    _safe_exceptions.append(\"ExceptionGroup\")",
            "",
            "for name in _safe_names:",
            "    safe_builtins[name] = getattr(builtins, name)",
            "",
            "for name in _safe_exceptions:",
            "    safe_builtins[name] = getattr(builtins, name)",
            "",
            "",
            "# Wrappers provided by this module:",
            "# delattr",
            "# setattr",
            "",
            "# Wrappers provided by ZopeGuards:",
            "# __import__",
            "# apply",
            "# dict",
            "# enumerate",
            "# filter",
            "# getattr",
            "# hasattr",
            "# iter",
            "# list",
            "# map",
            "# max",
            "# min",
            "# sum",
            "# all",
            "# any",
            "",
            "# Builtins that are intentionally disabled",
            "# compile   - don't let them produce new code",
            "# dir       - a general purpose introspector, probably hard to wrap",
            "# execfile  - no direct I/O",
            "# file      - no direct I/O",
            "# globals   - uncontrolled namespace access",
            "# input     - no direct I/O",
            "# locals    - uncontrolled namespace access",
            "# open      - no direct I/O",
            "# raw_input - no direct I/O",
            "# vars      - uncontrolled namespace access",
            "",
            "# There are several strings that describe Python.  I think there's no",
            "# point to including these, although they are obviously safe:",
            "# copyright, credits, exit, help, license, quit",
            "",
            "# Not provided anywhere.  Do something about these?  Several are",
            "# related to new-style classes, which we are too scared of to support",
            "# <0.3 wink>.  coerce, buffer, and reload are esoteric enough that no",
            "# one should care.",
            "",
            "# buffer",
            "# bytearray",
            "# classmethod",
            "# coerce",
            "# eval",
            "# intern",
            "# memoryview",
            "# object",
            "# property",
            "# reload",
            "# staticmethod",
            "# super",
            "# type",
            "",
            "",
            "def _write_wrapper():",
            "    # Construct the write wrapper class",
            "    def _handler(secattr, error_msg):",
            "        # Make a class method.",
            "        def handler(self, *args):",
            "            try:",
            "                f = getattr(self.ob, secattr)",
            "            except AttributeError:",
            "                raise TypeError(error_msg)",
            "            f(*args)",
            "        return handler",
            "",
            "    class Wrapper:",
            "        def __init__(self, ob):",
            "            self.__dict__['ob'] = ob",
            "",
            "        __setitem__ = _handler(",
            "            '__guarded_setitem__',",
            "            'object does not support item or slice assignment')",
            "",
            "        __delitem__ = _handler(",
            "            '__guarded_delitem__',",
            "            'object does not support item or slice assignment')",
            "",
            "        __setattr__ = _handler(",
            "            '__guarded_setattr__',",
            "            'attribute-less object (assign or del)')",
            "",
            "        __delattr__ = _handler(",
            "            '__guarded_delattr__',",
            "            'attribute-less object (assign or del)')",
            "    return Wrapper",
            "",
            "",
            "def _full_write_guard():",
            "    # Nested scope abuse!",
            "    # safetypes and Wrapper variables are used by guard()",
            "    safetypes = {dict, list}",
            "    Wrapper = _write_wrapper()",
            "",
            "    def guard(ob):",
            "        # Don't bother wrapping simple types, or objects that claim to",
            "        # handle their own write security.",
            "        if type(ob) in safetypes or hasattr(ob, '_guarded_writes'):",
            "            return ob",
            "        # Hand the object to the Wrapper instance, then return the instance.",
            "        return Wrapper(ob)",
            "    return guard",
            "",
            "",
            "full_write_guard = _full_write_guard()",
            "",
            "",
            "def guarded_setattr(object, name, value):",
            "    setattr(full_write_guard(object), name, value)",
            "",
            "",
            "safe_builtins['setattr'] = guarded_setattr",
            "",
            "",
            "def guarded_delattr(object, name):",
            "    delattr(full_write_guard(object), name)",
            "",
            "",
            "safe_builtins['delattr'] = guarded_delattr",
            "",
            "",
            "def safer_getattr(object, name, default=None, getattr=getattr):",
            "    \"\"\"Getattr implementation which prevents using format on string objects.",
            "",
            "    format() is considered harmful:",
            "    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/",
            "",
            "    \"\"\"",
            "    if isinstance(object, str) and name == 'format':",
            "        raise NotImplementedError(",
            "            'Using format() on a %s is not safe.' % object.__class__.__name__)",
            "    if name.startswith('_'):",
            "        raise AttributeError(",
            "            '\"{name}\" is an invalid attribute name because it '",
            "            'starts with \"_\"'.format(name=name)",
            "        )",
            "    return getattr(object, name, default)",
            "",
            "",
            "safe_builtins['_getattr_'] = safer_getattr",
            "",
            "",
            "def guarded_iter_unpack_sequence(it, spec, _getiter_):",
            "    \"\"\"Protect sequence unpacking of targets in a 'for loop'.",
            "",
            "    The target of a for loop could be a sequence.",
            "    For example \"for a, b in it\"",
            "    => Each object from the iterator needs guarded sequence unpacking.",
            "    \"\"\"",
            "    # The iteration itself needs to be protected as well.",
            "    for ob in _getiter_(it):",
            "        yield guarded_unpack_sequence(ob, spec, _getiter_)",
            "",
            "",
            "def guarded_unpack_sequence(it, spec, _getiter_):",
            "    \"\"\"Protect nested sequence unpacking.",
            "",
            "    Protect the unpacking of 'it' by wrapping it with '_getiter_'.",
            "    Furthermore for each child element, defined by spec,",
            "    guarded_unpack_sequence is called again.",
            "",
            "    Have a look at transformer.py 'gen_unpack_spec' for a more detailed",
            "    explanation.",
            "    \"\"\"",
            "    # Do the guarded unpacking of the sequence.",
            "    ret = list(_getiter_(it))",
            "",
            "    # If the sequence is shorter then expected the interpreter will raise",
            "    # 'ValueError: need more than X value to unpack' anyway",
            "    # => No childs are unpacked => nothing to protect.",
            "    if len(ret) < spec['min_len']:",
            "        return ret",
            "",
            "    # For all child elements do the guarded unpacking again.",
            "    for (idx, child_spec) in spec['childs']:",
            "        ret[idx] = guarded_unpack_sequence(ret[idx], child_spec, _getiter_)",
            "",
            "    return ret",
            "",
            "",
            "safe_globals = {'__builtins__': safe_builtins}"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "# This tiny set of safe builtins is extended by users of the module.",
            "# AccessControl.ZopeGuards contains a large set of wrappers for builtins.",
            "# DocumentTemplate.DT_UTil contains a few.",
            "",
            "import builtins",
            "",
            "from RestrictedPython._compat import IS_PY311_OR_GREATER",
            "",
            "",
            "safe_builtins = {}",
            "",
            "_safe_names = [",
            "    '__build_class__',",
            "    'None',",
            "    'False',",
            "    'True',",
            "    'abs',",
            "    'bool',",
            "    'bytes',",
            "    'callable',",
            "    'chr',",
            "    'complex',",
            "    'divmod',",
            "    'float',",
            "    'hash',",
            "    'hex',",
            "    'id',",
            "    'int',",
            "    'isinstance',",
            "    'issubclass',",
            "    'len',",
            "    'oct',",
            "    'ord',",
            "    'pow',",
            "    'range',",
            "    'repr',",
            "    'round',",
            "    'slice',",
            "    'sorted',",
            "    'str',",
            "    'tuple',",
            "    'zip'",
            "]",
            "",
            "_safe_exceptions = [",
            "    'ArithmeticError',",
            "    'AssertionError',",
            "    'AttributeError',",
            "    'BaseException',",
            "    'BufferError',",
            "    'BytesWarning',",
            "    'DeprecationWarning',",
            "    'EOFError',",
            "    'EnvironmentError',",
            "    'Exception',",
            "    'FloatingPointError',",
            "    'FutureWarning',",
            "    'GeneratorExit',",
            "    'IOError',",
            "    'ImportError',",
            "    'ImportWarning',",
            "    'IndentationError',",
            "    'IndexError',",
            "    'KeyError',",
            "    'KeyboardInterrupt',",
            "    'LookupError',",
            "    'MemoryError',",
            "    'NameError',",
            "    'NotImplementedError',",
            "    'OSError',",
            "    'OverflowError',",
            "    'PendingDeprecationWarning',",
            "    'ReferenceError',",
            "    'RuntimeError',",
            "    'RuntimeWarning',",
            "    'StopIteration',",
            "    'SyntaxError',",
            "    'SyntaxWarning',",
            "    'SystemError',",
            "    'SystemExit',",
            "    'TabError',",
            "    'TypeError',",
            "    'UnboundLocalError',",
            "    'UnicodeDecodeError',",
            "    'UnicodeEncodeError',",
            "    'UnicodeError',",
            "    'UnicodeTranslateError',",
            "    'UnicodeWarning',",
            "    'UserWarning',",
            "    'ValueError',",
            "    'Warning',",
            "    'ZeroDivisionError',",
            "]",
            "",
            "if IS_PY311_OR_GREATER:",
            "    _safe_exceptions.append(\"ExceptionGroup\")",
            "",
            "for name in _safe_names:",
            "    safe_builtins[name] = getattr(builtins, name)",
            "",
            "for name in _safe_exceptions:",
            "    safe_builtins[name] = getattr(builtins, name)",
            "",
            "",
            "# Wrappers provided by this module:",
            "# delattr",
            "# setattr",
            "",
            "# Wrappers provided by ZopeGuards:",
            "# __import__",
            "# apply",
            "# dict",
            "# enumerate",
            "# filter",
            "# getattr",
            "# hasattr",
            "# iter",
            "# list",
            "# map",
            "# max",
            "# min",
            "# sum",
            "# all",
            "# any",
            "",
            "# Builtins that are intentionally disabled",
            "# compile   - don't let them produce new code",
            "# dir       - a general purpose introspector, probably hard to wrap",
            "# execfile  - no direct I/O",
            "# file      - no direct I/O",
            "# globals   - uncontrolled namespace access",
            "# input     - no direct I/O",
            "# locals    - uncontrolled namespace access",
            "# open      - no direct I/O",
            "# raw_input - no direct I/O",
            "# vars      - uncontrolled namespace access",
            "",
            "# There are several strings that describe Python.  I think there's no",
            "# point to including these, although they are obviously safe:",
            "# copyright, credits, exit, help, license, quit",
            "",
            "# Not provided anywhere.  Do something about these?  Several are",
            "# related to new-style classes, which we are too scared of to support",
            "# <0.3 wink>.  coerce, buffer, and reload are esoteric enough that no",
            "# one should care.",
            "",
            "# buffer",
            "# bytearray",
            "# classmethod",
            "# coerce",
            "# eval",
            "# intern",
            "# memoryview",
            "# object",
            "# property",
            "# reload",
            "# staticmethod",
            "# super",
            "# type",
            "",
            "",
            "def _write_wrapper():",
            "    # Construct the write wrapper class",
            "    def _handler(secattr, error_msg):",
            "        # Make a class method.",
            "        def handler(self, *args):",
            "            try:",
            "                f = getattr(self.ob, secattr)",
            "            except AttributeError:",
            "                raise TypeError(error_msg)",
            "            f(*args)",
            "        return handler",
            "",
            "    class Wrapper:",
            "        def __init__(self, ob):",
            "            self.__dict__['ob'] = ob",
            "",
            "        __setitem__ = _handler(",
            "            '__guarded_setitem__',",
            "            'object does not support item or slice assignment')",
            "",
            "        __delitem__ = _handler(",
            "            '__guarded_delitem__',",
            "            'object does not support item or slice assignment')",
            "",
            "        __setattr__ = _handler(",
            "            '__guarded_setattr__',",
            "            'attribute-less object (assign or del)')",
            "",
            "        __delattr__ = _handler(",
            "            '__guarded_delattr__',",
            "            'attribute-less object (assign or del)')",
            "    return Wrapper",
            "",
            "",
            "def _full_write_guard():",
            "    # Nested scope abuse!",
            "    # safetypes and Wrapper variables are used by guard()",
            "    safetypes = {dict, list}",
            "    Wrapper = _write_wrapper()",
            "",
            "    def guard(ob):",
            "        # Don't bother wrapping simple types, or objects that claim to",
            "        # handle their own write security.",
            "        if type(ob) in safetypes or hasattr(ob, '_guarded_writes'):",
            "            return ob",
            "        # Hand the object to the Wrapper instance, then return the instance.",
            "        return Wrapper(ob)",
            "    return guard",
            "",
            "",
            "full_write_guard = _full_write_guard()",
            "",
            "",
            "def guarded_setattr(object, name, value):",
            "    setattr(full_write_guard(object), name, value)",
            "",
            "",
            "safe_builtins['setattr'] = guarded_setattr",
            "",
            "",
            "def guarded_delattr(object, name):",
            "    delattr(full_write_guard(object), name)",
            "",
            "",
            "safe_builtins['delattr'] = guarded_delattr",
            "",
            "",
            "def safer_getattr(object, name, default=None, getattr=getattr):",
            "    \"\"\"Getattr implementation which prevents using format on string objects.",
            "",
            "    format() is considered harmful:",
            "    http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/",
            "",
            "    \"\"\"",
            "    if name in ('format', 'format_map') and (",
            "            isinstance(object, str) or",
            "            (isinstance(object, type) and issubclass(object, str))):",
            "        raise NotImplementedError(",
            "            'Using the format*() methods of `str` is not safe')",
            "    if name.startswith('_'):",
            "        raise AttributeError(",
            "            '\"{name}\" is an invalid attribute name because it '",
            "            'starts with \"_\"'.format(name=name)",
            "        )",
            "    return getattr(object, name, default)",
            "",
            "",
            "safe_builtins['_getattr_'] = safer_getattr",
            "",
            "",
            "def guarded_iter_unpack_sequence(it, spec, _getiter_):",
            "    \"\"\"Protect sequence unpacking of targets in a 'for loop'.",
            "",
            "    The target of a for loop could be a sequence.",
            "    For example \"for a, b in it\"",
            "    => Each object from the iterator needs guarded sequence unpacking.",
            "    \"\"\"",
            "    # The iteration itself needs to be protected as well.",
            "    for ob in _getiter_(it):",
            "        yield guarded_unpack_sequence(ob, spec, _getiter_)",
            "",
            "",
            "def guarded_unpack_sequence(it, spec, _getiter_):",
            "    \"\"\"Protect nested sequence unpacking.",
            "",
            "    Protect the unpacking of 'it' by wrapping it with '_getiter_'.",
            "    Furthermore for each child element, defined by spec,",
            "    guarded_unpack_sequence is called again.",
            "",
            "    Have a look at transformer.py 'gen_unpack_spec' for a more detailed",
            "    explanation.",
            "    \"\"\"",
            "    # Do the guarded unpacking of the sequence.",
            "    ret = list(_getiter_(it))",
            "",
            "    # If the sequence is shorter then expected the interpreter will raise",
            "    # 'ValueError: need more than X value to unpack' anyway",
            "    # => No childs are unpacked => nothing to protect.",
            "    if len(ret) < spec['min_len']:",
            "        return ret",
            "",
            "    # For all child elements do the guarded unpacking again.",
            "    for (idx, child_spec) in spec['childs']:",
            "        ret[idx] = guarded_unpack_sequence(ret[idx], child_spec, _getiter_)",
            "",
            "    return ret",
            "",
            "",
            "safe_globals = {'__builtins__': safe_builtins}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "249": [
                "safer_getattr"
            ],
            "251": [
                "safer_getattr"
            ]
        },
        "addLocation": []
    },
    "src/RestrictedPython/Utilities.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " utility_builtins = {}"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-utility_builtins['string'] = string"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+class _AttributeDelegator:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    def __init__(self, mod, *excludes):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        \"\"\"delegate attribute lookups outside *excludes* to module *mod*.\"\"\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+        self.__mod = mod"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+        self.__excludes = excludes"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    def __getattr__(self, attr):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        if attr in self.__excludes:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            raise NotImplementedError("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+                f\"{self.__mod.__name__}.{attr} is not safe\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        return getattr(self.__mod, attr)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+utility_builtins['string'] = _AttributeDelegator(string, \"Formatter\")"
            },
            "19": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " utility_builtins['math'] = math"
            },
            "20": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " utility_builtins['random'] = random"
            },
            "21": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " utility_builtins['whrandom'] = random"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "import math",
            "import random",
            "import string",
            "",
            "",
            "utility_builtins = {}",
            "",
            "utility_builtins['string'] = string",
            "utility_builtins['math'] = math",
            "utility_builtins['random'] = random",
            "utility_builtins['whrandom'] = random",
            "utility_builtins['set'] = set",
            "utility_builtins['frozenset'] = frozenset",
            "",
            "try:",
            "    import DateTime",
            "    utility_builtins['DateTime'] = DateTime.DateTime",
            "except ImportError:",
            "    pass",
            "",
            "",
            "def same_type(arg1, *args):",
            "    \"\"\"Compares the class or type of two or more objects.\"\"\"",
            "    t = getattr(arg1, '__class__', type(arg1))",
            "    for arg in args:",
            "        if getattr(arg, '__class__', type(arg)) is not t:",
            "            return False",
            "    return True",
            "",
            "",
            "utility_builtins['same_type'] = same_type",
            "",
            "",
            "def test(*args):",
            "    length = len(args)",
            "    for i in range(1, length, 2):",
            "        if args[i - 1]:",
            "            return args[i]",
            "",
            "    if length % 2:",
            "        return args[-1]",
            "",
            "",
            "utility_builtins['test'] = test",
            "",
            "",
            "def reorder(s, with_=None, without=()):",
            "    # s, with_, and without are sequences treated as sets.",
            "    # The result is subtract(intersect(s, with_), without),",
            "    # unless with_ is None, in which case it is subtract(s, without).",
            "    if with_ is None:",
            "        with_ = s",
            "    orig = {}",
            "    for item in s:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            key, value = item",
            "        else:",
            "            key = value = item",
            "        orig[key] = value",
            "",
            "    result = []",
            "",
            "    for item in without:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            key, ignored = item",
            "        else:",
            "            key = item",
            "        if key in orig:",
            "            del orig[key]",
            "",
            "    for item in with_:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            key, ignored = item",
            "        else:",
            "            key = item",
            "        if key in orig:",
            "            result.append((key, orig[key]))",
            "            del orig[key]",
            "",
            "    return result",
            "",
            "",
            "utility_builtins['reorder'] = reorder"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "import math",
            "import random",
            "import string",
            "",
            "",
            "utility_builtins = {}",
            "",
            "",
            "class _AttributeDelegator:",
            "    def __init__(self, mod, *excludes):",
            "        \"\"\"delegate attribute lookups outside *excludes* to module *mod*.\"\"\"",
            "        self.__mod = mod",
            "        self.__excludes = excludes",
            "",
            "    def __getattr__(self, attr):",
            "        if attr in self.__excludes:",
            "            raise NotImplementedError(",
            "                f\"{self.__mod.__name__}.{attr} is not safe\")",
            "        return getattr(self.__mod, attr)",
            "",
            "",
            "utility_builtins['string'] = _AttributeDelegator(string, \"Formatter\")",
            "utility_builtins['math'] = math",
            "utility_builtins['random'] = random",
            "utility_builtins['whrandom'] = random",
            "utility_builtins['set'] = set",
            "utility_builtins['frozenset'] = frozenset",
            "",
            "try:",
            "    import DateTime",
            "    utility_builtins['DateTime'] = DateTime.DateTime",
            "except ImportError:",
            "    pass",
            "",
            "",
            "def same_type(arg1, *args):",
            "    \"\"\"Compares the class or type of two or more objects.\"\"\"",
            "    t = getattr(arg1, '__class__', type(arg1))",
            "    for arg in args:",
            "        if getattr(arg, '__class__', type(arg)) is not t:",
            "            return False",
            "    return True",
            "",
            "",
            "utility_builtins['same_type'] = same_type",
            "",
            "",
            "def test(*args):",
            "    length = len(args)",
            "    for i in range(1, length, 2):",
            "        if args[i - 1]:",
            "            return args[i]",
            "",
            "    if length % 2:",
            "        return args[-1]",
            "",
            "",
            "utility_builtins['test'] = test",
            "",
            "",
            "def reorder(s, with_=None, without=()):",
            "    # s, with_, and without are sequences treated as sets.",
            "    # The result is subtract(intersect(s, with_), without),",
            "    # unless with_ is None, in which case it is subtract(s, without).",
            "    if with_ is None:",
            "        with_ = s",
            "    orig = {}",
            "    for item in s:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            key, value = item",
            "        else:",
            "            key = value = item",
            "        orig[key] = value",
            "",
            "    result = []",
            "",
            "    for item in without:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            key, ignored = item",
            "        else:",
            "            key = item",
            "        if key in orig:",
            "            del orig[key]",
            "",
            "    for item in with_:",
            "        if isinstance(item, tuple) and len(item) == 2:",
            "            key, ignored = item",
            "        else:",
            "            key = item",
            "        if key in orig:",
            "            result.append((key, orig[key]))",
            "            del orig[key]",
            "",
            "    return result",
            "",
            "",
            "utility_builtins['reorder'] = reorder"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": []
        },
        "addLocation": []
    }
}