{
    "src/treq/client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import uuid"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import warnings"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from collections.abc import Mapping"
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from http.cookiejar import CookieJar"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from http.cookiejar import CookieJar, Cookie"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from urllib.parse import quote_plus, urlencode as _urlencode"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from twisted.internet.interfaces import IProtocol"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from treq.auth import add_auth"
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from treq import multipart"
            },
            "10": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from treq.response import _Response"
            },
            "11": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from requests.cookies import cookiejar_from_dict, merge_cookies"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+from requests.cookies import merge_cookies"
            },
            "13": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " _NOTHING = object()"
            },
            "16": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     return s"
            },
            "17": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+def _scoped_cookiejar_from_dict(url_object, cookie_dict):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    Create a CookieJar from a dictionary whose cookies are all scoped to the"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    given URL's origin."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    @note: This does not scope the cookies to any particular path, only the"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        host, port, and scheme of the given URL."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    \"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    cookie_jar = CookieJar()"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    if cookie_dict is None:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        return cookie_jar"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    for k, v in cookie_dict.items():"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        secure = url_object.scheme == 'https'"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        port_specified = not ("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            (url_object.scheme == \"https\" and url_object.port == 443)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            or (url_object.scheme == \"http\" and url_object.port == 80)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        )"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        port = str(url_object.port)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        domain = url_object.host"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        netscape_domain = domain if '.' in domain else domain + '.local'"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        cookie_jar.set_cookie("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            Cookie("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                # Scoping"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                domain=netscape_domain,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                port=port,"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                secure=secure,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                port_specified=port_specified,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                # Contents"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                name=k,"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                value=v,"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                # Constant/always-the-same stuff"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                version=0,"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+                path=\"/\","
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                expires=None,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                discard=False,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+                comment=None,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                comment_url=None,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                rfc2109=False,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                path_specified=False,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                domain_specified=False,"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                domain_initial_dot=False,"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+                rest=[],"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            )"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        )"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+    return cookie_jar"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " class _BodyBufferingProtocol(proxyForInterface(IProtocol)):"
            },
            "70": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     def __init__(self, original, buffer, finished):"
            },
            "71": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         self.original = original"
            },
            "72": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     def __init__(self, agent, cookiejar=None,"
            },
            "73": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "                  data_to_body_producer=IBodyProducer):"
            },
            "74": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         self._agent = agent"
            },
            "75": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._cookiejar = cookiejar or cookiejar_from_dict({})"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        if cookiejar is None:"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            cookiejar = CookieJar()"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        self._cookiejar = cookiejar"
            },
            "79": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         self._data_to_body_producer = data_to_body_producer"
            },
            "80": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     def get(self, url, **kwargs):"
            },
            "82": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             headers.setRawHeaders(b'Content-Type', [contentType])"
            },
            "83": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 248,
                "PatchRowcode": " "
            },
            "84": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         if not isinstance(cookies, CookieJar):"
            },
            "85": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cookies = cookiejar_from_dict(cookies)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+            cookies = _scoped_cookiejar_from_dict(parsed_url, cookies)"
            },
            "87": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "88": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         cookies = merge_cookies(self._cookiejar, cookies)"
            },
            "89": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         wrapped_agent = CookieAgent(self._agent, cookies)"
            }
        },
        "frontPatchFile": [
            "import io",
            "import mimetypes",
            "import uuid",
            "import warnings",
            "from collections.abc import Mapping",
            "from http.cookiejar import CookieJar",
            "from urllib.parse import quote_plus, urlencode as _urlencode",
            "",
            "from twisted.internet.interfaces import IProtocol",
            "from twisted.internet.defer import Deferred",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.filepath import FilePath",
            "from hyperlink import DecodedURL, EncodedURL",
            "",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IBodyProducer, IResponse",
            "",
            "from twisted.web.client import (",
            "    FileBodyProducer,",
            "    RedirectAgent,",
            "    BrowserLikeRedirectAgent,",
            "    ContentDecoderAgent,",
            "    GzipDecoder,",
            "    CookieAgent",
            ")",
            "",
            "from twisted.python.components import registerAdapter",
            "from json import dumps as json_dumps",
            "",
            "from treq.auth import add_auth",
            "from treq import multipart",
            "from treq.response import _Response",
            "from requests.cookies import cookiejar_from_dict, merge_cookies",
            "",
            "",
            "_NOTHING = object()",
            "",
            "",
            "def urlencode(query, doseq):",
            "    s = _urlencode(query, doseq)",
            "    if not isinstance(s, bytes):",
            "        s = s.encode(\"ascii\")",
            "    return s",
            "",
            "",
            "class _BodyBufferingProtocol(proxyForInterface(IProtocol)):",
            "    def __init__(self, original, buffer, finished):",
            "        self.original = original",
            "        self.buffer = buffer",
            "        self.finished = finished",
            "",
            "    def dataReceived(self, data):",
            "        self.buffer.append(data)",
            "        self.original.dataReceived(data)",
            "",
            "    def connectionLost(self, reason):",
            "        self.original.connectionLost(reason)",
            "        self.finished.errback(reason)",
            "",
            "",
            "class _BufferedResponse(proxyForInterface(IResponse)):",
            "    def __init__(self, original):",
            "        self.original = original",
            "        self._buffer = []",
            "        self._waiters = []",
            "        self._waiting = None",
            "        self._finished = False",
            "        self._reason = None",
            "",
            "    def _deliverWaiting(self, reason):",
            "        self._reason = reason",
            "        self._finished = True",
            "        for waiter in self._waiters:",
            "            for segment in self._buffer:",
            "                waiter.dataReceived(segment)",
            "            waiter.connectionLost(reason)",
            "",
            "    def deliverBody(self, protocol):",
            "        if self._waiting is None and not self._finished:",
            "            self._waiting = Deferred()",
            "            self._waiting.addBoth(self._deliverWaiting)",
            "            self.original.deliverBody(",
            "                _BodyBufferingProtocol(",
            "                    protocol,",
            "                    self._buffer,",
            "                    self._waiting",
            "                )",
            "            )",
            "        elif self._finished:",
            "            for segment in self._buffer:",
            "                protocol.dataReceived(segment)",
            "            protocol.connectionLost(self._reason)",
            "        else:",
            "            self._waiters.append(protocol)",
            "",
            "",
            "class HTTPClient:",
            "    def __init__(self, agent, cookiejar=None,",
            "                 data_to_body_producer=IBodyProducer):",
            "        self._agent = agent",
            "        self._cookiejar = cookiejar or cookiejar_from_dict({})",
            "        self._data_to_body_producer = data_to_body_producer",
            "",
            "    def get(self, url, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.get()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('GET', url, **kwargs)",
            "",
            "    def put(self, url, data=None, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.put()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('PUT', url, data=data, **kwargs)",
            "",
            "    def patch(self, url, data=None, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.patch()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('PATCH', url, data=data, **kwargs)",
            "",
            "    def post(self, url, data=None, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.post()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('POST', url, data=data, **kwargs)",
            "",
            "    def head(self, url, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.head()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('HEAD', url, **kwargs)",
            "",
            "    def delete(self, url, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.delete()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('DELETE', url, **kwargs)",
            "",
            "    def request(",
            "        self,",
            "        method,",
            "        url,",
            "        *,",
            "        params=None,",
            "        headers=None,",
            "        data=None,",
            "        files=None,",
            "        json=_NOTHING,",
            "        auth=None,",
            "        cookies=None,",
            "        allow_redirects=True,",
            "        browser_like_redirects=False,",
            "        unbuffered=False,",
            "        reactor=None,",
            "        timeout=None,",
            "        _stacklevel=2,",
            "    ):",
            "        \"\"\"",
            "        See :func:`treq.request()`.",
            "        \"\"\"",
            "        method = method.encode('ascii').upper()",
            "",
            "        if isinstance(url, DecodedURL):",
            "            parsed_url = url.encoded_url",
            "        elif isinstance(url, EncodedURL):",
            "            parsed_url = url",
            "        elif isinstance(url, str):",
            "            # We use hyperlink in lazy mode so that users can pass arbitrary",
            "            # bytes in the path and querystring.",
            "            parsed_url = EncodedURL.from_text(url)",
            "        else:",
            "            parsed_url = EncodedURL.from_text(url.decode('ascii'))",
            "",
            "        # Join parameters provided in the URL",
            "        # and the ones passed as argument.",
            "        if params:",
            "            parsed_url = parsed_url.replace(",
            "                query=parsed_url.query + tuple(_coerced_query_params(params))",
            "            )",
            "",
            "        url = parsed_url.to_uri().to_text().encode('ascii')",
            "",
            "        headers = self._request_headers(headers, _stacklevel + 1)",
            "",
            "        bodyProducer, contentType = self._request_body(data, files, json,",
            "                                                       stacklevel=_stacklevel + 1)",
            "        if contentType is not None:",
            "            headers.setRawHeaders(b'Content-Type', [contentType])",
            "",
            "        if not isinstance(cookies, CookieJar):",
            "            cookies = cookiejar_from_dict(cookies)",
            "",
            "        cookies = merge_cookies(self._cookiejar, cookies)",
            "        wrapped_agent = CookieAgent(self._agent, cookies)",
            "",
            "        if allow_redirects:",
            "            if browser_like_redirects:",
            "                wrapped_agent = BrowserLikeRedirectAgent(wrapped_agent)",
            "            else:",
            "                wrapped_agent = RedirectAgent(wrapped_agent)",
            "",
            "        wrapped_agent = ContentDecoderAgent(wrapped_agent,",
            "                                            [(b'gzip', GzipDecoder)])",
            "",
            "        if auth:",
            "            wrapped_agent = add_auth(wrapped_agent, auth)",
            "",
            "        d = wrapped_agent.request(",
            "            method, url, headers=headers,",
            "            bodyProducer=bodyProducer)",
            "",
            "        if reactor is None:",
            "            from twisted.internet import reactor",
            "        if timeout:",
            "            delayedCall = reactor.callLater(timeout, d.cancel)",
            "",
            "            def gotResult(result):",
            "                if delayedCall.active():",
            "                    delayedCall.cancel()",
            "                return result",
            "",
            "            d.addBoth(gotResult)",
            "",
            "        if not unbuffered:",
            "            d.addCallback(_BufferedResponse)",
            "",
            "        return d.addCallback(_Response, cookies)",
            "",
            "    def _request_headers(self, headers, stacklevel):",
            "        \"\"\"",
            "        Convert the *headers* argument to a :class:`Headers` instance",
            "",
            "        :returns:",
            "            :class:`twisted.web.http_headers.Headers`",
            "        \"\"\"",
            "        if isinstance(headers, dict):",
            "            h = Headers({})",
            "            for k, v in headers.items():",
            "                if isinstance(v, (bytes, str)):",
            "                    h.addRawHeader(k, v)",
            "                elif isinstance(v, list):",
            "                    h.setRawHeaders(k, v)",
            "                else:",
            "                    warnings.warn(",
            "                        (",
            "                            \"The value of headers key {!r} has non-string type {}\"",
            "                            \" and will be dropped.\"",
            "                            \" This will raise TypeError in the next treq release.\"",
            "                        ).format(k, type(v)),",
            "                        DeprecationWarning,",
            "                        stacklevel=stacklevel,",
            "                    )",
            "            return h",
            "        if isinstance(headers, Headers):",
            "            return headers",
            "        if headers is None:",
            "            return Headers({})",
            "",
            "        warnings.warn(",
            "            (",
            "                \"headers must be a dict, twisted.web.http_headers.Headers, or None,\"",
            "                \" but found {}, which will be ignored.\"",
            "                \" This will raise TypeError in the next treq release.\"",
            "            ).format(type(headers)),",
            "            DeprecationWarning,",
            "            stacklevel=stacklevel,",
            "        )",
            "        return Headers({})",
            "",
            "    def _request_body(self, data, files, json, stacklevel):",
            "        \"\"\"",
            "        Here we choose a right producer based on the parameters passed in.",
            "",
            "        :params data:",
            "            Arbitrary request body data.",
            "",
            "            If *files* is also passed this must be a :class:`dict`,",
            "            a :class:`tuple` or :class:`list` of field tuples as accepted by",
            "            :class:`MultiPartProducer`. The request is assigned a Content-Type",
            "            of ``multipart/form-data``.",
            "",
            "            If a :class:`dict`, :class:`list`, or :class:`tuple` it is",
            "            URL-encoded and the request assigned a Content-Type of",
            "            ``application/x-www-form-urlencoded``.",
            "",
            "            Otherwise, any non-``None`` value is passed to the client's",
            "            *data_to_body_producer* callable (by default,",
            "            :class:`IBodyProducer`), which accepts file-like objects.",
            "",
            "        :params files:",
            "            Files to include in the request body, in any of the several formats",
            "            described in :func:`_convert_files()`.",
            "",
            "        :params json:",
            "            JSON-encodable data, or the sentinel `_NOTHING`. The sentinel is",
            "            necessary because ``None`` is a valid JSON value.",
            "        \"\"\"",
            "        if json is not _NOTHING and (files or data):",
            "            warnings.warn(",
            "                (",
            "                    \"Argument 'json' will be ignored because '{}' was also passed.\"",
            "                    \" This will raise TypeError in the next treq release.\"",
            "                ).format(\"data\" if data else \"files\"),",
            "                DeprecationWarning,",
            "                stacklevel=stacklevel,",
            "            )",
            "",
            "        if files:",
            "            # If the files keyword is present we will issue a",
            "            # multipart/form-data request as it suits better for cases",
            "            # with files and/or large objects.",
            "            files = list(_convert_files(files))",
            "            boundary = str(uuid.uuid4()).encode('ascii')",
            "            if data:",
            "                data = _convert_params(data)",
            "            else:",
            "                data = []",
            "",
            "            return (",
            "                multipart.MultiPartProducer(data + files, boundary=boundary),",
            "                b'multipart/form-data; boundary=' + boundary,",
            "            )",
            "",
            "        # Otherwise stick to x-www-form-urlencoded format",
            "        # as it's generally faster for smaller requests.",
            "        if isinstance(data, (dict, list, tuple)):",
            "            return (",
            "                self._data_to_body_producer(urlencode(data, doseq=True)),",
            "                b'application/x-www-form-urlencoded',",
            "            )",
            "        elif data:",
            "            return (",
            "                self._data_to_body_producer(data),",
            "                None,",
            "            )",
            "",
            "        if json is not _NOTHING:",
            "            return (",
            "                self._data_to_body_producer(",
            "                    json_dumps(json, separators=(u',', u':')).encode('utf-8'),",
            "                ),",
            "                b'application/json; charset=UTF-8',",
            "            )",
            "",
            "        return None, None",
            "",
            "",
            "def _convert_params(params):",
            "    if hasattr(params, \"iteritems\"):",
            "        return list(sorted(params.iteritems()))",
            "    elif hasattr(params, \"items\"):",
            "        return list(sorted(params.items()))",
            "    elif isinstance(params, (tuple, list)):",
            "        return list(params)",
            "    else:",
            "        raise ValueError(\"Unsupported format\")",
            "",
            "",
            "def _convert_files(files):",
            "    \"\"\"",
            "    Files can be passed in a variety of formats:",
            "",
            "    * {\"fieldname\": open(\"bla.f\", \"rb\")}",
            "    * {\"fieldname\": (\"filename\", open(\"bla.f\", \"rb\"))}",
            "    * {\"fieldname\": (\"filename\", \"content-type\", open(\"bla.f\", \"rb\"))}",
            "    * Anything that has iteritems method, e.g. MultiDict:",
            "      MultiDict([(name, open()), (name, open())]",
            "",
            "    Our goal is to standardize it to unified form of:",
            "",
            "    * [(param, (file name, content type, producer))]",
            "    \"\"\"",
            "",
            "    if hasattr(files, \"iteritems\"):",
            "        files = files.iteritems()",
            "    elif hasattr(files, \"items\"):",
            "        files = files.items()",
            "",
            "    for param, val in files:",
            "        file_name, content_type, fobj = (None, None, None)",
            "        if isinstance(val, tuple):",
            "            if len(val) == 2:",
            "                file_name, fobj = val",
            "            elif len(val) == 3:",
            "                file_name, content_type, fobj = val",
            "            else:",
            "                # NB: This is TypeError for backward compatibility. This case",
            "                # used to fall through to `IBodyProducer`, below, which raised",
            "                # TypeError about being unable to coerce None.",
            "                raise TypeError(",
            "                    (",
            "                        \"`files` argument must be a sequence of tuples of\"",
            "                        \" (file_name, file_obj) or\"",
            "                        \" (file_name, content_type, file_obj),\"",
            "                        \" but the {!r} tuple has length {}: {!r}\"",
            "                    ).format(param, len(val), val),",
            "                )",
            "        else:",
            "            fobj = val",
            "            if hasattr(fobj, \"name\"):",
            "                file_name = FilePath(fobj.name).basename()",
            "",
            "        if not content_type:",
            "            content_type = _guess_content_type(file_name)",
            "",
            "        # XXX: Shouldn't this call self._data_to_body_producer?",
            "        yield (param, (file_name, content_type, IBodyProducer(fobj)))",
            "",
            "",
            "def _query_quote(v):",
            "    # (Any) -> Text",
            "    \"\"\"",
            "    Percent-encode a querystring name or value.",
            "",
            "    :param v: A value.",
            "",
            "    :returns:",
            "        The value, coerced to a string and percent-encoded as appropriate for",
            "        a querystring (with space as ``+``).",
            "    \"\"\"",
            "    if not isinstance(v, (str, bytes)):",
            "        v = str(v)",
            "    if not isinstance(v, bytes):",
            "        v = v.encode(\"utf-8\")",
            "    q = quote_plus(v)",
            "    return q",
            "",
            "",
            "def _coerced_query_params(params):",
            "    \"\"\"",
            "    Carefully coerce *params* in the same way as `urllib.parse.urlencode()`",
            "",
            "    Parameter names and values are coerced to unicode, which is encoded as",
            "    UTF-8 and then percent-encoded. As a special case, `bytes` are directly",
            "    percent-encoded.",
            "",
            "    :param params:",
            "        A mapping or sequence of (name, value) two-tuples. The value may be",
            "        a list or tuple of multiple values. Names and values may be pretty much",
            "        any type.",
            "",
            "    :returns:",
            "        A generator that yields two-tuples containing percent-encoded text",
            "        strings.",
            "    :rtype:",
            "        Iterator[Tuple[Text, Text]]",
            "    \"\"\"",
            "    if isinstance(params, Mapping):",
            "        items = params.items()",
            "    else:",
            "        items = params",
            "",
            "    for key, values in items:",
            "        key_quoted = _query_quote(key)",
            "",
            "        if not isinstance(values, (list, tuple)):",
            "            values = (values,)",
            "        for value in values:",
            "            yield key_quoted, _query_quote(value)",
            "",
            "",
            "def _from_bytes(orig_bytes):",
            "    return FileBodyProducer(io.BytesIO(orig_bytes))",
            "",
            "",
            "def _from_file(orig_file):",
            "    return FileBodyProducer(orig_file)",
            "",
            "",
            "def _guess_content_type(filename):",
            "    if filename:",
            "        guessed = mimetypes.guess_type(filename)[0]",
            "    else:",
            "        guessed = None",
            "    return guessed or 'application/octet-stream'",
            "",
            "",
            "registerAdapter(_from_bytes, bytes, IBodyProducer)",
            "registerAdapter(_from_file, io.BytesIO, IBodyProducer)",
            "",
            "# file()/open() equiv",
            "registerAdapter(_from_file, io.BufferedReader, IBodyProducer)"
        ],
        "afterPatchFile": [
            "import io",
            "import mimetypes",
            "import uuid",
            "import warnings",
            "from collections.abc import Mapping",
            "from http.cookiejar import CookieJar, Cookie",
            "from urllib.parse import quote_plus, urlencode as _urlencode",
            "",
            "from twisted.internet.interfaces import IProtocol",
            "from twisted.internet.defer import Deferred",
            "from twisted.python.components import proxyForInterface",
            "from twisted.python.filepath import FilePath",
            "from hyperlink import DecodedURL, EncodedURL",
            "",
            "from twisted.web.http_headers import Headers",
            "from twisted.web.iweb import IBodyProducer, IResponse",
            "",
            "from twisted.web.client import (",
            "    FileBodyProducer,",
            "    RedirectAgent,",
            "    BrowserLikeRedirectAgent,",
            "    ContentDecoderAgent,",
            "    GzipDecoder,",
            "    CookieAgent",
            ")",
            "",
            "from twisted.python.components import registerAdapter",
            "from json import dumps as json_dumps",
            "",
            "from treq.auth import add_auth",
            "from treq import multipart",
            "from treq.response import _Response",
            "from requests.cookies import merge_cookies",
            "",
            "",
            "_NOTHING = object()",
            "",
            "",
            "def urlencode(query, doseq):",
            "    s = _urlencode(query, doseq)",
            "    if not isinstance(s, bytes):",
            "        s = s.encode(\"ascii\")",
            "    return s",
            "",
            "",
            "def _scoped_cookiejar_from_dict(url_object, cookie_dict):",
            "    \"\"\"",
            "    Create a CookieJar from a dictionary whose cookies are all scoped to the",
            "    given URL's origin.",
            "",
            "    @note: This does not scope the cookies to any particular path, only the",
            "        host, port, and scheme of the given URL.",
            "    \"\"\"",
            "    cookie_jar = CookieJar()",
            "    if cookie_dict is None:",
            "        return cookie_jar",
            "    for k, v in cookie_dict.items():",
            "        secure = url_object.scheme == 'https'",
            "        port_specified = not (",
            "            (url_object.scheme == \"https\" and url_object.port == 443)",
            "            or (url_object.scheme == \"http\" and url_object.port == 80)",
            "        )",
            "        port = str(url_object.port)",
            "        domain = url_object.host",
            "        netscape_domain = domain if '.' in domain else domain + '.local'",
            "",
            "        cookie_jar.set_cookie(",
            "            Cookie(",
            "                # Scoping",
            "                domain=netscape_domain,",
            "                port=port,",
            "                secure=secure,",
            "                port_specified=port_specified,",
            "",
            "                # Contents",
            "                name=k,",
            "                value=v,",
            "",
            "                # Constant/always-the-same stuff",
            "                version=0,",
            "                path=\"/\",",
            "                expires=None,",
            "                discard=False,",
            "                comment=None,",
            "                comment_url=None,",
            "                rfc2109=False,",
            "                path_specified=False,",
            "                domain_specified=False,",
            "                domain_initial_dot=False,",
            "                rest=[],",
            "            )",
            "        )",
            "    return cookie_jar",
            "",
            "",
            "class _BodyBufferingProtocol(proxyForInterface(IProtocol)):",
            "    def __init__(self, original, buffer, finished):",
            "        self.original = original",
            "        self.buffer = buffer",
            "        self.finished = finished",
            "",
            "    def dataReceived(self, data):",
            "        self.buffer.append(data)",
            "        self.original.dataReceived(data)",
            "",
            "    def connectionLost(self, reason):",
            "        self.original.connectionLost(reason)",
            "        self.finished.errback(reason)",
            "",
            "",
            "class _BufferedResponse(proxyForInterface(IResponse)):",
            "    def __init__(self, original):",
            "        self.original = original",
            "        self._buffer = []",
            "        self._waiters = []",
            "        self._waiting = None",
            "        self._finished = False",
            "        self._reason = None",
            "",
            "    def _deliverWaiting(self, reason):",
            "        self._reason = reason",
            "        self._finished = True",
            "        for waiter in self._waiters:",
            "            for segment in self._buffer:",
            "                waiter.dataReceived(segment)",
            "            waiter.connectionLost(reason)",
            "",
            "    def deliverBody(self, protocol):",
            "        if self._waiting is None and not self._finished:",
            "            self._waiting = Deferred()",
            "            self._waiting.addBoth(self._deliverWaiting)",
            "            self.original.deliverBody(",
            "                _BodyBufferingProtocol(",
            "                    protocol,",
            "                    self._buffer,",
            "                    self._waiting",
            "                )",
            "            )",
            "        elif self._finished:",
            "            for segment in self._buffer:",
            "                protocol.dataReceived(segment)",
            "            protocol.connectionLost(self._reason)",
            "        else:",
            "            self._waiters.append(protocol)",
            "",
            "",
            "class HTTPClient:",
            "    def __init__(self, agent, cookiejar=None,",
            "                 data_to_body_producer=IBodyProducer):",
            "        self._agent = agent",
            "        if cookiejar is None:",
            "            cookiejar = CookieJar()",
            "        self._cookiejar = cookiejar",
            "        self._data_to_body_producer = data_to_body_producer",
            "",
            "    def get(self, url, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.get()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('GET', url, **kwargs)",
            "",
            "    def put(self, url, data=None, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.put()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('PUT', url, data=data, **kwargs)",
            "",
            "    def patch(self, url, data=None, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.patch()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('PATCH', url, data=data, **kwargs)",
            "",
            "    def post(self, url, data=None, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.post()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('POST', url, data=data, **kwargs)",
            "",
            "    def head(self, url, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.head()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('HEAD', url, **kwargs)",
            "",
            "    def delete(self, url, **kwargs):",
            "        \"\"\"",
            "        See :func:`treq.delete()`.",
            "        \"\"\"",
            "        kwargs.setdefault('_stacklevel', 3)",
            "        return self.request('DELETE', url, **kwargs)",
            "",
            "    def request(",
            "        self,",
            "        method,",
            "        url,",
            "        *,",
            "        params=None,",
            "        headers=None,",
            "        data=None,",
            "        files=None,",
            "        json=_NOTHING,",
            "        auth=None,",
            "        cookies=None,",
            "        allow_redirects=True,",
            "        browser_like_redirects=False,",
            "        unbuffered=False,",
            "        reactor=None,",
            "        timeout=None,",
            "        _stacklevel=2,",
            "    ):",
            "        \"\"\"",
            "        See :func:`treq.request()`.",
            "        \"\"\"",
            "        method = method.encode('ascii').upper()",
            "",
            "        if isinstance(url, DecodedURL):",
            "            parsed_url = url.encoded_url",
            "        elif isinstance(url, EncodedURL):",
            "            parsed_url = url",
            "        elif isinstance(url, str):",
            "            # We use hyperlink in lazy mode so that users can pass arbitrary",
            "            # bytes in the path and querystring.",
            "            parsed_url = EncodedURL.from_text(url)",
            "        else:",
            "            parsed_url = EncodedURL.from_text(url.decode('ascii'))",
            "",
            "        # Join parameters provided in the URL",
            "        # and the ones passed as argument.",
            "        if params:",
            "            parsed_url = parsed_url.replace(",
            "                query=parsed_url.query + tuple(_coerced_query_params(params))",
            "            )",
            "",
            "        url = parsed_url.to_uri().to_text().encode('ascii')",
            "",
            "        headers = self._request_headers(headers, _stacklevel + 1)",
            "",
            "        bodyProducer, contentType = self._request_body(data, files, json,",
            "                                                       stacklevel=_stacklevel + 1)",
            "        if contentType is not None:",
            "            headers.setRawHeaders(b'Content-Type', [contentType])",
            "",
            "        if not isinstance(cookies, CookieJar):",
            "            cookies = _scoped_cookiejar_from_dict(parsed_url, cookies)",
            "",
            "        cookies = merge_cookies(self._cookiejar, cookies)",
            "        wrapped_agent = CookieAgent(self._agent, cookies)",
            "",
            "        if allow_redirects:",
            "            if browser_like_redirects:",
            "                wrapped_agent = BrowserLikeRedirectAgent(wrapped_agent)",
            "            else:",
            "                wrapped_agent = RedirectAgent(wrapped_agent)",
            "",
            "        wrapped_agent = ContentDecoderAgent(wrapped_agent,",
            "                                            [(b'gzip', GzipDecoder)])",
            "",
            "        if auth:",
            "            wrapped_agent = add_auth(wrapped_agent, auth)",
            "",
            "        d = wrapped_agent.request(",
            "            method, url, headers=headers,",
            "            bodyProducer=bodyProducer)",
            "",
            "        if reactor is None:",
            "            from twisted.internet import reactor",
            "        if timeout:",
            "            delayedCall = reactor.callLater(timeout, d.cancel)",
            "",
            "            def gotResult(result):",
            "                if delayedCall.active():",
            "                    delayedCall.cancel()",
            "                return result",
            "",
            "            d.addBoth(gotResult)",
            "",
            "        if not unbuffered:",
            "            d.addCallback(_BufferedResponse)",
            "",
            "        return d.addCallback(_Response, cookies)",
            "",
            "    def _request_headers(self, headers, stacklevel):",
            "        \"\"\"",
            "        Convert the *headers* argument to a :class:`Headers` instance",
            "",
            "        :returns:",
            "            :class:`twisted.web.http_headers.Headers`",
            "        \"\"\"",
            "        if isinstance(headers, dict):",
            "            h = Headers({})",
            "            for k, v in headers.items():",
            "                if isinstance(v, (bytes, str)):",
            "                    h.addRawHeader(k, v)",
            "                elif isinstance(v, list):",
            "                    h.setRawHeaders(k, v)",
            "                else:",
            "                    warnings.warn(",
            "                        (",
            "                            \"The value of headers key {!r} has non-string type {}\"",
            "                            \" and will be dropped.\"",
            "                            \" This will raise TypeError in the next treq release.\"",
            "                        ).format(k, type(v)),",
            "                        DeprecationWarning,",
            "                        stacklevel=stacklevel,",
            "                    )",
            "            return h",
            "        if isinstance(headers, Headers):",
            "            return headers",
            "        if headers is None:",
            "            return Headers({})",
            "",
            "        warnings.warn(",
            "            (",
            "                \"headers must be a dict, twisted.web.http_headers.Headers, or None,\"",
            "                \" but found {}, which will be ignored.\"",
            "                \" This will raise TypeError in the next treq release.\"",
            "            ).format(type(headers)),",
            "            DeprecationWarning,",
            "            stacklevel=stacklevel,",
            "        )",
            "        return Headers({})",
            "",
            "    def _request_body(self, data, files, json, stacklevel):",
            "        \"\"\"",
            "        Here we choose a right producer based on the parameters passed in.",
            "",
            "        :params data:",
            "            Arbitrary request body data.",
            "",
            "            If *files* is also passed this must be a :class:`dict`,",
            "            a :class:`tuple` or :class:`list` of field tuples as accepted by",
            "            :class:`MultiPartProducer`. The request is assigned a Content-Type",
            "            of ``multipart/form-data``.",
            "",
            "            If a :class:`dict`, :class:`list`, or :class:`tuple` it is",
            "            URL-encoded and the request assigned a Content-Type of",
            "            ``application/x-www-form-urlencoded``.",
            "",
            "            Otherwise, any non-``None`` value is passed to the client's",
            "            *data_to_body_producer* callable (by default,",
            "            :class:`IBodyProducer`), which accepts file-like objects.",
            "",
            "        :params files:",
            "            Files to include in the request body, in any of the several formats",
            "            described in :func:`_convert_files()`.",
            "",
            "        :params json:",
            "            JSON-encodable data, or the sentinel `_NOTHING`. The sentinel is",
            "            necessary because ``None`` is a valid JSON value.",
            "        \"\"\"",
            "        if json is not _NOTHING and (files or data):",
            "            warnings.warn(",
            "                (",
            "                    \"Argument 'json' will be ignored because '{}' was also passed.\"",
            "                    \" This will raise TypeError in the next treq release.\"",
            "                ).format(\"data\" if data else \"files\"),",
            "                DeprecationWarning,",
            "                stacklevel=stacklevel,",
            "            )",
            "",
            "        if files:",
            "            # If the files keyword is present we will issue a",
            "            # multipart/form-data request as it suits better for cases",
            "            # with files and/or large objects.",
            "            files = list(_convert_files(files))",
            "            boundary = str(uuid.uuid4()).encode('ascii')",
            "            if data:",
            "                data = _convert_params(data)",
            "            else:",
            "                data = []",
            "",
            "            return (",
            "                multipart.MultiPartProducer(data + files, boundary=boundary),",
            "                b'multipart/form-data; boundary=' + boundary,",
            "            )",
            "",
            "        # Otherwise stick to x-www-form-urlencoded format",
            "        # as it's generally faster for smaller requests.",
            "        if isinstance(data, (dict, list, tuple)):",
            "            return (",
            "                self._data_to_body_producer(urlencode(data, doseq=True)),",
            "                b'application/x-www-form-urlencoded',",
            "            )",
            "        elif data:",
            "            return (",
            "                self._data_to_body_producer(data),",
            "                None,",
            "            )",
            "",
            "        if json is not _NOTHING:",
            "            return (",
            "                self._data_to_body_producer(",
            "                    json_dumps(json, separators=(u',', u':')).encode('utf-8'),",
            "                ),",
            "                b'application/json; charset=UTF-8',",
            "            )",
            "",
            "        return None, None",
            "",
            "",
            "def _convert_params(params):",
            "    if hasattr(params, \"iteritems\"):",
            "        return list(sorted(params.iteritems()))",
            "    elif hasattr(params, \"items\"):",
            "        return list(sorted(params.items()))",
            "    elif isinstance(params, (tuple, list)):",
            "        return list(params)",
            "    else:",
            "        raise ValueError(\"Unsupported format\")",
            "",
            "",
            "def _convert_files(files):",
            "    \"\"\"",
            "    Files can be passed in a variety of formats:",
            "",
            "    * {\"fieldname\": open(\"bla.f\", \"rb\")}",
            "    * {\"fieldname\": (\"filename\", open(\"bla.f\", \"rb\"))}",
            "    * {\"fieldname\": (\"filename\", \"content-type\", open(\"bla.f\", \"rb\"))}",
            "    * Anything that has iteritems method, e.g. MultiDict:",
            "      MultiDict([(name, open()), (name, open())]",
            "",
            "    Our goal is to standardize it to unified form of:",
            "",
            "    * [(param, (file name, content type, producer))]",
            "    \"\"\"",
            "",
            "    if hasattr(files, \"iteritems\"):",
            "        files = files.iteritems()",
            "    elif hasattr(files, \"items\"):",
            "        files = files.items()",
            "",
            "    for param, val in files:",
            "        file_name, content_type, fobj = (None, None, None)",
            "        if isinstance(val, tuple):",
            "            if len(val) == 2:",
            "                file_name, fobj = val",
            "            elif len(val) == 3:",
            "                file_name, content_type, fobj = val",
            "            else:",
            "                # NB: This is TypeError for backward compatibility. This case",
            "                # used to fall through to `IBodyProducer`, below, which raised",
            "                # TypeError about being unable to coerce None.",
            "                raise TypeError(",
            "                    (",
            "                        \"`files` argument must be a sequence of tuples of\"",
            "                        \" (file_name, file_obj) or\"",
            "                        \" (file_name, content_type, file_obj),\"",
            "                        \" but the {!r} tuple has length {}: {!r}\"",
            "                    ).format(param, len(val), val),",
            "                )",
            "        else:",
            "            fobj = val",
            "            if hasattr(fobj, \"name\"):",
            "                file_name = FilePath(fobj.name).basename()",
            "",
            "        if not content_type:",
            "            content_type = _guess_content_type(file_name)",
            "",
            "        # XXX: Shouldn't this call self._data_to_body_producer?",
            "        yield (param, (file_name, content_type, IBodyProducer(fobj)))",
            "",
            "",
            "def _query_quote(v):",
            "    # (Any) -> Text",
            "    \"\"\"",
            "    Percent-encode a querystring name or value.",
            "",
            "    :param v: A value.",
            "",
            "    :returns:",
            "        The value, coerced to a string and percent-encoded as appropriate for",
            "        a querystring (with space as ``+``).",
            "    \"\"\"",
            "    if not isinstance(v, (str, bytes)):",
            "        v = str(v)",
            "    if not isinstance(v, bytes):",
            "        v = v.encode(\"utf-8\")",
            "    q = quote_plus(v)",
            "    return q",
            "",
            "",
            "def _coerced_query_params(params):",
            "    \"\"\"",
            "    Carefully coerce *params* in the same way as `urllib.parse.urlencode()`",
            "",
            "    Parameter names and values are coerced to unicode, which is encoded as",
            "    UTF-8 and then percent-encoded. As a special case, `bytes` are directly",
            "    percent-encoded.",
            "",
            "    :param params:",
            "        A mapping or sequence of (name, value) two-tuples. The value may be",
            "        a list or tuple of multiple values. Names and values may be pretty much",
            "        any type.",
            "",
            "    :returns:",
            "        A generator that yields two-tuples containing percent-encoded text",
            "        strings.",
            "    :rtype:",
            "        Iterator[Tuple[Text, Text]]",
            "    \"\"\"",
            "    if isinstance(params, Mapping):",
            "        items = params.items()",
            "    else:",
            "        items = params",
            "",
            "    for key, values in items:",
            "        key_quoted = _query_quote(key)",
            "",
            "        if not isinstance(values, (list, tuple)):",
            "            values = (values,)",
            "        for value in values:",
            "            yield key_quoted, _query_quote(value)",
            "",
            "",
            "def _from_bytes(orig_bytes):",
            "    return FileBodyProducer(io.BytesIO(orig_bytes))",
            "",
            "",
            "def _from_file(orig_file):",
            "    return FileBodyProducer(orig_file)",
            "",
            "",
            "def _guess_content_type(filename):",
            "    if filename:",
            "        guessed = mimetypes.guess_type(filename)[0]",
            "    else:",
            "        guessed = None",
            "    return guessed or 'application/octet-stream'",
            "",
            "",
            "registerAdapter(_from_bytes, bytes, IBodyProducer)",
            "registerAdapter(_from_file, io.BytesIO, IBodyProducer)",
            "",
            "# file()/open() equiv",
            "registerAdapter(_from_file, io.BufferedReader, IBodyProducer)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "33": [],
            "101": [
                "HTTPClient",
                "__init__"
            ],
            "198": [
                "HTTPClient",
                "request"
            ]
        },
        "addLocation": []
    },
    "src/treq/test/test_testing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from functools import partial"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from inspect import getmembers, isfunction"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from json import dumps"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from unittest.mock import ANY"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         return b\"I'm a teapot\""
            },
            "8": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+class _RedirectResource(Resource):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    Resource that redirects to a different domain."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    \"\"\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    isLeaf = True"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    def render(self, request):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        if b'redirected' not in request.uri:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            request.redirect(b'https://example.org/redirected')"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        return dumps("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            {"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                key.decode(\"charmap\"): ["
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+                    value.decode(\"charmap\")"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                    for value in values"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                ]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+                for key, values in"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                request.requestHeaders.getAllRawHeaders()}"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        ).encode(\"utf-8\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " class _NonResponsiveTestResource(Resource):"
            },
            "31": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     \"\"\"Resource that returns NOT_DONE_YET and never finishes the request\"\"\""
            },
            "32": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     isLeaf = True"
            },
            "33": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 293,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "     def test_session_persistence_between_requests(self):"
            },
            "35": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "         \"\"\""
            },
            "36": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Calling request.getSession() in the wrapped resource will return"
            },
            "37": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        a session with the same ID, until the sessions are cleaned."
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+        Calling request.getSession() in the wrapped resource will return a"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+        session with the same ID, until the sessions are cleaned; in other"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+        words, cookies are propagated between requests when the result of"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+        C{response.cookies()} is passed to the next request."
            },
            "42": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         \"\"\""
            },
            "43": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         rsrc = _SessionIdTestResource()"
            },
            "44": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         stub = StubTreq(rsrc)"
            },
            "45": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "         sid_4 = self.successResultOf(resp.content())"
            },
            "46": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "         self.assertEqual(sid_3, sid_4)"
            },
            "47": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 329,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+    def test_different_domains(self):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        \"\"\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+        Cookies manually specified as part of a dictionary are not relayed"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        through redirects."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+        (This is really more of a test for scoping of cookies within treq"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+        itself, rather than just for testing.)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+        \"\"\""
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+        rsrc = _RedirectResource()"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+        stub = StubTreq(rsrc)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+        d = stub.request("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+            \"GET\", \"http://example.com/\","
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+            cookies={\"not-across-redirect\": \"nope\"}"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+        )"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+        resp = self.successResultOf(d)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+        received = self.successResultOf(resp.json())"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+        self.assertNotIn('not-across-redirect', received.get('Cookie', [''])[0])"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 348,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 349,
                "PatchRowcode": " class HasHeadersTests(TestCase):"
            },
            "68": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "In-memory treq returns stubbed responses.",
            "\"\"\"",
            "from functools import partial",
            "from inspect import getmembers, isfunction",
            "",
            "from unittest.mock import ANY",
            "",
            "from twisted.trial.unittest import TestCase",
            "from twisted.web.client import ResponseFailed",
            "from twisted.web.error import SchemeNotSupported",
            "from twisted.web.resource import Resource",
            "from twisted.web.server import NOT_DONE_YET",
            "",
            "import treq",
            "",
            "from treq.testing import (",
            "    HasHeaders,",
            "    RequestSequence,",
            "    StringStubbingResource,",
            "    StubTreq",
            ")",
            "",
            "",
            "class _StaticTestResource(Resource):",
            "    \"\"\"Resource that always returns 418 \"I'm a teapot\"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        request.setResponseCode(418)",
            "        request.setHeader(b\"x-teapot\", b\"teapot!\")",
            "        return b\"I'm a teapot\"",
            "",
            "",
            "class _NonResponsiveTestResource(Resource):",
            "    \"\"\"Resource that returns NOT_DONE_YET and never finishes the request\"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        return NOT_DONE_YET",
            "",
            "",
            "class _EventuallyResponsiveTestResource(Resource):",
            "    \"\"\"",
            "    Resource that returns NOT_DONE_YET and stores the request so that something",
            "    else can finish the response later.",
            "    \"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        self.stored_request = request",
            "        return NOT_DONE_YET",
            "",
            "",
            "class _SessionIdTestResource(Resource):",
            "    \"\"\"",
            "    Resource that returns the current session ID.",
            "    \"\"\"",
            "    isLeaf = True",
            "",
            "    def __init__(self):",
            "        super().__init__()",
            "        # keep track of all sessions created, so we can manually expire them later",
            "        self.sessions = []",
            "",
            "    def render(self, request):",
            "        session = request.getSession()",
            "        if session not in self.sessions:",
            "            # new session, add to internal list",
            "            self.sessions.append(session)",
            "        uid = session.uid",
            "        return uid",
            "",
            "    def expire_sessions(self):",
            "        \"\"\"",
            "        Manually expire all sessions created by this resource.",
            "        \"\"\"",
            "        for session in self.sessions:",
            "            session.expire()",
            "        self.sessions = []",
            "",
            "",
            "class StubbingTests(TestCase):",
            "    \"\"\"",
            "    Tests for :class:`StubTreq`.",
            "    \"\"\"",
            "    def test_stubtreq_provides_all_functions_in_treq_all(self):",
            "        \"\"\"",
            "        Every single function and attribute exposed by :obj:`treq.__all__` is",
            "        provided by :obj:`StubTreq`.",
            "        \"\"\"",
            "        treq_things = [(name, obj) for name, obj in getmembers(treq)",
            "                       if name in treq.__all__]",
            "        stub = StubTreq(_StaticTestResource())",
            "",
            "        api_things = [(name, obj) for name, obj in treq_things",
            "                      if obj.__module__ == \"treq.api\"]",
            "        content_things = [(name, obj) for name, obj in treq_things",
            "                          if obj.__module__ == \"treq.content\"]",
            "",
            "        # sanity checks - this test should fail if treq exposes a new API",
            "        # without changes being made to StubTreq and this test.",
            "        msg = (\"At the time this test was written, StubTreq only knew about \"",
            "               \"treq exposing functions from treq.api and treq.content.  If \"",
            "               \"this has changed, StubTreq will need to be updated, as will \"",
            "               \"this test.\")",
            "        self.assertTrue(all(isfunction(obj) for name, obj in treq_things), msg)",
            "        self.assertEqual(set(treq_things), set(api_things + content_things),",
            "                         msg)",
            "",
            "        for name, obj in api_things:",
            "            self.assertTrue(",
            "                isfunction(getattr(stub, name, None)),",
            "                \"StubTreq.{0} should be a function.\".format(name))",
            "",
            "        for name, obj in content_things:",
            "            self.assertIs(",
            "                getattr(stub, name, None), obj,",
            "                \"StubTreq.{0} should just expose treq.{0}\".format(name))",
            "",
            "    def test_providing_resource_to_stub_treq(self):",
            "        \"\"\"",
            "        The resource provided to StubTreq responds to every request no",
            "        matter what the URI or parameters or data.",
            "        \"\"\"",
            "        verbs = ('GET', 'PUT', 'HEAD', 'PATCH', 'DELETE', 'POST')",
            "        urls = (",
            "            'http://supports-http.com',",
            "            'https://supports-https.com',",
            "            'http://this/has/a/path/and/invalid/domain/name',",
            "            'https://supports-https.com:8080',",
            "            'http://supports-http.com:8080',",
            "        )",
            "        params = (None, {}, {b'page': [1]})",
            "        headers = (None, {}, {b'x-random-header': [b'value', b'value2']})",
            "        data = (None, b\"\", b'some data', b'{\"some\": \"json\"}')",
            "",
            "        stub = StubTreq(_StaticTestResource())",
            "",
            "        combos = (",
            "            (verb, {\"url\": url, \"params\": p, \"headers\": h, \"data\": d})",
            "            for verb in verbs",
            "            for url in urls",
            "            for p in params",
            "            for h in headers",
            "            for d in data",
            "        )",
            "        for combo in combos:",
            "            verb, kwargs = combo",
            "            deferreds = (stub.request(verb, **kwargs),",
            "                         getattr(stub, verb.lower())(**kwargs))",
            "            for d in deferreds:",
            "                resp = self.successResultOf(d)",
            "                self.assertEqual(418, resp.code)",
            "                self.assertEqual([b'teapot!'],",
            "                                 resp.headers.getRawHeaders(b'x-teapot'))",
            "                self.assertEqual(b\"\" if verb == \"HEAD\" else b\"I'm a teapot\",",
            "                                 self.successResultOf(stub.content(resp)))",
            "",
            "    def test_handles_invalid_schemes(self):",
            "        \"\"\"",
            "        Invalid URLs errback with a :obj:`SchemeNotSupported` failure, and does",
            "        so even after a successful request.",
            "        \"\"\"",
            "        stub = StubTreq(_StaticTestResource())",
            "        self.failureResultOf(stub.get(\"x-unknown-1:\"), SchemeNotSupported)",
            "        self.successResultOf(stub.get(\"http://url.com\"))",
            "        self.failureResultOf(stub.get(\"x-unknown-2:\"), SchemeNotSupported)",
            "",
            "    def test_files_are_rejected(self):",
            "        \"\"\"",
            "        StubTreq does not handle files yet - it should reject requests which",
            "        attempt to pass files.",
            "        \"\"\"",
            "        stub = StubTreq(_StaticTestResource())",
            "        self.assertRaises(",
            "            AssertionError, stub.request,",
            "            'method', 'http://url', files=b'some file')",
            "",
            "    def test_passing_in_strange_data_is_rejected(self):",
            "        \"\"\"",
            "        StubTreq rejects data that isn't list/dictionary/tuple/bytes/unicode.",
            "        \"\"\"",
            "        stub = StubTreq(_StaticTestResource())",
            "        self.assertRaises(",
            "            AssertionError, stub.request, 'method', 'http://url',",
            "            data=object())",
            "        self.successResultOf(stub.request('method', 'http://url', data={}))",
            "        self.successResultOf(stub.request('method', 'http://url', data=[]))",
            "        self.successResultOf(stub.request('method', 'http://url', data=()))",
            "        self.successResultOf(",
            "            stub.request('method', 'http://url', data=b\"\"))",
            "        self.successResultOf(",
            "            stub.request('method', 'http://url', data=\"\"))",
            "",
            "    def test_handles_failing_asynchronous_requests(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then canceling the",
            "        request.",
            "        \"\"\"",
            "        stub = StubTreq(_NonResponsiveTestResource())",
            "        d = stub.request('method', 'http://url', data=b\"1234\")",
            "        self.assertNoResult(d)",
            "        d.cancel()",
            "        self.failureResultOf(d, ResponseFailed)",
            "",
            "    def test_handles_successful_asynchronous_requests(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then later finishing the",
            "        response.",
            "        \"\"\"",
            "        rsrc = _EventuallyResponsiveTestResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request('method', 'http://example.com/', data=b\"1234\")",
            "        self.assertNoResult(d)",
            "        rsrc.stored_request.finish()",
            "        stub.flush()",
            "        resp = self.successResultOf(d)",
            "        self.assertEqual(resp.code, 200)",
            "",
            "    def test_handles_successful_asynchronous_requests_with_response_data(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then sending some data in",
            "        the response.",
            "        \"\"\"",
            "        rsrc = _EventuallyResponsiveTestResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request('method', 'http://example.com/', data=b\"1234\")",
            "        self.assertNoResult(d)",
            "",
            "        chunks = []",
            "        rsrc.stored_request.write(b'spam ')",
            "        rsrc.stored_request.write(b'eggs')",
            "        stub.flush()",
            "        resp = self.successResultOf(d)",
            "        d = stub.collect(resp, chunks.append)",
            "        self.assertNoResult(d)",
            "        self.assertEqual(b''.join(chunks), b'spam eggs')",
            "",
            "        rsrc.stored_request.finish()",
            "        stub.flush()",
            "        self.successResultOf(d)",
            "",
            "    def test_handles_successful_asynchronous_requests_with_streaming(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then streaming data back",
            "        gradually over time.",
            "        \"\"\"",
            "        rsrc = _EventuallyResponsiveTestResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request('method', 'http://example.com/', data=\"1234\")",
            "        self.assertNoResult(d)",
            "",
            "        chunks = []",
            "        rsrc.stored_request.write(b'spam ')",
            "        rsrc.stored_request.write(b'eggs')",
            "        stub.flush()",
            "        resp = self.successResultOf(d)",
            "        d = stub.collect(resp, chunks.append)",
            "        self.assertNoResult(d)",
            "        self.assertEqual(b''.join(chunks), b'spam eggs')",
            "",
            "        del chunks[:]",
            "        rsrc.stored_request.write(b'eggs\\r\\nspam\\r\\n')",
            "        stub.flush()",
            "        self.assertNoResult(d)",
            "        self.assertEqual(b''.join(chunks), b'eggs\\r\\nspam\\r\\n')",
            "",
            "        rsrc.stored_request.finish()",
            "        stub.flush()",
            "        self.successResultOf(d)",
            "",
            "    def test_session_persistence_between_requests(self):",
            "        \"\"\"",
            "        Calling request.getSession() in the wrapped resource will return",
            "        a session with the same ID, until the sessions are cleaned.",
            "        \"\"\"",
            "        rsrc = _SessionIdTestResource()",
            "        stub = StubTreq(rsrc)",
            "        # request 1, getting original session ID",
            "        d = stub.request(\"method\", \"http://example.com/\")",
            "        resp = self.successResultOf(d)",
            "        cookies = resp.cookies()",
            "        sid_1 = self.successResultOf(resp.content())",
            "        # request 2, ensuring session ID stays the same",
            "        d = stub.request(\"method\", \"http://example.com/\", cookies=cookies)",
            "        resp = self.successResultOf(d)",
            "        sid_2 = self.successResultOf(resp.content())",
            "        self.assertEqual(sid_1, sid_2)",
            "        # request 3, ensuring the session IDs are different after cleaning",
            "        # or expiring the sessions",
            "",
            "        # manually expire the sessions.",
            "        rsrc.expire_sessions()",
            "",
            "        d = stub.request(\"method\", \"http://example.com/\")",
            "        resp = self.successResultOf(d)",
            "        cookies = resp.cookies()",
            "        sid_3 = self.successResultOf(resp.content())",
            "        self.assertNotEqual(sid_1, sid_3)",
            "        # request 4, ensuring that once again the session IDs are the same",
            "        d = stub.request(\"method\", \"http://example.com/\", cookies=cookies)",
            "        resp = self.successResultOf(d)",
            "        sid_4 = self.successResultOf(resp.content())",
            "        self.assertEqual(sid_3, sid_4)",
            "",
            "",
            "class HasHeadersTests(TestCase):",
            "    \"\"\"",
            "    Tests for :obj:`HasHeaders`.",
            "    \"\"\"",
            "    def test_equality_and_strict_subsets_succeed(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` returns True if both sets of headers are",
            "        equivalent, or the first is a strict subset of the second.",
            "        \"\"\"",
            "        self.assertEqual(HasHeaders({'one': ['two', 'three']}),",
            "                         {'one': ['two', 'three']},",
            "                         \"Equivalent headers do not match.\")",
            "        self.assertEqual(HasHeaders({'one': ['two', 'three']}),",
            "                         {'one': ['two', 'three', 'four'],",
            "                          'ten': ['six']},",
            "                         \"Strict subset headers do not match\")",
            "",
            "    def test_partial_or_zero_intersection_subsets_fail(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` returns False if both sets of headers overlap",
            "        but the first is not a strict subset of the second.  It also returns",
            "        False if there is no overlap.",
            "        \"\"\"",
            "        self.assertNotEqual(HasHeaders({'one': ['two', 'three']}),",
            "                            {'one': ['three', 'four']},",
            "                            \"Partial value overlap matches\")",
            "        self.assertNotEqual(HasHeaders({'one': ['two', 'three']}),",
            "                            {'one': ['two']},",
            "                            \"Missing value matches\")",
            "        self.assertNotEqual(HasHeaders({'one': ['two', 'three']}),",
            "                            {'ten': ['six']},",
            "                            \"Complete inequality matches\")",
            "",
            "    def test_case_insensitive_keys(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` equality function ignores the case of the header",
            "        keys.",
            "        \"\"\"",
            "        self.assertEqual(HasHeaders({b'A': [b'1'], b'b': [b'2']}),",
            "                         {b'a': [b'1'], b'B': [b'2']})",
            "",
            "    def test_case_sensitive_values(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` equality function does care about the case of",
            "        the header value.",
            "        \"\"\"",
            "        self.assertNotEqual(HasHeaders({b'a': [b'a']}), {b'a': [b'A']})",
            "",
            "    def test_bytes_encoded_forms(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` equality function compares the bytes-encoded",
            "        forms of both sets of headers.",
            "        \"\"\"",
            "        self.assertEqual(HasHeaders({b'a': [b'a']}), {u'a': [u'a']})",
            "",
            "        self.assertEqual(HasHeaders({u'b': [u'b']}), {b'b': [b'b']})",
            "",
            "    def test_repr(self):",
            "        \"\"\"",
            "        :obj:`HasHeaders` returns a nice string repr.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            \"HasHeaders({b'a': [b'b']})\",",
            "            repr(HasHeaders({b\"A\": [b\"b\"]})),",
            "        )",
            "",
            "",
            "class StringStubbingTests(TestCase):",
            "    \"\"\"",
            "    Tests for :obj:`StringStubbingResource`.",
            "    \"\"\"",
            "    def _get_response_for(self, expected_args, response):",
            "        \"\"\"",
            "        Make a :obj:`IStringResponseStubs` that checks the expected args and",
            "        returns the given response.",
            "        \"\"\"",
            "        method, url, params, headers, data = expected_args",
            "",
            "        def get_response_for(_method, _url, _params, _headers, _data):",
            "            self.assertEqual((method, url, params, data),",
            "                             (_method, _url, _params, _data))",
            "            self.assertEqual(HasHeaders(headers), _headers)",
            "            return response",
            "",
            "        return get_response_for",
            "",
            "    def test_interacts_successfully_with_istub(self):",
            "        \"\"\"",
            "        The :obj:`IStringResponseStubs` is passed the correct parameters with",
            "        which to evaluate the response, and the response is returned.",
            "        \"\"\"",
            "        resource = StringStubbingResource(self._get_response_for(",
            "            (b'DELETE', 'http://what/a/thing', {b'page': [b'1']},",
            "             {b'x-header': [b'eh']}, b'datastr'),",
            "            (418, {b'x-response': b'responseheader'}, b'response body')))",
            "",
            "        stub = StubTreq(resource)",
            "",
            "        d = stub.delete('http://what/a/thing', headers={b'x-header': b'eh'},",
            "                        params={b'page': b'1'}, data=b'datastr')",
            "        resp = self.successResultOf(d)",
            "        self.assertEqual(418, resp.code)",
            "        self.assertEqual([b'responseheader'],",
            "                         resp.headers.getRawHeaders(b'x-response'))",
            "        self.assertEqual(b'response body',",
            "                         self.successResultOf(stub.content(resp)))",
            "",
            "",
            "class RequestSequenceTests(TestCase):",
            "    \"\"\"",
            "    Tests for :obj:`RequestSequence`.",
            "    \"\"\"",
            "    def setUp(self):",
            "        \"\"\"",
            "        Set up a way to report failures asynchronously.",
            "        \"\"\"",
            "        self.async_failures = []",
            "",
            "    def test_mismatched_request_causes_failure(self):",
            "        \"\"\"",
            "        If a request is made that is not expected as the next request,",
            "        causes a failure.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [((b'get', 'https://anything/', {b'1': [b'2']},",
            "               HasHeaders({b'1': [b'1']}), b'what'),",
            "              (418, {}, b'body')),",
            "             ((b'get', 'http://anything', {},",
            "               HasHeaders({b'2': [b'1']}), b'what'),",
            "              (202, {}, b'deleted'))],",
            "            async_failure_reporter=self.async_failures.append)",
            "",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "        get = partial(stub.get, 'https://anything?1=2', data=b'what',",
            "                      headers={b'1': b'1'})",
            "",
            "        resp = self.successResultOf(get())",
            "",
            "        self.assertEqual(418, resp.code)",
            "        self.assertEqual(b'body', self.successResultOf(stub.content(resp)))",
            "        self.assertEqual([], self.async_failures)",
            "",
            "        resp = self.successResultOf(get())",
            "        self.assertEqual(500, resp.code)",
            "        self.assertEqual(1, len(self.async_failures))",
            "        self.assertIn(\"Expected the next request to be\",",
            "                      self.async_failures[0])",
            "",
            "        self.assertFalse(sequence.consumed())",
            "",
            "    def test_unexpected_number_of_request_causes_failure(self):",
            "        \"\"\"",
            "        If there are no more expected requests, making a request causes a",
            "        failure.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [],",
            "            async_failure_reporter=self.async_failures.append)",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "        d = stub.get('https://anything', data=b'what', headers={b'1': b'1'})",
            "        resp = self.successResultOf(d)",
            "        self.assertEqual(500, resp.code)",
            "        self.assertEqual(b'StubbingError',",
            "                         self.successResultOf(resp.content()))",
            "        self.assertEqual(1, len(self.async_failures))",
            "        self.assertIn(\"No more requests expected, but request\",",
            "                      self.async_failures[0])",
            "",
            "        # the expected requests have all been made",
            "        self.assertTrue(sequence.consumed())",
            "",
            "    def test_works_with_mock_any(self):",
            "        \"\"\"",
            "        :obj:`mock.ANY` can be used with the request parameters.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [((ANY, ANY, ANY, ANY, ANY), (418, {}, b'body'))],",
            "            async_failure_reporter=self.async_failures.append)",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "",
            "        with sequence.consume(sync_failure_reporter=self.fail):",
            "            d = stub.get('https://anything', data=b'what',",
            "                         headers={b'1': b'1'})",
            "            resp = self.successResultOf(d)",
            "            self.assertEqual(418, resp.code)",
            "            self.assertEqual(b'body', self.successResultOf(stub.content(resp)))",
            "",
            "        self.assertEqual([], self.async_failures)",
            "",
            "        # the expected requests have all been made",
            "        self.assertTrue(sequence.consumed())",
            "",
            "    def test_consume_context_manager_fails_on_remaining_requests(self):",
            "        \"\"\"",
            "        If the `consume` context manager is used, if there are any remaining",
            "        expecting requests, the test case will be failed.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [((ANY, ANY, ANY, ANY, ANY), (418, {}, b'body'))] * 2,",
            "            async_failure_reporter=self.async_failures.append)",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "",
            "        consume_failures = []",
            "        with sequence.consume(sync_failure_reporter=consume_failures.append):",
            "",
            "            self.successResultOf(stub.get('https://anything', data=b'what',",
            "                                          headers={b'1': b'1'}))",
            "",
            "        self.assertEqual(1, len(consume_failures))",
            "        self.assertIn(",
            "            \"Not all expected requests were made.  Still expecting:\",",
            "            consume_failures[0])",
            "        self.assertIn(",
            "            \"{0}(url={0}, params={0}, headers={0}, data={0})\".format(",
            "                repr(ANY)),",
            "            consume_failures[0])",
            "",
            "        # no asynchronous failures (mismatches, etc.)",
            "        self.assertEqual([], self.async_failures)",
            "",
            "    def test_async_failures_logged(self):",
            "        \"\"\"",
            "        When no `async_failure_reporter` is passed async failures are logged by",
            "        default.",
            "        \"\"\"",
            "        sequence = RequestSequence([])",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "",
            "        with sequence.consume(self.fail):",
            "            self.successResultOf(stub.get('https://example.com'))",
            "",
            "        [failure] = self.flushLoggedErrors()",
            "        self.assertIsInstance(failure.value, AssertionError)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "In-memory treq returns stubbed responses.",
            "\"\"\"",
            "from functools import partial",
            "from inspect import getmembers, isfunction",
            "from json import dumps",
            "",
            "from unittest.mock import ANY",
            "",
            "from twisted.trial.unittest import TestCase",
            "from twisted.web.client import ResponseFailed",
            "from twisted.web.error import SchemeNotSupported",
            "from twisted.web.resource import Resource",
            "from twisted.web.server import NOT_DONE_YET",
            "",
            "import treq",
            "",
            "from treq.testing import (",
            "    HasHeaders,",
            "    RequestSequence,",
            "    StringStubbingResource,",
            "    StubTreq",
            ")",
            "",
            "",
            "class _StaticTestResource(Resource):",
            "    \"\"\"Resource that always returns 418 \"I'm a teapot\"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        request.setResponseCode(418)",
            "        request.setHeader(b\"x-teapot\", b\"teapot!\")",
            "        return b\"I'm a teapot\"",
            "",
            "",
            "class _RedirectResource(Resource):",
            "    \"\"\"",
            "    Resource that redirects to a different domain.",
            "    \"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        if b'redirected' not in request.uri:",
            "            request.redirect(b'https://example.org/redirected')",
            "        return dumps(",
            "            {",
            "                key.decode(\"charmap\"): [",
            "                    value.decode(\"charmap\")",
            "                    for value in values",
            "                ]",
            "                for key, values in",
            "                request.requestHeaders.getAllRawHeaders()}",
            "        ).encode(\"utf-8\")",
            "",
            "",
            "class _NonResponsiveTestResource(Resource):",
            "    \"\"\"Resource that returns NOT_DONE_YET and never finishes the request\"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        return NOT_DONE_YET",
            "",
            "",
            "class _EventuallyResponsiveTestResource(Resource):",
            "    \"\"\"",
            "    Resource that returns NOT_DONE_YET and stores the request so that something",
            "    else can finish the response later.",
            "    \"\"\"",
            "    isLeaf = True",
            "",
            "    def render(self, request):",
            "        self.stored_request = request",
            "        return NOT_DONE_YET",
            "",
            "",
            "class _SessionIdTestResource(Resource):",
            "    \"\"\"",
            "    Resource that returns the current session ID.",
            "    \"\"\"",
            "    isLeaf = True",
            "",
            "    def __init__(self):",
            "        super().__init__()",
            "        # keep track of all sessions created, so we can manually expire them later",
            "        self.sessions = []",
            "",
            "    def render(self, request):",
            "        session = request.getSession()",
            "        if session not in self.sessions:",
            "            # new session, add to internal list",
            "            self.sessions.append(session)",
            "        uid = session.uid",
            "        return uid",
            "",
            "    def expire_sessions(self):",
            "        \"\"\"",
            "        Manually expire all sessions created by this resource.",
            "        \"\"\"",
            "        for session in self.sessions:",
            "            session.expire()",
            "        self.sessions = []",
            "",
            "",
            "class StubbingTests(TestCase):",
            "    \"\"\"",
            "    Tests for :class:`StubTreq`.",
            "    \"\"\"",
            "    def test_stubtreq_provides_all_functions_in_treq_all(self):",
            "        \"\"\"",
            "        Every single function and attribute exposed by :obj:`treq.__all__` is",
            "        provided by :obj:`StubTreq`.",
            "        \"\"\"",
            "        treq_things = [(name, obj) for name, obj in getmembers(treq)",
            "                       if name in treq.__all__]",
            "        stub = StubTreq(_StaticTestResource())",
            "",
            "        api_things = [(name, obj) for name, obj in treq_things",
            "                      if obj.__module__ == \"treq.api\"]",
            "        content_things = [(name, obj) for name, obj in treq_things",
            "                          if obj.__module__ == \"treq.content\"]",
            "",
            "        # sanity checks - this test should fail if treq exposes a new API",
            "        # without changes being made to StubTreq and this test.",
            "        msg = (\"At the time this test was written, StubTreq only knew about \"",
            "               \"treq exposing functions from treq.api and treq.content.  If \"",
            "               \"this has changed, StubTreq will need to be updated, as will \"",
            "               \"this test.\")",
            "        self.assertTrue(all(isfunction(obj) for name, obj in treq_things), msg)",
            "        self.assertEqual(set(treq_things), set(api_things + content_things),",
            "                         msg)",
            "",
            "        for name, obj in api_things:",
            "            self.assertTrue(",
            "                isfunction(getattr(stub, name, None)),",
            "                \"StubTreq.{0} should be a function.\".format(name))",
            "",
            "        for name, obj in content_things:",
            "            self.assertIs(",
            "                getattr(stub, name, None), obj,",
            "                \"StubTreq.{0} should just expose treq.{0}\".format(name))",
            "",
            "    def test_providing_resource_to_stub_treq(self):",
            "        \"\"\"",
            "        The resource provided to StubTreq responds to every request no",
            "        matter what the URI or parameters or data.",
            "        \"\"\"",
            "        verbs = ('GET', 'PUT', 'HEAD', 'PATCH', 'DELETE', 'POST')",
            "        urls = (",
            "            'http://supports-http.com',",
            "            'https://supports-https.com',",
            "            'http://this/has/a/path/and/invalid/domain/name',",
            "            'https://supports-https.com:8080',",
            "            'http://supports-http.com:8080',",
            "        )",
            "        params = (None, {}, {b'page': [1]})",
            "        headers = (None, {}, {b'x-random-header': [b'value', b'value2']})",
            "        data = (None, b\"\", b'some data', b'{\"some\": \"json\"}')",
            "",
            "        stub = StubTreq(_StaticTestResource())",
            "",
            "        combos = (",
            "            (verb, {\"url\": url, \"params\": p, \"headers\": h, \"data\": d})",
            "            for verb in verbs",
            "            for url in urls",
            "            for p in params",
            "            for h in headers",
            "            for d in data",
            "        )",
            "        for combo in combos:",
            "            verb, kwargs = combo",
            "            deferreds = (stub.request(verb, **kwargs),",
            "                         getattr(stub, verb.lower())(**kwargs))",
            "            for d in deferreds:",
            "                resp = self.successResultOf(d)",
            "                self.assertEqual(418, resp.code)",
            "                self.assertEqual([b'teapot!'],",
            "                                 resp.headers.getRawHeaders(b'x-teapot'))",
            "                self.assertEqual(b\"\" if verb == \"HEAD\" else b\"I'm a teapot\",",
            "                                 self.successResultOf(stub.content(resp)))",
            "",
            "    def test_handles_invalid_schemes(self):",
            "        \"\"\"",
            "        Invalid URLs errback with a :obj:`SchemeNotSupported` failure, and does",
            "        so even after a successful request.",
            "        \"\"\"",
            "        stub = StubTreq(_StaticTestResource())",
            "        self.failureResultOf(stub.get(\"x-unknown-1:\"), SchemeNotSupported)",
            "        self.successResultOf(stub.get(\"http://url.com\"))",
            "        self.failureResultOf(stub.get(\"x-unknown-2:\"), SchemeNotSupported)",
            "",
            "    def test_files_are_rejected(self):",
            "        \"\"\"",
            "        StubTreq does not handle files yet - it should reject requests which",
            "        attempt to pass files.",
            "        \"\"\"",
            "        stub = StubTreq(_StaticTestResource())",
            "        self.assertRaises(",
            "            AssertionError, stub.request,",
            "            'method', 'http://url', files=b'some file')",
            "",
            "    def test_passing_in_strange_data_is_rejected(self):",
            "        \"\"\"",
            "        StubTreq rejects data that isn't list/dictionary/tuple/bytes/unicode.",
            "        \"\"\"",
            "        stub = StubTreq(_StaticTestResource())",
            "        self.assertRaises(",
            "            AssertionError, stub.request, 'method', 'http://url',",
            "            data=object())",
            "        self.successResultOf(stub.request('method', 'http://url', data={}))",
            "        self.successResultOf(stub.request('method', 'http://url', data=[]))",
            "        self.successResultOf(stub.request('method', 'http://url', data=()))",
            "        self.successResultOf(",
            "            stub.request('method', 'http://url', data=b\"\"))",
            "        self.successResultOf(",
            "            stub.request('method', 'http://url', data=\"\"))",
            "",
            "    def test_handles_failing_asynchronous_requests(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then canceling the",
            "        request.",
            "        \"\"\"",
            "        stub = StubTreq(_NonResponsiveTestResource())",
            "        d = stub.request('method', 'http://url', data=b\"1234\")",
            "        self.assertNoResult(d)",
            "        d.cancel()",
            "        self.failureResultOf(d, ResponseFailed)",
            "",
            "    def test_handles_successful_asynchronous_requests(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then later finishing the",
            "        response.",
            "        \"\"\"",
            "        rsrc = _EventuallyResponsiveTestResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request('method', 'http://example.com/', data=b\"1234\")",
            "        self.assertNoResult(d)",
            "        rsrc.stored_request.finish()",
            "        stub.flush()",
            "        resp = self.successResultOf(d)",
            "        self.assertEqual(resp.code, 200)",
            "",
            "    def test_handles_successful_asynchronous_requests_with_response_data(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then sending some data in",
            "        the response.",
            "        \"\"\"",
            "        rsrc = _EventuallyResponsiveTestResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request('method', 'http://example.com/', data=b\"1234\")",
            "        self.assertNoResult(d)",
            "",
            "        chunks = []",
            "        rsrc.stored_request.write(b'spam ')",
            "        rsrc.stored_request.write(b'eggs')",
            "        stub.flush()",
            "        resp = self.successResultOf(d)",
            "        d = stub.collect(resp, chunks.append)",
            "        self.assertNoResult(d)",
            "        self.assertEqual(b''.join(chunks), b'spam eggs')",
            "",
            "        rsrc.stored_request.finish()",
            "        stub.flush()",
            "        self.successResultOf(d)",
            "",
            "    def test_handles_successful_asynchronous_requests_with_streaming(self):",
            "        \"\"\"",
            "        Handle a resource returning NOT_DONE_YET and then streaming data back",
            "        gradually over time.",
            "        \"\"\"",
            "        rsrc = _EventuallyResponsiveTestResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request('method', 'http://example.com/', data=\"1234\")",
            "        self.assertNoResult(d)",
            "",
            "        chunks = []",
            "        rsrc.stored_request.write(b'spam ')",
            "        rsrc.stored_request.write(b'eggs')",
            "        stub.flush()",
            "        resp = self.successResultOf(d)",
            "        d = stub.collect(resp, chunks.append)",
            "        self.assertNoResult(d)",
            "        self.assertEqual(b''.join(chunks), b'spam eggs')",
            "",
            "        del chunks[:]",
            "        rsrc.stored_request.write(b'eggs\\r\\nspam\\r\\n')",
            "        stub.flush()",
            "        self.assertNoResult(d)",
            "        self.assertEqual(b''.join(chunks), b'eggs\\r\\nspam\\r\\n')",
            "",
            "        rsrc.stored_request.finish()",
            "        stub.flush()",
            "        self.successResultOf(d)",
            "",
            "    def test_session_persistence_between_requests(self):",
            "        \"\"\"",
            "        Calling request.getSession() in the wrapped resource will return a",
            "        session with the same ID, until the sessions are cleaned; in other",
            "        words, cookies are propagated between requests when the result of",
            "        C{response.cookies()} is passed to the next request.",
            "        \"\"\"",
            "        rsrc = _SessionIdTestResource()",
            "        stub = StubTreq(rsrc)",
            "        # request 1, getting original session ID",
            "        d = stub.request(\"method\", \"http://example.com/\")",
            "        resp = self.successResultOf(d)",
            "        cookies = resp.cookies()",
            "        sid_1 = self.successResultOf(resp.content())",
            "        # request 2, ensuring session ID stays the same",
            "        d = stub.request(\"method\", \"http://example.com/\", cookies=cookies)",
            "        resp = self.successResultOf(d)",
            "        sid_2 = self.successResultOf(resp.content())",
            "        self.assertEqual(sid_1, sid_2)",
            "        # request 3, ensuring the session IDs are different after cleaning",
            "        # or expiring the sessions",
            "",
            "        # manually expire the sessions.",
            "        rsrc.expire_sessions()",
            "",
            "        d = stub.request(\"method\", \"http://example.com/\")",
            "        resp = self.successResultOf(d)",
            "        cookies = resp.cookies()",
            "        sid_3 = self.successResultOf(resp.content())",
            "        self.assertNotEqual(sid_1, sid_3)",
            "        # request 4, ensuring that once again the session IDs are the same",
            "        d = stub.request(\"method\", \"http://example.com/\", cookies=cookies)",
            "        resp = self.successResultOf(d)",
            "        sid_4 = self.successResultOf(resp.content())",
            "        self.assertEqual(sid_3, sid_4)",
            "",
            "    def test_different_domains(self):",
            "        \"\"\"",
            "        Cookies manually specified as part of a dictionary are not relayed",
            "        through redirects.",
            "",
            "        (This is really more of a test for scoping of cookies within treq",
            "        itself, rather than just for testing.)",
            "        \"\"\"",
            "        rsrc = _RedirectResource()",
            "        stub = StubTreq(rsrc)",
            "        d = stub.request(",
            "            \"GET\", \"http://example.com/\",",
            "            cookies={\"not-across-redirect\": \"nope\"}",
            "        )",
            "        resp = self.successResultOf(d)",
            "        received = self.successResultOf(resp.json())",
            "        self.assertNotIn('not-across-redirect', received.get('Cookie', [''])[0])",
            "",
            "",
            "class HasHeadersTests(TestCase):",
            "    \"\"\"",
            "    Tests for :obj:`HasHeaders`.",
            "    \"\"\"",
            "    def test_equality_and_strict_subsets_succeed(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` returns True if both sets of headers are",
            "        equivalent, or the first is a strict subset of the second.",
            "        \"\"\"",
            "        self.assertEqual(HasHeaders({'one': ['two', 'three']}),",
            "                         {'one': ['two', 'three']},",
            "                         \"Equivalent headers do not match.\")",
            "        self.assertEqual(HasHeaders({'one': ['two', 'three']}),",
            "                         {'one': ['two', 'three', 'four'],",
            "                          'ten': ['six']},",
            "                         \"Strict subset headers do not match\")",
            "",
            "    def test_partial_or_zero_intersection_subsets_fail(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` returns False if both sets of headers overlap",
            "        but the first is not a strict subset of the second.  It also returns",
            "        False if there is no overlap.",
            "        \"\"\"",
            "        self.assertNotEqual(HasHeaders({'one': ['two', 'three']}),",
            "                            {'one': ['three', 'four']},",
            "                            \"Partial value overlap matches\")",
            "        self.assertNotEqual(HasHeaders({'one': ['two', 'three']}),",
            "                            {'one': ['two']},",
            "                            \"Missing value matches\")",
            "        self.assertNotEqual(HasHeaders({'one': ['two', 'three']}),",
            "                            {'ten': ['six']},",
            "                            \"Complete inequality matches\")",
            "",
            "    def test_case_insensitive_keys(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` equality function ignores the case of the header",
            "        keys.",
            "        \"\"\"",
            "        self.assertEqual(HasHeaders({b'A': [b'1'], b'b': [b'2']}),",
            "                         {b'a': [b'1'], b'B': [b'2']})",
            "",
            "    def test_case_sensitive_values(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` equality function does care about the case of",
            "        the header value.",
            "        \"\"\"",
            "        self.assertNotEqual(HasHeaders({b'a': [b'a']}), {b'a': [b'A']})",
            "",
            "    def test_bytes_encoded_forms(self):",
            "        \"\"\"",
            "        The :obj:`HasHeaders` equality function compares the bytes-encoded",
            "        forms of both sets of headers.",
            "        \"\"\"",
            "        self.assertEqual(HasHeaders({b'a': [b'a']}), {u'a': [u'a']})",
            "",
            "        self.assertEqual(HasHeaders({u'b': [u'b']}), {b'b': [b'b']})",
            "",
            "    def test_repr(self):",
            "        \"\"\"",
            "        :obj:`HasHeaders` returns a nice string repr.",
            "        \"\"\"",
            "        self.assertEqual(",
            "            \"HasHeaders({b'a': [b'b']})\",",
            "            repr(HasHeaders({b\"A\": [b\"b\"]})),",
            "        )",
            "",
            "",
            "class StringStubbingTests(TestCase):",
            "    \"\"\"",
            "    Tests for :obj:`StringStubbingResource`.",
            "    \"\"\"",
            "    def _get_response_for(self, expected_args, response):",
            "        \"\"\"",
            "        Make a :obj:`IStringResponseStubs` that checks the expected args and",
            "        returns the given response.",
            "        \"\"\"",
            "        method, url, params, headers, data = expected_args",
            "",
            "        def get_response_for(_method, _url, _params, _headers, _data):",
            "            self.assertEqual((method, url, params, data),",
            "                             (_method, _url, _params, _data))",
            "            self.assertEqual(HasHeaders(headers), _headers)",
            "            return response",
            "",
            "        return get_response_for",
            "",
            "    def test_interacts_successfully_with_istub(self):",
            "        \"\"\"",
            "        The :obj:`IStringResponseStubs` is passed the correct parameters with",
            "        which to evaluate the response, and the response is returned.",
            "        \"\"\"",
            "        resource = StringStubbingResource(self._get_response_for(",
            "            (b'DELETE', 'http://what/a/thing', {b'page': [b'1']},",
            "             {b'x-header': [b'eh']}, b'datastr'),",
            "            (418, {b'x-response': b'responseheader'}, b'response body')))",
            "",
            "        stub = StubTreq(resource)",
            "",
            "        d = stub.delete('http://what/a/thing', headers={b'x-header': b'eh'},",
            "                        params={b'page': b'1'}, data=b'datastr')",
            "        resp = self.successResultOf(d)",
            "        self.assertEqual(418, resp.code)",
            "        self.assertEqual([b'responseheader'],",
            "                         resp.headers.getRawHeaders(b'x-response'))",
            "        self.assertEqual(b'response body',",
            "                         self.successResultOf(stub.content(resp)))",
            "",
            "",
            "class RequestSequenceTests(TestCase):",
            "    \"\"\"",
            "    Tests for :obj:`RequestSequence`.",
            "    \"\"\"",
            "    def setUp(self):",
            "        \"\"\"",
            "        Set up a way to report failures asynchronously.",
            "        \"\"\"",
            "        self.async_failures = []",
            "",
            "    def test_mismatched_request_causes_failure(self):",
            "        \"\"\"",
            "        If a request is made that is not expected as the next request,",
            "        causes a failure.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [((b'get', 'https://anything/', {b'1': [b'2']},",
            "               HasHeaders({b'1': [b'1']}), b'what'),",
            "              (418, {}, b'body')),",
            "             ((b'get', 'http://anything', {},",
            "               HasHeaders({b'2': [b'1']}), b'what'),",
            "              (202, {}, b'deleted'))],",
            "            async_failure_reporter=self.async_failures.append)",
            "",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "        get = partial(stub.get, 'https://anything?1=2', data=b'what',",
            "                      headers={b'1': b'1'})",
            "",
            "        resp = self.successResultOf(get())",
            "",
            "        self.assertEqual(418, resp.code)",
            "        self.assertEqual(b'body', self.successResultOf(stub.content(resp)))",
            "        self.assertEqual([], self.async_failures)",
            "",
            "        resp = self.successResultOf(get())",
            "        self.assertEqual(500, resp.code)",
            "        self.assertEqual(1, len(self.async_failures))",
            "        self.assertIn(\"Expected the next request to be\",",
            "                      self.async_failures[0])",
            "",
            "        self.assertFalse(sequence.consumed())",
            "",
            "    def test_unexpected_number_of_request_causes_failure(self):",
            "        \"\"\"",
            "        If there are no more expected requests, making a request causes a",
            "        failure.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [],",
            "            async_failure_reporter=self.async_failures.append)",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "        d = stub.get('https://anything', data=b'what', headers={b'1': b'1'})",
            "        resp = self.successResultOf(d)",
            "        self.assertEqual(500, resp.code)",
            "        self.assertEqual(b'StubbingError',",
            "                         self.successResultOf(resp.content()))",
            "        self.assertEqual(1, len(self.async_failures))",
            "        self.assertIn(\"No more requests expected, but request\",",
            "                      self.async_failures[0])",
            "",
            "        # the expected requests have all been made",
            "        self.assertTrue(sequence.consumed())",
            "",
            "    def test_works_with_mock_any(self):",
            "        \"\"\"",
            "        :obj:`mock.ANY` can be used with the request parameters.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [((ANY, ANY, ANY, ANY, ANY), (418, {}, b'body'))],",
            "            async_failure_reporter=self.async_failures.append)",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "",
            "        with sequence.consume(sync_failure_reporter=self.fail):",
            "            d = stub.get('https://anything', data=b'what',",
            "                         headers={b'1': b'1'})",
            "            resp = self.successResultOf(d)",
            "            self.assertEqual(418, resp.code)",
            "            self.assertEqual(b'body', self.successResultOf(stub.content(resp)))",
            "",
            "        self.assertEqual([], self.async_failures)",
            "",
            "        # the expected requests have all been made",
            "        self.assertTrue(sequence.consumed())",
            "",
            "    def test_consume_context_manager_fails_on_remaining_requests(self):",
            "        \"\"\"",
            "        If the `consume` context manager is used, if there are any remaining",
            "        expecting requests, the test case will be failed.",
            "        \"\"\"",
            "        sequence = RequestSequence(",
            "            [((ANY, ANY, ANY, ANY, ANY), (418, {}, b'body'))] * 2,",
            "            async_failure_reporter=self.async_failures.append)",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "",
            "        consume_failures = []",
            "        with sequence.consume(sync_failure_reporter=consume_failures.append):",
            "",
            "            self.successResultOf(stub.get('https://anything', data=b'what',",
            "                                          headers={b'1': b'1'}))",
            "",
            "        self.assertEqual(1, len(consume_failures))",
            "        self.assertIn(",
            "            \"Not all expected requests were made.  Still expecting:\",",
            "            consume_failures[0])",
            "        self.assertIn(",
            "            \"{0}(url={0}, params={0}, headers={0}, data={0})\".format(",
            "                repr(ANY)),",
            "            consume_failures[0])",
            "",
            "        # no asynchronous failures (mismatches, etc.)",
            "        self.assertEqual([], self.async_failures)",
            "",
            "    def test_async_failures_logged(self):",
            "        \"\"\"",
            "        When no `async_failure_reporter` is passed async failures are logged by",
            "        default.",
            "        \"\"\"",
            "        sequence = RequestSequence([])",
            "        stub = StubTreq(StringStubbingResource(sequence))",
            "",
            "        with sequence.consume(self.fail):",
            "            self.successResultOf(stub.get('https://example.com'))",
            "",
            "        [failure] = self.flushLoggedErrors()",
            "        self.assertIsInstance(failure.value, AssertionError)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "275": [
                "StubbingTests",
                "test_session_persistence_between_requests"
            ],
            "276": [
                "StubbingTests",
                "test_session_persistence_between_requests"
            ]
        },
        "addLocation": [
            "hpack"
        ]
    },
    "src/treq/test/test_treq_integration.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         print('---')"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         print(response.code)"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         print(response.headers)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        print(response.request.headers)"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         text = yield treq.text_content(response)"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         print(text)"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         print('---')"
            }
        },
        "frontPatchFile": [
            "from io import BytesIO",
            "",
            "from twisted.python.url import URL",
            "",
            "from twisted.trial.unittest import TestCase",
            "from twisted.internet.defer import CancelledError, inlineCallbacks",
            "from twisted.internet.task import deferLater",
            "from twisted.internet import reactor",
            "from twisted.internet.tcp import Client",
            "from twisted.internet.ssl import Certificate, trustRootFromCertificates",
            "",
            "from twisted.web.client import (Agent, BrowserLikePolicyForHTTPS,",
            "                                HTTPConnectionPool, ResponseFailed)",
            "",
            "from treq.test.util import DEBUG, skip_on_windows_because_of_199",
            "",
            "from .local_httpbin.parent import _HTTPBinProcess",
            "",
            "import treq",
            "",
            "",
            "skip = skip_on_windows_because_of_199()",
            "",
            "",
            "@inlineCallbacks",
            "def print_response(response):",
            "    if DEBUG:",
            "        print()",
            "        print('---')",
            "        print(response.code)",
            "        print(response.headers)",
            "        text = yield treq.text_content(response)",
            "        print(text)",
            "        print('---')",
            "",
            "",
            "def with_baseurl(method):",
            "    def _request(self, url, *args, **kwargs):",
            "        return method(self.baseurl + url,",
            "                      *args,",
            "                      agent=self.agent,",
            "                      pool=self.pool,",
            "                      **kwargs)",
            "",
            "    return _request",
            "",
            "",
            "class TreqIntegrationTests(TestCase):",
            "    get = with_baseurl(treq.get)",
            "    head = with_baseurl(treq.head)",
            "    post = with_baseurl(treq.post)",
            "    put = with_baseurl(treq.put)",
            "    patch = with_baseurl(treq.patch)",
            "    delete = with_baseurl(treq.delete)",
            "",
            "    _httpbin_process = _HTTPBinProcess(https=False)",
            "",
            "    @inlineCallbacks",
            "    def setUp(self):",
            "        description = yield self._httpbin_process.server_description(",
            "            reactor)",
            "        self.baseurl = URL(scheme=u\"http\",",
            "                           host=description.host,",
            "                           port=description.port).asText()",
            "        self.agent = Agent(reactor)",
            "        self.pool = HTTPConnectionPool(reactor, False)",
            "",
            "    def tearDown(self):",
            "        def _check_fds(_):",
            "            # This appears to only be necessary for HTTPS tests.",
            "            # For the normal HTTP tests then closeCachedConnections is",
            "            # sufficient.",
            "            fds = set(reactor.getReaders() + reactor.getReaders())",
            "            if not [fd for fd in fds if isinstance(fd, Client)]:",
            "                return",
            "",
            "            return deferLater(reactor, 0, _check_fds, None)",
            "",
            "        return self.pool.closeCachedConnections().addBoth(_check_fds)",
            "",
            "    @inlineCallbacks",
            "    def assert_data(self, response, expected_data):",
            "        body = yield treq.json_content(response)",
            "        self.assertIn('data', body)",
            "        self.assertEqual(body['data'], expected_data)",
            "",
            "    @inlineCallbacks",
            "    def assert_sent_header(self, response, header, expected_value):",
            "        body = yield treq.json_content(response)",
            "        self.assertIn(header, body['headers'])",
            "        self.assertEqual(body['headers'][header], expected_value)",
            "",
            "    @inlineCallbacks",
            "    def test_get(self):",
            "        response = yield self.get('/get')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_headers(self):",
            "        response = yield self.get('/get', {b'X-Blah': [b'Foo', b'Bar']})",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_sent_header(response, 'X-Blah', 'Foo,Bar')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_headers_unicode(self):",
            "        response = yield self.get('/get', {u'X-Blah': [u'Foo', b'Bar']})",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_sent_header(response, 'X-Blah', 'Foo,Bar')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_302_absolute_redirect(self):",
            "        response = yield self.get(",
            "            '/redirect-to?url={0}/get'.format(self.baseurl))",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_302_relative_redirect(self):",
            "        response = yield self.get('/relative-redirect/1')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_302_redirect_disallowed(self):",
            "        response = yield self.get('/redirect/1', allow_redirects=False)",
            "        self.assertEqual(response.code, 302)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head(self):",
            "        response = yield self.head('/get')",
            "        body = yield treq.content(response)",
            "        self.assertEqual(b'', body)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head_302_absolute_redirect(self):",
            "        response = yield self.head(",
            "            '/redirect-to?url={0}/get'.format(self.baseurl))",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head_302_relative_redirect(self):",
            "        response = yield self.head('/relative-redirect/1')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head_302_redirect_disallowed(self):",
            "        response = yield self.head('/redirect/1', allow_redirects=False)",
            "        self.assertEqual(response.code, 302)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_post(self):",
            "        response = yield self.post('/post', b'Hello!')",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_data(response, 'Hello!')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_multipart_post(self):",
            "        class FileLikeObject(BytesIO):",
            "            def __init__(self, val):",
            "                BytesIO.__init__(self, val)",
            "                self.name = \"david.png\"",
            "",
            "            def read(*args, **kwargs):",
            "                return BytesIO.read(*args, **kwargs)",
            "",
            "        response = yield self.post(",
            "            '/post',",
            "            data={\"a\": \"b\"},",
            "            files={\"file1\": FileLikeObject(b\"file\")})",
            "        self.assertEqual(response.code, 200)",
            "",
            "        body = yield treq.json_content(response)",
            "        self.assertEqual('b', body['form']['a'])",
            "        self.assertEqual('file', body['files']['file1'])",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_post_headers(self):",
            "        response = yield self.post(",
            "            '/post',",
            "            b'{msg: \"Hello!\"}',",
            "            headers={'Content-Type': ['application/json']}",
            "        )",
            "",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_sent_header(",
            "            response, 'Content-Type', 'application/json')",
            "        yield self.assert_data(response, '{msg: \"Hello!\"}')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_put(self):",
            "        response = yield self.put('/put', data=b'Hello!')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_patch(self):",
            "        response = yield self.patch('/patch', data=b'Hello!')",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_data(response, 'Hello!')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_delete(self):",
            "        response = yield self.delete('/delete')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_gzip(self):",
            "        response = yield self.get('/gzip')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        json = yield treq.json_content(response)",
            "        self.assertTrue(json['gzipped'])",
            "",
            "    @inlineCallbacks",
            "    def test_basic_auth(self):",
            "        response = yield self.get('/basic-auth/treq/treq',",
            "                                  auth=('treq', 'treq'))",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        json = yield treq.json_content(response)",
            "        self.assertTrue(json['authenticated'])",
            "        self.assertEqual(json['user'], 'treq')",
            "",
            "    @inlineCallbacks",
            "    def test_failed_basic_auth(self):",
            "        response = yield self.get('/basic-auth/treq/treq',",
            "                                  auth=('not-treq', 'not-treq'))",
            "        self.assertEqual(response.code, 401)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_timeout(self):",
            "        \"\"\"",
            "        Verify a timeout fires if a request takes too long.",
            "        \"\"\"",
            "        yield self.assertFailure(self.get('/delay/2', timeout=1),",
            "                                 CancelledError,",
            "                                 ResponseFailed)",
            "",
            "    @inlineCallbacks",
            "    def test_cookie(self):",
            "        response = yield self.get('/cookies', cookies={'hello': 'there'})",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        json = yield treq.json_content(response)",
            "        self.assertEqual(json['cookies']['hello'], 'there')",
            "",
            "    @inlineCallbacks",
            "    def test_set_cookie(self):",
            "        response = yield self.get('/cookies/set',",
            "                                  allow_redirects=False,",
            "                                  params={'hello': 'there'})",
            "        # self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        self.assertEqual(response.cookies()['hello'], 'there')",
            "",
            "",
            "class HTTPSTreqIntegrationTests(TreqIntegrationTests):",
            "    _httpbin_process = _HTTPBinProcess(https=True)",
            "",
            "    @inlineCallbacks",
            "    def setUp(self):",
            "        description = yield self._httpbin_process.server_description(",
            "            reactor)",
            "        self.baseurl = URL(scheme=u\"https\",",
            "                           host=description.host,",
            "                           port=description.port).asText()",
            "",
            "        root = trustRootFromCertificates(",
            "            [Certificate.loadPEM(description.cacert)],",
            "        )",
            "        self.agent = Agent(",
            "            reactor,",
            "            contextFactory=BrowserLikePolicyForHTTPS(root),",
            "        )",
            "",
            "        self.pool = HTTPConnectionPool(reactor, False)"
        ],
        "afterPatchFile": [
            "from io import BytesIO",
            "",
            "from twisted.python.url import URL",
            "",
            "from twisted.trial.unittest import TestCase",
            "from twisted.internet.defer import CancelledError, inlineCallbacks",
            "from twisted.internet.task import deferLater",
            "from twisted.internet import reactor",
            "from twisted.internet.tcp import Client",
            "from twisted.internet.ssl import Certificate, trustRootFromCertificates",
            "",
            "from twisted.web.client import (Agent, BrowserLikePolicyForHTTPS,",
            "                                HTTPConnectionPool, ResponseFailed)",
            "",
            "from treq.test.util import DEBUG, skip_on_windows_because_of_199",
            "",
            "from .local_httpbin.parent import _HTTPBinProcess",
            "",
            "import treq",
            "",
            "",
            "skip = skip_on_windows_because_of_199()",
            "",
            "",
            "@inlineCallbacks",
            "def print_response(response):",
            "    if DEBUG:",
            "        print()",
            "        print('---')",
            "        print(response.code)",
            "        print(response.headers)",
            "        print(response.request.headers)",
            "        text = yield treq.text_content(response)",
            "        print(text)",
            "        print('---')",
            "",
            "",
            "def with_baseurl(method):",
            "    def _request(self, url, *args, **kwargs):",
            "        return method(self.baseurl + url,",
            "                      *args,",
            "                      agent=self.agent,",
            "                      pool=self.pool,",
            "                      **kwargs)",
            "",
            "    return _request",
            "",
            "",
            "class TreqIntegrationTests(TestCase):",
            "    get = with_baseurl(treq.get)",
            "    head = with_baseurl(treq.head)",
            "    post = with_baseurl(treq.post)",
            "    put = with_baseurl(treq.put)",
            "    patch = with_baseurl(treq.patch)",
            "    delete = with_baseurl(treq.delete)",
            "",
            "    _httpbin_process = _HTTPBinProcess(https=False)",
            "",
            "    @inlineCallbacks",
            "    def setUp(self):",
            "        description = yield self._httpbin_process.server_description(",
            "            reactor)",
            "        self.baseurl = URL(scheme=u\"http\",",
            "                           host=description.host,",
            "                           port=description.port).asText()",
            "        self.agent = Agent(reactor)",
            "        self.pool = HTTPConnectionPool(reactor, False)",
            "",
            "    def tearDown(self):",
            "        def _check_fds(_):",
            "            # This appears to only be necessary for HTTPS tests.",
            "            # For the normal HTTP tests then closeCachedConnections is",
            "            # sufficient.",
            "            fds = set(reactor.getReaders() + reactor.getReaders())",
            "            if not [fd for fd in fds if isinstance(fd, Client)]:",
            "                return",
            "",
            "            return deferLater(reactor, 0, _check_fds, None)",
            "",
            "        return self.pool.closeCachedConnections().addBoth(_check_fds)",
            "",
            "    @inlineCallbacks",
            "    def assert_data(self, response, expected_data):",
            "        body = yield treq.json_content(response)",
            "        self.assertIn('data', body)",
            "        self.assertEqual(body['data'], expected_data)",
            "",
            "    @inlineCallbacks",
            "    def assert_sent_header(self, response, header, expected_value):",
            "        body = yield treq.json_content(response)",
            "        self.assertIn(header, body['headers'])",
            "        self.assertEqual(body['headers'][header], expected_value)",
            "",
            "    @inlineCallbacks",
            "    def test_get(self):",
            "        response = yield self.get('/get')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_headers(self):",
            "        response = yield self.get('/get', {b'X-Blah': [b'Foo', b'Bar']})",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_sent_header(response, 'X-Blah', 'Foo,Bar')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_headers_unicode(self):",
            "        response = yield self.get('/get', {u'X-Blah': [u'Foo', b'Bar']})",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_sent_header(response, 'X-Blah', 'Foo,Bar')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_302_absolute_redirect(self):",
            "        response = yield self.get(",
            "            '/redirect-to?url={0}/get'.format(self.baseurl))",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_302_relative_redirect(self):",
            "        response = yield self.get('/relative-redirect/1')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_get_302_redirect_disallowed(self):",
            "        response = yield self.get('/redirect/1', allow_redirects=False)",
            "        self.assertEqual(response.code, 302)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head(self):",
            "        response = yield self.head('/get')",
            "        body = yield treq.content(response)",
            "        self.assertEqual(b'', body)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head_302_absolute_redirect(self):",
            "        response = yield self.head(",
            "            '/redirect-to?url={0}/get'.format(self.baseurl))",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head_302_relative_redirect(self):",
            "        response = yield self.head('/relative-redirect/1')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_head_302_redirect_disallowed(self):",
            "        response = yield self.head('/redirect/1', allow_redirects=False)",
            "        self.assertEqual(response.code, 302)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_post(self):",
            "        response = yield self.post('/post', b'Hello!')",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_data(response, 'Hello!')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_multipart_post(self):",
            "        class FileLikeObject(BytesIO):",
            "            def __init__(self, val):",
            "                BytesIO.__init__(self, val)",
            "                self.name = \"david.png\"",
            "",
            "            def read(*args, **kwargs):",
            "                return BytesIO.read(*args, **kwargs)",
            "",
            "        response = yield self.post(",
            "            '/post',",
            "            data={\"a\": \"b\"},",
            "            files={\"file1\": FileLikeObject(b\"file\")})",
            "        self.assertEqual(response.code, 200)",
            "",
            "        body = yield treq.json_content(response)",
            "        self.assertEqual('b', body['form']['a'])",
            "        self.assertEqual('file', body['files']['file1'])",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_post_headers(self):",
            "        response = yield self.post(",
            "            '/post',",
            "            b'{msg: \"Hello!\"}',",
            "            headers={'Content-Type': ['application/json']}",
            "        )",
            "",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_sent_header(",
            "            response, 'Content-Type', 'application/json')",
            "        yield self.assert_data(response, '{msg: \"Hello!\"}')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_put(self):",
            "        response = yield self.put('/put', data=b'Hello!')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_patch(self):",
            "        response = yield self.patch('/patch', data=b'Hello!')",
            "        self.assertEqual(response.code, 200)",
            "        yield self.assert_data(response, 'Hello!')",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_delete(self):",
            "        response = yield self.delete('/delete')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_gzip(self):",
            "        response = yield self.get('/gzip')",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        json = yield treq.json_content(response)",
            "        self.assertTrue(json['gzipped'])",
            "",
            "    @inlineCallbacks",
            "    def test_basic_auth(self):",
            "        response = yield self.get('/basic-auth/treq/treq',",
            "                                  auth=('treq', 'treq'))",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        json = yield treq.json_content(response)",
            "        self.assertTrue(json['authenticated'])",
            "        self.assertEqual(json['user'], 'treq')",
            "",
            "    @inlineCallbacks",
            "    def test_failed_basic_auth(self):",
            "        response = yield self.get('/basic-auth/treq/treq',",
            "                                  auth=('not-treq', 'not-treq'))",
            "        self.assertEqual(response.code, 401)",
            "        yield print_response(response)",
            "",
            "    @inlineCallbacks",
            "    def test_timeout(self):",
            "        \"\"\"",
            "        Verify a timeout fires if a request takes too long.",
            "        \"\"\"",
            "        yield self.assertFailure(self.get('/delay/2', timeout=1),",
            "                                 CancelledError,",
            "                                 ResponseFailed)",
            "",
            "    @inlineCallbacks",
            "    def test_cookie(self):",
            "        response = yield self.get('/cookies', cookies={'hello': 'there'})",
            "        self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        json = yield treq.json_content(response)",
            "        self.assertEqual(json['cookies']['hello'], 'there')",
            "",
            "    @inlineCallbacks",
            "    def test_set_cookie(self):",
            "        response = yield self.get('/cookies/set',",
            "                                  allow_redirects=False,",
            "                                  params={'hello': 'there'})",
            "        # self.assertEqual(response.code, 200)",
            "        yield print_response(response)",
            "        self.assertEqual(response.cookies()['hello'], 'there')",
            "",
            "",
            "class HTTPSTreqIntegrationTests(TreqIntegrationTests):",
            "    _httpbin_process = _HTTPBinProcess(https=True)",
            "",
            "    @inlineCallbacks",
            "    def setUp(self):",
            "        description = yield self._httpbin_process.server_description(",
            "            reactor)",
            "        self.baseurl = URL(scheme=u\"https\",",
            "                           host=description.host,",
            "                           port=description.port).asText()",
            "",
            "        root = trustRootFromCertificates(",
            "            [Certificate.loadPEM(description.cacert)],",
            "        )",
            "        self.agent = Agent(",
            "            reactor,",
            "            contextFactory=BrowserLikePolicyForHTTPS(root),",
            "        )",
            "",
            "        self.pool = HTTPConnectionPool(reactor, False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_cookie",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_failed_basic_auth",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_post",
            "hpack",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_head_302_absolute_redirect",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_get_302_absolute_redirect",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_delete",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_get_headers_unicode",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_head_302_relative_redirect",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_post_headers",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_patch",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_get_302_relative_redirect",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_get",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_multipart_post",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_get_headers",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_put",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_head",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_gzip",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_set_cookie",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_get_302_redirect_disallowed",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_head_302_redirect_disallowed",
            "src.treq.test.test_treq_integration.TreqIntegrationTests.test_basic_auth"
        ]
    }
}