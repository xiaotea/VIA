{
    "tensorflow/python/dlpack/dlpack_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from absl.testing import parameterized"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import numpy as np"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from tensorflow.python.dlpack import dlpack"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from tensorflow.python.framework import constant_op"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from tensorflow.python.framework import dtypes"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from tensorflow.python.framework import errors"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from tensorflow.python.framework import ops"
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from tensorflow.python.platform import test"
            },
            "10": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from tensorflow.python.ops import array_ops"
            },
            "11": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "     self.assertRaisesRegex(Exception, \".* is not supported by dlpack\","
            },
            "12": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                            UnsupportedComplex64)"
            },
            "13": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+  def testMustPassTensorArgumentToDLPack(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        errors.InvalidArgumentError,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        \"The argument to `to_dlpack` must be a TF tensor, not Python object\"):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+      dlpack.to_dlpack([1])"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "22": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "   ops.enable_eager_execution()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for DLPack functions.\"\"\"",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import print_function",
            "",
            "from absl.testing import parameterized",
            "import numpy as np",
            "",
            "from tensorflow.python.dlpack import dlpack",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.platform import test",
            "from tensorflow.python.ops import array_ops",
            "",
            "int_dtypes = [",
            "    np.int8, np.int16, np.int32, np.int64, np.uint8, np.uint16, np.uint32,",
            "    np.uint64",
            "]",
            "float_dtypes = [np.float16, np.float32, np.float64]",
            "complex_dtypes = [np.complex64, np.complex128]",
            "dlpack_dtypes = int_dtypes + float_dtypes + [dtypes.bfloat16]",
            "",
            "testcase_shapes = [(), (1,), (2, 3), (2, 0), (0, 7), (4, 1, 2)]",
            "",
            "",
            "def FormatShapeAndDtype(shape, dtype):",
            "  return \"_{}[{}]\".format(str(dtype), \",\".join(map(str, shape)))",
            "",
            "",
            "def GetNamedTestParameters():",
            "  result = []",
            "  for dtype in dlpack_dtypes:",
            "    for shape in testcase_shapes:",
            "      result.append({",
            "          \"testcase_name\": FormatShapeAndDtype(shape, dtype),",
            "          \"dtype\": dtype,",
            "          \"shape\": shape",
            "      })",
            "  return result",
            "",
            "",
            "class DLPackTest(parameterized.TestCase, test.TestCase):",
            "",
            "  @parameterized.named_parameters(GetNamedTestParameters())",
            "  def testRoundTrip(self, dtype, shape):",
            "    np.random.seed(42)",
            "    np_array = np.random.randint(0, 10, shape)",
            "    # copy to gpu if available",
            "    tf_tensor = array_ops.identity(constant_op.constant(np_array, dtype=dtype))",
            "    tf_tensor_device = tf_tensor.device",
            "    tf_tensor_dtype = tf_tensor.dtype",
            "    dlcapsule = dlpack.to_dlpack(tf_tensor)",
            "    del tf_tensor  # should still work",
            "    tf_tensor2 = dlpack.from_dlpack(dlcapsule)",
            "    self.assertAllClose(np_array, tf_tensor2)",
            "    if tf_tensor_dtype == dtypes.int32:",
            "      # int32 tensor is always on cpu for now",
            "      self.assertEqual(tf_tensor2.device,",
            "                       \"/job:localhost/replica:0/task:0/device:CPU:0\")",
            "    else:",
            "      self.assertEqual(tf_tensor_device, tf_tensor2.device)",
            "",
            "  def testTensorsCanBeConsumedOnceOnly(self):",
            "    np.random.seed(42)",
            "    np_array = np.random.randint(0, 10, (2, 3, 4))",
            "    tf_tensor = constant_op.constant(np_array, dtype=np.float32)",
            "    dlcapsule = dlpack.to_dlpack(tf_tensor)",
            "    del tf_tensor  # should still work",
            "    _ = dlpack.from_dlpack(dlcapsule)",
            "",
            "    def ConsumeDLPackTensor():",
            "      dlpack.from_dlpack(dlcapsule)  # Should can be consumed only once",
            "",
            "    self.assertRaisesRegex(Exception,",
            "                           \".*a DLPack tensor may be consumed at most once.*\",",
            "                           ConsumeDLPackTensor)",
            "",
            "  def testUnsupportedTypeToDLPack(self):",
            "",
            "    def UnsupportedQint16():",
            "      tf_tensor = constant_op.constant([[1, 4], [5, 2]], dtype=dtypes.qint16)",
            "      _ = dlpack.to_dlpack(tf_tensor)",
            "",
            "    def UnsupportedComplex64():",
            "      tf_tensor = constant_op.constant([[1, 4], [5, 2]], dtype=dtypes.complex64)",
            "      _ = dlpack.to_dlpack(tf_tensor)",
            "",
            "    self.assertRaisesRegex(Exception, \".* is not supported by dlpack\",",
            "                           UnsupportedQint16)",
            "    self.assertRaisesRegex(Exception, \".* is not supported by dlpack\",",
            "                           UnsupportedComplex64)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  ops.enable_eager_execution()",
            "  test.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for DLPack functions.\"\"\"",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import print_function",
            "",
            "from absl.testing import parameterized",
            "import numpy as np",
            "",
            "",
            "from tensorflow.python.dlpack import dlpack",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.platform import test",
            "from tensorflow.python.ops import array_ops",
            "",
            "int_dtypes = [",
            "    np.int8, np.int16, np.int32, np.int64, np.uint8, np.uint16, np.uint32,",
            "    np.uint64",
            "]",
            "float_dtypes = [np.float16, np.float32, np.float64]",
            "complex_dtypes = [np.complex64, np.complex128]",
            "dlpack_dtypes = int_dtypes + float_dtypes + [dtypes.bfloat16]",
            "",
            "testcase_shapes = [(), (1,), (2, 3), (2, 0), (0, 7), (4, 1, 2)]",
            "",
            "",
            "def FormatShapeAndDtype(shape, dtype):",
            "  return \"_{}[{}]\".format(str(dtype), \",\".join(map(str, shape)))",
            "",
            "",
            "def GetNamedTestParameters():",
            "  result = []",
            "  for dtype in dlpack_dtypes:",
            "    for shape in testcase_shapes:",
            "      result.append({",
            "          \"testcase_name\": FormatShapeAndDtype(shape, dtype),",
            "          \"dtype\": dtype,",
            "          \"shape\": shape",
            "      })",
            "  return result",
            "",
            "",
            "class DLPackTest(parameterized.TestCase, test.TestCase):",
            "",
            "  @parameterized.named_parameters(GetNamedTestParameters())",
            "  def testRoundTrip(self, dtype, shape):",
            "    np.random.seed(42)",
            "    np_array = np.random.randint(0, 10, shape)",
            "    # copy to gpu if available",
            "    tf_tensor = array_ops.identity(constant_op.constant(np_array, dtype=dtype))",
            "    tf_tensor_device = tf_tensor.device",
            "    tf_tensor_dtype = tf_tensor.dtype",
            "    dlcapsule = dlpack.to_dlpack(tf_tensor)",
            "    del tf_tensor  # should still work",
            "    tf_tensor2 = dlpack.from_dlpack(dlcapsule)",
            "    self.assertAllClose(np_array, tf_tensor2)",
            "    if tf_tensor_dtype == dtypes.int32:",
            "      # int32 tensor is always on cpu for now",
            "      self.assertEqual(tf_tensor2.device,",
            "                       \"/job:localhost/replica:0/task:0/device:CPU:0\")",
            "    else:",
            "      self.assertEqual(tf_tensor_device, tf_tensor2.device)",
            "",
            "  def testTensorsCanBeConsumedOnceOnly(self):",
            "    np.random.seed(42)",
            "    np_array = np.random.randint(0, 10, (2, 3, 4))",
            "    tf_tensor = constant_op.constant(np_array, dtype=np.float32)",
            "    dlcapsule = dlpack.to_dlpack(tf_tensor)",
            "    del tf_tensor  # should still work",
            "    _ = dlpack.from_dlpack(dlcapsule)",
            "",
            "    def ConsumeDLPackTensor():",
            "      dlpack.from_dlpack(dlcapsule)  # Should can be consumed only once",
            "",
            "    self.assertRaisesRegex(Exception,",
            "                           \".*a DLPack tensor may be consumed at most once.*\",",
            "                           ConsumeDLPackTensor)",
            "",
            "  def testUnsupportedTypeToDLPack(self):",
            "",
            "    def UnsupportedQint16():",
            "      tf_tensor = constant_op.constant([[1, 4], [5, 2]], dtype=dtypes.qint16)",
            "      _ = dlpack.to_dlpack(tf_tensor)",
            "",
            "    def UnsupportedComplex64():",
            "      tf_tensor = constant_op.constant([[1, 4], [5, 2]], dtype=dtypes.complex64)",
            "      _ = dlpack.to_dlpack(tf_tensor)",
            "",
            "    self.assertRaisesRegex(Exception, \".* is not supported by dlpack\",",
            "                           UnsupportedQint16)",
            "    self.assertRaisesRegex(Exception, \".* is not supported by dlpack\",",
            "                           UnsupportedComplex64)",
            "",
            "  def testMustPassTensorArgumentToDLPack(self):",
            "    with self.assertRaisesRegex(",
            "        errors.InvalidArgumentError,",
            "        \"The argument to `to_dlpack` must be a TF tensor, not Python object\"):",
            "      dlpack.to_dlpack([1])",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  ops.enable_eager_execution()",
            "  test.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "openstack_dashboard.dashboards.project.stacks.forms.TemplateForm"
        ]
    }
}