{
    "src/pydash/helpers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " def _base_get_object(obj, key, default=UNSET):"
            },
            "1": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     value = _base_get_item(obj, key, default=UNSET)"
            },
            "2": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     if value is UNSET:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        _raise_if_restricted_key(key)"
            },
            "4": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         value = default"
            },
            "5": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         try:"
            },
            "6": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "             value = getattr(obj, key)"
            },
            "7": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     return value"
            },
            "8": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+def _raise_if_restricted_key(key):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+    # Prevent access to dunder-methods since this could expose access to globals through leaky"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    # attributes such as obj.__init__.__globals__."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+    if len(key) > 4 and key.isascii() and key.startswith(\"__\") and key.endswith(\"__\"):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        raise KeyError(f\"access to restricted key {key!r} is not allowed\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " def base_set(obj, key, value, allow_override=True):"
            },
            "18": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "     \"\"\""
            },
            "19": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available"
            },
            "20": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "                 obj[:] = (obj + [None] * key)[:key]"
            },
            "21": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "             obj.append(value)"
            },
            "22": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "     elif (allow_override or not hasattr(obj, key)) and obj is not None:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        _raise_if_restricted_key(key)"
            },
            "24": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         setattr(obj, key, value)"
            },
            "25": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 226,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "     return obj"
            }
        },
        "frontPatchFile": [
            "\"\"\"Generic utility methods not part of main API.\"\"\"",
            "",
            "import builtins",
            "from collections.abc import Hashable, Iterable, Mapping, Sequence",
            "from decimal import Decimal",
            "from functools import wraps",
            "import inspect",
            "from inspect import getfullargspec",
            "import warnings",
            "",
            "import pydash as pyd",
            "",
            "",
            "#: Singleton object that differentiates between an explicit ``None`` value and an unset value.",
            "UNSET = object()",
            "",
            "#: Tuple of number types.",
            "NUMBER_TYPES = (int, float, Decimal)",
            "",
            "#: Dictionary of builtins with keys as the builtin function and values as the string name.",
            "BUILTINS = {value: key for key, value in builtins.__dict__.items() if isinstance(value, Hashable)}",
            "",
            "",
            "def callit(iteratee, *args, **kwargs):",
            "    \"\"\"Inspect argspec of `iteratee` function and only pass the supported arguments when calling",
            "    it.\"\"\"",
            "    maxargs = len(args)",
            "    argcount = kwargs[\"argcount\"] if \"argcount\" in kwargs else getargcount(iteratee, maxargs)",
            "    argstop = min([maxargs, argcount])",
            "",
            "    return iteratee(*args[:argstop])",
            "",
            "",
            "def getargcount(iteratee, maxargs):",
            "    \"\"\"Return argument count of iteratee function.\"\"\"",
            "    if hasattr(iteratee, \"_argcount\"):",
            "        # Optimization feature where argcount of iteratee is known and properly",
            "        # set by initiator.",
            "        return iteratee._argcount",
            "",
            "    if isinstance(iteratee, type) or pyd.is_builtin(iteratee):",
            "        # Only pass single argument to type iteratees or builtins.",
            "        argcount = 1",
            "    else:",
            "        argcount = 1",
            "",
            "        try:",
            "            argcount = _getargcount(iteratee, maxargs)",
            "        except TypeError:  # pragma: no cover",
            "            pass",
            "",
            "    return argcount",
            "",
            "",
            "def _getargcount(iteratee, maxargs):",
            "    argcount = None",
            "",
            "    try:",
            "        # PY2: inspect.signature was added in Python 3.",
            "        # Try to use inspect.signature when possible since it works better for our purpose of",
            "        # getting the iteratee argcount since it takes into account the \"self\" argument in callable",
            "        # classes.",
            "        sig = inspect.signature(iteratee)",
            "    except (TypeError, ValueError, AttributeError):",
            "        pass",
            "    else:  # pragma: no cover",
            "        if not any(",
            "            param.kind == inspect.Parameter.VAR_POSITIONAL for param in sig.parameters.values()",
            "        ):",
            "            argcount = len(sig.parameters)",
            "",
            "    if argcount is None:",
            "        argspec = getfullargspec(iteratee)",
            "        if argspec and not argspec.varargs:  # pragma: no cover",
            "            # Use inspected arg count.",
            "            argcount = len(argspec.args)",
            "",
            "    if argcount is None:",
            "        # Assume all args are handleable.",
            "        argcount = maxargs",
            "",
            "    return argcount",
            "",
            "",
            "def iteriteratee(obj, iteratee=None, reverse=False):",
            "    \"\"\"Return iterative iteratee based on collection type.\"\"\"",
            "    if iteratee is None:",
            "        cbk = pyd.identity",
            "        argcount = 1",
            "    else:",
            "        cbk = pyd.iteratee(iteratee)",
            "        argcount = getargcount(cbk, maxargs=3)",
            "",
            "    items = iterator(obj)",
            "",
            "    if reverse:",
            "        items = reversed(tuple(items))",
            "",
            "    for key, item in items:",
            "        yield callit(cbk, item, key, obj, argcount=argcount), item, key, obj",
            "",
            "",
            "def iterator(obj):",
            "    \"\"\"Return iterative based on object type.\"\"\"",
            "    if isinstance(obj, Mapping):",
            "        return obj.items()",
            "    elif hasattr(obj, \"iteritems\"):",
            "        return obj.iteritems()  # noqa: B301",
            "    elif hasattr(obj, \"items\"):",
            "        return iter(obj.items())",
            "    elif isinstance(obj, Iterable):",
            "        return enumerate(obj)",
            "    else:",
            "        return getattr(obj, \"__dict__\", {}).items()",
            "",
            "",
            "def base_get(obj, key, default=UNSET):",
            "    \"\"\"",
            "    Safely get an item by `key` from a sequence or mapping object when `default` provided.",
            "",
            "    Args:",
            "        obj (list|dict): Sequence or mapping to retrieve item from.",
            "        key (mixed): Key or index identifying which item to retrieve.",
            "        default (mixed, optional): Default value to return if `key` not found in `obj`.",
            "",
            "    Returns:",
            "        mixed: `obj[key]`, `obj.key`, or `default`.",
            "",
            "    Raises:",
            "        KeyError: If `obj` is missing key, index, or attribute and no default value provided.",
            "    \"\"\"",
            "    if isinstance(obj, dict):",
            "        value = _base_get_dict(obj, key, default=default)",
            "    elif not isinstance(obj, (Mapping, Sequence)) or (",
            "        isinstance(obj, tuple) and hasattr(obj, \"_fields\")",
            "    ):",
            "        # Don't use getattr for dict/list objects since we don't want class methods/attributes",
            "        # returned for them but do allow getattr for namedtuple.",
            "        value = _base_get_object(obj, key, default=default)",
            "    else:",
            "        value = _base_get_item(obj, key, default=default)",
            "",
            "    if value is UNSET:",
            "        # Raise if there's no default provided.",
            "        raise KeyError(f'Object \"{repr(obj)}\" does not have key \"{key}\"')",
            "",
            "    return value",
            "",
            "",
            "def _base_get_dict(obj, key, default=UNSET):",
            "    value = obj.get(key, UNSET)",
            "    if value is UNSET:",
            "        value = default",
            "        if not isinstance(key, int):",
            "            # Try integer key fallback.",
            "            try:",
            "                value = obj.get(int(key), default)",
            "            except Exception:",
            "                pass",
            "    return value",
            "",
            "",
            "def _base_get_item(obj, key, default=UNSET):",
            "    try:",
            "        return obj[key]",
            "    except Exception:",
            "        pass",
            "",
            "    if not isinstance(key, int):",
            "        try:",
            "            return obj[int(key)]",
            "        except Exception:",
            "            pass",
            "",
            "    return default",
            "",
            "",
            "def _base_get_object(obj, key, default=UNSET):",
            "    value = _base_get_item(obj, key, default=UNSET)",
            "    if value is UNSET:",
            "        value = default",
            "        try:",
            "            value = getattr(obj, key)",
            "        except Exception:",
            "            pass",
            "    return value",
            "",
            "",
            "def base_set(obj, key, value, allow_override=True):",
            "    \"\"\"",
            "    Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available",
            "    index position, append to list; otherwise, pad the list of ``None`` and then append to the list.",
            "",
            "    Args:",
            "        obj (list|dict): Object to assign value to.",
            "        key (mixed): Key or index to assign to.",
            "        value (mixed): Value to assign.",
            "        allow_override (bool): Whether to allow overriding a previously set key.",
            "    \"\"\"",
            "    if isinstance(obj, dict):",
            "        if allow_override or key not in obj:",
            "            obj[key] = value",
            "    elif isinstance(obj, list):",
            "        key = int(key)",
            "",
            "        if key < len(obj):",
            "            if allow_override:",
            "                obj[key] = value",
            "        else:",
            "            if key > len(obj):",
            "                # Pad list object with None values up to the index key so we can append the value",
            "                # into the key index.",
            "                obj[:] = (obj + [None] * key)[:key]",
            "            obj.append(value)",
            "    elif (allow_override or not hasattr(obj, key)) and obj is not None:",
            "        setattr(obj, key, value)",
            "",
            "    return obj",
            "",
            "",
            "def cmp(a, b):  # pragma: no cover",
            "    \"\"\"",
            "    Replacement for built-in function ``cmp`` that was removed in Python 3.",
            "",
            "    Note: Mainly used for comparison during sorting.",
            "    \"\"\"",
            "    if a is None and b is None:",
            "        return 0",
            "    elif a is None:",
            "        return -1",
            "    elif b is None:",
            "        return 1",
            "    return (a > b) - (a < b)",
            "",
            "",
            "def parse_iteratee(iteratee_keyword, *args, **kwargs):",
            "    \"\"\"Try to find iteratee function passed in either as a keyword argument or as the last",
            "    positional argument in `args`.\"\"\"",
            "    iteratee = kwargs.get(iteratee_keyword)",
            "    last_arg = args[-1]",
            "",
            "    if iteratee is None and (",
            "        callable(last_arg)",
            "        or isinstance(last_arg, str)",
            "        or isinstance(last_arg, dict)",
            "        or last_arg is None",
            "    ):",
            "        iteratee = last_arg",
            "        args = args[:-1]",
            "",
            "    return iteratee, args",
            "",
            "",
            "class iterator_with_default(object):",
            "    \"\"\"A wrapper around an iterator object that provides a default.\"\"\"",
            "",
            "    def __init__(self, collection, default):",
            "        self.iter = iter(collection)",
            "        self.default = default",
            "",
            "    def __iter__(self):",
            "        return self",
            "",
            "    def next_default(self):",
            "        ret = self.default",
            "        self.default = UNSET",
            "        return ret",
            "",
            "    def __next__(self):",
            "        ret = next(self.iter, self.next_default())",
            "        if ret is UNSET:",
            "            raise StopIteration",
            "        return ret",
            "",
            "    next = __next__",
            "",
            "",
            "def deprecated(func):  # pragma: no cover",
            "    \"\"\"",
            "    This is a decorator which can be used to mark functions as deprecated.",
            "",
            "    It will result in a warning being emitted when the function is used.",
            "    \"\"\"",
            "",
            "    @wraps(func)",
            "    def wrapper(*args, **kwargs):",
            "        warnings.warn(",
            "            f\"Call to deprecated function {func.__name__}.\",",
            "            category=DeprecationWarning,",
            "            stacklevel=3,",
            "        )",
            "        return func(*args, **kwargs)",
            "",
            "    return wrapper"
        ],
        "afterPatchFile": [
            "\"\"\"Generic utility methods not part of main API.\"\"\"",
            "",
            "import builtins",
            "from collections.abc import Hashable, Iterable, Mapping, Sequence",
            "from decimal import Decimal",
            "from functools import wraps",
            "import inspect",
            "from inspect import getfullargspec",
            "import warnings",
            "",
            "import pydash as pyd",
            "",
            "",
            "#: Singleton object that differentiates between an explicit ``None`` value and an unset value.",
            "UNSET = object()",
            "",
            "#: Tuple of number types.",
            "NUMBER_TYPES = (int, float, Decimal)",
            "",
            "#: Dictionary of builtins with keys as the builtin function and values as the string name.",
            "BUILTINS = {value: key for key, value in builtins.__dict__.items() if isinstance(value, Hashable)}",
            "",
            "",
            "def callit(iteratee, *args, **kwargs):",
            "    \"\"\"Inspect argspec of `iteratee` function and only pass the supported arguments when calling",
            "    it.\"\"\"",
            "    maxargs = len(args)",
            "    argcount = kwargs[\"argcount\"] if \"argcount\" in kwargs else getargcount(iteratee, maxargs)",
            "    argstop = min([maxargs, argcount])",
            "",
            "    return iteratee(*args[:argstop])",
            "",
            "",
            "def getargcount(iteratee, maxargs):",
            "    \"\"\"Return argument count of iteratee function.\"\"\"",
            "    if hasattr(iteratee, \"_argcount\"):",
            "        # Optimization feature where argcount of iteratee is known and properly",
            "        # set by initiator.",
            "        return iteratee._argcount",
            "",
            "    if isinstance(iteratee, type) or pyd.is_builtin(iteratee):",
            "        # Only pass single argument to type iteratees or builtins.",
            "        argcount = 1",
            "    else:",
            "        argcount = 1",
            "",
            "        try:",
            "            argcount = _getargcount(iteratee, maxargs)",
            "        except TypeError:  # pragma: no cover",
            "            pass",
            "",
            "    return argcount",
            "",
            "",
            "def _getargcount(iteratee, maxargs):",
            "    argcount = None",
            "",
            "    try:",
            "        # PY2: inspect.signature was added in Python 3.",
            "        # Try to use inspect.signature when possible since it works better for our purpose of",
            "        # getting the iteratee argcount since it takes into account the \"self\" argument in callable",
            "        # classes.",
            "        sig = inspect.signature(iteratee)",
            "    except (TypeError, ValueError, AttributeError):",
            "        pass",
            "    else:  # pragma: no cover",
            "        if not any(",
            "            param.kind == inspect.Parameter.VAR_POSITIONAL for param in sig.parameters.values()",
            "        ):",
            "            argcount = len(sig.parameters)",
            "",
            "    if argcount is None:",
            "        argspec = getfullargspec(iteratee)",
            "        if argspec and not argspec.varargs:  # pragma: no cover",
            "            # Use inspected arg count.",
            "            argcount = len(argspec.args)",
            "",
            "    if argcount is None:",
            "        # Assume all args are handleable.",
            "        argcount = maxargs",
            "",
            "    return argcount",
            "",
            "",
            "def iteriteratee(obj, iteratee=None, reverse=False):",
            "    \"\"\"Return iterative iteratee based on collection type.\"\"\"",
            "    if iteratee is None:",
            "        cbk = pyd.identity",
            "        argcount = 1",
            "    else:",
            "        cbk = pyd.iteratee(iteratee)",
            "        argcount = getargcount(cbk, maxargs=3)",
            "",
            "    items = iterator(obj)",
            "",
            "    if reverse:",
            "        items = reversed(tuple(items))",
            "",
            "    for key, item in items:",
            "        yield callit(cbk, item, key, obj, argcount=argcount), item, key, obj",
            "",
            "",
            "def iterator(obj):",
            "    \"\"\"Return iterative based on object type.\"\"\"",
            "    if isinstance(obj, Mapping):",
            "        return obj.items()",
            "    elif hasattr(obj, \"iteritems\"):",
            "        return obj.iteritems()  # noqa: B301",
            "    elif hasattr(obj, \"items\"):",
            "        return iter(obj.items())",
            "    elif isinstance(obj, Iterable):",
            "        return enumerate(obj)",
            "    else:",
            "        return getattr(obj, \"__dict__\", {}).items()",
            "",
            "",
            "def base_get(obj, key, default=UNSET):",
            "    \"\"\"",
            "    Safely get an item by `key` from a sequence or mapping object when `default` provided.",
            "",
            "    Args:",
            "        obj (list|dict): Sequence or mapping to retrieve item from.",
            "        key (mixed): Key or index identifying which item to retrieve.",
            "        default (mixed, optional): Default value to return if `key` not found in `obj`.",
            "",
            "    Returns:",
            "        mixed: `obj[key]`, `obj.key`, or `default`.",
            "",
            "    Raises:",
            "        KeyError: If `obj` is missing key, index, or attribute and no default value provided.",
            "    \"\"\"",
            "    if isinstance(obj, dict):",
            "        value = _base_get_dict(obj, key, default=default)",
            "    elif not isinstance(obj, (Mapping, Sequence)) or (",
            "        isinstance(obj, tuple) and hasattr(obj, \"_fields\")",
            "    ):",
            "        # Don't use getattr for dict/list objects since we don't want class methods/attributes",
            "        # returned for them but do allow getattr for namedtuple.",
            "        value = _base_get_object(obj, key, default=default)",
            "    else:",
            "        value = _base_get_item(obj, key, default=default)",
            "",
            "    if value is UNSET:",
            "        # Raise if there's no default provided.",
            "        raise KeyError(f'Object \"{repr(obj)}\" does not have key \"{key}\"')",
            "",
            "    return value",
            "",
            "",
            "def _base_get_dict(obj, key, default=UNSET):",
            "    value = obj.get(key, UNSET)",
            "    if value is UNSET:",
            "        value = default",
            "        if not isinstance(key, int):",
            "            # Try integer key fallback.",
            "            try:",
            "                value = obj.get(int(key), default)",
            "            except Exception:",
            "                pass",
            "    return value",
            "",
            "",
            "def _base_get_item(obj, key, default=UNSET):",
            "    try:",
            "        return obj[key]",
            "    except Exception:",
            "        pass",
            "",
            "    if not isinstance(key, int):",
            "        try:",
            "            return obj[int(key)]",
            "        except Exception:",
            "            pass",
            "",
            "    return default",
            "",
            "",
            "def _base_get_object(obj, key, default=UNSET):",
            "    value = _base_get_item(obj, key, default=UNSET)",
            "    if value is UNSET:",
            "        _raise_if_restricted_key(key)",
            "        value = default",
            "        try:",
            "            value = getattr(obj, key)",
            "        except Exception:",
            "            pass",
            "    return value",
            "",
            "",
            "def _raise_if_restricted_key(key):",
            "    # Prevent access to dunder-methods since this could expose access to globals through leaky",
            "    # attributes such as obj.__init__.__globals__.",
            "    if len(key) > 4 and key.isascii() and key.startswith(\"__\") and key.endswith(\"__\"):",
            "        raise KeyError(f\"access to restricted key {key!r} is not allowed\")",
            "",
            "",
            "def base_set(obj, key, value, allow_override=True):",
            "    \"\"\"",
            "    Set an object's `key` to `value`. If `obj` is a ``list`` and the `key` is the next available",
            "    index position, append to list; otherwise, pad the list of ``None`` and then append to the list.",
            "",
            "    Args:",
            "        obj (list|dict): Object to assign value to.",
            "        key (mixed): Key or index to assign to.",
            "        value (mixed): Value to assign.",
            "        allow_override (bool): Whether to allow overriding a previously set key.",
            "    \"\"\"",
            "    if isinstance(obj, dict):",
            "        if allow_override or key not in obj:",
            "            obj[key] = value",
            "    elif isinstance(obj, list):",
            "        key = int(key)",
            "",
            "        if key < len(obj):",
            "            if allow_override:",
            "                obj[key] = value",
            "        else:",
            "            if key > len(obj):",
            "                # Pad list object with None values up to the index key so we can append the value",
            "                # into the key index.",
            "                obj[:] = (obj + [None] * key)[:key]",
            "            obj.append(value)",
            "    elif (allow_override or not hasattr(obj, key)) and obj is not None:",
            "        _raise_if_restricted_key(key)",
            "        setattr(obj, key, value)",
            "",
            "    return obj",
            "",
            "",
            "def cmp(a, b):  # pragma: no cover",
            "    \"\"\"",
            "    Replacement for built-in function ``cmp`` that was removed in Python 3.",
            "",
            "    Note: Mainly used for comparison during sorting.",
            "    \"\"\"",
            "    if a is None and b is None:",
            "        return 0",
            "    elif a is None:",
            "        return -1",
            "    elif b is None:",
            "        return 1",
            "    return (a > b) - (a < b)",
            "",
            "",
            "def parse_iteratee(iteratee_keyword, *args, **kwargs):",
            "    \"\"\"Try to find iteratee function passed in either as a keyword argument or as the last",
            "    positional argument in `args`.\"\"\"",
            "    iteratee = kwargs.get(iteratee_keyword)",
            "    last_arg = args[-1]",
            "",
            "    if iteratee is None and (",
            "        callable(last_arg)",
            "        or isinstance(last_arg, str)",
            "        or isinstance(last_arg, dict)",
            "        or last_arg is None",
            "    ):",
            "        iteratee = last_arg",
            "        args = args[:-1]",
            "",
            "    return iteratee, args",
            "",
            "",
            "class iterator_with_default(object):",
            "    \"\"\"A wrapper around an iterator object that provides a default.\"\"\"",
            "",
            "    def __init__(self, collection, default):",
            "        self.iter = iter(collection)",
            "        self.default = default",
            "",
            "    def __iter__(self):",
            "        return self",
            "",
            "    def next_default(self):",
            "        ret = self.default",
            "        self.default = UNSET",
            "        return ret",
            "",
            "    def __next__(self):",
            "        ret = next(self.iter, self.next_default())",
            "        if ret is UNSET:",
            "            raise StopIteration",
            "        return ret",
            "",
            "    next = __next__",
            "",
            "",
            "def deprecated(func):  # pragma: no cover",
            "    \"\"\"",
            "    This is a decorator which can be used to mark functions as deprecated.",
            "",
            "    It will result in a warning being emitted when the function is used.",
            "    \"\"\"",
            "",
            "    @wraps(func)",
            "    def wrapper(*args, **kwargs):",
            "        warnings.warn(",
            "            f\"Call to deprecated function {func.__name__}.\",",
            "            category=DeprecationWarning,",
            "            stacklevel=3,",
            "        )",
            "        return func(*args, **kwargs)",
            "",
            "    return wrapper"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.pydash.helpers.base_get",
            "src.pydash.helpers._base_get_object",
            "src.pydash.helpers.base_set",
            "django.contrib.admin.options.ModelAdmin"
        ]
    }
}