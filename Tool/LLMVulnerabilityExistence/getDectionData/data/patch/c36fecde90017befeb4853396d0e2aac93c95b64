{
    "libnmap/process.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import os"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import platform"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import shlex"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+import string"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import subprocess"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import warnings"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from threading import Thread"
            },
            "7": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "                 \"Supplied target list should be either a string or a list\""
            },
            "8": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "             )"
            },
            "9": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        for target in self.__nmap_targets:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            self.__validate_target(target)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         self._nmap_options = set(options.split())"
            },
            "14": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         if safe_mode and not self._nmap_options.isdisjoint(unsafe_opts):"
            },
            "15": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             raise Exception("
            },
            "16": {
                "beforePatchRowNumber": 480,
                "afterPatchRowNumber": 484,
                "PatchRowcode": "             cmdline += self.__nmap_targets  # already a list"
            },
            "17": {
                "beforePatchRowNumber": 481,
                "afterPatchRowNumber": 485,
                "PatchRowcode": "         return cmdline"
            },
            "18": {
                "beforePatchRowNumber": 482,
                "afterPatchRowNumber": 486,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+    @staticmethod"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+    def __validate_target(target):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+        # See https://nmap.org/book/man-target-specification.html for all the"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+        # ways targets can be specified"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        allowed_characters = frozenset("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+            string.ascii_letters + string.digits + \"-.:/% \""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+        )"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+        if not set(target).issubset(allowed_characters):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+            raise Exception("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 496,
                "PatchRowcode": "+                \"Target '{}' contains invalid characters\".format(target)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 497,
                "PatchRowcode": "+            )"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+        # FQDN can contain dashes anywhere except at the beginning or end"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+        # This check also fixes/prevents CVE-2022-30284, which depends on being"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+        # able to pass options such as --script as a target"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+        elif target.startswith(\"-\") or target.endswith(\"-\"):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 502,
                "PatchRowcode": "+            raise Exception("
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+                \"Target '{}' cannot begin or end with a dash ('-')\".format("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+                    target"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 505,
                "PatchRowcode": "+                )"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+            )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": 483,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "     @property"
            },
            "41": {
                "beforePatchRowNumber": 484,
                "afterPatchRowNumber": 509,
                "PatchRowcode": "     def command(self):"
            },
            "42": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "import os",
            "import platform",
            "import shlex",
            "import subprocess",
            "import warnings",
            "from threading import Thread",
            "from xml.dom import pulldom",
            "",
            "try:",
            "    import pwd",
            "except ImportError:",
            "    pass",
            "",
            "",
            "__all__ = [\"NmapProcess\"]",
            "",
            "",
            "class NmapTask(object):",
            "",
            "    \"\"\"",
            "    NmapTask is a internal class used by process. Each time nmap",
            "    starts a new task during the scan, a new class will be instantiated.",
            "    Classes examples are: \"Ping Scan\", \"NSE script\", \"DNS Resolve\",..",
            "    To each class an estimated time to complete is assigned and updated",
            "    at least every second within the NmapProcess.",
            "    A property NmapProcess.current_task points to the running task at",
            "    time T and a dictionnary NmapProcess.tasks with \"task name\" as key",
            "    is built during scan execution",
            "    \"\"\"",
            "",
            "    def __init__(self, name, starttime=0, extrainfo=\"\"):",
            "        self.name = name",
            "        self.etc = 0",
            "        self.progress = 0",
            "        self.percent = 0",
            "        self.remaining = 0",
            "        self.status = \"started\"",
            "        self.starttime = starttime",
            "        self.endtime = 0",
            "        self.extrainfo = extrainfo",
            "        self.updated = 0",
            "",
            "",
            "class NmapProcess(Thread):",
            "",
            "    \"\"\"",
            "    NmapProcess is a class which wraps around the nmap executable.",
            "",
            "    Consequently, in order to run an NmapProcess, nmap should be installed",
            "    on the host running the script. By default NmapProcess will produce",
            "    the output of the nmap scan in the nmap XML format. This could be then",
            "    parsed out via the NmapParser class from libnmap.parser module.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        targets=\"127.0.0.1\",",
            "        options=\"-sT\",",
            "        event_callback=None,",
            "        safe_mode=True,",
            "        fqp=None,",
            "    ):",
            "        \"\"\"",
            "        Constructor of NmapProcess class.",
            "",
            "        :param targets: hosts to be scanned. Could be a string of hosts \\",
            "        separated with a coma or a python list of hosts/ip.",
            "        :type targets: string or list",
            "",
            "        :param options: list of nmap options to be applied to scan. \\",
            "        These options are all documented in nmap's man pages.",
            "",
            "        :param event_callback: callable function which will be ran \\",
            "        each time nmap process outputs data. This function will receive \\",
            "        two parameters:",
            "",
            "            1. the nmap process object",
            "            2. the data produced by nmap process. See readme for examples.",
            "",
            "        :param safe_mode: parameter to protect unsafe options like -oN, -oG, \\",
            "        -iL, -oA,...",
            "",
            "        :param fqp: full qualified path, if None, nmap will be searched \\",
            "        in the PATH",
            "",
            "        :return: NmapProcess object",
            "",
            "        \"\"\"",
            "        Thread.__init__(self)",
            "        unsafe_opts = set(",
            "            [",
            "                \"-oG\",",
            "                \"-oN\",",
            "                \"-iL\",",
            "                \"-oA\",",
            "                \"-oS\",",
            "                \"-oX\",",
            "                \"--iflist\",",
            "                \"--resume\",",
            "                \"--stylesheet\",",
            "                \"--datadir\",",
            "            ]",
            "        )",
            "        # more reliable than just using os.name() (cygwin)",
            "        self.__is_windows = platform.system() == \"Windows\"",
            "        if fqp:",
            "            if os.path.isfile(fqp) and os.access(fqp, os.X_OK):",
            "                self.__nmap_binary = fqp",
            "            else:",
            "                raise EnvironmentError(1, \"wrong path or not executable\", fqp)",
            "        else:",
            "            nmap_binary_name = \"nmap\"",
            "            self.__nmap_binary = self._whereis(nmap_binary_name)",
            "        self.__nmap_fixed_options = \"-oX - -vvv --stats-every 1s\"",
            "",
            "        if self.__nmap_binary is None:",
            "            em = \"nmap is not installed or could not be found in system path\"",
            "            raise EnvironmentError(1, em)",
            "",
            "        if isinstance(targets, str):",
            "            self.__nmap_targets = targets.replace(\" \", \"\").split(\",\")",
            "        elif isinstance(targets, list):",
            "            self.__nmap_targets = targets",
            "        else:",
            "            raise Exception(",
            "                \"Supplied target list should be either a string or a list\"",
            "            )",
            "",
            "        self._nmap_options = set(options.split())",
            "        if safe_mode and not self._nmap_options.isdisjoint(unsafe_opts):",
            "            raise Exception(",
            "                \"unsafe options activated while safe_mode is set True\"",
            "            )",
            "        self.__nmap_dynamic_options = options",
            "        self.__sudo_run = \"\"",
            "        self.__nmap_command_line = self.get_command_line()",
            "",
            "        if event_callback and callable(event_callback):",
            "            self.__nmap_event_callback = event_callback",
            "        else:",
            "            self.__nmap_event_callback = None",
            "        (",
            "            self.DONE,",
            "            self.READY,",
            "            self.RUNNING,",
            "            self.CANCELLED,",
            "            self.FAILED,",
            "        ) = range(5)",
            "        self._run_init()",
            "",
            "    def _run_init(self):",
            "        self.__nmap_command_line = self.get_command_line()",
            "        # API usable in callback function",
            "        self.__nmap_proc = None",
            "        self.__nmap_rc = 0",
            "        self.__state = self.RUNNING",
            "        self.__starttime = 0",
            "        self.__endtime = 0",
            "        self.__version = \"\"",
            "        self.__elapsed = \"\"",
            "        self.__summary = \"\"",
            "        self.__stdout = \"\"",
            "        self.__stderr = \"\"",
            "        self.__current_task = \"\"",
            "        self.__nmap_tasks = {}",
            "",
            "    def _whereis(self, program):",
            "        \"\"\"",
            "        Protected method enabling the object to find the full path of a binary",
            "        from its PATH environment variable.",
            "",
            "        :param program: name of a binary for which the full path needs to",
            "        be discovered.",
            "",
            "        :return: the full path to the binary.",
            "",
            "        :todo: add a default path list in case PATH is empty.",
            "        \"\"\"",
            "        split_char = \";\" if self.__is_windows else \":\"",
            "        program = program + \".exe\" if self.__is_windows else program",
            "        for path in os.environ.get(\"PATH\", \"\").split(split_char):",
            "            _file_path = os.path.join(path, program)",
            "            if os.path.exists(_file_path) and not os.path.isdir(_file_path):",
            "                return os.path.join(path, program)",
            "        return None",
            "",
            "    def get_command_line(self):",
            "        \"\"\"",
            "        Public method returning the reconstructed command line ran via the lib",
            "",
            "        :return: the full nmap command line to run",
            "        :rtype: string",
            "        \"\"\"",
            "        return \"{0} {1} {2} {3} {4}\".format(",
            "            self.__sudo_run,",
            "            self.__nmap_binary,",
            "            self.__nmap_fixed_options,",
            "            self.__nmap_dynamic_options,",
            "            \" \".join(self.__nmap_targets),",
            "        )",
            "",
            "    def _ensure_user_exists(self, username=\"\"):",
            "        try:",
            "            pwd.getpwnam(username).pw_uid",
            "        except KeyError as eobj:",
            "            _exmsg = (",
            "                \"Username {0} does not exists. Please supply\"",
            "                \" a valid username: {1}\".format(username, eobj)",
            "            )",
            "            raise EnvironmentError(_exmsg)",
            "",
            "    def sudo_run(self, run_as=\"root\"):",
            "        \"\"\"",
            "        Public method enabling the library's user to run the scan with",
            "        privileges via sudo. The sudo configuration should be set manually",
            "        on the local system otherwise sudo will prompt for a password.",
            "        This method alters the command line by prefixing the sudo command to",
            "        nmap and will then call self.run()",
            "",
            "        :param run_as: user name to which the lib needs to sudo to run the scan",
            "",
            "        :return: return code from nmap execution",
            "        \"\"\"",
            "        sudo_user = run_as.split().pop()",
            "        self._ensure_user_exists(sudo_user)",
            "",
            "        sudo_path = self._whereis(\"sudo\")",
            "        if sudo_path is None:",
            "            raise EnvironmentError(",
            "                2,",
            "                \"sudo is not installed or \"",
            "                \"could not be found in system path: \"",
            "                \"cannot run nmap with sudo\",",
            "            )",
            "",
            "        self.__sudo_run = \"{0} -u {1}\".format(sudo_path, sudo_user)",
            "        rc = self.run()",
            "        self.__sudo_run = \"\"",
            "",
            "        return rc",
            "",
            "    def sudo_run_background(self, run_as=\"root\"):",
            "        \"\"\"",
            "        Public method enabling the library's user to run in background a",
            "        nmap scan with privileges via sudo.",
            "        The sudo configuration should be set manually on the local system",
            "        otherwise sudo will prompt for a password.",
            "        This method alters the command line by prefixing the sudo command to",
            "        nmap and will then call self.run()",
            "",
            "        :param run_as: user name to which the lib needs to sudo to run the scan",
            "",
            "        :return: return code from nmap execution",
            "        \"\"\"",
            "        sudo_user = run_as.split().pop()",
            "        self._ensure_user_exists(sudo_user)",
            "",
            "        sudo_path = self._whereis(\"sudo\")",
            "        if sudo_path is None:",
            "            raise EnvironmentError(",
            "                2,",
            "                \"sudo is not installed or \"",
            "                \"could not be found in system path: \"",
            "                \"cannot run nmap with sudo\",",
            "            )",
            "",
            "        self.__sudo_run = \"{0} -u {1}\".format(sudo_path, sudo_user)",
            "        super(NmapProcess, self).start()",
            "",
            "    def run(self):",
            "        \"\"\"",
            "        Public method which is usually called right after the constructor",
            "        of NmapProcess. This method starts the nmap executable's subprocess.",
            "        It will also bind a Process that will read from subprocess' stdout",
            "        and stderr and push the lines read in a python queue for futher",
            "        processing. This processing is waken-up each time data is pushed",
            "        from the nmap binary into the stdout reading routine. Processing",
            "        could be performed by a user-provided callback. The whole",
            "        NmapProcess object could be accessible asynchroneously.",
            "",
            "        return: return code from nmap execution",
            "        \"\"\"",
            "        self._run_init()",
            "        _tmp_cmdline = (",
            "            self.__build_windows_cmdline()",
            "            if self.__is_windows",
            "            else shlex.split(self.__nmap_command_line)",
            "        )",
            "        try:",
            "            self.__nmap_proc = subprocess.Popen(",
            "                args=_tmp_cmdline,",
            "                stdout=subprocess.PIPE,",
            "                stderr=subprocess.PIPE,",
            "                universal_newlines=True,",
            "                bufsize=0,",
            "            )",
            "            self.__state = self.RUNNING",
            "        except OSError as emsg:",
            "            self.__state = self.FAILED",
            "            raise EnvironmentError(",
            "                1,",
            "                \"nmap is not installed or could \"",
            "                \"not be found in system path: {0}\".format(emsg),",
            "            )",
            "",
            "        while self.__nmap_proc.poll() is None:",
            "            self.__process_nmap_proc_stdout()",
            "        self.__process_nmap_proc_stdout()",
            "        self.__stderr += self.__nmap_proc.stderr.read()",
            "",
            "        self.__nmap_rc = self.__nmap_proc.poll()",
            "        if self.rc is None:",
            "            self.__state = self.CANCELLED",
            "        elif self.rc == 0:",
            "            self.__state = self.DONE",
            "            if self.current_task:",
            "                self.__nmap_tasks[self.current_task.name].progress = 100",
            "        else:",
            "            self.__state = self.FAILED",
            "        # Call the callback one last time to signal the new state",
            "        if self.__nmap_event_callback:",
            "            self.__nmap_event_callback(self)",
            "        return self.rc",
            "",
            "    def run_background(self):",
            "        \"\"\"",
            "        run nmap scan in background as a thread.",
            "        For privileged scans, consider NmapProcess.sudo_run_background()",
            "        \"\"\"",
            "        self.__state = self.RUNNING",
            "        super(NmapProcess, self).start()",
            "",
            "    def is_running(self):",
            "        \"\"\"",
            "        Checks if nmap is still running.",
            "",
            "        :return: True if nmap is still running",
            "        \"\"\"",
            "        return self.state == self.RUNNING",
            "",
            "    def has_terminated(self):",
            "        \"\"\"",
            "        Checks if nmap has terminated. Could have failed or succeeded",
            "",
            "        :return: True if nmap process is not running anymore.",
            "        \"\"\"",
            "        return (",
            "            self.state == self.DONE",
            "            or self.state == self.FAILED",
            "            or self.state == self.CANCELLED",
            "        )",
            "",
            "    def has_failed(self):",
            "        \"\"\"",
            "        Checks if nmap has failed.",
            "",
            "        :return: True if nmap process errored.",
            "        \"\"\"",
            "        return self.state == self.FAILED",
            "",
            "    def is_successful(self):",
            "        \"\"\"",
            "        Checks if nmap terminated successfully.",
            "",
            "        :return: True if nmap terminated successfully.",
            "        \"\"\"",
            "        return self.state == self.DONE",
            "",
            "    def stop(self):",
            "        \"\"\"",
            "        Send KILL -15 to the nmap subprocess and gently ask the threads to",
            "        stop.",
            "        \"\"\"",
            "        self.__state = self.CANCELLED",
            "        if self.__nmap_proc.poll() is None:",
            "            self.__nmap_proc.kill()",
            "",
            "    def __process_nmap_proc_stdout(self):",
            "        for streamline in iter(self.__nmap_proc.stdout.readline, \"\"):",
            "            self.__stdout += streamline",
            "            evnt = self.__process_event(streamline)",
            "            if self.__nmap_event_callback and evnt:",
            "                self.__nmap_event_callback(self)",
            "",
            "    def __process_event(self, eventdata):",
            "        \"\"\"",
            "        Private method called while nmap process is running. It enables the",
            "        library to handle specific data/events produced by nmap process.",
            "        So far, the following events are supported:",
            "",
            "        1. task progress: updates estimated time to completion and percentage",
            "           done while scan is running. Could be used in combination with a",
            "           callback function which could then handle this data while scan is",
            "           running.",
            "        2. nmap run: header of the scan. Usually displayed when nmap is started",
            "        3. finished: when nmap scan ends.",
            "",
            "        :return: True is event is known.",
            "",
            "        :todo: handle parsing directly via NmapParser.parse()",
            "        \"\"\"",
            "        rval = False",
            "        try:",
            "            edomdoc = pulldom.parseString(eventdata)",
            "            for xlmnt, xmlnode in edomdoc:",
            "                if xlmnt is not None and xlmnt == pulldom.START_ELEMENT:",
            "                    if (",
            "                        xmlnode.nodeName == \"taskbegin\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        xt = xmlnode.attributes",
            "                        taskname = xt[\"task\"].value",
            "                        starttime = xt[\"time\"].value",
            "                        xinfo = \"\"",
            "                        if \"extrainfo\" in xt.keys():",
            "                            xinfo = xt[\"extrainfo\"].value",
            "                        newtask = NmapTask(taskname, starttime, xinfo)",
            "                        self.__nmap_tasks[newtask.name] = newtask",
            "                        self.__current_task = newtask.name",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"taskend\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        xt = xmlnode.attributes",
            "                        tname = xt[\"task\"].value",
            "                        xinfo = \"\"",
            "                        self.__nmap_tasks[tname].endtime = xt[\"time\"].value",
            "                        if \"extrainfo\" in xt.keys():",
            "                            xinfo = xt[\"extrainfo\"].value",
            "                        self.__nmap_tasks[tname].extrainfo = xinfo",
            "                        self.__nmap_tasks[tname].status = \"ended\"",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"taskprogress\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        xt = xmlnode.attributes",
            "                        tname = xt[\"task\"].value",
            "                        percent = xt[\"percent\"].value",
            "                        etc = xt[\"etc\"].value",
            "                        remaining = xt[\"remaining\"].value",
            "                        updated = xt[\"time\"].value",
            "                        self.__nmap_tasks[tname].percent = percent",
            "                        self.__nmap_tasks[tname].progress = percent",
            "                        self.__nmap_tasks[tname].etc = etc",
            "                        self.__nmap_tasks[tname].remaining = remaining",
            "                        self.__nmap_tasks[tname].updated = updated",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"nmaprun\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        self.__starttime = xmlnode.attributes[\"start\"].value",
            "                        self.__version = xmlnode.attributes[\"version\"].value",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"finished\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        self.__endtime = xmlnode.attributes[\"time\"].value",
            "                        self.__elapsed = xmlnode.attributes[\"elapsed\"].value",
            "                        self.__summary = xmlnode.attributes[\"summary\"].value",
            "                        rval = True",
            "        except Exception:",
            "            pass",
            "        return rval",
            "",
            "    def __build_windows_cmdline(self):",
            "        cmdline = []",
            "        cmdline.append(self.__nmap_binary)",
            "        if self.__nmap_fixed_options:",
            "            cmdline += self.__nmap_fixed_options.split()",
            "        if self.__nmap_dynamic_options:",
            "            cmdline += self.__nmap_dynamic_options.split()",
            "        if self.__nmap_targets:",
            "            cmdline += self.__nmap_targets  # already a list",
            "        return cmdline",
            "",
            "    @property",
            "    def command(self):",
            "        \"\"\"",
            "        return the constructed nmap command or empty string if not",
            "        constructed yet.",
            "",
            "        :return: string",
            "        \"\"\"",
            "        return self.__nmap_command_line or \"\"",
            "",
            "    @property",
            "    def targets(self):",
            "        \"\"\"",
            "        Provides the list of targets to scan",
            "",
            "        :return: list of string",
            "        \"\"\"",
            "        return self.__nmap_targets",
            "",
            "    @property",
            "    def options(self):",
            "        \"\"\"",
            "        Provides the list of options for that scan",
            "",
            "        :return: list of string (nmap options)",
            "        \"\"\"",
            "        return self._nmap_options",
            "",
            "    @property",
            "    def state(self):",
            "        \"\"\"",
            "        Accessor for nmap execution state. Possible states are:",
            "",
            "        - self.READY",
            "        - self.RUNNING",
            "        - self.FAILED",
            "        - self.CANCELLED",
            "        - self.DONE",
            "",
            "        :return: integer (from above documented enum)",
            "        \"\"\"",
            "        return self.__state",
            "",
            "    @property",
            "    def starttime(self):",
            "        \"\"\"",
            "        Accessor for time when scan started",
            "",
            "        :return: string. Unix timestamp",
            "        \"\"\"",
            "        return self.__starttime",
            "",
            "    @property",
            "    def endtime(self):",
            "        \"\"\"",
            "        Accessor for time when scan ended",
            "",
            "        :return: string. Unix timestamp",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"data collected from finished events are deprecated.\"",
            "            \"Use NmapParser.parse()\",",
            "            DeprecationWarning,",
            "        )",
            "        return self.__endtime",
            "",
            "    @property",
            "    def elapsed(self):",
            "        \"\"\"",
            "        Accessor returning for how long the scan ran (in seconds)",
            "",
            "        :return: string",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"data collected from finished events are deprecated.\"",
            "            \"Use NmapParser.parse()\",",
            "            DeprecationWarning,",
            "        )",
            "        return self.__elapsed",
            "",
            "    @property",
            "    def summary(self):",
            "        \"\"\"",
            "        Accessor returning a short summary of the scan's results",
            "",
            "        :return: string",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"data collected from finished events are deprecated.\"",
            "            \"Use NmapParser.parse()\",",
            "            DeprecationWarning,",
            "        )",
            "        return self.__summary",
            "",
            "    @property",
            "    def tasks(self):",
            "        \"\"\"",
            "        Accessor returning for the list of tasks ran during nmap scan",
            "",
            "        :return: dict of NmapTask object",
            "        \"\"\"",
            "        return self.__nmap_tasks",
            "",
            "    @property",
            "    def version(self):",
            "        \"\"\"",
            "        Accessor for nmap binary version number",
            "",
            "        :return: version number of nmap binary",
            "        :rtype: string",
            "        \"\"\"",
            "        return self.__version",
            "",
            "    @property",
            "    def current_task(self):",
            "        \"\"\"",
            "        Accessor for the current NmapTask beeing run",
            "",
            "        :return: NmapTask or None if no task started yet",
            "        \"\"\"",
            "        rval = None",
            "        if len(self.__current_task):",
            "            rval = self.tasks[self.__current_task]",
            "        return rval",
            "",
            "    @property",
            "    def etc(self):",
            "        \"\"\"",
            "        Accessor for estimated time to completion",
            "",
            "        :return:  estimated time to completion",
            "        \"\"\"",
            "        rval = 0",
            "        if self.current_task:",
            "            rval = self.current_task.etc",
            "        return rval",
            "",
            "    @property",
            "    def progress(self):",
            "        \"\"\"",
            "        Accessor for progress status in percentage",
            "",
            "        :return: percentage of job processed.",
            "        \"\"\"",
            "        rval = 0",
            "        if self.current_task:",
            "            rval = self.current_task.progress",
            "        return rval",
            "",
            "    @property",
            "    def rc(self):",
            "        \"\"\"",
            "        Accessor for nmap execution's return code",
            "",
            "        :return: nmap execution's return code",
            "        \"\"\"",
            "        return self.__nmap_rc",
            "",
            "    @property",
            "    def stdout(self):",
            "        \"\"\"",
            "        Accessor for nmap standart output",
            "",
            "        :return: output from nmap scan in XML",
            "        :rtype: string",
            "        \"\"\"",
            "        return self.__stdout",
            "",
            "    @property",
            "    def stderr(self):",
            "        \"\"\"",
            "        Accessor for nmap standart error",
            "",
            "        :return: output from nmap when errors occured.",
            "        :rtype: string",
            "        \"\"\"",
            "        return self.__stderr",
            "",
            "",
            "def main():",
            "    def mycallback(nmapscan=None):",
            "        if nmapscan.is_running() and nmapscan.current_task:",
            "            ntask = nmapscan.current_task",
            "            print(",
            "                \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format(",
            "                    ntask.name, ntask.status, ntask.etc, ntask.progress",
            "                )",
            "            )",
            "",
            "    nm = NmapProcess(",
            "        \"scanme.nmap.org\", options=\"-A\", event_callback=mycallback",
            "    )",
            "    rc = nm.run()",
            "    if rc == 0:",
            "        print(",
            "            \"Scan started at {0} nmap version: {1}\".format(",
            "                nm.starttime, nm.version",
            "            )",
            "        )",
            "        print(\"state: {0} (rc: {1})\".format(nm.state, nm.rc))",
            "        print(\"results size: {0}\".format(len(nm.stdout)))",
            "        print(\"Scan ended {0}: {1}\".format(nm.endtime, nm.summary))",
            "    else:",
            "        print(\"state: {0} (rc: {1})\".format(nm.state, nm.rc))",
            "        print(\"Error: {stderr}\".format(stderr=nm.stderr))",
            "        print(\"Result: {0}\".format(nm.stdout))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "import os",
            "import platform",
            "import shlex",
            "import string",
            "import subprocess",
            "import warnings",
            "from threading import Thread",
            "from xml.dom import pulldom",
            "",
            "try:",
            "    import pwd",
            "except ImportError:",
            "    pass",
            "",
            "",
            "__all__ = [\"NmapProcess\"]",
            "",
            "",
            "class NmapTask(object):",
            "",
            "    \"\"\"",
            "    NmapTask is a internal class used by process. Each time nmap",
            "    starts a new task during the scan, a new class will be instantiated.",
            "    Classes examples are: \"Ping Scan\", \"NSE script\", \"DNS Resolve\",..",
            "    To each class an estimated time to complete is assigned and updated",
            "    at least every second within the NmapProcess.",
            "    A property NmapProcess.current_task points to the running task at",
            "    time T and a dictionnary NmapProcess.tasks with \"task name\" as key",
            "    is built during scan execution",
            "    \"\"\"",
            "",
            "    def __init__(self, name, starttime=0, extrainfo=\"\"):",
            "        self.name = name",
            "        self.etc = 0",
            "        self.progress = 0",
            "        self.percent = 0",
            "        self.remaining = 0",
            "        self.status = \"started\"",
            "        self.starttime = starttime",
            "        self.endtime = 0",
            "        self.extrainfo = extrainfo",
            "        self.updated = 0",
            "",
            "",
            "class NmapProcess(Thread):",
            "",
            "    \"\"\"",
            "    NmapProcess is a class which wraps around the nmap executable.",
            "",
            "    Consequently, in order to run an NmapProcess, nmap should be installed",
            "    on the host running the script. By default NmapProcess will produce",
            "    the output of the nmap scan in the nmap XML format. This could be then",
            "    parsed out via the NmapParser class from libnmap.parser module.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        targets=\"127.0.0.1\",",
            "        options=\"-sT\",",
            "        event_callback=None,",
            "        safe_mode=True,",
            "        fqp=None,",
            "    ):",
            "        \"\"\"",
            "        Constructor of NmapProcess class.",
            "",
            "        :param targets: hosts to be scanned. Could be a string of hosts \\",
            "        separated with a coma or a python list of hosts/ip.",
            "        :type targets: string or list",
            "",
            "        :param options: list of nmap options to be applied to scan. \\",
            "        These options are all documented in nmap's man pages.",
            "",
            "        :param event_callback: callable function which will be ran \\",
            "        each time nmap process outputs data. This function will receive \\",
            "        two parameters:",
            "",
            "            1. the nmap process object",
            "            2. the data produced by nmap process. See readme for examples.",
            "",
            "        :param safe_mode: parameter to protect unsafe options like -oN, -oG, \\",
            "        -iL, -oA,...",
            "",
            "        :param fqp: full qualified path, if None, nmap will be searched \\",
            "        in the PATH",
            "",
            "        :return: NmapProcess object",
            "",
            "        \"\"\"",
            "        Thread.__init__(self)",
            "        unsafe_opts = set(",
            "            [",
            "                \"-oG\",",
            "                \"-oN\",",
            "                \"-iL\",",
            "                \"-oA\",",
            "                \"-oS\",",
            "                \"-oX\",",
            "                \"--iflist\",",
            "                \"--resume\",",
            "                \"--stylesheet\",",
            "                \"--datadir\",",
            "            ]",
            "        )",
            "        # more reliable than just using os.name() (cygwin)",
            "        self.__is_windows = platform.system() == \"Windows\"",
            "        if fqp:",
            "            if os.path.isfile(fqp) and os.access(fqp, os.X_OK):",
            "                self.__nmap_binary = fqp",
            "            else:",
            "                raise EnvironmentError(1, \"wrong path or not executable\", fqp)",
            "        else:",
            "            nmap_binary_name = \"nmap\"",
            "            self.__nmap_binary = self._whereis(nmap_binary_name)",
            "        self.__nmap_fixed_options = \"-oX - -vvv --stats-every 1s\"",
            "",
            "        if self.__nmap_binary is None:",
            "            em = \"nmap is not installed or could not be found in system path\"",
            "            raise EnvironmentError(1, em)",
            "",
            "        if isinstance(targets, str):",
            "            self.__nmap_targets = targets.replace(\" \", \"\").split(\",\")",
            "        elif isinstance(targets, list):",
            "            self.__nmap_targets = targets",
            "        else:",
            "            raise Exception(",
            "                \"Supplied target list should be either a string or a list\"",
            "            )",
            "",
            "        for target in self.__nmap_targets:",
            "            self.__validate_target(target)",
            "",
            "        self._nmap_options = set(options.split())",
            "        if safe_mode and not self._nmap_options.isdisjoint(unsafe_opts):",
            "            raise Exception(",
            "                \"unsafe options activated while safe_mode is set True\"",
            "            )",
            "        self.__nmap_dynamic_options = options",
            "        self.__sudo_run = \"\"",
            "        self.__nmap_command_line = self.get_command_line()",
            "",
            "        if event_callback and callable(event_callback):",
            "            self.__nmap_event_callback = event_callback",
            "        else:",
            "            self.__nmap_event_callback = None",
            "        (",
            "            self.DONE,",
            "            self.READY,",
            "            self.RUNNING,",
            "            self.CANCELLED,",
            "            self.FAILED,",
            "        ) = range(5)",
            "        self._run_init()",
            "",
            "    def _run_init(self):",
            "        self.__nmap_command_line = self.get_command_line()",
            "        # API usable in callback function",
            "        self.__nmap_proc = None",
            "        self.__nmap_rc = 0",
            "        self.__state = self.RUNNING",
            "        self.__starttime = 0",
            "        self.__endtime = 0",
            "        self.__version = \"\"",
            "        self.__elapsed = \"\"",
            "        self.__summary = \"\"",
            "        self.__stdout = \"\"",
            "        self.__stderr = \"\"",
            "        self.__current_task = \"\"",
            "        self.__nmap_tasks = {}",
            "",
            "    def _whereis(self, program):",
            "        \"\"\"",
            "        Protected method enabling the object to find the full path of a binary",
            "        from its PATH environment variable.",
            "",
            "        :param program: name of a binary for which the full path needs to",
            "        be discovered.",
            "",
            "        :return: the full path to the binary.",
            "",
            "        :todo: add a default path list in case PATH is empty.",
            "        \"\"\"",
            "        split_char = \";\" if self.__is_windows else \":\"",
            "        program = program + \".exe\" if self.__is_windows else program",
            "        for path in os.environ.get(\"PATH\", \"\").split(split_char):",
            "            _file_path = os.path.join(path, program)",
            "            if os.path.exists(_file_path) and not os.path.isdir(_file_path):",
            "                return os.path.join(path, program)",
            "        return None",
            "",
            "    def get_command_line(self):",
            "        \"\"\"",
            "        Public method returning the reconstructed command line ran via the lib",
            "",
            "        :return: the full nmap command line to run",
            "        :rtype: string",
            "        \"\"\"",
            "        return \"{0} {1} {2} {3} {4}\".format(",
            "            self.__sudo_run,",
            "            self.__nmap_binary,",
            "            self.__nmap_fixed_options,",
            "            self.__nmap_dynamic_options,",
            "            \" \".join(self.__nmap_targets),",
            "        )",
            "",
            "    def _ensure_user_exists(self, username=\"\"):",
            "        try:",
            "            pwd.getpwnam(username).pw_uid",
            "        except KeyError as eobj:",
            "            _exmsg = (",
            "                \"Username {0} does not exists. Please supply\"",
            "                \" a valid username: {1}\".format(username, eobj)",
            "            )",
            "            raise EnvironmentError(_exmsg)",
            "",
            "    def sudo_run(self, run_as=\"root\"):",
            "        \"\"\"",
            "        Public method enabling the library's user to run the scan with",
            "        privileges via sudo. The sudo configuration should be set manually",
            "        on the local system otherwise sudo will prompt for a password.",
            "        This method alters the command line by prefixing the sudo command to",
            "        nmap and will then call self.run()",
            "",
            "        :param run_as: user name to which the lib needs to sudo to run the scan",
            "",
            "        :return: return code from nmap execution",
            "        \"\"\"",
            "        sudo_user = run_as.split().pop()",
            "        self._ensure_user_exists(sudo_user)",
            "",
            "        sudo_path = self._whereis(\"sudo\")",
            "        if sudo_path is None:",
            "            raise EnvironmentError(",
            "                2,",
            "                \"sudo is not installed or \"",
            "                \"could not be found in system path: \"",
            "                \"cannot run nmap with sudo\",",
            "            )",
            "",
            "        self.__sudo_run = \"{0} -u {1}\".format(sudo_path, sudo_user)",
            "        rc = self.run()",
            "        self.__sudo_run = \"\"",
            "",
            "        return rc",
            "",
            "    def sudo_run_background(self, run_as=\"root\"):",
            "        \"\"\"",
            "        Public method enabling the library's user to run in background a",
            "        nmap scan with privileges via sudo.",
            "        The sudo configuration should be set manually on the local system",
            "        otherwise sudo will prompt for a password.",
            "        This method alters the command line by prefixing the sudo command to",
            "        nmap and will then call self.run()",
            "",
            "        :param run_as: user name to which the lib needs to sudo to run the scan",
            "",
            "        :return: return code from nmap execution",
            "        \"\"\"",
            "        sudo_user = run_as.split().pop()",
            "        self._ensure_user_exists(sudo_user)",
            "",
            "        sudo_path = self._whereis(\"sudo\")",
            "        if sudo_path is None:",
            "            raise EnvironmentError(",
            "                2,",
            "                \"sudo is not installed or \"",
            "                \"could not be found in system path: \"",
            "                \"cannot run nmap with sudo\",",
            "            )",
            "",
            "        self.__sudo_run = \"{0} -u {1}\".format(sudo_path, sudo_user)",
            "        super(NmapProcess, self).start()",
            "",
            "    def run(self):",
            "        \"\"\"",
            "        Public method which is usually called right after the constructor",
            "        of NmapProcess. This method starts the nmap executable's subprocess.",
            "        It will also bind a Process that will read from subprocess' stdout",
            "        and stderr and push the lines read in a python queue for futher",
            "        processing. This processing is waken-up each time data is pushed",
            "        from the nmap binary into the stdout reading routine. Processing",
            "        could be performed by a user-provided callback. The whole",
            "        NmapProcess object could be accessible asynchroneously.",
            "",
            "        return: return code from nmap execution",
            "        \"\"\"",
            "        self._run_init()",
            "        _tmp_cmdline = (",
            "            self.__build_windows_cmdline()",
            "            if self.__is_windows",
            "            else shlex.split(self.__nmap_command_line)",
            "        )",
            "        try:",
            "            self.__nmap_proc = subprocess.Popen(",
            "                args=_tmp_cmdline,",
            "                stdout=subprocess.PIPE,",
            "                stderr=subprocess.PIPE,",
            "                universal_newlines=True,",
            "                bufsize=0,",
            "            )",
            "            self.__state = self.RUNNING",
            "        except OSError as emsg:",
            "            self.__state = self.FAILED",
            "            raise EnvironmentError(",
            "                1,",
            "                \"nmap is not installed or could \"",
            "                \"not be found in system path: {0}\".format(emsg),",
            "            )",
            "",
            "        while self.__nmap_proc.poll() is None:",
            "            self.__process_nmap_proc_stdout()",
            "        self.__process_nmap_proc_stdout()",
            "        self.__stderr += self.__nmap_proc.stderr.read()",
            "",
            "        self.__nmap_rc = self.__nmap_proc.poll()",
            "        if self.rc is None:",
            "            self.__state = self.CANCELLED",
            "        elif self.rc == 0:",
            "            self.__state = self.DONE",
            "            if self.current_task:",
            "                self.__nmap_tasks[self.current_task.name].progress = 100",
            "        else:",
            "            self.__state = self.FAILED",
            "        # Call the callback one last time to signal the new state",
            "        if self.__nmap_event_callback:",
            "            self.__nmap_event_callback(self)",
            "        return self.rc",
            "",
            "    def run_background(self):",
            "        \"\"\"",
            "        run nmap scan in background as a thread.",
            "        For privileged scans, consider NmapProcess.sudo_run_background()",
            "        \"\"\"",
            "        self.__state = self.RUNNING",
            "        super(NmapProcess, self).start()",
            "",
            "    def is_running(self):",
            "        \"\"\"",
            "        Checks if nmap is still running.",
            "",
            "        :return: True if nmap is still running",
            "        \"\"\"",
            "        return self.state == self.RUNNING",
            "",
            "    def has_terminated(self):",
            "        \"\"\"",
            "        Checks if nmap has terminated. Could have failed or succeeded",
            "",
            "        :return: True if nmap process is not running anymore.",
            "        \"\"\"",
            "        return (",
            "            self.state == self.DONE",
            "            or self.state == self.FAILED",
            "            or self.state == self.CANCELLED",
            "        )",
            "",
            "    def has_failed(self):",
            "        \"\"\"",
            "        Checks if nmap has failed.",
            "",
            "        :return: True if nmap process errored.",
            "        \"\"\"",
            "        return self.state == self.FAILED",
            "",
            "    def is_successful(self):",
            "        \"\"\"",
            "        Checks if nmap terminated successfully.",
            "",
            "        :return: True if nmap terminated successfully.",
            "        \"\"\"",
            "        return self.state == self.DONE",
            "",
            "    def stop(self):",
            "        \"\"\"",
            "        Send KILL -15 to the nmap subprocess and gently ask the threads to",
            "        stop.",
            "        \"\"\"",
            "        self.__state = self.CANCELLED",
            "        if self.__nmap_proc.poll() is None:",
            "            self.__nmap_proc.kill()",
            "",
            "    def __process_nmap_proc_stdout(self):",
            "        for streamline in iter(self.__nmap_proc.stdout.readline, \"\"):",
            "            self.__stdout += streamline",
            "            evnt = self.__process_event(streamline)",
            "            if self.__nmap_event_callback and evnt:",
            "                self.__nmap_event_callback(self)",
            "",
            "    def __process_event(self, eventdata):",
            "        \"\"\"",
            "        Private method called while nmap process is running. It enables the",
            "        library to handle specific data/events produced by nmap process.",
            "        So far, the following events are supported:",
            "",
            "        1. task progress: updates estimated time to completion and percentage",
            "           done while scan is running. Could be used in combination with a",
            "           callback function which could then handle this data while scan is",
            "           running.",
            "        2. nmap run: header of the scan. Usually displayed when nmap is started",
            "        3. finished: when nmap scan ends.",
            "",
            "        :return: True is event is known.",
            "",
            "        :todo: handle parsing directly via NmapParser.parse()",
            "        \"\"\"",
            "        rval = False",
            "        try:",
            "            edomdoc = pulldom.parseString(eventdata)",
            "            for xlmnt, xmlnode in edomdoc:",
            "                if xlmnt is not None and xlmnt == pulldom.START_ELEMENT:",
            "                    if (",
            "                        xmlnode.nodeName == \"taskbegin\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        xt = xmlnode.attributes",
            "                        taskname = xt[\"task\"].value",
            "                        starttime = xt[\"time\"].value",
            "                        xinfo = \"\"",
            "                        if \"extrainfo\" in xt.keys():",
            "                            xinfo = xt[\"extrainfo\"].value",
            "                        newtask = NmapTask(taskname, starttime, xinfo)",
            "                        self.__nmap_tasks[newtask.name] = newtask",
            "                        self.__current_task = newtask.name",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"taskend\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        xt = xmlnode.attributes",
            "                        tname = xt[\"task\"].value",
            "                        xinfo = \"\"",
            "                        self.__nmap_tasks[tname].endtime = xt[\"time\"].value",
            "                        if \"extrainfo\" in xt.keys():",
            "                            xinfo = xt[\"extrainfo\"].value",
            "                        self.__nmap_tasks[tname].extrainfo = xinfo",
            "                        self.__nmap_tasks[tname].status = \"ended\"",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"taskprogress\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        xt = xmlnode.attributes",
            "                        tname = xt[\"task\"].value",
            "                        percent = xt[\"percent\"].value",
            "                        etc = xt[\"etc\"].value",
            "                        remaining = xt[\"remaining\"].value",
            "                        updated = xt[\"time\"].value",
            "                        self.__nmap_tasks[tname].percent = percent",
            "                        self.__nmap_tasks[tname].progress = percent",
            "                        self.__nmap_tasks[tname].etc = etc",
            "                        self.__nmap_tasks[tname].remaining = remaining",
            "                        self.__nmap_tasks[tname].updated = updated",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"nmaprun\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        self.__starttime = xmlnode.attributes[\"start\"].value",
            "                        self.__version = xmlnode.attributes[\"version\"].value",
            "                        rval = True",
            "                    elif (",
            "                        xmlnode.nodeName == \"finished\"",
            "                        and xmlnode.attributes.keys()",
            "                    ):",
            "                        self.__endtime = xmlnode.attributes[\"time\"].value",
            "                        self.__elapsed = xmlnode.attributes[\"elapsed\"].value",
            "                        self.__summary = xmlnode.attributes[\"summary\"].value",
            "                        rval = True",
            "        except Exception:",
            "            pass",
            "        return rval",
            "",
            "    def __build_windows_cmdline(self):",
            "        cmdline = []",
            "        cmdline.append(self.__nmap_binary)",
            "        if self.__nmap_fixed_options:",
            "            cmdline += self.__nmap_fixed_options.split()",
            "        if self.__nmap_dynamic_options:",
            "            cmdline += self.__nmap_dynamic_options.split()",
            "        if self.__nmap_targets:",
            "            cmdline += self.__nmap_targets  # already a list",
            "        return cmdline",
            "",
            "    @staticmethod",
            "    def __validate_target(target):",
            "        # See https://nmap.org/book/man-target-specification.html for all the",
            "        # ways targets can be specified",
            "        allowed_characters = frozenset(",
            "            string.ascii_letters + string.digits + \"-.:/% \"",
            "        )",
            "        if not set(target).issubset(allowed_characters):",
            "            raise Exception(",
            "                \"Target '{}' contains invalid characters\".format(target)",
            "            )",
            "        # FQDN can contain dashes anywhere except at the beginning or end",
            "        # This check also fixes/prevents CVE-2022-30284, which depends on being",
            "        # able to pass options such as --script as a target",
            "        elif target.startswith(\"-\") or target.endswith(\"-\"):",
            "            raise Exception(",
            "                \"Target '{}' cannot begin or end with a dash ('-')\".format(",
            "                    target",
            "                )",
            "            )",
            "",
            "    @property",
            "    def command(self):",
            "        \"\"\"",
            "        return the constructed nmap command or empty string if not",
            "        constructed yet.",
            "",
            "        :return: string",
            "        \"\"\"",
            "        return self.__nmap_command_line or \"\"",
            "",
            "    @property",
            "    def targets(self):",
            "        \"\"\"",
            "        Provides the list of targets to scan",
            "",
            "        :return: list of string",
            "        \"\"\"",
            "        return self.__nmap_targets",
            "",
            "    @property",
            "    def options(self):",
            "        \"\"\"",
            "        Provides the list of options for that scan",
            "",
            "        :return: list of string (nmap options)",
            "        \"\"\"",
            "        return self._nmap_options",
            "",
            "    @property",
            "    def state(self):",
            "        \"\"\"",
            "        Accessor for nmap execution state. Possible states are:",
            "",
            "        - self.READY",
            "        - self.RUNNING",
            "        - self.FAILED",
            "        - self.CANCELLED",
            "        - self.DONE",
            "",
            "        :return: integer (from above documented enum)",
            "        \"\"\"",
            "        return self.__state",
            "",
            "    @property",
            "    def starttime(self):",
            "        \"\"\"",
            "        Accessor for time when scan started",
            "",
            "        :return: string. Unix timestamp",
            "        \"\"\"",
            "        return self.__starttime",
            "",
            "    @property",
            "    def endtime(self):",
            "        \"\"\"",
            "        Accessor for time when scan ended",
            "",
            "        :return: string. Unix timestamp",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"data collected from finished events are deprecated.\"",
            "            \"Use NmapParser.parse()\",",
            "            DeprecationWarning,",
            "        )",
            "        return self.__endtime",
            "",
            "    @property",
            "    def elapsed(self):",
            "        \"\"\"",
            "        Accessor returning for how long the scan ran (in seconds)",
            "",
            "        :return: string",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"data collected from finished events are deprecated.\"",
            "            \"Use NmapParser.parse()\",",
            "            DeprecationWarning,",
            "        )",
            "        return self.__elapsed",
            "",
            "    @property",
            "    def summary(self):",
            "        \"\"\"",
            "        Accessor returning a short summary of the scan's results",
            "",
            "        :return: string",
            "        \"\"\"",
            "        warnings.warn(",
            "            \"data collected from finished events are deprecated.\"",
            "            \"Use NmapParser.parse()\",",
            "            DeprecationWarning,",
            "        )",
            "        return self.__summary",
            "",
            "    @property",
            "    def tasks(self):",
            "        \"\"\"",
            "        Accessor returning for the list of tasks ran during nmap scan",
            "",
            "        :return: dict of NmapTask object",
            "        \"\"\"",
            "        return self.__nmap_tasks",
            "",
            "    @property",
            "    def version(self):",
            "        \"\"\"",
            "        Accessor for nmap binary version number",
            "",
            "        :return: version number of nmap binary",
            "        :rtype: string",
            "        \"\"\"",
            "        return self.__version",
            "",
            "    @property",
            "    def current_task(self):",
            "        \"\"\"",
            "        Accessor for the current NmapTask beeing run",
            "",
            "        :return: NmapTask or None if no task started yet",
            "        \"\"\"",
            "        rval = None",
            "        if len(self.__current_task):",
            "            rval = self.tasks[self.__current_task]",
            "        return rval",
            "",
            "    @property",
            "    def etc(self):",
            "        \"\"\"",
            "        Accessor for estimated time to completion",
            "",
            "        :return:  estimated time to completion",
            "        \"\"\"",
            "        rval = 0",
            "        if self.current_task:",
            "            rval = self.current_task.etc",
            "        return rval",
            "",
            "    @property",
            "    def progress(self):",
            "        \"\"\"",
            "        Accessor for progress status in percentage",
            "",
            "        :return: percentage of job processed.",
            "        \"\"\"",
            "        rval = 0",
            "        if self.current_task:",
            "            rval = self.current_task.progress",
            "        return rval",
            "",
            "    @property",
            "    def rc(self):",
            "        \"\"\"",
            "        Accessor for nmap execution's return code",
            "",
            "        :return: nmap execution's return code",
            "        \"\"\"",
            "        return self.__nmap_rc",
            "",
            "    @property",
            "    def stdout(self):",
            "        \"\"\"",
            "        Accessor for nmap standart output",
            "",
            "        :return: output from nmap scan in XML",
            "        :rtype: string",
            "        \"\"\"",
            "        return self.__stdout",
            "",
            "    @property",
            "    def stderr(self):",
            "        \"\"\"",
            "        Accessor for nmap standart error",
            "",
            "        :return: output from nmap when errors occured.",
            "        :rtype: string",
            "        \"\"\"",
            "        return self.__stderr",
            "",
            "",
            "def main():",
            "    def mycallback(nmapscan=None):",
            "        if nmapscan.is_running() and nmapscan.current_task:",
            "            ntask = nmapscan.current_task",
            "            print(",
            "                \"Task {0} ({1}): ETC: {2} DONE: {3}%\".format(",
            "                    ntask.name, ntask.status, ntask.etc, ntask.progress",
            "                )",
            "            )",
            "",
            "    nm = NmapProcess(",
            "        \"scanme.nmap.org\", options=\"-A\", event_callback=mycallback",
            "    )",
            "    rc = nm.run()",
            "    if rc == 0:",
            "        print(",
            "            \"Scan started at {0} nmap version: {1}\".format(",
            "                nm.starttime, nm.version",
            "            )",
            "        )",
            "        print(\"state: {0} (rc: {1})\".format(nm.state, nm.rc))",
            "        print(\"results size: {0}\".format(len(nm.stdout)))",
            "        print(\"Scan ended {0}: {1}\".format(nm.endtime, nm.summary))",
            "    else:",
            "        print(\"state: {0} (rc: {1})\".format(nm.state, nm.rc))",
            "        print(\"Error: {stderr}\".format(stderr=nm.stderr))",
            "        print(\"Result: {0}\".format(nm.stdout))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "libnmap.process.main",
            "tensorflow.python.kernel_tests.array_ops.array_ops_test.SliceAssignTest.testTensorStridedSliceUpdateNoInputForward",
            "libnmap.process.NmapProcess.self",
            "libnmap.process.NmapProcess.__init__",
            "libnmap.process.main.nm",
            "libnmap.process.NmapProcess"
        ]
    },
    "libnmap/test/test_process.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "             self._assertRaisesRegex = self.assertRaisesRegexp"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         self.fdir = os.path.dirname(os.path.realpath(__file__))"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_check_targets(self):"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        invalid_target_tests = [{\"a\": \"bba\"}, 5]"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    def test_check_valid_targets(self):"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         valid_target_tests = ["
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "             {\"value\": \"127.0.0.1, 1.1.1.1,     2.20.202\", \"size\": 3},"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "             {\"value\": [\"127.0.0.1\", \"1.1.1.1\", \"2.20.202.2\"], \"size\": 3},"
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "             {\"value\": [\"     127.0.0.1\", \"  1.1.1.1\"], \"size\": 2},"
            },
            "10": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "             {\"value\": \"     127.0.0.1,      1.1.1.1  , a\", \"size\": 3},"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+            {\"value\": [\"192.168.10.0/24\", \"192.168.0-255.1-254\"], \"size\": 2},"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            {\"value\": [\"fe80::a8bb:ccff:fedd:eeff%eth0\"], \"size\": 1},"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+            {\"value\": [\"my-domain.com\", \"my-num3r1c-domain.com\"], \"size\": 2},"
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         ]"
            },
            "15": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         for vtarget in valid_target_tests:"
            },
            "16": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "             nmapobj = NmapProcess(targets=vtarget[\"value\"], options=\"-sP\")"
            },
            "17": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "             self.assertEqual(vtarget[\"size\"], len(nmapobj.targets))"
            },
            "18": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for vtarget in invalid_target_tests:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    def test_check_invalid_targets(self):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        invalid_target_type_tests = [{\"a\": \"bba\"}, 5]"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        invalid_target_character_tests = [\"1.1.1.1$\", \"invalid_domain.com\"]"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        invalid_target_dash_tests = [\"-invalid-target\", \"--option\"]"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        for vtarget in invalid_target_type_tests:"
            },
            "26": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "             self._assertRaisesRegex("
            },
            "27": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "                 Exception,"
            },
            "28": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "                 \"Supplied target list should be either a string or a list\","
            },
            "29": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "                 options=\"-sP\","
            },
            "30": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             )"
            },
            "31": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        for vtarget in invalid_target_character_tests:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            self._assertRaisesRegex("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                Exception,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                \"contains invalid characters\","
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                NmapProcess,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                targets=vtarget,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                options=\"-sP\","
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+            )"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        for vtarget in invalid_target_dash_tests:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            self._assertRaisesRegex("
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                Exception,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+                \"cannot begin or end with a dash\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+                NmapProcess,"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                targets=vtarget,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                options=\"-sP\","
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            )"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     def test_nmap_options(self):"
            },
            "51": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         invalid_options = [\"--iflist\"]"
            },
            "52": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "import os",
            "import sys",
            "import unittest",
            "from time import sleep",
            "",
            "from libnmap.objects.report import NmapReport",
            "from libnmap.parser import NmapParser",
            "from libnmap.process import NmapProcess",
            "",
            "",
            "class TestNmapProcess(unittest.TestCase):",
            "    def setUp(self):",
            "        if int(sys.version[0]) == 3:",
            "            self._assertRaisesRegex = self.assertRaisesRegex",
            "        else:",
            "            self._assertRaisesRegex = self.assertRaisesRegexp",
            "        self.fdir = os.path.dirname(os.path.realpath(__file__))",
            "",
            "    def test_check_targets(self):",
            "        invalid_target_tests = [{\"a\": \"bba\"}, 5]",
            "        valid_target_tests = [",
            "            {\"value\": \"127.0.0.1, 1.1.1.1,     2.20.202\", \"size\": 3},",
            "            {\"value\": [\"127.0.0.1\", \"1.1.1.1\", \"2.20.202.2\"], \"size\": 3},",
            "            {\"value\": [\"     127.0.0.1\", \"  1.1.1.1\"], \"size\": 2},",
            "            {\"value\": \"     127.0.0.1,      1.1.1.1  , a\", \"size\": 3},",
            "        ]",
            "        for vtarget in valid_target_tests:",
            "            nmapobj = NmapProcess(targets=vtarget[\"value\"], options=\"-sP\")",
            "            self.assertEqual(vtarget[\"size\"], len(nmapobj.targets))",
            "",
            "        for vtarget in invalid_target_tests:",
            "            self._assertRaisesRegex(",
            "                Exception,",
            "                \"Supplied target list should be either a string or a list\",",
            "                NmapProcess,",
            "                targets=vtarget,",
            "                options=\"-sP\",",
            "            )",
            "",
            "    def test_nmap_options(self):",
            "        invalid_options = [\"--iflist\"]",
            "",
            "        for invalid_option in invalid_options:",
            "            self._assertRaisesRegex(",
            "                Exception,",
            "                \"unsafe options activated while safe_mode is set True\",",
            "                NmapProcess,",
            "                targets=\"127.0.0.1\",",
            "                options=invalid_option,",
            "            )",
            "",
            "    def test_missing_binary(self):",
            "        _path = os.environ[\"PATH\"]",
            "        os.environ[\"PATH\"] = \"/does_not_exists\"",
            "        self._assertRaisesRegex(",
            "            EnvironmentError,",
            "            \"nmap is not installed or could not be found in system path\",",
            "            NmapProcess,",
            "            targets=\"127.0.0.1\",",
            "            options=\"-sP\",",
            "        )",
            "        os.environ[\"PATH\"] = _path",
            "",
            "    def test_exec_env(self):",
            "        self.assertRaises(",
            "            EnvironmentError,",
            "            NmapProcess,",
            "            targets=\"127.0.0.1\",",
            "            options=\"-sV\",",
            "            fqp=\"/usr/bin/does-not-exists\",",
            "        )",
            "",
            "    def test_exec(self):",
            "        nmapobj = NmapProcess(targets=\"127.0.0.1\", options=\"-sP\")",
            "        rc = nmapobj.run()",
            "        parsed = NmapParser.parse(nmapobj.stdout)",
            "        self.assertEqual(rc, 0)",
            "        self.assertGreater(len(nmapobj.stdout), 0)",
            "        self.assertIsInstance(parsed, NmapReport)",
            "",
            "    def test_sudo_exec(self):",
            "        nmapobj = NmapProcess(targets=\"127.0.0.1\", options=\"-sP\")",
            "        self._assertRaisesRegex(",
            "            EnvironmentError,",
            "            \"Username.*does not exists\",",
            "            nmapobj.sudo_run,",
            "            run_as=\"non-existing-user\",",
            "        )",
            "        self._assertRaisesRegex(",
            "            EnvironmentError,",
            "            \"Username.*does not exists\",",
            "            nmapobj.sudo_run_background,",
            "            run_as=\"non-existing-user\",",
            "        )",
            "",
            "    def test_exec_reportsize(self):",
            "        def make_nmproc_obj(targets, options):",
            "            return NmapProcess(targets=targets, options=options)",
            "",
            "        def start_all(nmprocs):",
            "            for nmp in nmprocs:",
            "                nmp.run()",
            "",
            "        nb_targets = 20",
            "        nm_target = \"localhost\"",
            "        nm_opts = \"-sT\"",
            "",
            "        nm_targets = [nm_target for i in range(nb_targets)]",
            "        nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]",
            "        start_all(nm_procs)",
            "",
            "        nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]",
            "        start_all(nm_procs)",
            "",
            "        self.assertEqual(len(nm_procs), nb_targets)",
            "",
            "        total_size = 0",
            "        for i in range(len(nm_procs)):",
            "            total_size += len(nm_procs[i].stdout)",
            "",
            "        average_size = int(total_size / len(nm_procs))",
            "        for nm in nm_procs:",
            "            self.assertAlmostEqual(",
            "                average_size, int(len(nm.stdout)), delta=200",
            "            )",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    test_suite = [",
            "        \"test_exec_env\",",
            "        \"test_check_targets\",",
            "        \"test_exec\",",
            "        \"test_exec_reportsize\",",
            "    ]",
            "    suite = unittest.TestSuite(map(TestNmapProcess, test_suite))",
            "    test_result = unittest.TextTestRunner(verbosity=2).run(suite)"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "",
            "import os",
            "import sys",
            "import unittest",
            "from time import sleep",
            "",
            "from libnmap.objects.report import NmapReport",
            "from libnmap.parser import NmapParser",
            "from libnmap.process import NmapProcess",
            "",
            "",
            "class TestNmapProcess(unittest.TestCase):",
            "    def setUp(self):",
            "        if int(sys.version[0]) == 3:",
            "            self._assertRaisesRegex = self.assertRaisesRegex",
            "        else:",
            "            self._assertRaisesRegex = self.assertRaisesRegexp",
            "        self.fdir = os.path.dirname(os.path.realpath(__file__))",
            "",
            "    def test_check_valid_targets(self):",
            "        valid_target_tests = [",
            "            {\"value\": \"127.0.0.1, 1.1.1.1,     2.20.202\", \"size\": 3},",
            "            {\"value\": [\"127.0.0.1\", \"1.1.1.1\", \"2.20.202.2\"], \"size\": 3},",
            "            {\"value\": [\"     127.0.0.1\", \"  1.1.1.1\"], \"size\": 2},",
            "            {\"value\": \"     127.0.0.1,      1.1.1.1  , a\", \"size\": 3},",
            "            {\"value\": [\"192.168.10.0/24\", \"192.168.0-255.1-254\"], \"size\": 2},",
            "            {\"value\": [\"fe80::a8bb:ccff:fedd:eeff%eth0\"], \"size\": 1},",
            "            {\"value\": [\"my-domain.com\", \"my-num3r1c-domain.com\"], \"size\": 2},",
            "        ]",
            "        for vtarget in valid_target_tests:",
            "            nmapobj = NmapProcess(targets=vtarget[\"value\"], options=\"-sP\")",
            "            self.assertEqual(vtarget[\"size\"], len(nmapobj.targets))",
            "",
            "    def test_check_invalid_targets(self):",
            "        invalid_target_type_tests = [{\"a\": \"bba\"}, 5]",
            "        invalid_target_character_tests = [\"1.1.1.1$\", \"invalid_domain.com\"]",
            "        invalid_target_dash_tests = [\"-invalid-target\", \"--option\"]",
            "",
            "        for vtarget in invalid_target_type_tests:",
            "            self._assertRaisesRegex(",
            "                Exception,",
            "                \"Supplied target list should be either a string or a list\",",
            "                NmapProcess,",
            "                targets=vtarget,",
            "                options=\"-sP\",",
            "            )",
            "",
            "        for vtarget in invalid_target_character_tests:",
            "            self._assertRaisesRegex(",
            "                Exception,",
            "                \"contains invalid characters\",",
            "                NmapProcess,",
            "                targets=vtarget,",
            "                options=\"-sP\",",
            "            )",
            "",
            "        for vtarget in invalid_target_dash_tests:",
            "            self._assertRaisesRegex(",
            "                Exception,",
            "                \"cannot begin or end with a dash\",",
            "                NmapProcess,",
            "                targets=vtarget,",
            "                options=\"-sP\",",
            "            )",
            "",
            "    def test_nmap_options(self):",
            "        invalid_options = [\"--iflist\"]",
            "",
            "        for invalid_option in invalid_options:",
            "            self._assertRaisesRegex(",
            "                Exception,",
            "                \"unsafe options activated while safe_mode is set True\",",
            "                NmapProcess,",
            "                targets=\"127.0.0.1\",",
            "                options=invalid_option,",
            "            )",
            "",
            "    def test_missing_binary(self):",
            "        _path = os.environ[\"PATH\"]",
            "        os.environ[\"PATH\"] = \"/does_not_exists\"",
            "        self._assertRaisesRegex(",
            "            EnvironmentError,",
            "            \"nmap is not installed or could not be found in system path\",",
            "            NmapProcess,",
            "            targets=\"127.0.0.1\",",
            "            options=\"-sP\",",
            "        )",
            "        os.environ[\"PATH\"] = _path",
            "",
            "    def test_exec_env(self):",
            "        self.assertRaises(",
            "            EnvironmentError,",
            "            NmapProcess,",
            "            targets=\"127.0.0.1\",",
            "            options=\"-sV\",",
            "            fqp=\"/usr/bin/does-not-exists\",",
            "        )",
            "",
            "    def test_exec(self):",
            "        nmapobj = NmapProcess(targets=\"127.0.0.1\", options=\"-sP\")",
            "        rc = nmapobj.run()",
            "        parsed = NmapParser.parse(nmapobj.stdout)",
            "        self.assertEqual(rc, 0)",
            "        self.assertGreater(len(nmapobj.stdout), 0)",
            "        self.assertIsInstance(parsed, NmapReport)",
            "",
            "    def test_sudo_exec(self):",
            "        nmapobj = NmapProcess(targets=\"127.0.0.1\", options=\"-sP\")",
            "        self._assertRaisesRegex(",
            "            EnvironmentError,",
            "            \"Username.*does not exists\",",
            "            nmapobj.sudo_run,",
            "            run_as=\"non-existing-user\",",
            "        )",
            "        self._assertRaisesRegex(",
            "            EnvironmentError,",
            "            \"Username.*does not exists\",",
            "            nmapobj.sudo_run_background,",
            "            run_as=\"non-existing-user\",",
            "        )",
            "",
            "    def test_exec_reportsize(self):",
            "        def make_nmproc_obj(targets, options):",
            "            return NmapProcess(targets=targets, options=options)",
            "",
            "        def start_all(nmprocs):",
            "            for nmp in nmprocs:",
            "                nmp.run()",
            "",
            "        nb_targets = 20",
            "        nm_target = \"localhost\"",
            "        nm_opts = \"-sT\"",
            "",
            "        nm_targets = [nm_target for i in range(nb_targets)]",
            "        nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]",
            "        start_all(nm_procs)",
            "",
            "        nm_procs = [make_nmproc_obj(t, nm_opts) for t in nm_targets]",
            "        start_all(nm_procs)",
            "",
            "        self.assertEqual(len(nm_procs), nb_targets)",
            "",
            "        total_size = 0",
            "        for i in range(len(nm_procs)):",
            "            total_size += len(nm_procs[i].stdout)",
            "",
            "        average_size = int(total_size / len(nm_procs))",
            "        for nm in nm_procs:",
            "            self.assertAlmostEqual(",
            "                average_size, int(len(nm.stdout)), delta=200",
            "            )",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    test_suite = [",
            "        \"test_exec_env\",",
            "        \"test_check_targets\",",
            "        \"test_exec\",",
            "        \"test_exec_reportsize\",",
            "    ]",
            "    suite = unittest.TestSuite(map(TestNmapProcess, test_suite))",
            "    test_result = unittest.TextTestRunner(verbosity=2).run(suite)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [
                "TestNmapProcess",
                "test_check_targets"
            ],
            "23": [
                "TestNmapProcess",
                "test_check_targets"
            ],
            "34": [
                "TestNmapProcess",
                "test_check_targets"
            ]
        },
        "addLocation": []
    }
}