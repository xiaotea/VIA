{
    "keystone/notifications.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "                                          taxonomy.OUTCOME_FAILURE,"
            },
            "1": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "                                          target, self.event_type,"
            },
            "2": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "                                          reason=audit_reason)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 583,
                "PatchRowcode": "+                if isinstance(ex, exception.AccountLocked):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 584,
                "PatchRowcode": "+                    raise exception.Unauthorized"
            },
            "5": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 585,
                "PatchRowcode": "                 raise"
            },
            "6": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "             except Exception:"
            },
            "7": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": 587,
                "PatchRowcode": "                 # For authentication failure send a CADF event as well"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 IBM Corp.",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "",
            "\"\"\"Notifications module for OpenStack Identity Service resources.\"\"\"",
            "",
            "import collections",
            "import functools",
            "import inspect",
            "import socket",
            "",
            "import flask",
            "from oslo_log import log",
            "import oslo_messaging",
            "from oslo_utils import reflection",
            "import pycadf",
            "from pycadf import cadftaxonomy as taxonomy",
            "from pycadf import cadftype",
            "from pycadf import credential",
            "from pycadf import eventfactory",
            "from pycadf import host",
            "from pycadf import reason",
            "from pycadf import resource",
            "",
            "from keystone.common import context",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "import keystone.conf",
            "from keystone import exception",
            "from keystone.i18n import _",
            "",
            "",
            "_CATALOG_HELPER_OBJ = None",
            "",
            "LOG = log.getLogger(__name__)",
            "# NOTE(gyee): actions that can be notified. One must update this list whenever",
            "# a new action is supported.",
            "_ACTIONS = collections.namedtuple(",
            "    'NotificationActions',",
            "    'created, deleted, disabled, updated, internal')",
            "ACTIONS = _ACTIONS(created='created', deleted='deleted', disabled='disabled',",
            "                   updated='updated', internal='internal')",
            "\"\"\"The actions on resources.\"\"\"",
            "",
            "CADF_TYPE_MAP = {",
            "    'group': taxonomy.SECURITY_GROUP,",
            "    'project': taxonomy.SECURITY_PROJECT,",
            "    'role': taxonomy.SECURITY_ROLE,",
            "    'user': taxonomy.SECURITY_ACCOUNT_USER,",
            "    'domain': taxonomy.SECURITY_DOMAIN,",
            "    'region': taxonomy.SECURITY_REGION,",
            "    'endpoint': taxonomy.SECURITY_ENDPOINT,",
            "    'service': taxonomy.SECURITY_SERVICE,",
            "    'policy': taxonomy.SECURITY_POLICY,",
            "    'OS-TRUST:trust': taxonomy.SECURITY_TRUST,",
            "    'OS-OAUTH1:access_token': taxonomy.SECURITY_CREDENTIAL,",
            "    'OS-OAUTH1:request_token': taxonomy.SECURITY_CREDENTIAL,",
            "    'OS-OAUTH1:consumer': taxonomy.SECURITY_ACCOUNT,",
            "    'application_credential': taxonomy.SECURITY_CREDENTIAL,",
            "}",
            "",
            "SAML_AUDIT_TYPE = 'http://docs.oasis-open.org/security/saml/v2.0'",
            "# resource types that can be notified",
            "_SUBSCRIBERS = {}",
            "_notifier = None",
            "SERVICE = 'identity'",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "ROOT_DOMAIN = '<<keystone.domain.root>>'",
            "",
            "CONF = keystone.conf.CONF",
            "",
            "# NOTE(morganfainberg): Special case notifications that are only used",
            "# internally for handling token persistence token deletions",
            "INVALIDATE_TOKEN_CACHE = 'invalidate_token_cache'  # nosec",
            "PERSIST_REVOCATION_EVENT_FOR_USER = 'persist_revocation_event_for_user'",
            "REMOVE_APP_CREDS_FOR_USER = 'remove_application_credentials_for_user'",
            "DOMAIN_DELETED = 'domain_deleted'",
            "",
            "",
            "def build_audit_initiator():",
            "    \"\"\"A pyCADF initiator describing the current authenticated context.\"\"\"",
            "    pycadf_host = host.Host(address=flask.request.remote_addr,",
            "                            agent=str(flask.request.user_agent))",
            "    initiator = resource.Resource(typeURI=taxonomy.ACCOUNT_USER,",
            "                                  host=pycadf_host)",
            "    oslo_context = flask.request.environ.get(context.REQUEST_CONTEXT_ENV)",
            "    if oslo_context.user_id:",
            "        initiator.id = utils.resource_uuid(oslo_context.user_id)",
            "        initiator.user_id = oslo_context.user_id",
            "",
            "    if oslo_context.project_id:",
            "        initiator.project_id = oslo_context.project_id",
            "",
            "    if oslo_context.domain_id:",
            "        initiator.domain_id = oslo_context.domain_id",
            "",
            "    initiator.request_id = oslo_context.request_id",
            "",
            "    if oslo_context.global_request_id:",
            "        initiator.global_request_id = oslo_context.global_request_id",
            "",
            "    return initiator",
            "",
            "",
            "class Audit(object):",
            "    \"\"\"Namespace for audit notification functions.",
            "",
            "    This is a namespace object to contain all of the direct notification",
            "    functions utilized for ``Manager`` methods.",
            "    \"\"\"",
            "",
            "    @classmethod",
            "    def _emit(cls, operation, resource_type, resource_id, initiator, public,",
            "              actor_dict=None, reason=None):",
            "        \"\"\"Directly send an event notification.",
            "",
            "        :param operation: one of the values from ACTIONS",
            "        :param resource_type: type of resource being affected",
            "        :param resource_id: ID of the resource affected",
            "        :param initiator: CADF representation of the user that created the",
            "                          request",
            "        :param public: If True (default), the event will be sent to the",
            "                       notifier API.  If False, the event will only be sent via",
            "                       notify_event_callbacks to in process listeners",
            "        :param actor_dict: dictionary of actor information in the event of",
            "                           assignment notification",
            "        :param reason: pycadf object containing the response code and",
            "                       message description",
            "        \"\"\"",
            "        # NOTE(stevemar): the _send_notification function is",
            "        # overloaded, it's used to register callbacks and to actually",
            "        # send the notification externally. Thus, we should check",
            "        # the desired notification format in the function instead",
            "        # of before it.",
            "        _send_notification(",
            "            operation,",
            "            resource_type,",
            "            resource_id,",
            "            initiator=initiator,",
            "            actor_dict=actor_dict,",
            "            public=public)",
            "",
            "        if CONF.notification_format == 'cadf' and public:",
            "            outcome = taxonomy.OUTCOME_SUCCESS",
            "            _create_cadf_payload(operation, resource_type, resource_id,",
            "                                 outcome, initiator, reason)",
            "",
            "    @classmethod",
            "    def created(cls, resource_type, resource_id, initiator=None,",
            "                public=True, reason=None):",
            "        cls._emit(ACTIONS.created, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def updated(cls, resource_type, resource_id, initiator=None,",
            "                public=True, reason=None):",
            "        cls._emit(ACTIONS.updated, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def disabled(cls, resource_type, resource_id, initiator=None,",
            "                 public=True, reason=None):",
            "        cls._emit(ACTIONS.disabled, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def deleted(cls, resource_type, resource_id, initiator=None,",
            "                public=True, reason=None):",
            "        cls._emit(ACTIONS.deleted, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def added_to(cls, target_type, target_id, actor_type, actor_id,",
            "                 initiator=None, public=True, reason=None):",
            "        actor_dict = {'id': actor_id,",
            "                      'type': actor_type,",
            "                      'actor_operation': 'added'}",
            "        cls._emit(ACTIONS.updated, target_type, target_id, initiator, public,",
            "                  actor_dict=actor_dict, reason=reason)",
            "",
            "    @classmethod",
            "    def removed_from(cls, target_type, target_id, actor_type, actor_id,",
            "                     initiator=None, public=True, reason=None):",
            "        actor_dict = {'id': actor_id,",
            "                      'type': actor_type,",
            "                      'actor_operation': 'removed'}",
            "        cls._emit(ACTIONS.updated, target_type, target_id, initiator, public,",
            "                  actor_dict=actor_dict, reason=reason)",
            "",
            "    @classmethod",
            "    def internal(cls, resource_type, resource_id, reason=None):",
            "        # NOTE(lbragstad): Internal notifications are never public and have",
            "        # never used the initiator variable, but the _emit() method expects",
            "        # them. Let's set them here but not expose them through the method",
            "        # signature - that way someone can not do something like send an",
            "        # internal notification publicly.",
            "        initiator = None",
            "        public = False",
            "        cls._emit(ACTIONS.internal, resource_type, resource_id, initiator,",
            "                  public, reason)",
            "",
            "",
            "def invalidate_token_cache_notification(reason):",
            "    \"\"\"A specific notification for invalidating the token cache.",
            "",
            "    :param reason: The specific reason why the token cache is being",
            "                   invalidated.",
            "    :type reason: string",
            "",
            "    \"\"\"",
            "    # Since keystone does a lot of work in the authentication and validation",
            "    # process to make sure the authorization context for the user is",
            "    # update-to-date, invalidating the token cache is a somewhat common",
            "    # operation. It's done across various subsystems when role assignments",
            "    # change, users are disabled, identity providers deleted or disabled, etc..",
            "    # This notification is meant to make the process of invalidating the token",
            "    # cache DRY, instead of have each subsystem implement their own token cache",
            "    # invalidation strategy or callbacks.",
            "    LOG.debug(reason)",
            "    resource_id = None",
            "    initiator = None",
            "    public = False",
            "    Audit._emit(",
            "        ACTIONS.internal, INVALIDATE_TOKEN_CACHE, resource_id, initiator,",
            "        public, reason=reason",
            "    )",
            "",
            "",
            "def _get_callback_info(callback):",
            "    \"\"\"Return list containing callback's module and name.",
            "",
            "    If the callback is a bound instance method also return the class name.",
            "",
            "    :param callback: Function to call",
            "    :type callback: function",
            "    :returns: List containing parent module, (optional class,) function name",
            "    :rtype: list",
            "    \"\"\"",
            "    module_name = getattr(callback, '__module__', None)",
            "    func_name = callback.__name__",
            "    if inspect.ismethod(callback):",
            "        class_name = reflection.get_class_name(callback.__self__,",
            "                                               fully_qualified=False)",
            "        return [module_name, class_name, func_name]",
            "    else:",
            "        return [module_name, func_name]",
            "",
            "",
            "def register_event_callback(event, resource_type, callbacks):",
            "    \"\"\"Register each callback with the event.",
            "",
            "    :param event: Action being registered",
            "    :type event: keystone.notifications.ACTIONS",
            "    :param resource_type: Type of resource being operated on",
            "    :type resource_type: str",
            "    :param callbacks: Callback items to be registered with event",
            "    :type callbacks: list",
            "    :raises ValueError: If event is not a valid ACTION",
            "    :raises TypeError: If callback is not callable",
            "    \"\"\"",
            "    if event not in ACTIONS:",
            "        raise ValueError(_('%(event)s is not a valid notification event, must '",
            "                           'be one of: %(actions)s') %",
            "                         {'event': event, 'actions': ', '.join(ACTIONS)})",
            "",
            "    if not hasattr(callbacks, '__iter__'):",
            "        callbacks = [callbacks]",
            "",
            "    for callback in callbacks:",
            "        if not callable(callback):",
            "            msg = 'Method not callable: %s' % callback",
            "            tr_msg = _('Method not callable: %s') % callback",
            "            LOG.error(msg)",
            "            raise TypeError(tr_msg)",
            "        _SUBSCRIBERS.setdefault(event, {}).setdefault(resource_type, set())",
            "        _SUBSCRIBERS[event][resource_type].add(callback)",
            "",
            "        if LOG.logger.getEffectiveLevel() <= log.DEBUG:",
            "            # Do this only if its going to appear in the logs.",
            "            msg = 'Callback: `%(callback)s` subscribed to event `%(event)s`.'",
            "            callback_info = _get_callback_info(callback)",
            "            callback_str = '.'.join(i for i in callback_info if i is not None)",
            "            event_str = '.'.join(['identity', resource_type, event])",
            "            LOG.debug(msg, {'callback': callback_str, 'event': event_str})",
            "",
            "",
            "def listener(cls):",
            "    \"\"\"A class decorator to declare a class to be a notification listener.",
            "",
            "    A notification listener must specify the event(s) it is interested in by",
            "    defining a ``event_callbacks`` attribute or property. ``event_callbacks``",
            "    is a dictionary where the key is the type of event and the value is a",
            "    dictionary containing a mapping of resource types to callback(s).",
            "",
            "    :data:`.ACTIONS` contains constants for the currently",
            "    supported events. There is currently no single place to find constants for",
            "    the resource types.",
            "",
            "    Example::",
            "",
            "        @listener",
            "        class Something(object):",
            "",
            "            def __init__(self):",
            "                self.event_callbacks = {",
            "                    notifications.ACTIONS.created: {",
            "                        'user': self._user_created_callback,",
            "                    },",
            "                    notifications.ACTIONS.deleted: {",
            "                        'project': [",
            "                            self._project_deleted_callback,",
            "                            self._do_cleanup,",
            "                        ]",
            "                    },",
            "                }",
            "",
            "    \"\"\"",
            "    def init_wrapper(init):",
            "        @functools.wraps(init)",
            "        def __new_init__(self, *args, **kwargs):",
            "            init(self, *args, **kwargs)",
            "            _register_event_callbacks(self)",
            "        return __new_init__",
            "",
            "    def _register_event_callbacks(self):",
            "        for event, resource_types in self.event_callbacks.items():",
            "            for resource_type, callbacks in resource_types.items():",
            "                register_event_callback(event, resource_type, callbacks)",
            "",
            "    cls.__init__ = init_wrapper(cls.__init__)",
            "    return cls",
            "",
            "",
            "def notify_event_callbacks(service, resource_type, operation, payload):",
            "    \"\"\"Send a notification to registered extensions.\"\"\"",
            "    if operation in _SUBSCRIBERS:",
            "        if resource_type in _SUBSCRIBERS[operation]:",
            "            for cb in _SUBSCRIBERS[operation][resource_type]:",
            "                subst_dict = {'cb_name': cb.__name__,",
            "                              'service': service,",
            "                              'resource_type': resource_type,",
            "                              'operation': operation,",
            "                              'payload': payload}",
            "                LOG.debug('Invoking callback %(cb_name)s for event '",
            "                          '%(service)s %(resource_type)s %(operation)s for '",
            "                          '%(payload)s', subst_dict)",
            "                cb(service, resource_type, operation, payload)",
            "",
            "",
            "def _get_notifier():",
            "    \"\"\"Return a notifier object.",
            "",
            "    If _notifier is None it means that a notifier object has not been set.",
            "    If _notifier is False it means that a notifier has previously failed to",
            "    construct.",
            "    Otherwise it is a constructed Notifier object.",
            "    \"\"\"",
            "    global _notifier",
            "",
            "    if _notifier is None:",
            "        host = CONF.default_publisher_id or socket.gethostname()",
            "        try:",
            "            transport = oslo_messaging.get_notification_transport(CONF)",
            "            _notifier = oslo_messaging.Notifier(transport,",
            "                                                \"identity.%s\" % host)",
            "        except Exception:",
            "            LOG.exception(\"Failed to construct notifier\")",
            "            _notifier = False",
            "",
            "    return _notifier",
            "",
            "",
            "def clear_subscribers():",
            "    \"\"\"Empty subscribers dictionary.",
            "",
            "    This effectively stops notifications since there will be no subscribers",
            "    to publish to.",
            "    \"\"\"",
            "    _SUBSCRIBERS.clear()",
            "",
            "",
            "def reset_notifier():",
            "    \"\"\"Reset the notifications internal state.",
            "",
            "    This is used only for testing purposes.",
            "",
            "    \"\"\"",
            "    global _notifier",
            "    _notifier = None",
            "",
            "",
            "def _create_cadf_payload(operation, resource_type, resource_id,",
            "                         outcome, initiator, reason=None):",
            "    \"\"\"Prepare data for CADF audit notifier.",
            "",
            "    Transform the arguments into content to be consumed by the function that",
            "    emits CADF events (_send_audit_notification). Specifically the",
            "    ``resource_type`` (role, user, etc) must be transformed into a CADF",
            "    keyword, such as: ``data/security/role``. The ``resource_id`` is added as a",
            "    top level value for the ``resource_info`` key. Lastly, the ``operation`` is",
            "    used to create the CADF ``action``, and the ``event_type`` name.",
            "",
            "    As per the CADF specification, the ``action`` must start with create,",
            "    update, delete, etc... i.e.: created.user or deleted.role",
            "",
            "    However the ``event_type`` is an OpenStack-ism that is typically of the",
            "    form project.resource.operation. i.e.: identity.project.updated",
            "",
            "    :param operation: operation being performed (created, updated, or deleted)",
            "    :param resource_type: type of resource being operated on (role, user, etc)",
            "    :param resource_id: ID of resource being operated on",
            "    :param outcome: outcomes of the operation (SUCCESS, FAILURE, etc)",
            "    :param initiator: CADF representation of the user that created the request",
            "    :param reason: pycadf object containing the response code and",
            "                   message description",
            "    \"\"\"",
            "    if resource_type not in CADF_TYPE_MAP:",
            "        target_uri = taxonomy.UNKNOWN",
            "    else:",
            "        target_uri = CADF_TYPE_MAP.get(resource_type)",
            "",
            "    # TODO(gagehugo): The root domain ID is typically hidden, there isn't a",
            "    # reason to emit a notification for it. Once we expose the root domain",
            "    # (and handle the CADF UUID), remove this.",
            "    if resource_id == ROOT_DOMAIN:",
            "        return",
            "",
            "    target = resource.Resource(typeURI=target_uri,",
            "                               id=resource_id)",
            "",
            "    audit_kwargs = {'resource_info': resource_id}",
            "    cadf_action = '%s.%s' % (operation, resource_type)",
            "    event_type = '%s.%s.%s' % (SERVICE, resource_type, operation)",
            "",
            "    _send_audit_notification(cadf_action, initiator, outcome,",
            "                             target, event_type, reason=reason, **audit_kwargs)",
            "",
            "",
            "def _send_notification(operation, resource_type, resource_id, initiator=None,",
            "                       actor_dict=None, public=True):",
            "    \"\"\"Send notification to inform observers about the affected resource.",
            "",
            "    This method doesn't raise an exception when sending the notification fails.",
            "",
            "    :param operation: operation being performed (created, updated, or deleted)",
            "    :param resource_type: type of resource being operated on",
            "    :param resource_id: ID of resource being operated on",
            "    :param initiator: representation of the user that created the request",
            "    :param actor_dict: a dictionary containing the actor's ID and type",
            "    :param public:  if True (default), the event will be sent",
            "                    to the notifier API.",
            "                    if False, the event will only be sent via",
            "                    notify_event_callbacks to in process listeners.",
            "    \"\"\"",
            "    payload = {'resource_info': resource_id}",
            "",
            "    if actor_dict:",
            "        payload['actor_id'] = actor_dict['id']",
            "        payload['actor_type'] = actor_dict['type']",
            "        payload['actor_operation'] = actor_dict['actor_operation']",
            "",
            "    if initiator:",
            "        payload['request_id'] = initiator.request_id",
            "        global_request_id = getattr(initiator, 'global_request_id', None)",
            "        if global_request_id:",
            "            payload['global_request_id'] = global_request_id",
            "",
            "    notify_event_callbacks(SERVICE, resource_type, operation, payload)",
            "",
            "    # Only send this notification if the 'basic' format is used, otherwise",
            "    # let the CADF functions handle sending the notification. But we check",
            "    # here so as to not disrupt the notify_event_callbacks function.",
            "    if public and CONF.notification_format == 'basic':",
            "        notifier = _get_notifier()",
            "        if notifier:",
            "            context = {}",
            "            event_type = '%(service)s.%(resource_type)s.%(operation)s' % {",
            "                'service': SERVICE,",
            "                'resource_type': resource_type,",
            "                'operation': operation}",
            "            if _check_notification_opt_out(event_type, outcome=None):",
            "                return",
            "            try:",
            "                notifier.info(context, event_type, payload)",
            "            except Exception:",
            "                LOG.exception(",
            "                    'Failed to send %(res_id)s %(event_type)s notification',",
            "                    {'res_id': resource_id, 'event_type': event_type})",
            "",
            "",
            "def _get_request_audit_info(context, user_id=None):",
            "    \"\"\"Collect audit information about the request used for CADF.",
            "",
            "    :param context: Request context",
            "    :param user_id: Optional user ID, alternatively collected from context",
            "    :returns: Auditing data about the request",
            "    :rtype: :class:`pycadf.Resource`",
            "    \"\"\"",
            "    remote_addr = None",
            "    http_user_agent = None",
            "    project_id = None",
            "    domain_id = None",
            "",
            "    if context and 'environment' in context and context['environment']:",
            "        environment = context['environment']",
            "        remote_addr = environment.get('REMOTE_ADDR')",
            "        http_user_agent = environment.get('HTTP_USER_AGENT')",
            "        if not user_id:",
            "            user_id = environment.get('KEYSTONE_AUTH_CONTEXT',",
            "                                      {}).get('user_id')",
            "        project_id = environment.get('KEYSTONE_AUTH_CONTEXT',",
            "                                     {}).get('project_id')",
            "        domain_id = environment.get('KEYSTONE_AUTH_CONTEXT',",
            "                                    {}).get('domain_id')",
            "",
            "    host = pycadf.host.Host(address=remote_addr, agent=http_user_agent)",
            "    initiator = resource.Resource(typeURI=taxonomy.ACCOUNT_USER, host=host)",
            "",
            "    if user_id:",
            "        initiator.user_id = user_id",
            "        initiator.id = utils.resource_uuid(user_id)",
            "        initiator = _add_username_to_initiator(initiator)",
            "",
            "    if project_id:",
            "        initiator.project_id = project_id",
            "    if domain_id:",
            "        initiator.domain_id = domain_id",
            "",
            "    return initiator",
            "",
            "",
            "class CadfNotificationWrapper(object):",
            "    \"\"\"Send CADF event notifications for various methods.",
            "",
            "    This function is only used for Authentication events. Its ``action`` and",
            "    ``event_type`` are dictated below.",
            "",
            "    - action: ``authenticate``",
            "    - event_type: ``identity.authenticate``",
            "",
            "    Sends CADF notifications for events such as whether an authentication was",
            "    successful or not.",
            "",
            "    :param operation: The authentication related action being performed",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, operation):",
            "        self.action = operation",
            "        self.event_type = '%s.%s' % (SERVICE, operation)",
            "",
            "    def __call__(self, f):",
            "        @functools.wraps(f)",
            "        def wrapper(wrapped_self, user_id, *args, **kwargs):",
            "            \"\"\"Will always send a notification.\"\"\"",
            "            target = resource.Resource(typeURI=taxonomy.ACCOUNT_USER)",
            "            initiator = build_audit_initiator()",
            "            initiator.user_id = user_id",
            "            initiator = _add_username_to_initiator(initiator)",
            "            initiator.id = utils.resource_uuid(user_id)",
            "            try:",
            "                result = f(wrapped_self, user_id, *args, **kwargs)",
            "            except (exception.AccountLocked,",
            "                    exception.PasswordExpired) as ex:",
            "                # Send a CADF event with a reason for PCI-DSS related",
            "                # authentication failures",
            "                audit_reason = reason.Reason(str(ex), str(ex.code))",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_FAILURE,",
            "                                         target, self.event_type,",
            "                                         reason=audit_reason)",
            "                raise",
            "            except Exception:",
            "                # For authentication failure send a CADF event as well",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_FAILURE,",
            "                                         target, self.event_type)",
            "                raise",
            "            else:",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_SUCCESS,",
            "                                         target, self.event_type)",
            "                return result",
            "",
            "        return wrapper",
            "",
            "",
            "class CadfRoleAssignmentNotificationWrapper(object):",
            "    \"\"\"Send CADF notifications for ``role_assignment`` methods.",
            "",
            "    This function is only used for role assignment events. Its ``action`` and",
            "    ``event_type`` are dictated below.",
            "",
            "    - action: ``created.role_assignment`` or ``deleted.role_assignment``",
            "    - event_type: ``identity.role_assignment.created`` or",
            "        ``identity.role_assignment.deleted``",
            "",
            "    Sends a CADF notification if the wrapped method does not raise an",
            "    :class:`Exception` (such as :class:`keystone.exception.NotFound`).",
            "",
            "    :param operation: one of the values from ACTIONS (created or deleted)",
            "    \"\"\"",
            "",
            "    ROLE_ASSIGNMENT = 'role_assignment'",
            "",
            "    def __init__(self, operation):",
            "        self.action = '%s.%s' % (operation, self.ROLE_ASSIGNMENT)",
            "        self.event_type = '%s.%s.%s' % (SERVICE, self.ROLE_ASSIGNMENT,",
            "                                        operation)",
            "",
            "    def __call__(self, f):",
            "        @functools.wraps(f)",
            "        def wrapper(wrapped_self, role_id, *args, **kwargs):",
            "            \"\"\"Send a notification if the wrapped callable is successful.",
            "",
            "            NOTE(stevemar): The reason we go through checking kwargs",
            "            and args for possible target and actor values is because the",
            "            create_grant() (and delete_grant()) method are called",
            "            differently in various tests.",
            "            Using named arguments, i.e.::",
            "",
            "                create_grant(user_id=user['id'], domain_id=domain['id'],",
            "                             role_id=role['id'])",
            "",
            "            Or, using positional arguments, i.e.::",
            "",
            "                create_grant(role_id['id'], user['id'], None,",
            "                             domain_id=domain['id'], None)",
            "",
            "            Or, both, i.e.::",
            "",
            "                create_grant(role_id['id'], user_id=user['id'],",
            "                             domain_id=domain['id'])",
            "",
            "            Checking the values for kwargs is easy enough, since it comes",
            "            in as a dictionary",
            "",
            "            The actual method signature is",
            "",
            "            ::",
            "",
            "                create_grant(role_id, user_id=None, group_id=None,",
            "                             domain_id=None, project_id=None,",
            "                             inherited_to_projects=False)",
            "",
            "            So, if the values of actor or target are still None after",
            "            checking kwargs, we can check the positional arguments,",
            "            based on the method signature.",
            "            \"\"\"",
            "            call_args = inspect.getcallargs(",
            "                f, wrapped_self, role_id, *args, **kwargs)",
            "            inherited = call_args['inherited_to_projects']",
            "            initiator = call_args.get('initiator', None)",
            "            target = resource.Resource(typeURI=taxonomy.ACCOUNT_USER)",
            "",
            "            audit_kwargs = {}",
            "            if call_args['project_id']:",
            "                audit_kwargs['project'] = call_args['project_id']",
            "            elif call_args['domain_id']:",
            "                audit_kwargs['domain'] = call_args['domain_id']",
            "",
            "            if call_args['user_id']:",
            "                audit_kwargs['user'] = call_args['user_id']",
            "            elif call_args['group_id']:",
            "                audit_kwargs['group'] = call_args['group_id']",
            "",
            "            audit_kwargs['inherited_to_projects'] = inherited",
            "            audit_kwargs['role'] = role_id",
            "",
            "            try:",
            "                result = f(wrapped_self, role_id, *args, **kwargs)",
            "            except Exception:",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_FAILURE,",
            "                                         target, self.event_type,",
            "                                         **audit_kwargs)",
            "                raise",
            "            else:",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_SUCCESS,",
            "                                         target, self.event_type,",
            "                                         **audit_kwargs)",
            "                return result",
            "",
            "        return wrapper",
            "",
            "",
            "def send_saml_audit_notification(action, user_id, group_ids,",
            "                                 identity_provider, protocol, token_id,",
            "                                 outcome):",
            "    \"\"\"Send notification to inform observers about SAML events.",
            "",
            "    :param action: Action being audited",
            "    :type action: str",
            "    :param user_id: User ID from Keystone token",
            "    :type user_id: str",
            "    :param group_ids: List of Group IDs from Keystone token",
            "    :type group_ids: list",
            "    :param identity_provider: ID of the IdP from the Keystone token",
            "    :type identity_provider: str or None",
            "    :param protocol: Protocol ID for IdP from the Keystone token",
            "    :type protocol: str",
            "    :param token_id: audit_id from Keystone token",
            "    :type token_id: str or None",
            "    :param outcome: One of :class:`pycadf.cadftaxonomy`",
            "    :type outcome: str",
            "    \"\"\"",
            "    initiator = build_audit_initiator()",
            "    target = resource.Resource(typeURI=taxonomy.ACCOUNT_USER)",
            "    audit_type = SAML_AUDIT_TYPE",
            "    user_id = user_id or taxonomy.UNKNOWN",
            "    token_id = token_id or taxonomy.UNKNOWN",
            "    group_ids = group_ids or []",
            "    cred = credential.FederatedCredential(token=token_id, type=audit_type,",
            "                                          identity_provider=identity_provider,",
            "                                          user=user_id, groups=group_ids)",
            "    initiator.credential = cred",
            "    event_type = '%s.%s' % (SERVICE, action)",
            "    _send_audit_notification(action, initiator, outcome, target, event_type)",
            "",
            "",
            "class _CatalogHelperObj(provider_api.ProviderAPIMixin, object):",
            "    \"\"\"A helper object to allow lookups of identity service id.\"\"\"",
            "",
            "",
            "def _send_audit_notification(action, initiator, outcome, target,",
            "                             event_type, reason=None, **kwargs):",
            "    \"\"\"Send CADF notification to inform observers about the affected resource.",
            "",
            "    This method logs an exception when sending the notification fails.",
            "",
            "    :param action: CADF action being audited (e.g., 'authenticate')",
            "    :param initiator: CADF resource representing the initiator",
            "    :param outcome: The CADF outcome (taxonomy.OUTCOME_PENDING,",
            "        taxonomy.OUTCOME_SUCCESS, taxonomy.OUTCOME_FAILURE)",
            "    :param target: CADF resource representing the target",
            "    :param event_type: An OpenStack-ism, typically this is the meter name that",
            "        Ceilometer uses to poll events.",
            "    :param kwargs: Any additional arguments passed in will be added as",
            "        key-value pairs to the CADF event.",
            "    :param reason: Reason for the notification which contains the response",
            "        code and message description",
            "    \"\"\"",
            "    if _check_notification_opt_out(event_type, outcome):",
            "        return",
            "",
            "    global _CATALOG_HELPER_OBJ",
            "    if _CATALOG_HELPER_OBJ is None:",
            "        _CATALOG_HELPER_OBJ = _CatalogHelperObj()",
            "    service_list = _CATALOG_HELPER_OBJ.catalog_api.list_services()",
            "    service_id = None",
            "",
            "    for i in service_list:",
            "        if i['type'] == SERVICE:",
            "            service_id = i['id']",
            "            break",
            "",
            "    initiator = _add_username_to_initiator(initiator)",
            "",
            "    event = eventfactory.EventFactory().new_event(",
            "        eventType=cadftype.EVENTTYPE_ACTIVITY,",
            "        outcome=outcome,",
            "        action=action,",
            "        initiator=initiator,",
            "        target=target,",
            "        reason=reason,",
            "        observer=resource.Resource(typeURI=taxonomy.SERVICE_SECURITY))",
            "",
            "    if service_id is not None:",
            "        event.observer.id = service_id",
            "",
            "    for key, value in kwargs.items():",
            "        setattr(event, key, value)",
            "",
            "    context = {}",
            "    payload = event.as_dict()",
            "    notifier = _get_notifier()",
            "",
            "    if notifier:",
            "        try:",
            "            notifier.info(context, event_type, payload)",
            "        except Exception:",
            "            # diaper defense: any exception that occurs while emitting the",
            "            # notification should not interfere with the API request",
            "            LOG.exception(",
            "                'Failed to send %(action)s %(event_type)s notification',",
            "                {'action': action, 'event_type': event_type})",
            "",
            "",
            "def _check_notification_opt_out(event_type, outcome):",
            "    \"\"\"Check if a particular event_type has been opted-out of.",
            "",
            "    This method checks to see if an event should be sent to the messaging",
            "    service. Any event specified in the opt-out list will not be transmitted.",
            "",
            "    :param event_type: This is the meter name that Ceilometer uses to poll",
            "        events. For example: identity.user.created, or",
            "        identity.authenticate.success, or identity.role_assignment.created",
            "    :param outcome: The CADF outcome (taxonomy.OUTCOME_PENDING,",
            "        taxonomy.OUTCOME_SUCCESS, taxonomy.OUTCOME_FAILURE)",
            "",
            "    \"\"\"",
            "    # NOTE(stevemar): Special handling for authenticate, we look at the outcome",
            "    # as well when evaluating. For authN events, event_type is just",
            "    # identity.authenticate, which isn't fine enough to provide any opt-out",
            "    # value, so we attach the outcome to re-create the meter name used in",
            "    # ceilometer.",
            "    if 'authenticate' in event_type:",
            "        event_type = event_type + \".\" + outcome",
            "",
            "    if event_type in CONF.notification_opt_out:",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def _add_username_to_initiator(initiator):",
            "    \"\"\"Add the username to the initiator if missing.\"\"\"",
            "    if hasattr(initiator, 'username'):",
            "        return initiator",
            "    try:",
            "        user_ref = PROVIDERS.identity_api.get_user(initiator.user_id)",
            "        initiator.username = user_ref['name']",
            "    except (exception.UserNotFound, AttributeError):",
            "        # Either user not found or no user_id, move along",
            "        pass",
            "",
            "    return initiator",
            "",
            "emit_event = CadfNotificationWrapper",
            "",
            "",
            "role_assignment = CadfRoleAssignmentNotificationWrapper"
        ],
        "afterPatchFile": [
            "# Copyright 2013 IBM Corp.",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "",
            "\"\"\"Notifications module for OpenStack Identity Service resources.\"\"\"",
            "",
            "import collections",
            "import functools",
            "import inspect",
            "import socket",
            "",
            "import flask",
            "from oslo_log import log",
            "import oslo_messaging",
            "from oslo_utils import reflection",
            "import pycadf",
            "from pycadf import cadftaxonomy as taxonomy",
            "from pycadf import cadftype",
            "from pycadf import credential",
            "from pycadf import eventfactory",
            "from pycadf import host",
            "from pycadf import reason",
            "from pycadf import resource",
            "",
            "from keystone.common import context",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "import keystone.conf",
            "from keystone import exception",
            "from keystone.i18n import _",
            "",
            "",
            "_CATALOG_HELPER_OBJ = None",
            "",
            "LOG = log.getLogger(__name__)",
            "# NOTE(gyee): actions that can be notified. One must update this list whenever",
            "# a new action is supported.",
            "_ACTIONS = collections.namedtuple(",
            "    'NotificationActions',",
            "    'created, deleted, disabled, updated, internal')",
            "ACTIONS = _ACTIONS(created='created', deleted='deleted', disabled='disabled',",
            "                   updated='updated', internal='internal')",
            "\"\"\"The actions on resources.\"\"\"",
            "",
            "CADF_TYPE_MAP = {",
            "    'group': taxonomy.SECURITY_GROUP,",
            "    'project': taxonomy.SECURITY_PROJECT,",
            "    'role': taxonomy.SECURITY_ROLE,",
            "    'user': taxonomy.SECURITY_ACCOUNT_USER,",
            "    'domain': taxonomy.SECURITY_DOMAIN,",
            "    'region': taxonomy.SECURITY_REGION,",
            "    'endpoint': taxonomy.SECURITY_ENDPOINT,",
            "    'service': taxonomy.SECURITY_SERVICE,",
            "    'policy': taxonomy.SECURITY_POLICY,",
            "    'OS-TRUST:trust': taxonomy.SECURITY_TRUST,",
            "    'OS-OAUTH1:access_token': taxonomy.SECURITY_CREDENTIAL,",
            "    'OS-OAUTH1:request_token': taxonomy.SECURITY_CREDENTIAL,",
            "    'OS-OAUTH1:consumer': taxonomy.SECURITY_ACCOUNT,",
            "    'application_credential': taxonomy.SECURITY_CREDENTIAL,",
            "}",
            "",
            "SAML_AUDIT_TYPE = 'http://docs.oasis-open.org/security/saml/v2.0'",
            "# resource types that can be notified",
            "_SUBSCRIBERS = {}",
            "_notifier = None",
            "SERVICE = 'identity'",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "ROOT_DOMAIN = '<<keystone.domain.root>>'",
            "",
            "CONF = keystone.conf.CONF",
            "",
            "# NOTE(morganfainberg): Special case notifications that are only used",
            "# internally for handling token persistence token deletions",
            "INVALIDATE_TOKEN_CACHE = 'invalidate_token_cache'  # nosec",
            "PERSIST_REVOCATION_EVENT_FOR_USER = 'persist_revocation_event_for_user'",
            "REMOVE_APP_CREDS_FOR_USER = 'remove_application_credentials_for_user'",
            "DOMAIN_DELETED = 'domain_deleted'",
            "",
            "",
            "def build_audit_initiator():",
            "    \"\"\"A pyCADF initiator describing the current authenticated context.\"\"\"",
            "    pycadf_host = host.Host(address=flask.request.remote_addr,",
            "                            agent=str(flask.request.user_agent))",
            "    initiator = resource.Resource(typeURI=taxonomy.ACCOUNT_USER,",
            "                                  host=pycadf_host)",
            "    oslo_context = flask.request.environ.get(context.REQUEST_CONTEXT_ENV)",
            "    if oslo_context.user_id:",
            "        initiator.id = utils.resource_uuid(oslo_context.user_id)",
            "        initiator.user_id = oslo_context.user_id",
            "",
            "    if oslo_context.project_id:",
            "        initiator.project_id = oslo_context.project_id",
            "",
            "    if oslo_context.domain_id:",
            "        initiator.domain_id = oslo_context.domain_id",
            "",
            "    initiator.request_id = oslo_context.request_id",
            "",
            "    if oslo_context.global_request_id:",
            "        initiator.global_request_id = oslo_context.global_request_id",
            "",
            "    return initiator",
            "",
            "",
            "class Audit(object):",
            "    \"\"\"Namespace for audit notification functions.",
            "",
            "    This is a namespace object to contain all of the direct notification",
            "    functions utilized for ``Manager`` methods.",
            "    \"\"\"",
            "",
            "    @classmethod",
            "    def _emit(cls, operation, resource_type, resource_id, initiator, public,",
            "              actor_dict=None, reason=None):",
            "        \"\"\"Directly send an event notification.",
            "",
            "        :param operation: one of the values from ACTIONS",
            "        :param resource_type: type of resource being affected",
            "        :param resource_id: ID of the resource affected",
            "        :param initiator: CADF representation of the user that created the",
            "                          request",
            "        :param public: If True (default), the event will be sent to the",
            "                       notifier API.  If False, the event will only be sent via",
            "                       notify_event_callbacks to in process listeners",
            "        :param actor_dict: dictionary of actor information in the event of",
            "                           assignment notification",
            "        :param reason: pycadf object containing the response code and",
            "                       message description",
            "        \"\"\"",
            "        # NOTE(stevemar): the _send_notification function is",
            "        # overloaded, it's used to register callbacks and to actually",
            "        # send the notification externally. Thus, we should check",
            "        # the desired notification format in the function instead",
            "        # of before it.",
            "        _send_notification(",
            "            operation,",
            "            resource_type,",
            "            resource_id,",
            "            initiator=initiator,",
            "            actor_dict=actor_dict,",
            "            public=public)",
            "",
            "        if CONF.notification_format == 'cadf' and public:",
            "            outcome = taxonomy.OUTCOME_SUCCESS",
            "            _create_cadf_payload(operation, resource_type, resource_id,",
            "                                 outcome, initiator, reason)",
            "",
            "    @classmethod",
            "    def created(cls, resource_type, resource_id, initiator=None,",
            "                public=True, reason=None):",
            "        cls._emit(ACTIONS.created, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def updated(cls, resource_type, resource_id, initiator=None,",
            "                public=True, reason=None):",
            "        cls._emit(ACTIONS.updated, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def disabled(cls, resource_type, resource_id, initiator=None,",
            "                 public=True, reason=None):",
            "        cls._emit(ACTIONS.disabled, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def deleted(cls, resource_type, resource_id, initiator=None,",
            "                public=True, reason=None):",
            "        cls._emit(ACTIONS.deleted, resource_type, resource_id, initiator,",
            "                  public, reason=reason)",
            "",
            "    @classmethod",
            "    def added_to(cls, target_type, target_id, actor_type, actor_id,",
            "                 initiator=None, public=True, reason=None):",
            "        actor_dict = {'id': actor_id,",
            "                      'type': actor_type,",
            "                      'actor_operation': 'added'}",
            "        cls._emit(ACTIONS.updated, target_type, target_id, initiator, public,",
            "                  actor_dict=actor_dict, reason=reason)",
            "",
            "    @classmethod",
            "    def removed_from(cls, target_type, target_id, actor_type, actor_id,",
            "                     initiator=None, public=True, reason=None):",
            "        actor_dict = {'id': actor_id,",
            "                      'type': actor_type,",
            "                      'actor_operation': 'removed'}",
            "        cls._emit(ACTIONS.updated, target_type, target_id, initiator, public,",
            "                  actor_dict=actor_dict, reason=reason)",
            "",
            "    @classmethod",
            "    def internal(cls, resource_type, resource_id, reason=None):",
            "        # NOTE(lbragstad): Internal notifications are never public and have",
            "        # never used the initiator variable, but the _emit() method expects",
            "        # them. Let's set them here but not expose them through the method",
            "        # signature - that way someone can not do something like send an",
            "        # internal notification publicly.",
            "        initiator = None",
            "        public = False",
            "        cls._emit(ACTIONS.internal, resource_type, resource_id, initiator,",
            "                  public, reason)",
            "",
            "",
            "def invalidate_token_cache_notification(reason):",
            "    \"\"\"A specific notification for invalidating the token cache.",
            "",
            "    :param reason: The specific reason why the token cache is being",
            "                   invalidated.",
            "    :type reason: string",
            "",
            "    \"\"\"",
            "    # Since keystone does a lot of work in the authentication and validation",
            "    # process to make sure the authorization context for the user is",
            "    # update-to-date, invalidating the token cache is a somewhat common",
            "    # operation. It's done across various subsystems when role assignments",
            "    # change, users are disabled, identity providers deleted or disabled, etc..",
            "    # This notification is meant to make the process of invalidating the token",
            "    # cache DRY, instead of have each subsystem implement their own token cache",
            "    # invalidation strategy or callbacks.",
            "    LOG.debug(reason)",
            "    resource_id = None",
            "    initiator = None",
            "    public = False",
            "    Audit._emit(",
            "        ACTIONS.internal, INVALIDATE_TOKEN_CACHE, resource_id, initiator,",
            "        public, reason=reason",
            "    )",
            "",
            "",
            "def _get_callback_info(callback):",
            "    \"\"\"Return list containing callback's module and name.",
            "",
            "    If the callback is a bound instance method also return the class name.",
            "",
            "    :param callback: Function to call",
            "    :type callback: function",
            "    :returns: List containing parent module, (optional class,) function name",
            "    :rtype: list",
            "    \"\"\"",
            "    module_name = getattr(callback, '__module__', None)",
            "    func_name = callback.__name__",
            "    if inspect.ismethod(callback):",
            "        class_name = reflection.get_class_name(callback.__self__,",
            "                                               fully_qualified=False)",
            "        return [module_name, class_name, func_name]",
            "    else:",
            "        return [module_name, func_name]",
            "",
            "",
            "def register_event_callback(event, resource_type, callbacks):",
            "    \"\"\"Register each callback with the event.",
            "",
            "    :param event: Action being registered",
            "    :type event: keystone.notifications.ACTIONS",
            "    :param resource_type: Type of resource being operated on",
            "    :type resource_type: str",
            "    :param callbacks: Callback items to be registered with event",
            "    :type callbacks: list",
            "    :raises ValueError: If event is not a valid ACTION",
            "    :raises TypeError: If callback is not callable",
            "    \"\"\"",
            "    if event not in ACTIONS:",
            "        raise ValueError(_('%(event)s is not a valid notification event, must '",
            "                           'be one of: %(actions)s') %",
            "                         {'event': event, 'actions': ', '.join(ACTIONS)})",
            "",
            "    if not hasattr(callbacks, '__iter__'):",
            "        callbacks = [callbacks]",
            "",
            "    for callback in callbacks:",
            "        if not callable(callback):",
            "            msg = 'Method not callable: %s' % callback",
            "            tr_msg = _('Method not callable: %s') % callback",
            "            LOG.error(msg)",
            "            raise TypeError(tr_msg)",
            "        _SUBSCRIBERS.setdefault(event, {}).setdefault(resource_type, set())",
            "        _SUBSCRIBERS[event][resource_type].add(callback)",
            "",
            "        if LOG.logger.getEffectiveLevel() <= log.DEBUG:",
            "            # Do this only if its going to appear in the logs.",
            "            msg = 'Callback: `%(callback)s` subscribed to event `%(event)s`.'",
            "            callback_info = _get_callback_info(callback)",
            "            callback_str = '.'.join(i for i in callback_info if i is not None)",
            "            event_str = '.'.join(['identity', resource_type, event])",
            "            LOG.debug(msg, {'callback': callback_str, 'event': event_str})",
            "",
            "",
            "def listener(cls):",
            "    \"\"\"A class decorator to declare a class to be a notification listener.",
            "",
            "    A notification listener must specify the event(s) it is interested in by",
            "    defining a ``event_callbacks`` attribute or property. ``event_callbacks``",
            "    is a dictionary where the key is the type of event and the value is a",
            "    dictionary containing a mapping of resource types to callback(s).",
            "",
            "    :data:`.ACTIONS` contains constants for the currently",
            "    supported events. There is currently no single place to find constants for",
            "    the resource types.",
            "",
            "    Example::",
            "",
            "        @listener",
            "        class Something(object):",
            "",
            "            def __init__(self):",
            "                self.event_callbacks = {",
            "                    notifications.ACTIONS.created: {",
            "                        'user': self._user_created_callback,",
            "                    },",
            "                    notifications.ACTIONS.deleted: {",
            "                        'project': [",
            "                            self._project_deleted_callback,",
            "                            self._do_cleanup,",
            "                        ]",
            "                    },",
            "                }",
            "",
            "    \"\"\"",
            "    def init_wrapper(init):",
            "        @functools.wraps(init)",
            "        def __new_init__(self, *args, **kwargs):",
            "            init(self, *args, **kwargs)",
            "            _register_event_callbacks(self)",
            "        return __new_init__",
            "",
            "    def _register_event_callbacks(self):",
            "        for event, resource_types in self.event_callbacks.items():",
            "            for resource_type, callbacks in resource_types.items():",
            "                register_event_callback(event, resource_type, callbacks)",
            "",
            "    cls.__init__ = init_wrapper(cls.__init__)",
            "    return cls",
            "",
            "",
            "def notify_event_callbacks(service, resource_type, operation, payload):",
            "    \"\"\"Send a notification to registered extensions.\"\"\"",
            "    if operation in _SUBSCRIBERS:",
            "        if resource_type in _SUBSCRIBERS[operation]:",
            "            for cb in _SUBSCRIBERS[operation][resource_type]:",
            "                subst_dict = {'cb_name': cb.__name__,",
            "                              'service': service,",
            "                              'resource_type': resource_type,",
            "                              'operation': operation,",
            "                              'payload': payload}",
            "                LOG.debug('Invoking callback %(cb_name)s for event '",
            "                          '%(service)s %(resource_type)s %(operation)s for '",
            "                          '%(payload)s', subst_dict)",
            "                cb(service, resource_type, operation, payload)",
            "",
            "",
            "def _get_notifier():",
            "    \"\"\"Return a notifier object.",
            "",
            "    If _notifier is None it means that a notifier object has not been set.",
            "    If _notifier is False it means that a notifier has previously failed to",
            "    construct.",
            "    Otherwise it is a constructed Notifier object.",
            "    \"\"\"",
            "    global _notifier",
            "",
            "    if _notifier is None:",
            "        host = CONF.default_publisher_id or socket.gethostname()",
            "        try:",
            "            transport = oslo_messaging.get_notification_transport(CONF)",
            "            _notifier = oslo_messaging.Notifier(transport,",
            "                                                \"identity.%s\" % host)",
            "        except Exception:",
            "            LOG.exception(\"Failed to construct notifier\")",
            "            _notifier = False",
            "",
            "    return _notifier",
            "",
            "",
            "def clear_subscribers():",
            "    \"\"\"Empty subscribers dictionary.",
            "",
            "    This effectively stops notifications since there will be no subscribers",
            "    to publish to.",
            "    \"\"\"",
            "    _SUBSCRIBERS.clear()",
            "",
            "",
            "def reset_notifier():",
            "    \"\"\"Reset the notifications internal state.",
            "",
            "    This is used only for testing purposes.",
            "",
            "    \"\"\"",
            "    global _notifier",
            "    _notifier = None",
            "",
            "",
            "def _create_cadf_payload(operation, resource_type, resource_id,",
            "                         outcome, initiator, reason=None):",
            "    \"\"\"Prepare data for CADF audit notifier.",
            "",
            "    Transform the arguments into content to be consumed by the function that",
            "    emits CADF events (_send_audit_notification). Specifically the",
            "    ``resource_type`` (role, user, etc) must be transformed into a CADF",
            "    keyword, such as: ``data/security/role``. The ``resource_id`` is added as a",
            "    top level value for the ``resource_info`` key. Lastly, the ``operation`` is",
            "    used to create the CADF ``action``, and the ``event_type`` name.",
            "",
            "    As per the CADF specification, the ``action`` must start with create,",
            "    update, delete, etc... i.e.: created.user or deleted.role",
            "",
            "    However the ``event_type`` is an OpenStack-ism that is typically of the",
            "    form project.resource.operation. i.e.: identity.project.updated",
            "",
            "    :param operation: operation being performed (created, updated, or deleted)",
            "    :param resource_type: type of resource being operated on (role, user, etc)",
            "    :param resource_id: ID of resource being operated on",
            "    :param outcome: outcomes of the operation (SUCCESS, FAILURE, etc)",
            "    :param initiator: CADF representation of the user that created the request",
            "    :param reason: pycadf object containing the response code and",
            "                   message description",
            "    \"\"\"",
            "    if resource_type not in CADF_TYPE_MAP:",
            "        target_uri = taxonomy.UNKNOWN",
            "    else:",
            "        target_uri = CADF_TYPE_MAP.get(resource_type)",
            "",
            "    # TODO(gagehugo): The root domain ID is typically hidden, there isn't a",
            "    # reason to emit a notification for it. Once we expose the root domain",
            "    # (and handle the CADF UUID), remove this.",
            "    if resource_id == ROOT_DOMAIN:",
            "        return",
            "",
            "    target = resource.Resource(typeURI=target_uri,",
            "                               id=resource_id)",
            "",
            "    audit_kwargs = {'resource_info': resource_id}",
            "    cadf_action = '%s.%s' % (operation, resource_type)",
            "    event_type = '%s.%s.%s' % (SERVICE, resource_type, operation)",
            "",
            "    _send_audit_notification(cadf_action, initiator, outcome,",
            "                             target, event_type, reason=reason, **audit_kwargs)",
            "",
            "",
            "def _send_notification(operation, resource_type, resource_id, initiator=None,",
            "                       actor_dict=None, public=True):",
            "    \"\"\"Send notification to inform observers about the affected resource.",
            "",
            "    This method doesn't raise an exception when sending the notification fails.",
            "",
            "    :param operation: operation being performed (created, updated, or deleted)",
            "    :param resource_type: type of resource being operated on",
            "    :param resource_id: ID of resource being operated on",
            "    :param initiator: representation of the user that created the request",
            "    :param actor_dict: a dictionary containing the actor's ID and type",
            "    :param public:  if True (default), the event will be sent",
            "                    to the notifier API.",
            "                    if False, the event will only be sent via",
            "                    notify_event_callbacks to in process listeners.",
            "    \"\"\"",
            "    payload = {'resource_info': resource_id}",
            "",
            "    if actor_dict:",
            "        payload['actor_id'] = actor_dict['id']",
            "        payload['actor_type'] = actor_dict['type']",
            "        payload['actor_operation'] = actor_dict['actor_operation']",
            "",
            "    if initiator:",
            "        payload['request_id'] = initiator.request_id",
            "        global_request_id = getattr(initiator, 'global_request_id', None)",
            "        if global_request_id:",
            "            payload['global_request_id'] = global_request_id",
            "",
            "    notify_event_callbacks(SERVICE, resource_type, operation, payload)",
            "",
            "    # Only send this notification if the 'basic' format is used, otherwise",
            "    # let the CADF functions handle sending the notification. But we check",
            "    # here so as to not disrupt the notify_event_callbacks function.",
            "    if public and CONF.notification_format == 'basic':",
            "        notifier = _get_notifier()",
            "        if notifier:",
            "            context = {}",
            "            event_type = '%(service)s.%(resource_type)s.%(operation)s' % {",
            "                'service': SERVICE,",
            "                'resource_type': resource_type,",
            "                'operation': operation}",
            "            if _check_notification_opt_out(event_type, outcome=None):",
            "                return",
            "            try:",
            "                notifier.info(context, event_type, payload)",
            "            except Exception:",
            "                LOG.exception(",
            "                    'Failed to send %(res_id)s %(event_type)s notification',",
            "                    {'res_id': resource_id, 'event_type': event_type})",
            "",
            "",
            "def _get_request_audit_info(context, user_id=None):",
            "    \"\"\"Collect audit information about the request used for CADF.",
            "",
            "    :param context: Request context",
            "    :param user_id: Optional user ID, alternatively collected from context",
            "    :returns: Auditing data about the request",
            "    :rtype: :class:`pycadf.Resource`",
            "    \"\"\"",
            "    remote_addr = None",
            "    http_user_agent = None",
            "    project_id = None",
            "    domain_id = None",
            "",
            "    if context and 'environment' in context and context['environment']:",
            "        environment = context['environment']",
            "        remote_addr = environment.get('REMOTE_ADDR')",
            "        http_user_agent = environment.get('HTTP_USER_AGENT')",
            "        if not user_id:",
            "            user_id = environment.get('KEYSTONE_AUTH_CONTEXT',",
            "                                      {}).get('user_id')",
            "        project_id = environment.get('KEYSTONE_AUTH_CONTEXT',",
            "                                     {}).get('project_id')",
            "        domain_id = environment.get('KEYSTONE_AUTH_CONTEXT',",
            "                                    {}).get('domain_id')",
            "",
            "    host = pycadf.host.Host(address=remote_addr, agent=http_user_agent)",
            "    initiator = resource.Resource(typeURI=taxonomy.ACCOUNT_USER, host=host)",
            "",
            "    if user_id:",
            "        initiator.user_id = user_id",
            "        initiator.id = utils.resource_uuid(user_id)",
            "        initiator = _add_username_to_initiator(initiator)",
            "",
            "    if project_id:",
            "        initiator.project_id = project_id",
            "    if domain_id:",
            "        initiator.domain_id = domain_id",
            "",
            "    return initiator",
            "",
            "",
            "class CadfNotificationWrapper(object):",
            "    \"\"\"Send CADF event notifications for various methods.",
            "",
            "    This function is only used for Authentication events. Its ``action`` and",
            "    ``event_type`` are dictated below.",
            "",
            "    - action: ``authenticate``",
            "    - event_type: ``identity.authenticate``",
            "",
            "    Sends CADF notifications for events such as whether an authentication was",
            "    successful or not.",
            "",
            "    :param operation: The authentication related action being performed",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, operation):",
            "        self.action = operation",
            "        self.event_type = '%s.%s' % (SERVICE, operation)",
            "",
            "    def __call__(self, f):",
            "        @functools.wraps(f)",
            "        def wrapper(wrapped_self, user_id, *args, **kwargs):",
            "            \"\"\"Will always send a notification.\"\"\"",
            "            target = resource.Resource(typeURI=taxonomy.ACCOUNT_USER)",
            "            initiator = build_audit_initiator()",
            "            initiator.user_id = user_id",
            "            initiator = _add_username_to_initiator(initiator)",
            "            initiator.id = utils.resource_uuid(user_id)",
            "            try:",
            "                result = f(wrapped_self, user_id, *args, **kwargs)",
            "            except (exception.AccountLocked,",
            "                    exception.PasswordExpired) as ex:",
            "                # Send a CADF event with a reason for PCI-DSS related",
            "                # authentication failures",
            "                audit_reason = reason.Reason(str(ex), str(ex.code))",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_FAILURE,",
            "                                         target, self.event_type,",
            "                                         reason=audit_reason)",
            "                if isinstance(ex, exception.AccountLocked):",
            "                    raise exception.Unauthorized",
            "                raise",
            "            except Exception:",
            "                # For authentication failure send a CADF event as well",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_FAILURE,",
            "                                         target, self.event_type)",
            "                raise",
            "            else:",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_SUCCESS,",
            "                                         target, self.event_type)",
            "                return result",
            "",
            "        return wrapper",
            "",
            "",
            "class CadfRoleAssignmentNotificationWrapper(object):",
            "    \"\"\"Send CADF notifications for ``role_assignment`` methods.",
            "",
            "    This function is only used for role assignment events. Its ``action`` and",
            "    ``event_type`` are dictated below.",
            "",
            "    - action: ``created.role_assignment`` or ``deleted.role_assignment``",
            "    - event_type: ``identity.role_assignment.created`` or",
            "        ``identity.role_assignment.deleted``",
            "",
            "    Sends a CADF notification if the wrapped method does not raise an",
            "    :class:`Exception` (such as :class:`keystone.exception.NotFound`).",
            "",
            "    :param operation: one of the values from ACTIONS (created or deleted)",
            "    \"\"\"",
            "",
            "    ROLE_ASSIGNMENT = 'role_assignment'",
            "",
            "    def __init__(self, operation):",
            "        self.action = '%s.%s' % (operation, self.ROLE_ASSIGNMENT)",
            "        self.event_type = '%s.%s.%s' % (SERVICE, self.ROLE_ASSIGNMENT,",
            "                                        operation)",
            "",
            "    def __call__(self, f):",
            "        @functools.wraps(f)",
            "        def wrapper(wrapped_self, role_id, *args, **kwargs):",
            "            \"\"\"Send a notification if the wrapped callable is successful.",
            "",
            "            NOTE(stevemar): The reason we go through checking kwargs",
            "            and args for possible target and actor values is because the",
            "            create_grant() (and delete_grant()) method are called",
            "            differently in various tests.",
            "            Using named arguments, i.e.::",
            "",
            "                create_grant(user_id=user['id'], domain_id=domain['id'],",
            "                             role_id=role['id'])",
            "",
            "            Or, using positional arguments, i.e.::",
            "",
            "                create_grant(role_id['id'], user['id'], None,",
            "                             domain_id=domain['id'], None)",
            "",
            "            Or, both, i.e.::",
            "",
            "                create_grant(role_id['id'], user_id=user['id'],",
            "                             domain_id=domain['id'])",
            "",
            "            Checking the values for kwargs is easy enough, since it comes",
            "            in as a dictionary",
            "",
            "            The actual method signature is",
            "",
            "            ::",
            "",
            "                create_grant(role_id, user_id=None, group_id=None,",
            "                             domain_id=None, project_id=None,",
            "                             inherited_to_projects=False)",
            "",
            "            So, if the values of actor or target are still None after",
            "            checking kwargs, we can check the positional arguments,",
            "            based on the method signature.",
            "            \"\"\"",
            "            call_args = inspect.getcallargs(",
            "                f, wrapped_self, role_id, *args, **kwargs)",
            "            inherited = call_args['inherited_to_projects']",
            "            initiator = call_args.get('initiator', None)",
            "            target = resource.Resource(typeURI=taxonomy.ACCOUNT_USER)",
            "",
            "            audit_kwargs = {}",
            "            if call_args['project_id']:",
            "                audit_kwargs['project'] = call_args['project_id']",
            "            elif call_args['domain_id']:",
            "                audit_kwargs['domain'] = call_args['domain_id']",
            "",
            "            if call_args['user_id']:",
            "                audit_kwargs['user'] = call_args['user_id']",
            "            elif call_args['group_id']:",
            "                audit_kwargs['group'] = call_args['group_id']",
            "",
            "            audit_kwargs['inherited_to_projects'] = inherited",
            "            audit_kwargs['role'] = role_id",
            "",
            "            try:",
            "                result = f(wrapped_self, role_id, *args, **kwargs)",
            "            except Exception:",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_FAILURE,",
            "                                         target, self.event_type,",
            "                                         **audit_kwargs)",
            "                raise",
            "            else:",
            "                _send_audit_notification(self.action, initiator,",
            "                                         taxonomy.OUTCOME_SUCCESS,",
            "                                         target, self.event_type,",
            "                                         **audit_kwargs)",
            "                return result",
            "",
            "        return wrapper",
            "",
            "",
            "def send_saml_audit_notification(action, user_id, group_ids,",
            "                                 identity_provider, protocol, token_id,",
            "                                 outcome):",
            "    \"\"\"Send notification to inform observers about SAML events.",
            "",
            "    :param action: Action being audited",
            "    :type action: str",
            "    :param user_id: User ID from Keystone token",
            "    :type user_id: str",
            "    :param group_ids: List of Group IDs from Keystone token",
            "    :type group_ids: list",
            "    :param identity_provider: ID of the IdP from the Keystone token",
            "    :type identity_provider: str or None",
            "    :param protocol: Protocol ID for IdP from the Keystone token",
            "    :type protocol: str",
            "    :param token_id: audit_id from Keystone token",
            "    :type token_id: str or None",
            "    :param outcome: One of :class:`pycadf.cadftaxonomy`",
            "    :type outcome: str",
            "    \"\"\"",
            "    initiator = build_audit_initiator()",
            "    target = resource.Resource(typeURI=taxonomy.ACCOUNT_USER)",
            "    audit_type = SAML_AUDIT_TYPE",
            "    user_id = user_id or taxonomy.UNKNOWN",
            "    token_id = token_id or taxonomy.UNKNOWN",
            "    group_ids = group_ids or []",
            "    cred = credential.FederatedCredential(token=token_id, type=audit_type,",
            "                                          identity_provider=identity_provider,",
            "                                          user=user_id, groups=group_ids)",
            "    initiator.credential = cred",
            "    event_type = '%s.%s' % (SERVICE, action)",
            "    _send_audit_notification(action, initiator, outcome, target, event_type)",
            "",
            "",
            "class _CatalogHelperObj(provider_api.ProviderAPIMixin, object):",
            "    \"\"\"A helper object to allow lookups of identity service id.\"\"\"",
            "",
            "",
            "def _send_audit_notification(action, initiator, outcome, target,",
            "                             event_type, reason=None, **kwargs):",
            "    \"\"\"Send CADF notification to inform observers about the affected resource.",
            "",
            "    This method logs an exception when sending the notification fails.",
            "",
            "    :param action: CADF action being audited (e.g., 'authenticate')",
            "    :param initiator: CADF resource representing the initiator",
            "    :param outcome: The CADF outcome (taxonomy.OUTCOME_PENDING,",
            "        taxonomy.OUTCOME_SUCCESS, taxonomy.OUTCOME_FAILURE)",
            "    :param target: CADF resource representing the target",
            "    :param event_type: An OpenStack-ism, typically this is the meter name that",
            "        Ceilometer uses to poll events.",
            "    :param kwargs: Any additional arguments passed in will be added as",
            "        key-value pairs to the CADF event.",
            "    :param reason: Reason for the notification which contains the response",
            "        code and message description",
            "    \"\"\"",
            "    if _check_notification_opt_out(event_type, outcome):",
            "        return",
            "",
            "    global _CATALOG_HELPER_OBJ",
            "    if _CATALOG_HELPER_OBJ is None:",
            "        _CATALOG_HELPER_OBJ = _CatalogHelperObj()",
            "    service_list = _CATALOG_HELPER_OBJ.catalog_api.list_services()",
            "    service_id = None",
            "",
            "    for i in service_list:",
            "        if i['type'] == SERVICE:",
            "            service_id = i['id']",
            "            break",
            "",
            "    initiator = _add_username_to_initiator(initiator)",
            "",
            "    event = eventfactory.EventFactory().new_event(",
            "        eventType=cadftype.EVENTTYPE_ACTIVITY,",
            "        outcome=outcome,",
            "        action=action,",
            "        initiator=initiator,",
            "        target=target,",
            "        reason=reason,",
            "        observer=resource.Resource(typeURI=taxonomy.SERVICE_SECURITY))",
            "",
            "    if service_id is not None:",
            "        event.observer.id = service_id",
            "",
            "    for key, value in kwargs.items():",
            "        setattr(event, key, value)",
            "",
            "    context = {}",
            "    payload = event.as_dict()",
            "    notifier = _get_notifier()",
            "",
            "    if notifier:",
            "        try:",
            "            notifier.info(context, event_type, payload)",
            "        except Exception:",
            "            # diaper defense: any exception that occurs while emitting the",
            "            # notification should not interfere with the API request",
            "            LOG.exception(",
            "                'Failed to send %(action)s %(event_type)s notification',",
            "                {'action': action, 'event_type': event_type})",
            "",
            "",
            "def _check_notification_opt_out(event_type, outcome):",
            "    \"\"\"Check if a particular event_type has been opted-out of.",
            "",
            "    This method checks to see if an event should be sent to the messaging",
            "    service. Any event specified in the opt-out list will not be transmitted.",
            "",
            "    :param event_type: This is the meter name that Ceilometer uses to poll",
            "        events. For example: identity.user.created, or",
            "        identity.authenticate.success, or identity.role_assignment.created",
            "    :param outcome: The CADF outcome (taxonomy.OUTCOME_PENDING,",
            "        taxonomy.OUTCOME_SUCCESS, taxonomy.OUTCOME_FAILURE)",
            "",
            "    \"\"\"",
            "    # NOTE(stevemar): Special handling for authenticate, we look at the outcome",
            "    # as well when evaluating. For authN events, event_type is just",
            "    # identity.authenticate, which isn't fine enough to provide any opt-out",
            "    # value, so we attach the outcome to re-create the meter name used in",
            "    # ceilometer.",
            "    if 'authenticate' in event_type:",
            "        event_type = event_type + \".\" + outcome",
            "",
            "    if event_type in CONF.notification_opt_out:",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def _add_username_to_initiator(initiator):",
            "    \"\"\"Add the username to the initiator if missing.\"\"\"",
            "    if hasattr(initiator, 'username'):",
            "        return initiator",
            "    try:",
            "        user_ref = PROVIDERS.identity_api.get_user(initiator.user_id)",
            "        initiator.username = user_ref['name']",
            "    except (exception.UserNotFound, AttributeError):",
            "        # Either user not found or no user_id, move along",
            "        pass",
            "",
            "    return initiator",
            "",
            "emit_event = CadfNotificationWrapper",
            "",
            "",
            "role_assignment = CadfRoleAssignmentNotificationWrapper"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "keystone.notifications.CadfNotificationWrapper.__call__"
        ]
    },
    "keystone/tests/unit/common/test_notifications.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": 802,
                "PatchRowcode": "         password = uuid.uuid4().hex"
            },
            "1": {
                "beforePatchRowNumber": 803,
                "afterPatchRowNumber": 803,
                "PatchRowcode": "         new_password = uuid.uuid4().hex"
            },
            "2": {
                "beforePatchRowNumber": 804,
                "afterPatchRowNumber": 804,
                "PatchRowcode": "         expected_responses = [AssertionError, AssertionError, AssertionError,"
            },
            "3": {
                "beforePatchRowNumber": 805,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                              exception.AccountLocked]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 805,
                "PatchRowcode": "+                              exception.Unauthorized]"
            },
            "5": {
                "beforePatchRowNumber": 806,
                "afterPatchRowNumber": 806,
                "PatchRowcode": "         user_ref = unit.new_user_ref(domain_id=self.domain_id,"
            },
            "6": {
                "beforePatchRowNumber": 807,
                "afterPatchRowNumber": 807,
                "PatchRowcode": "                                      password=password)"
            },
            "7": {
                "beforePatchRowNumber": 808,
                "afterPatchRowNumber": 808,
                "PatchRowcode": "         user_ref = PROVIDERS.identity_api.create_user(user_ref)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2013 IBM Corp.",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "",
            "import datetime",
            "import uuid",
            "",
            "import fixtures",
            "import freezegun",
            "import mock",
            "from oslo_config import fixture as config_fixture",
            "from oslo_log import log",
            "import oslo_messaging",
            "from pycadf import cadftaxonomy",
            "from pycadf import cadftype",
            "from pycadf import eventfactory",
            "from pycadf import resource as cadfresource",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "import keystone.conf",
            "from keystone import exception",
            "from keystone import notifications",
            "from keystone.tests import unit",
            "from keystone.tests.unit import test_v3",
            "",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "EXP_RESOURCE_TYPE = uuid.uuid4().hex",
            "CREATED_OPERATION = notifications.ACTIONS.created",
            "UPDATED_OPERATION = notifications.ACTIONS.updated",
            "DELETED_OPERATION = notifications.ACTIONS.deleted",
            "DISABLED_OPERATION = notifications.ACTIONS.disabled",
            "",
            "",
            "class ArbitraryException(Exception):",
            "    pass",
            "",
            "",
            "def register_callback(operation, resource_type=EXP_RESOURCE_TYPE):",
            "    \"\"\"Helper for creating and registering a mock callback.\"\"\"",
            "    callback = mock.Mock(__name__='callback',",
            "                         im_class=mock.Mock(__name__='class'))",
            "    notifications.register_event_callback(operation, resource_type, callback)",
            "    return callback",
            "",
            "",
            "class AuditNotificationsTestCase(unit.BaseTestCase):",
            "    def setUp(self):",
            "        super(AuditNotificationsTestCase, self).setUp()",
            "        self.config_fixture = self.useFixture(config_fixture.Config(CONF))",
            "        self.addCleanup(notifications.clear_subscribers)",
            "",
            "    def _test_notification_operation_with_basic_format(self,",
            "                                                       notify_function,",
            "                                                       operation):",
            "        self.config_fixture.config(notification_format='basic')",
            "        exp_resource_id = uuid.uuid4().hex",
            "        callback = register_callback(operation)",
            "        notify_function(EXP_RESOURCE_TYPE, exp_resource_id)",
            "        callback.assert_called_once_with('identity', EXP_RESOURCE_TYPE,",
            "                                         operation,",
            "                                         {'resource_info': exp_resource_id})",
            "",
            "    def _test_notification_operation_with_cadf_format(self,",
            "                                                      notify_function,",
            "                                                      operation):",
            "        self.config_fixture.config(notification_format='cadf')",
            "        exp_resource_id = uuid.uuid4().hex",
            "        with mock.patch(",
            "                'keystone.notifications._create_cadf_payload') as cadf_notify:",
            "            notify_function(EXP_RESOURCE_TYPE, exp_resource_id)",
            "            initiator = None",
            "            reason = None",
            "            cadf_notify.assert_called_once_with(",
            "                operation, EXP_RESOURCE_TYPE, exp_resource_id,",
            "                notifications.taxonomy.OUTCOME_SUCCESS, initiator, reason)",
            "            notify_function(EXP_RESOURCE_TYPE, exp_resource_id, public=False)",
            "            cadf_notify.assert_called_once_with(",
            "                operation, EXP_RESOURCE_TYPE, exp_resource_id,",
            "                notifications.taxonomy.OUTCOME_SUCCESS, initiator, reason)",
            "",
            "    def test_resource_created_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.created, CREATED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.created, CREATED_OPERATION)",
            "",
            "    def test_resource_updated_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.updated, UPDATED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.updated, UPDATED_OPERATION)",
            "",
            "    def test_resource_deleted_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.deleted, DELETED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.deleted, DELETED_OPERATION)",
            "",
            "    def test_resource_disabled_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.disabled, DISABLED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.disabled, DISABLED_OPERATION)",
            "",
            "",
            "class NotificationsTestCase(unit.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(NotificationsTestCase, self).setUp()",
            "        self.config_fixture = self.useFixture(config_fixture.Config(CONF))",
            "        self.config_fixture.config(",
            "            group='oslo_messaging_notifications', transport_url='rabbit://'",
            "        )",
            "",
            "    def test_send_notification(self):",
            "        \"\"\"Test _send_notification.",
            "",
            "        Test the private method _send_notification to ensure event_type,",
            "        payload, and context are built and passed properly.",
            "",
            "        \"\"\"",
            "        resource = uuid.uuid4().hex",
            "        resource_type = EXP_RESOURCE_TYPE",
            "        operation = CREATED_OPERATION",
            "",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_format='basic')",
            "",
            "        # NOTE(ldbragst): Even though notifications._send_notification doesn't",
            "        # contain logic that creates cases, this is supposed to test that",
            "        # context is always empty and that we ensure the resource ID of the",
            "        # resource in the notification is contained in the payload. It was",
            "        # agreed that context should be empty in Keystone's case, which is",
            "        # also noted in the /keystone/notifications.py module. This test",
            "        # ensures and maintains these conditions.",
            "        expected_args = [",
            "            {},  # empty context",
            "            'identity.%s.created' % resource_type,  # event_type",
            "            {'resource_info': resource}  # payload",
            "        ]",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "            notifications._send_notification(operation, resource_type,",
            "                                             resource)",
            "            mocked.assert_called_once_with(*expected_args)",
            "",
            "    def test_send_notification_with_opt_out(self):",
            "        \"\"\"Test the private method _send_notification with opt-out.",
            "",
            "        Test that _send_notification does not notify when a valid",
            "        notification_opt_out configuration is provided.",
            "        \"\"\"",
            "        resource = uuid.uuid4().hex",
            "        resource_type = EXP_RESOURCE_TYPE",
            "        operation = CREATED_OPERATION",
            "        event_type = 'identity.%s.created' % resource_type",
            "",
            "        # NOTE(diazjf): Here we add notification_opt_out to the",
            "        # configuration so that we should return before _get_notifer is",
            "        # called. This is because we are opting out notifications for the",
            "        # passed resource_type and operation.",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_opt_out=[event_type])",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_notification(operation, resource_type,",
            "                                             resource)",
            "            mocked.assert_not_called()",
            "",
            "    def test_send_audit_notification_with_opt_out(self):",
            "        \"\"\"Test the private method _send_audit_notification with opt-out.",
            "",
            "        Test that _send_audit_notification does not notify when a valid",
            "        notification_opt_out configuration is provided.",
            "        \"\"\"",
            "        resource_type = EXP_RESOURCE_TYPE",
            "",
            "        action = CREATED_OPERATION + '.' + resource_type",
            "        initiator = mock",
            "        target = mock",
            "        outcome = 'success'",
            "        event_type = 'identity.%s.created' % resource_type",
            "",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_opt_out=[event_type])",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_audit_notification(action,",
            "                                                   initiator,",
            "                                                   outcome,",
            "                                                   target,",
            "                                                   event_type)",
            "            mocked.assert_not_called()",
            "",
            "    def test_opt_out_authenticate_event(self):",
            "        \"\"\"Test that authenticate events are successfully opted out.\"\"\"",
            "        resource_type = EXP_RESOURCE_TYPE",
            "",
            "        action = CREATED_OPERATION + '.' + resource_type",
            "        initiator = mock",
            "        target = mock",
            "        outcome = 'success'",
            "        event_type = 'identity.authenticate'",
            "        meter_name = '%s.%s' % (event_type, outcome)",
            "",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_opt_out=[meter_name])",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_audit_notification(action,",
            "                                                   initiator,",
            "                                                   outcome,",
            "                                                   target,",
            "                                                   event_type)",
            "            mocked.assert_not_called()",
            "",
            "",
            "class BaseNotificationTest(test_v3.RestfulTestCase):",
            "",
            "    def setUp(self):",
            "        super(BaseNotificationTest, self).setUp()",
            "",
            "        self._notifications = []",
            "        self._audits = []",
            "",
            "        def fake_notify(operation, resource_type, resource_id, initiator=None,",
            "                        actor_dict=None, public=True):",
            "            note = {",
            "                'resource_id': resource_id,",
            "                'operation': operation,",
            "                'resource_type': resource_type,",
            "                'initiator': initiator,",
            "                'send_notification_called': True,",
            "                'public': public}",
            "            if actor_dict:",
            "                note['actor_id'] = actor_dict.get('id')",
            "                note['actor_type'] = actor_dict.get('type')",
            "                note['actor_operation'] = actor_dict.get('actor_operation')",
            "            self._notifications.append(note)",
            "",
            "        self.useFixture(fixtures.MockPatchObject(",
            "            notifications, '_send_notification', fake_notify))",
            "",
            "        def fake_audit(action, initiator, outcome, target,",
            "                       event_type, reason=None, **kwargs):",
            "            service_security = cadftaxonomy.SERVICE_SECURITY",
            "",
            "            event = eventfactory.EventFactory().new_event(",
            "                eventType=cadftype.EVENTTYPE_ACTIVITY,",
            "                outcome=outcome,",
            "                action=action,",
            "                initiator=initiator,",
            "                target=target,",
            "                reason=reason,",
            "                observer=cadfresource.Resource(typeURI=service_security))",
            "",
            "            for key, value in kwargs.items():",
            "                setattr(event, key, value)",
            "",
            "            payload = event.as_dict()",
            "",
            "            audit = {",
            "                'payload': payload,",
            "                'event_type': event_type,",
            "                'send_notification_called': True}",
            "            self._audits.append(audit)",
            "",
            "        self.useFixture(fixtures.MockPatchObject(",
            "            notifications, '_send_audit_notification', fake_audit))",
            "",
            "    def _assert_last_note(self, resource_id, operation, resource_type,",
            "                          actor_id=None, actor_type=None,",
            "                          actor_operation=None):",
            "        # NOTE(stevemar): If 'basic' format is not used, then simply",
            "        # return since this assertion is not valid.",
            "        if CONF.notification_format != 'basic':",
            "            return",
            "        self.assertGreater(len(self._notifications), 0)",
            "        note = self._notifications[-1]",
            "        self.assertEqual(operation, note['operation'])",
            "        self.assertEqual(resource_id, note['resource_id'])",
            "        self.assertEqual(resource_type, note['resource_type'])",
            "        self.assertTrue(note['send_notification_called'])",
            "        if actor_id:",
            "            self.assertEqual(actor_id, note['actor_id'])",
            "            self.assertEqual(actor_type, note['actor_type'])",
            "            self.assertEqual(actor_operation, note['actor_operation'])",
            "",
            "    def _assert_last_audit(self, resource_id, operation, resource_type,",
            "                           target_uri, reason=None):",
            "        # NOTE(stevemar): If 'cadf' format is not used, then simply",
            "        # return since this assertion is not valid.",
            "        if CONF.notification_format != 'cadf':",
            "            return",
            "        self.assertGreater(len(self._audits), 0)",
            "        audit = self._audits[-1]",
            "        payload = audit['payload']",
            "        if 'resource_info' in payload:",
            "            self.assertEqual(resource_id, payload['resource_info'])",
            "        action = '.'.join(filter(None, [operation, resource_type]))",
            "        self.assertEqual(action, payload['action'])",
            "        self.assertEqual(target_uri, payload['target']['typeURI'])",
            "        if resource_id:",
            "            self.assertEqual(resource_id, payload['target']['id'])",
            "        event_type = '.'.join(filter(None, ['identity',",
            "                                            resource_type,",
            "                                            operation]))",
            "        self.assertEqual(event_type, audit['event_type'])",
            "        if reason:",
            "            self.assertEqual(reason['reasonCode'],",
            "                             payload['reason']['reasonCode'])",
            "            self.assertEqual(reason['reasonType'],",
            "                             payload['reason']['reasonType'])",
            "        self.assertTrue(audit['send_notification_called'])",
            "",
            "    def _assert_initiator_data_is_set(self, operation, resource_type, typeURI):",
            "        self.assertGreater(len(self._audits), 0)",
            "        audit = self._audits[-1]",
            "        payload = audit['payload']",
            "        self.assertEqual(self.user_id, payload['initiator']['id'])",
            "        self.assertEqual(self.project_id, payload['initiator']['project_id'])",
            "        self.assertEqual(typeURI, payload['target']['typeURI'])",
            "        self.assertIn('request_id', payload['initiator'])",
            "        action = '%s.%s' % (operation, resource_type)",
            "        self.assertEqual(action, payload['action'])",
            "",
            "    def _assert_notify_not_sent(self, resource_id, operation, resource_type,",
            "                                public=True):",
            "        unexpected = {",
            "            'resource_id': resource_id,",
            "            'operation': operation,",
            "            'resource_type': resource_type,",
            "            'send_notification_called': True,",
            "            'public': public}",
            "        for note in self._notifications:",
            "            self.assertNotEqual(unexpected, note)",
            "",
            "    def _assert_notify_sent(self, resource_id, operation, resource_type,",
            "                            public=True):",
            "        expected = {",
            "            'resource_id': resource_id,",
            "            'operation': operation,",
            "            'resource_type': resource_type,",
            "            'send_notification_called': True,",
            "            'public': public}",
            "        for note in self._notifications:",
            "            # compare only expected fields",
            "            if all(note.get(k) == v for k, v in expected.items()):",
            "                break",
            "        else:",
            "            self.fail(\"Notification not sent.\")",
            "",
            "",
            "class NotificationsForEntities(BaseNotificationTest):",
            "",
            "    def test_create_group(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        self._assert_last_note(group_ref['id'], CREATED_OPERATION, 'group')",
            "        self._assert_last_audit(group_ref['id'], CREATED_OPERATION, 'group',",
            "                                cadftaxonomy.SECURITY_GROUP)",
            "",
            "    def test_create_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self._assert_last_note(",
            "            project_ref['id'], CREATED_OPERATION, 'project')",
            "        self._assert_last_audit(project_ref['id'], CREATED_OPERATION,",
            "                                'project', cadftaxonomy.SECURITY_PROJECT)",
            "",
            "    def test_create_role(self):",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        self._assert_last_note(role_ref['id'], CREATED_OPERATION, 'role')",
            "        self._assert_last_audit(role_ref['id'], CREATED_OPERATION, 'role',",
            "                                cadftaxonomy.SECURITY_ROLE)",
            "",
            "    def test_create_user(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        self._assert_last_note(user_ref['id'], CREATED_OPERATION, 'user')",
            "        self._assert_last_audit(user_ref['id'], CREATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER)",
            "",
            "    def test_create_trust(self):",
            "        trustor = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustor = PROVIDERS.identity_api.create_user(trustor)",
            "        trustee = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustee = PROVIDERS.identity_api.create_user(trustee)",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        trust_ref = unit.new_trust_ref(trustor['id'],",
            "                                       trustee['id'])",
            "        PROVIDERS.trust_api.create_trust(",
            "            trust_ref['id'], trust_ref, [role_ref]",
            "        )",
            "        self._assert_last_note(",
            "            trust_ref['id'], CREATED_OPERATION, 'OS-TRUST:trust')",
            "        self._assert_last_audit(trust_ref['id'], CREATED_OPERATION,",
            "                                'OS-TRUST:trust', cadftaxonomy.SECURITY_TRUST)",
            "",
            "    def test_delete_group(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.delete_group(group_ref['id'])",
            "        self._assert_last_note(group_ref['id'], DELETED_OPERATION, 'group')",
            "        self._assert_last_audit(group_ref['id'], DELETED_OPERATION, 'group',",
            "                                cadftaxonomy.SECURITY_GROUP)",
            "",
            "    def test_delete_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        PROVIDERS.resource_api.delete_project(project_ref['id'])",
            "        self._assert_last_note(",
            "            project_ref['id'], DELETED_OPERATION, 'project')",
            "        self._assert_last_audit(project_ref['id'], DELETED_OPERATION,",
            "                                'project', cadftaxonomy.SECURITY_PROJECT)",
            "",
            "    def test_delete_role(self):",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        PROVIDERS.role_api.delete_role(role_ref['id'])",
            "        self._assert_last_note(role_ref['id'], DELETED_OPERATION, 'role')",
            "        self._assert_last_audit(role_ref['id'], DELETED_OPERATION, 'role',",
            "                                cadftaxonomy.SECURITY_ROLE)",
            "",
            "    def test_delete_user(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        PROVIDERS.identity_api.delete_user(user_ref['id'])",
            "        self._assert_last_note(user_ref['id'], DELETED_OPERATION, 'user')",
            "        self._assert_last_audit(user_ref['id'], DELETED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER)",
            "",
            "    def test_create_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        self._assert_last_note(domain_ref['id'], CREATED_OPERATION, 'domain')",
            "        self._assert_last_audit(domain_ref['id'], CREATED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_update_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        domain_ref['description'] = uuid.uuid4().hex",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        self._assert_last_note(domain_ref['id'], UPDATED_OPERATION, 'domain')",
            "        self._assert_last_audit(domain_ref['id'], UPDATED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_delete_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        domain_ref['enabled'] = False",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        PROVIDERS.resource_api.delete_domain(domain_ref['id'])",
            "        self._assert_last_note(domain_ref['id'], DELETED_OPERATION, 'domain')",
            "        self._assert_last_audit(domain_ref['id'], DELETED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_delete_trust(self):",
            "        trustor = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustor = PROVIDERS.identity_api.create_user(trustor)",
            "        trustee = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustee = PROVIDERS.identity_api.create_user(trustee)",
            "        role_ref = unit.new_role_ref()",
            "        trust_ref = unit.new_trust_ref(trustor['id'], trustee['id'])",
            "        PROVIDERS.trust_api.create_trust(",
            "            trust_ref['id'], trust_ref, [role_ref]",
            "        )",
            "        PROVIDERS.trust_api.delete_trust(trust_ref['id'])",
            "        self._assert_last_note(",
            "            trust_ref['id'], DELETED_OPERATION, 'OS-TRUST:trust')",
            "        self._assert_last_audit(trust_ref['id'], DELETED_OPERATION,",
            "                                'OS-TRUST:trust', cadftaxonomy.SECURITY_TRUST)",
            "",
            "    def test_create_endpoint(self):",
            "        endpoint_ref = unit.new_endpoint_ref(service_id=self.service_id,",
            "                                             interface='public',",
            "                                             region_id=self.region_id)",
            "        PROVIDERS.catalog_api.create_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        self._assert_notify_sent(endpoint_ref['id'], CREATED_OPERATION,",
            "                                 'endpoint')",
            "        self._assert_last_audit(endpoint_ref['id'], CREATED_OPERATION,",
            "                                'endpoint', cadftaxonomy.SECURITY_ENDPOINT)",
            "",
            "    def test_update_endpoint(self):",
            "        endpoint_ref = unit.new_endpoint_ref(service_id=self.service_id,",
            "                                             interface='public',",
            "                                             region_id=self.region_id)",
            "        PROVIDERS.catalog_api.create_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        PROVIDERS.catalog_api.update_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        self._assert_notify_sent(endpoint_ref['id'], UPDATED_OPERATION,",
            "                                 'endpoint')",
            "        self._assert_last_audit(endpoint_ref['id'], UPDATED_OPERATION,",
            "                                'endpoint', cadftaxonomy.SECURITY_ENDPOINT)",
            "",
            "    def test_delete_endpoint(self):",
            "        endpoint_ref = unit.new_endpoint_ref(service_id=self.service_id,",
            "                                             interface='public',",
            "                                             region_id=self.region_id)",
            "        PROVIDERS.catalog_api.create_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        PROVIDERS.catalog_api.delete_endpoint(endpoint_ref['id'])",
            "        self._assert_notify_sent(endpoint_ref['id'], DELETED_OPERATION,",
            "                                 'endpoint')",
            "        self._assert_last_audit(endpoint_ref['id'], DELETED_OPERATION,",
            "                                'endpoint', cadftaxonomy.SECURITY_ENDPOINT)",
            "",
            "    def test_create_service(self):",
            "        service_ref = unit.new_service_ref()",
            "        PROVIDERS.catalog_api.create_service(service_ref['id'], service_ref)",
            "        self._assert_notify_sent(service_ref['id'], CREATED_OPERATION,",
            "                                 'service')",
            "        self._assert_last_audit(service_ref['id'], CREATED_OPERATION,",
            "                                'service', cadftaxonomy.SECURITY_SERVICE)",
            "",
            "    def test_update_service(self):",
            "        service_ref = unit.new_service_ref()",
            "        PROVIDERS.catalog_api.create_service(service_ref['id'], service_ref)",
            "        PROVIDERS.catalog_api.update_service(service_ref['id'], service_ref)",
            "        self._assert_notify_sent(service_ref['id'], UPDATED_OPERATION,",
            "                                 'service')",
            "        self._assert_last_audit(service_ref['id'], UPDATED_OPERATION,",
            "                                'service', cadftaxonomy.SECURITY_SERVICE)",
            "",
            "    def test_delete_service(self):",
            "        service_ref = unit.new_service_ref()",
            "        PROVIDERS.catalog_api.create_service(service_ref['id'], service_ref)",
            "        PROVIDERS.catalog_api.delete_service(service_ref['id'])",
            "        self._assert_notify_sent(service_ref['id'], DELETED_OPERATION,",
            "                                 'service')",
            "        self._assert_last_audit(service_ref['id'], DELETED_OPERATION,",
            "                                'service', cadftaxonomy.SECURITY_SERVICE)",
            "",
            "    def test_create_region(self):",
            "        region_ref = unit.new_region_ref()",
            "        PROVIDERS.catalog_api.create_region(region_ref)",
            "        self._assert_notify_sent(region_ref['id'], CREATED_OPERATION,",
            "                                 'region')",
            "        self._assert_last_audit(region_ref['id'], CREATED_OPERATION,",
            "                                'region', cadftaxonomy.SECURITY_REGION)",
            "",
            "    def test_update_region(self):",
            "        region_ref = unit.new_region_ref()",
            "        PROVIDERS.catalog_api.create_region(region_ref)",
            "        PROVIDERS.catalog_api.update_region(region_ref['id'], region_ref)",
            "        self._assert_notify_sent(region_ref['id'], UPDATED_OPERATION,",
            "                                 'region')",
            "        self._assert_last_audit(region_ref['id'], UPDATED_OPERATION,",
            "                                'region', cadftaxonomy.SECURITY_REGION)",
            "",
            "    def test_delete_region(self):",
            "        region_ref = unit.new_region_ref()",
            "        PROVIDERS.catalog_api.create_region(region_ref)",
            "        PROVIDERS.catalog_api.delete_region(region_ref['id'])",
            "        self._assert_notify_sent(region_ref['id'], DELETED_OPERATION,",
            "                                 'region')",
            "        self._assert_last_audit(region_ref['id'], DELETED_OPERATION,",
            "                                'region', cadftaxonomy.SECURITY_REGION)",
            "",
            "    def test_create_policy(self):",
            "        policy_ref = unit.new_policy_ref()",
            "        PROVIDERS.policy_api.create_policy(policy_ref['id'], policy_ref)",
            "        self._assert_notify_sent(policy_ref['id'], CREATED_OPERATION,",
            "                                 'policy')",
            "        self._assert_last_audit(policy_ref['id'], CREATED_OPERATION,",
            "                                'policy', cadftaxonomy.SECURITY_POLICY)",
            "",
            "    def test_update_policy(self):",
            "        policy_ref = unit.new_policy_ref()",
            "        PROVIDERS.policy_api.create_policy(policy_ref['id'], policy_ref)",
            "        PROVIDERS.policy_api.update_policy(policy_ref['id'], policy_ref)",
            "        self._assert_notify_sent(policy_ref['id'], UPDATED_OPERATION,",
            "                                 'policy')",
            "        self._assert_last_audit(policy_ref['id'], UPDATED_OPERATION,",
            "                                'policy', cadftaxonomy.SECURITY_POLICY)",
            "",
            "    def test_delete_policy(self):",
            "        policy_ref = unit.new_policy_ref()",
            "        PROVIDERS.policy_api.create_policy(policy_ref['id'], policy_ref)",
            "        PROVIDERS.policy_api.delete_policy(policy_ref['id'])",
            "        self._assert_notify_sent(policy_ref['id'], DELETED_OPERATION,",
            "                                 'policy')",
            "        self._assert_last_audit(policy_ref['id'], DELETED_OPERATION,",
            "                                'policy', cadftaxonomy.SECURITY_POLICY)",
            "",
            "    def test_disable_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        domain_ref['enabled'] = False",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        self._assert_notify_sent(domain_ref['id'], 'disabled', 'domain',",
            "                                 public=False)",
            "",
            "    def test_disable_of_disabled_domain_does_not_notify(self):",
            "        domain_ref = unit.new_domain_ref(enabled=False)",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        # The domain_ref above is not changed during the create process. We",
            "        # can use the same ref to perform the update.",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        self._assert_notify_not_sent(domain_ref['id'], 'disabled', 'domain',",
            "                                     public=False)",
            "",
            "    def test_update_group(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.update_group(group_ref['id'], group_ref)",
            "        self._assert_last_note(group_ref['id'], UPDATED_OPERATION, 'group')",
            "        self._assert_last_audit(group_ref['id'], UPDATED_OPERATION, 'group',",
            "                                cadftaxonomy.SECURITY_GROUP)",
            "",
            "    def test_update_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_notify_sent(",
            "            project_ref['id'], UPDATED_OPERATION, 'project', public=True)",
            "        self._assert_last_audit(project_ref['id'], UPDATED_OPERATION,",
            "                                'project', cadftaxonomy.SECURITY_PROJECT)",
            "",
            "    def test_disable_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        project_ref['enabled'] = False",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_notify_sent(project_ref['id'], 'disabled', 'project',",
            "                                 public=False)",
            "",
            "    def test_disable_of_disabled_project_does_not_notify(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id,",
            "                                           enabled=False)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        # The project_ref above is not changed during the create process. We",
            "        # can use the same ref to perform the update.",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_notify_not_sent(project_ref['id'], 'disabled', 'project',",
            "                                     public=False)",
            "",
            "    def test_update_project_does_not_send_disable(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        project_ref['enabled'] = True",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_last_note(",
            "            project_ref['id'], UPDATED_OPERATION, 'project')",
            "        self._assert_notify_not_sent(project_ref['id'], 'disabled', 'project')",
            "",
            "    def test_update_role(self):",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        PROVIDERS.role_api.update_role(role_ref['id'], role_ref)",
            "        self._assert_last_note(role_ref['id'], UPDATED_OPERATION, 'role')",
            "        self._assert_last_audit(role_ref['id'], UPDATED_OPERATION, 'role',",
            "                                cadftaxonomy.SECURITY_ROLE)",
            "",
            "    def test_update_user(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        PROVIDERS.identity_api.update_user(user_ref['id'], user_ref)",
            "        self._assert_last_note(user_ref['id'], UPDATED_OPERATION, 'user')",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER)",
            "",
            "    def test_config_option_no_events(self):",
            "        self.config_fixture.config(notification_format='basic')",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        # The regular notifications will still be emitted, since they are",
            "        # used for callback handling.",
            "        self._assert_last_note(role_ref['id'], CREATED_OPERATION, 'role')",
            "        # No audit event should have occurred",
            "        self.assertEqual(0, len(self._audits))",
            "",
            "    def test_add_user_to_group(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.add_user_to_group(",
            "            user_ref['id'], group_ref['id']",
            "        )",
            "        self._assert_last_note(group_ref['id'], UPDATED_OPERATION, 'group',",
            "                               actor_id=user_ref['id'], actor_type='user',",
            "                               actor_operation='added')",
            "",
            "    def test_remove_user_from_group(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.add_user_to_group(",
            "            user_ref['id'], group_ref['id']",
            "        )",
            "        PROVIDERS.identity_api.remove_user_from_group(",
            "            user_ref['id'], group_ref['id']",
            "        )",
            "        self._assert_last_note(group_ref['id'], UPDATED_OPERATION, 'group',",
            "                               actor_id=user_ref['id'], actor_type='user',",
            "                               actor_operation='removed')",
            "",
            "    def test_initiator_request_id(self):",
            "        ref = unit.new_domain_ref()",
            "        self.post('/domains', body={'domain': ref})",
            "        note = self._notifications[-1]",
            "        initiator = note['initiator']",
            "        self.assertIsNotNone(initiator.request_id)",
            "",
            "    def test_initiator_global_request_id(self):",
            "        global_request_id = 'req-%s' % uuid.uuid4()",
            "        ref = unit.new_domain_ref()",
            "        self.post('/domains', body={'domain': ref},",
            "                  headers={'X-OpenStack-Request-Id': global_request_id})",
            "        note = self._notifications[-1]",
            "        initiator = note['initiator']",
            "        self.assertEqual(",
            "            initiator.global_request_id, global_request_id)",
            "",
            "    def test_initiator_global_request_id_not_set(self):",
            "        ref = unit.new_domain_ref()",
            "        self.post('/domains', body={'domain': ref})",
            "        note = self._notifications[-1]",
            "        initiator = note['initiator']",
            "        self.assertFalse(hasattr(initiator, 'global_request_id'))",
            "",
            "",
            "class CADFNotificationsForPCIDSSEvents(BaseNotificationTest):",
            "",
            "    def setUp(self):",
            "        super(CADFNotificationsForPCIDSSEvents, self).setUp()",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_format='cadf')",
            "        conf.config(group='security_compliance',",
            "                    password_expires_days=2)",
            "        conf.config(group='security_compliance',",
            "                    lockout_failure_attempts=3)",
            "        conf.config(group='security_compliance',",
            "                    unique_last_password_count=2)",
            "        conf.config(group='security_compliance',",
            "                    minimum_password_age=2)",
            "        conf.config(group='security_compliance',",
            "                    password_regex='^(?=.*\\d)(?=.*[a-zA-Z]).{7,}$')",
            "        conf.config(group='security_compliance',",
            "                    password_regex_description='1 letter, 1 digit, 7 chars')",
            "",
            "    def test_password_expired_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        password_creation_time = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days + 1)",
            "        )",
            "        freezer = freezegun.freeze_time(password_creation_time)",
            "",
            "        # NOTE(gagehugo): This part below uses freezegun to spoof",
            "        # the time as being three days in the past from right now. We will",
            "        # create a user and have that user successfully authenticate,",
            "        # then stop the time machine and return to the present time,",
            "        # where the user's password is now expired.",
            "        freezer.start()",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.authenticate(user_ref['id'], password)",
            "        freezer.stop()",
            "",
            "        reason_type = (exception.PasswordExpired.message_format %",
            "                       {'user_id': user_ref['id']})",
            "        expected_reason = {'reasonCode': '401',",
            "                           'reasonType': reason_type}",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user_ref['id'],",
            "                              password=password)",
            "        self._assert_last_audit(None, 'authenticate', None,",
            "                                cadftaxonomy.ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_locked_out_user_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        new_password = uuid.uuid4().hex",
            "        expected_responses = [AssertionError, AssertionError, AssertionError,",
            "                              exception.AccountLocked]",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        reason_type = (exception.AccountLocked.message_format %",
            "                       {'user_id': user_ref['id']})",
            "        expected_reason = {'reasonCode': '401',",
            "                           'reasonType': reason_type}",
            "        for ex in expected_responses:",
            "            with self.make_request():",
            "                self.assertRaises(ex,",
            "                                  PROVIDERS.identity_api.change_password,",
            "                                  user_id=user_ref['id'],",
            "                                  original_password=new_password,",
            "                                  new_password=new_password)",
            "",
            "        self._assert_last_audit(None, 'authenticate', None,",
            "                                cadftaxonomy.ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_repeated_password_sends_notification(self):",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(group='security_compliance',",
            "                    minimum_password_age=0)",
            "        password = uuid.uuid4().hex",
            "        new_password = uuid.uuid4().hex",
            "        count = CONF.security_compliance.unique_last_password_count",
            "        reason_type = (exception.PasswordHistoryValidationError.message_format",
            "                       % {'unique_count': count})",
            "        expected_reason = {'reasonCode': '400',",
            "                           'reasonType': reason_type}",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_ref['id'],",
            "                original_password=password, new_password=new_password",
            "            )",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user_ref['id'],",
            "                              original_password=new_password,",
            "                              new_password=password)",
            "",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_invalid_password_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        invalid_password = '1'",
            "        regex = CONF.security_compliance.password_regex_description",
            "        reason_type = (exception.PasswordRequirementsValidationError",
            "                       .message_format %",
            "                       {'detail': regex})",
            "        expected_reason = {'reasonCode': '400',",
            "                           'reasonType': reason_type}",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user_ref['id'],",
            "                              original_password=password,",
            "                              new_password=invalid_password)",
            "",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_changing_password_too_early_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        new_password = uuid.uuid4().hex",
            "        next_password = uuid.uuid4().hex",
            "",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password,",
            "                                     password_created_at=(",
            "                                         datetime.datetime.utcnow()))",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "",
            "        min_days = CONF.security_compliance.minimum_password_age",
            "        min_age = (user_ref['password_created_at'] +",
            "                   datetime.timedelta(days=min_days))",
            "        days_left = (min_age - datetime.datetime.utcnow()).days",
            "        reason_type = (exception.PasswordAgeValidationError.message_format %",
            "                       {'min_age_days': min_days, 'days_left': days_left})",
            "        expected_reason = {'reasonCode': '400',",
            "                           'reasonType': reason_type}",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_ref['id'],",
            "                original_password=password, new_password=new_password",
            "            )",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user_ref['id'],",
            "                              original_password=new_password,",
            "                              new_password=next_password)",
            "",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "",
            "class CADFNotificationsForEntities(NotificationsForEntities):",
            "",
            "    def setUp(self):",
            "        super(CADFNotificationsForEntities, self).setUp()",
            "        self.config_fixture.config(notification_format='cadf')",
            "",
            "    def test_initiator_data_is_set(self):",
            "        ref = unit.new_domain_ref()",
            "        resp = self.post('/domains', body={'domain': ref})",
            "        resource_id = resp.result.get('domain').get('id')",
            "        self._assert_last_audit(resource_id, CREATED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "        self._assert_initiator_data_is_set(CREATED_OPERATION,",
            "                                           'domain',",
            "                                           cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_initiator_request_id(self):",
            "        data = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.user['password'])",
            "        self.post('/auth/tokens', body=data)",
            "        audit = self._audits[-1]",
            "        initiator = audit['payload']['initiator']",
            "        self.assertIn('request_id', initiator)",
            "",
            "    def test_initiator_global_request_id(self):",
            "        global_request_id = 'req-%s' % uuid.uuid4()",
            "        data = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.user['password'])",
            "        self.post(",
            "            '/auth/tokens', body=data,",
            "            headers={'X-OpenStack-Request-Id': global_request_id})",
            "        audit = self._audits[-1]",
            "        initiator = audit['payload']['initiator']",
            "        self.assertEqual(",
            "            initiator['global_request_id'], global_request_id)",
            "",
            "    def test_initiator_global_request_id_not_set(self):",
            "        data = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.user['password'])",
            "        self.post('/auth/tokens', body=data)",
            "        audit = self._audits[-1]",
            "        initiator = audit['payload']['initiator']",
            "        self.assertNotIn('global_request_id', initiator)",
            "",
            "",
            "class TestEventCallbacks(test_v3.RestfulTestCase):",
            "",
            "    class FakeManager(object):",
            "",
            "        def _project_deleted_callback(self, service, resource_type, operation,",
            "                                      payload):",
            "            \"\"\"Used just for the callback interface.\"\"\"",
            "",
            "    def test_notification_received(self):",
            "        callback = register_callback(CREATED_OPERATION, 'project')",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self.assertTrue(callback.called)",
            "",
            "    def test_notification_method_not_callable(self):",
            "        fake_method = None",
            "        self.assertRaises(TypeError,",
            "                          notifications.register_event_callback,",
            "                          UPDATED_OPERATION,",
            "                          'project',",
            "                          [fake_method])",
            "",
            "    def test_notification_event_not_valid(self):",
            "        manager = self.FakeManager()",
            "        self.assertRaises(ValueError,",
            "                          notifications.register_event_callback,",
            "                          uuid.uuid4().hex,",
            "                          'project',",
            "                          manager._project_deleted_callback)",
            "",
            "    def test_event_registration_for_unknown_resource_type(self):",
            "        # Registration for unknown resource types should succeed.  If no event",
            "        # is issued for that resource type, the callback wont be triggered.",
            "",
            "        manager = self.FakeManager()",
            "",
            "        notifications.register_event_callback(",
            "            DELETED_OPERATION,",
            "            uuid.uuid4().hex,",
            "            manager._project_deleted_callback)",
            "        resource_type = uuid.uuid4().hex",
            "        notifications.register_event_callback(",
            "            DELETED_OPERATION,",
            "            resource_type,",
            "            manager._project_deleted_callback)",
            "",
            "    def test_provider_event_callback_subscription(self):",
            "        callback_called = []",
            "",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {",
            "                    CREATED_OPERATION: {'project': self.foo_callback}}",
            "",
            "            def foo_callback(self, service, resource_type, operation,",
            "                             payload):",
            "                # uses callback_called from the closure",
            "                callback_called.append(True)",
            "",
            "        Foo()",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self.assertEqual([True], callback_called)",
            "",
            "    def test_provider_event_callbacks_subscription(self):",
            "        callback_called = []",
            "",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {",
            "                    CREATED_OPERATION: {",
            "                        'project': [self.callback_0, self.callback_1]}}",
            "",
            "            def callback_0(self, service, resource_type, operation, payload):",
            "                # uses callback_called from the closure",
            "                callback_called.append('cb0')",
            "",
            "            def callback_1(self, service, resource_type, operation, payload):",
            "                # uses callback_called from the closure",
            "                callback_called.append('cb1')",
            "",
            "        Foo()",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self.assertItemsEqual(['cb1', 'cb0'], callback_called)",
            "",
            "    def test_invalid_event_callbacks(self):",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = 'bogus'",
            "",
            "        self.assertRaises(AttributeError, Foo)",
            "",
            "    def test_invalid_event_callbacks_event(self):",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {CREATED_OPERATION: 'bogus'}",
            "",
            "        self.assertRaises(AttributeError, Foo)",
            "",
            "    def test_using_an_unbound_method_as_a_callback_fails(self):",
            "        # NOTE(dstanek): An unbound method is when you reference a method",
            "        # from a class object. You'll get a method that isn't bound to a",
            "        # particular instance so there is no magic 'self'. You can call it,",
            "        # but you have to pass in the instance manually like: C.m(C()).",
            "        # If you reference the method from an instance then you get a method",
            "        # that effectively curries the self argument for you",
            "        # (think functools.partial). Obviously is we don't have an",
            "        # instance then we can't call the method.",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {CREATED_OPERATION:",
            "                                        {'project': Foo.callback}}",
            "",
            "            def callback(self, service, resource_type, operation, payload):",
            "                pass",
            "",
            "        # TODO(dstanek): it would probably be nice to fail early using",
            "        # something like:",
            "        #     self.assertRaises(TypeError, Foo)",
            "        Foo()",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        self.assertRaises(TypeError, PROVIDERS.resource_api.create_project,",
            "                          project_ref['id'], project_ref)",
            "",
            "",
            "class CadfNotificationsWrapperTestCase(test_v3.RestfulTestCase):",
            "",
            "    LOCAL_HOST = 'localhost'",
            "    ACTION = 'authenticate'",
            "    ROLE_ASSIGNMENT = 'role_assignment'",
            "",
            "    def setUp(self):",
            "        super(CadfNotificationsWrapperTestCase, self).setUp()",
            "        self._notifications = []",
            "",
            "        def fake_notify(action, initiator, outcome, target,",
            "                        event_type, reason=None, **kwargs):",
            "            service_security = cadftaxonomy.SERVICE_SECURITY",
            "",
            "            event = eventfactory.EventFactory().new_event(",
            "                eventType=cadftype.EVENTTYPE_ACTIVITY,",
            "                outcome=outcome,",
            "                action=action,",
            "                initiator=initiator,",
            "                target=target,",
            "                reason=reason,",
            "                observer=cadfresource.Resource(typeURI=service_security))",
            "",
            "            for key, value in kwargs.items():",
            "                setattr(event, key, value)",
            "",
            "            note = {",
            "                'action': action,",
            "                'initiator': initiator,",
            "                'event': event,",
            "                'event_type': event_type,",
            "                'send_notification_called': True}",
            "            self._notifications.append(note)",
            "",
            "        self.useFixture(fixtures.MockPatchObject(",
            "            notifications, '_send_audit_notification', fake_notify))",
            "",
            "    def _get_last_note(self):",
            "        self.assertTrue(self._notifications)",
            "        return self._notifications[-1]",
            "",
            "    def _assert_last_note(self, action, user_id, event_type=None):",
            "        self.assertTrue(self._notifications)",
            "        note = self._notifications[-1]",
            "        self.assertEqual(action, note['action'])",
            "        initiator = note['initiator']",
            "        self.assertEqual(user_id, initiator.id)",
            "        self.assertEqual(self.LOCAL_HOST, initiator.host.address)",
            "        self.assertTrue(note['send_notification_called'])",
            "        if event_type:",
            "            self.assertEqual(event_type, note['event_type'])",
            "",
            "    def _assert_event(self, role_id, project=None, domain=None,",
            "                      user=None, group=None, inherit=False):",
            "        \"\"\"Assert that the CADF event is valid.",
            "",
            "        In the case of role assignments, the event will have extra data,",
            "        specifically, the role, target, actor, and if the role is inherited.",
            "",
            "        An example event, as a dictionary is seen below:",
            "            {",
            "                'typeURI': 'http://schemas.dmtf.org/cloud/audit/1.0/event',",
            "                'initiator': {",
            "                    'typeURI': 'service/security/account/user',",
            "                    'host': {'address': 'localhost'},",
            "                    'id': 'openstack:0a90d95d-582c-4efb-9cbc-e2ca7ca9c341',",
            "                    'username': u'admin'",
            "                },",
            "                'target': {",
            "                    'typeURI': 'service/security/account/user',",
            "                    'id': 'openstack:d48ea485-ef70-4f65-8d2b-01aa9d7ec12d'",
            "                },",
            "                'observer': {",
            "                    'typeURI': 'service/security',",
            "                    'id': 'openstack:d51dd870-d929-4aba-8d75-dcd7555a0c95'",
            "                },",
            "                'eventType': 'activity',",
            "                'eventTime': '2014-08-21T21:04:56.204536+0000',",
            "                'role': u'0e6b990380154a2599ce6b6e91548a68',",
            "                'domain': u'24bdcff1aab8474895dbaac509793de1',",
            "                'inherited_to_projects': False,",
            "                'group': u'c1e22dc67cbd469ea0e33bf428fe597a',",
            "                'action': 'created.role_assignment',",
            "                'outcome': 'success',",
            "                'id': 'openstack:782689dd-f428-4f13-99c7-5c70f94a5ac1'",
            "            }",
            "        \"\"\"",
            "        note = self._notifications[-1]",
            "        event = note['event']",
            "        if project:",
            "            self.assertEqual(project, event.project)",
            "        if domain:",
            "            self.assertEqual(domain, event.domain)",
            "        if group:",
            "            self.assertEqual(group, event.group)",
            "        elif user:",
            "            self.assertEqual(user, event.user)",
            "        self.assertEqual(role_id, event.role)",
            "        self.assertEqual(inherit, event.inherited_to_projects)",
            "",
            "    def test_initiator_id_always_matches_user_id(self):",
            "        # Clear notifications",
            "        while self._notifications:",
            "            self._notifications.pop()",
            "",
            "        self.get_scoped_token()",
            "        self.assertEqual(len(self._notifications), 1)",
            "        note = self._notifications.pop()",
            "        initiator = note['initiator']",
            "        self.assertEqual(self.user_id, initiator.id)",
            "        self.assertEqual(self.user_id, initiator.user_id)",
            "",
            "    def test_initiator_always_contains_username(self):",
            "        # Clear notifications",
            "        while self._notifications:",
            "            self._notifications.pop()",
            "",
            "        self.get_scoped_token()",
            "        self.assertEqual(len(self._notifications), 1)",
            "        note = self._notifications.pop()",
            "        initiator = note['initiator']",
            "        self.assertEqual(self.user['name'], initiator.username)",
            "",
            "    def test_v3_authenticate_user_name_and_domain_id(self):",
            "        user_id = self.user_id",
            "        user_name = self.user['name']",
            "        password = self.user['password']",
            "        domain_id = self.domain_id",
            "        data = self.build_authentication_request(username=user_name,",
            "                                                 user_domain_id=domain_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data)",
            "        self._assert_last_note(self.ACTION, user_id)",
            "",
            "    def test_v3_authenticate_user_id(self):",
            "        user_id = self.user_id",
            "        password = self.user['password']",
            "        data = self.build_authentication_request(user_id=user_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data)",
            "        self._assert_last_note(self.ACTION, user_id)",
            "",
            "    def test_v3_authenticate_with_invalid_user_id_sends_notification(self):",
            "        user_id = uuid.uuid4().hex",
            "        password = self.user['password']",
            "        data = self.build_authentication_request(user_id=user_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data,",
            "                  expected_status=http_client.UNAUTHORIZED)",
            "        note = self._get_last_note()",
            "        initiator = note['initiator']",
            "",
            "        # Confirm user-name specific event was emitted.",
            "        self.assertEqual(self.ACTION, note['action'])",
            "        self.assertEqual(user_id, initiator.user_id)",
            "        self.assertTrue(note['send_notification_called'])",
            "        self.assertEqual(cadftaxonomy.OUTCOME_FAILURE, note['event'].outcome)",
            "        self.assertEqual(self.LOCAL_HOST, initiator.host.address)",
            "",
            "    def test_v3_authenticate_with_invalid_user_name_sends_notification(self):",
            "        user_name = uuid.uuid4().hex",
            "        password = self.user['password']",
            "        domain_id = self.domain_id",
            "        data = self.build_authentication_request(username=user_name,",
            "                                                 user_domain_id=domain_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data,",
            "                  expected_status=http_client.UNAUTHORIZED)",
            "        note = self._get_last_note()",
            "        initiator = note['initiator']",
            "",
            "        # Confirm user-name specific event was emitted.",
            "        self.assertEqual(self.ACTION, note['action'])",
            "        self.assertEqual(user_name, initiator.user_name)",
            "        self.assertEqual(domain_id, initiator.domain_id)",
            "        self.assertTrue(note['send_notification_called'])",
            "        self.assertEqual(cadftaxonomy.OUTCOME_FAILURE, note['event'].outcome)",
            "        self.assertEqual(self.LOCAL_HOST, initiator.host.address)",
            "",
            "    def test_v3_authenticate_user_name_and_domain_name(self):",
            "        user_id = self.user_id",
            "        user_name = self.user['name']",
            "        password = self.user['password']",
            "        domain_name = self.domain['name']",
            "        data = self.build_authentication_request(username=user_name,",
            "                                                 user_domain_name=domain_name,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data)",
            "        self._assert_last_note(self.ACTION, user_id)",
            "",
            "    def _test_role_assignment(self, url, role, project=None, domain=None,",
            "                              user=None, group=None):",
            "        self.put(url)",
            "        action = \"%s.%s\" % (CREATED_OPERATION, self.ROLE_ASSIGNMENT)",
            "        event_type = '%s.%s.%s' % (notifications.SERVICE,",
            "                                   self.ROLE_ASSIGNMENT, CREATED_OPERATION)",
            "        self._assert_last_note(action, self.user_id, event_type)",
            "        self._assert_event(role, project, domain, user, group)",
            "        self.delete(url)",
            "        action = \"%s.%s\" % (DELETED_OPERATION, self.ROLE_ASSIGNMENT)",
            "        event_type = '%s.%s.%s' % (notifications.SERVICE,",
            "                                   self.ROLE_ASSIGNMENT, DELETED_OPERATION)",
            "        self._assert_last_note(action, self.user_id, event_type)",
            "        self._assert_event(role, project, domain, user, None)",
            "",
            "    def test_user_project_grant(self):",
            "        url = ('/projects/%s/users/%s/roles/%s' %",
            "               (self.project_id, self.user_id, self.role_id))",
            "        self._test_role_assignment(url, self.role_id,",
            "                                   project=self.project_id,",
            "                                   user=self.user_id)",
            "",
            "    def test_group_domain_grant(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.add_user_to_group(self.user_id, group['id'])",
            "        url = ('/domains/%s/groups/%s/roles/%s' %",
            "               (self.domain_id, group['id'], self.role_id))",
            "        self._test_role_assignment(url, self.role_id,",
            "                                   domain=self.domain_id,",
            "                                   group=group['id'])",
            "",
            "    def test_add_role_to_user_and_project(self):",
            "        # A notification is sent when add_role_to_user_and_project is called on",
            "        # the assignment manager.",
            "",
            "        project_ref = unit.new_project_ref(self.domain_id)",
            "        project = PROVIDERS.resource_api.create_project(",
            "            project_ref['id'], project_ref)",
            "        project_id = project['id']",
            "",
            "        PROVIDERS.assignment_api.add_role_to_user_and_project(",
            "            self.user_id, project_id, self.role_id)",
            "",
            "        self.assertTrue(self._notifications)",
            "        note = self._notifications[-1]",
            "        self.assertEqual('created.role_assignment', note['action'])",
            "        self.assertTrue(note['send_notification_called'])",
            "",
            "        self._assert_event(self.role_id, project=project_id, user=self.user_id)",
            "",
            "    def test_remove_role_from_user_and_project(self):",
            "        # A notification is sent when remove_role_from_user_and_project is",
            "        # called on the assignment manager.",
            "",
            "        PROVIDERS.assignment_api.remove_role_from_user_and_project(",
            "            self.user_id, self.project_id, self.role_id)",
            "",
            "        self.assertTrue(self._notifications)",
            "        note = self._notifications[-1]",
            "        self.assertEqual('deleted.role_assignment', note['action'])",
            "        self.assertTrue(note['send_notification_called'])",
            "",
            "        self._assert_event(self.role_id, project=self.project_id,",
            "                           user=self.user_id)",
            "",
            "",
            "class TestCallbackRegistration(unit.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestCallbackRegistration, self).setUp()",
            "        self.mock_log = mock.Mock()",
            "        # Force the callback logging to occur",
            "        self.mock_log.logger.getEffectiveLevel.return_value = log.DEBUG",
            "",
            "    def verify_log_message(self, data):",
            "        \"\"\"Verify log message.",
            "",
            "        Tests that use this are a little brittle because adding more",
            "        logging can break them.",
            "",
            "        TODO(dstanek): remove the need for this in a future refactoring",
            "",
            "        \"\"\"",
            "        log_fn = self.mock_log.debug",
            "        self.assertEqual(len(data), log_fn.call_count)",
            "        for datum in data:",
            "            log_fn.assert_any_call(mock.ANY, datum)",
            "",
            "    def test_a_function_callback(self):",
            "        def callback(*args, **kwargs):",
            "            pass",
            "",
            "        resource_type = 'thing'",
            "        with mock.patch('keystone.notifications.LOG', self.mock_log):",
            "            notifications.register_event_callback(",
            "                CREATED_OPERATION, resource_type, callback)",
            "",
            "        callback = 'keystone.tests.unit.common.test_notifications.callback'",
            "        expected_log_data = {",
            "            'callback': callback,",
            "            'event': 'identity.%s.created' % resource_type",
            "        }",
            "        self.verify_log_message([expected_log_data])",
            "",
            "    def test_a_method_callback(self):",
            "        class C(object):",
            "            def callback(self, *args, **kwargs):",
            "                pass",
            "",
            "        with mock.patch('keystone.notifications.LOG', self.mock_log):",
            "            notifications.register_event_callback(",
            "                CREATED_OPERATION, 'thing', C().callback)",
            "",
            "        callback = 'keystone.tests.unit.common.test_notifications.C.callback'",
            "        expected_log_data = {",
            "            'callback': callback,",
            "            'event': 'identity.thing.created'",
            "        }",
            "        self.verify_log_message([expected_log_data])",
            "",
            "    def test_a_list_of_callbacks(self):",
            "        def callback(*args, **kwargs):",
            "            pass",
            "",
            "        class C(object):",
            "            def callback(self, *args, **kwargs):",
            "                pass",
            "",
            "        with mock.patch('keystone.notifications.LOG', self.mock_log):",
            "            notifications.register_event_callback(",
            "                CREATED_OPERATION, 'thing', [callback, C().callback])",
            "",
            "        callback_1 = 'keystone.tests.unit.common.test_notifications.callback'",
            "        callback_2 = 'keystone.tests.unit.common.test_notifications.C.callback'",
            "        expected_log_data = [",
            "            {",
            "                'callback': callback_1,",
            "                'event': 'identity.thing.created'",
            "            },",
            "            {",
            "                'callback': callback_2,",
            "                'event': 'identity.thing.created'",
            "            },",
            "        ]",
            "        self.verify_log_message(expected_log_data)",
            "",
            "    def test_an_invalid_callback(self):",
            "        self.assertRaises(TypeError,",
            "                          notifications.register_event_callback,",
            "                          (CREATED_OPERATION, 'thing', object()))",
            "",
            "    def test_an_invalid_event(self):",
            "        def callback(*args, **kwargs):",
            "            pass",
            "",
            "        self.assertRaises(ValueError,",
            "                          notifications.register_event_callback,",
            "                          uuid.uuid4().hex,",
            "                          'thing',",
            "                          callback)",
            "",
            "",
            "class CADFNotificationsDataTestCase(test_v3.RestfulTestCase):",
            "",
            "    def config_overrides(self):",
            "        super(CADFNotificationsDataTestCase, self).config_overrides()",
            "        # NOTE(lbragstad): This is a workaround since oslo.messaging version",
            "        # 9.0.0 had a broken default for transport_url. This makes it so that",
            "        # we are able to use version 9.0.0 in tests because we are supplying",
            "        # an override to use a sane default (rabbit://). The problem is that",
            "        # we can't update the config fixture until we call",
            "        # get_notification_transport since that method registers the",
            "        # configuration options for oslo.messaging, which fails since there",
            "        # isn't a default value for transport_url with version 9.0.0. All the",
            "        # next line is doing is bypassing the broken default logic by supplying",
            "        # a dummy url, which allows the options to be registered. After that,",
            "        # we can actually update the configuration option to override the",
            "        # transport_url option that was just registered before proceeding with",
            "        # the test.",
            "        oslo_messaging.get_notification_transport(CONF, url='rabbit://')",
            "        self.config_fixture.config(",
            "            group='oslo_messaging_notifications', transport_url='rabbit://'",
            "        )",
            "",
            "    def test_receive_identityId_from_audit_notification(self):",
            "        observer = None",
            "        resource_type = EXP_RESOURCE_TYPE",
            "",
            "        ref = unit.new_service_ref()",
            "        ref['type'] = 'identity'",
            "        PROVIDERS.catalog_api.create_service(ref['id'], ref.copy())",
            "",
            "        action = CREATED_OPERATION + '.' + resource_type",
            "        initiator = notifications._get_request_audit_info(self.user_id)",
            "        target = cadfresource.Resource(typeURI=cadftaxonomy.ACCOUNT_USER)",
            "        outcome = 'success'",
            "        event_type = 'identity.authenticate.created'",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_audit_notification(action,",
            "                                                   initiator,",
            "                                                   outcome,",
            "                                                   target,",
            "                                                   event_type)",
            "",
            "            for mock_args_list in mocked.call_args:",
            "                if len(mock_args_list) != 0:",
            "                    for mock_args in mock_args_list:",
            "                        if 'observer' in mock_args:",
            "                            observer = mock_args['observer']",
            "                            break",
            "",
            "        self.assertEqual(ref['id'], observer['id'])"
        ],
        "afterPatchFile": [
            "# Copyright 2013 IBM Corp.",
            "#",
            "#   Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#   not use this file except in compliance with the License. You may obtain",
            "#   a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#   Unless required by applicable law or agreed to in writing, software",
            "#   distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#   WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#   License for the specific language governing permissions and limitations",
            "#   under the License.",
            "",
            "import datetime",
            "import uuid",
            "",
            "import fixtures",
            "import freezegun",
            "import mock",
            "from oslo_config import fixture as config_fixture",
            "from oslo_log import log",
            "import oslo_messaging",
            "from pycadf import cadftaxonomy",
            "from pycadf import cadftype",
            "from pycadf import eventfactory",
            "from pycadf import resource as cadfresource",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "import keystone.conf",
            "from keystone import exception",
            "from keystone import notifications",
            "from keystone.tests import unit",
            "from keystone.tests.unit import test_v3",
            "",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "EXP_RESOURCE_TYPE = uuid.uuid4().hex",
            "CREATED_OPERATION = notifications.ACTIONS.created",
            "UPDATED_OPERATION = notifications.ACTIONS.updated",
            "DELETED_OPERATION = notifications.ACTIONS.deleted",
            "DISABLED_OPERATION = notifications.ACTIONS.disabled",
            "",
            "",
            "class ArbitraryException(Exception):",
            "    pass",
            "",
            "",
            "def register_callback(operation, resource_type=EXP_RESOURCE_TYPE):",
            "    \"\"\"Helper for creating and registering a mock callback.\"\"\"",
            "    callback = mock.Mock(__name__='callback',",
            "                         im_class=mock.Mock(__name__='class'))",
            "    notifications.register_event_callback(operation, resource_type, callback)",
            "    return callback",
            "",
            "",
            "class AuditNotificationsTestCase(unit.BaseTestCase):",
            "    def setUp(self):",
            "        super(AuditNotificationsTestCase, self).setUp()",
            "        self.config_fixture = self.useFixture(config_fixture.Config(CONF))",
            "        self.addCleanup(notifications.clear_subscribers)",
            "",
            "    def _test_notification_operation_with_basic_format(self,",
            "                                                       notify_function,",
            "                                                       operation):",
            "        self.config_fixture.config(notification_format='basic')",
            "        exp_resource_id = uuid.uuid4().hex",
            "        callback = register_callback(operation)",
            "        notify_function(EXP_RESOURCE_TYPE, exp_resource_id)",
            "        callback.assert_called_once_with('identity', EXP_RESOURCE_TYPE,",
            "                                         operation,",
            "                                         {'resource_info': exp_resource_id})",
            "",
            "    def _test_notification_operation_with_cadf_format(self,",
            "                                                      notify_function,",
            "                                                      operation):",
            "        self.config_fixture.config(notification_format='cadf')",
            "        exp_resource_id = uuid.uuid4().hex",
            "        with mock.patch(",
            "                'keystone.notifications._create_cadf_payload') as cadf_notify:",
            "            notify_function(EXP_RESOURCE_TYPE, exp_resource_id)",
            "            initiator = None",
            "            reason = None",
            "            cadf_notify.assert_called_once_with(",
            "                operation, EXP_RESOURCE_TYPE, exp_resource_id,",
            "                notifications.taxonomy.OUTCOME_SUCCESS, initiator, reason)",
            "            notify_function(EXP_RESOURCE_TYPE, exp_resource_id, public=False)",
            "            cadf_notify.assert_called_once_with(",
            "                operation, EXP_RESOURCE_TYPE, exp_resource_id,",
            "                notifications.taxonomy.OUTCOME_SUCCESS, initiator, reason)",
            "",
            "    def test_resource_created_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.created, CREATED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.created, CREATED_OPERATION)",
            "",
            "    def test_resource_updated_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.updated, UPDATED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.updated, UPDATED_OPERATION)",
            "",
            "    def test_resource_deleted_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.deleted, DELETED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.deleted, DELETED_OPERATION)",
            "",
            "    def test_resource_disabled_notification(self):",
            "        self._test_notification_operation_with_basic_format(",
            "            notifications.Audit.disabled, DISABLED_OPERATION)",
            "        self._test_notification_operation_with_cadf_format(",
            "            notifications.Audit.disabled, DISABLED_OPERATION)",
            "",
            "",
            "class NotificationsTestCase(unit.BaseTestCase):",
            "",
            "    def setUp(self):",
            "        super(NotificationsTestCase, self).setUp()",
            "        self.config_fixture = self.useFixture(config_fixture.Config(CONF))",
            "        self.config_fixture.config(",
            "            group='oslo_messaging_notifications', transport_url='rabbit://'",
            "        )",
            "",
            "    def test_send_notification(self):",
            "        \"\"\"Test _send_notification.",
            "",
            "        Test the private method _send_notification to ensure event_type,",
            "        payload, and context are built and passed properly.",
            "",
            "        \"\"\"",
            "        resource = uuid.uuid4().hex",
            "        resource_type = EXP_RESOURCE_TYPE",
            "        operation = CREATED_OPERATION",
            "",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_format='basic')",
            "",
            "        # NOTE(ldbragst): Even though notifications._send_notification doesn't",
            "        # contain logic that creates cases, this is supposed to test that",
            "        # context is always empty and that we ensure the resource ID of the",
            "        # resource in the notification is contained in the payload. It was",
            "        # agreed that context should be empty in Keystone's case, which is",
            "        # also noted in the /keystone/notifications.py module. This test",
            "        # ensures and maintains these conditions.",
            "        expected_args = [",
            "            {},  # empty context",
            "            'identity.%s.created' % resource_type,  # event_type",
            "            {'resource_info': resource}  # payload",
            "        ]",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "            notifications._send_notification(operation, resource_type,",
            "                                             resource)",
            "            mocked.assert_called_once_with(*expected_args)",
            "",
            "    def test_send_notification_with_opt_out(self):",
            "        \"\"\"Test the private method _send_notification with opt-out.",
            "",
            "        Test that _send_notification does not notify when a valid",
            "        notification_opt_out configuration is provided.",
            "        \"\"\"",
            "        resource = uuid.uuid4().hex",
            "        resource_type = EXP_RESOURCE_TYPE",
            "        operation = CREATED_OPERATION",
            "        event_type = 'identity.%s.created' % resource_type",
            "",
            "        # NOTE(diazjf): Here we add notification_opt_out to the",
            "        # configuration so that we should return before _get_notifer is",
            "        # called. This is because we are opting out notifications for the",
            "        # passed resource_type and operation.",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_opt_out=[event_type])",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_notification(operation, resource_type,",
            "                                             resource)",
            "            mocked.assert_not_called()",
            "",
            "    def test_send_audit_notification_with_opt_out(self):",
            "        \"\"\"Test the private method _send_audit_notification with opt-out.",
            "",
            "        Test that _send_audit_notification does not notify when a valid",
            "        notification_opt_out configuration is provided.",
            "        \"\"\"",
            "        resource_type = EXP_RESOURCE_TYPE",
            "",
            "        action = CREATED_OPERATION + '.' + resource_type",
            "        initiator = mock",
            "        target = mock",
            "        outcome = 'success'",
            "        event_type = 'identity.%s.created' % resource_type",
            "",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_opt_out=[event_type])",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_audit_notification(action,",
            "                                                   initiator,",
            "                                                   outcome,",
            "                                                   target,",
            "                                                   event_type)",
            "            mocked.assert_not_called()",
            "",
            "    def test_opt_out_authenticate_event(self):",
            "        \"\"\"Test that authenticate events are successfully opted out.\"\"\"",
            "        resource_type = EXP_RESOURCE_TYPE",
            "",
            "        action = CREATED_OPERATION + '.' + resource_type",
            "        initiator = mock",
            "        target = mock",
            "        outcome = 'success'",
            "        event_type = 'identity.authenticate'",
            "        meter_name = '%s.%s' % (event_type, outcome)",
            "",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_opt_out=[meter_name])",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_audit_notification(action,",
            "                                                   initiator,",
            "                                                   outcome,",
            "                                                   target,",
            "                                                   event_type)",
            "            mocked.assert_not_called()",
            "",
            "",
            "class BaseNotificationTest(test_v3.RestfulTestCase):",
            "",
            "    def setUp(self):",
            "        super(BaseNotificationTest, self).setUp()",
            "",
            "        self._notifications = []",
            "        self._audits = []",
            "",
            "        def fake_notify(operation, resource_type, resource_id, initiator=None,",
            "                        actor_dict=None, public=True):",
            "            note = {",
            "                'resource_id': resource_id,",
            "                'operation': operation,",
            "                'resource_type': resource_type,",
            "                'initiator': initiator,",
            "                'send_notification_called': True,",
            "                'public': public}",
            "            if actor_dict:",
            "                note['actor_id'] = actor_dict.get('id')",
            "                note['actor_type'] = actor_dict.get('type')",
            "                note['actor_operation'] = actor_dict.get('actor_operation')",
            "            self._notifications.append(note)",
            "",
            "        self.useFixture(fixtures.MockPatchObject(",
            "            notifications, '_send_notification', fake_notify))",
            "",
            "        def fake_audit(action, initiator, outcome, target,",
            "                       event_type, reason=None, **kwargs):",
            "            service_security = cadftaxonomy.SERVICE_SECURITY",
            "",
            "            event = eventfactory.EventFactory().new_event(",
            "                eventType=cadftype.EVENTTYPE_ACTIVITY,",
            "                outcome=outcome,",
            "                action=action,",
            "                initiator=initiator,",
            "                target=target,",
            "                reason=reason,",
            "                observer=cadfresource.Resource(typeURI=service_security))",
            "",
            "            for key, value in kwargs.items():",
            "                setattr(event, key, value)",
            "",
            "            payload = event.as_dict()",
            "",
            "            audit = {",
            "                'payload': payload,",
            "                'event_type': event_type,",
            "                'send_notification_called': True}",
            "            self._audits.append(audit)",
            "",
            "        self.useFixture(fixtures.MockPatchObject(",
            "            notifications, '_send_audit_notification', fake_audit))",
            "",
            "    def _assert_last_note(self, resource_id, operation, resource_type,",
            "                          actor_id=None, actor_type=None,",
            "                          actor_operation=None):",
            "        # NOTE(stevemar): If 'basic' format is not used, then simply",
            "        # return since this assertion is not valid.",
            "        if CONF.notification_format != 'basic':",
            "            return",
            "        self.assertGreater(len(self._notifications), 0)",
            "        note = self._notifications[-1]",
            "        self.assertEqual(operation, note['operation'])",
            "        self.assertEqual(resource_id, note['resource_id'])",
            "        self.assertEqual(resource_type, note['resource_type'])",
            "        self.assertTrue(note['send_notification_called'])",
            "        if actor_id:",
            "            self.assertEqual(actor_id, note['actor_id'])",
            "            self.assertEqual(actor_type, note['actor_type'])",
            "            self.assertEqual(actor_operation, note['actor_operation'])",
            "",
            "    def _assert_last_audit(self, resource_id, operation, resource_type,",
            "                           target_uri, reason=None):",
            "        # NOTE(stevemar): If 'cadf' format is not used, then simply",
            "        # return since this assertion is not valid.",
            "        if CONF.notification_format != 'cadf':",
            "            return",
            "        self.assertGreater(len(self._audits), 0)",
            "        audit = self._audits[-1]",
            "        payload = audit['payload']",
            "        if 'resource_info' in payload:",
            "            self.assertEqual(resource_id, payload['resource_info'])",
            "        action = '.'.join(filter(None, [operation, resource_type]))",
            "        self.assertEqual(action, payload['action'])",
            "        self.assertEqual(target_uri, payload['target']['typeURI'])",
            "        if resource_id:",
            "            self.assertEqual(resource_id, payload['target']['id'])",
            "        event_type = '.'.join(filter(None, ['identity',",
            "                                            resource_type,",
            "                                            operation]))",
            "        self.assertEqual(event_type, audit['event_type'])",
            "        if reason:",
            "            self.assertEqual(reason['reasonCode'],",
            "                             payload['reason']['reasonCode'])",
            "            self.assertEqual(reason['reasonType'],",
            "                             payload['reason']['reasonType'])",
            "        self.assertTrue(audit['send_notification_called'])",
            "",
            "    def _assert_initiator_data_is_set(self, operation, resource_type, typeURI):",
            "        self.assertGreater(len(self._audits), 0)",
            "        audit = self._audits[-1]",
            "        payload = audit['payload']",
            "        self.assertEqual(self.user_id, payload['initiator']['id'])",
            "        self.assertEqual(self.project_id, payload['initiator']['project_id'])",
            "        self.assertEqual(typeURI, payload['target']['typeURI'])",
            "        self.assertIn('request_id', payload['initiator'])",
            "        action = '%s.%s' % (operation, resource_type)",
            "        self.assertEqual(action, payload['action'])",
            "",
            "    def _assert_notify_not_sent(self, resource_id, operation, resource_type,",
            "                                public=True):",
            "        unexpected = {",
            "            'resource_id': resource_id,",
            "            'operation': operation,",
            "            'resource_type': resource_type,",
            "            'send_notification_called': True,",
            "            'public': public}",
            "        for note in self._notifications:",
            "            self.assertNotEqual(unexpected, note)",
            "",
            "    def _assert_notify_sent(self, resource_id, operation, resource_type,",
            "                            public=True):",
            "        expected = {",
            "            'resource_id': resource_id,",
            "            'operation': operation,",
            "            'resource_type': resource_type,",
            "            'send_notification_called': True,",
            "            'public': public}",
            "        for note in self._notifications:",
            "            # compare only expected fields",
            "            if all(note.get(k) == v for k, v in expected.items()):",
            "                break",
            "        else:",
            "            self.fail(\"Notification not sent.\")",
            "",
            "",
            "class NotificationsForEntities(BaseNotificationTest):",
            "",
            "    def test_create_group(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        self._assert_last_note(group_ref['id'], CREATED_OPERATION, 'group')",
            "        self._assert_last_audit(group_ref['id'], CREATED_OPERATION, 'group',",
            "                                cadftaxonomy.SECURITY_GROUP)",
            "",
            "    def test_create_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self._assert_last_note(",
            "            project_ref['id'], CREATED_OPERATION, 'project')",
            "        self._assert_last_audit(project_ref['id'], CREATED_OPERATION,",
            "                                'project', cadftaxonomy.SECURITY_PROJECT)",
            "",
            "    def test_create_role(self):",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        self._assert_last_note(role_ref['id'], CREATED_OPERATION, 'role')",
            "        self._assert_last_audit(role_ref['id'], CREATED_OPERATION, 'role',",
            "                                cadftaxonomy.SECURITY_ROLE)",
            "",
            "    def test_create_user(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        self._assert_last_note(user_ref['id'], CREATED_OPERATION, 'user')",
            "        self._assert_last_audit(user_ref['id'], CREATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER)",
            "",
            "    def test_create_trust(self):",
            "        trustor = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustor = PROVIDERS.identity_api.create_user(trustor)",
            "        trustee = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustee = PROVIDERS.identity_api.create_user(trustee)",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        trust_ref = unit.new_trust_ref(trustor['id'],",
            "                                       trustee['id'])",
            "        PROVIDERS.trust_api.create_trust(",
            "            trust_ref['id'], trust_ref, [role_ref]",
            "        )",
            "        self._assert_last_note(",
            "            trust_ref['id'], CREATED_OPERATION, 'OS-TRUST:trust')",
            "        self._assert_last_audit(trust_ref['id'], CREATED_OPERATION,",
            "                                'OS-TRUST:trust', cadftaxonomy.SECURITY_TRUST)",
            "",
            "    def test_delete_group(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.delete_group(group_ref['id'])",
            "        self._assert_last_note(group_ref['id'], DELETED_OPERATION, 'group')",
            "        self._assert_last_audit(group_ref['id'], DELETED_OPERATION, 'group',",
            "                                cadftaxonomy.SECURITY_GROUP)",
            "",
            "    def test_delete_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        PROVIDERS.resource_api.delete_project(project_ref['id'])",
            "        self._assert_last_note(",
            "            project_ref['id'], DELETED_OPERATION, 'project')",
            "        self._assert_last_audit(project_ref['id'], DELETED_OPERATION,",
            "                                'project', cadftaxonomy.SECURITY_PROJECT)",
            "",
            "    def test_delete_role(self):",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        PROVIDERS.role_api.delete_role(role_ref['id'])",
            "        self._assert_last_note(role_ref['id'], DELETED_OPERATION, 'role')",
            "        self._assert_last_audit(role_ref['id'], DELETED_OPERATION, 'role',",
            "                                cadftaxonomy.SECURITY_ROLE)",
            "",
            "    def test_delete_user(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        PROVIDERS.identity_api.delete_user(user_ref['id'])",
            "        self._assert_last_note(user_ref['id'], DELETED_OPERATION, 'user')",
            "        self._assert_last_audit(user_ref['id'], DELETED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER)",
            "",
            "    def test_create_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        self._assert_last_note(domain_ref['id'], CREATED_OPERATION, 'domain')",
            "        self._assert_last_audit(domain_ref['id'], CREATED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_update_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        domain_ref['description'] = uuid.uuid4().hex",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        self._assert_last_note(domain_ref['id'], UPDATED_OPERATION, 'domain')",
            "        self._assert_last_audit(domain_ref['id'], UPDATED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_delete_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        domain_ref['enabled'] = False",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        PROVIDERS.resource_api.delete_domain(domain_ref['id'])",
            "        self._assert_last_note(domain_ref['id'], DELETED_OPERATION, 'domain')",
            "        self._assert_last_audit(domain_ref['id'], DELETED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_delete_trust(self):",
            "        trustor = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustor = PROVIDERS.identity_api.create_user(trustor)",
            "        trustee = unit.new_user_ref(domain_id=self.domain_id)",
            "        trustee = PROVIDERS.identity_api.create_user(trustee)",
            "        role_ref = unit.new_role_ref()",
            "        trust_ref = unit.new_trust_ref(trustor['id'], trustee['id'])",
            "        PROVIDERS.trust_api.create_trust(",
            "            trust_ref['id'], trust_ref, [role_ref]",
            "        )",
            "        PROVIDERS.trust_api.delete_trust(trust_ref['id'])",
            "        self._assert_last_note(",
            "            trust_ref['id'], DELETED_OPERATION, 'OS-TRUST:trust')",
            "        self._assert_last_audit(trust_ref['id'], DELETED_OPERATION,",
            "                                'OS-TRUST:trust', cadftaxonomy.SECURITY_TRUST)",
            "",
            "    def test_create_endpoint(self):",
            "        endpoint_ref = unit.new_endpoint_ref(service_id=self.service_id,",
            "                                             interface='public',",
            "                                             region_id=self.region_id)",
            "        PROVIDERS.catalog_api.create_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        self._assert_notify_sent(endpoint_ref['id'], CREATED_OPERATION,",
            "                                 'endpoint')",
            "        self._assert_last_audit(endpoint_ref['id'], CREATED_OPERATION,",
            "                                'endpoint', cadftaxonomy.SECURITY_ENDPOINT)",
            "",
            "    def test_update_endpoint(self):",
            "        endpoint_ref = unit.new_endpoint_ref(service_id=self.service_id,",
            "                                             interface='public',",
            "                                             region_id=self.region_id)",
            "        PROVIDERS.catalog_api.create_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        PROVIDERS.catalog_api.update_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        self._assert_notify_sent(endpoint_ref['id'], UPDATED_OPERATION,",
            "                                 'endpoint')",
            "        self._assert_last_audit(endpoint_ref['id'], UPDATED_OPERATION,",
            "                                'endpoint', cadftaxonomy.SECURITY_ENDPOINT)",
            "",
            "    def test_delete_endpoint(self):",
            "        endpoint_ref = unit.new_endpoint_ref(service_id=self.service_id,",
            "                                             interface='public',",
            "                                             region_id=self.region_id)",
            "        PROVIDERS.catalog_api.create_endpoint(endpoint_ref['id'], endpoint_ref)",
            "        PROVIDERS.catalog_api.delete_endpoint(endpoint_ref['id'])",
            "        self._assert_notify_sent(endpoint_ref['id'], DELETED_OPERATION,",
            "                                 'endpoint')",
            "        self._assert_last_audit(endpoint_ref['id'], DELETED_OPERATION,",
            "                                'endpoint', cadftaxonomy.SECURITY_ENDPOINT)",
            "",
            "    def test_create_service(self):",
            "        service_ref = unit.new_service_ref()",
            "        PROVIDERS.catalog_api.create_service(service_ref['id'], service_ref)",
            "        self._assert_notify_sent(service_ref['id'], CREATED_OPERATION,",
            "                                 'service')",
            "        self._assert_last_audit(service_ref['id'], CREATED_OPERATION,",
            "                                'service', cadftaxonomy.SECURITY_SERVICE)",
            "",
            "    def test_update_service(self):",
            "        service_ref = unit.new_service_ref()",
            "        PROVIDERS.catalog_api.create_service(service_ref['id'], service_ref)",
            "        PROVIDERS.catalog_api.update_service(service_ref['id'], service_ref)",
            "        self._assert_notify_sent(service_ref['id'], UPDATED_OPERATION,",
            "                                 'service')",
            "        self._assert_last_audit(service_ref['id'], UPDATED_OPERATION,",
            "                                'service', cadftaxonomy.SECURITY_SERVICE)",
            "",
            "    def test_delete_service(self):",
            "        service_ref = unit.new_service_ref()",
            "        PROVIDERS.catalog_api.create_service(service_ref['id'], service_ref)",
            "        PROVIDERS.catalog_api.delete_service(service_ref['id'])",
            "        self._assert_notify_sent(service_ref['id'], DELETED_OPERATION,",
            "                                 'service')",
            "        self._assert_last_audit(service_ref['id'], DELETED_OPERATION,",
            "                                'service', cadftaxonomy.SECURITY_SERVICE)",
            "",
            "    def test_create_region(self):",
            "        region_ref = unit.new_region_ref()",
            "        PROVIDERS.catalog_api.create_region(region_ref)",
            "        self._assert_notify_sent(region_ref['id'], CREATED_OPERATION,",
            "                                 'region')",
            "        self._assert_last_audit(region_ref['id'], CREATED_OPERATION,",
            "                                'region', cadftaxonomy.SECURITY_REGION)",
            "",
            "    def test_update_region(self):",
            "        region_ref = unit.new_region_ref()",
            "        PROVIDERS.catalog_api.create_region(region_ref)",
            "        PROVIDERS.catalog_api.update_region(region_ref['id'], region_ref)",
            "        self._assert_notify_sent(region_ref['id'], UPDATED_OPERATION,",
            "                                 'region')",
            "        self._assert_last_audit(region_ref['id'], UPDATED_OPERATION,",
            "                                'region', cadftaxonomy.SECURITY_REGION)",
            "",
            "    def test_delete_region(self):",
            "        region_ref = unit.new_region_ref()",
            "        PROVIDERS.catalog_api.create_region(region_ref)",
            "        PROVIDERS.catalog_api.delete_region(region_ref['id'])",
            "        self._assert_notify_sent(region_ref['id'], DELETED_OPERATION,",
            "                                 'region')",
            "        self._assert_last_audit(region_ref['id'], DELETED_OPERATION,",
            "                                'region', cadftaxonomy.SECURITY_REGION)",
            "",
            "    def test_create_policy(self):",
            "        policy_ref = unit.new_policy_ref()",
            "        PROVIDERS.policy_api.create_policy(policy_ref['id'], policy_ref)",
            "        self._assert_notify_sent(policy_ref['id'], CREATED_OPERATION,",
            "                                 'policy')",
            "        self._assert_last_audit(policy_ref['id'], CREATED_OPERATION,",
            "                                'policy', cadftaxonomy.SECURITY_POLICY)",
            "",
            "    def test_update_policy(self):",
            "        policy_ref = unit.new_policy_ref()",
            "        PROVIDERS.policy_api.create_policy(policy_ref['id'], policy_ref)",
            "        PROVIDERS.policy_api.update_policy(policy_ref['id'], policy_ref)",
            "        self._assert_notify_sent(policy_ref['id'], UPDATED_OPERATION,",
            "                                 'policy')",
            "        self._assert_last_audit(policy_ref['id'], UPDATED_OPERATION,",
            "                                'policy', cadftaxonomy.SECURITY_POLICY)",
            "",
            "    def test_delete_policy(self):",
            "        policy_ref = unit.new_policy_ref()",
            "        PROVIDERS.policy_api.create_policy(policy_ref['id'], policy_ref)",
            "        PROVIDERS.policy_api.delete_policy(policy_ref['id'])",
            "        self._assert_notify_sent(policy_ref['id'], DELETED_OPERATION,",
            "                                 'policy')",
            "        self._assert_last_audit(policy_ref['id'], DELETED_OPERATION,",
            "                                'policy', cadftaxonomy.SECURITY_POLICY)",
            "",
            "    def test_disable_domain(self):",
            "        domain_ref = unit.new_domain_ref()",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        domain_ref['enabled'] = False",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        self._assert_notify_sent(domain_ref['id'], 'disabled', 'domain',",
            "                                 public=False)",
            "",
            "    def test_disable_of_disabled_domain_does_not_notify(self):",
            "        domain_ref = unit.new_domain_ref(enabled=False)",
            "        PROVIDERS.resource_api.create_domain(domain_ref['id'], domain_ref)",
            "        # The domain_ref above is not changed during the create process. We",
            "        # can use the same ref to perform the update.",
            "        PROVIDERS.resource_api.update_domain(domain_ref['id'], domain_ref)",
            "        self._assert_notify_not_sent(domain_ref['id'], 'disabled', 'domain',",
            "                                     public=False)",
            "",
            "    def test_update_group(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.update_group(group_ref['id'], group_ref)",
            "        self._assert_last_note(group_ref['id'], UPDATED_OPERATION, 'group')",
            "        self._assert_last_audit(group_ref['id'], UPDATED_OPERATION, 'group',",
            "                                cadftaxonomy.SECURITY_GROUP)",
            "",
            "    def test_update_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_notify_sent(",
            "            project_ref['id'], UPDATED_OPERATION, 'project', public=True)",
            "        self._assert_last_audit(project_ref['id'], UPDATED_OPERATION,",
            "                                'project', cadftaxonomy.SECURITY_PROJECT)",
            "",
            "    def test_disable_project(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        project_ref['enabled'] = False",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_notify_sent(project_ref['id'], 'disabled', 'project',",
            "                                 public=False)",
            "",
            "    def test_disable_of_disabled_project_does_not_notify(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id,",
            "                                           enabled=False)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        # The project_ref above is not changed during the create process. We",
            "        # can use the same ref to perform the update.",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_notify_not_sent(project_ref['id'], 'disabled', 'project',",
            "                                     public=False)",
            "",
            "    def test_update_project_does_not_send_disable(self):",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        project_ref['enabled'] = True",
            "        PROVIDERS.resource_api.update_project(project_ref['id'], project_ref)",
            "        self._assert_last_note(",
            "            project_ref['id'], UPDATED_OPERATION, 'project')",
            "        self._assert_notify_not_sent(project_ref['id'], 'disabled', 'project')",
            "",
            "    def test_update_role(self):",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        PROVIDERS.role_api.update_role(role_ref['id'], role_ref)",
            "        self._assert_last_note(role_ref['id'], UPDATED_OPERATION, 'role')",
            "        self._assert_last_audit(role_ref['id'], UPDATED_OPERATION, 'role',",
            "                                cadftaxonomy.SECURITY_ROLE)",
            "",
            "    def test_update_user(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        PROVIDERS.identity_api.update_user(user_ref['id'], user_ref)",
            "        self._assert_last_note(user_ref['id'], UPDATED_OPERATION, 'user')",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER)",
            "",
            "    def test_config_option_no_events(self):",
            "        self.config_fixture.config(notification_format='basic')",
            "        role_ref = unit.new_role_ref()",
            "        PROVIDERS.role_api.create_role(role_ref['id'], role_ref)",
            "        # The regular notifications will still be emitted, since they are",
            "        # used for callback handling.",
            "        self._assert_last_note(role_ref['id'], CREATED_OPERATION, 'role')",
            "        # No audit event should have occurred",
            "        self.assertEqual(0, len(self._audits))",
            "",
            "    def test_add_user_to_group(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.add_user_to_group(",
            "            user_ref['id'], group_ref['id']",
            "        )",
            "        self._assert_last_note(group_ref['id'], UPDATED_OPERATION, 'group',",
            "                               actor_id=user_ref['id'], actor_type='user',",
            "                               actor_operation='added')",
            "",
            "    def test_remove_user_from_group(self):",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group_ref = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.add_user_to_group(",
            "            user_ref['id'], group_ref['id']",
            "        )",
            "        PROVIDERS.identity_api.remove_user_from_group(",
            "            user_ref['id'], group_ref['id']",
            "        )",
            "        self._assert_last_note(group_ref['id'], UPDATED_OPERATION, 'group',",
            "                               actor_id=user_ref['id'], actor_type='user',",
            "                               actor_operation='removed')",
            "",
            "    def test_initiator_request_id(self):",
            "        ref = unit.new_domain_ref()",
            "        self.post('/domains', body={'domain': ref})",
            "        note = self._notifications[-1]",
            "        initiator = note['initiator']",
            "        self.assertIsNotNone(initiator.request_id)",
            "",
            "    def test_initiator_global_request_id(self):",
            "        global_request_id = 'req-%s' % uuid.uuid4()",
            "        ref = unit.new_domain_ref()",
            "        self.post('/domains', body={'domain': ref},",
            "                  headers={'X-OpenStack-Request-Id': global_request_id})",
            "        note = self._notifications[-1]",
            "        initiator = note['initiator']",
            "        self.assertEqual(",
            "            initiator.global_request_id, global_request_id)",
            "",
            "    def test_initiator_global_request_id_not_set(self):",
            "        ref = unit.new_domain_ref()",
            "        self.post('/domains', body={'domain': ref})",
            "        note = self._notifications[-1]",
            "        initiator = note['initiator']",
            "        self.assertFalse(hasattr(initiator, 'global_request_id'))",
            "",
            "",
            "class CADFNotificationsForPCIDSSEvents(BaseNotificationTest):",
            "",
            "    def setUp(self):",
            "        super(CADFNotificationsForPCIDSSEvents, self).setUp()",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(notification_format='cadf')",
            "        conf.config(group='security_compliance',",
            "                    password_expires_days=2)",
            "        conf.config(group='security_compliance',",
            "                    lockout_failure_attempts=3)",
            "        conf.config(group='security_compliance',",
            "                    unique_last_password_count=2)",
            "        conf.config(group='security_compliance',",
            "                    minimum_password_age=2)",
            "        conf.config(group='security_compliance',",
            "                    password_regex='^(?=.*\\d)(?=.*[a-zA-Z]).{7,}$')",
            "        conf.config(group='security_compliance',",
            "                    password_regex_description='1 letter, 1 digit, 7 chars')",
            "",
            "    def test_password_expired_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        password_creation_time = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days + 1)",
            "        )",
            "        freezer = freezegun.freeze_time(password_creation_time)",
            "",
            "        # NOTE(gagehugo): This part below uses freezegun to spoof",
            "        # the time as being three days in the past from right now. We will",
            "        # create a user and have that user successfully authenticate,",
            "        # then stop the time machine and return to the present time,",
            "        # where the user's password is now expired.",
            "        freezer.start()",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.authenticate(user_ref['id'], password)",
            "        freezer.stop()",
            "",
            "        reason_type = (exception.PasswordExpired.message_format %",
            "                       {'user_id': user_ref['id']})",
            "        expected_reason = {'reasonCode': '401',",
            "                           'reasonType': reason_type}",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user_ref['id'],",
            "                              password=password)",
            "        self._assert_last_audit(None, 'authenticate', None,",
            "                                cadftaxonomy.ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_locked_out_user_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        new_password = uuid.uuid4().hex",
            "        expected_responses = [AssertionError, AssertionError, AssertionError,",
            "                              exception.Unauthorized]",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        reason_type = (exception.AccountLocked.message_format %",
            "                       {'user_id': user_ref['id']})",
            "        expected_reason = {'reasonCode': '401',",
            "                           'reasonType': reason_type}",
            "        for ex in expected_responses:",
            "            with self.make_request():",
            "                self.assertRaises(ex,",
            "                                  PROVIDERS.identity_api.change_password,",
            "                                  user_id=user_ref['id'],",
            "                                  original_password=new_password,",
            "                                  new_password=new_password)",
            "",
            "        self._assert_last_audit(None, 'authenticate', None,",
            "                                cadftaxonomy.ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_repeated_password_sends_notification(self):",
            "        conf = self.useFixture(config_fixture.Config(CONF))",
            "        conf.config(group='security_compliance',",
            "                    minimum_password_age=0)",
            "        password = uuid.uuid4().hex",
            "        new_password = uuid.uuid4().hex",
            "        count = CONF.security_compliance.unique_last_password_count",
            "        reason_type = (exception.PasswordHistoryValidationError.message_format",
            "                       % {'unique_count': count})",
            "        expected_reason = {'reasonCode': '400',",
            "                           'reasonType': reason_type}",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_ref['id'],",
            "                original_password=password, new_password=new_password",
            "            )",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user_ref['id'],",
            "                              original_password=new_password,",
            "                              new_password=password)",
            "",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_invalid_password_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        invalid_password = '1'",
            "        regex = CONF.security_compliance.password_regex_description",
            "        reason_type = (exception.PasswordRequirementsValidationError",
            "                       .message_format %",
            "                       {'detail': regex})",
            "        expected_reason = {'reasonCode': '400',",
            "                           'reasonType': reason_type}",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password)",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user_ref['id'],",
            "                              original_password=password,",
            "                              new_password=invalid_password)",
            "",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "    def test_changing_password_too_early_sends_notification(self):",
            "        password = uuid.uuid4().hex",
            "        new_password = uuid.uuid4().hex",
            "        next_password = uuid.uuid4().hex",
            "",
            "        user_ref = unit.new_user_ref(domain_id=self.domain_id,",
            "                                     password=password,",
            "                                     password_created_at=(",
            "                                         datetime.datetime.utcnow()))",
            "        user_ref = PROVIDERS.identity_api.create_user(user_ref)",
            "",
            "        min_days = CONF.security_compliance.minimum_password_age",
            "        min_age = (user_ref['password_created_at'] +",
            "                   datetime.timedelta(days=min_days))",
            "        days_left = (min_age - datetime.datetime.utcnow()).days",
            "        reason_type = (exception.PasswordAgeValidationError.message_format %",
            "                       {'min_age_days': min_days, 'days_left': days_left})",
            "        expected_reason = {'reasonCode': '400',",
            "                           'reasonType': reason_type}",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_ref['id'],",
            "                original_password=password, new_password=new_password",
            "            )",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user_ref['id'],",
            "                              original_password=new_password,",
            "                              new_password=next_password)",
            "",
            "        self._assert_last_audit(user_ref['id'], UPDATED_OPERATION, 'user',",
            "                                cadftaxonomy.SECURITY_ACCOUNT_USER,",
            "                                reason=expected_reason)",
            "",
            "",
            "class CADFNotificationsForEntities(NotificationsForEntities):",
            "",
            "    def setUp(self):",
            "        super(CADFNotificationsForEntities, self).setUp()",
            "        self.config_fixture.config(notification_format='cadf')",
            "",
            "    def test_initiator_data_is_set(self):",
            "        ref = unit.new_domain_ref()",
            "        resp = self.post('/domains', body={'domain': ref})",
            "        resource_id = resp.result.get('domain').get('id')",
            "        self._assert_last_audit(resource_id, CREATED_OPERATION, 'domain',",
            "                                cadftaxonomy.SECURITY_DOMAIN)",
            "        self._assert_initiator_data_is_set(CREATED_OPERATION,",
            "                                           'domain',",
            "                                           cadftaxonomy.SECURITY_DOMAIN)",
            "",
            "    def test_initiator_request_id(self):",
            "        data = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.user['password'])",
            "        self.post('/auth/tokens', body=data)",
            "        audit = self._audits[-1]",
            "        initiator = audit['payload']['initiator']",
            "        self.assertIn('request_id', initiator)",
            "",
            "    def test_initiator_global_request_id(self):",
            "        global_request_id = 'req-%s' % uuid.uuid4()",
            "        data = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.user['password'])",
            "        self.post(",
            "            '/auth/tokens', body=data,",
            "            headers={'X-OpenStack-Request-Id': global_request_id})",
            "        audit = self._audits[-1]",
            "        initiator = audit['payload']['initiator']",
            "        self.assertEqual(",
            "            initiator['global_request_id'], global_request_id)",
            "",
            "    def test_initiator_global_request_id_not_set(self):",
            "        data = self.build_authentication_request(",
            "            user_id=self.user_id,",
            "            password=self.user['password'])",
            "        self.post('/auth/tokens', body=data)",
            "        audit = self._audits[-1]",
            "        initiator = audit['payload']['initiator']",
            "        self.assertNotIn('global_request_id', initiator)",
            "",
            "",
            "class TestEventCallbacks(test_v3.RestfulTestCase):",
            "",
            "    class FakeManager(object):",
            "",
            "        def _project_deleted_callback(self, service, resource_type, operation,",
            "                                      payload):",
            "            \"\"\"Used just for the callback interface.\"\"\"",
            "",
            "    def test_notification_received(self):",
            "        callback = register_callback(CREATED_OPERATION, 'project')",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self.assertTrue(callback.called)",
            "",
            "    def test_notification_method_not_callable(self):",
            "        fake_method = None",
            "        self.assertRaises(TypeError,",
            "                          notifications.register_event_callback,",
            "                          UPDATED_OPERATION,",
            "                          'project',",
            "                          [fake_method])",
            "",
            "    def test_notification_event_not_valid(self):",
            "        manager = self.FakeManager()",
            "        self.assertRaises(ValueError,",
            "                          notifications.register_event_callback,",
            "                          uuid.uuid4().hex,",
            "                          'project',",
            "                          manager._project_deleted_callback)",
            "",
            "    def test_event_registration_for_unknown_resource_type(self):",
            "        # Registration for unknown resource types should succeed.  If no event",
            "        # is issued for that resource type, the callback wont be triggered.",
            "",
            "        manager = self.FakeManager()",
            "",
            "        notifications.register_event_callback(",
            "            DELETED_OPERATION,",
            "            uuid.uuid4().hex,",
            "            manager._project_deleted_callback)",
            "        resource_type = uuid.uuid4().hex",
            "        notifications.register_event_callback(",
            "            DELETED_OPERATION,",
            "            resource_type,",
            "            manager._project_deleted_callback)",
            "",
            "    def test_provider_event_callback_subscription(self):",
            "        callback_called = []",
            "",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {",
            "                    CREATED_OPERATION: {'project': self.foo_callback}}",
            "",
            "            def foo_callback(self, service, resource_type, operation,",
            "                             payload):",
            "                # uses callback_called from the closure",
            "                callback_called.append(True)",
            "",
            "        Foo()",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self.assertEqual([True], callback_called)",
            "",
            "    def test_provider_event_callbacks_subscription(self):",
            "        callback_called = []",
            "",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {",
            "                    CREATED_OPERATION: {",
            "                        'project': [self.callback_0, self.callback_1]}}",
            "",
            "            def callback_0(self, service, resource_type, operation, payload):",
            "                # uses callback_called from the closure",
            "                callback_called.append('cb0')",
            "",
            "            def callback_1(self, service, resource_type, operation, payload):",
            "                # uses callback_called from the closure",
            "                callback_called.append('cb1')",
            "",
            "        Foo()",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        PROVIDERS.resource_api.create_project(project_ref['id'], project_ref)",
            "        self.assertItemsEqual(['cb1', 'cb0'], callback_called)",
            "",
            "    def test_invalid_event_callbacks(self):",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = 'bogus'",
            "",
            "        self.assertRaises(AttributeError, Foo)",
            "",
            "    def test_invalid_event_callbacks_event(self):",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {CREATED_OPERATION: 'bogus'}",
            "",
            "        self.assertRaises(AttributeError, Foo)",
            "",
            "    def test_using_an_unbound_method_as_a_callback_fails(self):",
            "        # NOTE(dstanek): An unbound method is when you reference a method",
            "        # from a class object. You'll get a method that isn't bound to a",
            "        # particular instance so there is no magic 'self'. You can call it,",
            "        # but you have to pass in the instance manually like: C.m(C()).",
            "        # If you reference the method from an instance then you get a method",
            "        # that effectively curries the self argument for you",
            "        # (think functools.partial). Obviously is we don't have an",
            "        # instance then we can't call the method.",
            "        @notifications.listener",
            "        class Foo(object):",
            "            def __init__(self):",
            "                self.event_callbacks = {CREATED_OPERATION:",
            "                                        {'project': Foo.callback}}",
            "",
            "            def callback(self, service, resource_type, operation, payload):",
            "                pass",
            "",
            "        # TODO(dstanek): it would probably be nice to fail early using",
            "        # something like:",
            "        #     self.assertRaises(TypeError, Foo)",
            "        Foo()",
            "        project_ref = unit.new_project_ref(domain_id=self.domain_id)",
            "        self.assertRaises(TypeError, PROVIDERS.resource_api.create_project,",
            "                          project_ref['id'], project_ref)",
            "",
            "",
            "class CadfNotificationsWrapperTestCase(test_v3.RestfulTestCase):",
            "",
            "    LOCAL_HOST = 'localhost'",
            "    ACTION = 'authenticate'",
            "    ROLE_ASSIGNMENT = 'role_assignment'",
            "",
            "    def setUp(self):",
            "        super(CadfNotificationsWrapperTestCase, self).setUp()",
            "        self._notifications = []",
            "",
            "        def fake_notify(action, initiator, outcome, target,",
            "                        event_type, reason=None, **kwargs):",
            "            service_security = cadftaxonomy.SERVICE_SECURITY",
            "",
            "            event = eventfactory.EventFactory().new_event(",
            "                eventType=cadftype.EVENTTYPE_ACTIVITY,",
            "                outcome=outcome,",
            "                action=action,",
            "                initiator=initiator,",
            "                target=target,",
            "                reason=reason,",
            "                observer=cadfresource.Resource(typeURI=service_security))",
            "",
            "            for key, value in kwargs.items():",
            "                setattr(event, key, value)",
            "",
            "            note = {",
            "                'action': action,",
            "                'initiator': initiator,",
            "                'event': event,",
            "                'event_type': event_type,",
            "                'send_notification_called': True}",
            "            self._notifications.append(note)",
            "",
            "        self.useFixture(fixtures.MockPatchObject(",
            "            notifications, '_send_audit_notification', fake_notify))",
            "",
            "    def _get_last_note(self):",
            "        self.assertTrue(self._notifications)",
            "        return self._notifications[-1]",
            "",
            "    def _assert_last_note(self, action, user_id, event_type=None):",
            "        self.assertTrue(self._notifications)",
            "        note = self._notifications[-1]",
            "        self.assertEqual(action, note['action'])",
            "        initiator = note['initiator']",
            "        self.assertEqual(user_id, initiator.id)",
            "        self.assertEqual(self.LOCAL_HOST, initiator.host.address)",
            "        self.assertTrue(note['send_notification_called'])",
            "        if event_type:",
            "            self.assertEqual(event_type, note['event_type'])",
            "",
            "    def _assert_event(self, role_id, project=None, domain=None,",
            "                      user=None, group=None, inherit=False):",
            "        \"\"\"Assert that the CADF event is valid.",
            "",
            "        In the case of role assignments, the event will have extra data,",
            "        specifically, the role, target, actor, and if the role is inherited.",
            "",
            "        An example event, as a dictionary is seen below:",
            "            {",
            "                'typeURI': 'http://schemas.dmtf.org/cloud/audit/1.0/event',",
            "                'initiator': {",
            "                    'typeURI': 'service/security/account/user',",
            "                    'host': {'address': 'localhost'},",
            "                    'id': 'openstack:0a90d95d-582c-4efb-9cbc-e2ca7ca9c341',",
            "                    'username': u'admin'",
            "                },",
            "                'target': {",
            "                    'typeURI': 'service/security/account/user',",
            "                    'id': 'openstack:d48ea485-ef70-4f65-8d2b-01aa9d7ec12d'",
            "                },",
            "                'observer': {",
            "                    'typeURI': 'service/security',",
            "                    'id': 'openstack:d51dd870-d929-4aba-8d75-dcd7555a0c95'",
            "                },",
            "                'eventType': 'activity',",
            "                'eventTime': '2014-08-21T21:04:56.204536+0000',",
            "                'role': u'0e6b990380154a2599ce6b6e91548a68',",
            "                'domain': u'24bdcff1aab8474895dbaac509793de1',",
            "                'inherited_to_projects': False,",
            "                'group': u'c1e22dc67cbd469ea0e33bf428fe597a',",
            "                'action': 'created.role_assignment',",
            "                'outcome': 'success',",
            "                'id': 'openstack:782689dd-f428-4f13-99c7-5c70f94a5ac1'",
            "            }",
            "        \"\"\"",
            "        note = self._notifications[-1]",
            "        event = note['event']",
            "        if project:",
            "            self.assertEqual(project, event.project)",
            "        if domain:",
            "            self.assertEqual(domain, event.domain)",
            "        if group:",
            "            self.assertEqual(group, event.group)",
            "        elif user:",
            "            self.assertEqual(user, event.user)",
            "        self.assertEqual(role_id, event.role)",
            "        self.assertEqual(inherit, event.inherited_to_projects)",
            "",
            "    def test_initiator_id_always_matches_user_id(self):",
            "        # Clear notifications",
            "        while self._notifications:",
            "            self._notifications.pop()",
            "",
            "        self.get_scoped_token()",
            "        self.assertEqual(len(self._notifications), 1)",
            "        note = self._notifications.pop()",
            "        initiator = note['initiator']",
            "        self.assertEqual(self.user_id, initiator.id)",
            "        self.assertEqual(self.user_id, initiator.user_id)",
            "",
            "    def test_initiator_always_contains_username(self):",
            "        # Clear notifications",
            "        while self._notifications:",
            "            self._notifications.pop()",
            "",
            "        self.get_scoped_token()",
            "        self.assertEqual(len(self._notifications), 1)",
            "        note = self._notifications.pop()",
            "        initiator = note['initiator']",
            "        self.assertEqual(self.user['name'], initiator.username)",
            "",
            "    def test_v3_authenticate_user_name_and_domain_id(self):",
            "        user_id = self.user_id",
            "        user_name = self.user['name']",
            "        password = self.user['password']",
            "        domain_id = self.domain_id",
            "        data = self.build_authentication_request(username=user_name,",
            "                                                 user_domain_id=domain_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data)",
            "        self._assert_last_note(self.ACTION, user_id)",
            "",
            "    def test_v3_authenticate_user_id(self):",
            "        user_id = self.user_id",
            "        password = self.user['password']",
            "        data = self.build_authentication_request(user_id=user_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data)",
            "        self._assert_last_note(self.ACTION, user_id)",
            "",
            "    def test_v3_authenticate_with_invalid_user_id_sends_notification(self):",
            "        user_id = uuid.uuid4().hex",
            "        password = self.user['password']",
            "        data = self.build_authentication_request(user_id=user_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data,",
            "                  expected_status=http_client.UNAUTHORIZED)",
            "        note = self._get_last_note()",
            "        initiator = note['initiator']",
            "",
            "        # Confirm user-name specific event was emitted.",
            "        self.assertEqual(self.ACTION, note['action'])",
            "        self.assertEqual(user_id, initiator.user_id)",
            "        self.assertTrue(note['send_notification_called'])",
            "        self.assertEqual(cadftaxonomy.OUTCOME_FAILURE, note['event'].outcome)",
            "        self.assertEqual(self.LOCAL_HOST, initiator.host.address)",
            "",
            "    def test_v3_authenticate_with_invalid_user_name_sends_notification(self):",
            "        user_name = uuid.uuid4().hex",
            "        password = self.user['password']",
            "        domain_id = self.domain_id",
            "        data = self.build_authentication_request(username=user_name,",
            "                                                 user_domain_id=domain_id,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data,",
            "                  expected_status=http_client.UNAUTHORIZED)",
            "        note = self._get_last_note()",
            "        initiator = note['initiator']",
            "",
            "        # Confirm user-name specific event was emitted.",
            "        self.assertEqual(self.ACTION, note['action'])",
            "        self.assertEqual(user_name, initiator.user_name)",
            "        self.assertEqual(domain_id, initiator.domain_id)",
            "        self.assertTrue(note['send_notification_called'])",
            "        self.assertEqual(cadftaxonomy.OUTCOME_FAILURE, note['event'].outcome)",
            "        self.assertEqual(self.LOCAL_HOST, initiator.host.address)",
            "",
            "    def test_v3_authenticate_user_name_and_domain_name(self):",
            "        user_id = self.user_id",
            "        user_name = self.user['name']",
            "        password = self.user['password']",
            "        domain_name = self.domain['name']",
            "        data = self.build_authentication_request(username=user_name,",
            "                                                 user_domain_name=domain_name,",
            "                                                 password=password)",
            "        self.post('/auth/tokens', body=data)",
            "        self._assert_last_note(self.ACTION, user_id)",
            "",
            "    def _test_role_assignment(self, url, role, project=None, domain=None,",
            "                              user=None, group=None):",
            "        self.put(url)",
            "        action = \"%s.%s\" % (CREATED_OPERATION, self.ROLE_ASSIGNMENT)",
            "        event_type = '%s.%s.%s' % (notifications.SERVICE,",
            "                                   self.ROLE_ASSIGNMENT, CREATED_OPERATION)",
            "        self._assert_last_note(action, self.user_id, event_type)",
            "        self._assert_event(role, project, domain, user, group)",
            "        self.delete(url)",
            "        action = \"%s.%s\" % (DELETED_OPERATION, self.ROLE_ASSIGNMENT)",
            "        event_type = '%s.%s.%s' % (notifications.SERVICE,",
            "                                   self.ROLE_ASSIGNMENT, DELETED_OPERATION)",
            "        self._assert_last_note(action, self.user_id, event_type)",
            "        self._assert_event(role, project, domain, user, None)",
            "",
            "    def test_user_project_grant(self):",
            "        url = ('/projects/%s/users/%s/roles/%s' %",
            "               (self.project_id, self.user_id, self.role_id))",
            "        self._test_role_assignment(url, self.role_id,",
            "                                   project=self.project_id,",
            "                                   user=self.user_id)",
            "",
            "    def test_group_domain_grant(self):",
            "        group_ref = unit.new_group_ref(domain_id=self.domain_id)",
            "        group = PROVIDERS.identity_api.create_group(group_ref)",
            "        PROVIDERS.identity_api.add_user_to_group(self.user_id, group['id'])",
            "        url = ('/domains/%s/groups/%s/roles/%s' %",
            "               (self.domain_id, group['id'], self.role_id))",
            "        self._test_role_assignment(url, self.role_id,",
            "                                   domain=self.domain_id,",
            "                                   group=group['id'])",
            "",
            "    def test_add_role_to_user_and_project(self):",
            "        # A notification is sent when add_role_to_user_and_project is called on",
            "        # the assignment manager.",
            "",
            "        project_ref = unit.new_project_ref(self.domain_id)",
            "        project = PROVIDERS.resource_api.create_project(",
            "            project_ref['id'], project_ref)",
            "        project_id = project['id']",
            "",
            "        PROVIDERS.assignment_api.add_role_to_user_and_project(",
            "            self.user_id, project_id, self.role_id)",
            "",
            "        self.assertTrue(self._notifications)",
            "        note = self._notifications[-1]",
            "        self.assertEqual('created.role_assignment', note['action'])",
            "        self.assertTrue(note['send_notification_called'])",
            "",
            "        self._assert_event(self.role_id, project=project_id, user=self.user_id)",
            "",
            "    def test_remove_role_from_user_and_project(self):",
            "        # A notification is sent when remove_role_from_user_and_project is",
            "        # called on the assignment manager.",
            "",
            "        PROVIDERS.assignment_api.remove_role_from_user_and_project(",
            "            self.user_id, self.project_id, self.role_id)",
            "",
            "        self.assertTrue(self._notifications)",
            "        note = self._notifications[-1]",
            "        self.assertEqual('deleted.role_assignment', note['action'])",
            "        self.assertTrue(note['send_notification_called'])",
            "",
            "        self._assert_event(self.role_id, project=self.project_id,",
            "                           user=self.user_id)",
            "",
            "",
            "class TestCallbackRegistration(unit.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestCallbackRegistration, self).setUp()",
            "        self.mock_log = mock.Mock()",
            "        # Force the callback logging to occur",
            "        self.mock_log.logger.getEffectiveLevel.return_value = log.DEBUG",
            "",
            "    def verify_log_message(self, data):",
            "        \"\"\"Verify log message.",
            "",
            "        Tests that use this are a little brittle because adding more",
            "        logging can break them.",
            "",
            "        TODO(dstanek): remove the need for this in a future refactoring",
            "",
            "        \"\"\"",
            "        log_fn = self.mock_log.debug",
            "        self.assertEqual(len(data), log_fn.call_count)",
            "        for datum in data:",
            "            log_fn.assert_any_call(mock.ANY, datum)",
            "",
            "    def test_a_function_callback(self):",
            "        def callback(*args, **kwargs):",
            "            pass",
            "",
            "        resource_type = 'thing'",
            "        with mock.patch('keystone.notifications.LOG', self.mock_log):",
            "            notifications.register_event_callback(",
            "                CREATED_OPERATION, resource_type, callback)",
            "",
            "        callback = 'keystone.tests.unit.common.test_notifications.callback'",
            "        expected_log_data = {",
            "            'callback': callback,",
            "            'event': 'identity.%s.created' % resource_type",
            "        }",
            "        self.verify_log_message([expected_log_data])",
            "",
            "    def test_a_method_callback(self):",
            "        class C(object):",
            "            def callback(self, *args, **kwargs):",
            "                pass",
            "",
            "        with mock.patch('keystone.notifications.LOG', self.mock_log):",
            "            notifications.register_event_callback(",
            "                CREATED_OPERATION, 'thing', C().callback)",
            "",
            "        callback = 'keystone.tests.unit.common.test_notifications.C.callback'",
            "        expected_log_data = {",
            "            'callback': callback,",
            "            'event': 'identity.thing.created'",
            "        }",
            "        self.verify_log_message([expected_log_data])",
            "",
            "    def test_a_list_of_callbacks(self):",
            "        def callback(*args, **kwargs):",
            "            pass",
            "",
            "        class C(object):",
            "            def callback(self, *args, **kwargs):",
            "                pass",
            "",
            "        with mock.patch('keystone.notifications.LOG', self.mock_log):",
            "            notifications.register_event_callback(",
            "                CREATED_OPERATION, 'thing', [callback, C().callback])",
            "",
            "        callback_1 = 'keystone.tests.unit.common.test_notifications.callback'",
            "        callback_2 = 'keystone.tests.unit.common.test_notifications.C.callback'",
            "        expected_log_data = [",
            "            {",
            "                'callback': callback_1,",
            "                'event': 'identity.thing.created'",
            "            },",
            "            {",
            "                'callback': callback_2,",
            "                'event': 'identity.thing.created'",
            "            },",
            "        ]",
            "        self.verify_log_message(expected_log_data)",
            "",
            "    def test_an_invalid_callback(self):",
            "        self.assertRaises(TypeError,",
            "                          notifications.register_event_callback,",
            "                          (CREATED_OPERATION, 'thing', object()))",
            "",
            "    def test_an_invalid_event(self):",
            "        def callback(*args, **kwargs):",
            "            pass",
            "",
            "        self.assertRaises(ValueError,",
            "                          notifications.register_event_callback,",
            "                          uuid.uuid4().hex,",
            "                          'thing',",
            "                          callback)",
            "",
            "",
            "class CADFNotificationsDataTestCase(test_v3.RestfulTestCase):",
            "",
            "    def config_overrides(self):",
            "        super(CADFNotificationsDataTestCase, self).config_overrides()",
            "        # NOTE(lbragstad): This is a workaround since oslo.messaging version",
            "        # 9.0.0 had a broken default for transport_url. This makes it so that",
            "        # we are able to use version 9.0.0 in tests because we are supplying",
            "        # an override to use a sane default (rabbit://). The problem is that",
            "        # we can't update the config fixture until we call",
            "        # get_notification_transport since that method registers the",
            "        # configuration options for oslo.messaging, which fails since there",
            "        # isn't a default value for transport_url with version 9.0.0. All the",
            "        # next line is doing is bypassing the broken default logic by supplying",
            "        # a dummy url, which allows the options to be registered. After that,",
            "        # we can actually update the configuration option to override the",
            "        # transport_url option that was just registered before proceeding with",
            "        # the test.",
            "        oslo_messaging.get_notification_transport(CONF, url='rabbit://')",
            "        self.config_fixture.config(",
            "            group='oslo_messaging_notifications', transport_url='rabbit://'",
            "        )",
            "",
            "    def test_receive_identityId_from_audit_notification(self):",
            "        observer = None",
            "        resource_type = EXP_RESOURCE_TYPE",
            "",
            "        ref = unit.new_service_ref()",
            "        ref['type'] = 'identity'",
            "        PROVIDERS.catalog_api.create_service(ref['id'], ref.copy())",
            "",
            "        action = CREATED_OPERATION + '.' + resource_type",
            "        initiator = notifications._get_request_audit_info(self.user_id)",
            "        target = cadfresource.Resource(typeURI=cadftaxonomy.ACCOUNT_USER)",
            "        outcome = 'success'",
            "        event_type = 'identity.authenticate.created'",
            "",
            "        with mock.patch.object(notifications._get_notifier(),",
            "                               'info') as mocked:",
            "",
            "            notifications._send_audit_notification(action,",
            "                                                   initiator,",
            "                                                   outcome,",
            "                                                   target,",
            "                                                   event_type)",
            "",
            "            for mock_args_list in mocked.call_args:",
            "                if len(mock_args_list) != 0:",
            "                    for mock_args in mock_args_list:",
            "                        if 'observer' in mock_args:",
            "                            observer = mock_args['observer']",
            "                            break",
            "",
            "        self.assertEqual(ref['id'], observer['id'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "805": [
                "CADFNotificationsForPCIDSSEvents",
                "test_locked_out_user_sends_notification"
            ]
        },
        "addLocation": []
    },
    "keystone/tests/unit/identity/test_backend_sql.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 576,
                "afterPatchRowNumber": 576,
                "PatchRowcode": "             )"
            },
            "1": {
                "beforePatchRowNumber": 577,
                "afterPatchRowNumber": 577,
                "PatchRowcode": "             # test locking out user after max failed attempts"
            },
            "2": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": 578,
                "PatchRowcode": "             self._fail_auth_repeatedly(self.user['id'])"
            },
            "3": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertRaises(exception.AccountLocked,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 579,
                "PatchRowcode": "+            self.assertRaises(exception.Unauthorized,"
            },
            "5": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "                               PROVIDERS.identity_api.authenticate,"
            },
            "6": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "                               user_id=self.user['id'],"
            },
            "7": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "                               password=uuid.uuid4().hex)"
            },
            "8": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": 605,
                "PatchRowcode": "         with self.make_request():"
            },
            "9": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": 606,
                "PatchRowcode": "             # lockout user"
            },
            "10": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": 607,
                "PatchRowcode": "             self._fail_auth_repeatedly(self.user['id'])"
            },
            "11": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertRaises(exception.AccountLocked,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+            self.assertRaises(exception.Unauthorized,"
            },
            "13": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": 609,
                "PatchRowcode": "                               PROVIDERS.identity_api.authenticate,"
            },
            "14": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": 610,
                "PatchRowcode": "                               user_id=self.user['id'],"
            },
            "15": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": 611,
                "PatchRowcode": "                               password=uuid.uuid4().hex)"
            },
            "16": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "             with self.make_request():"
            },
            "17": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "                 # lockout user"
            },
            "18": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "                 self._fail_auth_repeatedly(self.user['id'])"
            },
            "19": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.assertRaises(exception.AccountLocked,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 627,
                "PatchRowcode": "+                self.assertRaises(exception.Unauthorized,"
            },
            "21": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 628,
                "PatchRowcode": "                                   PROVIDERS.identity_api.authenticate,"
            },
            "22": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": 629,
                "PatchRowcode": "                                   user_id=self.user['id'],"
            },
            "23": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": 630,
                "PatchRowcode": "                                   password=uuid.uuid4().hex)"
            },
            "24": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 650,
                "PatchRowcode": "             with self.make_request():"
            },
            "25": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 651,
                "PatchRowcode": "                 # lockout user"
            },
            "26": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 652,
                "PatchRowcode": "                 self._fail_auth_repeatedly(self.user['id'])"
            },
            "27": {
                "beforePatchRowNumber": 653,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.assertRaises(exception.AccountLocked,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 653,
                "PatchRowcode": "+                self.assertRaises(exception.Unauthorized,"
            },
            "29": {
                "beforePatchRowNumber": 654,
                "afterPatchRowNumber": 654,
                "PatchRowcode": "                                   PROVIDERS.identity_api.authenticate,"
            },
            "30": {
                "beforePatchRowNumber": 655,
                "afterPatchRowNumber": 655,
                "PatchRowcode": "                                   user_id=self.user['id'],"
            },
            "31": {
                "beforePatchRowNumber": 656,
                "afterPatchRowNumber": 656,
                "PatchRowcode": "                                   password=uuid.uuid4().hex)"
            },
            "32": {
                "beforePatchRowNumber": 660,
                "afterPatchRowNumber": 660,
                "PatchRowcode": "                 # repeat failed auth the max times"
            },
            "33": {
                "beforePatchRowNumber": 661,
                "afterPatchRowNumber": 661,
                "PatchRowcode": "                 self._fail_auth_repeatedly(self.user['id'])"
            },
            "34": {
                "beforePatchRowNumber": 662,
                "afterPatchRowNumber": 662,
                "PatchRowcode": "                 # test user account is locked"
            },
            "35": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.assertRaises(exception.AccountLocked,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 663,
                "PatchRowcode": "+                self.assertRaises(exception.Unauthorized,"
            },
            "37": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": 664,
                "PatchRowcode": "                                   PROVIDERS.identity_api.authenticate,"
            },
            "38": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 665,
                "PatchRowcode": "                                   user_id=self.user['id'],"
            },
            "39": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": 666,
                "PatchRowcode": "                                   password=uuid.uuid4().hex)"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import datetime",
            "import uuid",
            "",
            "import freezegun",
            "import passlib.hash",
            "",
            "from keystone.common import password_hashing",
            "from keystone.common import provider_api",
            "from keystone.common import resource_options",
            "from keystone.common import sql",
            "import keystone.conf",
            "from keystone import exception",
            "from keystone.identity.backends import base",
            "from keystone.identity.backends import resource_options as iro",
            "from keystone.identity.backends import sql_model as model",
            "from keystone.tests.unit import test_backend_sql",
            "",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "",
            "class UserPasswordCreatedAtIntTests(test_backend_sql.SqlTests):",
            "    def config_overrides(self):",
            "        super(UserPasswordCreatedAtIntTests, self).config_overrides()",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   password_expires_days=1)",
            "",
            "    def test_user_password_created_expired_at_int_matches_created_at(self):",
            "        with sql.session_for_read() as session:",
            "            user_ref = PROVIDERS.identity_api._get_user(",
            "                session, self.user_foo['id']",
            "            )",
            "            self.assertIsNotNone(user_ref.password_ref._created_at)",
            "            self.assertIsNotNone(user_ref.password_ref._expires_at)",
            "            self.assertEqual(user_ref.password_ref._created_at,",
            "                             user_ref.password_ref.created_at_int)",
            "            self.assertEqual(user_ref.password_ref._expires_at,",
            "                             user_ref.password_ref.expires_at_int)",
            "            self.assertEqual(user_ref.password_ref.created_at,",
            "                             user_ref.password_ref.created_at_int)",
            "            self.assertEqual(user_ref.password_ref.expires_at,",
            "                             user_ref.password_ref.expires_at_int)",
            "",
            "",
            "class UserPasswordHashingTestsNoCompat(test_backend_sql.SqlTests):",
            "    def config_overrides(self):",
            "        super(UserPasswordHashingTestsNoCompat, self).config_overrides()",
            "        self.config_fixture.config(group='identity',",
            "                                   password_hash_algorithm='scrypt')",
            "",
            "    def test_configured_algorithm_used(self):",
            "        with sql.session_for_read() as session:",
            "            user_ref = PROVIDERS.identity_api._get_user(",
            "                session, self.user_foo['id']",
            "            )",
            "        self.assertEqual(",
            "            passlib.hash.scrypt,",
            "            password_hashing._get_hasher_from_ident(user_ref.password))",
            "",
            "",
            "class UserResourceOptionTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(UserResourceOptionTests, self).setUp()",
            "        # RESET STATE OF REGISTRY OPTIONS",
            "        self.addCleanup(iro.register_user_options)",
            "        self.addCleanup(iro.USER_OPTIONS_REGISTRY._registered_options.clear)",
            "",
            "        self.option1 = resource_options.ResourceOption('opt1', 'option1')",
            "        self.option2 = resource_options.ResourceOption('opt2', 'option2')",
            "        self.cleanup_instance('option1', 'option2')",
            "",
            "        iro.USER_OPTIONS_REGISTRY._registered_options.clear()",
            "        iro.USER_OPTIONS_REGISTRY.register_option(self.option1)",
            "        iro.USER_OPTIONS_REGISTRY.register_option(self.option2)",
            "",
            "    def test_user_set_option_in_resource_option(self):",
            "        user = self._create_user(self._get_user_dict())",
            "        opt_value = uuid.uuid4().hex",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertIn(self.option1.option_id, raw_ref._resource_option_mapper)",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "        api_get_ref = PROVIDERS.identity_api.get_user(user['id'])",
            "        # Ensure options are properly set in a .get_user call.",
            "        self.assertEqual(opt_value,",
            "                         api_get_ref['options'][self.option1.option_name])",
            "",
            "    def test_user_add_update_delete_option_in_resource_option(self):",
            "        user = self._create_user(self._get_user_dict())",
            "",
            "        opt_value = uuid.uuid4().hex",
            "        new_opt_value = uuid.uuid4().hex",
            "",
            "        # Update user to add the new value option",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Update the option Value and confirm it is updated",
            "        user['options'][self.option1.option_name] = new_opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(new_opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Set the option value to None, meaning delete the option",
            "        user['options'][self.option1.option_name] = None",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertNotIn(self.option1.option_name, new_ref['options'])",
            "",
            "    def test_user_add_delete_resource_option_existing_option_values(self):",
            "        user = self._create_user(self._get_user_dict())",
            "",
            "        opt_value = uuid.uuid4().hex",
            "        opt2_value = uuid.uuid4().hex",
            "",
            "        # Update user to add the new value option",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Update the option value for option 2 and confirm it is updated and",
            "        # option1's value remains the same. Option 1 is not specified in the",
            "        # updated user ref.",
            "        del user['options'][self.option1.option_name]",
            "        user['options'][self.option2.option_name] = opt2_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        self.assertEqual(opt2_value,",
            "                         new_ref['options'][self.option2.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "        self.assertEqual(",
            "            opt2_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option2.option_id].option_value)",
            "",
            "        # Set the option value to None, meaning delete the option, ensure",
            "        # option 2 still remains and has the right value",
            "        user['options'][self.option1.option_name] = None",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertNotIn(self.option1.option_name, new_ref['options'])",
            "        self.assertEqual(opt2_value,",
            "                         new_ref['options'][self.option2.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertNotIn(raw_ref._resource_option_mapper,",
            "                         self.option1.option_id)",
            "        self.assertEqual(",
            "            opt2_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option2.option_id].option_value)",
            "",
            "    def test_unregistered_resource_option_deleted(self):",
            "        user = self._create_user(self._get_user_dict())",
            "",
            "        opt_value = uuid.uuid4().hex",
            "        opt2_value = uuid.uuid4().hex",
            "",
            "        # Update user to add the new value option",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Update the option value for option 2 and confirm it is updated and",
            "        # option1's value remains the same. Option 1 is not specified in the",
            "        # updated user ref.",
            "        del user['options'][self.option1.option_name]",
            "        user['options'][self.option2.option_name] = opt2_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        self.assertEqual(opt2_value,",
            "                         new_ref['options'][self.option2.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "        self.assertEqual(",
            "            opt2_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option2.option_id].option_value)",
            "",
            "        # clear registered options and only re-register option1, update user",
            "        # and confirm option2 is gone from the ref and returned dict",
            "        iro.USER_OPTIONS_REGISTRY._registered_options.clear()",
            "        iro.USER_OPTIONS_REGISTRY.register_option(self.option1)",
            "        user['name'] = uuid.uuid4().hex",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertNotIn(self.option2.option_name, new_ref['options'])",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertNotIn(raw_ref._resource_option_mapper,",
            "                         self.option2.option_id)",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "",
            "    def _get_user_ref(self, user_id):",
            "        with sql.session_for_read() as session:",
            "            return session.query(model.User).get(user_id)",
            "",
            "    def _create_user(self, user_dict):",
            "        user_dict['id'] = uuid.uuid4().hex",
            "        with sql.session_for_write() as session:",
            "            user_ref = model.User.from_dict(user_dict)",
            "            session.add(user_ref)",
            "            return base.filter_user(user_ref.to_dict())",
            "",
            "    def _get_user_dict(self):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': uuid.uuid4().hex",
            "        }",
            "        return user",
            "",
            "",
            "class DisableInactiveUserTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(DisableInactiveUserTests, self).setUp()",
            "        self.password = uuid.uuid4().hex",
            "        self.user_dict = self._get_user_dict(self.password)",
            "        self.max_inactive_days = 90",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            disable_user_account_days_inactive=self.max_inactive_days)",
            "",
            "    def test_authenticate_user_disabled_due_to_inactivity(self):",
            "        # create user and set last_active_at beyond the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(days=self.max_inactive_days + 1))",
            "        user = self._create_user(self.user_dict, last_active_at.date())",
            "        with self.make_request():",
            "            self.assertRaises(exception.UserDisabled,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user['id'],",
            "                              password=self.password)",
            "            # verify that the user is actually disabled",
            "            user = PROVIDERS.identity_api.get_user(user['id'])",
            "            self.assertFalse(user['enabled'])",
            "            # set the user to enabled and authenticate",
            "            user['enabled'] = True",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            user = PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "            self.assertTrue(user['enabled'])",
            "",
            "    def test_authenticate_user_not_disabled_due_to_inactivity(self):",
            "        # create user and set last_active_at just below the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(days=self.max_inactive_days - 1)).date()",
            "        user = self._create_user(self.user_dict, last_active_at)",
            "        with self.make_request():",
            "            user = PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "        self.assertTrue(user['enabled'])",
            "",
            "    def test_get_user_disabled_due_to_inactivity(self):",
            "        user = PROVIDERS.identity_api.create_user(self.user_dict)",
            "        # set last_active_at just beyond the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(self.max_inactive_days + 1)).date()",
            "        self._update_user_last_active_at(user['id'], last_active_at)",
            "        # get user and verify that the user is actually disabled",
            "        user = PROVIDERS.identity_api.get_user(user['id'])",
            "        self.assertFalse(user['enabled'])",
            "        # set enabled and test",
            "        user['enabled'] = True",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user = PROVIDERS.identity_api.get_user(user['id'])",
            "        self.assertTrue(user['enabled'])",
            "",
            "    def test_get_user_not_disabled_due_to_inactivity(self):",
            "        user = PROVIDERS.identity_api.create_user(self.user_dict)",
            "        self.assertTrue(user['enabled'])",
            "        # set last_active_at just below the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(self.max_inactive_days - 1)).date()",
            "        self._update_user_last_active_at(user['id'], last_active_at)",
            "        # get user and verify that the user is still enabled",
            "        user = PROVIDERS.identity_api.get_user(user['id'])",
            "        self.assertTrue(user['enabled'])",
            "",
            "    def test_enabled_after_create_update_user(self):",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   disable_user_account_days_inactive=90)",
            "        # create user without enabled; assert enabled",
            "        del self.user_dict['enabled']",
            "        user = PROVIDERS.identity_api.create_user(self.user_dict)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertTrue(user_ref.enabled)",
            "        now = datetime.datetime.utcnow().date()",
            "        self.assertGreaterEqual(now, user_ref.last_active_at)",
            "        # set enabled and test",
            "        user['enabled'] = True",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertTrue(user_ref.enabled)",
            "        # set disabled and test",
            "        user['enabled'] = False",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertFalse(user_ref.enabled)",
            "        # re-enable user and test",
            "        user['enabled'] = True",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertTrue(user_ref.enabled)",
            "",
            "    def _get_user_dict(self, password):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return user",
            "",
            "    def _get_user_ref(self, user_id):",
            "        with sql.session_for_read() as session:",
            "            return session.query(model.User).get(user_id)",
            "",
            "    def _create_user(self, user_dict, last_active_at):",
            "        user_dict['id'] = uuid.uuid4().hex",
            "        with sql.session_for_write() as session:",
            "            user_ref = model.User.from_dict(user_dict)",
            "            user_ref.last_active_at = last_active_at",
            "            session.add(user_ref)",
            "            return base.filter_user(user_ref.to_dict())",
            "",
            "    def _update_user_last_active_at(self, user_id, last_active_at):",
            "        with sql.session_for_write() as session:",
            "            user_ref = session.query(model.User).get(user_id)",
            "            user_ref.last_active_at = last_active_at",
            "            return user_ref",
            "",
            "",
            "class PasswordHistoryValidationTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(PasswordHistoryValidationTests, self).setUp()",
            "        self.max_cnt = 3",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "",
            "    def test_validate_password_history_with_invalid_password(self):",
            "        password = uuid.uuid4().hex",
            "        user = self._create_user(password)",
            "        # Attempt to change to the same password",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user['id'],",
            "                              original_password=password,",
            "                              new_password=password)",
            "            # Attempt to change to a unique password",
            "            new_password = uuid.uuid4().hex",
            "            self.assertValidChangePassword(user['id'], password, new_password)",
            "            # Attempt to change back to the initial password",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user['id'],",
            "                              original_password=new_password,",
            "                              new_password=password)",
            "",
            "    def test_validate_password_history_with_valid_password(self):",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex, uuid.uuid4().hex,",
            "                     uuid.uuid4().hex]",
            "        user = self._create_user(passwords[0])",
            "        self.assertValidChangePassword(user['id'], passwords[0], passwords[1])",
            "        self.assertValidChangePassword(user['id'], passwords[1], passwords[2])",
            "        self.assertValidChangePassword(user['id'], passwords[2], passwords[3])",
            "        # Now you should be able to change the password to match the initial",
            "        # password because the password history only contains password elements",
            "        # 1, 2, 3",
            "        self.assertValidChangePassword(user['id'], passwords[3], passwords[0])",
            "",
            "    def test_validate_password_history_with_valid_password_only_once(self):",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=1)",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex]",
            "        user = self._create_user(passwords[0])",
            "        self.assertValidChangePassword(user['id'], passwords[0], passwords[1])",
            "        self.assertValidChangePassword(user['id'], passwords[1], passwords[0])",
            "",
            "    def test_validate_password_history_but_start_with_password_none(self):",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex]",
            "        # Create user and confirm password is None",
            "        user = self._create_user(None)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertIsNone(user_ref.password)",
            "        # Admin password reset",
            "        user['password'] = passwords[0]",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        # Self-service change password",
            "        self.assertValidChangePassword(user['id'], passwords[0], passwords[1])",
            "        # Attempt to update with a previous password",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user['id'],",
            "                              original_password=passwords[1],",
            "                              new_password=passwords[0])",
            "",
            "    def test_disable_password_history_and_repeat_same_password(self):",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=0)",
            "        password = uuid.uuid4().hex",
            "        user = self._create_user(password)",
            "        # Repeatedly change password with the same password",
            "        self.assertValidChangePassword(user['id'], password, password)",
            "        self.assertValidChangePassword(user['id'], password, password)",
            "",
            "    def test_admin_password_reset_is_not_validated_by_password_history(self):",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex]",
            "        user = self._create_user(passwords[0])",
            "        # Attempt to change password to a unique password",
            "        user['password'] = passwords[1]",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=passwords[1]",
            "            )",
            "            # Attempt to change password with the same password",
            "            user['password'] = passwords[1]",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=passwords[1]",
            "            )",
            "            # Attempt to change password with the initial password",
            "            user['password'] = passwords[0]",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=passwords[0]",
            "            )",
            "",
            "    def test_truncate_passwords(self):",
            "        user = self._create_user(uuid.uuid4().hex)",
            "        self._add_passwords_to_history(user, n=4)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            len(user_ref.local_user.passwords), (self.max_cnt + 1))",
            "",
            "    def test_truncate_passwords_when_max_is_default(self):",
            "        self.max_cnt = 1",
            "        expected_length = self.max_cnt + 1",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        user = self._create_user(uuid.uuid4().hex)",
            "        self._add_passwords_to_history(user, n=4)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(len(user_ref.local_user.passwords), expected_length)",
            "        # Start with multiple passwords and then change max_cnt to one",
            "        self.max_cnt = 4",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        self._add_passwords_to_history(user, n=self.max_cnt)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            len(user_ref.local_user.passwords), (self.max_cnt + 1))",
            "        self.max_cnt = 1",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        self._add_passwords_to_history(user, n=1)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(len(user_ref.local_user.passwords), expected_length)",
            "",
            "    def test_truncate_passwords_when_max_is_default_and_no_password(self):",
            "        expected_length = 1",
            "        self.max_cnt = 1",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': 'default',",
            "            'enabled': True,",
            "        }",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        self._add_passwords_to_history(user, n=1)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(len(user_ref.local_user.passwords), expected_length)",
            "",
            "    def _create_user(self, password):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': 'default',",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return PROVIDERS.identity_api.create_user(user)",
            "",
            "    def assertValidChangePassword(self, user_id, password, new_password):",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_id, original_password=password,",
            "                new_password=new_password",
            "            )",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user_id, password=new_password",
            "            )",
            "",
            "    def _add_passwords_to_history(self, user, n):",
            "        for _ in range(n):",
            "            user['password'] = uuid.uuid4().hex",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "",
            "    def _get_user_ref(self, user_id):",
            "        with sql.session_for_read() as session:",
            "            return PROVIDERS.identity_api._get_user(session, user_id)",
            "",
            "",
            "class LockingOutUserTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(LockingOutUserTests, self).setUp()",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            lockout_failure_attempts=6)",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            lockout_duration=5)",
            "        # create user",
            "        self.password = uuid.uuid4().hex",
            "        user_dict = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': self.password",
            "        }",
            "        self.user = PROVIDERS.identity_api.create_user(user_dict)",
            "",
            "    def test_locking_out_user_after_max_failed_attempts(self):",
            "        with self.make_request():",
            "            # authenticate with wrong password",
            "            self.assertRaises(AssertionError,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "            # authenticate with correct password",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=self.user['id'],",
            "                password=self.password",
            "            )",
            "            # test locking out user after max failed attempts",
            "            self._fail_auth_repeatedly(self.user['id'])",
            "            self.assertRaises(exception.AccountLocked,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "",
            "    def test_lock_out_for_ignored_user(self):",
            "        # mark the user as exempt from failed password attempts",
            "        # ignore user and reset password, password not expired",
            "        self.user['options'][iro.IGNORE_LOCKOUT_ATTEMPT_OPT.option_name] = True",
            "        PROVIDERS.identity_api.update_user(self.user['id'], self.user)",
            "",
            "        # fail authentication repeatedly the max number of times",
            "        self._fail_auth_repeatedly(self.user['id'])",
            "        # authenticate with wrong password, account should not be locked",
            "        with self.make_request():",
            "            self.assertRaises(AssertionError,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "            # authenticate with correct password, account should not be locked",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=self.user['id'],",
            "                password=self.password",
            "            )",
            "",
            "    def test_set_enabled_unlocks_user(self):",
            "        with self.make_request():",
            "            # lockout user",
            "            self._fail_auth_repeatedly(self.user['id'])",
            "            self.assertRaises(exception.AccountLocked,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "            # set enabled, user should be unlocked",
            "            self.user['enabled'] = True",
            "            PROVIDERS.identity_api.update_user(self.user['id'], self.user)",
            "            user_ret = PROVIDERS.identity_api.authenticate(",
            "                user_id=self.user['id'],",
            "                password=self.password",
            "            )",
            "            self.assertTrue(user_ret['enabled'])",
            "",
            "    def test_lockout_duration(self):",
            "        # freeze time",
            "        with freezegun.freeze_time(datetime.datetime.utcnow()) as frozen_time:",
            "            with self.make_request():",
            "                # lockout user",
            "                self._fail_auth_repeatedly(self.user['id'])",
            "                self.assertRaises(exception.AccountLocked,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "                # freeze time past the duration, user should be unlocked and",
            "                # failed auth count should get reset",
            "                frozen_time.tick(delta=datetime.timedelta(",
            "                    seconds=CONF.security_compliance.lockout_duration + 1))",
            "                PROVIDERS.identity_api.authenticate(",
            "                    user_id=self.user['id'],",
            "                    password=self.password",
            "                )",
            "                # test failed auth count was reset by authenticating with the",
            "                # wrong password, should raise an assertion error and not",
            "                # account locked",
            "                self.assertRaises(AssertionError,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "",
            "    def test_lockout_duration_failed_auth_cnt_resets(self):",
            "        # freeze time",
            "        with freezegun.freeze_time(datetime.datetime.utcnow()) as frozen_time:",
            "            with self.make_request():",
            "                # lockout user",
            "                self._fail_auth_repeatedly(self.user['id'])",
            "                self.assertRaises(exception.AccountLocked,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "                # freeze time past the duration, failed_auth_cnt should reset",
            "                frozen_time.tick(delta=datetime.timedelta(",
            "                    seconds=CONF.security_compliance.lockout_duration + 1))",
            "                # repeat failed auth the max times",
            "                self._fail_auth_repeatedly(self.user['id'])",
            "                # test user account is locked",
            "                self.assertRaises(exception.AccountLocked,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "",
            "    def _fail_auth_repeatedly(self, user_id):",
            "        wrong_password = uuid.uuid4().hex",
            "        for _ in range(CONF.security_compliance.lockout_failure_attempts):",
            "            with self.make_request():",
            "                self.assertRaises(AssertionError,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=user_id,",
            "                                  password=wrong_password)",
            "",
            "",
            "class PasswordExpiresValidationTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(PasswordExpiresValidationTests, self).setUp()",
            "        self.password = uuid.uuid4().hex",
            "        self.user_dict = self._get_test_user_dict(self.password)",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            password_expires_days=90)",
            "",
            "    def test_authenticate_with_expired_password(self):",
            "        # set password created_at so that the password will expire",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days + 1)",
            "        )",
            "        user = self._create_user(self.user_dict, password_created_at)",
            "        # test password is expired",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user['id'],",
            "                              password=self.password)",
            "",
            "    def test_authenticate_with_non_expired_password(self):",
            "        # set password created_at so that the password will not expire",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days - 1)",
            "        )",
            "        user = self._create_user(self.user_dict, password_created_at)",
            "        # test password is not expired",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "",
            "    def test_authenticate_with_expired_password_for_ignore_user_option(self):",
            "        # set user to have the 'ignore_password_expiry' option set to False",
            "        self.user_dict.setdefault('options', {})[",
            "            iro.IGNORE_PASSWORD_EXPIRY_OPT.option_name] = False",
            "        # set password created_at so that the password will expire",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days + 1)",
            "        )",
            "        user = self._create_user(self.user_dict, password_created_at)",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user['id'],",
            "                              password=self.password)",
            "",
            "            # update user to explicitly have the expiry option to True",
            "            user['options'][",
            "                iro.IGNORE_PASSWORD_EXPIRY_OPT.option_name] = True",
            "            user = PROVIDERS.identity_api.update_user(",
            "                user['id'], user",
            "            )",
            "            # test password is not expired due to ignore option",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "",
            "    def _get_test_user_dict(self, password):",
            "        test_user_dict = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return test_user_dict",
            "",
            "    def _create_user(self, user_dict, password_created_at):",
            "        # Bypass business logic and go straight for the identity driver",
            "        # (SQL in this case)",
            "        driver = PROVIDERS.identity_api.driver",
            "        driver.create_user(user_dict['id'], user_dict)",
            "        with sql.session_for_write() as session:",
            "            user_ref = session.query(model.User).get(user_dict['id'])",
            "            user_ref.password_ref.created_at = password_created_at",
            "            user_ref.password_ref.expires_at = (",
            "                user_ref._get_password_expires_at(password_created_at))",
            "            return base.filter_user(user_ref.to_dict())",
            "",
            "",
            "class MinimumPasswordAgeTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(MinimumPasswordAgeTests, self).setUp()",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            minimum_password_age=1)",
            "        self.initial_password = uuid.uuid4().hex",
            "        self.user = self._create_new_user(self.initial_password)",
            "",
            "    def test_user_cannot_change_password_before_min_age(self):",
            "        # user can change password after create",
            "        new_password = uuid.uuid4().hex",
            "        self.assertValidChangePassword(self.user['id'], self.initial_password,",
            "                                       new_password)",
            "        # user cannot change password before min age",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordAgeValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=self.user['id'],",
            "                              original_password=new_password,",
            "                              new_password=uuid.uuid4().hex)",
            "",
            "    def test_user_can_change_password_after_min_age(self):",
            "        # user can change password after create",
            "        new_password = uuid.uuid4().hex",
            "        self.assertValidChangePassword(self.user['id'], self.initial_password,",
            "                                       new_password)",
            "        # set password_created_at so that the min password age has past",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.minimum_password_age + 1))",
            "        self._update_password_created_at(self.user['id'], password_created_at)",
            "        # user can change their password after min password age has past",
            "        self.assertValidChangePassword(self.user['id'], new_password,",
            "                                       uuid.uuid4().hex)",
            "",
            "    def test_user_can_change_password_after_admin_reset(self):",
            "        # user can change password after create",
            "        new_password = uuid.uuid4().hex",
            "        self.assertValidChangePassword(self.user['id'], self.initial_password,",
            "                                       new_password)",
            "        # user cannot change password before min age",
            "",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordAgeValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=self.user['id'],",
            "                              original_password=new_password,",
            "                              new_password=uuid.uuid4().hex)",
            "        # admin reset",
            "        new_password = uuid.uuid4().hex",
            "        self.user['password'] = new_password",
            "        PROVIDERS.identity_api.update_user(self.user['id'], self.user)",
            "        # user can change password after admin reset",
            "        self.assertValidChangePassword(self.user['id'], new_password,",
            "                                       uuid.uuid4().hex)",
            "",
            "    def assertValidChangePassword(self, user_id, password, new_password):",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_id, original_password=password,",
            "                new_password=new_password",
            "            )",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user_id, password=new_password",
            "            )",
            "",
            "    def _create_new_user(self, password):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return PROVIDERS.identity_api.create_user(user)",
            "",
            "    def _update_password_created_at(self, user_id, password_create_at):",
            "        # User instance has an attribute password_ref. This attribute is used",
            "        # in authentication. It always points to the last created password. The",
            "        # order of passwords is determined by `created_at` field.",
            "        # By changing `created_at`, this method interferes with password_ref",
            "        # behaviour, making it return not last value. That's why all passwords",
            "        # except the latest, need to have `created_at` slightly less than",
            "        # the latest password.",
            "        with sql.session_for_write() as session:",
            "            user_ref = session.query(model.User).get(user_id)",
            "            latest_password = user_ref.password_ref",
            "            slightly_less = datetime.timedelta(minutes=1)",
            "            for password_ref in user_ref.local_user.passwords:",
            "                password_ref.created_at = password_create_at - slightly_less",
            "            latest_password.created_at = password_create_at",
            "",
            "",
            "class ChangePasswordRequiredAfterFirstUse(test_backend_sql.SqlTests):",
            "    def _create_user(self, password, change_password_upon_first_use):",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            change_password_upon_first_use=change_password_upon_first_use)",
            "        user_dict = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return PROVIDERS.identity_api.create_user(user_dict)",
            "",
            "    def assertPasswordIsExpired(self, user_id, password):",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user_id,",
            "                              password=password)",
            "",
            "    def assertPasswordIsNotExpired(self, user_id, password):",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user_id, password=password",
            "            )",
            "",
            "    def test_password_expired_after_create(self):",
            "        # create user, password expired",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, True)",
            "        self.assertPasswordIsExpired(user['id'], initial_password)",
            "        # change password (self-service), password not expired",
            "        new_password = uuid.uuid4().hex",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user['id'], initial_password, new_password",
            "            )",
            "        self.assertPasswordIsNotExpired(user['id'], new_password)",
            "",
            "    def test_password_expired_after_reset(self):",
            "        # create user with feature disabled, password not expired",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, False)",
            "        self.assertPasswordIsNotExpired(user['id'], initial_password)",
            "        # enable change_password_upon_first_use",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            change_password_upon_first_use=True)",
            "        # admin reset, password expired",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsExpired(user['id'], admin_password)",
            "        # change password (self-service), password not expired",
            "        new_password = uuid.uuid4().hex",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user['id'], admin_password, new_password",
            "            )",
            "        self.assertPasswordIsNotExpired(user['id'], new_password)",
            "",
            "    def test_password_not_expired_when_feature_disabled(self):",
            "        # create user with feature disabled",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, False)",
            "        self.assertPasswordIsNotExpired(user['id'], initial_password)",
            "        # admin reset",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsNotExpired(user['id'], admin_password)",
            "",
            "    def test_password_not_expired_for_ignore_user(self):",
            "        # create user with feature disabled, password not expired",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, False)",
            "        self.assertPasswordIsNotExpired(user['id'], initial_password)",
            "        # enable change_password_upon_first_use",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            change_password_upon_first_use=True)",
            "        # ignore user and reset password, password not expired",
            "        user['options'][iro.IGNORE_CHANGE_PASSWORD_OPT.option_name] = True",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsNotExpired(user['id'], admin_password)",
            "        # set ignore user to false and reset password, password is expired",
            "        user['options'][iro.IGNORE_CHANGE_PASSWORD_OPT.option_name] = False",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsExpired(user['id'], admin_password)"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import datetime",
            "import uuid",
            "",
            "import freezegun",
            "import passlib.hash",
            "",
            "from keystone.common import password_hashing",
            "from keystone.common import provider_api",
            "from keystone.common import resource_options",
            "from keystone.common import sql",
            "import keystone.conf",
            "from keystone import exception",
            "from keystone.identity.backends import base",
            "from keystone.identity.backends import resource_options as iro",
            "from keystone.identity.backends import sql_model as model",
            "from keystone.tests.unit import test_backend_sql",
            "",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "",
            "class UserPasswordCreatedAtIntTests(test_backend_sql.SqlTests):",
            "    def config_overrides(self):",
            "        super(UserPasswordCreatedAtIntTests, self).config_overrides()",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   password_expires_days=1)",
            "",
            "    def test_user_password_created_expired_at_int_matches_created_at(self):",
            "        with sql.session_for_read() as session:",
            "            user_ref = PROVIDERS.identity_api._get_user(",
            "                session, self.user_foo['id']",
            "            )",
            "            self.assertIsNotNone(user_ref.password_ref._created_at)",
            "            self.assertIsNotNone(user_ref.password_ref._expires_at)",
            "            self.assertEqual(user_ref.password_ref._created_at,",
            "                             user_ref.password_ref.created_at_int)",
            "            self.assertEqual(user_ref.password_ref._expires_at,",
            "                             user_ref.password_ref.expires_at_int)",
            "            self.assertEqual(user_ref.password_ref.created_at,",
            "                             user_ref.password_ref.created_at_int)",
            "            self.assertEqual(user_ref.password_ref.expires_at,",
            "                             user_ref.password_ref.expires_at_int)",
            "",
            "",
            "class UserPasswordHashingTestsNoCompat(test_backend_sql.SqlTests):",
            "    def config_overrides(self):",
            "        super(UserPasswordHashingTestsNoCompat, self).config_overrides()",
            "        self.config_fixture.config(group='identity',",
            "                                   password_hash_algorithm='scrypt')",
            "",
            "    def test_configured_algorithm_used(self):",
            "        with sql.session_for_read() as session:",
            "            user_ref = PROVIDERS.identity_api._get_user(",
            "                session, self.user_foo['id']",
            "            )",
            "        self.assertEqual(",
            "            passlib.hash.scrypt,",
            "            password_hashing._get_hasher_from_ident(user_ref.password))",
            "",
            "",
            "class UserResourceOptionTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(UserResourceOptionTests, self).setUp()",
            "        # RESET STATE OF REGISTRY OPTIONS",
            "        self.addCleanup(iro.register_user_options)",
            "        self.addCleanup(iro.USER_OPTIONS_REGISTRY._registered_options.clear)",
            "",
            "        self.option1 = resource_options.ResourceOption('opt1', 'option1')",
            "        self.option2 = resource_options.ResourceOption('opt2', 'option2')",
            "        self.cleanup_instance('option1', 'option2')",
            "",
            "        iro.USER_OPTIONS_REGISTRY._registered_options.clear()",
            "        iro.USER_OPTIONS_REGISTRY.register_option(self.option1)",
            "        iro.USER_OPTIONS_REGISTRY.register_option(self.option2)",
            "",
            "    def test_user_set_option_in_resource_option(self):",
            "        user = self._create_user(self._get_user_dict())",
            "        opt_value = uuid.uuid4().hex",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertIn(self.option1.option_id, raw_ref._resource_option_mapper)",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "        api_get_ref = PROVIDERS.identity_api.get_user(user['id'])",
            "        # Ensure options are properly set in a .get_user call.",
            "        self.assertEqual(opt_value,",
            "                         api_get_ref['options'][self.option1.option_name])",
            "",
            "    def test_user_add_update_delete_option_in_resource_option(self):",
            "        user = self._create_user(self._get_user_dict())",
            "",
            "        opt_value = uuid.uuid4().hex",
            "        new_opt_value = uuid.uuid4().hex",
            "",
            "        # Update user to add the new value option",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Update the option Value and confirm it is updated",
            "        user['options'][self.option1.option_name] = new_opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(new_opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Set the option value to None, meaning delete the option",
            "        user['options'][self.option1.option_name] = None",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertNotIn(self.option1.option_name, new_ref['options'])",
            "",
            "    def test_user_add_delete_resource_option_existing_option_values(self):",
            "        user = self._create_user(self._get_user_dict())",
            "",
            "        opt_value = uuid.uuid4().hex",
            "        opt2_value = uuid.uuid4().hex",
            "",
            "        # Update user to add the new value option",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Update the option value for option 2 and confirm it is updated and",
            "        # option1's value remains the same. Option 1 is not specified in the",
            "        # updated user ref.",
            "        del user['options'][self.option1.option_name]",
            "        user['options'][self.option2.option_name] = opt2_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        self.assertEqual(opt2_value,",
            "                         new_ref['options'][self.option2.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "        self.assertEqual(",
            "            opt2_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option2.option_id].option_value)",
            "",
            "        # Set the option value to None, meaning delete the option, ensure",
            "        # option 2 still remains and has the right value",
            "        user['options'][self.option1.option_name] = None",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertNotIn(self.option1.option_name, new_ref['options'])",
            "        self.assertEqual(opt2_value,",
            "                         new_ref['options'][self.option2.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertNotIn(raw_ref._resource_option_mapper,",
            "                         self.option1.option_id)",
            "        self.assertEqual(",
            "            opt2_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option2.option_id].option_value)",
            "",
            "    def test_unregistered_resource_option_deleted(self):",
            "        user = self._create_user(self._get_user_dict())",
            "",
            "        opt_value = uuid.uuid4().hex",
            "        opt2_value = uuid.uuid4().hex",
            "",
            "        # Update user to add the new value option",
            "        user['options'][self.option1.option_name] = opt_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "",
            "        # Update the option value for option 2 and confirm it is updated and",
            "        # option1's value remains the same. Option 1 is not specified in the",
            "        # updated user ref.",
            "        del user['options'][self.option1.option_name]",
            "        user['options'][self.option2.option_name] = opt2_value",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        self.assertEqual(opt2_value,",
            "                         new_ref['options'][self.option2.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "        self.assertEqual(",
            "            opt2_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option2.option_id].option_value)",
            "",
            "        # clear registered options and only re-register option1, update user",
            "        # and confirm option2 is gone from the ref and returned dict",
            "        iro.USER_OPTIONS_REGISTRY._registered_options.clear()",
            "        iro.USER_OPTIONS_REGISTRY.register_option(self.option1)",
            "        user['name'] = uuid.uuid4().hex",
            "        new_ref = PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertNotIn(self.option2.option_name, new_ref['options'])",
            "        self.assertEqual(opt_value,",
            "                         new_ref['options'][self.option1.option_name])",
            "        raw_ref = self._get_user_ref(user['id'])",
            "        self.assertNotIn(raw_ref._resource_option_mapper,",
            "                         self.option2.option_id)",
            "        self.assertEqual(",
            "            opt_value,",
            "            raw_ref._resource_option_mapper[",
            "                self.option1.option_id].option_value)",
            "",
            "    def _get_user_ref(self, user_id):",
            "        with sql.session_for_read() as session:",
            "            return session.query(model.User).get(user_id)",
            "",
            "    def _create_user(self, user_dict):",
            "        user_dict['id'] = uuid.uuid4().hex",
            "        with sql.session_for_write() as session:",
            "            user_ref = model.User.from_dict(user_dict)",
            "            session.add(user_ref)",
            "            return base.filter_user(user_ref.to_dict())",
            "",
            "    def _get_user_dict(self):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': uuid.uuid4().hex",
            "        }",
            "        return user",
            "",
            "",
            "class DisableInactiveUserTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(DisableInactiveUserTests, self).setUp()",
            "        self.password = uuid.uuid4().hex",
            "        self.user_dict = self._get_user_dict(self.password)",
            "        self.max_inactive_days = 90",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            disable_user_account_days_inactive=self.max_inactive_days)",
            "",
            "    def test_authenticate_user_disabled_due_to_inactivity(self):",
            "        # create user and set last_active_at beyond the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(days=self.max_inactive_days + 1))",
            "        user = self._create_user(self.user_dict, last_active_at.date())",
            "        with self.make_request():",
            "            self.assertRaises(exception.UserDisabled,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user['id'],",
            "                              password=self.password)",
            "            # verify that the user is actually disabled",
            "            user = PROVIDERS.identity_api.get_user(user['id'])",
            "            self.assertFalse(user['enabled'])",
            "            # set the user to enabled and authenticate",
            "            user['enabled'] = True",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            user = PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "            self.assertTrue(user['enabled'])",
            "",
            "    def test_authenticate_user_not_disabled_due_to_inactivity(self):",
            "        # create user and set last_active_at just below the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(days=self.max_inactive_days - 1)).date()",
            "        user = self._create_user(self.user_dict, last_active_at)",
            "        with self.make_request():",
            "            user = PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "        self.assertTrue(user['enabled'])",
            "",
            "    def test_get_user_disabled_due_to_inactivity(self):",
            "        user = PROVIDERS.identity_api.create_user(self.user_dict)",
            "        # set last_active_at just beyond the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(self.max_inactive_days + 1)).date()",
            "        self._update_user_last_active_at(user['id'], last_active_at)",
            "        # get user and verify that the user is actually disabled",
            "        user = PROVIDERS.identity_api.get_user(user['id'])",
            "        self.assertFalse(user['enabled'])",
            "        # set enabled and test",
            "        user['enabled'] = True",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user = PROVIDERS.identity_api.get_user(user['id'])",
            "        self.assertTrue(user['enabled'])",
            "",
            "    def test_get_user_not_disabled_due_to_inactivity(self):",
            "        user = PROVIDERS.identity_api.create_user(self.user_dict)",
            "        self.assertTrue(user['enabled'])",
            "        # set last_active_at just below the max",
            "        last_active_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(self.max_inactive_days - 1)).date()",
            "        self._update_user_last_active_at(user['id'], last_active_at)",
            "        # get user and verify that the user is still enabled",
            "        user = PROVIDERS.identity_api.get_user(user['id'])",
            "        self.assertTrue(user['enabled'])",
            "",
            "    def test_enabled_after_create_update_user(self):",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   disable_user_account_days_inactive=90)",
            "        # create user without enabled; assert enabled",
            "        del self.user_dict['enabled']",
            "        user = PROVIDERS.identity_api.create_user(self.user_dict)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertTrue(user_ref.enabled)",
            "        now = datetime.datetime.utcnow().date()",
            "        self.assertGreaterEqual(now, user_ref.last_active_at)",
            "        # set enabled and test",
            "        user['enabled'] = True",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertTrue(user_ref.enabled)",
            "        # set disabled and test",
            "        user['enabled'] = False",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertFalse(user_ref.enabled)",
            "        # re-enable user and test",
            "        user['enabled'] = True",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertTrue(user_ref.enabled)",
            "",
            "    def _get_user_dict(self, password):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return user",
            "",
            "    def _get_user_ref(self, user_id):",
            "        with sql.session_for_read() as session:",
            "            return session.query(model.User).get(user_id)",
            "",
            "    def _create_user(self, user_dict, last_active_at):",
            "        user_dict['id'] = uuid.uuid4().hex",
            "        with sql.session_for_write() as session:",
            "            user_ref = model.User.from_dict(user_dict)",
            "            user_ref.last_active_at = last_active_at",
            "            session.add(user_ref)",
            "            return base.filter_user(user_ref.to_dict())",
            "",
            "    def _update_user_last_active_at(self, user_id, last_active_at):",
            "        with sql.session_for_write() as session:",
            "            user_ref = session.query(model.User).get(user_id)",
            "            user_ref.last_active_at = last_active_at",
            "            return user_ref",
            "",
            "",
            "class PasswordHistoryValidationTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(PasswordHistoryValidationTests, self).setUp()",
            "        self.max_cnt = 3",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "",
            "    def test_validate_password_history_with_invalid_password(self):",
            "        password = uuid.uuid4().hex",
            "        user = self._create_user(password)",
            "        # Attempt to change to the same password",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user['id'],",
            "                              original_password=password,",
            "                              new_password=password)",
            "            # Attempt to change to a unique password",
            "            new_password = uuid.uuid4().hex",
            "            self.assertValidChangePassword(user['id'], password, new_password)",
            "            # Attempt to change back to the initial password",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user['id'],",
            "                              original_password=new_password,",
            "                              new_password=password)",
            "",
            "    def test_validate_password_history_with_valid_password(self):",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex, uuid.uuid4().hex,",
            "                     uuid.uuid4().hex]",
            "        user = self._create_user(passwords[0])",
            "        self.assertValidChangePassword(user['id'], passwords[0], passwords[1])",
            "        self.assertValidChangePassword(user['id'], passwords[1], passwords[2])",
            "        self.assertValidChangePassword(user['id'], passwords[2], passwords[3])",
            "        # Now you should be able to change the password to match the initial",
            "        # password because the password history only contains password elements",
            "        # 1, 2, 3",
            "        self.assertValidChangePassword(user['id'], passwords[3], passwords[0])",
            "",
            "    def test_validate_password_history_with_valid_password_only_once(self):",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=1)",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex]",
            "        user = self._create_user(passwords[0])",
            "        self.assertValidChangePassword(user['id'], passwords[0], passwords[1])",
            "        self.assertValidChangePassword(user['id'], passwords[1], passwords[0])",
            "",
            "    def test_validate_password_history_but_start_with_password_none(self):",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex]",
            "        # Create user and confirm password is None",
            "        user = self._create_user(None)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertIsNone(user_ref.password)",
            "        # Admin password reset",
            "        user['password'] = passwords[0]",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        # Self-service change password",
            "        self.assertValidChangePassword(user['id'], passwords[0], passwords[1])",
            "        # Attempt to update with a previous password",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=user['id'],",
            "                              original_password=passwords[1],",
            "                              new_password=passwords[0])",
            "",
            "    def test_disable_password_history_and_repeat_same_password(self):",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=0)",
            "        password = uuid.uuid4().hex",
            "        user = self._create_user(password)",
            "        # Repeatedly change password with the same password",
            "        self.assertValidChangePassword(user['id'], password, password)",
            "        self.assertValidChangePassword(user['id'], password, password)",
            "",
            "    def test_admin_password_reset_is_not_validated_by_password_history(self):",
            "        passwords = [uuid.uuid4().hex, uuid.uuid4().hex]",
            "        user = self._create_user(passwords[0])",
            "        # Attempt to change password to a unique password",
            "        user['password'] = passwords[1]",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=passwords[1]",
            "            )",
            "            # Attempt to change password with the same password",
            "            user['password'] = passwords[1]",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=passwords[1]",
            "            )",
            "            # Attempt to change password with the initial password",
            "            user['password'] = passwords[0]",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=passwords[0]",
            "            )",
            "",
            "    def test_truncate_passwords(self):",
            "        user = self._create_user(uuid.uuid4().hex)",
            "        self._add_passwords_to_history(user, n=4)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            len(user_ref.local_user.passwords), (self.max_cnt + 1))",
            "",
            "    def test_truncate_passwords_when_max_is_default(self):",
            "        self.max_cnt = 1",
            "        expected_length = self.max_cnt + 1",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        user = self._create_user(uuid.uuid4().hex)",
            "        self._add_passwords_to_history(user, n=4)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(len(user_ref.local_user.passwords), expected_length)",
            "        # Start with multiple passwords and then change max_cnt to one",
            "        self.max_cnt = 4",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        self._add_passwords_to_history(user, n=self.max_cnt)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(",
            "            len(user_ref.local_user.passwords), (self.max_cnt + 1))",
            "        self.max_cnt = 1",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        self._add_passwords_to_history(user, n=1)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(len(user_ref.local_user.passwords), expected_length)",
            "",
            "    def test_truncate_passwords_when_max_is_default_and_no_password(self):",
            "        expected_length = 1",
            "        self.max_cnt = 1",
            "        self.config_fixture.config(group='security_compliance',",
            "                                   unique_last_password_count=self.max_cnt)",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': 'default',",
            "            'enabled': True,",
            "        }",
            "        user = PROVIDERS.identity_api.create_user(user)",
            "        self._add_passwords_to_history(user, n=1)",
            "        user_ref = self._get_user_ref(user['id'])",
            "        self.assertEqual(len(user_ref.local_user.passwords), expected_length)",
            "",
            "    def _create_user(self, password):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': 'default',",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return PROVIDERS.identity_api.create_user(user)",
            "",
            "    def assertValidChangePassword(self, user_id, password, new_password):",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_id, original_password=password,",
            "                new_password=new_password",
            "            )",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user_id, password=new_password",
            "            )",
            "",
            "    def _add_passwords_to_history(self, user, n):",
            "        for _ in range(n):",
            "            user['password'] = uuid.uuid4().hex",
            "            PROVIDERS.identity_api.update_user(user['id'], user)",
            "",
            "    def _get_user_ref(self, user_id):",
            "        with sql.session_for_read() as session:",
            "            return PROVIDERS.identity_api._get_user(session, user_id)",
            "",
            "",
            "class LockingOutUserTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(LockingOutUserTests, self).setUp()",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            lockout_failure_attempts=6)",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            lockout_duration=5)",
            "        # create user",
            "        self.password = uuid.uuid4().hex",
            "        user_dict = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': self.password",
            "        }",
            "        self.user = PROVIDERS.identity_api.create_user(user_dict)",
            "",
            "    def test_locking_out_user_after_max_failed_attempts(self):",
            "        with self.make_request():",
            "            # authenticate with wrong password",
            "            self.assertRaises(AssertionError,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "            # authenticate with correct password",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=self.user['id'],",
            "                password=self.password",
            "            )",
            "            # test locking out user after max failed attempts",
            "            self._fail_auth_repeatedly(self.user['id'])",
            "            self.assertRaises(exception.Unauthorized,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "",
            "    def test_lock_out_for_ignored_user(self):",
            "        # mark the user as exempt from failed password attempts",
            "        # ignore user and reset password, password not expired",
            "        self.user['options'][iro.IGNORE_LOCKOUT_ATTEMPT_OPT.option_name] = True",
            "        PROVIDERS.identity_api.update_user(self.user['id'], self.user)",
            "",
            "        # fail authentication repeatedly the max number of times",
            "        self._fail_auth_repeatedly(self.user['id'])",
            "        # authenticate with wrong password, account should not be locked",
            "        with self.make_request():",
            "            self.assertRaises(AssertionError,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "            # authenticate with correct password, account should not be locked",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=self.user['id'],",
            "                password=self.password",
            "            )",
            "",
            "    def test_set_enabled_unlocks_user(self):",
            "        with self.make_request():",
            "            # lockout user",
            "            self._fail_auth_repeatedly(self.user['id'])",
            "            self.assertRaises(exception.Unauthorized,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=self.user['id'],",
            "                              password=uuid.uuid4().hex)",
            "            # set enabled, user should be unlocked",
            "            self.user['enabled'] = True",
            "            PROVIDERS.identity_api.update_user(self.user['id'], self.user)",
            "            user_ret = PROVIDERS.identity_api.authenticate(",
            "                user_id=self.user['id'],",
            "                password=self.password",
            "            )",
            "            self.assertTrue(user_ret['enabled'])",
            "",
            "    def test_lockout_duration(self):",
            "        # freeze time",
            "        with freezegun.freeze_time(datetime.datetime.utcnow()) as frozen_time:",
            "            with self.make_request():",
            "                # lockout user",
            "                self._fail_auth_repeatedly(self.user['id'])",
            "                self.assertRaises(exception.Unauthorized,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "                # freeze time past the duration, user should be unlocked and",
            "                # failed auth count should get reset",
            "                frozen_time.tick(delta=datetime.timedelta(",
            "                    seconds=CONF.security_compliance.lockout_duration + 1))",
            "                PROVIDERS.identity_api.authenticate(",
            "                    user_id=self.user['id'],",
            "                    password=self.password",
            "                )",
            "                # test failed auth count was reset by authenticating with the",
            "                # wrong password, should raise an assertion error and not",
            "                # account locked",
            "                self.assertRaises(AssertionError,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "",
            "    def test_lockout_duration_failed_auth_cnt_resets(self):",
            "        # freeze time",
            "        with freezegun.freeze_time(datetime.datetime.utcnow()) as frozen_time:",
            "            with self.make_request():",
            "                # lockout user",
            "                self._fail_auth_repeatedly(self.user['id'])",
            "                self.assertRaises(exception.Unauthorized,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "                # freeze time past the duration, failed_auth_cnt should reset",
            "                frozen_time.tick(delta=datetime.timedelta(",
            "                    seconds=CONF.security_compliance.lockout_duration + 1))",
            "                # repeat failed auth the max times",
            "                self._fail_auth_repeatedly(self.user['id'])",
            "                # test user account is locked",
            "                self.assertRaises(exception.Unauthorized,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=self.user['id'],",
            "                                  password=uuid.uuid4().hex)",
            "",
            "    def _fail_auth_repeatedly(self, user_id):",
            "        wrong_password = uuid.uuid4().hex",
            "        for _ in range(CONF.security_compliance.lockout_failure_attempts):",
            "            with self.make_request():",
            "                self.assertRaises(AssertionError,",
            "                                  PROVIDERS.identity_api.authenticate,",
            "                                  user_id=user_id,",
            "                                  password=wrong_password)",
            "",
            "",
            "class PasswordExpiresValidationTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(PasswordExpiresValidationTests, self).setUp()",
            "        self.password = uuid.uuid4().hex",
            "        self.user_dict = self._get_test_user_dict(self.password)",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            password_expires_days=90)",
            "",
            "    def test_authenticate_with_expired_password(self):",
            "        # set password created_at so that the password will expire",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days + 1)",
            "        )",
            "        user = self._create_user(self.user_dict, password_created_at)",
            "        # test password is expired",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user['id'],",
            "                              password=self.password)",
            "",
            "    def test_authenticate_with_non_expired_password(self):",
            "        # set password created_at so that the password will not expire",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days - 1)",
            "        )",
            "        user = self._create_user(self.user_dict, password_created_at)",
            "        # test password is not expired",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "",
            "    def test_authenticate_with_expired_password_for_ignore_user_option(self):",
            "        # set user to have the 'ignore_password_expiry' option set to False",
            "        self.user_dict.setdefault('options', {})[",
            "            iro.IGNORE_PASSWORD_EXPIRY_OPT.option_name] = False",
            "        # set password created_at so that the password will expire",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.password_expires_days + 1)",
            "        )",
            "        user = self._create_user(self.user_dict, password_created_at)",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user['id'],",
            "                              password=self.password)",
            "",
            "            # update user to explicitly have the expiry option to True",
            "            user['options'][",
            "                iro.IGNORE_PASSWORD_EXPIRY_OPT.option_name] = True",
            "            user = PROVIDERS.identity_api.update_user(",
            "                user['id'], user",
            "            )",
            "            # test password is not expired due to ignore option",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user['id'], password=self.password",
            "            )",
            "",
            "    def _get_test_user_dict(self, password):",
            "        test_user_dict = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return test_user_dict",
            "",
            "    def _create_user(self, user_dict, password_created_at):",
            "        # Bypass business logic and go straight for the identity driver",
            "        # (SQL in this case)",
            "        driver = PROVIDERS.identity_api.driver",
            "        driver.create_user(user_dict['id'], user_dict)",
            "        with sql.session_for_write() as session:",
            "            user_ref = session.query(model.User).get(user_dict['id'])",
            "            user_ref.password_ref.created_at = password_created_at",
            "            user_ref.password_ref.expires_at = (",
            "                user_ref._get_password_expires_at(password_created_at))",
            "            return base.filter_user(user_ref.to_dict())",
            "",
            "",
            "class MinimumPasswordAgeTests(test_backend_sql.SqlTests):",
            "    def setUp(self):",
            "        super(MinimumPasswordAgeTests, self).setUp()",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            minimum_password_age=1)",
            "        self.initial_password = uuid.uuid4().hex",
            "        self.user = self._create_new_user(self.initial_password)",
            "",
            "    def test_user_cannot_change_password_before_min_age(self):",
            "        # user can change password after create",
            "        new_password = uuid.uuid4().hex",
            "        self.assertValidChangePassword(self.user['id'], self.initial_password,",
            "                                       new_password)",
            "        # user cannot change password before min age",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordAgeValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=self.user['id'],",
            "                              original_password=new_password,",
            "                              new_password=uuid.uuid4().hex)",
            "",
            "    def test_user_can_change_password_after_min_age(self):",
            "        # user can change password after create",
            "        new_password = uuid.uuid4().hex",
            "        self.assertValidChangePassword(self.user['id'], self.initial_password,",
            "                                       new_password)",
            "        # set password_created_at so that the min password age has past",
            "        password_created_at = (",
            "            datetime.datetime.utcnow() -",
            "            datetime.timedelta(",
            "                days=CONF.security_compliance.minimum_password_age + 1))",
            "        self._update_password_created_at(self.user['id'], password_created_at)",
            "        # user can change their password after min password age has past",
            "        self.assertValidChangePassword(self.user['id'], new_password,",
            "                                       uuid.uuid4().hex)",
            "",
            "    def test_user_can_change_password_after_admin_reset(self):",
            "        # user can change password after create",
            "        new_password = uuid.uuid4().hex",
            "        self.assertValidChangePassword(self.user['id'], self.initial_password,",
            "                                       new_password)",
            "        # user cannot change password before min age",
            "",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordAgeValidationError,",
            "                              PROVIDERS.identity_api.change_password,",
            "                              user_id=self.user['id'],",
            "                              original_password=new_password,",
            "                              new_password=uuid.uuid4().hex)",
            "        # admin reset",
            "        new_password = uuid.uuid4().hex",
            "        self.user['password'] = new_password",
            "        PROVIDERS.identity_api.update_user(self.user['id'], self.user)",
            "        # user can change password after admin reset",
            "        self.assertValidChangePassword(self.user['id'], new_password,",
            "                                       uuid.uuid4().hex)",
            "",
            "    def assertValidChangePassword(self, user_id, password, new_password):",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_id, original_password=password,",
            "                new_password=new_password",
            "            )",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user_id, password=new_password",
            "            )",
            "",
            "    def _create_new_user(self, password):",
            "        user = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return PROVIDERS.identity_api.create_user(user)",
            "",
            "    def _update_password_created_at(self, user_id, password_create_at):",
            "        # User instance has an attribute password_ref. This attribute is used",
            "        # in authentication. It always points to the last created password. The",
            "        # order of passwords is determined by `created_at` field.",
            "        # By changing `created_at`, this method interferes with password_ref",
            "        # behaviour, making it return not last value. That's why all passwords",
            "        # except the latest, need to have `created_at` slightly less than",
            "        # the latest password.",
            "        with sql.session_for_write() as session:",
            "            user_ref = session.query(model.User).get(user_id)",
            "            latest_password = user_ref.password_ref",
            "            slightly_less = datetime.timedelta(minutes=1)",
            "            for password_ref in user_ref.local_user.passwords:",
            "                password_ref.created_at = password_create_at - slightly_less",
            "            latest_password.created_at = password_create_at",
            "",
            "",
            "class ChangePasswordRequiredAfterFirstUse(test_backend_sql.SqlTests):",
            "    def _create_user(self, password, change_password_upon_first_use):",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            change_password_upon_first_use=change_password_upon_first_use)",
            "        user_dict = {",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'enabled': True,",
            "            'password': password",
            "        }",
            "        return PROVIDERS.identity_api.create_user(user_dict)",
            "",
            "    def assertPasswordIsExpired(self, user_id, password):",
            "        with self.make_request():",
            "            self.assertRaises(exception.PasswordExpired,",
            "                              PROVIDERS.identity_api.authenticate,",
            "                              user_id=user_id,",
            "                              password=password)",
            "",
            "    def assertPasswordIsNotExpired(self, user_id, password):",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.authenticate(",
            "                user_id=user_id, password=password",
            "            )",
            "",
            "    def test_password_expired_after_create(self):",
            "        # create user, password expired",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, True)",
            "        self.assertPasswordIsExpired(user['id'], initial_password)",
            "        # change password (self-service), password not expired",
            "        new_password = uuid.uuid4().hex",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user['id'], initial_password, new_password",
            "            )",
            "        self.assertPasswordIsNotExpired(user['id'], new_password)",
            "",
            "    def test_password_expired_after_reset(self):",
            "        # create user with feature disabled, password not expired",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, False)",
            "        self.assertPasswordIsNotExpired(user['id'], initial_password)",
            "        # enable change_password_upon_first_use",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            change_password_upon_first_use=True)",
            "        # admin reset, password expired",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsExpired(user['id'], admin_password)",
            "        # change password (self-service), password not expired",
            "        new_password = uuid.uuid4().hex",
            "        with self.make_request():",
            "            PROVIDERS.identity_api.change_password(",
            "                user['id'], admin_password, new_password",
            "            )",
            "        self.assertPasswordIsNotExpired(user['id'], new_password)",
            "",
            "    def test_password_not_expired_when_feature_disabled(self):",
            "        # create user with feature disabled",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, False)",
            "        self.assertPasswordIsNotExpired(user['id'], initial_password)",
            "        # admin reset",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsNotExpired(user['id'], admin_password)",
            "",
            "    def test_password_not_expired_for_ignore_user(self):",
            "        # create user with feature disabled, password not expired",
            "        initial_password = uuid.uuid4().hex",
            "        user = self._create_user(initial_password, False)",
            "        self.assertPasswordIsNotExpired(user['id'], initial_password)",
            "        # enable change_password_upon_first_use",
            "        self.config_fixture.config(",
            "            group='security_compliance',",
            "            change_password_upon_first_use=True)",
            "        # ignore user and reset password, password not expired",
            "        user['options'][iro.IGNORE_CHANGE_PASSWORD_OPT.option_name] = True",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsNotExpired(user['id'], admin_password)",
            "        # set ignore user to false and reset password, password is expired",
            "        user['options'][iro.IGNORE_CHANGE_PASSWORD_OPT.option_name] = False",
            "        admin_password = uuid.uuid4().hex",
            "        user['password'] = admin_password",
            "        PROVIDERS.identity_api.update_user(user['id'], user)",
            "        self.assertPasswordIsExpired(user['id'], admin_password)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "579": [
                "LockingOutUserTests",
                "test_locking_out_user_after_max_failed_attempts"
            ],
            "608": [
                "LockingOutUserTests",
                "test_set_enabled_unlocks_user"
            ],
            "627": [
                "LockingOutUserTests",
                "test_lockout_duration"
            ],
            "653": [
                "LockingOutUserTests",
                "test_lockout_duration_failed_auth_cnt_resets"
            ],
            "663": [
                "LockingOutUserTests",
                "test_lockout_duration_failed_auth_cnt_resets"
            ]
        },
        "addLocation": []
    }
}