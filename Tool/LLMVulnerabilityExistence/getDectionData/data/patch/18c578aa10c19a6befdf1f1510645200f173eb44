{
    "neutron/agent/linux/openvswitch_firewall/rules.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     # item means a removal."
            },
            "1": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     result = []"
            },
            "2": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     rule_tmpl = rule_conj_list[0][0]"
            },
            "3": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    cur_conj = set()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    cur_conj = {}"
            },
            "5": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     cur_range_min = None"
            },
            "6": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     for port, m, conj_id in port_ranges:"
            },
            "7": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         if m == 'min':"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+            if conj_id in cur_conj:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                cur_conj[conj_id] += 1"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+                continue"
            },
            "11": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "             if cur_conj and cur_range_min != port:"
            },
            "12": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                 rule = rule_tmpl.copy()"
            },
            "13": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "                 rule['port_range_min'] = cur_range_min"
            },
            "14": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                 rule['port_range_max'] = port - 1"
            },
            "15": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result.append((rule, list(cur_conj)))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+                result.append((rule, list(cur_conj.keys())))"
            },
            "17": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "             cur_range_min = port"
            },
            "18": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cur_conj.add(conj_id)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            cur_conj[conj_id] = 1"
            },
            "20": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         else:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            if cur_conj[conj_id] > 1:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                cur_conj[conj_id] -= 1"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+                continue"
            },
            "24": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             if cur_range_min <= port:"
            },
            "25": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "                 rule = rule_tmpl.copy()"
            },
            "26": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "                 rule['port_range_min'] = cur_range_min"
            },
            "27": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                 rule['port_range_max'] = port"
            },
            "28": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                result.append((rule, list(cur_conj)))"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                result.append((rule, list(cur_conj.keys())))"
            },
            "30": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "                 # The next port range without 'port' starts from (port + 1)"
            },
            "31": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                 cur_range_min = port + 1"
            },
            "32": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            cur_conj.remove(conj_id)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            del cur_conj[conj_id]"
            },
            "34": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     if (len(result) == 1 and result[0][0]['port_range_min'] == 1 and"
            },
            "36": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "             result[0][0]['port_range_max'] == 65535):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "",
            "import netaddr",
            "from neutron_lib import constants as n_consts",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.linux.openvswitch_firewall import constants as ovsfw_consts",
            "from neutron.common import utils",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants \\",
            "        as ovs_consts",
            "",
            "CT_STATES = [",
            "    ovsfw_consts.OF_STATE_ESTABLISHED_NOT_REPLY,",
            "    ovsfw_consts.OF_STATE_NEW_NOT_ESTABLISHED]",
            "",
            "FLOW_FIELD_FOR_IPVER_AND_DIRECTION = {",
            "    (n_consts.IP_VERSION_4, n_consts.EGRESS_DIRECTION): 'nw_dst',",
            "    (n_consts.IP_VERSION_6, n_consts.EGRESS_DIRECTION): 'ipv6_dst',",
            "    (n_consts.IP_VERSION_4, n_consts.INGRESS_DIRECTION): 'nw_src',",
            "    (n_consts.IP_VERSION_6, n_consts.INGRESS_DIRECTION): 'ipv6_src',",
            "}",
            "",
            "FORBIDDEN_PREFIXES = (n_consts.IPv4_ANY, n_consts.IPv6_ANY)",
            "",
            "",
            "def is_valid_prefix(ip_prefix):",
            "    # IPv6 have multiple ways how to describe ::/0 network, converting to",
            "    # IPNetwork and back to string unifies it",
            "    return (ip_prefix and",
            "            str(netaddr.IPNetwork(ip_prefix)) not in FORBIDDEN_PREFIXES)",
            "",
            "",
            "def _assert_mergeable_rules(rule_conj_list):",
            "    \"\"\"Assert a given (rule, conj_ids) list has mergeable rules.",
            "",
            "    The given rules must be the same except for port_range_{min,max}",
            "    differences.",
            "    \"\"\"",
            "    rule_tmpl = rule_conj_list[0][0].copy()",
            "    rule_tmpl.pop('port_range_min', None)",
            "    rule_tmpl.pop('port_range_max', None)",
            "    for rule, conj_id in rule_conj_list[1:]:",
            "        rule1 = rule.copy()",
            "        rule1.pop('port_range_min', None)",
            "        rule1.pop('port_range_max', None)",
            "        if rule_tmpl != rule1:",
            "            raise RuntimeError(",
            "                _(\"Incompatible SG rules detected: %(rule1)s and %(rule2)s. \"",
            "                  \"They cannot be merged. This should not happen.\") %",
            "                {'rule1': rule_tmpl, 'rule2': rule})",
            "",
            "",
            "def merge_common_rules(rule_conj_list):",
            "    \"\"\"Take a list of (rule, conj_id) and merge elements with the same rules.",
            "    Return a list of (rule, conj_id_list).",
            "    \"\"\"",
            "    if len(rule_conj_list) == 1:",
            "        rule, conj_id = rule_conj_list[0]",
            "        return [(rule, [conj_id])]",
            "",
            "    _assert_mergeable_rules(rule_conj_list)",
            "    rule_conj_map = collections.defaultdict(list)",
            "    for rule, conj_id in rule_conj_list:",
            "        rule_conj_map[(rule.get('port_range_min'),",
            "                       rule.get('port_range_max'))].append(conj_id)",
            "",
            "    result = []",
            "    rule_tmpl = rule_conj_list[0][0]",
            "    rule_tmpl.pop('port_range_min', None)",
            "    rule_tmpl.pop('port_range_max', None)",
            "    for (port_min, port_max), conj_ids in rule_conj_map.items():",
            "        rule = rule_tmpl.copy()",
            "        if port_min is not None:",
            "            rule['port_range_min'] = port_min",
            "        if port_max is not None:",
            "            rule['port_range_max'] = port_max",
            "        result.append((rule, conj_ids))",
            "    return result",
            "",
            "",
            "def _merge_port_ranges_helper(port_range_item):",
            "    # Sort with 'port' but 'min' things must come first.",
            "    port, m, dummy = port_range_item",
            "    return port * 2 + (0 if m == 'min' else 1)",
            "",
            "",
            "def merge_port_ranges(rule_conj_list):",
            "    \"\"\"Take a list of (rule, conj_id) and transform into a list",
            "    whose rules don't overlap. Return a list of (rule, conj_id_list).",
            "    \"\"\"",
            "    if len(rule_conj_list) == 1:",
            "        rule, conj_id = rule_conj_list[0]",
            "        return [(rule, [conj_id])]",
            "",
            "    _assert_mergeable_rules(rule_conj_list)",
            "    port_ranges = []",
            "    for rule, conj_id in rule_conj_list:",
            "        port_ranges.append((rule.get('port_range_min', 1), 'min', conj_id))",
            "        port_ranges.append((rule.get('port_range_max', 65535), 'max', conj_id))",
            "",
            "    port_ranges.sort(key=_merge_port_ranges_helper)",
            "",
            "    # The idea here is to scan the port_ranges list in an ascending order,",
            "    # keeping active conjunction IDs and range in cur_conj and cur_range_min.",
            "    # A 'min' port_ranges item means an addition to cur_conj, while a 'max'",
            "    # item means a removal.",
            "    result = []",
            "    rule_tmpl = rule_conj_list[0][0]",
            "    cur_conj = set()",
            "    cur_range_min = None",
            "    for port, m, conj_id in port_ranges:",
            "        if m == 'min':",
            "            if cur_conj and cur_range_min != port:",
            "                rule = rule_tmpl.copy()",
            "                rule['port_range_min'] = cur_range_min",
            "                rule['port_range_max'] = port - 1",
            "                result.append((rule, list(cur_conj)))",
            "            cur_range_min = port",
            "            cur_conj.add(conj_id)",
            "        else:",
            "            if cur_range_min <= port:",
            "                rule = rule_tmpl.copy()",
            "                rule['port_range_min'] = cur_range_min",
            "                rule['port_range_max'] = port",
            "                result.append((rule, list(cur_conj)))",
            "                # The next port range without 'port' starts from (port + 1)",
            "                cur_range_min = port + 1",
            "            cur_conj.remove(conj_id)",
            "",
            "    if (len(result) == 1 and result[0][0]['port_range_min'] == 1 and",
            "            result[0][0]['port_range_max'] == 65535):",
            "        del result[0][0]['port_range_min']",
            "        del result[0][0]['port_range_max']",
            "    return result",
            "",
            "",
            "def flow_priority_offset(rule, conjunction=False):",
            "    \"\"\"Calculate flow priority offset from rule.",
            "    Whether the rule belongs to conjunction flows or not is decided",
            "    upon existence of rule['remote_group_id'] but can be overridden",
            "    to be True using the optional conjunction arg.",
            "    \"\"\"",
            "    conj_offset = 0 if 'remote_group_id' in rule or conjunction else 4",
            "    protocol = rule.get('protocol')",
            "    if protocol is None:",
            "        return conj_offset",
            "",
            "    if protocol in [n_consts.PROTO_NUM_ICMP, n_consts.PROTO_NUM_IPV6_ICMP]:",
            "        if 'port_range_min' not in rule:",
            "            return conj_offset + 1",
            "        elif 'port_range_max' not in rule:",
            "            return conj_offset + 2",
            "    return conj_offset + 3",
            "",
            "",
            "def create_flows_from_rule_and_port(rule, port, conjunction=False):",
            "    \"\"\"Create flows from given args.",
            "    For description of the optional conjunction arg, see flow_priority_offset.",
            "    \"\"\"",
            "    ethertype = rule['ethertype']",
            "    direction = rule['direction']",
            "    dst_ip_prefix = rule.get('dest_ip_prefix')",
            "    src_ip_prefix = rule.get('source_ip_prefix')",
            "",
            "    flow_template = {",
            "        'priority': 70 + flow_priority_offset(rule, conjunction),",
            "        'dl_type': ovsfw_consts.ethertype_to_dl_type_map[ethertype],",
            "        'reg_port': port.ofport,",
            "    }",
            "",
            "    if is_valid_prefix(dst_ip_prefix):",
            "        flow_template[FLOW_FIELD_FOR_IPVER_AND_DIRECTION[(",
            "            utils.get_ip_version(dst_ip_prefix), n_consts.EGRESS_DIRECTION)]",
            "        ] = dst_ip_prefix",
            "",
            "    if is_valid_prefix(src_ip_prefix):",
            "        flow_template[FLOW_FIELD_FOR_IPVER_AND_DIRECTION[(",
            "            utils.get_ip_version(src_ip_prefix), n_consts.INGRESS_DIRECTION)]",
            "        ] = src_ip_prefix",
            "",
            "    flows = create_protocol_flows(direction, flow_template, port, rule)",
            "",
            "    return flows",
            "",
            "",
            "def populate_flow_common(direction, flow_template, port):",
            "    \"\"\"Initialize common flow fields.\"\"\"",
            "    if direction == n_consts.INGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_INGRESS_TABLE",
            "        flow_template['actions'] = \"output:{:d}\".format(port.ofport)",
            "    elif direction == n_consts.EGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_EGRESS_TABLE",
            "        # Traffic can be both ingress and egress, check that no ingress rules",
            "        # should be applied",
            "        flow_template['actions'] = 'resubmit(,{:d})'.format(",
            "            ovs_consts.ACCEPT_OR_INGRESS_TABLE)",
            "    return flow_template",
            "",
            "",
            "def create_protocol_flows(direction, flow_template, port, rule):",
            "    flow_template = populate_flow_common(direction,",
            "                                         flow_template.copy(),",
            "                                         port)",
            "    protocol = rule.get('protocol')",
            "    if protocol is not None:",
            "        flow_template['nw_proto'] = protocol",
            "",
            "    if protocol in [n_consts.PROTO_NUM_ICMP, n_consts.PROTO_NUM_IPV6_ICMP]:",
            "        flows = create_icmp_flows(flow_template, rule)",
            "    else:",
            "        flows = create_port_range_flows(flow_template, rule)",
            "    return flows or [flow_template]",
            "",
            "",
            "def create_port_range_flows(flow_template, rule):",
            "    protocol = ovsfw_consts.REVERSE_IP_PROTOCOL_MAP_WITH_PORTS.get(",
            "        rule.get('protocol'))",
            "    if protocol is None:",
            "        return []",
            "    flows = []",
            "    src_port_match = '{:s}_src'.format(protocol)",
            "    src_port_min = rule.get('source_port_range_min')",
            "    src_port_max = rule.get('source_port_range_max')",
            "    dst_port_match = '{:s}_dst'.format(protocol)",
            "    dst_port_min = rule.get('port_range_min')",
            "    dst_port_max = rule.get('port_range_max')",
            "",
            "    dst_port_range = []",
            "    if dst_port_min and dst_port_max:",
            "        dst_port_range = utils.port_rule_masking(dst_port_min, dst_port_max)",
            "",
            "    src_port_range = []",
            "    if src_port_min and src_port_max:",
            "        src_port_range = utils.port_rule_masking(src_port_min, src_port_max)",
            "        for port in src_port_range:",
            "            flow = flow_template.copy()",
            "            flow[src_port_match] = port",
            "            if dst_port_range:",
            "                for port in dst_port_range:",
            "                    dst_flow = flow.copy()",
            "                    dst_flow[dst_port_match] = port",
            "                    flows.append(dst_flow)",
            "            else:",
            "                flows.append(flow)",
            "    else:",
            "        for port in dst_port_range:",
            "            flow = flow_template.copy()",
            "            flow[dst_port_match] = port",
            "            flows.append(flow)",
            "",
            "    return flows",
            "",
            "",
            "def create_icmp_flows(flow_template, rule):",
            "    icmp_type = rule.get('port_range_min')",
            "    if icmp_type is None:",
            "        return",
            "    flow = flow_template.copy()",
            "    flow['icmp_type'] = icmp_type",
            "",
            "    icmp_code = rule.get('port_range_max')",
            "    if icmp_code is not None:",
            "        flow['icmp_code'] = icmp_code",
            "    return [flow]",
            "",
            "",
            "def _flow_priority_offset_from_conj_id(conj_id):",
            "    \"Return a flow priority offset encoded in a conj_id.\"",
            "    # A base conj_id, which is returned by ConjIdMap.get_conj_id, is a",
            "    # multiple of 8, and we use 2 conj_ids per offset.",
            "    return conj_id % 8 // 2",
            "",
            "",
            "def create_flows_for_ip_address(ip_address, direction, ethertype,",
            "                                vlan_tag, conj_ids):",
            "    \"\"\"Create flows from a rule and an ip_address derived from",
            "    remote_group_id",
            "    \"\"\"",
            "",
            "    # Group conj_ids per priority.",
            "    conj_id_lists = [[] for i in range(4)]",
            "    for conj_id in conj_ids:",
            "        conj_id_lists[",
            "            _flow_priority_offset_from_conj_id(conj_id)].append(conj_id)",
            "",
            "    ip_prefix = str(netaddr.IPNetwork(ip_address).cidr)",
            "",
            "    flow_template = {",
            "        'dl_type': ovsfw_consts.ethertype_to_dl_type_map[ethertype],",
            "        'reg_net': vlan_tag,  # needed for project separation",
            "    }",
            "",
            "    ip_ver = utils.get_ip_version(ip_prefix)",
            "",
            "    if direction == n_consts.EGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_EGRESS_TABLE",
            "    elif direction == n_consts.INGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_INGRESS_TABLE",
            "",
            "    flow_template[FLOW_FIELD_FOR_IPVER_AND_DIRECTION[(",
            "        ip_ver, direction)]] = ip_prefix",
            "",
            "    result = []",
            "    for offset, conj_id_list in enumerate(conj_id_lists):",
            "        if not conj_id_list:",
            "            continue",
            "        flow_template['priority'] = 70 + offset",
            "        result.extend(",
            "            substitute_conjunction_actions([flow_template], 1, conj_id_list))",
            "    return result",
            "",
            "",
            "def create_accept_flows(flow):",
            "    flow['ct_state'] = CT_STATES[0]",
            "    result = [flow.copy()]",
            "    flow['ct_state'] = CT_STATES[1]",
            "    if flow['table'] == ovs_consts.RULES_INGRESS_TABLE:",
            "        flow['actions'] = (",
            "            'ct(commit,zone=NXM_NX_REG{:d}[0..15]),{:s},'",
            "            'resubmit(,{:d})'.format(",
            "                ovsfw_consts.REG_NET, flow['actions'],",
            "                ovs_consts.ACCEPTED_INGRESS_TRAFFIC_TABLE)",
            "        )",
            "    result.append(flow)",
            "    return result",
            "",
            "",
            "def substitute_conjunction_actions(flows, dimension, conj_ids):",
            "    result = []",
            "    for flow in flows:",
            "        for i in range(2):",
            "            new_flow = flow.copy()",
            "            new_flow['ct_state'] = CT_STATES[i]",
            "            new_flow['actions'] = ','.join(",
            "                [\"conjunction(%d,%d/2)\" % (s + i, dimension)",
            "                 for s in conj_ids])",
            "            result.append(new_flow)",
            "",
            "    return result",
            "",
            "",
            "def create_conj_flows(port, conj_id, direction, ethertype):",
            "    \"\"\"Generate \"accept\" flows for a given conjunction ID.\"\"\"",
            "    flow_template = {",
            "        'priority': 70 + _flow_priority_offset_from_conj_id(conj_id),",
            "        'conj_id': conj_id,",
            "        'dl_type': ovsfw_consts.ethertype_to_dl_type_map[ethertype],",
            "        # This reg_port matching is for delete_all_port_flows.",
            "        # The matching is redundant as it has been done by",
            "        # conjunction(...,2/2) flows and flows can be summarized",
            "        # without this.",
            "        'reg_port': port.ofport,",
            "    }",
            "    flow_template = populate_flow_common(direction, flow_template, port)",
            "    flows = create_accept_flows(flow_template)",
            "    flows[1]['conj_id'] += 1",
            "    return flows"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "",
            "import netaddr",
            "from neutron_lib import constants as n_consts",
            "",
            "from neutron._i18n import _",
            "from neutron.agent.linux.openvswitch_firewall import constants as ovsfw_consts",
            "from neutron.common import utils",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants \\",
            "        as ovs_consts",
            "",
            "CT_STATES = [",
            "    ovsfw_consts.OF_STATE_ESTABLISHED_NOT_REPLY,",
            "    ovsfw_consts.OF_STATE_NEW_NOT_ESTABLISHED]",
            "",
            "FLOW_FIELD_FOR_IPVER_AND_DIRECTION = {",
            "    (n_consts.IP_VERSION_4, n_consts.EGRESS_DIRECTION): 'nw_dst',",
            "    (n_consts.IP_VERSION_6, n_consts.EGRESS_DIRECTION): 'ipv6_dst',",
            "    (n_consts.IP_VERSION_4, n_consts.INGRESS_DIRECTION): 'nw_src',",
            "    (n_consts.IP_VERSION_6, n_consts.INGRESS_DIRECTION): 'ipv6_src',",
            "}",
            "",
            "FORBIDDEN_PREFIXES = (n_consts.IPv4_ANY, n_consts.IPv6_ANY)",
            "",
            "",
            "def is_valid_prefix(ip_prefix):",
            "    # IPv6 have multiple ways how to describe ::/0 network, converting to",
            "    # IPNetwork and back to string unifies it",
            "    return (ip_prefix and",
            "            str(netaddr.IPNetwork(ip_prefix)) not in FORBIDDEN_PREFIXES)",
            "",
            "",
            "def _assert_mergeable_rules(rule_conj_list):",
            "    \"\"\"Assert a given (rule, conj_ids) list has mergeable rules.",
            "",
            "    The given rules must be the same except for port_range_{min,max}",
            "    differences.",
            "    \"\"\"",
            "    rule_tmpl = rule_conj_list[0][0].copy()",
            "    rule_tmpl.pop('port_range_min', None)",
            "    rule_tmpl.pop('port_range_max', None)",
            "    for rule, conj_id in rule_conj_list[1:]:",
            "        rule1 = rule.copy()",
            "        rule1.pop('port_range_min', None)",
            "        rule1.pop('port_range_max', None)",
            "        if rule_tmpl != rule1:",
            "            raise RuntimeError(",
            "                _(\"Incompatible SG rules detected: %(rule1)s and %(rule2)s. \"",
            "                  \"They cannot be merged. This should not happen.\") %",
            "                {'rule1': rule_tmpl, 'rule2': rule})",
            "",
            "",
            "def merge_common_rules(rule_conj_list):",
            "    \"\"\"Take a list of (rule, conj_id) and merge elements with the same rules.",
            "    Return a list of (rule, conj_id_list).",
            "    \"\"\"",
            "    if len(rule_conj_list) == 1:",
            "        rule, conj_id = rule_conj_list[0]",
            "        return [(rule, [conj_id])]",
            "",
            "    _assert_mergeable_rules(rule_conj_list)",
            "    rule_conj_map = collections.defaultdict(list)",
            "    for rule, conj_id in rule_conj_list:",
            "        rule_conj_map[(rule.get('port_range_min'),",
            "                       rule.get('port_range_max'))].append(conj_id)",
            "",
            "    result = []",
            "    rule_tmpl = rule_conj_list[0][0]",
            "    rule_tmpl.pop('port_range_min', None)",
            "    rule_tmpl.pop('port_range_max', None)",
            "    for (port_min, port_max), conj_ids in rule_conj_map.items():",
            "        rule = rule_tmpl.copy()",
            "        if port_min is not None:",
            "            rule['port_range_min'] = port_min",
            "        if port_max is not None:",
            "            rule['port_range_max'] = port_max",
            "        result.append((rule, conj_ids))",
            "    return result",
            "",
            "",
            "def _merge_port_ranges_helper(port_range_item):",
            "    # Sort with 'port' but 'min' things must come first.",
            "    port, m, dummy = port_range_item",
            "    return port * 2 + (0 if m == 'min' else 1)",
            "",
            "",
            "def merge_port_ranges(rule_conj_list):",
            "    \"\"\"Take a list of (rule, conj_id) and transform into a list",
            "    whose rules don't overlap. Return a list of (rule, conj_id_list).",
            "    \"\"\"",
            "    if len(rule_conj_list) == 1:",
            "        rule, conj_id = rule_conj_list[0]",
            "        return [(rule, [conj_id])]",
            "",
            "    _assert_mergeable_rules(rule_conj_list)",
            "    port_ranges = []",
            "    for rule, conj_id in rule_conj_list:",
            "        port_ranges.append((rule.get('port_range_min', 1), 'min', conj_id))",
            "        port_ranges.append((rule.get('port_range_max', 65535), 'max', conj_id))",
            "",
            "    port_ranges.sort(key=_merge_port_ranges_helper)",
            "",
            "    # The idea here is to scan the port_ranges list in an ascending order,",
            "    # keeping active conjunction IDs and range in cur_conj and cur_range_min.",
            "    # A 'min' port_ranges item means an addition to cur_conj, while a 'max'",
            "    # item means a removal.",
            "    result = []",
            "    rule_tmpl = rule_conj_list[0][0]",
            "    cur_conj = {}",
            "    cur_range_min = None",
            "    for port, m, conj_id in port_ranges:",
            "        if m == 'min':",
            "            if conj_id in cur_conj:",
            "                cur_conj[conj_id] += 1",
            "                continue",
            "            if cur_conj and cur_range_min != port:",
            "                rule = rule_tmpl.copy()",
            "                rule['port_range_min'] = cur_range_min",
            "                rule['port_range_max'] = port - 1",
            "                result.append((rule, list(cur_conj.keys())))",
            "            cur_range_min = port",
            "            cur_conj[conj_id] = 1",
            "        else:",
            "            if cur_conj[conj_id] > 1:",
            "                cur_conj[conj_id] -= 1",
            "                continue",
            "            if cur_range_min <= port:",
            "                rule = rule_tmpl.copy()",
            "                rule['port_range_min'] = cur_range_min",
            "                rule['port_range_max'] = port",
            "                result.append((rule, list(cur_conj.keys())))",
            "                # The next port range without 'port' starts from (port + 1)",
            "                cur_range_min = port + 1",
            "            del cur_conj[conj_id]",
            "",
            "    if (len(result) == 1 and result[0][0]['port_range_min'] == 1 and",
            "            result[0][0]['port_range_max'] == 65535):",
            "        del result[0][0]['port_range_min']",
            "        del result[0][0]['port_range_max']",
            "    return result",
            "",
            "",
            "def flow_priority_offset(rule, conjunction=False):",
            "    \"\"\"Calculate flow priority offset from rule.",
            "    Whether the rule belongs to conjunction flows or not is decided",
            "    upon existence of rule['remote_group_id'] but can be overridden",
            "    to be True using the optional conjunction arg.",
            "    \"\"\"",
            "    conj_offset = 0 if 'remote_group_id' in rule or conjunction else 4",
            "    protocol = rule.get('protocol')",
            "    if protocol is None:",
            "        return conj_offset",
            "",
            "    if protocol in [n_consts.PROTO_NUM_ICMP, n_consts.PROTO_NUM_IPV6_ICMP]:",
            "        if 'port_range_min' not in rule:",
            "            return conj_offset + 1",
            "        elif 'port_range_max' not in rule:",
            "            return conj_offset + 2",
            "    return conj_offset + 3",
            "",
            "",
            "def create_flows_from_rule_and_port(rule, port, conjunction=False):",
            "    \"\"\"Create flows from given args.",
            "    For description of the optional conjunction arg, see flow_priority_offset.",
            "    \"\"\"",
            "    ethertype = rule['ethertype']",
            "    direction = rule['direction']",
            "    dst_ip_prefix = rule.get('dest_ip_prefix')",
            "    src_ip_prefix = rule.get('source_ip_prefix')",
            "",
            "    flow_template = {",
            "        'priority': 70 + flow_priority_offset(rule, conjunction),",
            "        'dl_type': ovsfw_consts.ethertype_to_dl_type_map[ethertype],",
            "        'reg_port': port.ofport,",
            "    }",
            "",
            "    if is_valid_prefix(dst_ip_prefix):",
            "        flow_template[FLOW_FIELD_FOR_IPVER_AND_DIRECTION[(",
            "            utils.get_ip_version(dst_ip_prefix), n_consts.EGRESS_DIRECTION)]",
            "        ] = dst_ip_prefix",
            "",
            "    if is_valid_prefix(src_ip_prefix):",
            "        flow_template[FLOW_FIELD_FOR_IPVER_AND_DIRECTION[(",
            "            utils.get_ip_version(src_ip_prefix), n_consts.INGRESS_DIRECTION)]",
            "        ] = src_ip_prefix",
            "",
            "    flows = create_protocol_flows(direction, flow_template, port, rule)",
            "",
            "    return flows",
            "",
            "",
            "def populate_flow_common(direction, flow_template, port):",
            "    \"\"\"Initialize common flow fields.\"\"\"",
            "    if direction == n_consts.INGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_INGRESS_TABLE",
            "        flow_template['actions'] = \"output:{:d}\".format(port.ofport)",
            "    elif direction == n_consts.EGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_EGRESS_TABLE",
            "        # Traffic can be both ingress and egress, check that no ingress rules",
            "        # should be applied",
            "        flow_template['actions'] = 'resubmit(,{:d})'.format(",
            "            ovs_consts.ACCEPT_OR_INGRESS_TABLE)",
            "    return flow_template",
            "",
            "",
            "def create_protocol_flows(direction, flow_template, port, rule):",
            "    flow_template = populate_flow_common(direction,",
            "                                         flow_template.copy(),",
            "                                         port)",
            "    protocol = rule.get('protocol')",
            "    if protocol is not None:",
            "        flow_template['nw_proto'] = protocol",
            "",
            "    if protocol in [n_consts.PROTO_NUM_ICMP, n_consts.PROTO_NUM_IPV6_ICMP]:",
            "        flows = create_icmp_flows(flow_template, rule)",
            "    else:",
            "        flows = create_port_range_flows(flow_template, rule)",
            "    return flows or [flow_template]",
            "",
            "",
            "def create_port_range_flows(flow_template, rule):",
            "    protocol = ovsfw_consts.REVERSE_IP_PROTOCOL_MAP_WITH_PORTS.get(",
            "        rule.get('protocol'))",
            "    if protocol is None:",
            "        return []",
            "    flows = []",
            "    src_port_match = '{:s}_src'.format(protocol)",
            "    src_port_min = rule.get('source_port_range_min')",
            "    src_port_max = rule.get('source_port_range_max')",
            "    dst_port_match = '{:s}_dst'.format(protocol)",
            "    dst_port_min = rule.get('port_range_min')",
            "    dst_port_max = rule.get('port_range_max')",
            "",
            "    dst_port_range = []",
            "    if dst_port_min and dst_port_max:",
            "        dst_port_range = utils.port_rule_masking(dst_port_min, dst_port_max)",
            "",
            "    src_port_range = []",
            "    if src_port_min and src_port_max:",
            "        src_port_range = utils.port_rule_masking(src_port_min, src_port_max)",
            "        for port in src_port_range:",
            "            flow = flow_template.copy()",
            "            flow[src_port_match] = port",
            "            if dst_port_range:",
            "                for port in dst_port_range:",
            "                    dst_flow = flow.copy()",
            "                    dst_flow[dst_port_match] = port",
            "                    flows.append(dst_flow)",
            "            else:",
            "                flows.append(flow)",
            "    else:",
            "        for port in dst_port_range:",
            "            flow = flow_template.copy()",
            "            flow[dst_port_match] = port",
            "            flows.append(flow)",
            "",
            "    return flows",
            "",
            "",
            "def create_icmp_flows(flow_template, rule):",
            "    icmp_type = rule.get('port_range_min')",
            "    if icmp_type is None:",
            "        return",
            "    flow = flow_template.copy()",
            "    flow['icmp_type'] = icmp_type",
            "",
            "    icmp_code = rule.get('port_range_max')",
            "    if icmp_code is not None:",
            "        flow['icmp_code'] = icmp_code",
            "    return [flow]",
            "",
            "",
            "def _flow_priority_offset_from_conj_id(conj_id):",
            "    \"Return a flow priority offset encoded in a conj_id.\"",
            "    # A base conj_id, which is returned by ConjIdMap.get_conj_id, is a",
            "    # multiple of 8, and we use 2 conj_ids per offset.",
            "    return conj_id % 8 // 2",
            "",
            "",
            "def create_flows_for_ip_address(ip_address, direction, ethertype,",
            "                                vlan_tag, conj_ids):",
            "    \"\"\"Create flows from a rule and an ip_address derived from",
            "    remote_group_id",
            "    \"\"\"",
            "",
            "    # Group conj_ids per priority.",
            "    conj_id_lists = [[] for i in range(4)]",
            "    for conj_id in conj_ids:",
            "        conj_id_lists[",
            "            _flow_priority_offset_from_conj_id(conj_id)].append(conj_id)",
            "",
            "    ip_prefix = str(netaddr.IPNetwork(ip_address).cidr)",
            "",
            "    flow_template = {",
            "        'dl_type': ovsfw_consts.ethertype_to_dl_type_map[ethertype],",
            "        'reg_net': vlan_tag,  # needed for project separation",
            "    }",
            "",
            "    ip_ver = utils.get_ip_version(ip_prefix)",
            "",
            "    if direction == n_consts.EGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_EGRESS_TABLE",
            "    elif direction == n_consts.INGRESS_DIRECTION:",
            "        flow_template['table'] = ovs_consts.RULES_INGRESS_TABLE",
            "",
            "    flow_template[FLOW_FIELD_FOR_IPVER_AND_DIRECTION[(",
            "        ip_ver, direction)]] = ip_prefix",
            "",
            "    result = []",
            "    for offset, conj_id_list in enumerate(conj_id_lists):",
            "        if not conj_id_list:",
            "            continue",
            "        flow_template['priority'] = 70 + offset",
            "        result.extend(",
            "            substitute_conjunction_actions([flow_template], 1, conj_id_list))",
            "    return result",
            "",
            "",
            "def create_accept_flows(flow):",
            "    flow['ct_state'] = CT_STATES[0]",
            "    result = [flow.copy()]",
            "    flow['ct_state'] = CT_STATES[1]",
            "    if flow['table'] == ovs_consts.RULES_INGRESS_TABLE:",
            "        flow['actions'] = (",
            "            'ct(commit,zone=NXM_NX_REG{:d}[0..15]),{:s},'",
            "            'resubmit(,{:d})'.format(",
            "                ovsfw_consts.REG_NET, flow['actions'],",
            "                ovs_consts.ACCEPTED_INGRESS_TRAFFIC_TABLE)",
            "        )",
            "    result.append(flow)",
            "    return result",
            "",
            "",
            "def substitute_conjunction_actions(flows, dimension, conj_ids):",
            "    result = []",
            "    for flow in flows:",
            "        for i in range(2):",
            "            new_flow = flow.copy()",
            "            new_flow['ct_state'] = CT_STATES[i]",
            "            new_flow['actions'] = ','.join(",
            "                [\"conjunction(%d,%d/2)\" % (s + i, dimension)",
            "                 for s in conj_ids])",
            "            result.append(new_flow)",
            "",
            "    return result",
            "",
            "",
            "def create_conj_flows(port, conj_id, direction, ethertype):",
            "    \"\"\"Generate \"accept\" flows for a given conjunction ID.\"\"\"",
            "    flow_template = {",
            "        'priority': 70 + _flow_priority_offset_from_conj_id(conj_id),",
            "        'conj_id': conj_id,",
            "        'dl_type': ovsfw_consts.ethertype_to_dl_type_map[ethertype],",
            "        # This reg_port matching is for delete_all_port_flows.",
            "        # The matching is redundant as it has been done by",
            "        # conjunction(...,2/2) flows and flows can be summarized",
            "        # without this.",
            "        'reg_port': port.ofport,",
            "    }",
            "    flow_template = populate_flow_common(direction, flow_template, port)",
            "    flows = create_accept_flows(flow_template)",
            "    flows[1]['conj_id'] += 1",
            "    return flows"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "124": [
                "merge_port_ranges"
            ],
            "132": [
                "merge_port_ranges"
            ],
            "134": [
                "merge_port_ranges"
            ],
            "140": [
                "merge_port_ranges"
            ],
            "143": [
                "merge_port_ranges"
            ]
        },
        "addLocation": []
    },
    "neutron/tests/unit/agent/linux/openvswitch_firewall/test_rules.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 420,
                "PatchRowcode": "         self.assertEqual(len(expected), len(result))"
            },
            "1": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "         for (range_min, range_max, conj_ids), result1 in zip("
            },
            "2": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "                 expected, result):"
            },
            "3": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertEqual(range_min, result1[0]['port_range_min'])"
            },
            "4": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertEqual(range_max, result1[0]['port_range_max'])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+            self.assertEqual(range_min, result1[0].get('port_range_min'))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+            self.assertEqual(range_max, result1[0].get('port_range_max'))"
            },
            "7": {
                "beforePatchRowNumber": 425,
                "afterPatchRowNumber": 425,
                "PatchRowcode": "             self.assertEqual(conj_ids, set(result1[1]))"
            },
            "8": {
                "beforePatchRowNumber": 426,
                "afterPatchRowNumber": 426,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 427,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "     def test__assert_mergeable_rules(self):"
            },
            "10": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 489,
                "PatchRowcode": "                 (30, 40, {10, 12, 4}),"
            },
            "11": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 490,
                "PatchRowcode": "                 (41, 65535, {10, 12})], result)"
            },
            "12": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 491,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+    def test_merge_port_ranges_no_port_ranges_same_conj_id(self):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+        result = rules.merge_port_ranges("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+            [(dict(self.rule_tmpl), 10),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+             (dict(self.rule_tmpl), 12),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 496,
                "PatchRowcode": "+             (dict([('port_range_min', 30), ('port_range_max', 30)] +"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 497,
                "PatchRowcode": "+                   self.rule_tmpl), 10)])"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+        self._test_merge_port_ranges_helper(["
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+                (None, None, {10, 12})], result)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 501,
                "PatchRowcode": "     def test_merge_port_ranges_nonoverlapping(self):"
            },
            "23": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "         result = rules.merge_port_ranges("
            },
            "24": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "             [(dict([('port_range_min', 30), ('port_range_max', 40)] +"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Red Hat, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from neutron_lib import constants",
            "",
            "from neutron.agent.linux.openvswitch_firewall import constants as ovsfw_consts",
            "from neutron.agent.linux.openvswitch_firewall import firewall as ovsfw",
            "from neutron.agent.linux.openvswitch_firewall import rules",
            "from neutron.common import constants as n_const",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants \\",
            "        as ovs_consts",
            "from neutron.tests import base",
            "",
            "TESTING_VLAN_TAG = 1",
            "",
            "",
            "class TestIsValidPrefix(base.BaseTestCase):",
            "    def test_valid_prefix_ipv4(self):",
            "        is_valid = rules.is_valid_prefix('10.0.0.0/0')",
            "        self.assertTrue(is_valid)",
            "",
            "    def test_invalid_prefix_ipv4(self):",
            "        is_valid = rules.is_valid_prefix('0.0.0.0/0')",
            "        self.assertFalse(is_valid)",
            "",
            "    def test_valid_prefix_ipv6(self):",
            "        is_valid = rules.is_valid_prefix('ffff::0/0')",
            "        self.assertTrue(is_valid)",
            "",
            "    def test_invalid_prefix_ipv6(self):",
            "        is_valid = rules.is_valid_prefix('0000:0::0/0')",
            "        self.assertFalse(is_valid)",
            "        is_valid = rules.is_valid_prefix('::0/0')",
            "        self.assertFalse(is_valid)",
            "        is_valid = rules.is_valid_prefix('::/0')",
            "        self.assertFalse(is_valid)",
            "",
            "",
            "class TestCreateFlowsFromRuleAndPort(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestCreateFlowsFromRuleAndPort, self).setUp()",
            "        ovs_port = mock.Mock(vif_mac='00:00:00:00:00:00')",
            "        ovs_port.ofport = 1",
            "        port_dict = {'device': 'port_id'}",
            "        self.port = ovsfw.OFPort(",
            "            port_dict, ovs_port, vlan_tag=TESTING_VLAN_TAG)",
            "",
            "        self.create_flows_mock = mock.patch.object(",
            "            rules, 'create_protocol_flows').start()",
            "",
            "    @property",
            "    def passed_flow_template(self):",
            "        return self.create_flows_mock.call_args[0][1]",
            "",
            "    def _test_create_flows_from_rule_and_port_helper(",
            "            self, rule, expected_template):",
            "        rules.create_flows_from_rule_and_port(rule, self.port)",
            "",
            "        self.assertEqual(expected_template, self.passed_flow_template)",
            "",
            "    def test_create_flows_from_rule_and_port_no_ip_ipv4(self):",
            "        rule = {",
            "            'ethertype': constants.IPv4,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_port': self.port.ofport,",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_ipv4(self):",
            "        rule = {",
            "            'ethertype': constants.IPv4,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '192.168.0.0/24',",
            "            'dest_ip_prefix': '10.0.0.1/32',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_port': self.port.ofport,",
            "            'nw_src': '192.168.0.0/24',",
            "            'nw_dst': '10.0.0.1/32',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_with_zero_ipv4(self):",
            "        rule = {",
            "            'ethertype': constants.IPv4,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '192.168.0.0/24',",
            "            'dest_ip_prefix': '0.0.0.0/0',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_port': self.port.ofport,",
            "            'nw_src': '192.168.0.0/24',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_no_ip_ipv6(self):",
            "        rule = {",
            "            'ethertype': constants.IPv6,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'reg_port': self.port.ofport,",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_ipv6(self):",
            "        rule = {",
            "            'ethertype': constants.IPv6,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '2001:db8:bbbb::1/64',",
            "            'dest_ip_prefix': '2001:db8:aaaa::1/64',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'reg_port': self.port.ofport,",
            "            'ipv6_src': '2001:db8:bbbb::1/64',",
            "            'ipv6_dst': '2001:db8:aaaa::1/64',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_with_zero_ipv6(self):",
            "        rule = {",
            "            'ethertype': constants.IPv6,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '2001:db8:bbbb::1/64',",
            "            'dest_ip_prefix': '::/0',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'reg_port': self.port.ofport,",
            "            'ipv6_src': '2001:db8:bbbb::1/64',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "",
            "class TestCreateProtocolFlows(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestCreateProtocolFlows, self).setUp()",
            "        ovs_port = mock.Mock(vif_mac='00:00:00:00:00:00')",
            "        ovs_port.ofport = 1",
            "        port_dict = {'device': 'port_id'}",
            "        self.port = ovsfw.OFPort(",
            "            port_dict, ovs_port, vlan_tag=TESTING_VLAN_TAG)",
            "",
            "    def _test_create_protocol_flows_helper(self, direction, rule,",
            "                                           expected_flows):",
            "        flow_template = {'some_settings': 'foo'}",
            "        for flow in expected_flows:",
            "            flow.update(flow_template)",
            "        flows = rules.create_protocol_flows(",
            "            direction, flow_template, self.port, rule)",
            "        self.assertEqual(expected_flows, flows)",
            "",
            "    def test_create_protocol_flows_ingress(self):",
            "        rule = {'protocol': constants.PROTO_NUM_TCP}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_INGRESS_TABLE,",
            "            'actions': 'output:1',",
            "            'nw_proto': constants.PROTO_NUM_TCP,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.INGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_egress(self):",
            "        rule = {'protocol': constants.PROTO_NUM_TCP}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_TCP,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_no_protocol(self):",
            "        rule = {}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_icmp6(self):",
            "        rule = {'ethertype': constants.IPv6,",
            "                'protocol': constants.PROTO_NUM_IPV6_ICMP}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_IPV6_ICMP,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_port_range(self):",
            "        rule = {'ethertype': constants.IPv4,",
            "                'protocol': constants.PROTO_NUM_TCP,",
            "                'port_range_min': 22,",
            "                'port_range_max': 23}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_TCP,",
            "            'tcp_dst': '0x0016/0xfffe'",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_icmp(self):",
            "        rule = {'ethertype': constants.IPv4,",
            "                'protocol': constants.PROTO_NUM_ICMP,",
            "                'port_range_min': 0}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_ICMP,",
            "            'icmp_type': 0",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_ipv6_icmp(self):",
            "        rule = {'ethertype': constants.IPv6,",
            "                'protocol': constants.PROTO_NUM_IPV6_ICMP,",
            "                'port_range_min': 5,",
            "                'port_range_max': 0}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_IPV6_ICMP,",
            "            'icmp_type': 5,",
            "            'icmp_code': 0,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "",
            "class TestCreatePortRangeFlows(base.BaseTestCase):",
            "    def _test_create_port_range_flows_helper(self, expected_flows, rule):",
            "        flow_template = {'some_settings': 'foo'}",
            "        for flow in expected_flows:",
            "            flow.update(flow_template)",
            "        port_range_flows = rules.create_port_range_flows(flow_template, rule)",
            "        self.assertEqual(expected_flows, port_range_flows)",
            "",
            "    def test_create_port_range_flows_with_source_and_destination(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "            'source_port_range_min': 123,",
            "            'source_port_range_max': 124,",
            "            'port_range_min': 10,",
            "            'port_range_max': 11,",
            "        }",
            "        expected_flows = [",
            "            {'tcp_src': '0x007b', 'tcp_dst': '0x000a/0xfffe'},",
            "            {'tcp_src': '0x007c', 'tcp_dst': '0x000a/0xfffe'},",
            "        ]",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_flows_with_source(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "            'source_port_range_min': 123,",
            "            'source_port_range_max': 124,",
            "        }",
            "        expected_flows = [",
            "            {'tcp_src': '0x007b'},",
            "            {'tcp_src': '0x007c'},",
            "        ]",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_flows_with_destination(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "            'port_range_min': 10,",
            "            'port_range_max': 11,",
            "        }",
            "        expected_flows = [",
            "            {'tcp_dst': '0x000a/0xfffe'},",
            "        ]",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_flows_without_port_range(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "        }",
            "        expected_flows = []",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_with_icmp_protocol(self):",
            "        # NOTE: such call is prevented by create_protocols_flows",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_ICMP,",
            "            'port_range_min': 10,",
            "            'port_range_max': 11,",
            "        }",
            "        expected_flows = []",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "",
            "class TestCreateFlowsForIpAddress(base.BaseTestCase):",
            "    def _generate_conjuncion_actions(self, conj_ids, offset):",
            "        return ','.join(",
            "            [\"conjunction(%d,1/2)\" % (c + offset)",
            "             for c in conj_ids])",
            "",
            "    def test_create_flows_for_ip_address_egress(self):",
            "        expected_template = {",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'priority': 72,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_net': 0x123,",
            "            'nw_dst': '192.168.0.1/32'",
            "        }",
            "",
            "        conj_ids = [12, 20]",
            "        flows = rules.create_flows_for_ip_address(",
            "            '192.168.0.1', constants.EGRESS_DIRECTION, constants.IPv4,",
            "            0x123, conj_ids)",
            "",
            "        self.assertEqual(2, len(flows))",
            "        self.assertEqual(ovsfw_consts.OF_STATE_ESTABLISHED_NOT_REPLY,",
            "                         flows[0]['ct_state'])",
            "        self.assertEqual(ovsfw_consts.OF_STATE_NEW_NOT_ESTABLISHED,",
            "                         flows[1]['ct_state'])",
            "        for i in range(2):",
            "            self.assertEqual(self._generate_conjuncion_actions(conj_ids, i),",
            "                             flows[i]['actions'])",
            "        for f in flows:",
            "            del f['actions']",
            "            del f['ct_state']",
            "            self.assertEqual(expected_template, f)",
            "",
            "",
            "class TestCreateConjFlows(base.BaseTestCase):",
            "    def test_create_conj_flows(self):",
            "        ovs_port = mock.Mock(ofport=1, vif_mac='00:00:00:00:00:00')",
            "        port_dict = {'device': 'port_id'}",
            "        port = ovsfw.OFPort(",
            "            port_dict, ovs_port, vlan_tag=TESTING_VLAN_TAG)",
            "",
            "        conj_id = 1234",
            "        expected_template = {",
            "            'table': ovs_consts.RULES_INGRESS_TABLE,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'priority': 71,",
            "            'conj_id': conj_id,",
            "            'reg_port': port.ofport",
            "        }",
            "",
            "        flows = rules.create_conj_flows(port, conj_id,",
            "                                        constants.INGRESS_DIRECTION,",
            "                                        constants.IPv6)",
            "",
            "        self.assertEqual(ovsfw_consts.OF_STATE_ESTABLISHED_NOT_REPLY,",
            "                         flows[0]['ct_state'])",
            "        self.assertEqual(ovsfw_consts.OF_STATE_NEW_NOT_ESTABLISHED,",
            "                         flows[1]['ct_state'])",
            "        self.assertEqual(\"output:{:d}\".format(port.ofport),",
            "                         flows[0]['actions'])",
            "        self.assertEqual(\"ct(commit,zone=NXM_NX_REG{:d}[0..15]),{:s},\"",
            "                         \"resubmit(,{:d})\".format(",
            "                             ovsfw_consts.REG_NET, flows[0]['actions'],",
            "                             ovs_consts.ACCEPTED_INGRESS_TRAFFIC_TABLE),",
            "                         flows[1]['actions'])",
            "",
            "        for f in flows:",
            "            del f['actions']",
            "            del f['ct_state']",
            "            self.assertEqual(expected_template, f)",
            "            expected_template['conj_id'] += 1",
            "",
            "",
            "class TestMergeRules(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestMergeRules, self).setUp()",
            "        self.rule_tmpl = [('direction', 'ingress'), ('ethertype', 'IPv4'),",
            "                          ('protocol', 6)]",
            "",
            "    def _test_merge_port_ranges_helper(self, expected, result):",
            "        \"\"\"Take a list of (port_range_min, port_range_max, conj_ids)",
            "        and an output from rules.merge_port_ranges and check if they",
            "        are identical, ignoring the other rule fields.",
            "        \"\"\"",
            "        self.assertEqual(len(expected), len(result))",
            "        for (range_min, range_max, conj_ids), result1 in zip(",
            "                expected, result):",
            "            self.assertEqual(range_min, result1[0]['port_range_min'])",
            "            self.assertEqual(range_max, result1[0]['port_range_max'])",
            "            self.assertEqual(conj_ids, set(result1[1]))",
            "",
            "    def test__assert_mergeable_rules(self):",
            "        self.assertRaises(RuntimeError,",
            "                          rules._assert_mergeable_rules,",
            "                          [({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                             'protocol': 1}, 8),",
            "                           ({'direction': 'ingress', 'ethertype': 'IPv6'},",
            "                            16)])",
            "",
            "    def test_merge_common_rules_single(self):",
            "        rule_conj_tuple = ({'direction': 'egress', 'ethertype': 'IPv4',",
            "                            'protocol': 1}, 8)",
            "        result = rules.merge_common_rules([rule_conj_tuple])",
            "        self.assertEqual([(rule_conj_tuple[0], [rule_conj_tuple[1]])],",
            "                         result)",
            "",
            "    def test_merge_common_rules(self):",
            "        rule_conj_list = [({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1}, 8),",
            "                          ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1, 'port_range_min': 3}, 16),",
            "                          ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1, 'port_range_min': 3,",
            "                            'port_range_max': 0}, 40),",
            "                          ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1}, 24)]",
            "        result = rules.merge_common_rules(rule_conj_list)",
            "        self.assertItemsEqual(",
            "            [({'direction': 'ingress', 'ethertype': 'IPv4',",
            "               'protocol': 1}, [8, 24]),",
            "             ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "               'protocol': 1, 'port_range_min': 3}, [16]),",
            "             ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "               'protocol': 1, 'port_range_min': 3, 'port_range_max': 0},",
            "              [40])],",
            "            result)",
            "",
            "    def test_merge_port_ranges_overlapping(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict([('port_range_min', 20), ('port_range_max', 30)] +",
            "                   self.rule_tmpl), 6),",
            "             (dict([('port_range_min', 30), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 14),",
            "             (dict([('port_range_min', 35), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 22),",
            "             (dict([('port_range_min', 20), ('port_range_max', 20)] +",
            "                   self.rule_tmpl), 30)])",
            "        self._test_merge_port_ranges_helper([",
            "            # port_range_min, port_range_max, conj_ids",
            "            (20, 20, {6, 30}),",
            "            (21, 29, {6}),",
            "            (30, 30, {6, 14}),",
            "            (31, 34, {14}),",
            "            (35, 40, {14, 22})], result)",
            "",
            "    def test_merge_port_ranges_no_port_ranges(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict(self.rule_tmpl), 10),",
            "             (dict(self.rule_tmpl), 12),",
            "             (dict([('port_range_min', 30), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 4)])",
            "        self._test_merge_port_ranges_helper([",
            "                (1, 29, {10, 12}),",
            "                (30, 40, {10, 12, 4}),",
            "                (41, 65535, {10, 12})], result)",
            "",
            "    def test_merge_port_ranges_nonoverlapping(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict([('port_range_min', 30), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 32),",
            "             (dict([('port_range_min', 100), ('port_range_max', 140)] +",
            "                   self.rule_tmpl), 40)])",
            "        self._test_merge_port_ranges_helper(",
            "            [(30, 40, {32}), (100, 140, {40})], result)",
            "",
            "",
            "class TestFlowPriority(base.BaseTestCase):",
            "    def test_flow_priority_offset(self):",
            "        self.assertEqual(0,",
            "                         rules.flow_priority_offset(",
            "                             {'foo': 'bar',",
            "                              'remote_group_id': 'hoge'}))",
            "        self.assertEqual(4,",
            "                         rules.flow_priority_offset({'foo': 'bar'}))",
            "        self.assertEqual(5,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_ICMP}))",
            "        self.assertEqual(7,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_TCP}))",
            "",
            "        self.assertEqual(6,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_ICMP,",
            "                              'port_range_min': 0}))",
            "        self.assertEqual(7,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_IPV6_ICMP,",
            "                              'port_range_min': 0, 'port_range_max': 0}))"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Red Hat, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from neutron_lib import constants",
            "",
            "from neutron.agent.linux.openvswitch_firewall import constants as ovsfw_consts",
            "from neutron.agent.linux.openvswitch_firewall import firewall as ovsfw",
            "from neutron.agent.linux.openvswitch_firewall import rules",
            "from neutron.common import constants as n_const",
            "from neutron.plugins.ml2.drivers.openvswitch.agent.common import constants \\",
            "        as ovs_consts",
            "from neutron.tests import base",
            "",
            "TESTING_VLAN_TAG = 1",
            "",
            "",
            "class TestIsValidPrefix(base.BaseTestCase):",
            "    def test_valid_prefix_ipv4(self):",
            "        is_valid = rules.is_valid_prefix('10.0.0.0/0')",
            "        self.assertTrue(is_valid)",
            "",
            "    def test_invalid_prefix_ipv4(self):",
            "        is_valid = rules.is_valid_prefix('0.0.0.0/0')",
            "        self.assertFalse(is_valid)",
            "",
            "    def test_valid_prefix_ipv6(self):",
            "        is_valid = rules.is_valid_prefix('ffff::0/0')",
            "        self.assertTrue(is_valid)",
            "",
            "    def test_invalid_prefix_ipv6(self):",
            "        is_valid = rules.is_valid_prefix('0000:0::0/0')",
            "        self.assertFalse(is_valid)",
            "        is_valid = rules.is_valid_prefix('::0/0')",
            "        self.assertFalse(is_valid)",
            "        is_valid = rules.is_valid_prefix('::/0')",
            "        self.assertFalse(is_valid)",
            "",
            "",
            "class TestCreateFlowsFromRuleAndPort(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestCreateFlowsFromRuleAndPort, self).setUp()",
            "        ovs_port = mock.Mock(vif_mac='00:00:00:00:00:00')",
            "        ovs_port.ofport = 1",
            "        port_dict = {'device': 'port_id'}",
            "        self.port = ovsfw.OFPort(",
            "            port_dict, ovs_port, vlan_tag=TESTING_VLAN_TAG)",
            "",
            "        self.create_flows_mock = mock.patch.object(",
            "            rules, 'create_protocol_flows').start()",
            "",
            "    @property",
            "    def passed_flow_template(self):",
            "        return self.create_flows_mock.call_args[0][1]",
            "",
            "    def _test_create_flows_from_rule_and_port_helper(",
            "            self, rule, expected_template):",
            "        rules.create_flows_from_rule_and_port(rule, self.port)",
            "",
            "        self.assertEqual(expected_template, self.passed_flow_template)",
            "",
            "    def test_create_flows_from_rule_and_port_no_ip_ipv4(self):",
            "        rule = {",
            "            'ethertype': constants.IPv4,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_port': self.port.ofport,",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_ipv4(self):",
            "        rule = {",
            "            'ethertype': constants.IPv4,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '192.168.0.0/24',",
            "            'dest_ip_prefix': '10.0.0.1/32',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_port': self.port.ofport,",
            "            'nw_src': '192.168.0.0/24',",
            "            'nw_dst': '10.0.0.1/32',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_with_zero_ipv4(self):",
            "        rule = {",
            "            'ethertype': constants.IPv4,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '192.168.0.0/24',",
            "            'dest_ip_prefix': '0.0.0.0/0',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_port': self.port.ofport,",
            "            'nw_src': '192.168.0.0/24',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_no_ip_ipv6(self):",
            "        rule = {",
            "            'ethertype': constants.IPv6,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'reg_port': self.port.ofport,",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_ipv6(self):",
            "        rule = {",
            "            'ethertype': constants.IPv6,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '2001:db8:bbbb::1/64',",
            "            'dest_ip_prefix': '2001:db8:aaaa::1/64',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'reg_port': self.port.ofport,",
            "            'ipv6_src': '2001:db8:bbbb::1/64',",
            "            'ipv6_dst': '2001:db8:aaaa::1/64',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "    def test_create_flows_from_rule_and_port_src_and_dst_with_zero_ipv6(self):",
            "        rule = {",
            "            'ethertype': constants.IPv6,",
            "            'direction': constants.INGRESS_DIRECTION,",
            "            'source_ip_prefix': '2001:db8:bbbb::1/64',",
            "            'dest_ip_prefix': '::/0',",
            "        }",
            "        expected_template = {",
            "            'priority': 74,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'reg_port': self.port.ofport,",
            "            'ipv6_src': '2001:db8:bbbb::1/64',",
            "        }",
            "        self._test_create_flows_from_rule_and_port_helper(rule,",
            "                                                          expected_template)",
            "",
            "",
            "class TestCreateProtocolFlows(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestCreateProtocolFlows, self).setUp()",
            "        ovs_port = mock.Mock(vif_mac='00:00:00:00:00:00')",
            "        ovs_port.ofport = 1",
            "        port_dict = {'device': 'port_id'}",
            "        self.port = ovsfw.OFPort(",
            "            port_dict, ovs_port, vlan_tag=TESTING_VLAN_TAG)",
            "",
            "    def _test_create_protocol_flows_helper(self, direction, rule,",
            "                                           expected_flows):",
            "        flow_template = {'some_settings': 'foo'}",
            "        for flow in expected_flows:",
            "            flow.update(flow_template)",
            "        flows = rules.create_protocol_flows(",
            "            direction, flow_template, self.port, rule)",
            "        self.assertEqual(expected_flows, flows)",
            "",
            "    def test_create_protocol_flows_ingress(self):",
            "        rule = {'protocol': constants.PROTO_NUM_TCP}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_INGRESS_TABLE,",
            "            'actions': 'output:1',",
            "            'nw_proto': constants.PROTO_NUM_TCP,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.INGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_egress(self):",
            "        rule = {'protocol': constants.PROTO_NUM_TCP}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_TCP,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_no_protocol(self):",
            "        rule = {}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_icmp6(self):",
            "        rule = {'ethertype': constants.IPv6,",
            "                'protocol': constants.PROTO_NUM_IPV6_ICMP}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_IPV6_ICMP,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_port_range(self):",
            "        rule = {'ethertype': constants.IPv4,",
            "                'protocol': constants.PROTO_NUM_TCP,",
            "                'port_range_min': 22,",
            "                'port_range_max': 23}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_TCP,",
            "            'tcp_dst': '0x0016/0xfffe'",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_icmp(self):",
            "        rule = {'ethertype': constants.IPv4,",
            "                'protocol': constants.PROTO_NUM_ICMP,",
            "                'port_range_min': 0}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_ICMP,",
            "            'icmp_type': 0",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "    def test_create_protocol_flows_ipv6_icmp(self):",
            "        rule = {'ethertype': constants.IPv6,",
            "                'protocol': constants.PROTO_NUM_IPV6_ICMP,",
            "                'port_range_min': 5,",
            "                'port_range_max': 0}",
            "        expected_flows = [{",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'actions': 'resubmit(,{:d})'.format(",
            "                ovs_consts.ACCEPT_OR_INGRESS_TABLE),",
            "            'nw_proto': constants.PROTO_NUM_IPV6_ICMP,",
            "            'icmp_type': 5,",
            "            'icmp_code': 0,",
            "        }]",
            "        self._test_create_protocol_flows_helper(",
            "            constants.EGRESS_DIRECTION, rule, expected_flows)",
            "",
            "",
            "class TestCreatePortRangeFlows(base.BaseTestCase):",
            "    def _test_create_port_range_flows_helper(self, expected_flows, rule):",
            "        flow_template = {'some_settings': 'foo'}",
            "        for flow in expected_flows:",
            "            flow.update(flow_template)",
            "        port_range_flows = rules.create_port_range_flows(flow_template, rule)",
            "        self.assertEqual(expected_flows, port_range_flows)",
            "",
            "    def test_create_port_range_flows_with_source_and_destination(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "            'source_port_range_min': 123,",
            "            'source_port_range_max': 124,",
            "            'port_range_min': 10,",
            "            'port_range_max': 11,",
            "        }",
            "        expected_flows = [",
            "            {'tcp_src': '0x007b', 'tcp_dst': '0x000a/0xfffe'},",
            "            {'tcp_src': '0x007c', 'tcp_dst': '0x000a/0xfffe'},",
            "        ]",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_flows_with_source(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "            'source_port_range_min': 123,",
            "            'source_port_range_max': 124,",
            "        }",
            "        expected_flows = [",
            "            {'tcp_src': '0x007b'},",
            "            {'tcp_src': '0x007c'},",
            "        ]",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_flows_with_destination(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "            'port_range_min': 10,",
            "            'port_range_max': 11,",
            "        }",
            "        expected_flows = [",
            "            {'tcp_dst': '0x000a/0xfffe'},",
            "        ]",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_flows_without_port_range(self):",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_TCP,",
            "        }",
            "        expected_flows = []",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "    def test_create_port_range_with_icmp_protocol(self):",
            "        # NOTE: such call is prevented by create_protocols_flows",
            "        rule = {",
            "            'protocol': constants.PROTO_NUM_ICMP,",
            "            'port_range_min': 10,",
            "            'port_range_max': 11,",
            "        }",
            "        expected_flows = []",
            "        self._test_create_port_range_flows_helper(expected_flows, rule)",
            "",
            "",
            "class TestCreateFlowsForIpAddress(base.BaseTestCase):",
            "    def _generate_conjuncion_actions(self, conj_ids, offset):",
            "        return ','.join(",
            "            [\"conjunction(%d,1/2)\" % (c + offset)",
            "             for c in conj_ids])",
            "",
            "    def test_create_flows_for_ip_address_egress(self):",
            "        expected_template = {",
            "            'table': ovs_consts.RULES_EGRESS_TABLE,",
            "            'priority': 72,",
            "            'dl_type': n_const.ETHERTYPE_IP,",
            "            'reg_net': 0x123,",
            "            'nw_dst': '192.168.0.1/32'",
            "        }",
            "",
            "        conj_ids = [12, 20]",
            "        flows = rules.create_flows_for_ip_address(",
            "            '192.168.0.1', constants.EGRESS_DIRECTION, constants.IPv4,",
            "            0x123, conj_ids)",
            "",
            "        self.assertEqual(2, len(flows))",
            "        self.assertEqual(ovsfw_consts.OF_STATE_ESTABLISHED_NOT_REPLY,",
            "                         flows[0]['ct_state'])",
            "        self.assertEqual(ovsfw_consts.OF_STATE_NEW_NOT_ESTABLISHED,",
            "                         flows[1]['ct_state'])",
            "        for i in range(2):",
            "            self.assertEqual(self._generate_conjuncion_actions(conj_ids, i),",
            "                             flows[i]['actions'])",
            "        for f in flows:",
            "            del f['actions']",
            "            del f['ct_state']",
            "            self.assertEqual(expected_template, f)",
            "",
            "",
            "class TestCreateConjFlows(base.BaseTestCase):",
            "    def test_create_conj_flows(self):",
            "        ovs_port = mock.Mock(ofport=1, vif_mac='00:00:00:00:00:00')",
            "        port_dict = {'device': 'port_id'}",
            "        port = ovsfw.OFPort(",
            "            port_dict, ovs_port, vlan_tag=TESTING_VLAN_TAG)",
            "",
            "        conj_id = 1234",
            "        expected_template = {",
            "            'table': ovs_consts.RULES_INGRESS_TABLE,",
            "            'dl_type': n_const.ETHERTYPE_IPV6,",
            "            'priority': 71,",
            "            'conj_id': conj_id,",
            "            'reg_port': port.ofport",
            "        }",
            "",
            "        flows = rules.create_conj_flows(port, conj_id,",
            "                                        constants.INGRESS_DIRECTION,",
            "                                        constants.IPv6)",
            "",
            "        self.assertEqual(ovsfw_consts.OF_STATE_ESTABLISHED_NOT_REPLY,",
            "                         flows[0]['ct_state'])",
            "        self.assertEqual(ovsfw_consts.OF_STATE_NEW_NOT_ESTABLISHED,",
            "                         flows[1]['ct_state'])",
            "        self.assertEqual(\"output:{:d}\".format(port.ofport),",
            "                         flows[0]['actions'])",
            "        self.assertEqual(\"ct(commit,zone=NXM_NX_REG{:d}[0..15]),{:s},\"",
            "                         \"resubmit(,{:d})\".format(",
            "                             ovsfw_consts.REG_NET, flows[0]['actions'],",
            "                             ovs_consts.ACCEPTED_INGRESS_TRAFFIC_TABLE),",
            "                         flows[1]['actions'])",
            "",
            "        for f in flows:",
            "            del f['actions']",
            "            del f['ct_state']",
            "            self.assertEqual(expected_template, f)",
            "            expected_template['conj_id'] += 1",
            "",
            "",
            "class TestMergeRules(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(TestMergeRules, self).setUp()",
            "        self.rule_tmpl = [('direction', 'ingress'), ('ethertype', 'IPv4'),",
            "                          ('protocol', 6)]",
            "",
            "    def _test_merge_port_ranges_helper(self, expected, result):",
            "        \"\"\"Take a list of (port_range_min, port_range_max, conj_ids)",
            "        and an output from rules.merge_port_ranges and check if they",
            "        are identical, ignoring the other rule fields.",
            "        \"\"\"",
            "        self.assertEqual(len(expected), len(result))",
            "        for (range_min, range_max, conj_ids), result1 in zip(",
            "                expected, result):",
            "            self.assertEqual(range_min, result1[0].get('port_range_min'))",
            "            self.assertEqual(range_max, result1[0].get('port_range_max'))",
            "            self.assertEqual(conj_ids, set(result1[1]))",
            "",
            "    def test__assert_mergeable_rules(self):",
            "        self.assertRaises(RuntimeError,",
            "                          rules._assert_mergeable_rules,",
            "                          [({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                             'protocol': 1}, 8),",
            "                           ({'direction': 'ingress', 'ethertype': 'IPv6'},",
            "                            16)])",
            "",
            "    def test_merge_common_rules_single(self):",
            "        rule_conj_tuple = ({'direction': 'egress', 'ethertype': 'IPv4',",
            "                            'protocol': 1}, 8)",
            "        result = rules.merge_common_rules([rule_conj_tuple])",
            "        self.assertEqual([(rule_conj_tuple[0], [rule_conj_tuple[1]])],",
            "                         result)",
            "",
            "    def test_merge_common_rules(self):",
            "        rule_conj_list = [({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1}, 8),",
            "                          ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1, 'port_range_min': 3}, 16),",
            "                          ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1, 'port_range_min': 3,",
            "                            'port_range_max': 0}, 40),",
            "                          ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "                            'protocol': 1}, 24)]",
            "        result = rules.merge_common_rules(rule_conj_list)",
            "        self.assertItemsEqual(",
            "            [({'direction': 'ingress', 'ethertype': 'IPv4',",
            "               'protocol': 1}, [8, 24]),",
            "             ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "               'protocol': 1, 'port_range_min': 3}, [16]),",
            "             ({'direction': 'ingress', 'ethertype': 'IPv4',",
            "               'protocol': 1, 'port_range_min': 3, 'port_range_max': 0},",
            "              [40])],",
            "            result)",
            "",
            "    def test_merge_port_ranges_overlapping(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict([('port_range_min', 20), ('port_range_max', 30)] +",
            "                   self.rule_tmpl), 6),",
            "             (dict([('port_range_min', 30), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 14),",
            "             (dict([('port_range_min', 35), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 22),",
            "             (dict([('port_range_min', 20), ('port_range_max', 20)] +",
            "                   self.rule_tmpl), 30)])",
            "        self._test_merge_port_ranges_helper([",
            "            # port_range_min, port_range_max, conj_ids",
            "            (20, 20, {6, 30}),",
            "            (21, 29, {6}),",
            "            (30, 30, {6, 14}),",
            "            (31, 34, {14}),",
            "            (35, 40, {14, 22})], result)",
            "",
            "    def test_merge_port_ranges_no_port_ranges(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict(self.rule_tmpl), 10),",
            "             (dict(self.rule_tmpl), 12),",
            "             (dict([('port_range_min', 30), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 4)])",
            "        self._test_merge_port_ranges_helper([",
            "                (1, 29, {10, 12}),",
            "                (30, 40, {10, 12, 4}),",
            "                (41, 65535, {10, 12})], result)",
            "",
            "    def test_merge_port_ranges_no_port_ranges_same_conj_id(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict(self.rule_tmpl), 10),",
            "             (dict(self.rule_tmpl), 12),",
            "             (dict([('port_range_min', 30), ('port_range_max', 30)] +",
            "                   self.rule_tmpl), 10)])",
            "        self._test_merge_port_ranges_helper([",
            "                (None, None, {10, 12})], result)",
            "",
            "    def test_merge_port_ranges_nonoverlapping(self):",
            "        result = rules.merge_port_ranges(",
            "            [(dict([('port_range_min', 30), ('port_range_max', 40)] +",
            "                   self.rule_tmpl), 32),",
            "             (dict([('port_range_min', 100), ('port_range_max', 140)] +",
            "                   self.rule_tmpl), 40)])",
            "        self._test_merge_port_ranges_helper(",
            "            [(30, 40, {32}), (100, 140, {40})], result)",
            "",
            "",
            "class TestFlowPriority(base.BaseTestCase):",
            "    def test_flow_priority_offset(self):",
            "        self.assertEqual(0,",
            "                         rules.flow_priority_offset(",
            "                             {'foo': 'bar',",
            "                              'remote_group_id': 'hoge'}))",
            "        self.assertEqual(4,",
            "                         rules.flow_priority_offset({'foo': 'bar'}))",
            "        self.assertEqual(5,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_ICMP}))",
            "        self.assertEqual(7,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_TCP}))",
            "",
            "        self.assertEqual(6,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_ICMP,",
            "                              'port_range_min': 0}))",
            "        self.assertEqual(7,",
            "                         rules.flow_priority_offset(",
            "                             {'protocol': constants.PROTO_NUM_IPV6_ICMP,",
            "                              'port_range_min': 0, 'port_range_max': 0}))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "423": [
                "TestMergeRules",
                "_test_merge_port_ranges_helper"
            ],
            "424": [
                "TestMergeRules",
                "_test_merge_port_ranges_helper"
            ]
        },
        "addLocation": []
    }
}