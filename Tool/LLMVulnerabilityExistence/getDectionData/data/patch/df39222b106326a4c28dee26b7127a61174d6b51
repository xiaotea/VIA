{
    "nova/tests/unit/virt/libvirt/test_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "             _context, image_id, target, trusted_certs)"
            },
            "1": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 444,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "3": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch.object(format_inspector, 'get_inspector')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+    @mock.patch.object(format_inspector, 'detect_file_format')"
            },
            "5": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "     @mock.patch.object(compute_utils, 'disk_ops_semaphore')"
            },
            "6": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "     @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)"
            },
            "7": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "     @mock.patch('nova.privsep.qemu.unprivileged_convert_image')"
            },
            "8": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "     def test_fetch_raw_image(self, mock_convert_image, mock_direct_io,"
            },
            "9": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                             mock_disk_op_sema, mock_gi, mock_glance):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+                             mock_disk_op_sema, mock_detect, mock_glance):"
            },
            "11": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 452,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "         def fake_rename(old, new):"
            },
            "13": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 454,
                "PatchRowcode": "             self.executes.append(('mv', old, new))"
            },
            "14": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": 488,
                "PatchRowcode": "         self.stub_out('oslo_utils.fileutils.delete_if_exists',"
            },
            "15": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 489,
                "PatchRowcode": "                       fake_rm_on_error)"
            },
            "16": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 490,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_inspector = mock_gi.return_value.from_file.return_value"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        mock_inspector = mock_detect.return_value"
            },
            "19": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 492,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 493,
                "PatchRowcode": "         # Since the remove param of fileutils.remove_path_on_error()"
            },
            "21": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 494,
                "PatchRowcode": "         # is initialized at load time, we must provide a wrapper"
            },
            "22": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 502,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "         # Make sure qcow2 gets converted to raw"
            },
            "24": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "         mock_inspector.safety_check.return_value = True"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 505,
                "PatchRowcode": "+        mock_inspector.__str__.return_value = 'qcow2'"
            },
            "26": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'qcow2'}"
            },
            "27": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 507,
                "PatchRowcode": "         target = 't.qcow2'"
            },
            "28": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "         self.executes = []"
            },
            "29": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 517,
                "PatchRowcode": "             dest_encryption=None)"
            },
            "30": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 518,
                "PatchRowcode": "         mock_convert_image.reset_mock()"
            },
            "31": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 519,
                "PatchRowcode": "         mock_inspector.safety_check.assert_called_once_with()"
            },
            "32": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.assert_called_once_with('qcow2')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+        mock_detect.assert_called_once_with('t.qcow2.part')"
            },
            "34": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 521,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 522,
                "PatchRowcode": "         # Make sure raw does not get converted"
            },
            "36": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.reset_mock()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 523,
                "PatchRowcode": "+        mock_detect.reset_mock()"
            },
            "38": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 524,
                "PatchRowcode": "         mock_inspector.safety_check.reset_mock()"
            },
            "39": {
                "beforePatchRowNumber": 524,
                "afterPatchRowNumber": 525,
                "PatchRowcode": "         mock_inspector.safety_check.return_value = True"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+        mock_inspector.__str__.return_value = 'raw'"
            },
            "41": {
                "beforePatchRowNumber": 525,
                "afterPatchRowNumber": 527,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'raw'}"
            },
            "42": {
                "beforePatchRowNumber": 526,
                "afterPatchRowNumber": 528,
                "PatchRowcode": "         target = 't.raw'"
            },
            "43": {
                "beforePatchRowNumber": 527,
                "afterPatchRowNumber": 529,
                "PatchRowcode": "         self.executes = []"
            },
            "44": {
                "beforePatchRowNumber": 530,
                "afterPatchRowNumber": 532,
                "PatchRowcode": "         self.assertEqual(self.executes, expected_commands)"
            },
            "45": {
                "beforePatchRowNumber": 531,
                "afterPatchRowNumber": 533,
                "PatchRowcode": "         mock_convert_image.assert_not_called()"
            },
            "46": {
                "beforePatchRowNumber": 532,
                "afterPatchRowNumber": 534,
                "PatchRowcode": "         mock_inspector.safety_check.assert_called_once_with()"
            },
            "47": {
                "beforePatchRowNumber": 533,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.assert_called_once_with('raw')"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 535,
                "PatchRowcode": "+        mock_detect.assert_called_once_with('t.raw.part')"
            },
            "49": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": 536,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 535,
                "afterPatchRowNumber": 537,
                "PatchRowcode": "         # Make sure safety check failure prevents us from proceeding"
            },
            "51": {
                "beforePatchRowNumber": 536,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.reset_mock()"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 538,
                "PatchRowcode": "+        mock_detect.reset_mock()"
            },
            "53": {
                "beforePatchRowNumber": 537,
                "afterPatchRowNumber": 539,
                "PatchRowcode": "         mock_inspector.safety_check.reset_mock()"
            },
            "54": {
                "beforePatchRowNumber": 538,
                "afterPatchRowNumber": 540,
                "PatchRowcode": "         mock_inspector.safety_check.return_value = False"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 541,
                "PatchRowcode": "+        mock_inspector.__str__.return_value = 'qcow2'"
            },
            "56": {
                "beforePatchRowNumber": 539,
                "afterPatchRowNumber": 542,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'qcow2'}"
            },
            "57": {
                "beforePatchRowNumber": 540,
                "afterPatchRowNumber": 543,
                "PatchRowcode": "         target = 'backing.qcow2'"
            },
            "58": {
                "beforePatchRowNumber": 541,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "         self.executes = []"
            },
            "59": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "         self.assertEqual(self.executes, expected_commands)"
            },
            "60": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 549,
                "PatchRowcode": "         mock_convert_image.assert_not_called()"
            },
            "61": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "         mock_inspector.safety_check.assert_called_once_with()"
            },
            "62": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.assert_called_once_with('qcow2')"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 551,
                "PatchRowcode": "+        mock_detect.assert_called_once_with('backing.qcow2.part')"
            },
            "64": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 552,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 553,
                "PatchRowcode": "         # Make sure a format mismatch prevents us from proceeding"
            },
            "66": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.reset_mock()"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 554,
                "PatchRowcode": "+        mock_detect.reset_mock()"
            },
            "68": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 555,
                "PatchRowcode": "         mock_inspector.safety_check.reset_mock()"
            },
            "69": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": 556,
                "PatchRowcode": "         mock_inspector.safety_check.side_effect = ("
            },
            "70": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": 557,
                "PatchRowcode": "             format_inspector.ImageFormatError)"
            },
            "71": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 564,
                "PatchRowcode": "         self.assertEqual(self.executes, expected_commands)"
            },
            "72": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "         mock_convert_image.assert_not_called()"
            },
            "73": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 566,
                "PatchRowcode": "         mock_inspector.safety_check.assert_called_once_with()"
            },
            "74": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.assert_called_once_with('qcow2')"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+        mock_detect.assert_called_once_with('backing.qcow2.part')"
            },
            "76": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 568,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "         del self.executes"
            },
            "78": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 570,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 NTT Data. All Rights Reserved.",
            "# Copyright 2012 Yahoo! Inc. All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import grp",
            "import os",
            "import pwd",
            "import tempfile",
            "from unittest import mock",
            "",
            "import ddt",
            "import os_traits",
            "from oslo_config import cfg",
            "from oslo_utils import fileutils",
            "from oslo_utils.fixture import uuidsentinel as uuids",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import context",
            "from nova import exception",
            "from nova.image import format_inspector",
            "from nova import objects",
            "from nova.objects import fields as obj_fields",
            "import nova.privsep.fs",
            "import nova.privsep.qemu",
            "from nova import test",
            "from nova.tests import fixtures as nova_fixtures",
            "from nova.tests.unit import fake_instance",
            "from nova.virt import images",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "@ddt.ddt",
            "class LibvirtUtilsTestCase(test.NoDBTestCase):",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_copy_image_local(self, mock_execute):",
            "        libvirt_utils.copy_image('src', 'dest')",
            "        mock_execute.assert_called_once_with('cp', '-r', 'src', 'dest')",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.SshDriver.copy_file')",
            "    def test_copy_image_remote_ssh(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='ssh', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.RsyncDriver.copy_file')",
            "    def test_copy_image_remote_rsync(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='rsync', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_disk_type_from_path(self, mock_exists):",
            "        # Seems like lvm detection",
            "        # if its in /dev ??",
            "        for p in ['/dev/b', '/dev/blah/blah']:",
            "            d_type = libvirt_utils.get_disk_type_from_path(p)",
            "            self.assertEqual('lvm', d_type)",
            "",
            "        # Try rbd detection",
            "        d_type = libvirt_utils.get_disk_type_from_path('rbd:pool/instance')",
            "        self.assertEqual('rbd', d_type)",
            "",
            "        # Try the other types",
            "        path = '/myhome/disk.config'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        self.assertIsNone(d_type)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=True)",
            "    def test_disk_type_ploop(self, mock_isdir, mock_exists):",
            "        path = '/some/path'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        mock_isdir.assert_called_once_with(path)",
            "        mock_exists.assert_called_once_with(\"%s/DiskDescriptor.xml\" % path)",
            "        self.assertEqual('ploop', d_type)",
            "",
            "    def test_valid_hostname_normal(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"hello.world.com\"))",
            "",
            "    def test_valid_hostname_ipv4addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"10.0.2.1\"))",
            "",
            "    def test_valid_hostname_ipv6addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"240:2ac3::2\"))",
            "",
            "    def test_valid_hostname_bad(self):",
            "        self.assertFalse(libvirt_utils.is_valid_hostname(\"foo/?com=/bin/sh\"))",
            "",
            "    @mock.patch('tempfile.NamedTemporaryFile')",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch('nova.virt.images.qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    def _test_create_image(",
            "        self, path, disk_format, disk_size, mock_detect, mock_info,",
            "        mock_execute, mock_ntf, backing_file=None, encryption=None,",
            "        safety_check=True",
            "    ):",
            "        if isinstance(backing_file, dict):",
            "            backing_info = backing_file",
            "            backing_file = backing_info.pop('file', None)",
            "        else:",
            "            backing_info = {}",
            "        backing_backing_file = backing_info.pop('backing_file', None)",
            "        backing_fmt = backing_info.pop('backing_fmt',",
            "                                       mock.sentinel.backing_fmt)",
            "",
            "        mock_info.return_value = mock.Mock(",
            "            file_format=backing_fmt,",
            "            cluster_size=mock.sentinel.cluster_size,",
            "            backing_file=backing_backing_file,",
            "            format_specific=backing_info,",
            "        )",
            "        fh = mock_ntf.return_value.__enter__.return_value",
            "",
            "        mock_detect.return_value.safety_check.return_value = safety_check",
            "",
            "        libvirt_utils.create_image(",
            "            path, disk_format, disk_size, backing_file=backing_file,",
            "            encryption=encryption,",
            "        )",
            "",
            "        cow_opts = []",
            "",
            "        if backing_file is None:",
            "            mock_info.assert_not_called()",
            "        else:",
            "            mock_info.assert_called_once_with(backing_file)",
            "            cow_opts = [",
            "                '-o',",
            "                f'backing_file={backing_file},'",
            "                f'backing_fmt={backing_fmt},'",
            "                f'cluster_size={mock.sentinel.cluster_size}',",
            "            ]",
            "",
            "        encryption_opts = []",
            "",
            "        if encryption:",
            "            encryption_opts = [",
            "                '--object', f\"secret,id=sec,file={fh.name}\",",
            "                '-o', 'encrypt.key-secret=sec',",
            "                '-o', f\"encrypt.format={encryption.get('format')}\",",
            "            ]",
            "",
            "            encryption_options = {",
            "                'cipher-alg': 'aes-256',",
            "                'cipher-mode': 'xts',",
            "                'hash-alg': 'sha256',",
            "                'iter-time': 2000,",
            "                'ivgen-alg': 'plain64',",
            "                'ivgen-hash-alg': 'sha256',",
            "            }",
            "            for option, value in encryption_options.items():",
            "                encryption_opts += [",
            "                    '-o',",
            "                    f'encrypt.{option}={value}',",
            "                ]",
            "",
            "        expected_args = (",
            "            'env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'create', '-f',",
            "            disk_format, *cow_opts, *encryption_opts, path,",
            "        )",
            "        if disk_size is not None:",
            "            expected_args += (disk_size,)",
            "",
            "        self.assertEqual([(expected_args,)], mock_execute.call_args_list)",
            "        if backing_file:",
            "            mock_detect.return_value.safety_check.assert_called_once_with()",
            "",
            "    def test_create_image_raw(self):",
            "        self._test_create_image('/some/path', 'raw', '10G')",
            "",
            "    def test_create_image_qcow2(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "        )",
            "",
            "    def test_create_image_backing_file(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_base_has_backing_file(self):",
            "        self.assertRaises(",
            "            exception.InvalidDiskInfo,",
            "            self._test_create_image,",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_file': mock.sentinel.backing_backing_file},",
            "        )",
            "",
            "    def test_create_image_base_has_data_file(self):",
            "        self.assertRaises(",
            "            exception.InvalidDiskInfo,",
            "            self._test_create_image,",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_file': mock.sentinel.backing_backing_file,",
            "                          'data': {'data-file': mock.sentinel.data_file}},",
            "        )",
            "",
            "    def test_create_image_size_none(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', None,",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_vmdk(self):",
            "        self._test_create_image(",
            "            '/some/vmdk', 'vmdk', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_fmt': 'vmdk',",
            "                          'backing_file': None,",
            "                          'data': {'create-type': 'monolithicSparse'}}",
            "        )",
            "",
            "    def test_create_image_vmdk_invalid_type(self):",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "            self._test_create_image,",
            "            '/some/vmdk', 'vmdk', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_fmt': 'vmdk',",
            "                          'backing_file': None,",
            "                          'data': {'create-type': 'monolithicFlat'}}",
            "        )",
            "",
            "    def test_create_image_encryption(self):",
            "        encryption = {",
            "            'secret': 'a_secret',",
            "            'format': 'luks',",
            "        }",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            encryption=encryption,",
            "        )",
            "",
            "    @ddt.unpack",
            "    @ddt.data({'fs_type': 'some_fs_type',",
            "               'default_eph_format': None,",
            "               'expected_fs_type': 'some_fs_type'},",
            "              {'fs_type': None,",
            "               'default_eph_format': None,",
            "               'expected_fs_type': nova.privsep.fs.FS_FORMAT_EXT4},",
            "              {'fs_type': None,",
            "               'default_eph_format': 'eph_format',",
            "               'expected_fs_type': 'eph_format'})",
            "    def test_create_ploop_image(self, fs_type,",
            "                                default_eph_format,",
            "                                expected_fs_type):",
            "        with test.nested(mock.patch('oslo_utils.fileutils.ensure_tree'),",
            "                         mock.patch('nova.privsep.libvirt.ploop_init')",
            "                         ) as (mock_ensure_tree, mock_ploop_init):",
            "            self.flags(default_ephemeral_format=default_eph_format)",
            "            libvirt_utils.create_ploop_image('expanded', '/some/path',",
            "                                             '5G', fs_type)",
            "            mock_ensure_tree.assert_has_calls([",
            "                mock.call('/some/path')])",
            "            mock_ploop_init.assert_has_calls([",
            "                mock.call('5G', 'expanded', expected_fs_type,",
            "                          '/some/path/root.hds')])",
            "",
            "    def test_copy_image(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            src_fd, src_path = tempfile.mkstemp()",
            "            try:",
            "                with os.fdopen(src_fd, 'w') as fp:",
            "                    fp.write('canary')",
            "",
            "                libvirt_utils.copy_image(src_path, dst_path)",
            "                with open(dst_path, 'r') as fp:",
            "                    self.assertEqual(fp.read(), 'canary')",
            "            finally:",
            "                os.unlink(src_path)",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_no_directio(self, mock_execute,",
            "                                  mock_direct_io,",
            "                                  mock_disk_op_sema):",
            "        # Test a single variant with no support for direct IO.",
            "        # This could be removed if we add unit tests for convert_image().",
            "        src_format = 'qcow2'",
            "        dest_format = 'raw'",
            "        out_format = 'raw'",
            "",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'writeback',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    def _do_test_extract_snapshot(self, mock_execute, mock_direct_io,",
            "                                  mock_disk_op_sema,",
            "                                  src_format='qcow2',",
            "                                  dest_format='raw', out_format='raw'):",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'none',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_raw(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_iso(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute, dest_format='iso')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2_and_compression(self, mock_execute):",
            "        self.flags(snapshot_compression=True, group='libvirt')",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_parallels(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       src_format='raw',",
            "                                       dest_format='ploop',",
            "                                       out_format='parallels')",
            "",
            "    def test_load_file(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            self.assertEqual(libvirt_utils.load_file(dst_path), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_file_open(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            with libvirt_utils.file_open(dst_path, 'r') as fp:",
            "                self.assertEqual(fp.read(), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_get_fs_info(self):",
            "",
            "        class FakeStatResult(object):",
            "",
            "            def __init__(self):",
            "                self.f_bsize = 4096",
            "                self.f_frsize = 4096",
            "                self.f_blocks = 2000",
            "                self.f_bfree = 1000",
            "                self.f_bavail = 900",
            "                self.f_files = 2000",
            "                self.f_ffree = 1000",
            "                self.f_favail = 900",
            "                self.f_flag = 4096",
            "                self.f_namemax = 255",
            "",
            "        self.path = None",
            "",
            "        def fake_statvfs(path):",
            "            self.path = path",
            "            return FakeStatResult()",
            "",
            "        self.stub_out('os.statvfs', fake_statvfs)",
            "",
            "        fs_info = libvirt_utils.get_fs_info('/some/file/path')",
            "        self.assertEqual('/some/file/path', self.path)",
            "        self.assertEqual(8192000, fs_info['total'])",
            "        self.assertEqual(3686400, fs_info['free'])",
            "        self.assertEqual(4096000, fs_info['used'])",
            "",
            "    @mock.patch('nova.virt.images.fetch_to_raw')",
            "    def test_fetch_image(self, mock_images):",
            "        context = 'opaque context'",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_image(context, target, image_id, trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch('nova.virt.images.fetch')",
            "    def test_fetch_initrd_image(self, mock_images):",
            "        _context = context.RequestContext(project_id=123,",
            "                                          project_name=\"aubergine\",",
            "                                          user_id=456,",
            "                                          user_name=\"pie\")",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_raw_image(_context, target, image_id,",
            "                                      trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            _context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(format_inspector, 'get_inspector')",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_convert_image')",
            "    def test_fetch_raw_image(self, mock_convert_image, mock_direct_io,",
            "                             mock_disk_op_sema, mock_gi, mock_glance):",
            "",
            "        def fake_rename(old, new):",
            "            self.executes.append(('mv', old, new))",
            "",
            "        def fake_unlink(path):",
            "            self.executes.append(('rm', path))",
            "",
            "        def fake_rm_on_error(path, remove=None):",
            "            self.executes.append(('rm', '-f', path))",
            "",
            "        def fake_qemu_img_info(path, format=None):",
            "            class FakeImgInfo(object):",
            "                pass",
            "",
            "            file_format = path.split('.')[-1]",
            "            if file_format == 'part':",
            "                file_format = path.split('.')[-2]",
            "            elif file_format == 'converted':",
            "                file_format = 'raw'",
            "",
            "            if 'backing' in path:",
            "                backing_file = 'backing'",
            "            else:",
            "                backing_file = None",
            "",
            "            FakeImgInfo.file_format = file_format",
            "            FakeImgInfo.backing_file = backing_file",
            "            FakeImgInfo.virtual_size = 1",
            "            FakeImgInfo.format_specific = None if file_format == 'raw' else {}",
            "",
            "            return FakeImgInfo()",
            "",
            "        self.stub_out('os.rename', fake_rename)",
            "        self.stub_out('os.unlink', fake_unlink)",
            "        self.stub_out('nova.virt.images.fetch', lambda *_, **__: None)",
            "        self.stub_out('nova.virt.images.qemu_img_info', fake_qemu_img_info)",
            "        self.stub_out('oslo_utils.fileutils.delete_if_exists',",
            "                      fake_rm_on_error)",
            "",
            "        mock_inspector = mock_gi.return_value.from_file.return_value",
            "",
            "        # Since the remove param of fileutils.remove_path_on_error()",
            "        # is initialized at load time, we must provide a wrapper",
            "        # that explicitly resets it to our fake delete_if_exists()",
            "        old_rm_path_on_error = fileutils.remove_path_on_error",
            "        f = functools.partial(old_rm_path_on_error, remove=fake_rm_on_error)",
            "        self.stub_out('oslo_utils.fileutils.remove_path_on_error', f)",
            "",
            "        context = 'opaque context'",
            "        image_id = '4'",
            "",
            "        # Make sure qcow2 gets converted to raw",
            "        mock_inspector.safety_check.return_value = True",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        target = 't.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', 't.qcow2.part'),",
            "                             ('mv', 't.qcow2.converted', 't.qcow2')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_convert_image.assert_called_with(",
            "            't.qcow2.part', 't.qcow2.converted', 'qcow2', 'raw',",
            "            CONF.instances_path, False, src_encryption=None,",
            "            dest_encryption=None)",
            "        mock_convert_image.reset_mock()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_gi.assert_called_once_with('qcow2')",
            "",
            "        # Make sure raw does not get converted",
            "        mock_gi.reset_mock()",
            "        mock_inspector.safety_check.reset_mock()",
            "        mock_inspector.safety_check.return_value = True",
            "        mock_glance.get.return_value = {'disk_format': 'raw'}",
            "        target = 't.raw'",
            "        self.executes = []",
            "        expected_commands = [('mv', 't.raw.part', 't.raw')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_gi.assert_called_once_with('raw')",
            "",
            "        # Make sure safety check failure prevents us from proceeding",
            "        mock_gi.reset_mock()",
            "        mock_inspector.safety_check.reset_mock()",
            "        mock_inspector.safety_check.return_value = False",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        target = 'backing.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', '-f', 'backing.qcow2.part')]",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_gi.assert_called_once_with('qcow2')",
            "",
            "        # Make sure a format mismatch prevents us from proceeding",
            "        mock_gi.reset_mock()",
            "        mock_inspector.safety_check.reset_mock()",
            "        mock_inspector.safety_check.side_effect = (",
            "            format_inspector.ImageFormatError)",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        target = 'backing.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', '-f', 'backing.qcow2.part')]",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_gi.assert_called_once_with('qcow2')",
            "",
            "        del self.executes",
            "",
            "    def test_get_instance_path_at_destination(self):",
            "        instance = fake_instance.fake_instance_obj(None, name='fake_inst',",
            "                                                   uuid=uuids.instance)",
            "",
            "        migrate_data = None",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = {}",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            instance_relative_path='fake_relative_path')",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, 'fake_relative_path')",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "    def test_get_arch(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'properties': {'architecture': \"X86_64\"}})",
            "        image_arch = libvirt_utils.get_arch(image_meta)",
            "        self.assertEqual(obj_fields.Architecture.X86_64, image_arch)",
            "",
            "    def test_is_mounted(self):",
            "        mount_path = \"/var/lib/nova/mnt\"",
            "        source = \"192.168.0.1:/nova\"",
            "        proc_with_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.1:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_wrong_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.2:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_without_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "\"\"\"",
            "        with mock.patch.object(os.path, 'ismount') as mock_ismount:",
            "            # is_mounted(mount_path) with no source is equivalent to",
            "            # os.path.ismount(mount_path)",
            "            mock_ismount.return_value = False",
            "            self.assertFalse(libvirt_utils.is_mounted(mount_path))",
            "",
            "            mock_ismount.return_value = True",
            "            self.assertTrue(libvirt_utils.is_mounted(mount_path))",
            "",
            "            # Source is given, and matches source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_with_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertTrue(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and doesn't match source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_wrong_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and mountpoint isn't present in /proc/mounts",
            "            # Note that this shouldn't occur, as os.path.ismount should have",
            "            # previously returned False in this case.",
            "            proc_umnt = mock.mock_open(read_data=proc_without_mnt)",
            "            with mock.patch('builtins.open', proc_umnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "    def test_find_disk_file_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"file\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"qcow2\" cache=\"none\" io=\"native\"/>",
            "                <source file=\"/tmp/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/tmp/hello', disk_path)",
            "        self.assertEqual('qcow2', format)",
            "",
            "    def test_find_disk_block_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"block\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source dev=\"/dev/nova-vg/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/dev/nova-vg/hello', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_rbd(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"network\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source name=\"pool/image\" protocol=\"rbd\">",
            "                  <host name=\"1.2.3.4\" port=\"456\"/>",
            "                </source>",
            "                <target bus=\"virtio\" dev=\"/dev/vda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('rbd:pool/image', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_lxc(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='lxc'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type=\"mount\">",
            "                <source dir=\"/myhome/rootfs\"/>",
            "                <target dir=\"/\"/>",
            "              </filesystem>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/myhome/disk', disk_path)",
            "        self.assertIsNone(format)",
            "",
            "    def test_find_disk_parallels(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='parallels'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type='file'>\"",
            "                <driver format='ploop' type='ploop'/>\"",
            "                <source file='/test/disk'/>\"",
            "                <target dir='/'/>",
            "              </filesystem>\"",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/test/disk', disk_path)",
            "        self.assertEqual('ploop', format)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.get_arch')",
            "    def test_get_machine_type_from_fallbacks(self, mock_get_arch):",
            "        \"\"\"Test hardcoded arch-specific fallbacks for default machine type\"\"\"",
            "        image_meta = objects.ImageMeta.from_dict({\"disk_format\": \"raw\"})",
            "        host_cpu_archs = {",
            "            obj_fields.Architecture.ARMV7: \"virt\",",
            "            obj_fields.Architecture.AARCH64: \"virt\",",
            "            obj_fields.Architecture.S390: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.S390X: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.I686: \"pc\",",
            "            obj_fields.Architecture.X86_64: \"pc\",",
            "        }",
            "        for arch, expected_mtype in host_cpu_archs.items():",
            "            mock_get_arch.return_value = arch",
            "            mtype = libvirt_utils.get_machine_type(image_meta)",
            "            self.assertEqual(expected_mtype, mtype)",
            "",
            "    def test_get_machine_type_from_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_no_conf_or_fallback(self):",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_missing_conf_and_fallback(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_survives_invalid_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'foo']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_from_image(self):",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\", \"properties\": {\"hw_machine_type\": \"q35\"}",
            "        })",
            "        os_mach_type = libvirt_utils.get_machine_type(image_meta)",
            "        self.assertEqual('q35', os_mach_type)",
            "",
            "    def test_make_reverse_cpu_traits_mapping(self):",
            "        for k in libvirt_utils.make_reverse_cpu_traits_mapping():",
            "            self.assertIsInstance(k, str)",
            "",
            "    def test_get_flags_by_flavor_specs(self):",
            "        flavor = objects.Flavor(",
            "            id=1, flavorid='fakeid-1', name='fake1.small', memory_mb=128,",
            "            vcpus=1, root_gb=1, ephemeral_gb=0, swap=0, rxtx_factor=0,",
            "            deleted=False, extra_specs={",
            "                'trait:%s' % os_traits.HW_CPU_X86_3DNOW: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SSE2: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_HYPERTHREADING: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_INTEL_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SVM: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_AMD_SVM: 'required',",
            "            })",
            "        traits = libvirt_utils.get_flags_by_flavor_specs(flavor)",
            "        # we shouldn't see the hyperthreading trait since that's a valid trait",
            "        # but not a CPU flag",
            "        self.assertEqual(set(['3dnow', 'sse2', 'vmx', 'svm']), traits)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_save_migrate_vtpm(",
            "        self, mock_exists, mock_ensure, mock_move, mock_chown, mock_copy,",
            "    ):",
            "        def _on_execute():",
            "            pass",
            "",
            "        def _on_completion():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _on_execute,",
            "            _on_completion,",
            "        )",
            "",
            "        vtpm_dir = f'/var/lib/libvirt/swtpm/{uuids.instance}'",
            "        swtpm_dir = 'base_resize/swtpm'",
            "        mock_exists.assert_called_once_with(vtpm_dir)",
            "        mock_ensure.assert_called_once_with(swtpm_dir)",
            "        mock_move.assert_called_once_with(vtpm_dir, swtpm_dir)",
            "        mock_chown.assert_called_once_with(",
            "            swtpm_dir, os.geteuid(), os.getegid(), recursive=True,",
            "        )",
            "        mock_copy.assert_called_once_with(",
            "            swtpm_dir, 'base', host='host', on_completion=_on_completion,",
            "            on_execute=_on_execute,",
            "        )",
            "",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    def test_save_migrate_vtpm_not_enabled(",
            "        self, mock_exists, mock_copy_image, mock_chown, mock_move,",
            "    ):",
            "        def _dummy():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _dummy, _dummy,",
            "        )",
            "",
            "        mock_exists.assert_called_once_with(",
            "            f'/var/lib/libvirt/swtpm/{uuids.instance}')",
            "        mock_copy_image.assert_not_called()",
            "        mock_chown.assert_not_called()",
            "        mock_move.assert_not_called()",
            "",
            "    @mock.patch('grp.getgrnam')",
            "    @mock.patch('pwd.getpwnam')",
            "    @mock.patch('nova.privsep.path.chmod')",
            "    @mock.patch('nova.privsep.path.makedirs')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.path.isdir')",
            "    def _test_restore_vtpm(",
            "        self, exists, mock_isdir, mock_exists, mock_chown, mock_move,",
            "        mock_makedirs, mock_chmod, mock_getpwnam, mock_getgrnam,",
            "    ):",
            "        mock_exists.return_value = exists",
            "        mock_isdir.return_value = True",
            "        mock_getpwnam.return_value = pwd.struct_passwd(",
            "            ('swtpm', '*', 1234, 1234, None, '/home/test', '/bin/bash'))",
            "        mock_getgrnam.return_value = grp.struct_group(('swtpm', '*', 4321, []))",
            "",
            "        libvirt_utils.restore_vtpm_dir('dummy')",
            "",
            "        if not exists:",
            "            mock_makedirs.assert_called_once_with(libvirt_utils.VTPM_DIR)",
            "            mock_chmod.assert_called_once_with(libvirt_utils.VTPM_DIR, 0o711)",
            "",
            "        mock_getpwnam.assert_called_once_with(CONF.libvirt.swtpm_user)",
            "        mock_getgrnam.assert_called_once_with(CONF.libvirt.swtpm_group)",
            "        mock_chown.assert_called_with('dummy', 1234, 4321, recursive=True)",
            "        mock_move.assert_called_with('dummy', libvirt_utils.VTPM_DIR)",
            "",
            "    def test_restore_vtpm(self):",
            "        self._test_restore_vtpm(True)",
            "",
            "    def test_restore_vtpm_not_exist(self):",
            "        self._test_restore_vtpm(False)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=False)",
            "    def test_restore_vtpm_notdir(self, mock_isdir, mock_exists):",
            "        self.assertRaises(exception.Invalid,",
            "                          libvirt_utils.restore_vtpm_dir, 'dummy')"
        ],
        "afterPatchFile": [
            "# Copyright 2012 NTT Data. All Rights Reserved.",
            "# Copyright 2012 Yahoo! Inc. All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import functools",
            "import grp",
            "import os",
            "import pwd",
            "import tempfile",
            "from unittest import mock",
            "",
            "import ddt",
            "import os_traits",
            "from oslo_config import cfg",
            "from oslo_utils import fileutils",
            "from oslo_utils.fixture import uuidsentinel as uuids",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import context",
            "from nova import exception",
            "from nova.image import format_inspector",
            "from nova import objects",
            "from nova.objects import fields as obj_fields",
            "import nova.privsep.fs",
            "import nova.privsep.qemu",
            "from nova import test",
            "from nova.tests import fixtures as nova_fixtures",
            "from nova.tests.unit import fake_instance",
            "from nova.virt import images",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "@ddt.ddt",
            "class LibvirtUtilsTestCase(test.NoDBTestCase):",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_copy_image_local(self, mock_execute):",
            "        libvirt_utils.copy_image('src', 'dest')",
            "        mock_execute.assert_called_once_with('cp', '-r', 'src', 'dest')",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.SshDriver.copy_file')",
            "    def test_copy_image_remote_ssh(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='ssh', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.volume.remotefs.RsyncDriver.copy_file')",
            "    def test_copy_image_remote_rsync(self, mock_rem_fs_remove):",
            "        self.flags(remote_filesystem_transport='rsync', group='libvirt')",
            "        libvirt_utils.copy_image('src', 'dest', host='host')",
            "        mock_rem_fs_remove.assert_called_once_with('src', 'host:dest',",
            "            on_completion=None, on_execute=None, compression=True)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_disk_type_from_path(self, mock_exists):",
            "        # Seems like lvm detection",
            "        # if its in /dev ??",
            "        for p in ['/dev/b', '/dev/blah/blah']:",
            "            d_type = libvirt_utils.get_disk_type_from_path(p)",
            "            self.assertEqual('lvm', d_type)",
            "",
            "        # Try rbd detection",
            "        d_type = libvirt_utils.get_disk_type_from_path('rbd:pool/instance')",
            "        self.assertEqual('rbd', d_type)",
            "",
            "        # Try the other types",
            "        path = '/myhome/disk.config'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        self.assertIsNone(d_type)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=True)",
            "    def test_disk_type_ploop(self, mock_isdir, mock_exists):",
            "        path = '/some/path'",
            "        d_type = libvirt_utils.get_disk_type_from_path(path)",
            "        mock_isdir.assert_called_once_with(path)",
            "        mock_exists.assert_called_once_with(\"%s/DiskDescriptor.xml\" % path)",
            "        self.assertEqual('ploop', d_type)",
            "",
            "    def test_valid_hostname_normal(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"hello.world.com\"))",
            "",
            "    def test_valid_hostname_ipv4addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"10.0.2.1\"))",
            "",
            "    def test_valid_hostname_ipv6addr(self):",
            "        self.assertTrue(libvirt_utils.is_valid_hostname(\"240:2ac3::2\"))",
            "",
            "    def test_valid_hostname_bad(self):",
            "        self.assertFalse(libvirt_utils.is_valid_hostname(\"foo/?com=/bin/sh\"))",
            "",
            "    @mock.patch('tempfile.NamedTemporaryFile')",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch('nova.virt.images.qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    def _test_create_image(",
            "        self, path, disk_format, disk_size, mock_detect, mock_info,",
            "        mock_execute, mock_ntf, backing_file=None, encryption=None,",
            "        safety_check=True",
            "    ):",
            "        if isinstance(backing_file, dict):",
            "            backing_info = backing_file",
            "            backing_file = backing_info.pop('file', None)",
            "        else:",
            "            backing_info = {}",
            "        backing_backing_file = backing_info.pop('backing_file', None)",
            "        backing_fmt = backing_info.pop('backing_fmt',",
            "                                       mock.sentinel.backing_fmt)",
            "",
            "        mock_info.return_value = mock.Mock(",
            "            file_format=backing_fmt,",
            "            cluster_size=mock.sentinel.cluster_size,",
            "            backing_file=backing_backing_file,",
            "            format_specific=backing_info,",
            "        )",
            "        fh = mock_ntf.return_value.__enter__.return_value",
            "",
            "        mock_detect.return_value.safety_check.return_value = safety_check",
            "",
            "        libvirt_utils.create_image(",
            "            path, disk_format, disk_size, backing_file=backing_file,",
            "            encryption=encryption,",
            "        )",
            "",
            "        cow_opts = []",
            "",
            "        if backing_file is None:",
            "            mock_info.assert_not_called()",
            "        else:",
            "            mock_info.assert_called_once_with(backing_file)",
            "            cow_opts = [",
            "                '-o',",
            "                f'backing_file={backing_file},'",
            "                f'backing_fmt={backing_fmt},'",
            "                f'cluster_size={mock.sentinel.cluster_size}',",
            "            ]",
            "",
            "        encryption_opts = []",
            "",
            "        if encryption:",
            "            encryption_opts = [",
            "                '--object', f\"secret,id=sec,file={fh.name}\",",
            "                '-o', 'encrypt.key-secret=sec',",
            "                '-o', f\"encrypt.format={encryption.get('format')}\",",
            "            ]",
            "",
            "            encryption_options = {",
            "                'cipher-alg': 'aes-256',",
            "                'cipher-mode': 'xts',",
            "                'hash-alg': 'sha256',",
            "                'iter-time': 2000,",
            "                'ivgen-alg': 'plain64',",
            "                'ivgen-hash-alg': 'sha256',",
            "            }",
            "            for option, value in encryption_options.items():",
            "                encryption_opts += [",
            "                    '-o',",
            "                    f'encrypt.{option}={value}',",
            "                ]",
            "",
            "        expected_args = (",
            "            'env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'create', '-f',",
            "            disk_format, *cow_opts, *encryption_opts, path,",
            "        )",
            "        if disk_size is not None:",
            "            expected_args += (disk_size,)",
            "",
            "        self.assertEqual([(expected_args,)], mock_execute.call_args_list)",
            "        if backing_file:",
            "            mock_detect.return_value.safety_check.assert_called_once_with()",
            "",
            "    def test_create_image_raw(self):",
            "        self._test_create_image('/some/path', 'raw', '10G')",
            "",
            "    def test_create_image_qcow2(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "        )",
            "",
            "    def test_create_image_backing_file(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_base_has_backing_file(self):",
            "        self.assertRaises(",
            "            exception.InvalidDiskInfo,",
            "            self._test_create_image,",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_file': mock.sentinel.backing_backing_file},",
            "        )",
            "",
            "    def test_create_image_base_has_data_file(self):",
            "        self.assertRaises(",
            "            exception.InvalidDiskInfo,",
            "            self._test_create_image,",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_file': mock.sentinel.backing_backing_file,",
            "                          'data': {'data-file': mock.sentinel.data_file}},",
            "        )",
            "",
            "    def test_create_image_size_none(self):",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', None,",
            "            backing_file=mock.sentinel.backing_file,",
            "        )",
            "",
            "    def test_create_image_vmdk(self):",
            "        self._test_create_image(",
            "            '/some/vmdk', 'vmdk', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_fmt': 'vmdk',",
            "                          'backing_file': None,",
            "                          'data': {'create-type': 'monolithicSparse'}}",
            "        )",
            "",
            "    def test_create_image_vmdk_invalid_type(self):",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "            self._test_create_image,",
            "            '/some/vmdk', 'vmdk', '1234567891234',",
            "            backing_file={'file': mock.sentinel.backing_file,",
            "                          'backing_fmt': 'vmdk',",
            "                          'backing_file': None,",
            "                          'data': {'create-type': 'monolithicFlat'}}",
            "        )",
            "",
            "    def test_create_image_encryption(self):",
            "        encryption = {",
            "            'secret': 'a_secret',",
            "            'format': 'luks',",
            "        }",
            "        self._test_create_image(",
            "            '/some/stuff', 'qcow2', '1234567891234',",
            "            encryption=encryption,",
            "        )",
            "",
            "    @ddt.unpack",
            "    @ddt.data({'fs_type': 'some_fs_type',",
            "               'default_eph_format': None,",
            "               'expected_fs_type': 'some_fs_type'},",
            "              {'fs_type': None,",
            "               'default_eph_format': None,",
            "               'expected_fs_type': nova.privsep.fs.FS_FORMAT_EXT4},",
            "              {'fs_type': None,",
            "               'default_eph_format': 'eph_format',",
            "               'expected_fs_type': 'eph_format'})",
            "    def test_create_ploop_image(self, fs_type,",
            "                                default_eph_format,",
            "                                expected_fs_type):",
            "        with test.nested(mock.patch('oslo_utils.fileutils.ensure_tree'),",
            "                         mock.patch('nova.privsep.libvirt.ploop_init')",
            "                         ) as (mock_ensure_tree, mock_ploop_init):",
            "            self.flags(default_ephemeral_format=default_eph_format)",
            "            libvirt_utils.create_ploop_image('expanded', '/some/path',",
            "                                             '5G', fs_type)",
            "            mock_ensure_tree.assert_has_calls([",
            "                mock.call('/some/path')])",
            "            mock_ploop_init.assert_has_calls([",
            "                mock.call('5G', 'expanded', expected_fs_type,",
            "                          '/some/path/root.hds')])",
            "",
            "    def test_copy_image(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            src_fd, src_path = tempfile.mkstemp()",
            "            try:",
            "                with os.fdopen(src_fd, 'w') as fp:",
            "                    fp.write('canary')",
            "",
            "                libvirt_utils.copy_image(src_path, dst_path)",
            "                with open(dst_path, 'r') as fp:",
            "                    self.assertEqual(fp.read(), 'canary')",
            "            finally:",
            "                os.unlink(src_path)",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_no_directio(self, mock_execute,",
            "                                  mock_direct_io,",
            "                                  mock_disk_op_sema):",
            "        # Test a single variant with no support for direct IO.",
            "        # This could be removed if we add unit tests for convert_image().",
            "        src_format = 'qcow2'",
            "        dest_format = 'raw'",
            "        out_format = 'raw'",
            "",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'writeback',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    def _do_test_extract_snapshot(self, mock_execute, mock_direct_io,",
            "                                  mock_disk_op_sema,",
            "                                  src_format='qcow2',",
            "                                  dest_format='raw', out_format='raw'):",
            "        libvirt_utils.extract_snapshot('/path/to/disk/image', src_format,",
            "                                       '/extracted/snap', dest_format)",
            "        qemu_img_cmd = ('qemu-img', 'convert', '-t', 'none',",
            "                        '-O', out_format, '-f', src_format, )",
            "        if CONF.libvirt.snapshot_compression and dest_format == \"qcow2\":",
            "            qemu_img_cmd += ('-c',)",
            "        qemu_img_cmd += ('/path/to/disk/image', '/extracted/snap')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_direct_io.assert_called_once_with(CONF.instances_path)",
            "        mock_execute.assert_called_once_with(*qemu_img_cmd)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_raw(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute)",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_iso(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute, dest_format='iso')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_qcow2_and_compression(self, mock_execute):",
            "        self.flags(snapshot_compression=True, group='libvirt')",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       dest_format='qcow2', out_format='qcow2')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_extract_snapshot_parallels(self, mock_execute):",
            "        self._do_test_extract_snapshot(mock_execute,",
            "                                       src_format='raw',",
            "                                       dest_format='ploop',",
            "                                       out_format='parallels')",
            "",
            "    def test_load_file(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            self.assertEqual(libvirt_utils.load_file(dst_path), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_file_open(self):",
            "        dst_fd, dst_path = tempfile.mkstemp()",
            "        try:",
            "            os.close(dst_fd)",
            "",
            "            with open(dst_path, 'w') as f:",
            "                f.write('hello')",
            "            with libvirt_utils.file_open(dst_path, 'r') as fp:",
            "                self.assertEqual(fp.read(), 'hello')",
            "        finally:",
            "            os.unlink(dst_path)",
            "",
            "    def test_get_fs_info(self):",
            "",
            "        class FakeStatResult(object):",
            "",
            "            def __init__(self):",
            "                self.f_bsize = 4096",
            "                self.f_frsize = 4096",
            "                self.f_blocks = 2000",
            "                self.f_bfree = 1000",
            "                self.f_bavail = 900",
            "                self.f_files = 2000",
            "                self.f_ffree = 1000",
            "                self.f_favail = 900",
            "                self.f_flag = 4096",
            "                self.f_namemax = 255",
            "",
            "        self.path = None",
            "",
            "        def fake_statvfs(path):",
            "            self.path = path",
            "            return FakeStatResult()",
            "",
            "        self.stub_out('os.statvfs', fake_statvfs)",
            "",
            "        fs_info = libvirt_utils.get_fs_info('/some/file/path')",
            "        self.assertEqual('/some/file/path', self.path)",
            "        self.assertEqual(8192000, fs_info['total'])",
            "        self.assertEqual(3686400, fs_info['free'])",
            "        self.assertEqual(4096000, fs_info['used'])",
            "",
            "    @mock.patch('nova.virt.images.fetch_to_raw')",
            "    def test_fetch_image(self, mock_images):",
            "        context = 'opaque context'",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_image(context, target, image_id, trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch('nova.virt.images.fetch')",
            "    def test_fetch_initrd_image(self, mock_images):",
            "        _context = context.RequestContext(project_id=123,",
            "                                          project_name=\"aubergine\",",
            "                                          user_id=456,",
            "                                          user_name=\"pie\")",
            "        target = '/tmp/targetfile'",
            "        image_id = '4'",
            "        trusted_certs = objects.TrustedCerts(",
            "            ids=['0b5d2c72-12cc-4ba6-a8d7-3ff5cc1d8cb8',",
            "                 '674736e3-f25c-405c-8362-bbf991e0ce0a'])",
            "        libvirt_utils.fetch_raw_image(_context, target, image_id,",
            "                                      trusted_certs)",
            "        mock_images.assert_called_once_with(",
            "            _context, image_id, target, trusted_certs)",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(format_inspector, 'detect_file_format')",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_convert_image')",
            "    def test_fetch_raw_image(self, mock_convert_image, mock_direct_io,",
            "                             mock_disk_op_sema, mock_detect, mock_glance):",
            "",
            "        def fake_rename(old, new):",
            "            self.executes.append(('mv', old, new))",
            "",
            "        def fake_unlink(path):",
            "            self.executes.append(('rm', path))",
            "",
            "        def fake_rm_on_error(path, remove=None):",
            "            self.executes.append(('rm', '-f', path))",
            "",
            "        def fake_qemu_img_info(path, format=None):",
            "            class FakeImgInfo(object):",
            "                pass",
            "",
            "            file_format = path.split('.')[-1]",
            "            if file_format == 'part':",
            "                file_format = path.split('.')[-2]",
            "            elif file_format == 'converted':",
            "                file_format = 'raw'",
            "",
            "            if 'backing' in path:",
            "                backing_file = 'backing'",
            "            else:",
            "                backing_file = None",
            "",
            "            FakeImgInfo.file_format = file_format",
            "            FakeImgInfo.backing_file = backing_file",
            "            FakeImgInfo.virtual_size = 1",
            "            FakeImgInfo.format_specific = None if file_format == 'raw' else {}",
            "",
            "            return FakeImgInfo()",
            "",
            "        self.stub_out('os.rename', fake_rename)",
            "        self.stub_out('os.unlink', fake_unlink)",
            "        self.stub_out('nova.virt.images.fetch', lambda *_, **__: None)",
            "        self.stub_out('nova.virt.images.qemu_img_info', fake_qemu_img_info)",
            "        self.stub_out('oslo_utils.fileutils.delete_if_exists',",
            "                      fake_rm_on_error)",
            "",
            "        mock_inspector = mock_detect.return_value",
            "",
            "        # Since the remove param of fileutils.remove_path_on_error()",
            "        # is initialized at load time, we must provide a wrapper",
            "        # that explicitly resets it to our fake delete_if_exists()",
            "        old_rm_path_on_error = fileutils.remove_path_on_error",
            "        f = functools.partial(old_rm_path_on_error, remove=fake_rm_on_error)",
            "        self.stub_out('oslo_utils.fileutils.remove_path_on_error', f)",
            "",
            "        context = 'opaque context'",
            "        image_id = '4'",
            "",
            "        # Make sure qcow2 gets converted to raw",
            "        mock_inspector.safety_check.return_value = True",
            "        mock_inspector.__str__.return_value = 'qcow2'",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        target = 't.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', 't.qcow2.part'),",
            "                             ('mv', 't.qcow2.converted', 't.qcow2')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        mock_convert_image.assert_called_with(",
            "            't.qcow2.part', 't.qcow2.converted', 'qcow2', 'raw',",
            "            CONF.instances_path, False, src_encryption=None,",
            "            dest_encryption=None)",
            "        mock_convert_image.reset_mock()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_detect.assert_called_once_with('t.qcow2.part')",
            "",
            "        # Make sure raw does not get converted",
            "        mock_detect.reset_mock()",
            "        mock_inspector.safety_check.reset_mock()",
            "        mock_inspector.safety_check.return_value = True",
            "        mock_inspector.__str__.return_value = 'raw'",
            "        mock_glance.get.return_value = {'disk_format': 'raw'}",
            "        target = 't.raw'",
            "        self.executes = []",
            "        expected_commands = [('mv', 't.raw.part', 't.raw')]",
            "        images.fetch_to_raw(context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_detect.assert_called_once_with('t.raw.part')",
            "",
            "        # Make sure safety check failure prevents us from proceeding",
            "        mock_detect.reset_mock()",
            "        mock_inspector.safety_check.reset_mock()",
            "        mock_inspector.safety_check.return_value = False",
            "        mock_inspector.__str__.return_value = 'qcow2'",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        target = 'backing.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', '-f', 'backing.qcow2.part')]",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_detect.assert_called_once_with('backing.qcow2.part')",
            "",
            "        # Make sure a format mismatch prevents us from proceeding",
            "        mock_detect.reset_mock()",
            "        mock_inspector.safety_check.reset_mock()",
            "        mock_inspector.safety_check.side_effect = (",
            "            format_inspector.ImageFormatError)",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        target = 'backing.qcow2'",
            "        self.executes = []",
            "        expected_commands = [('rm', '-f', 'backing.qcow2.part')]",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, context, image_id, target)",
            "        self.assertEqual(self.executes, expected_commands)",
            "        mock_convert_image.assert_not_called()",
            "        mock_inspector.safety_check.assert_called_once_with()",
            "        mock_detect.assert_called_once_with('backing.qcow2.part')",
            "",
            "        del self.executes",
            "",
            "    def test_get_instance_path_at_destination(self):",
            "        instance = fake_instance.fake_instance_obj(None, name='fake_inst',",
            "                                                   uuid=uuids.instance)",
            "",
            "        migrate_data = None",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = {}",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, instance['uuid'])",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            instance_relative_path='fake_relative_path')",
            "        inst_path_at_dest = libvirt_utils.get_instance_path_at_destination(",
            "            instance, migrate_data)",
            "        expected_path = os.path.join(CONF.instances_path, 'fake_relative_path')",
            "        self.assertEqual(expected_path, inst_path_at_dest)",
            "",
            "    def test_get_arch(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'properties': {'architecture': \"X86_64\"}})",
            "        image_arch = libvirt_utils.get_arch(image_meta)",
            "        self.assertEqual(obj_fields.Architecture.X86_64, image_arch)",
            "",
            "    def test_is_mounted(self):",
            "        mount_path = \"/var/lib/nova/mnt\"",
            "        source = \"192.168.0.1:/nova\"",
            "        proc_with_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.1:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_wrong_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "192.168.0.2:/nova /var/lib/nova/mnt nfs4 rw,relatime,vers=4.1",
            "\"\"\"",
            "        proc_without_mnt = \"\"\"/dev/sda3 / xfs rw,seclabel,,attr2,inode64 0 0",
            "tmpfs /tmp tmpfs rw,seclabel 0 0",
            "hugetlbfs /dev/hugepages hugetlbfs rw,seclabel,relatime 0 0",
            "mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0",
            "debugfs /sys/kernel/debug debugfs rw,seclabel,relatime 0 0",
            "nfsd /proc/fs/nfsd nfsd rw,relatime 0 0",
            "/dev/sda1 /boot ext4 rw,seclabel,relatime,data=ordered 0 0",
            "sunrpc /var/lib/nfs/rpc_pipefs rpc_pipefs rw,relatime 0 0",
            "\"\"\"",
            "        with mock.patch.object(os.path, 'ismount') as mock_ismount:",
            "            # is_mounted(mount_path) with no source is equivalent to",
            "            # os.path.ismount(mount_path)",
            "            mock_ismount.return_value = False",
            "            self.assertFalse(libvirt_utils.is_mounted(mount_path))",
            "",
            "            mock_ismount.return_value = True",
            "            self.assertTrue(libvirt_utils.is_mounted(mount_path))",
            "",
            "            # Source is given, and matches source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_with_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertTrue(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and doesn't match source in /proc/mounts",
            "            proc_mnt = mock.mock_open(read_data=proc_wrong_mnt)",
            "            with mock.patch('builtins.open', proc_mnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "            # Source is given, and mountpoint isn't present in /proc/mounts",
            "            # Note that this shouldn't occur, as os.path.ismount should have",
            "            # previously returned False in this case.",
            "            proc_umnt = mock.mock_open(read_data=proc_without_mnt)",
            "            with mock.patch('builtins.open', proc_umnt):",
            "                self.assertFalse(libvirt_utils.is_mounted(mount_path, source))",
            "",
            "    def test_find_disk_file_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"file\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"qcow2\" cache=\"none\" io=\"native\"/>",
            "                <source file=\"/tmp/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/tmp/hello', disk_path)",
            "        self.assertEqual('qcow2', format)",
            "",
            "    def test_find_disk_block_device(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"block\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source dev=\"/dev/nova-vg/hello\"/>",
            "                <target bus=\"ide\" dev=\"/dev/hda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/dev/nova-vg/hello', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_rbd(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='kvm'>",
            "            <os>",
            "              <type>linux</type>",
            "            </os>",
            "            <devices>",
            "              <disk type=\"network\" device=\"disk\">",
            "                <driver name=\"qemu\" type=\"raw\"/>",
            "                <source name=\"pool/image\" protocol=\"rbd\">",
            "                  <host name=\"1.2.3.4\" port=\"456\"/>",
            "                </source>",
            "                <target bus=\"virtio\" dev=\"/dev/vda\"/>",
            "              </disk>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('rbd:pool/image', disk_path)",
            "        self.assertEqual('raw', format)",
            "",
            "    def test_find_disk_lxc(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='lxc'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type=\"mount\">",
            "                <source dir=\"/myhome/rootfs\"/>",
            "                <target dir=\"/\"/>",
            "              </filesystem>",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/myhome/disk', disk_path)",
            "        self.assertIsNone(format)",
            "",
            "    def test_find_disk_parallels(self):",
            "        self.useFixture(nova_fixtures.LibvirtFixture())",
            "        xml = \"\"\"",
            "          <domain type='parallels'>",
            "            <os>",
            "              <type>exe</type>",
            "            </os>",
            "            <devices>",
            "              <filesystem type='file'>\"",
            "                <driver format='ploop' type='ploop'/>\"",
            "                <source file='/test/disk'/>\"",
            "                <target dir='/'/>",
            "              </filesystem>\"",
            "            </devices>",
            "          </domain>",
            "        \"\"\"",
            "        virt_dom = mock.Mock(XMLDesc=mock.Mock(return_value=xml))",
            "        guest = libvirt_guest.Guest(virt_dom)",
            "        disk_path, format = libvirt_utils.find_disk(guest)",
            "        self.assertEqual('/test/disk', disk_path)",
            "        self.assertEqual('ploop', format)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.get_arch')",
            "    def test_get_machine_type_from_fallbacks(self, mock_get_arch):",
            "        \"\"\"Test hardcoded arch-specific fallbacks for default machine type\"\"\"",
            "        image_meta = objects.ImageMeta.from_dict({\"disk_format\": \"raw\"})",
            "        host_cpu_archs = {",
            "            obj_fields.Architecture.ARMV7: \"virt\",",
            "            obj_fields.Architecture.AARCH64: \"virt\",",
            "            obj_fields.Architecture.S390: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.S390X: \"s390-ccw-virtio\",",
            "            obj_fields.Architecture.I686: \"pc\",",
            "            obj_fields.Architecture.X86_64: \"pc\",",
            "        }",
            "        for arch, expected_mtype in host_cpu_archs.items():",
            "            mock_get_arch.return_value = arch",
            "            mtype = libvirt_utils.get_machine_type(image_meta)",
            "            self.assertEqual(expected_mtype, mtype)",
            "",
            "    def test_get_machine_type_from_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_no_conf_or_fallback(self):",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_missing_conf_and_fallback(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'i686=legacy']))",
            "        self.assertIsNone(libvirt_utils.get_default_machine_type('sparc'))",
            "",
            "    def test_get_machine_type_survives_invalid_conf(self):",
            "        self.useFixture(nova_fixtures.ConfPatcher(",
            "            group=\"libvirt\", hw_machine_type=['x86_64=q35', 'foo']))",
            "        self.assertEqual('q35',",
            "                         libvirt_utils.get_default_machine_type('x86_64'))",
            "",
            "    def test_get_machine_type_from_image(self):",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\", \"properties\": {\"hw_machine_type\": \"q35\"}",
            "        })",
            "        os_mach_type = libvirt_utils.get_machine_type(image_meta)",
            "        self.assertEqual('q35', os_mach_type)",
            "",
            "    def test_make_reverse_cpu_traits_mapping(self):",
            "        for k in libvirt_utils.make_reverse_cpu_traits_mapping():",
            "            self.assertIsInstance(k, str)",
            "",
            "    def test_get_flags_by_flavor_specs(self):",
            "        flavor = objects.Flavor(",
            "            id=1, flavorid='fakeid-1', name='fake1.small', memory_mb=128,",
            "            vcpus=1, root_gb=1, ephemeral_gb=0, swap=0, rxtx_factor=0,",
            "            deleted=False, extra_specs={",
            "                'trait:%s' % os_traits.HW_CPU_X86_3DNOW: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SSE2: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_HYPERTHREADING: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_INTEL_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_VMX: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_SVM: 'required',",
            "                'trait:%s' % os_traits.HW_CPU_X86_AMD_SVM: 'required',",
            "            })",
            "        traits = libvirt_utils.get_flags_by_flavor_specs(flavor)",
            "        # we shouldn't see the hyperthreading trait since that's a valid trait",
            "        # but not a CPU flag",
            "        self.assertEqual(set(['3dnow', 'sse2', 'vmx', 'svm']), traits)",
            "",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_save_migrate_vtpm(",
            "        self, mock_exists, mock_ensure, mock_move, mock_chown, mock_copy,",
            "    ):",
            "        def _on_execute():",
            "            pass",
            "",
            "        def _on_completion():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _on_execute,",
            "            _on_completion,",
            "        )",
            "",
            "        vtpm_dir = f'/var/lib/libvirt/swtpm/{uuids.instance}'",
            "        swtpm_dir = 'base_resize/swtpm'",
            "        mock_exists.assert_called_once_with(vtpm_dir)",
            "        mock_ensure.assert_called_once_with(swtpm_dir)",
            "        mock_move.assert_called_once_with(vtpm_dir, swtpm_dir)",
            "        mock_chown.assert_called_once_with(",
            "            swtpm_dir, os.geteuid(), os.getegid(), recursive=True,",
            "        )",
            "        mock_copy.assert_called_once_with(",
            "            swtpm_dir, 'base', host='host', on_completion=_on_completion,",
            "            on_execute=_on_execute,",
            "        )",
            "",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    def test_save_migrate_vtpm_not_enabled(",
            "        self, mock_exists, mock_copy_image, mock_chown, mock_move,",
            "    ):",
            "        def _dummy():",
            "            pass",
            "",
            "        libvirt_utils.save_and_migrate_vtpm_dir(",
            "            uuids.instance, 'base_resize', 'base', 'host', _dummy, _dummy,",
            "        )",
            "",
            "        mock_exists.assert_called_once_with(",
            "            f'/var/lib/libvirt/swtpm/{uuids.instance}')",
            "        mock_copy_image.assert_not_called()",
            "        mock_chown.assert_not_called()",
            "        mock_move.assert_not_called()",
            "",
            "    @mock.patch('grp.getgrnam')",
            "    @mock.patch('pwd.getpwnam')",
            "    @mock.patch('nova.privsep.path.chmod')",
            "    @mock.patch('nova.privsep.path.makedirs')",
            "    @mock.patch('nova.privsep.path.move_tree')",
            "    @mock.patch('nova.privsep.path.chown')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.path.isdir')",
            "    def _test_restore_vtpm(",
            "        self, exists, mock_isdir, mock_exists, mock_chown, mock_move,",
            "        mock_makedirs, mock_chmod, mock_getpwnam, mock_getgrnam,",
            "    ):",
            "        mock_exists.return_value = exists",
            "        mock_isdir.return_value = True",
            "        mock_getpwnam.return_value = pwd.struct_passwd(",
            "            ('swtpm', '*', 1234, 1234, None, '/home/test', '/bin/bash'))",
            "        mock_getgrnam.return_value = grp.struct_group(('swtpm', '*', 4321, []))",
            "",
            "        libvirt_utils.restore_vtpm_dir('dummy')",
            "",
            "        if not exists:",
            "            mock_makedirs.assert_called_once_with(libvirt_utils.VTPM_DIR)",
            "            mock_chmod.assert_called_once_with(libvirt_utils.VTPM_DIR, 0o711)",
            "",
            "        mock_getpwnam.assert_called_once_with(CONF.libvirt.swtpm_user)",
            "        mock_getgrnam.assert_called_once_with(CONF.libvirt.swtpm_group)",
            "        mock_chown.assert_called_with('dummy', 1234, 4321, recursive=True)",
            "        mock_move.assert_called_with('dummy', libvirt_utils.VTPM_DIR)",
            "",
            "    def test_restore_vtpm(self):",
            "        self._test_restore_vtpm(True)",
            "",
            "    def test_restore_vtpm_not_exist(self):",
            "        self._test_restore_vtpm(False)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('os.path.isdir', return_value=False)",
            "    def test_restore_vtpm_notdir(self, mock_isdir, mock_exists):",
            "        self.assertRaises(exception.Invalid,",
            "                          libvirt_utils.restore_vtpm_dir, 'dummy')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "446": [
                "LibvirtUtilsTestCase"
            ],
            "451": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "491": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "519": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "522": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "533": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "536": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "548": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "551": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ],
            "564": [
                "LibvirtUtilsTestCase",
                "test_fetch_raw_image"
            ]
        },
        "addLocation": []
    },
    "nova/tests/unit/virt/test_images.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from nova.compute import utils as compute_utils"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from nova import exception"
            },
            "3": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from nova.image import format_inspector"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from nova import test"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from nova.virt import images"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         mocked_execute.assert_called_once()"
            },
            "8": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "10": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "12": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "     @mock.patch.object(images, 'convert_image',"
            },
            "13": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "                        side_effect=exception.ImageUnacceptable)"
            },
            "14": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "15": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "16": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     def test_fetch_to_raw_errors(self, convert_image, qemu_img_info, fetch,"
            },
            "17": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                 get_inspector, glance):"
            },
            "18": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inspector = get_inspector.return_value.from_file.return_value"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                                 mock_detect, glance):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        inspector = mock_detect.return_value"
            },
            "21": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         inspector.safety_check.return_value = True"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        inspector.__str__.return_value = 'qcow2'"
            },
            "23": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         glance.get.return_value = {'disk_format': 'qcow2'}"
            },
            "24": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         qemu_img_info.backing_file = None"
            },
            "25": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         qemu_img_info.file_format = 'qcow2'"
            },
            "26": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "                                None, 'href123', '/no/path')"
            },
            "27": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "29": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "31": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     @mock.patch.object(images, 'convert_image',"
            },
            "32": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "                        side_effect=exception.ImageUnacceptable)"
            },
            "33": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "34": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "35": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     def test_fetch_to_raw_data_file(self, convert_image, qemu_img_info_fn,"
            },
            "36": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    fetch, mock_gi, mock_glance):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                                    fetch, mock_detect, mock_glance):"
            },
            "38": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'qcow2'}"
            },
            "39": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inspector = mock_gi.return_value.from_file.return_value"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        inspector = mock_detect.return_value"
            },
            "41": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         inspector.safety_check.return_value = True"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        inspector.__str__.return_value = 'qcow2'"
            },
            "43": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         # NOTE(danms): the above test needs the following line as well, as it"
            },
            "44": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         # is broken without it."
            },
            "45": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         qemu_img_info = qemu_img_info_fn.return_value"
            },
            "46": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "                                images.fetch_to_raw,"
            },
            "47": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "                                None, 'href123', '/no/path')"
            },
            "48": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "51": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "52": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     @mock.patch('os.rename')"
            },
            "53": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "54": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "55": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     def test_fetch_to_raw_from_raw(self, fetch, qemu_img_info_fn, mock_rename,"
            },
            "56": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   mock_glance, mock_gi):"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                                   mock_glance, mock_detect):"
            },
            "58": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         # Make sure we support a case where we fetch an already-raw image and"
            },
            "59": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         # qemu-img returns None for \"format_specific\"."
            },
            "60": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'raw'}"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        mock_detect.return_value.__str__.return_value = 'raw'"
            },
            "62": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         qemu_img_info = qemu_img_info_fn.return_value"
            },
            "63": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         qemu_img_info.file_format = 'raw'"
            },
            "64": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         qemu_img_info.backing_file = None"
            },
            "65": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "                                                  format='json'))"
            },
            "66": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "68": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "70": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "71": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "     @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')"
            },
            "72": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_checks_vmdk_rules(self, mock_info, mock_fetch, mock_gi,"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+    def test_fetch_checks_vmdk_rules(self, mock_info, mock_fetch, mock_detect,"
            },
            "74": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "                                      mock_glance):"
            },
            "75": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'vmdk'}"
            },
            "76": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inspector = mock_gi.return_value.from_file.return_value"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        inspector = mock_detect.return_value"
            },
            "78": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "         inspector.safety_check.return_value = True"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        inspector.__str__.return_value = 'vmdk'"
            },
            "80": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         info = {'format': 'vmdk',"
            },
            "81": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "                 'format-specific': {"
            },
            "82": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "                     'type': 'vmdk',"
            },
            "83": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "     @mock.patch('os.rename')"
            },
            "84": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "85": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "     @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "87": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "88": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')"
            },
            "89": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_iso_is_raw(self, mock_info, mock_fetch, mock_gi,"
            },
            "90": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                              mock_glance, mock_rename):"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    def test_fetch_iso_is_raw("
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        self, mock_info, mock_fetch, mock_detect_file_format, mock_gi,"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        mock_glance, mock_rename):"
            },
            "94": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'iso'}"
            },
            "95": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         inspector = mock_gi.return_value.from_file.return_value"
            },
            "96": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         inspector.safety_check.return_value = True"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        inspector.__str__.return_value = 'iso'"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        mock_detect_file_format.return_value = inspector"
            },
            "99": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         # qemu-img does not have a parser for iso so it is treated as raw"
            },
            "100": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         info = {"
            },
            "101": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             \"virtual-size\": 356352,"
            },
            "102": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "             images.fetch_to_raw(None, 'foo', 'anypath')"
            },
            "103": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         # Make sure we called info with -f raw for an iso, since qemu-img does"
            },
            "104": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "         # not support iso"
            },
            "105": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_info.assert_called_once_with('anypath.part', format='raw')"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        mock_info.assert_called_once_with('anypath.part', format=None)"
            },
            "107": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         # Make sure that since we considered this to be a raw file, we did the"
            },
            "108": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "         # just-rename-don't-convert path"
            },
            "109": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "         mock_rename.assert_called_once_with('anypath.part', 'anypath')"
            },
            "110": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 272,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "112": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "114": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "115": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "116": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_to_raw_inspector(self, fetch, qemu_img_info, mock_gi,"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    def test_fetch_to_raw_inspector(self, fetch, qemu_img_info, mock_detect,"
            },
            "118": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "                                     mock_glance):"
            },
            "119": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         # Image claims to be qcow2, is qcow2, but fails safety check, so we"
            },
            "120": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         # abort before qemu-img-info"
            },
            "121": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         mock_glance.get.return_value = {'disk_format': 'qcow2'}"
            },
            "122": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inspector = mock_gi.return_value.from_file.return_value"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+        inspector = mock_detect.return_value"
            },
            "124": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         inspector.safety_check.return_value = False"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        inspector.__str__.return_value = 'qcow2'"
            },
            "126": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "         self.assertRaises(exception.ImageUnacceptable,"
            },
            "127": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "                           images.fetch_to_raw, None, 'href123', '/no.path')"
            },
            "128": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         qemu_img_info.assert_not_called()"
            },
            "129": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.assert_called_once_with('qcow2')"
            },
            "130": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.return_value.from_file.assert_called_once_with('/no.path.part')"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        mock_detect.assert_called_once_with('/no.path.part')"
            },
            "132": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         inspector.safety_check.assert_called_once_with()"
            },
            "133": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "         mock_glance.get.assert_called_once_with(None, 'href123')"
            },
            "134": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " "
            },
            "135": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "         # Image claims to be qcow2 in glance, but the image is something else,"
            },
            "136": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         # so we abort before qemu-img-info"
            },
            "137": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         qemu_img_info.reset_mock()"
            },
            "138": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.reset_mock()"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+        mock_detect.reset_mock()"
            },
            "140": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "         inspector.safety_check.reset_mock()"
            },
            "141": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.return_value.from_file.side_effect = ("
            },
            "142": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            format_inspector.ImageFormatError)"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        mock_detect.return_value.__str__.return_value = 'vmdk'"
            },
            "144": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "         self.assertRaises(exception.ImageUnacceptable,"
            },
            "145": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "                           images.fetch_to_raw, None, 'href123', '/no.path')"
            },
            "146": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mock_gi.assert_called_once_with('qcow2')"
            },
            "147": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        inspector.safety_check.assert_not_called()"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        mock_detect.assert_called_once_with('/no.path.part')"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+        inspector.safety_check.assert_called_once_with()"
            },
            "150": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "         qemu_img_info.assert_not_called()"
            },
            "151": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 310,
                "PatchRowcode": " "
            },
            "152": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "153": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "155": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "156": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "     @mock.patch.object(images, 'fetch')"
            },
            "157": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "     def test_fetch_to_raw_inspector_disabled(self, fetch, qemu_img_info,"
            },
            "158": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 322,
                "PatchRowcode": "         # If deep inspection is disabled, we should never call the inspector"
            },
            "159": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "         mock_gi.assert_not_called()"
            },
            "160": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "         # ... and we let qemu-img detect the format itself."
            },
            "161": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        qemu_img_info.assert_called_once_with('/no.path.part',"
            },
            "162": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                              format=None)"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+        qemu_img_info.assert_called_once_with('/no.path.part')"
            },
            "164": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "         mock_glance.get.assert_not_called()"
            },
            "165": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 327,
                "PatchRowcode": " "
            },
            "166": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "167": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "168": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_inspect_ami(self, imginfo, glance):"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+    def test_fetch_inspect_ami(self, detect, imginfo, glance):"
            },
            "171": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "         glance.get.return_value = {'disk_format': 'ami'}"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        detect.return_value.__str__.return_value = 'raw'"
            },
            "173": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         self.assertRaises(exception.ImageUnacceptable,"
            },
            "174": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "                           images.fetch_to_raw, None, 'href123', '/no.path')"
            },
            "175": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         # Make sure 'ami was translated into 'raw' before we call qemu-img"
            },
            "176": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        imginfo.assert_called_once_with('/no.path.part', format='raw')"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+        imginfo.assert_called_once_with('/no.path.part')"
            },
            "178": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 338,
                "PatchRowcode": " "
            },
            "179": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "180": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "181": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_inspect_aki(self, imginfo, glance):"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+    def test_fetch_inspect_aki(self, detect, imginfo, glance):"
            },
            "184": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "         glance.get.return_value = {'disk_format': 'aki'}"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+        detect.return_value.__str__.return_value = 'raw'"
            },
            "186": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "         self.assertRaises(exception.ImageUnacceptable,"
            },
            "187": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "                           images.fetch_to_raw, None, 'href123', '/no.path')"
            },
            "188": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "         # Make sure 'aki was translated into 'raw' before we call qemu-img"
            },
            "189": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        imginfo.assert_called_once_with('/no.path.part', format='raw')"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+        imginfo.assert_called_once_with('/no.path.part')"
            },
            "191": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 349,
                "PatchRowcode": " "
            },
            "192": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "193": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "194": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_inspect_ari(self, imginfo, glance):"
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    def test_fetch_inspect_ari(self, detect, imginfo, glance):"
            },
            "197": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "         glance.get.return_value = {'disk_format': 'ari'}"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        detect.return_value.__str__.return_value = 'raw'"
            },
            "199": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         self.assertRaises(exception.ImageUnacceptable,"
            },
            "200": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "                           images.fetch_to_raw, None, 'href123', '/no.path')"
            },
            "201": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "         # Make sure 'aki was translated into 'raw' before we call qemu-img"
            },
            "202": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        imginfo.assert_called_once_with('/no.path.part', format='raw')"
            },
            "203": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+        imginfo.assert_called_once_with('/no.path.part')"
            },
            "204": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " "
            },
            "205": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "206": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "207": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 369,
                "PatchRowcode": " "
            },
            "208": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "     @mock.patch.object(images, 'IMAGE_API')"
            },
            "209": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "     @mock.patch.object(images, 'qemu_img_info')"
            },
            "210": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @mock.patch('nova.image.format_inspector.get_inspector')"
            },
            "211": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_fetch_inspect_disagrees_qemu(self, mock_gi, imginfo, glance):"
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+    @mock.patch('nova.image.format_inspector.detect_file_format')"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+    def test_fetch_inspect_disagrees_qemu(self, mock_detect, imginfo, glance):"
            },
            "214": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         glance.get.return_value = {'disk_format': 'qcow2'}"
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+        mock_detect.return_value.__str__.return_value = 'qcow2'"
            },
            "216": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "         # Glance and inspector think it is a qcow2 file, but qemu-img does not"
            },
            "217": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # agree. It was forced to interpret as a qcow2, but returned no"
            },
            "218": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # format information as a result."
            },
            "219": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        # agree."
            },
            "220": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "         imginfo.return_value.data_file = None"
            },
            "221": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertRaises(exception.ImageUnacceptable,"
            },
            "222": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                          images.fetch_to_raw, None, 'href123', '/no.path')"
            },
            "223": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        imginfo.assert_called_once_with('/no.path.part', format='qcow2')"
            },
            "224": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        imginfo.return_value.file_format = 'vmdk'"
            },
            "225": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+        ex = self.assertRaises(exception.ImageUnacceptable,"
            },
            "226": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+                               images.fetch_to_raw,"
            },
            "227": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+                               None, 'href123', '/no.path')"
            },
            "228": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        self.assertIn('content does not match disk_format', str(ex))"
            },
            "229": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+        imginfo.assert_called_once_with('/no.path.part')"
            }
        },
        "frontPatchFile": [
            "#    Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os",
            "from unittest import mock",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import imageutils",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import exception",
            "from nova.image import format_inspector",
            "from nova import test",
            "from nova.virt import images",
            "",
            "",
            "class QemuTestCase(test.NoDBTestCase):",
            "    def test_qemu_info_with_bad_path(self):",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/path/that/does/not/exist')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_info_with_errors(self, path_exists, mock_exec):",
            "        err = processutils.ProcessExecutionError(",
            "            exit_code=1, stderr='No such file or directory')",
            "        mock_exec.side_effect = err",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/fake/path')",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_no_errors(self, path_exists,",
            "                                      utils_execute):",
            "        image_info = images.qemu_img_info('/fake/path')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_rbd_path(self, utils_execute):",
            "        # Assert that the use of a RBD URI as the path doesn't raise",
            "        # exception.DiskNotFound",
            "        image_info = images.qemu_img_info('rbd:volume/pool')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch.object(processutils, 'execute',",
            "                       side_effect=processutils.ProcessExecutionError)",
            "    def test_convert_image_with_errors(self, mocked_execute, mock_direct_io,",
            "                                       mock_disk_op_sema):",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.convert_image,",
            "                          '/path/that/does/not/exist',",
            "                          '/other/path/that/does/not/exist',",
            "                          'qcow2',",
            "                          'raw')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_convert_image_with_prlimit_fail(self, path, mocked_execute):",
            "        mocked_execute.side_effect = \\",
            "            processutils.ProcessExecutionError(exit_code=-9)",
            "        exc = self.assertRaises(exception.InvalidDiskInfo,",
            "                                images.qemu_img_info,",
            "                                '/fake/path')",
            "        self.assertIn('qemu-img aborted by prlimits', str(exc))",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_img_info_with_disk_not_found(self, exists, mocked_execute):",
            "        \"\"\"Tests that the initial os.path.exists check passes but the qemu-img",
            "        command fails because the path is gone by the time the command runs.",
            "        \"\"\"",
            "        path = '/opt/stack/data/nova/instances/some-uuid/disk'",
            "        stderr = (u\"qemu-img: Could not open \"",
            "                  \"'/opt/stack/data/nova/instances/some-uuid/disk': \"",
            "                  \"Could not open '/opt/stack/data/nova/instances/some-uuid/\"",
            "                  \"disk': No such file or directory\\n\")",
            "        mocked_execute.side_effect = (",
            "            processutils.ProcessExecutionError(",
            "                exit_code=1, stderr=stderr))",
            "        self.assertRaises(exception.DiskNotFound, images.qemu_img_info, path)",
            "        exists.assert_called_once_with(path)",
            "        mocked_execute.assert_called_once()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_errors(self, convert_image, qemu_img_info, fetch,",
            "                                 get_inspector, glance):",
            "        inspector = get_inspector.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = True",
            "        glance.get.return_value = {'disk_format': 'qcow2'}",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_data_file(self, convert_image, qemu_img_info_fn,",
            "                                    fetch, mock_gi, mock_glance):",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        inspector = mock_gi.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = True",
            "        # NOTE(danms): the above test needs the following line as well, as it",
            "        # is broken without it.",
            "        qemu_img_info = qemu_img_info_fn.return_value",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        qemu_img_info.format_specific = {'data': {'data-file': 'somefile'}}",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*somefile',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('os.rename')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_from_raw(self, fetch, qemu_img_info_fn, mock_rename,",
            "                                   mock_glance, mock_gi):",
            "        # Make sure we support a case where we fetch an already-raw image and",
            "        # qemu-img returns None for \"format_specific\".",
            "        mock_glance.get.return_value = {'disk_format': 'raw'}",
            "        qemu_img_info = qemu_img_info_fn.return_value",
            "        qemu_img_info.file_format = 'raw'",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.format_specific = None",
            "        images.fetch_to_raw(None, 'href123', '/no/path')",
            "        mock_rename.assert_called_once_with('/no/path.part', '/no/path')",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_with_direct_io_support(self, mock_execute,",
            "                                                  mock_direct_io,",
            "                                                  mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'none', '-O', 'out_format',",
            "                    '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_without_direct_io_support(self, mock_execute,",
            "                                                     mock_direct_io,",
            "                                                     mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'writeback',",
            "                    '-O', 'out_format', '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    def test_convert_image_vmdk_allowed_list_checking(self):",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "",
            "        # If the format is not in the allowed list, we should get an error",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "        # With the format in the allowed list, no error",
            "        self.flags(vmdk_allowed_types=['streamOptimized', 'monolithicFlat',",
            "                                       'monolithicSparse'],",
            "                   group='compute')",
            "        images.check_vmdk_image('foo',",
            "                                imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                       format='json'))",
            "",
            "        # With an empty list, allow nothing",
            "        self.flags(vmdk_allowed_types=[], group='compute')",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'fetch')",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')",
            "    def test_fetch_checks_vmdk_rules(self, mock_info, mock_fetch, mock_gi,",
            "                                     mock_glance):",
            "        mock_glance.get.return_value = {'disk_format': 'vmdk'}",
            "        inspector = mock_gi.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = True",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "        mock_info.return_value = jsonutils.dumps(info)",
            "        with mock.patch('os.path.exists', return_value=True):",
            "            e = self.assertRaises(exception.ImageUnacceptable,",
            "                                  images.fetch_to_raw, None, 'foo', 'anypath')",
            "            self.assertIn('Invalid VMDK create-type specified', str(e))",
            "",
            "    @mock.patch('os.rename')",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'fetch')",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')",
            "    def test_fetch_iso_is_raw(self, mock_info, mock_fetch, mock_gi,",
            "                              mock_glance, mock_rename):",
            "        mock_glance.get.return_value = {'disk_format': 'iso'}",
            "        inspector = mock_gi.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = True",
            "        # qemu-img does not have a parser for iso so it is treated as raw",
            "        info = {",
            "            \"virtual-size\": 356352,",
            "            \"filename\": \"foo.iso\",",
            "            \"format\": \"raw\",",
            "            \"actual-size\": 356352,",
            "            \"dirty-flag\": False",
            "        }",
            "        mock_info.return_value = jsonutils.dumps(info)",
            "        with mock.patch('os.path.exists', return_value=True):",
            "            images.fetch_to_raw(None, 'foo', 'anypath')",
            "        # Make sure we called info with -f raw for an iso, since qemu-img does",
            "        # not support iso",
            "        mock_info.assert_called_once_with('anypath.part', format='raw')",
            "        # Make sure that since we considered this to be a raw file, we did the",
            "        # just-rename-don't-convert path",
            "        mock_rename.assert_called_once_with('anypath.part', 'anypath')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_inspector(self, fetch, qemu_img_info, mock_gi,",
            "                                    mock_glance):",
            "        # Image claims to be qcow2, is qcow2, but fails safety check, so we",
            "        # abort before qemu-img-info",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        inspector = mock_gi.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = False",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        qemu_img_info.assert_not_called()",
            "        mock_gi.assert_called_once_with('qcow2')",
            "        mock_gi.return_value.from_file.assert_called_once_with('/no.path.part')",
            "        inspector.safety_check.assert_called_once_with()",
            "        mock_glance.get.assert_called_once_with(None, 'href123')",
            "",
            "        # Image claims to be qcow2, is qcow2, passes safety check, so we make",
            "        # it all the way to qemu-img-info",
            "        inspector.safety_check.return_value = True",
            "        qemu_img_info.side_effect = test.TestingException",
            "        self.assertRaises(test.TestingException,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "",
            "        # Image claims to be qcow2 in glance, but the image is something else,",
            "        # so we abort before qemu-img-info",
            "        qemu_img_info.reset_mock()",
            "        mock_gi.reset_mock()",
            "        inspector.safety_check.reset_mock()",
            "        mock_gi.return_value.from_file.side_effect = (",
            "            format_inspector.ImageFormatError)",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        mock_gi.assert_called_once_with('qcow2')",
            "        inspector.safety_check.assert_not_called()",
            "        qemu_img_info.assert_not_called()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_inspector_disabled(self, fetch, qemu_img_info,",
            "                                             mock_gi, mock_glance):",
            "        self.flags(disable_deep_image_inspection=True,",
            "                   group='workarounds')",
            "        qemu_img_info.side_effect = test.TestingException",
            "        self.assertRaises(test.TestingException,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # If deep inspection is disabled, we should never call the inspector",
            "        mock_gi.assert_not_called()",
            "        # ... and we let qemu-img detect the format itself.",
            "        qemu_img_info.assert_called_once_with('/no.path.part',",
            "                                              format=None)",
            "        mock_glance.get.assert_not_called()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    def test_fetch_inspect_ami(self, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'ami'}",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Make sure 'ami was translated into 'raw' before we call qemu-img",
            "        imginfo.assert_called_once_with('/no.path.part', format='raw')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    def test_fetch_inspect_aki(self, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'aki'}",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Make sure 'aki was translated into 'raw' before we call qemu-img",
            "        imginfo.assert_called_once_with('/no.path.part', format='raw')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    def test_fetch_inspect_ari(self, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'ari'}",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Make sure 'aki was translated into 'raw' before we call qemu-img",
            "        imginfo.assert_called_once_with('/no.path.part', format='raw')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    def test_fetch_inspect_unknown_format(self, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'commodore-64-disk'}",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Unsupported formats do not make it past deep inspection",
            "        imginfo.assert_not_called()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    def test_fetch_inspect_disagrees_qemu(self, mock_gi, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'qcow2'}",
            "        # Glance and inspector think it is a qcow2 file, but qemu-img does not",
            "        # agree. It was forced to interpret as a qcow2, but returned no",
            "        # format information as a result.",
            "        imginfo.return_value.data_file = None",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        imginfo.assert_called_once_with('/no.path.part', format='qcow2')"
        ],
        "afterPatchFile": [
            "#    Copyright 2013 IBM Corp.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import os",
            "from unittest import mock",
            "",
            "from oslo_concurrency import processutils",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import imageutils",
            "",
            "from nova.compute import utils as compute_utils",
            "from nova import exception",
            "from nova import test",
            "from nova.virt import images",
            "",
            "",
            "class QemuTestCase(test.NoDBTestCase):",
            "    def test_qemu_info_with_bad_path(self):",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/path/that/does/not/exist')",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_info_with_errors(self, path_exists, mock_exec):",
            "        err = processutils.ProcessExecutionError(",
            "            exit_code=1, stderr='No such file or directory')",
            "        mock_exec.side_effect = err",
            "        self.assertRaises(exception.DiskNotFound,",
            "                          images.qemu_img_info,",
            "                          '/fake/path')",
            "",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_no_errors(self, path_exists,",
            "                                      utils_execute):",
            "        image_info = images.qemu_img_info('/fake/path')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info',",
            "                return_value={})",
            "    def test_qemu_info_with_rbd_path(self, utils_execute):",
            "        # Assert that the use of a RBD URI as the path doesn't raise",
            "        # exception.DiskNotFound",
            "        image_info = images.qemu_img_info('rbd:volume/pool')",
            "        self.assertTrue(image_info)",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch.object(processutils, 'execute',",
            "                       side_effect=processutils.ProcessExecutionError)",
            "    def test_convert_image_with_errors(self, mocked_execute, mock_direct_io,",
            "                                       mock_disk_op_sema):",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.convert_image,",
            "                          '/path/that/does/not/exist',",
            "                          '/other/path/that/does/not/exist',",
            "                          'qcow2',",
            "                          'raw')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_convert_image_with_prlimit_fail(self, path, mocked_execute):",
            "        mocked_execute.side_effect = \\",
            "            processutils.ProcessExecutionError(exit_code=-9)",
            "        exc = self.assertRaises(exception.InvalidDiskInfo,",
            "                                images.qemu_img_info,",
            "                                '/fake/path')",
            "        self.assertIn('qemu-img aborted by prlimits', str(exc))",
            "",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_qemu_img_info_with_disk_not_found(self, exists, mocked_execute):",
            "        \"\"\"Tests that the initial os.path.exists check passes but the qemu-img",
            "        command fails because the path is gone by the time the command runs.",
            "        \"\"\"",
            "        path = '/opt/stack/data/nova/instances/some-uuid/disk'",
            "        stderr = (u\"qemu-img: Could not open \"",
            "                  \"'/opt/stack/data/nova/instances/some-uuid/disk': \"",
            "                  \"Could not open '/opt/stack/data/nova/instances/some-uuid/\"",
            "                  \"disk': No such file or directory\\n\")",
            "        mocked_execute.side_effect = (",
            "            processutils.ProcessExecutionError(",
            "                exit_code=1, stderr=stderr))",
            "        self.assertRaises(exception.DiskNotFound, images.qemu_img_info, path)",
            "        exists.assert_called_once_with(path)",
            "        mocked_execute.assert_called_once()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_errors(self, convert_image, qemu_img_info, fetch,",
            "                                 mock_detect, glance):",
            "        inspector = mock_detect.return_value",
            "        inspector.safety_check.return_value = True",
            "        inspector.__str__.return_value = 'qcow2'",
            "        glance.get.return_value = {'disk_format': 'qcow2'}",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'convert_image',",
            "                       side_effect=exception.ImageUnacceptable)",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_data_file(self, convert_image, qemu_img_info_fn,",
            "                                    fetch, mock_detect, mock_glance):",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        inspector = mock_detect.return_value",
            "        inspector.safety_check.return_value = True",
            "        inspector.__str__.return_value = 'qcow2'",
            "        # NOTE(danms): the above test needs the following line as well, as it",
            "        # is broken without it.",
            "        qemu_img_info = qemu_img_info_fn.return_value",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.file_format = 'qcow2'",
            "        qemu_img_info.virtual_size = 20",
            "        qemu_img_info.format_specific = {'data': {'data-file': 'somefile'}}",
            "        self.assertRaisesRegex(exception.ImageUnacceptable,",
            "                               'Image href123 is unacceptable.*somefile',",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no/path')",
            "",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('os.rename')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_from_raw(self, fetch, qemu_img_info_fn, mock_rename,",
            "                                   mock_glance, mock_detect):",
            "        # Make sure we support a case where we fetch an already-raw image and",
            "        # qemu-img returns None for \"format_specific\".",
            "        mock_glance.get.return_value = {'disk_format': 'raw'}",
            "        mock_detect.return_value.__str__.return_value = 'raw'",
            "        qemu_img_info = qemu_img_info_fn.return_value",
            "        qemu_img_info.file_format = 'raw'",
            "        qemu_img_info.backing_file = None",
            "        qemu_img_info.format_specific = None",
            "        images.fetch_to_raw(None, 'href123', '/no/path')",
            "        mock_rename.assert_called_once_with('/no/path.part', '/no/path')",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=True)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_with_direct_io_support(self, mock_execute,",
            "                                                  mock_direct_io,",
            "                                                  mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'none', '-O', 'out_format',",
            "                    '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    @mock.patch.object(compute_utils, 'disk_ops_semaphore')",
            "    @mock.patch('nova.privsep.utils.supports_direct_io', return_value=False)",
            "    @mock.patch('oslo_concurrency.processutils.execute')",
            "    def test_convert_image_without_direct_io_support(self, mock_execute,",
            "                                                     mock_direct_io,",
            "                                                     mock_disk_op_sema):",
            "        images._convert_image('source', 'dest', 'in_format', 'out_format',",
            "                              run_as_root=False)",
            "        expected = ('qemu-img', 'convert', '-t', 'writeback',",
            "                    '-O', 'out_format', '-f', 'in_format', 'source', 'dest')",
            "        mock_disk_op_sema.__enter__.assert_called_once()",
            "        self.assertTupleEqual(expected, mock_execute.call_args[0])",
            "",
            "    def test_convert_image_vmdk_allowed_list_checking(self):",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "",
            "        # If the format is not in the allowed list, we should get an error",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "        # With the format in the allowed list, no error",
            "        self.flags(vmdk_allowed_types=['streamOptimized', 'monolithicFlat',",
            "                                       'monolithicSparse'],",
            "                   group='compute')",
            "        images.check_vmdk_image('foo',",
            "                                imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                       format='json'))",
            "",
            "        # With an empty list, allow nothing",
            "        self.flags(vmdk_allowed_types=[], group='compute')",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.check_vmdk_image, 'foo',",
            "                          imageutils.QemuImgInfo(jsonutils.dumps(info),",
            "                                                 format='json'))",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'fetch')",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')",
            "    def test_fetch_checks_vmdk_rules(self, mock_info, mock_fetch, mock_detect,",
            "                                     mock_glance):",
            "        mock_glance.get.return_value = {'disk_format': 'vmdk'}",
            "        inspector = mock_detect.return_value",
            "        inspector.safety_check.return_value = True",
            "        inspector.__str__.return_value = 'vmdk'",
            "        info = {'format': 'vmdk',",
            "                'format-specific': {",
            "                    'type': 'vmdk',",
            "                    'data': {",
            "                        'create-type': 'monolithicFlat',",
            "                }}}",
            "        mock_info.return_value = jsonutils.dumps(info)",
            "        with mock.patch('os.path.exists', return_value=True):",
            "            e = self.assertRaises(exception.ImageUnacceptable,",
            "                                  images.fetch_to_raw, None, 'foo', 'anypath')",
            "            self.assertIn('Invalid VMDK create-type specified', str(e))",
            "",
            "    @mock.patch('os.rename')",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.get_inspector')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'fetch')",
            "    @mock.patch('nova.privsep.qemu.unprivileged_qemu_img_info')",
            "    def test_fetch_iso_is_raw(",
            "        self, mock_info, mock_fetch, mock_detect_file_format, mock_gi,",
            "        mock_glance, mock_rename):",
            "        mock_glance.get.return_value = {'disk_format': 'iso'}",
            "        inspector = mock_gi.return_value.from_file.return_value",
            "        inspector.safety_check.return_value = True",
            "        inspector.__str__.return_value = 'iso'",
            "        mock_detect_file_format.return_value = inspector",
            "        # qemu-img does not have a parser for iso so it is treated as raw",
            "        info = {",
            "            \"virtual-size\": 356352,",
            "            \"filename\": \"foo.iso\",",
            "            \"format\": \"raw\",",
            "            \"actual-size\": 356352,",
            "            \"dirty-flag\": False",
            "        }",
            "        mock_info.return_value = jsonutils.dumps(info)",
            "        with mock.patch('os.path.exists', return_value=True):",
            "            images.fetch_to_raw(None, 'foo', 'anypath')",
            "        # Make sure we called info with -f raw for an iso, since qemu-img does",
            "        # not support iso",
            "        mock_info.assert_called_once_with('anypath.part', format=None)",
            "        # Make sure that since we considered this to be a raw file, we did the",
            "        # just-rename-don't-convert path",
            "        mock_rename.assert_called_once_with('anypath.part', 'anypath')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_inspector(self, fetch, qemu_img_info, mock_detect,",
            "                                    mock_glance):",
            "        # Image claims to be qcow2, is qcow2, but fails safety check, so we",
            "        # abort before qemu-img-info",
            "        mock_glance.get.return_value = {'disk_format': 'qcow2'}",
            "        inspector = mock_detect.return_value",
            "        inspector.safety_check.return_value = False",
            "        inspector.__str__.return_value = 'qcow2'",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        qemu_img_info.assert_not_called()",
            "        mock_detect.assert_called_once_with('/no.path.part')",
            "        inspector.safety_check.assert_called_once_with()",
            "        mock_glance.get.assert_called_once_with(None, 'href123')",
            "",
            "        # Image claims to be qcow2, is qcow2, passes safety check, so we make",
            "        # it all the way to qemu-img-info",
            "        inspector.safety_check.return_value = True",
            "        qemu_img_info.side_effect = test.TestingException",
            "        self.assertRaises(test.TestingException,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "",
            "        # Image claims to be qcow2 in glance, but the image is something else,",
            "        # so we abort before qemu-img-info",
            "        qemu_img_info.reset_mock()",
            "        mock_detect.reset_mock()",
            "        inspector.safety_check.reset_mock()",
            "        mock_detect.return_value.__str__.return_value = 'vmdk'",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        mock_detect.assert_called_once_with('/no.path.part')",
            "        inspector.safety_check.assert_called_once_with()",
            "        qemu_img_info.assert_not_called()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch.object(images, 'fetch')",
            "    def test_fetch_to_raw_inspector_disabled(self, fetch, qemu_img_info,",
            "                                             mock_gi, mock_glance):",
            "        self.flags(disable_deep_image_inspection=True,",
            "                   group='workarounds')",
            "        qemu_img_info.side_effect = test.TestingException",
            "        self.assertRaises(test.TestingException,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # If deep inspection is disabled, we should never call the inspector",
            "        mock_gi.assert_not_called()",
            "        # ... and we let qemu-img detect the format itself.",
            "        qemu_img_info.assert_called_once_with('/no.path.part')",
            "        mock_glance.get.assert_not_called()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    def test_fetch_inspect_ami(self, detect, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'ami'}",
            "        detect.return_value.__str__.return_value = 'raw'",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Make sure 'ami was translated into 'raw' before we call qemu-img",
            "        imginfo.assert_called_once_with('/no.path.part')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    def test_fetch_inspect_aki(self, detect, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'aki'}",
            "        detect.return_value.__str__.return_value = 'raw'",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Make sure 'aki was translated into 'raw' before we call qemu-img",
            "        imginfo.assert_called_once_with('/no.path.part')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    def test_fetch_inspect_ari(self, detect, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'ari'}",
            "        detect.return_value.__str__.return_value = 'raw'",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Make sure 'aki was translated into 'raw' before we call qemu-img",
            "        imginfo.assert_called_once_with('/no.path.part')",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    def test_fetch_inspect_unknown_format(self, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'commodore-64-disk'}",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          images.fetch_to_raw, None, 'href123', '/no.path')",
            "        # Unsupported formats do not make it past deep inspection",
            "        imginfo.assert_not_called()",
            "",
            "    @mock.patch.object(images, 'IMAGE_API')",
            "    @mock.patch.object(images, 'qemu_img_info')",
            "    @mock.patch('nova.image.format_inspector.detect_file_format')",
            "    def test_fetch_inspect_disagrees_qemu(self, mock_detect, imginfo, glance):",
            "        glance.get.return_value = {'disk_format': 'qcow2'}",
            "        mock_detect.return_value.__str__.return_value = 'qcow2'",
            "        # Glance and inspector think it is a qcow2 file, but qemu-img does not",
            "        # agree.",
            "        imginfo.return_value.data_file = None",
            "        imginfo.return_value.file_format = 'vmdk'",
            "        ex = self.assertRaises(exception.ImageUnacceptable,",
            "                               images.fetch_to_raw,",
            "                               None, 'href123', '/no.path')",
            "        self.assertIn('content does not match disk_format', str(ex))",
            "        imginfo.assert_called_once_with('/no.path.part')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "24": [],
            "104": [
                "QemuTestCase"
            ],
            "110": [
                "QemuTestCase",
                "test_fetch_to_raw_errors"
            ],
            "111": [
                "QemuTestCase",
                "test_fetch_to_raw_errors"
            ],
            "123": [
                "QemuTestCase"
            ],
            "129": [
                "QemuTestCase",
                "test_fetch_to_raw_data_file"
            ],
            "131": [
                "QemuTestCase",
                "test_fetch_to_raw_data_file"
            ],
            "145": [
                "QemuTestCase"
            ],
            "151": [
                "QemuTestCase",
                "test_fetch_to_raw_from_raw"
            ],
            "218": [
                "QemuTestCase"
            ],
            "221": [
                "QemuTestCase",
                "test_fetch_checks_vmdk_rules"
            ],
            "224": [
                "QemuTestCase",
                "test_fetch_checks_vmdk_rules"
            ],
            "243": [
                "QemuTestCase",
                "test_fetch_iso_is_raw"
            ],
            "244": [
                "QemuTestCase",
                "test_fetch_iso_is_raw"
            ],
            "261": [
                "QemuTestCase",
                "test_fetch_iso_is_raw"
            ],
            "267": [
                "QemuTestCase"
            ],
            "270": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "275": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "280": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "281": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "295": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "297": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "298": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "301": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "302": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector"
            ],
            "306": [
                "QemuTestCase"
            ],
            "319": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector_disabled"
            ],
            "320": [
                "QemuTestCase",
                "test_fetch_to_raw_inspector_disabled"
            ],
            "325": [
                "QemuTestCase",
                "test_fetch_inspect_ami"
            ],
            "330": [
                "QemuTestCase",
                "test_fetch_inspect_ami"
            ],
            "334": [
                "QemuTestCase",
                "test_fetch_inspect_aki"
            ],
            "339": [
                "QemuTestCase",
                "test_fetch_inspect_aki"
            ],
            "343": [
                "QemuTestCase",
                "test_fetch_inspect_ari"
            ],
            "348": [
                "QemuTestCase",
                "test_fetch_inspect_ari"
            ],
            "361": [
                "QemuTestCase"
            ],
            "362": [
                "QemuTestCase",
                "test_fetch_inspect_disagrees_qemu"
            ],
            "365": [
                "QemuTestCase",
                "test_fetch_inspect_disagrees_qemu"
            ],
            "366": [
                "QemuTestCase",
                "test_fetch_inspect_disagrees_qemu"
            ],
            "368": [
                "QemuTestCase",
                "test_fetch_inspect_disagrees_qemu"
            ],
            "369": [
                "QemuTestCase",
                "test_fetch_inspect_disagrees_qemu"
            ],
            "370": [
                "QemuTestCase",
                "test_fetch_inspect_disagrees_qemu"
            ]
        },
        "addLocation": []
    }
}