{
    "kotti/tests/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     return connection"
            },
            "1": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@fixture(scope='session')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+@fixture"
            },
            "5": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " def content(connection, settings):"
            },
            "6": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     \"\"\" sets up some default content using Kotti's testing populator."
            },
            "7": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from transaction import commit"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    import transaction"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+    from kotti import DBSession"
            },
            "11": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "     from kotti import metadata"
            },
            "12": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     from kotti.resources import get_root"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+    if connection.in_transaction():"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        transaction.abort()"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    DBSession().close()"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     metadata.drop_all(connection.engine)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    transaction.begin()"
            },
            "20": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "     metadata.create_all(connection.engine)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     # to create the default content with the correct workflow state"
            },
            "23": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     # the workflow must be initialized first;  please note that these"
            },
            "24": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     # settings won't persist, though;  use the `workflow` fixture if needed"
            },
            "25": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     # 'event' and therefore the event handlers aren't fired for root"
            },
            "26": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     # otherwise:"
            },
            "27": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "     get_root().path = u'/'"
            },
            "28": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    commit()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    transaction.commit()"
            },
            "30": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 193,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " @fixture"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "\"\"\"",
            "",
            "Fixture dependencies",
            "--------------------",
            "",
            ".. graphviz::",
            "",
            "   digraph kotti_fixtures {",
            "      \"allwarnings\";",
            "      \"app\" -> \"webtest\";",
            "      \"config\" -> \"db_session\";",
            "      \"config\" -> \"depot_tween\";",
            "      \"config\" -> \"dummy_request\";",
            "      \"config\" -> \"events\";",
            "      \"config\" -> \"workflow\";",
            "      \"connection\" -> \"content\";",
            "      \"connection\" -> \"db_session\";",
            "      \"content\" -> \"db_session\";",
            "      \"custom_settings\" -> \"connection\";",
            "      \"custom_settings\" -> \"unresolved_settings\";",
            "      \"db_session\" -> \"app\";",
            "      \"db_session\" -> \"browser\";",
            "      \"db_session\" -> \"filedepot\";",
            "      \"db_session\" -> \"root\";",
            "      \"depot_tween\" -> \"webtest\";",
            "      \"dummy_mailer\" -> \"app\";",
            "      \"dummy_mailer\";",
            "      \"dummy_request\" -> \"depot_tween\";",
            "      \"events\" -> \"app\";",
            "      \"depot_tween\" -> \"filedepot\";",
            "      \"depot_tween\" -> \"mock_filedepot\";",
            "      \"mock_filedepot\";",
            "      \"depot_tween\" -> \"no_filedepots\";",
            "      \"settings\" -> \"config\";",
            "      \"settings\" -> \"content\";",
            "      \"setup_app\" -> \"app\";",
            "      \"setup_app\" -> \"browser\";",
            "      \"unresolved_settings\" -> \"settings\";",
            "      \"unresolved_settings\" -> \"setup_app\";",
            "      \"workflow\" -> \"app\";",
            "   }",
            "",
            "\"\"\"",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "import warnings",
            "from datetime import datetime",
            "",
            "from mock import MagicMock",
            "from pytest import fixture",
            "",
            "from kotti import testing",
            "",
            "",
            "@fixture",
            "def image_asset():",
            "    \"\"\" Return an image file \"\"\"",
            "",
            "    return testing.asset('sendeschluss.jpg')",
            "",
            "",
            "@fixture",
            "def image_asset2():",
            "    \"\"\" Return another image file \"\"\"",
            "",
            "    return testing.asset('logo.png')",
            "",
            "",
            "@fixture",
            "def allwarnings(request):",
            "    save_filters = warnings.filters[:]",
            "    warnings.filters[:] = []",
            "",
            "    def restore():",
            "        warnings.filters[:] = save_filters",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture(scope='session')",
            "def custom_settings():",
            "    \"\"\" This is a dummy fixture meant to be overriden in add on package's",
            "    ``conftest.py``.  It can be used to inject arbitrary settings for third",
            "    party test suites.  The default settings dictionary will be updated",
            "    with the dictionary returned by this fixture.",
            "",
            "    This is also a good place to import your add on's ``resources`` module to",
            "    have the corresponding tables created during ``create_all()`` in",
            "    :func:`kotti.tests.content`.",
            "",
            "    :result: settings",
            "    :rtype: dict",
            "    \"\"\"",
            "",
            "    return {}",
            "",
            "",
            "@fixture(scope='session')",
            "def unresolved_settings(custom_settings):",
            "    from kotti import conf_defaults",
            "    from kotti.testing import testing_db_url",
            "    settings = conf_defaults.copy()",
            "    settings['kotti.secret'] = 'secret'",
            "    settings['kotti.secret2'] = 'secret2'",
            "    settings['kotti.populators'] = 'kotti.testing._populator'",
            "    settings['sqlalchemy.url'] = testing_db_url()",
            "    settings.update(custom_settings)",
            "    return settings",
            "",
            "",
            "@fixture(scope='session')",
            "def settings(unresolved_settings):",
            "    from kotti import _resolve_dotted",
            "    return _resolve_dotted(unresolved_settings)",
            "",
            "",
            "@fixture",
            "def config(request, settings):",
            "    \"\"\" returns a Pyramid `Configurator` object initialized",
            "        with Kotti's default (test) settings.",
            "    \"\"\"",
            "    from pyramid import testing",
            "    from kotti import security",
            "    config = testing.setUp(settings=settings)",
            "    config.include('pyramid_chameleon')",
            "    config.add_default_renderers()",
            "    request.addfinalizer(security.reset)",
            "    request.addfinalizer(testing.tearDown)",
            "    return config",
            "",
            "",
            "@fixture(scope='session')",
            "def connection(custom_settings):",
            "    \"\"\" sets up a SQLAlchemy engine and returns a connection to the database.",
            "    The connection string used for testing can be specified via the",
            "    ``KOTTI_TEST_DB_STRING`` environment variable.  The ``custom_settings``",
            "    fixture is needed to allow users to import their models easily instead of",
            "    having to override the ``connection``.",
            "    \"\"\"",
            "    # the following setup is based on `kotti.resources.initialize_sql`,",
            "    # except that it explicitly binds the session to a specific connection",
            "    # enabling us to use savepoints independent from the orm, thus allowing",
            "    # to `rollback` after using `transaction.commit`...",
            "    from sqlalchemy import create_engine",
            "    from kotti import DBSession",
            "    from kotti import metadata",
            "    from kotti.resources import _adjust_for_engine",
            "    from kotti.testing import testing_db_url",
            "    engine = create_engine(testing_db_url())",
            "    _adjust_for_engine(engine)",
            "    connection = engine.connect()",
            "    DBSession.registry.clear()",
            "    DBSession.configure(bind=connection)",
            "    metadata.bind = engine",
            "    return connection",
            "",
            "",
            "@fixture(scope='session')",
            "def content(connection, settings):",
            "    \"\"\" sets up some default content using Kotti's testing populator.",
            "    \"\"\"",
            "    from transaction import commit",
            "    from kotti import metadata",
            "    from kotti.resources import get_root",
            "    metadata.drop_all(connection.engine)",
            "    metadata.create_all(connection.engine)",
            "    # to create the default content with the correct workflow state",
            "    # the workflow must be initialized first;  please note that these",
            "    # settings won't persist, though;  use the `workflow` fixture if needed",
            "    from zope.configuration import xmlconfig",
            "    import kotti",
            "    xmlconfig.file('workflow.zcml', kotti, execute=True)",
            "    for populate in settings['kotti.populators']:",
            "        populate()",
            "",
            "    # We set the path here since it's required for some integration",
            "    # tests, and because the 'content' fixture does not depend on",
            "    # 'event' and therefore the event handlers aren't fired for root",
            "    # otherwise:",
            "    get_root().path = u'/'",
            "    commit()",
            "",
            "",
            "@fixture",
            "def db_session(config, content, connection, request):",
            "    \"\"\" returns a db session object and sets up a db transaction",
            "        savepoint, which will be rolled back after the test.",
            "    \"\"\"",
            "",
            "    from transaction import abort",
            "    trans = connection.begin()          # begin a non-orm transaction",
            "    request.addfinalizer(trans.rollback)",
            "    request.addfinalizer(abort)",
            "    from kotti import DBSession",
            "    return DBSession()",
            "",
            "",
            "@fixture",
            "def dummy_request(config, request, monkeypatch):",
            "    \"\"\" returns a dummy request object after registering it as",
            "        the currently active request.  This is needed when",
            "        `pyramid.threadlocal.get_current_request` is used.",
            "    \"\"\"",
            "",
            "    from kotti.testing import DummyRequest",
            "",
            "    if 'user' in request.keywords:",
            "        monkeypatch.setattr(",
            "            DummyRequest,",
            "            \"authenticated_userid\",",
            "            request.keywords['user'].args[0])",
            "",
            "    config.manager.get()['request'] = dummy_request = DummyRequest()",
            "",
            "    return dummy_request",
            "",
            "",
            "@fixture",
            "def dummy_mailer(monkeypatch):",
            "    from pyramid_mailer.mailer import DummyMailer",
            "",
            "    mailer = DummyMailer()",
            "    monkeypatch.setattr('kotti.message.get_mailer', lambda: mailer)",
            "    return mailer",
            "",
            "",
            "@fixture",
            "def events(config, request):",
            "    \"\"\" sets up Kotti's default event handlers.",
            "    \"\"\"",
            "    from kotti.events import clear",
            "    config.include('kotti.events')",
            "    request.addfinalizer(clear)",
            "    return config",
            "",
            "",
            "@fixture",
            "def setup_app(unresolved_settings, filedepot):",
            "    from kotti import base_configure",
            "    config = base_configure({}, **unresolved_settings)",
            "    return config.make_wsgi_app()",
            "",
            "",
            "@fixture",
            "def app(workflow, db_session, dummy_mailer, events, setup_app):",
            "    return setup_app",
            "",
            "",
            "@fixture",
            "def browser(db_session, request, setup_app):",
            "    \"\"\" returns an instance of `zope.testbrowser`.  The `kotti.testing.user`",
            "        pytest marker (or `pytest.mark.user`) can be used to pre-authenticate",
            "        the browser with the given login name: `@user('admin')`.",
            "    \"\"\"",
            "    from zope.testbrowser.wsgi import Browser",
            "    from kotti.testing import BASE_URL",
            "    host, port = BASE_URL.split(':')[-2:]",
            "    browser = Browser('http://{}:{}/'.format(host[2:], int(port)),",
            "                      wsgi_app=setup_app)",
            "    if 'user' in request.keywords:",
            "        # set auth cookie directly on the browser instance...",
            "        from pyramid.security import remember",
            "        from pyramid.testing import DummyRequest",
            "        login = request.keywords['user'].args[0]",
            "        environ = dict(HTTP_HOST=host[2:])",
            "        for _, value in remember(DummyRequest(environ=environ), login):",
            "            cookie, _ = value.split(';', 1)",
            "            name, value = cookie.split('=')",
            "            if name in browser.cookies:",
            "                del browser.cookies[name]",
            "            browser.cookies.create(name, value.strip('\"'), path='/')",
            "    return browser",
            "",
            "",
            "@fixture",
            "def root(db_session):",
            "    \"\"\" returns Kotti's 'root' node.",
            "    \"\"\"",
            "    from kotti.resources import get_root",
            "    return get_root()",
            "",
            "",
            "@fixture",
            "def webtest(app, monkeypatch, request, filedepot, dummy_mailer):",
            "    from webtest import TestApp",
            "    if 'user' in request.keywords:",
            "        login = request.keywords['user'].args[0]",
            "        monkeypatch.setattr(",
            "            \"pyramid.authentication.\"",
            "            \"AuthTktAuthenticationPolicy.unauthenticated_userid\",",
            "            lambda self, req: login)",
            "    return TestApp(app)",
            "",
            "",
            "@fixture",
            "def workflow(config):",
            "    \"\"\" loads and activates Kotti's default workflow rules.",
            "    \"\"\"",
            "    from zope.configuration import xmlconfig",
            "    import kotti",
            "    xmlconfig.file('workflow.zcml', kotti, execute=True)",
            "",
            "",
            "class TestStorage:",
            "    def __init__(self):",
            "        self._storage = {}",
            "        self._storage.setdefault(0)",
            "",
            "    def get(self, id):",
            "        info = self._storage[int(id)]",
            "",
            "        from StringIO import StringIO",
            "",
            "        f = MagicMock(wraps=StringIO(info['content']))",
            "        f.seek(0)",
            "        f.public_url = None",
            "        f.filename = info['filename']",
            "        f.content_type = info['content_type']",
            "        f.content_length = len(info['content'])",
            "        # needed to make JSON serializable, Mock objects are not",
            "        f.last_modified = datetime(2012, 12, 30)",
            "",
            "        return f",
            "",
            "    def create(self, content, filename=None, content_type=None):",
            "        _id = max(self._storage) + 1",
            "        filename = filename or getattr(content, 'filename', None)",
            "        content_type = content_type or getattr(content, 'type', None)",
            "",
            "        if hasattr(content, 'file') and hasattr(content.file, 'read'):",
            "            content = content.file.read()",
            "        elif hasattr(content, 'read'):",
            "            content = content.read()",
            "",
            "        self._storage[_id] = {'content': content,",
            "                              'filename': filename,",
            "                              'content_type': content_type}",
            "        return _id",
            "",
            "    def delete(self, id):",
            "        del self._storage[int(id)]",
            "",
            "",
            "@fixture",
            "def depot_tween(request, config, dummy_request):",
            "    \"\"\" Sets up the Depot tween and patches Depot's ``set_middleware`` to",
            "    suppress exceptions on subsequent calls \"\"\"",
            "",
            "    from depot.manager import DepotManager",
            "    from kotti.filedepot import TweenFactory",
            "    from kotti.filedepot import uploaded_file_response",
            "    from kotti.filedepot import uploaded_file_url",
            "",
            "    dummy_request.__class__.uploaded_file_response = uploaded_file_response",
            "    dummy_request.__class__.uploaded_file_url = uploaded_file_url",
            "",
            "    _set_middleware = DepotManager.set_middleware",
            "    TweenFactory(None, config.registry)",
            "",
            "    # noinspection PyDecorator",
            "    @classmethod",
            "    def set_middleware_patched(cls, mw):",
            "        pass",
            "",
            "    DepotManager.set_middleware = set_middleware_patched",
            "",
            "    def restore():",
            "        DepotManager.set_middleware = _set_middleware",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture",
            "def mock_filedepot(request, depot_tween):",
            "    \"\"\" Configures a mock depot store for :class:`depot.manager.DepotManager`",
            "",
            "    This filedepot is not integrated with dbsession.",
            "    Can be used in simple, standalone unit tests.",
            "    \"\"\"",
            "    from depot.manager import DepotManager",
            "",
            "    DepotManager._depots = {",
            "        'mockdepot': MagicMock(wraps=TestStorage())",
            "    }",
            "    DepotManager._default_depot = 'mockdepot'",
            "",
            "    def restore():",
            "        DepotManager._clear()",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture",
            "def filedepot(db_session, request, depot_tween):",
            "    \"\"\" Configures a dbsession integrated mock depot store for",
            "    :class:`depot.manager.DepotManager`",
            "    \"\"\"",
            "    from depot.manager import DepotManager",
            "",
            "    DepotManager._depots = {",
            "        'filedepot': MagicMock(wraps=TestStorage())",
            "    }",
            "    DepotManager._default_depot = 'filedepot'",
            "",
            "    def restore():",
            "        db_session.rollback()",
            "        DepotManager._clear()",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture",
            "def no_filedepots(db_session, request, depot_tween):",
            "    \"\"\" A filedepot fixture to empty and then restore DepotManager configuration",
            "    \"\"\"",
            "    from depot.manager import DepotManager",
            "",
            "    DepotManager._depots = {}",
            "    DepotManager._default_depot = None",
            "",
            "    def restore():",
            "        db_session.rollback()",
            "        DepotManager._clear()",
            "",
            "    request.addfinalizer(restore)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "\"\"\"",
            "",
            "Fixture dependencies",
            "--------------------",
            "",
            ".. graphviz::",
            "",
            "   digraph kotti_fixtures {",
            "      \"allwarnings\";",
            "      \"app\" -> \"webtest\";",
            "      \"config\" -> \"db_session\";",
            "      \"config\" -> \"depot_tween\";",
            "      \"config\" -> \"dummy_request\";",
            "      \"config\" -> \"events\";",
            "      \"config\" -> \"workflow\";",
            "      \"connection\" -> \"content\";",
            "      \"connection\" -> \"db_session\";",
            "      \"content\" -> \"db_session\";",
            "      \"custom_settings\" -> \"connection\";",
            "      \"custom_settings\" -> \"unresolved_settings\";",
            "      \"db_session\" -> \"app\";",
            "      \"db_session\" -> \"browser\";",
            "      \"db_session\" -> \"filedepot\";",
            "      \"db_session\" -> \"root\";",
            "      \"depot_tween\" -> \"webtest\";",
            "      \"dummy_mailer\" -> \"app\";",
            "      \"dummy_mailer\";",
            "      \"dummy_request\" -> \"depot_tween\";",
            "      \"events\" -> \"app\";",
            "      \"depot_tween\" -> \"filedepot\";",
            "      \"depot_tween\" -> \"mock_filedepot\";",
            "      \"mock_filedepot\";",
            "      \"depot_tween\" -> \"no_filedepots\";",
            "      \"settings\" -> \"config\";",
            "      \"settings\" -> \"content\";",
            "      \"setup_app\" -> \"app\";",
            "      \"setup_app\" -> \"browser\";",
            "      \"unresolved_settings\" -> \"settings\";",
            "      \"unresolved_settings\" -> \"setup_app\";",
            "      \"workflow\" -> \"app\";",
            "   }",
            "",
            "\"\"\"",
            "",
            "from __future__ import absolute_import, division, print_function",
            "",
            "import warnings",
            "from datetime import datetime",
            "",
            "from mock import MagicMock",
            "from pytest import fixture",
            "",
            "from kotti import testing",
            "",
            "",
            "@fixture",
            "def image_asset():",
            "    \"\"\" Return an image file \"\"\"",
            "",
            "    return testing.asset('sendeschluss.jpg')",
            "",
            "",
            "@fixture",
            "def image_asset2():",
            "    \"\"\" Return another image file \"\"\"",
            "",
            "    return testing.asset('logo.png')",
            "",
            "",
            "@fixture",
            "def allwarnings(request):",
            "    save_filters = warnings.filters[:]",
            "    warnings.filters[:] = []",
            "",
            "    def restore():",
            "        warnings.filters[:] = save_filters",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture(scope='session')",
            "def custom_settings():",
            "    \"\"\" This is a dummy fixture meant to be overriden in add on package's",
            "    ``conftest.py``.  It can be used to inject arbitrary settings for third",
            "    party test suites.  The default settings dictionary will be updated",
            "    with the dictionary returned by this fixture.",
            "",
            "    This is also a good place to import your add on's ``resources`` module to",
            "    have the corresponding tables created during ``create_all()`` in",
            "    :func:`kotti.tests.content`.",
            "",
            "    :result: settings",
            "    :rtype: dict",
            "    \"\"\"",
            "",
            "    return {}",
            "",
            "",
            "@fixture(scope='session')",
            "def unresolved_settings(custom_settings):",
            "    from kotti import conf_defaults",
            "    from kotti.testing import testing_db_url",
            "    settings = conf_defaults.copy()",
            "    settings['kotti.secret'] = 'secret'",
            "    settings['kotti.secret2'] = 'secret2'",
            "    settings['kotti.populators'] = 'kotti.testing._populator'",
            "    settings['sqlalchemy.url'] = testing_db_url()",
            "    settings.update(custom_settings)",
            "    return settings",
            "",
            "",
            "@fixture(scope='session')",
            "def settings(unresolved_settings):",
            "    from kotti import _resolve_dotted",
            "    return _resolve_dotted(unresolved_settings)",
            "",
            "",
            "@fixture",
            "def config(request, settings):",
            "    \"\"\" returns a Pyramid `Configurator` object initialized",
            "        with Kotti's default (test) settings.",
            "    \"\"\"",
            "    from pyramid import testing",
            "    from kotti import security",
            "    config = testing.setUp(settings=settings)",
            "    config.include('pyramid_chameleon')",
            "    config.add_default_renderers()",
            "    request.addfinalizer(security.reset)",
            "    request.addfinalizer(testing.tearDown)",
            "    return config",
            "",
            "",
            "@fixture(scope='session')",
            "def connection(custom_settings):",
            "    \"\"\" sets up a SQLAlchemy engine and returns a connection to the database.",
            "    The connection string used for testing can be specified via the",
            "    ``KOTTI_TEST_DB_STRING`` environment variable.  The ``custom_settings``",
            "    fixture is needed to allow users to import their models easily instead of",
            "    having to override the ``connection``.",
            "    \"\"\"",
            "    # the following setup is based on `kotti.resources.initialize_sql`,",
            "    # except that it explicitly binds the session to a specific connection",
            "    # enabling us to use savepoints independent from the orm, thus allowing",
            "    # to `rollback` after using `transaction.commit`...",
            "    from sqlalchemy import create_engine",
            "    from kotti import DBSession",
            "    from kotti import metadata",
            "    from kotti.resources import _adjust_for_engine",
            "    from kotti.testing import testing_db_url",
            "    engine = create_engine(testing_db_url())",
            "    _adjust_for_engine(engine)",
            "    connection = engine.connect()",
            "    DBSession.registry.clear()",
            "    DBSession.configure(bind=connection)",
            "    metadata.bind = engine",
            "    return connection",
            "",
            "",
            "@fixture",
            "def content(connection, settings):",
            "    \"\"\" sets up some default content using Kotti's testing populator.",
            "    \"\"\"",
            "    import transaction",
            "    from kotti import DBSession",
            "    from kotti import metadata",
            "    from kotti.resources import get_root",
            "",
            "    if connection.in_transaction():",
            "        transaction.abort()",
            "    DBSession().close()",
            "",
            "    metadata.drop_all(connection.engine)",
            "    transaction.begin()",
            "    metadata.create_all(connection.engine)",
            "",
            "    # to create the default content with the correct workflow state",
            "    # the workflow must be initialized first;  please note that these",
            "    # settings won't persist, though;  use the `workflow` fixture if needed",
            "    from zope.configuration import xmlconfig",
            "    import kotti",
            "    xmlconfig.file('workflow.zcml', kotti, execute=True)",
            "    for populate in settings['kotti.populators']:",
            "        populate()",
            "",
            "    # We set the path here since it's required for some integration",
            "    # tests, and because the 'content' fixture does not depend on",
            "    # 'event' and therefore the event handlers aren't fired for root",
            "    # otherwise:",
            "    get_root().path = u'/'",
            "    transaction.commit()",
            "",
            "",
            "@fixture",
            "def db_session(config, content, connection, request):",
            "    \"\"\" returns a db session object and sets up a db transaction",
            "        savepoint, which will be rolled back after the test.",
            "    \"\"\"",
            "",
            "    from transaction import abort",
            "    trans = connection.begin()          # begin a non-orm transaction",
            "    request.addfinalizer(trans.rollback)",
            "    request.addfinalizer(abort)",
            "    from kotti import DBSession",
            "    return DBSession()",
            "",
            "",
            "@fixture",
            "def dummy_request(config, request, monkeypatch):",
            "    \"\"\" returns a dummy request object after registering it as",
            "        the currently active request.  This is needed when",
            "        `pyramid.threadlocal.get_current_request` is used.",
            "    \"\"\"",
            "",
            "    from kotti.testing import DummyRequest",
            "",
            "    if 'user' in request.keywords:",
            "        monkeypatch.setattr(",
            "            DummyRequest,",
            "            \"authenticated_userid\",",
            "            request.keywords['user'].args[0])",
            "",
            "    config.manager.get()['request'] = dummy_request = DummyRequest()",
            "",
            "    return dummy_request",
            "",
            "",
            "@fixture",
            "def dummy_mailer(monkeypatch):",
            "    from pyramid_mailer.mailer import DummyMailer",
            "",
            "    mailer = DummyMailer()",
            "    monkeypatch.setattr('kotti.message.get_mailer', lambda: mailer)",
            "    return mailer",
            "",
            "",
            "@fixture",
            "def events(config, request):",
            "    \"\"\" sets up Kotti's default event handlers.",
            "    \"\"\"",
            "    from kotti.events import clear",
            "    config.include('kotti.events')",
            "    request.addfinalizer(clear)",
            "    return config",
            "",
            "",
            "@fixture",
            "def setup_app(unresolved_settings, filedepot):",
            "    from kotti import base_configure",
            "    config = base_configure({}, **unresolved_settings)",
            "    return config.make_wsgi_app()",
            "",
            "",
            "@fixture",
            "def app(workflow, db_session, dummy_mailer, events, setup_app):",
            "    return setup_app",
            "",
            "",
            "@fixture",
            "def browser(db_session, request, setup_app):",
            "    \"\"\" returns an instance of `zope.testbrowser`.  The `kotti.testing.user`",
            "        pytest marker (or `pytest.mark.user`) can be used to pre-authenticate",
            "        the browser with the given login name: `@user('admin')`.",
            "    \"\"\"",
            "    from zope.testbrowser.wsgi import Browser",
            "    from kotti.testing import BASE_URL",
            "    host, port = BASE_URL.split(':')[-2:]",
            "    browser = Browser('http://{}:{}/'.format(host[2:], int(port)),",
            "                      wsgi_app=setup_app)",
            "    if 'user' in request.keywords:",
            "        # set auth cookie directly on the browser instance...",
            "        from pyramid.security import remember",
            "        from pyramid.testing import DummyRequest",
            "        login = request.keywords['user'].args[0]",
            "        environ = dict(HTTP_HOST=host[2:])",
            "        for _, value in remember(DummyRequest(environ=environ), login):",
            "            cookie, _ = value.split(';', 1)",
            "            name, value = cookie.split('=')",
            "            if name in browser.cookies:",
            "                del browser.cookies[name]",
            "            browser.cookies.create(name, value.strip('\"'), path='/')",
            "    return browser",
            "",
            "",
            "@fixture",
            "def root(db_session):",
            "    \"\"\" returns Kotti's 'root' node.",
            "    \"\"\"",
            "    from kotti.resources import get_root",
            "    return get_root()",
            "",
            "",
            "@fixture",
            "def webtest(app, monkeypatch, request, filedepot, dummy_mailer):",
            "    from webtest import TestApp",
            "    if 'user' in request.keywords:",
            "        login = request.keywords['user'].args[0]",
            "        monkeypatch.setattr(",
            "            \"pyramid.authentication.\"",
            "            \"AuthTktAuthenticationPolicy.unauthenticated_userid\",",
            "            lambda self, req: login)",
            "    return TestApp(app)",
            "",
            "",
            "@fixture",
            "def workflow(config):",
            "    \"\"\" loads and activates Kotti's default workflow rules.",
            "    \"\"\"",
            "    from zope.configuration import xmlconfig",
            "    import kotti",
            "    xmlconfig.file('workflow.zcml', kotti, execute=True)",
            "",
            "",
            "class TestStorage:",
            "    def __init__(self):",
            "        self._storage = {}",
            "        self._storage.setdefault(0)",
            "",
            "    def get(self, id):",
            "        info = self._storage[int(id)]",
            "",
            "        from StringIO import StringIO",
            "",
            "        f = MagicMock(wraps=StringIO(info['content']))",
            "        f.seek(0)",
            "        f.public_url = None",
            "        f.filename = info['filename']",
            "        f.content_type = info['content_type']",
            "        f.content_length = len(info['content'])",
            "        # needed to make JSON serializable, Mock objects are not",
            "        f.last_modified = datetime(2012, 12, 30)",
            "",
            "        return f",
            "",
            "    def create(self, content, filename=None, content_type=None):",
            "        _id = max(self._storage) + 1",
            "        filename = filename or getattr(content, 'filename', None)",
            "        content_type = content_type or getattr(content, 'type', None)",
            "",
            "        if hasattr(content, 'file') and hasattr(content.file, 'read'):",
            "            content = content.file.read()",
            "        elif hasattr(content, 'read'):",
            "            content = content.read()",
            "",
            "        self._storage[_id] = {'content': content,",
            "                              'filename': filename,",
            "                              'content_type': content_type}",
            "        return _id",
            "",
            "    def delete(self, id):",
            "        del self._storage[int(id)]",
            "",
            "",
            "@fixture",
            "def depot_tween(request, config, dummy_request):",
            "    \"\"\" Sets up the Depot tween and patches Depot's ``set_middleware`` to",
            "    suppress exceptions on subsequent calls \"\"\"",
            "",
            "    from depot.manager import DepotManager",
            "    from kotti.filedepot import TweenFactory",
            "    from kotti.filedepot import uploaded_file_response",
            "    from kotti.filedepot import uploaded_file_url",
            "",
            "    dummy_request.__class__.uploaded_file_response = uploaded_file_response",
            "    dummy_request.__class__.uploaded_file_url = uploaded_file_url",
            "",
            "    _set_middleware = DepotManager.set_middleware",
            "    TweenFactory(None, config.registry)",
            "",
            "    # noinspection PyDecorator",
            "    @classmethod",
            "    def set_middleware_patched(cls, mw):",
            "        pass",
            "",
            "    DepotManager.set_middleware = set_middleware_patched",
            "",
            "    def restore():",
            "        DepotManager.set_middleware = _set_middleware",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture",
            "def mock_filedepot(request, depot_tween):",
            "    \"\"\" Configures a mock depot store for :class:`depot.manager.DepotManager`",
            "",
            "    This filedepot is not integrated with dbsession.",
            "    Can be used in simple, standalone unit tests.",
            "    \"\"\"",
            "    from depot.manager import DepotManager",
            "",
            "    DepotManager._depots = {",
            "        'mockdepot': MagicMock(wraps=TestStorage())",
            "    }",
            "    DepotManager._default_depot = 'mockdepot'",
            "",
            "    def restore():",
            "        DepotManager._clear()",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture",
            "def filedepot(db_session, request, depot_tween):",
            "    \"\"\" Configures a dbsession integrated mock depot store for",
            "    :class:`depot.manager.DepotManager`",
            "    \"\"\"",
            "    from depot.manager import DepotManager",
            "",
            "    DepotManager._depots = {",
            "        'filedepot': MagicMock(wraps=TestStorage())",
            "    }",
            "    DepotManager._default_depot = 'filedepot'",
            "",
            "    def restore():",
            "        db_session.rollback()",
            "        DepotManager._clear()",
            "",
            "    request.addfinalizer(restore)",
            "",
            "",
            "@fixture",
            "def no_filedepots(db_session, request, depot_tween):",
            "    \"\"\" A filedepot fixture to empty and then restore DepotManager configuration",
            "    \"\"\"",
            "    from depot.manager import DepotManager",
            "",
            "    DepotManager._depots = {}",
            "    DepotManager._default_depot = None",
            "",
            "    def restore():",
            "        db_session.rollback()",
            "        DepotManager._clear()",
            "",
            "    request.addfinalizer(restore)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "161": [],
            "165": [
                "content"
            ],
            "184": [
                "content"
            ]
        },
        "addLocation": []
    },
    "kotti/tests/test_node_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from kotti.testing import DummyRequest"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from pyramid.exceptions import Forbidden"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from pyramid.httpexceptions import HTTPBadRequest"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from pytest import raises"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from webob.multidict import MultiDict"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "         request = DummyRequest()"
            },
            "8": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 433,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         request.params['apply'] = u''"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 435,
                "PatchRowcode": "+        request.params['csrf_token'] = request.session.get_csrf_token()"
            },
            "11": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "         share_node(root, request)"
            },
            "12": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "         assert (request.session.pop_flash('info') == [u'No changes were made.'])"
            },
            "13": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         assert list_groups('bob', root) == []"
            },
            "14": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "             set(list_groups('bob', root)) =="
            },
            "15": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "             {'role:owner', 'role:editor', 'role:special'}"
            },
            "16": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "             )"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+    def test_csrf(self, extra_principals, root, dummy_request):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+        \"\"\" Test if a CSRF token is present and checked on submission \"\"\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+        from kotti.views.users import share_node"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 469,
                "PatchRowcode": "+        result = share_node(root, dummy_request)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 470,
                "PatchRowcode": "+        assert 'csrf_token' in result"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+        dummy_request.params['apply'] = u''"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+        with raises(HTTPBadRequest):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+            share_node(root, dummy_request)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+        dummy_request.params['csrf_token'] = dummy_request.session.get_csrf_token()  # noqa"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        result = share_node(root, dummy_request)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+        assert result['csrf_token'] == dummy_request.session.get_csrf_token()"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function",
            "",
            "from kotti.testing import DummyRequest",
            "from pyramid.exceptions import Forbidden",
            "from pytest import raises",
            "from webob.multidict import MultiDict",
            "",
            "",
            "class TestAddableTypes:",
            "    def test_view_permitted_yes(self, config, root):",
            "        from kotti.resources import Document",
            "",
            "        config.testing_securitypolicy(permissive=True)",
            "        config.include('kotti.views.edit.content')",
            "        request = DummyRequest()",
            "        assert Document.type_info.addable(root, request) is True",
            "",
            "    def test_view_permitted_no(self, config, root):",
            "        from kotti.resources import Document",
            "",
            "        config.testing_securitypolicy(permissive=False)",
            "        config.include('kotti.views.edit.content')",
            "        request = DummyRequest()",
            "        assert Document.type_info.addable(root, request) is False",
            "",
            "    def test_addable_views_registered_to_some_context(self, config, root):",
            "",
            "        from kotti.resources import Document, File",
            "",
            "        _saved = Document.type_info.addable_to",
            "        Document.type_info.addable_to = ['File']",
            "",
            "        config.testing_securitypolicy(permissive=True)",
            "        config.add_view(",
            "            lambda context, request: {},",
            "            name=Document.type_info.add_view,",
            "            permission='add',",
            "            renderer='kotti:templates/edit/node.pt',",
            "            context=File,",
            "        )",
            "        request = DummyRequest()",
            "",
            "        assert Document.type_info.addable(Document(), request) is False",
            "        assert Document.type_info.addable(File(), request) is True",
            "",
            "        Document.type_info.addable_to = _saved",
            "",
            "",
            "class TestNodePaste:",
            "    def test_get_non_existing_paste_item(self, root):",
            "        from kotti.util import get_paste_items",
            "",
            "        request = DummyRequest()",
            "        request.session['kotti.paste'] = ([1701], 'copy')",
            "        item = get_paste_items(root, request)",
            "        assert item == []",
            "",
            "    def test_paste_non_existing_node(self, root):",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        request = DummyRequest()",
            "",
            "        for index, action in enumerate(['copy', 'cut']):",
            "            request.session['kotti.paste'] = ([1701], 'copy')",
            "            response = NodeActions(root, request).paste_nodes()",
            "            assert response.status == '302 Found'",
            "            assert len(request.session['_f_error']) == index + 1",
            "",
            "    def test_paste_without_edit_permission(self, config, root):",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        request = DummyRequest()",
            "        request.params['paste'] = u'on'",
            "        config.testing_securitypolicy(permissive=False)",
            "",
            "        # We need to have the 'edit' permission on the original object",
            "        # to be able to cut and paste:",
            "        request.session['kotti.paste'] = ([1], 'cut')",
            "        view = NodeActions(root, request)",
            "        with raises(Forbidden):",
            "            view.paste_nodes()",
            "",
            "        # We don't need 'edit' permission if we're just copying:",
            "        request.session['kotti.paste'] = ([1], 'copy')",
            "        response = NodeActions(root, request).paste_nodes()",
            "        assert response.status == '302 Found'",
            "",
            "",
            "class TestNodeRename:",
            "    def setUp(self):",
            "        from pyramid.threadlocal import get_current_registry",
            "        from kotti.url_normalizer import url_normalizer",
            "        r = get_current_registry()",
            "        settings = r.settings = {}",
            "        settings['kotti.url_normalizer'] = [url_normalizer]",
            "        settings['kotti.url_normalizer.map_non_ascii_characters'] = False",
            "",
            "    def test_rename_to_empty_name(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        child = root['child'] = Document(title=u\"Child\")",
            "        request = DummyRequest()",
            "        request.params['rename'] = u'on'",
            "        request.params['name'] = u''",
            "        request.params['title'] = u'foo'",
            "        NodeActions(child, request).rename_node()",
            "        assert (request.session.pop_flash('error') ==",
            "                [u'Name and title are required.'])",
            "",
            "    def test_multi_rename(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "        self.setUp()",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        request = DummyRequest()",
            "        request.POST = MultiDict()",
            "        id1 = str(root['child1'].id)",
            "        id2 = str(root['child2'].id)",
            "        request.POST.add('children-to-rename', id1)",
            "        request.POST.add('children-to-rename', id2)",
            "        request.POST.add(id1 + '-name', u'')",
            "        request.POST.add(id1 + '-title', u'Unhappy Child')",
            "        request.POST.add(id2 + '-name', u'happy-child')",
            "        request.POST.add(id2 + '-title', u'')",
            "        request.POST.add('rename_nodes', u'rename_nodes')",
            "        NodeActions(root, request).rename_nodes()",
            "        assert request.session.pop_flash('error') ==\\",
            "            [u'Name and title are required.']",
            "",
            "        request.POST.add(id1 + '-name', u'unhappy-child')",
            "        request.POST.add(id1 + '-title', u'Unhappy Child')",
            "        request.POST.add(id2 + '-name', u'happy-child')",
            "        request.POST.add(id2 + '-title', u'Happy Child')",
            "        request.POST.add('rename_nodes', u'rename_nodes')",
            "        NodeActions(root, request).rename_nodes()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'Your changes have been saved.']",
            "",
            "",
            "class TestNodeDelete:",
            "",
            "    def test_multi_delete(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.resources import File",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['file1'] = File(title=u\"File 1\")",
            "",
            "        request = DummyRequest()",
            "        request.POST = MultiDict()",
            "        id1 = str(root['child1'].id)",
            "        id2 = str(root['child2'].id)",
            "        id3 = str(root['file1'].id)",
            "        request.POST.add('delete_nodes', u'delete_nodes')",
            "        NodeActions(root, request).delete_nodes()",
            "        assert request.session.pop_flash('info') ==\\",
            "            [u'Nothing was deleted.']",
            "",
            "        request.POST.add('children-to-delete', id1)",
            "        request.POST.add('children-to-delete', id2)",
            "        request.POST.add('children-to-delete', id3)",
            "        NodeActions(root, request).delete_nodes()",
            "        assert request.session.pop_flash('success') == \\",
            "            [u'${title} was deleted.',",
            "             u'${title} was deleted.',",
            "             u'${title} was deleted.']",
            "",
            "",
            "class TestNodeMove:",
            "    def test_move_up(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        assert root['child1'].position < root['child2'].position",
            "",
            "        request = DummyRequest()",
            "        request.session['kotti.selected-children'] = [str(root['child2'].id)]",
            "        NodeActions(root, request).up()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} was moved.']",
            "        assert root['child1'].position > root['child2'].position",
            "",
            "    def test_move_down(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['child3'] = Document(title=u\"Child 3\")",
            "        assert root['child1'].position < root['child3'].position",
            "        assert root['child2'].position < root['child3'].position",
            "",
            "        request = DummyRequest()",
            "        ids = [str(root['child1'].id), str(root['child2'].id)]",
            "        request.session['kotti.selected-children'] = ids",
            "        NodeActions(root, request).down()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} was moved.', u'${title} was moved.']",
            "        assert root['child1'].position > root['child3'].position",
            "        assert root['child2'].position > root['child3'].position",
            "",
            "    def test_move_child_position_post(self, root, db_session):",
            "",
            "        import transaction",
            "",
            "        from kotti.resources import Document",
            "        from kotti.resources import get_root",
            "        from kotti.views.edit.actions import move_child_position",
            "",
            "        # Create some documents",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['child3'] = Document(title=u\"Child 3\")",
            "        root['child4'] = Document(title=u\"Child 4\")",
            "        root['child5'] = Document(title=u\"Child 5\")",
            "",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child1', u'child2', u'child3', u'child4', u'child5']",
            "",
            "        request = DummyRequest()",
            "",
            "        # Move down",
            "        request.POST = {'from': '0', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child2', u'child3', u'child4', u'child1', u'child5']",
            "",
            "        # Move up",
            "        request.POST = {'from': '4', 'to': '0'}",
            "        move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child5', u'child2', u'child3', u'child4', u'child1']",
            "",
            "        # Invalid param value",
            "        request.POST = {'from': 'a', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.POST = {'from': '0', 'to': '10'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.POST = {'from': '10', 'to': '0'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # Missing param",
            "        request.POST = {'from': 'a', }",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # we have to clean up, because we committed transactions",
            "        del root['child1']",
            "        del root['child2']",
            "        del root['child3']",
            "        del root['child4']",
            "        del root['child5']",
            "        transaction.commit()",
            "",
            "    def test_move_child_position_json(self, root, db_session):",
            "",
            "        import transaction",
            "",
            "        from kotti.resources import Document",
            "        from kotti.resources import get_root",
            "        from kotti.views.edit.actions import move_child_position",
            "",
            "        # Create some documents",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['child3'] = Document(title=u\"Child 3\")",
            "        root['child4'] = Document(title=u\"Child 4\")",
            "        root['child5'] = Document(title=u\"Child 5\")",
            "",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child1', u'child2', u'child3', u'child4', u'child5']",
            "",
            "        request = DummyRequest()",
            "",
            "        # Move down",
            "        request.json_body = {'from': '0', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child2', u'child3', u'child4', u'child1', u'child5']",
            "",
            "        # Move up",
            "        request.json_body = {'from': '4', 'to': '0'}",
            "        move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child5', u'child2', u'child3', u'child4', u'child1']",
            "",
            "        # Invalid param value",
            "        request.json_body = {'from': 'a', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.json_body = {'from': '0', 'to': '10'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.json_body = {'from': '10', 'to': '0'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # Missing param",
            "        request.json_body = {'from': 'a', }",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # we have to clean up, because we committed transactions",
            "        del root['child1']",
            "        del root['child2']",
            "        del root['child3']",
            "        del root['child4']",
            "        del root['child5']",
            "        transaction.commit()",
            "",
            "",
            "class TestNodeShowHide:",
            "    def test_show_hide(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        assert root['child1'].in_navigation is True",
            "",
            "        request = DummyRequest()",
            "        request.session['kotti.selected-children'] = [str(root['child1'].id)]",
            "        NodeActions(root, request).hide()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} is no longer visible in the navigation.']",
            "        assert root['child1'].in_navigation is False",
            "",
            "        request.session['kotti.selected-children'] = [str(root['child1'].id)]",
            "        NodeActions(root, request).show()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} is now visible in the navigation.']",
            "        assert root['child1'].in_navigation is True",
            "",
            "",
            "class TestNodeShare:",
            "    def test_roles(self, root):",
            "        from kotti.views.users import share_node",
            "        from kotti.security import SHARING_ROLES",
            "",
            "        # The 'share_node' view will return a list of available roles",
            "        # as defined in 'kotti.security.SHARING_ROLES'",
            "        request = DummyRequest()",
            "        assert (",
            "            [r.name for r in share_node(root, request)['available_roles']] ==",
            "            SHARING_ROLES)",
            "",
            "    def test_search(self, extra_principals, root):",
            "        from kotti.security import get_principals",
            "        from kotti.security import set_groups",
            "        from kotti.views.users import share_node",
            "",
            "        request = DummyRequest()",
            "        P = get_principals()",
            "",
            "        # Search for \"Bob\", which will return both the user and the",
            "        # group, both of which have no roles:",
            "        request.params['search'] = u''",
            "        request.params['query'] = u'Bob'",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 2",
            "        assert entries[0][0] == P['bob']",
            "        assert entries[0][1] == ([], [])",
            "        assert entries[1][0] == P['group:bobsgroup']",
            "        assert entries[1][1] == ([], [])",
            "",
            "        # We make Bob an Editor in this context, and Bob's Group",
            "        # becomes global Admin:",
            "        set_groups(u'bob', root, [u'role:editor'])",
            "        P[u'group:bobsgroup'].groups = [u'role:admin']",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 2",
            "        assert entries[0][0] == P['bob']",
            "        assert entries[0][1] == ([u'role:editor'], [])",
            "        assert entries[1][0] == P['group:bobsgroup']",
            "        assert entries[1][1] == ([u'role:admin'], [u'role:admin'])",
            "",
            "        # A search that doesn't return any items will still include",
            "        # entries with existing local roles:",
            "        request.params['query'] = u'Weeee'",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 1",
            "        assert entries[0][0] == P[u'bob']",
            "        assert entries[0][1] == ([u'role:editor'], [])",
            "        assert (request.session.pop_flash('info') ==",
            "                [u'No users or groups were found.'])",
            "",
            "        # It does not, however, include entries that have local group",
            "        # assignments only:",
            "        set_groups(u'frank', root, [u'group:franksgroup'])",
            "        request.params['query'] = u'Weeee'",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 1",
            "        assert entries[0][0] == P['bob']",
            "",
            "    def test_apply(self, extra_principals, root):",
            "        from kotti.security import list_groups",
            "        from kotti.security import set_groups",
            "        from kotti.views.users import share_node",
            "",
            "        request = DummyRequest()",
            "",
            "        request.params['apply'] = u''",
            "        share_node(root, request)",
            "        assert (request.session.pop_flash('info') == [u'No changes were made.'])",
            "        assert list_groups('bob', root) == []",
            "        set_groups('bob', root, ['role:special'])",
            "",
            "        request.params['role::bob::role:owner'] = u'1'",
            "        request.params['role::bob::role:editor'] = u'1'",
            "        request.params['orig-role::bob::role:owner'] = u''",
            "        request.params['orig-role::bob::role:editor'] = u''",
            "",
            "        share_node(root, request)",
            "        assert (request.session.pop_flash('success') ==",
            "                [u'Your changes have been saved.'])",
            "        assert (",
            "            set(list_groups('bob', root)) ==",
            "            {'role:owner', 'role:editor', 'role:special'}",
            "            )",
            "",
            "        # We cannot set a role that's not displayed, even if we forged",
            "        # the request:",
            "        request.params['role::bob::role:admin'] = u'1'",
            "        request.params['orig-role::bob::role:admin'] = u''",
            "        with raises(Forbidden):",
            "            share_node(root, request)",
            "        assert (",
            "            set(list_groups('bob', root)) ==",
            "            {'role:owner', 'role:editor', 'role:special'}",
            "            )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from __future__ import absolute_import, division, print_function",
            "",
            "from kotti.testing import DummyRequest",
            "from pyramid.exceptions import Forbidden",
            "from pyramid.httpexceptions import HTTPBadRequest",
            "from pytest import raises",
            "from webob.multidict import MultiDict",
            "",
            "",
            "class TestAddableTypes:",
            "    def test_view_permitted_yes(self, config, root):",
            "        from kotti.resources import Document",
            "",
            "        config.testing_securitypolicy(permissive=True)",
            "        config.include('kotti.views.edit.content')",
            "        request = DummyRequest()",
            "        assert Document.type_info.addable(root, request) is True",
            "",
            "    def test_view_permitted_no(self, config, root):",
            "        from kotti.resources import Document",
            "",
            "        config.testing_securitypolicy(permissive=False)",
            "        config.include('kotti.views.edit.content')",
            "        request = DummyRequest()",
            "        assert Document.type_info.addable(root, request) is False",
            "",
            "    def test_addable_views_registered_to_some_context(self, config, root):",
            "",
            "        from kotti.resources import Document, File",
            "",
            "        _saved = Document.type_info.addable_to",
            "        Document.type_info.addable_to = ['File']",
            "",
            "        config.testing_securitypolicy(permissive=True)",
            "        config.add_view(",
            "            lambda context, request: {},",
            "            name=Document.type_info.add_view,",
            "            permission='add',",
            "            renderer='kotti:templates/edit/node.pt',",
            "            context=File,",
            "        )",
            "        request = DummyRequest()",
            "",
            "        assert Document.type_info.addable(Document(), request) is False",
            "        assert Document.type_info.addable(File(), request) is True",
            "",
            "        Document.type_info.addable_to = _saved",
            "",
            "",
            "class TestNodePaste:",
            "    def test_get_non_existing_paste_item(self, root):",
            "        from kotti.util import get_paste_items",
            "",
            "        request = DummyRequest()",
            "        request.session['kotti.paste'] = ([1701], 'copy')",
            "        item = get_paste_items(root, request)",
            "        assert item == []",
            "",
            "    def test_paste_non_existing_node(self, root):",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        request = DummyRequest()",
            "",
            "        for index, action in enumerate(['copy', 'cut']):",
            "            request.session['kotti.paste'] = ([1701], 'copy')",
            "            response = NodeActions(root, request).paste_nodes()",
            "            assert response.status == '302 Found'",
            "            assert len(request.session['_f_error']) == index + 1",
            "",
            "    def test_paste_without_edit_permission(self, config, root):",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        request = DummyRequest()",
            "        request.params['paste'] = u'on'",
            "        config.testing_securitypolicy(permissive=False)",
            "",
            "        # We need to have the 'edit' permission on the original object",
            "        # to be able to cut and paste:",
            "        request.session['kotti.paste'] = ([1], 'cut')",
            "        view = NodeActions(root, request)",
            "        with raises(Forbidden):",
            "            view.paste_nodes()",
            "",
            "        # We don't need 'edit' permission if we're just copying:",
            "        request.session['kotti.paste'] = ([1], 'copy')",
            "        response = NodeActions(root, request).paste_nodes()",
            "        assert response.status == '302 Found'",
            "",
            "",
            "class TestNodeRename:",
            "    def setUp(self):",
            "        from pyramid.threadlocal import get_current_registry",
            "        from kotti.url_normalizer import url_normalizer",
            "        r = get_current_registry()",
            "        settings = r.settings = {}",
            "        settings['kotti.url_normalizer'] = [url_normalizer]",
            "        settings['kotti.url_normalizer.map_non_ascii_characters'] = False",
            "",
            "    def test_rename_to_empty_name(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        child = root['child'] = Document(title=u\"Child\")",
            "        request = DummyRequest()",
            "        request.params['rename'] = u'on'",
            "        request.params['name'] = u''",
            "        request.params['title'] = u'foo'",
            "        NodeActions(child, request).rename_node()",
            "        assert (request.session.pop_flash('error') ==",
            "                [u'Name and title are required.'])",
            "",
            "    def test_multi_rename(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "        self.setUp()",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        request = DummyRequest()",
            "        request.POST = MultiDict()",
            "        id1 = str(root['child1'].id)",
            "        id2 = str(root['child2'].id)",
            "        request.POST.add('children-to-rename', id1)",
            "        request.POST.add('children-to-rename', id2)",
            "        request.POST.add(id1 + '-name', u'')",
            "        request.POST.add(id1 + '-title', u'Unhappy Child')",
            "        request.POST.add(id2 + '-name', u'happy-child')",
            "        request.POST.add(id2 + '-title', u'')",
            "        request.POST.add('rename_nodes', u'rename_nodes')",
            "        NodeActions(root, request).rename_nodes()",
            "        assert request.session.pop_flash('error') ==\\",
            "            [u'Name and title are required.']",
            "",
            "        request.POST.add(id1 + '-name', u'unhappy-child')",
            "        request.POST.add(id1 + '-title', u'Unhappy Child')",
            "        request.POST.add(id2 + '-name', u'happy-child')",
            "        request.POST.add(id2 + '-title', u'Happy Child')",
            "        request.POST.add('rename_nodes', u'rename_nodes')",
            "        NodeActions(root, request).rename_nodes()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'Your changes have been saved.']",
            "",
            "",
            "class TestNodeDelete:",
            "",
            "    def test_multi_delete(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.resources import File",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['file1'] = File(title=u\"File 1\")",
            "",
            "        request = DummyRequest()",
            "        request.POST = MultiDict()",
            "        id1 = str(root['child1'].id)",
            "        id2 = str(root['child2'].id)",
            "        id3 = str(root['file1'].id)",
            "        request.POST.add('delete_nodes', u'delete_nodes')",
            "        NodeActions(root, request).delete_nodes()",
            "        assert request.session.pop_flash('info') ==\\",
            "            [u'Nothing was deleted.']",
            "",
            "        request.POST.add('children-to-delete', id1)",
            "        request.POST.add('children-to-delete', id2)",
            "        request.POST.add('children-to-delete', id3)",
            "        NodeActions(root, request).delete_nodes()",
            "        assert request.session.pop_flash('success') == \\",
            "            [u'${title} was deleted.',",
            "             u'${title} was deleted.',",
            "             u'${title} was deleted.']",
            "",
            "",
            "class TestNodeMove:",
            "    def test_move_up(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        assert root['child1'].position < root['child2'].position",
            "",
            "        request = DummyRequest()",
            "        request.session['kotti.selected-children'] = [str(root['child2'].id)]",
            "        NodeActions(root, request).up()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} was moved.']",
            "        assert root['child1'].position > root['child2'].position",
            "",
            "    def test_move_down(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['child3'] = Document(title=u\"Child 3\")",
            "        assert root['child1'].position < root['child3'].position",
            "        assert root['child2'].position < root['child3'].position",
            "",
            "        request = DummyRequest()",
            "        ids = [str(root['child1'].id), str(root['child2'].id)]",
            "        request.session['kotti.selected-children'] = ids",
            "        NodeActions(root, request).down()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} was moved.', u'${title} was moved.']",
            "        assert root['child1'].position > root['child3'].position",
            "        assert root['child2'].position > root['child3'].position",
            "",
            "    def test_move_child_position_post(self, root, db_session):",
            "",
            "        import transaction",
            "",
            "        from kotti.resources import Document",
            "        from kotti.resources import get_root",
            "        from kotti.views.edit.actions import move_child_position",
            "",
            "        # Create some documents",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['child3'] = Document(title=u\"Child 3\")",
            "        root['child4'] = Document(title=u\"Child 4\")",
            "        root['child5'] = Document(title=u\"Child 5\")",
            "",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child1', u'child2', u'child3', u'child4', u'child5']",
            "",
            "        request = DummyRequest()",
            "",
            "        # Move down",
            "        request.POST = {'from': '0', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child2', u'child3', u'child4', u'child1', u'child5']",
            "",
            "        # Move up",
            "        request.POST = {'from': '4', 'to': '0'}",
            "        move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child5', u'child2', u'child3', u'child4', u'child1']",
            "",
            "        # Invalid param value",
            "        request.POST = {'from': 'a', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.POST = {'from': '0', 'to': '10'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.POST = {'from': '10', 'to': '0'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # Missing param",
            "        request.POST = {'from': 'a', }",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # we have to clean up, because we committed transactions",
            "        del root['child1']",
            "        del root['child2']",
            "        del root['child3']",
            "        del root['child4']",
            "        del root['child5']",
            "        transaction.commit()",
            "",
            "    def test_move_child_position_json(self, root, db_session):",
            "",
            "        import transaction",
            "",
            "        from kotti.resources import Document",
            "        from kotti.resources import get_root",
            "        from kotti.views.edit.actions import move_child_position",
            "",
            "        # Create some documents",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        root['child2'] = Document(title=u\"Child 2\")",
            "        root['child3'] = Document(title=u\"Child 3\")",
            "        root['child4'] = Document(title=u\"Child 4\")",
            "        root['child5'] = Document(title=u\"Child 5\")",
            "",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child1', u'child2', u'child3', u'child4', u'child5']",
            "",
            "        request = DummyRequest()",
            "",
            "        # Move down",
            "        request.json_body = {'from': '0', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child2', u'child3', u'child4', u'child1', u'child5']",
            "",
            "        # Move up",
            "        request.json_body = {'from': '4', 'to': '0'}",
            "        move_child_position(root, request)",
            "        transaction.commit()",
            "        root = get_root()",
            "        assert result['result'] == 'success'",
            "        assert [c.position for c in root._children] == [0, 1, 2, 3, 4]",
            "        assert [c.name for c in root._children] == [",
            "            u'child5', u'child2', u'child3', u'child4', u'child1']",
            "",
            "        # Invalid param value",
            "        request.json_body = {'from': 'a', 'to': '3'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.json_body = {'from': '0', 'to': '10'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        request.json_body = {'from': '10', 'to': '0'}",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # Missing param",
            "        request.json_body = {'from': 'a', }",
            "        result = move_child_position(root, request)",
            "        assert result['result'] == 'error'",
            "",
            "        # we have to clean up, because we committed transactions",
            "        del root['child1']",
            "        del root['child2']",
            "        del root['child3']",
            "        del root['child4']",
            "        del root['child5']",
            "        transaction.commit()",
            "",
            "",
            "class TestNodeShowHide:",
            "    def test_show_hide(self, root):",
            "        from kotti.resources import Document",
            "        from kotti.views.edit.actions import NodeActions",
            "",
            "        root['child1'] = Document(title=u\"Child 1\")",
            "        assert root['child1'].in_navigation is True",
            "",
            "        request = DummyRequest()",
            "        request.session['kotti.selected-children'] = [str(root['child1'].id)]",
            "        NodeActions(root, request).hide()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} is no longer visible in the navigation.']",
            "        assert root['child1'].in_navigation is False",
            "",
            "        request.session['kotti.selected-children'] = [str(root['child1'].id)]",
            "        NodeActions(root, request).show()",
            "        assert request.session.pop_flash('success') ==\\",
            "            [u'${title} is now visible in the navigation.']",
            "        assert root['child1'].in_navigation is True",
            "",
            "",
            "class TestNodeShare:",
            "    def test_roles(self, root):",
            "        from kotti.views.users import share_node",
            "        from kotti.security import SHARING_ROLES",
            "",
            "        # The 'share_node' view will return a list of available roles",
            "        # as defined in 'kotti.security.SHARING_ROLES'",
            "        request = DummyRequest()",
            "        assert (",
            "            [r.name for r in share_node(root, request)['available_roles']] ==",
            "            SHARING_ROLES)",
            "",
            "    def test_search(self, extra_principals, root):",
            "        from kotti.security import get_principals",
            "        from kotti.security import set_groups",
            "        from kotti.views.users import share_node",
            "",
            "        request = DummyRequest()",
            "        P = get_principals()",
            "",
            "        # Search for \"Bob\", which will return both the user and the",
            "        # group, both of which have no roles:",
            "        request.params['search'] = u''",
            "        request.params['query'] = u'Bob'",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 2",
            "        assert entries[0][0] == P['bob']",
            "        assert entries[0][1] == ([], [])",
            "        assert entries[1][0] == P['group:bobsgroup']",
            "        assert entries[1][1] == ([], [])",
            "",
            "        # We make Bob an Editor in this context, and Bob's Group",
            "        # becomes global Admin:",
            "        set_groups(u'bob', root, [u'role:editor'])",
            "        P[u'group:bobsgroup'].groups = [u'role:admin']",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 2",
            "        assert entries[0][0] == P['bob']",
            "        assert entries[0][1] == ([u'role:editor'], [])",
            "        assert entries[1][0] == P['group:bobsgroup']",
            "        assert entries[1][1] == ([u'role:admin'], [u'role:admin'])",
            "",
            "        # A search that doesn't return any items will still include",
            "        # entries with existing local roles:",
            "        request.params['query'] = u'Weeee'",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 1",
            "        assert entries[0][0] == P[u'bob']",
            "        assert entries[0][1] == ([u'role:editor'], [])",
            "        assert (request.session.pop_flash('info') ==",
            "                [u'No users or groups were found.'])",
            "",
            "        # It does not, however, include entries that have local group",
            "        # assignments only:",
            "        set_groups(u'frank', root, [u'group:franksgroup'])",
            "        request.params['query'] = u'Weeee'",
            "        entries = share_node(root, request)['entries']",
            "        assert len(entries) == 1",
            "        assert entries[0][0] == P['bob']",
            "",
            "    def test_apply(self, extra_principals, root):",
            "        from kotti.security import list_groups",
            "        from kotti.security import set_groups",
            "        from kotti.views.users import share_node",
            "",
            "        request = DummyRequest()",
            "",
            "        request.params['apply'] = u''",
            "        request.params['csrf_token'] = request.session.get_csrf_token()",
            "        share_node(root, request)",
            "        assert (request.session.pop_flash('info') == [u'No changes were made.'])",
            "        assert list_groups('bob', root) == []",
            "        set_groups('bob', root, ['role:special'])",
            "",
            "        request.params['role::bob::role:owner'] = u'1'",
            "        request.params['role::bob::role:editor'] = u'1'",
            "        request.params['orig-role::bob::role:owner'] = u''",
            "        request.params['orig-role::bob::role:editor'] = u''",
            "",
            "        share_node(root, request)",
            "        assert (request.session.pop_flash('success') ==",
            "                [u'Your changes have been saved.'])",
            "        assert (",
            "            set(list_groups('bob', root)) ==",
            "            {'role:owner', 'role:editor', 'role:special'}",
            "            )",
            "",
            "        # We cannot set a role that's not displayed, even if we forged",
            "        # the request:",
            "        request.params['role::bob::role:admin'] = u'1'",
            "        request.params['orig-role::bob::role:admin'] = u''",
            "        with raises(Forbidden):",
            "            share_node(root, request)",
            "        assert (",
            "            set(list_groups('bob', root)) ==",
            "            {'role:owner', 'role:editor', 'role:special'}",
            "            )",
            "",
            "    def test_csrf(self, extra_principals, root, dummy_request):",
            "        \"\"\" Test if a CSRF token is present and checked on submission \"\"\"",
            "        from kotti.views.users import share_node",
            "",
            "        result = share_node(root, dummy_request)",
            "        assert 'csrf_token' in result",
            "",
            "        dummy_request.params['apply'] = u''",
            "",
            "        with raises(HTTPBadRequest):",
            "            share_node(root, dummy_request)",
            "",
            "        dummy_request.params['csrf_token'] = dummy_request.session.get_csrf_token()  # noqa",
            "        result = share_node(root, dummy_request)",
            "        assert result['csrf_token'] == dummy_request.session.get_csrf_token()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "kotti.tests.test_node_views.TestNodeShare.self",
            "src.pyload.webui.app.blueprints.json_blueprint"
        ]
    },
    "kotti/views/users.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from deform.widget import CheckedPasswordWidget"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from deform.widget import SequenceWidget"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from pyramid.exceptions import Forbidden"
            },
            "3": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pyramid.httpexceptions import HTTPFound"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from pyramid.httpexceptions import HTTPFound, HTTPBadRequest"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from pyramid.view import view_config"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from pyramid_deform import FormView"
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from six import string_types"
            },
            "8": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "              renderer='kotti:templates/edit/share.pt')"
            },
            "9": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " def share_node(context, request):"
            },
            "10": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "     # Allow roles_form_handler to do processing on 'apply':"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    if 'apply' in request.POST:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        if request.params.get('csrf_token') != request.session.get_csrf_token():"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            raise HTTPBadRequest('Invalid CSRF token')"
            },
            "14": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     changed = roles_form_handler("
            },
            "15": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         context, request, SHARING_ROLES, list_groups_raw)"
            },
            "16": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     if changed:"
            },
            "17": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     return {"
            },
            "18": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         'entries': entries,"
            },
            "19": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         'available_roles': available_roles,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        'csrf_token': request.session.get_csrf_token()"
            },
            "21": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         }"
            },
            "22": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "User management screens",
            "\"\"\"",
            "from __future__ import absolute_import, division, print_function",
            "",
            "import re",
            "from urllib import urlencode",
            "",
            "import colander",
            "from deform import Button",
            "from deform.widget import AutocompleteInputWidget",
            "from deform.widget import CheckboxChoiceWidget",
            "from deform.widget import CheckedPasswordWidget",
            "from deform.widget import SequenceWidget",
            "from pyramid.exceptions import Forbidden",
            "from pyramid.httpexceptions import HTTPFound",
            "from pyramid.view import view_config",
            "from pyramid_deform import FormView",
            "from six import string_types",
            "",
            "from kotti.events import UserDeleted",
            "from kotti.events import notify",
            "from kotti.message import email_set_password",
            "from kotti.resources import get_root",
            "from kotti.security import ROLES",
            "from kotti.security import SHARING_ROLES",
            "from kotti.security import USER_MANAGEMENT_ROLES",
            "from kotti.security import get_principals",
            "from kotti.security import list_groups_ext",
            "from kotti.security import list_groups_raw",
            "from kotti.security import map_principals_with_local_roles",
            "from kotti.security import set_groups",
            "from kotti.util import _",
            "from kotti.views.form import AddFormView",
            "from kotti.views.form import EditFormView",
            "from kotti.views.site_setup import CONTROL_PANEL_LINKS",
            "from kotti.views.util import template_api",
            "",
            "",
            "def roles_form_handler(context, request, available_role_names, groups_lister):",
            "    changed = []",
            "",
            "    if 'apply' in request.POST:",
            "        p_to_r = {}",
            "        for name in request.params:",
            "            if name.startswith('orig-role::'):",
            "                # orig-role::* is hidden checkboxes that allow us to",
            "                # see what checkboxes were in the form originally",
            "                token, principal_name, role_name = unicode(name).split(u'::')",
            "                if role_name not in available_role_names:",
            "                    raise Forbidden()",
            "                new_value = bool(request.params.get(",
            "                    u'role::{0}::{1}'.format(principal_name, role_name)))",
            "                if principal_name not in p_to_r:",
            "                    p_to_r[principal_name] = set()",
            "                if new_value:",
            "                    p_to_r[principal_name].add(role_name)",
            "",
            "        for principal_name, new_role_names in p_to_r.items():",
            "            # We have to be careful with roles that aren't mutable here:",
            "            orig_role_names = set(",
            "                groups_lister(principal_name, context))",
            "            orig_sharing_role_names = set(",
            "                r for r in orig_role_names if r in available_role_names)",
            "            if new_role_names != orig_sharing_role_names:",
            "                final_role_names = orig_role_names - set(available_role_names)",
            "                final_role_names |= new_role_names",
            "                changed.append((principal_name, context, final_role_names))",
            "",
            "        if changed:",
            "            request.session.flash(",
            "                _(u'Your changes have been saved.'), 'success')",
            "        else:",
            "            request.session.flash(_(u'No changes were made.'), 'info')",
            "",
            "    return changed",
            "",
            "",
            "def search_principals(request, context=None, ignore=None, extra=()):",
            "    flash = request.session.flash",
            "    principals = get_principals()",
            "",
            "    if ignore is None:",
            "        ignore = set()",
            "",
            "    entries = []",
            "    for principal_name in extra:",
            "        if principal_name not in ignore:",
            "            p = principals[principal_name]",
            "            entries.append((p, list_groups_ext(principal_name, context)))",
            "            ignore.add(principal_name)",
            "",
            "    postdata = request.POST",
            "    if request.method == 'POST' and request.is_xhr:",
            "        postdata = request.json",
            "    if 'search' in postdata:",
            "        if request.is_xhr:",
            "            query = u'*{0}*'.format(postdata['query'])",
            "        else:",
            "            query = u'*{0}*'.format(request.params['query'])",
            "        found = False",
            "        for p in principals.search(name=query, title=query, email=query):",
            "            found = True",
            "            if p.name not in ignore:",
            "                entries.append((p, list_groups_ext(p.name, context)))",
            "        if not found:",
            "            flash(_(u'No users or groups were found.'), 'info')",
            "",
            "    return entries",
            "",
            "",
            "@view_config(name='share', permission='manage',",
            "             renderer='kotti:templates/edit/share.pt')",
            "def share_node(context, request):",
            "    # Allow roles_form_handler to do processing on 'apply':",
            "    changed = roles_form_handler(",
            "        context, request, SHARING_ROLES, list_groups_raw)",
            "    if changed:",
            "        for (principal_name, context, groups) in changed:",
            "            set_groups(principal_name, context, groups)",
            "        return HTTPFound(location=request.url)",
            "",
            "    existing = map_principals_with_local_roles(context)",
            "",
            "    def with_roles(entry):",
            "        all_groups = entry[1][0]",
            "        return [g for g in all_groups if g.startswith('role:')]",
            "",
            "    existing = filter(with_roles, existing)",
            "    seen = set([entry[0].name for entry in existing])",
            "",
            "    # Allow search to take place and add some entries:",
            "    entries = existing + search_principals(request, context, ignore=seen)",
            "    available_roles = [ROLES[role_name] for role_name in SHARING_ROLES]",
            "",
            "    return {",
            "        'entries': entries,",
            "        'available_roles': available_roles,",
            "        }",
            "",
            "",
            "def name_pattern_validator(node, value):",
            "    \"\"\"",
            "        >>> name_pattern_validator(None, u'bob')",
            "        >>> name_pattern_validator(None, u'b ob')",
            "        Traceback (most recent call last):",
            "        Invalid: <unprintable Invalid object>",
            "        >>> name_pattern_validator(None, u'b:ob')",
            "        Traceback (most recent call last):",
            "        Invalid: <unprintable Invalid object>",
            "    \"\"\"",
            "    valid_pattern = re.compile(r\"^[a-zA-Z0-9_\\-\\.]+$\")",
            "    if not valid_pattern.match(value):",
            "        raise colander.Invalid(node, _(u\"Invalid value\"))",
            "",
            "",
            "def name_new_validator(node, value):",
            "    if get_principals().get(value.lower()) is not None:",
            "        raise colander.Invalid(",
            "            node, _(u\"A user with that name already exists.\"))",
            "",
            "",
            "@colander.deferred",
            "def deferred_email_validator(node, kw):",
            "    def raise_invalid_email(node, value):",
            "        raise colander.Invalid(",
            "            node, _(u\"A user with that email already exists.\"))",
            "    request = kw['request']",
            "    if request.POST:",
            "        email = request.params.get('email')",
            "        name = request.params.get('name')",
            "        if not name and request.user:",
            "            name = request.user.name",
            "        if email and name:",
            "            principals = get_principals()",
            "            if any(p for p in principals.search(email=email)",
            "                   if p.name.lower() != name.lower()):",
            "                # verify duplicated email except myself when update info",
            "                return raise_invalid_email",
            "",
            "",
            "def roleset_validator(node, value):",
            "    oneof = colander.OneOf(USER_MANAGEMENT_ROLES)",
            "    [oneof(node, item) for item in value]",
            "",
            "",
            "def group_validator(node, value):",
            "    principals = get_principals()",
            "    if principals.get('group:' + value) is None:",
            "        raise colander.Invalid(node, _(u\"No such group: ${group}\",",
            "                                       mapping=dict(group=value)))",
            "",
            "",
            "class Groups(colander.SequenceSchema):",
            "    group = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Group'),",
            "        validator=group_validator,",
            "        missing=None,",
            "        widget=AutocompleteInputWidget(),",
            "        )",
            "",
            "",
            "class PrincipalBasic(colander.MappingSchema):",
            "    title = colander.SchemaNode(colander.String(), title=_(u'Title'))",
            "    email = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Email'),",
            "        validator=deferred_email_validator,",
            "    )",
            "",
            "",
            "class PrincipalFull(PrincipalBasic):",
            "    name = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Name'),",
            "        validator=colander.All(name_pattern_validator, name_new_validator),",
            "        )",
            "    password = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Password'),",
            "        validator=colander.Length(min=5),",
            "        missing=None,",
            "        widget=CheckedPasswordWidget(),",
            "        )",
            "    active = colander.SchemaNode(",
            "        colander.Boolean(),",
            "        title=_(u'Active'),",
            "        description=_(u\"Untick this to deactivate the account.\"),",
            "        )",
            "    roles = colander.SchemaNode(",
            "        colander.Set(),",
            "        validator=roleset_validator,",
            "        missing=[],",
            "        title=_(u\"Global roles\"),",
            "        widget=CheckboxChoiceWidget(),",
            "        )",
            "    groups = Groups(",
            "        title=_(u'Groups'),",
            "        missing=[],",
            "        # XXX min_len doesn't really do what we want here.  We'd like",
            "        # the close buttons to appear nevertheless (maybe the now",
            "        # deprecated render_initial_item did exactly that).",
            "        widget=SequenceWidget(min_len=1),",
            "        )",
            "",
            "",
            "def principal_schema(base=PrincipalFull()):",
            "    principals = get_principals()",
            "    schema = base.clone()",
            "    has_groups = True",
            "    try:",
            "        schema['groups']",
            "    except KeyError:",
            "        has_groups = False",
            "    if has_groups:",
            "        all_groups = []",
            "        for p in principals.search(name=u'group:*'):",
            "            value = p.name.split(u'group:')[1]",
            "            label = u\"{0}, {1}\".format(p.title, value)",
            "            all_groups.append(dict(value=value, label=label))",
            "        schema['groups']['group'].widget.values = all_groups",
            "        schema['roles'].widget.values = [",
            "            (n, ROLES[n].title) for n in USER_MANAGEMENT_ROLES]",
            "    return schema",
            "",
            "",
            "def user_schema(base=PrincipalFull()):",
            "    schema = principal_schema(base)",
            "    has_password = True",
            "    try:",
            "        schema['password']",
            "    except KeyError:",
            "        has_password = False",
            "    if has_password:",
            "        schema['password'].description = _(",
            "            u\"Leave this empty and tick the 'Send password registration' \"",
            "            u\"box below to have the user set their own password.\")",
            "    schema['title'].title = _(u\"Full name\")",
            "    return schema",
            "",
            "",
            "def group_schema(base=PrincipalFull()):",
            "    schema = principal_schema(base)",
            "    del schema['password']",
            "    schema['email'].missing = None",
            "    return schema",
            "",
            "",
            "def _massage_groups_in(appstruct):",
            "    \"\"\"Manipulate appstruct received from form so that it's suitable",
            "    for saving on the Principal.",
            "",
            "    What we do for groups is we prefix them with 'group:'.  And the",
            "    'roles' in the form are really groups too, so we add to 'groups'.",
            "",
            "    The value in the form is 'name', not 'group:name', so we'll",
            "    need to append that before we save.",
            "    \"\"\"",
            "    groups = appstruct.get('groups', [])",
            "    all_groups = list(appstruct.get('roles', [])) + [",
            "        u'group:{0}'.format(g) for g in groups if g]",
            "    if 'roles' in appstruct:",
            "        del appstruct['roles']",
            "    appstruct['groups'] = all_groups",
            "",
            "",
            "def _massage_groups_out(appstruct):",
            "    \"\"\"Opposite of '_massage_groups_in': remove 'groups:' prefix and",
            "    split 'groups' into 'roles' and 'groups'.",
            "    \"\"\"",
            "    d = appstruct",
            "    groups = [g.split(u'group:')[1] for g in d.get('groups', u'')",
            "              if g and g.startswith(u'group:')]",
            "    roles = [r for r in d.get('groups', u'') if r and r.startswith(u'role:')]",
            "    d['groups'] = groups",
            "    d['roles'] = roles",
            "    return d",
            "",
            "",
            "class UserAddFormView(AddFormView):",
            "    item_type = _(u'User')",
            "    form_options = (('formid', 'deform_user_add'), )",
            "    buttons = (Button('add_user', _(u'Add User')),",
            "               Button('cancel', _(u'Cancel')))",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = user_schema()",
            "        del schema['active']",
            "        schema.add(colander.SchemaNode(",
            "            colander.Boolean(),",
            "            name=u'send_email',",
            "            title=_(u'Send password registration link.'),",
            "            default=True,",
            "            ))",
            "        return schema",
            "",
            "    def add_user_success(self, appstruct):",
            "        appstruct.pop('csrf_token', None)",
            "        _massage_groups_in(appstruct)",
            "        name = appstruct['name'] = appstruct['name'].lower()",
            "        appstruct['email'] = appstruct['email'] and appstruct['email'].lower()",
            "        send_email = appstruct.pop('send_email', False)",
            "        get_principals()[name] = appstruct",
            "        if send_email:",
            "            email_set_password(get_principals()[name], self.request)",
            "        self.request.session.flash(",
            "            _(u'${title} was added.',",
            "              mapping=dict(title=appstruct['title'])), 'success')",
            "        location = self.request.url.split('?')[0] + '?' + urlencode(",
            "            {'extra': name})",
            "        return HTTPFound(location=location)",
            "",
            "",
            "class GroupAddFormView(UserAddFormView):",
            "    item_type = _(u\"Group\")",
            "    form_options = (('formid', 'deform_group_add'), )",
            "    buttons = (Button('add_group', _(u'Add Group')),",
            "               Button('cancel', _(u'Cancel')))",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = group_schema()",
            "        del schema['active']",
            "        return schema",
            "",
            "    def add_group_success(self, appstruct):",
            "        appstruct['name'] = u'group:{0}'.format(appstruct['name'].lower())",
            "        return self.add_user_success(appstruct)",
            "",
            "",
            "@view_config(name='setup-users', permission='admin',",
            "             root_only=True,",
            "             renderer='kotti:templates/site-setup/users.pt')",
            "class UsersManage(FormView):",
            "",
            "    UserAddFormView = UserAddFormView",
            "    GroupAddFormView = GroupAddFormView",
            "",
            "    def __init__(self, context, request):",
            "        super(UsersManage, self).__init__(request)",
            "        self.context = context",
            "",
            "    def __call__(self):",
            "        api = template_api(self.context, self.request,",
            "                           cp_links=CONTROL_PANEL_LINKS)",
            "",
            "        api.page_title = _(u\"User Management\")",
            "",
            "        principals = get_principals()",
            "",
            "        def groups_lister(principal_name, context):",
            "            return principals[principal_name].groups",
            "",
            "        # Handling the user/roles matrix:",
            "        changed = roles_form_handler(",
            "            self.context, self.request, USER_MANAGEMENT_ROLES, groups_lister)",
            "        if changed:",
            "            changed_names = []",
            "            for (principal_name, context, groups) in changed:",
            "                principal = principals[principal_name]",
            "                principal.groups = list(groups)",
            "                changed_names.append(principal_name)",
            "            location = self.request.url.split('?')[0] + '?' + urlencode(",
            "                {'extra': ','.join(changed_names)})",
            "            return HTTPFound(location=location)",
            "",
            "        extra = self.request.params.get('extra') or ()",
            "        if isinstance(extra, string_types):",
            "            extra = extra.split(',')",
            "        search_entries = search_principals(self.request, extra=extra)",
            "        available_roles = [ROLES[role_name]",
            "                           for role_name in USER_MANAGEMENT_ROLES]",
            "",
            "        # Add forms:",
            "        user_addform = self.UserAddFormView(self.context, self.request)()",
            "        if self.request.is_response(user_addform):",
            "            return user_addform",
            "",
            "        group_addform = self.GroupAddFormView(self.context, self.request)()",
            "        if self.request.is_response(group_addform):",
            "            return group_addform",
            "",
            "        if self.request.params.get('add_user'):",
            "            active_tab = 'add_user'",
            "        elif self.request.params.get('add_group'):",
            "            active_tab = 'add_group'",
            "        else:",
            "            active_tab = 'search'",
            "        return {",
            "            'api': api,",
            "            'entries': search_entries,",
            "            'available_roles': available_roles,",
            "            'user_addform': user_addform['form'],",
            "            'group_addform': group_addform['form'],",
            "            'active_tab': active_tab,",
            "        }",
            "",
            "",
            "class UserEditFormView(EditFormView):",
            "    @property",
            "    def success_url(self):",
            "        return self.request.url",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        return user_schema(PrincipalBasic())",
            "",
            "",
            "class UserManageFormView(UserEditFormView):",
            "",
            "    buttons = (Button('save', _(u'Save')),",
            "               Button('cancel', _(u'Cancel')),",
            "               Button('delete', _(u'Delete'), css_class='btn btn-danger'))",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = user_schema()",
            "        del schema['name']",
            "        return schema",
            "",
            "    def before(self, form):",
            "        context = self.context.__dict__.copy()",
            "        context['password'] = u''",
            "        form.appstruct = _massage_groups_out(context)",
            "",
            "    def save_success(self, appstruct):",
            "        if appstruct.get('password'):",
            "            hashed = get_principals().hash_password(appstruct['password'])",
            "            appstruct['password'] = hashed",
            "        else:",
            "            appstruct.pop('password', None)",
            "        _massage_groups_in(appstruct)",
            "        return super(UserManageFormView, self).save_success(appstruct)",
            "",
            "    def cancel_success(self, appstruct):",
            "        self.request.session.flash(_(u'No changes were made.'), 'info')",
            "        location = u'{0}/@@setup-users'.format(self.request.application_url)",
            "        return HTTPFound(location=location)",
            "    cancel_failure = cancel_success",
            "",
            "    def delete_success(self, appstruct):",
            "        location = u'{0}/@@delete-user?name={1}'.format(",
            "            self.request.application_url, self.request.params['name'])",
            "        return HTTPFound(location=location)",
            "",
            "",
            "class GroupManageFormView(UserManageFormView):",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = group_schema()",
            "        del schema['name']",
            "        del schema['active']",
            "        return schema",
            "",
            "",
            "@view_config(name='setup-user', permission='admin',",
            "             root_only=True,",
            "             renderer='kotti:templates/site-setup/user.pt')",
            "class UserManage(FormView):",
            "",
            "    GroupManageFormView = GroupManageFormView",
            "    UserManageFormView = UserManageFormView",
            "",
            "    def __init__(self, context, request):",
            "        super(UserManage, self).__init__(request)",
            "        self.context = context",
            "",
            "    def __call__(self):",
            "        user_or_group = self.request.params['name']",
            "        principal = get_principals()[user_or_group]",
            "",
            "        is_group = user_or_group.startswith(\"group:\")",
            "        principal_type = _(u\"Group\") if is_group else _(u\"User\")",
            "",
            "        api = template_api(",
            "            self.context, self.request,",
            "            page_title=_(u\"Edit ${principal_type} ${title}\",",
            "                         mapping=dict(principal_type=principal_type,",
            "                                      title=self.context.title)),",
            "            cp_links=CONTROL_PANEL_LINKS,",
            "            principal=principal)",
            "",
            "        form_view = self.GroupManageFormView if is_group \\",
            "            else self.UserManageFormView",
            "        form = form_view(principal, self.request)()",
            "        if self.request.is_response(form):",
            "            return form",
            "",
            "        return {",
            "            'api': api,",
            "            'form': form['form'],",
            "            }",
            "",
            "",
            "@view_config(name='delete-user', permission='admin',",
            "             root_only=True,",
            "             renderer='kotti:templates/site-setup/delete-user.pt')",
            "def user_delete(context, request):",
            "    principals = get_principals()",
            "",
            "    if 'name' in request.params and request.params['name']:",
            "        user_or_group = request.params['name']",
            "        principal = principals.search(name=user_or_group).first()",
            "        if principal is None:",
            "            request.session.flash(_(u'User was not found.'), 'error')",
            "        else:",
            "            is_group = user_or_group.startswith(\"group:\")",
            "            principal_type = _(u\"Group\") if is_group else _(u\"User\")",
            "",
            "            # We already coming from the confirmation page.",
            "            if 'delete' in request.POST:",
            "                principals.__delitem__(principal.name)",
            "                notify(UserDeleted(principal, request))",
            "                request.session.flash(",
            "                    _(u'${principal_type} ${title} was deleted.',",
            "                      mapping=dict(principal_type=principal_type,",
            "                                   title=principal.title)), 'info')",
            "                location = u'{0}/@@setup-users'.format(request.application_url)",
            "                return HTTPFound(location=location)",
            "",
            "            api = template_api(",
            "                context, request,",
            "                page_title=_(u\"Delete ${principal_type} ${title}\",",
            "                             mapping=dict(principal_type=principal_type,",
            "                                          title=principal.title)),",
            "                principal_type=principal_type,",
            "                principal=principal)",
            "            return {'api': api, }",
            "    else:",
            "        request.session.flash(_(u'No name was given.'), 'error')",
            "",
            "    return {'api': template_api(context, request), }",
            "",
            "",
            "class PreferencesFormView(UserEditFormView):",
            "",
            "    def cancel_success(self, appstruct):",
            "        location = self.request.resource_url(get_root())",
            "        return HTTPFound(location=location)",
            "    cancel_failure = cancel_success",
            "",
            "",
            "@view_config(name='prefs', root_only=True,",
            "             renderer='kotti:templates/edit/simpleform.pt')",
            "class Preferences(FormView):",
            "",
            "    PreferencesFormView = PreferencesFormView",
            "",
            "    def __init__(self, context, request):",
            "        super(Preferences, self).__init__(request)",
            "        self.context = context",
            "",
            "    def __call__(self):",
            "        user = self.request.user",
            "        if user is None:",
            "            raise Forbidden()",
            "",
            "        api = template_api(self.context, self.request)",
            "        api.page_title = _(u\"My preferences - ${title}\",",
            "                           mapping=dict(title=api.site_title))",
            "",
            "        form = self.PreferencesFormView(user, self.request)()",
            "",
            "        if self.request.is_response(form):",
            "            return form",
            "",
            "        return {",
            "            'api': api,",
            "            'form': form['form'],",
            "            'macro': api.macro('kotti:templates/site-setup/master.pt'),",
            "            }",
            "",
            "",
            "def includeme(config):",
            "    \"\"\" Pyramid includeme hook.",
            "",
            "    :param config: app config",
            "    :type config: :class:`pyramid.config.Configurator`",
            "    \"\"\"",
            "",
            "    config.scan(__name__)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "User management screens",
            "\"\"\"",
            "from __future__ import absolute_import, division, print_function",
            "",
            "import re",
            "from urllib import urlencode",
            "",
            "import colander",
            "from deform import Button",
            "from deform.widget import AutocompleteInputWidget",
            "from deform.widget import CheckboxChoiceWidget",
            "from deform.widget import CheckedPasswordWidget",
            "from deform.widget import SequenceWidget",
            "from pyramid.exceptions import Forbidden",
            "from pyramid.httpexceptions import HTTPFound, HTTPBadRequest",
            "from pyramid.view import view_config",
            "from pyramid_deform import FormView",
            "from six import string_types",
            "",
            "from kotti.events import UserDeleted",
            "from kotti.events import notify",
            "from kotti.message import email_set_password",
            "from kotti.resources import get_root",
            "from kotti.security import ROLES",
            "from kotti.security import SHARING_ROLES",
            "from kotti.security import USER_MANAGEMENT_ROLES",
            "from kotti.security import get_principals",
            "from kotti.security import list_groups_ext",
            "from kotti.security import list_groups_raw",
            "from kotti.security import map_principals_with_local_roles",
            "from kotti.security import set_groups",
            "from kotti.util import _",
            "from kotti.views.form import AddFormView",
            "from kotti.views.form import EditFormView",
            "from kotti.views.site_setup import CONTROL_PANEL_LINKS",
            "from kotti.views.util import template_api",
            "",
            "",
            "def roles_form_handler(context, request, available_role_names, groups_lister):",
            "    changed = []",
            "",
            "    if 'apply' in request.POST:",
            "        p_to_r = {}",
            "        for name in request.params:",
            "            if name.startswith('orig-role::'):",
            "                # orig-role::* is hidden checkboxes that allow us to",
            "                # see what checkboxes were in the form originally",
            "                token, principal_name, role_name = unicode(name).split(u'::')",
            "                if role_name not in available_role_names:",
            "                    raise Forbidden()",
            "                new_value = bool(request.params.get(",
            "                    u'role::{0}::{1}'.format(principal_name, role_name)))",
            "                if principal_name not in p_to_r:",
            "                    p_to_r[principal_name] = set()",
            "                if new_value:",
            "                    p_to_r[principal_name].add(role_name)",
            "",
            "        for principal_name, new_role_names in p_to_r.items():",
            "            # We have to be careful with roles that aren't mutable here:",
            "            orig_role_names = set(",
            "                groups_lister(principal_name, context))",
            "            orig_sharing_role_names = set(",
            "                r for r in orig_role_names if r in available_role_names)",
            "            if new_role_names != orig_sharing_role_names:",
            "                final_role_names = orig_role_names - set(available_role_names)",
            "                final_role_names |= new_role_names",
            "                changed.append((principal_name, context, final_role_names))",
            "",
            "        if changed:",
            "            request.session.flash(",
            "                _(u'Your changes have been saved.'), 'success')",
            "        else:",
            "            request.session.flash(_(u'No changes were made.'), 'info')",
            "",
            "    return changed",
            "",
            "",
            "def search_principals(request, context=None, ignore=None, extra=()):",
            "    flash = request.session.flash",
            "    principals = get_principals()",
            "",
            "    if ignore is None:",
            "        ignore = set()",
            "",
            "    entries = []",
            "    for principal_name in extra:",
            "        if principal_name not in ignore:",
            "            p = principals[principal_name]",
            "            entries.append((p, list_groups_ext(principal_name, context)))",
            "            ignore.add(principal_name)",
            "",
            "    postdata = request.POST",
            "    if request.method == 'POST' and request.is_xhr:",
            "        postdata = request.json",
            "    if 'search' in postdata:",
            "        if request.is_xhr:",
            "            query = u'*{0}*'.format(postdata['query'])",
            "        else:",
            "            query = u'*{0}*'.format(request.params['query'])",
            "        found = False",
            "        for p in principals.search(name=query, title=query, email=query):",
            "            found = True",
            "            if p.name not in ignore:",
            "                entries.append((p, list_groups_ext(p.name, context)))",
            "        if not found:",
            "            flash(_(u'No users or groups were found.'), 'info')",
            "",
            "    return entries",
            "",
            "",
            "@view_config(name='share', permission='manage',",
            "             renderer='kotti:templates/edit/share.pt')",
            "def share_node(context, request):",
            "    # Allow roles_form_handler to do processing on 'apply':",
            "    if 'apply' in request.POST:",
            "        if request.params.get('csrf_token') != request.session.get_csrf_token():",
            "            raise HTTPBadRequest('Invalid CSRF token')",
            "    changed = roles_form_handler(",
            "        context, request, SHARING_ROLES, list_groups_raw)",
            "    if changed:",
            "        for (principal_name, context, groups) in changed:",
            "            set_groups(principal_name, context, groups)",
            "        return HTTPFound(location=request.url)",
            "",
            "    existing = map_principals_with_local_roles(context)",
            "",
            "    def with_roles(entry):",
            "        all_groups = entry[1][0]",
            "        return [g for g in all_groups if g.startswith('role:')]",
            "",
            "    existing = filter(with_roles, existing)",
            "    seen = set([entry[0].name for entry in existing])",
            "",
            "    # Allow search to take place and add some entries:",
            "    entries = existing + search_principals(request, context, ignore=seen)",
            "    available_roles = [ROLES[role_name] for role_name in SHARING_ROLES]",
            "",
            "    return {",
            "        'entries': entries,",
            "        'available_roles': available_roles,",
            "        'csrf_token': request.session.get_csrf_token()",
            "        }",
            "",
            "",
            "def name_pattern_validator(node, value):",
            "    \"\"\"",
            "        >>> name_pattern_validator(None, u'bob')",
            "        >>> name_pattern_validator(None, u'b ob')",
            "        Traceback (most recent call last):",
            "        Invalid: <unprintable Invalid object>",
            "        >>> name_pattern_validator(None, u'b:ob')",
            "        Traceback (most recent call last):",
            "        Invalid: <unprintable Invalid object>",
            "    \"\"\"",
            "    valid_pattern = re.compile(r\"^[a-zA-Z0-9_\\-\\.]+$\")",
            "    if not valid_pattern.match(value):",
            "        raise colander.Invalid(node, _(u\"Invalid value\"))",
            "",
            "",
            "def name_new_validator(node, value):",
            "    if get_principals().get(value.lower()) is not None:",
            "        raise colander.Invalid(",
            "            node, _(u\"A user with that name already exists.\"))",
            "",
            "",
            "@colander.deferred",
            "def deferred_email_validator(node, kw):",
            "    def raise_invalid_email(node, value):",
            "        raise colander.Invalid(",
            "            node, _(u\"A user with that email already exists.\"))",
            "    request = kw['request']",
            "    if request.POST:",
            "        email = request.params.get('email')",
            "        name = request.params.get('name')",
            "        if not name and request.user:",
            "            name = request.user.name",
            "        if email and name:",
            "            principals = get_principals()",
            "            if any(p for p in principals.search(email=email)",
            "                   if p.name.lower() != name.lower()):",
            "                # verify duplicated email except myself when update info",
            "                return raise_invalid_email",
            "",
            "",
            "def roleset_validator(node, value):",
            "    oneof = colander.OneOf(USER_MANAGEMENT_ROLES)",
            "    [oneof(node, item) for item in value]",
            "",
            "",
            "def group_validator(node, value):",
            "    principals = get_principals()",
            "    if principals.get('group:' + value) is None:",
            "        raise colander.Invalid(node, _(u\"No such group: ${group}\",",
            "                                       mapping=dict(group=value)))",
            "",
            "",
            "class Groups(colander.SequenceSchema):",
            "    group = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Group'),",
            "        validator=group_validator,",
            "        missing=None,",
            "        widget=AutocompleteInputWidget(),",
            "        )",
            "",
            "",
            "class PrincipalBasic(colander.MappingSchema):",
            "    title = colander.SchemaNode(colander.String(), title=_(u'Title'))",
            "    email = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Email'),",
            "        validator=deferred_email_validator,",
            "    )",
            "",
            "",
            "class PrincipalFull(PrincipalBasic):",
            "    name = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Name'),",
            "        validator=colander.All(name_pattern_validator, name_new_validator),",
            "        )",
            "    password = colander.SchemaNode(",
            "        colander.String(),",
            "        title=_(u'Password'),",
            "        validator=colander.Length(min=5),",
            "        missing=None,",
            "        widget=CheckedPasswordWidget(),",
            "        )",
            "    active = colander.SchemaNode(",
            "        colander.Boolean(),",
            "        title=_(u'Active'),",
            "        description=_(u\"Untick this to deactivate the account.\"),",
            "        )",
            "    roles = colander.SchemaNode(",
            "        colander.Set(),",
            "        validator=roleset_validator,",
            "        missing=[],",
            "        title=_(u\"Global roles\"),",
            "        widget=CheckboxChoiceWidget(),",
            "        )",
            "    groups = Groups(",
            "        title=_(u'Groups'),",
            "        missing=[],",
            "        # XXX min_len doesn't really do what we want here.  We'd like",
            "        # the close buttons to appear nevertheless (maybe the now",
            "        # deprecated render_initial_item did exactly that).",
            "        widget=SequenceWidget(min_len=1),",
            "        )",
            "",
            "",
            "def principal_schema(base=PrincipalFull()):",
            "    principals = get_principals()",
            "    schema = base.clone()",
            "    has_groups = True",
            "    try:",
            "        schema['groups']",
            "    except KeyError:",
            "        has_groups = False",
            "    if has_groups:",
            "        all_groups = []",
            "        for p in principals.search(name=u'group:*'):",
            "            value = p.name.split(u'group:')[1]",
            "            label = u\"{0}, {1}\".format(p.title, value)",
            "            all_groups.append(dict(value=value, label=label))",
            "        schema['groups']['group'].widget.values = all_groups",
            "        schema['roles'].widget.values = [",
            "            (n, ROLES[n].title) for n in USER_MANAGEMENT_ROLES]",
            "    return schema",
            "",
            "",
            "def user_schema(base=PrincipalFull()):",
            "    schema = principal_schema(base)",
            "    has_password = True",
            "    try:",
            "        schema['password']",
            "    except KeyError:",
            "        has_password = False",
            "    if has_password:",
            "        schema['password'].description = _(",
            "            u\"Leave this empty and tick the 'Send password registration' \"",
            "            u\"box below to have the user set their own password.\")",
            "    schema['title'].title = _(u\"Full name\")",
            "    return schema",
            "",
            "",
            "def group_schema(base=PrincipalFull()):",
            "    schema = principal_schema(base)",
            "    del schema['password']",
            "    schema['email'].missing = None",
            "    return schema",
            "",
            "",
            "def _massage_groups_in(appstruct):",
            "    \"\"\"Manipulate appstruct received from form so that it's suitable",
            "    for saving on the Principal.",
            "",
            "    What we do for groups is we prefix them with 'group:'.  And the",
            "    'roles' in the form are really groups too, so we add to 'groups'.",
            "",
            "    The value in the form is 'name', not 'group:name', so we'll",
            "    need to append that before we save.",
            "    \"\"\"",
            "    groups = appstruct.get('groups', [])",
            "    all_groups = list(appstruct.get('roles', [])) + [",
            "        u'group:{0}'.format(g) for g in groups if g]",
            "    if 'roles' in appstruct:",
            "        del appstruct['roles']",
            "    appstruct['groups'] = all_groups",
            "",
            "",
            "def _massage_groups_out(appstruct):",
            "    \"\"\"Opposite of '_massage_groups_in': remove 'groups:' prefix and",
            "    split 'groups' into 'roles' and 'groups'.",
            "    \"\"\"",
            "    d = appstruct",
            "    groups = [g.split(u'group:')[1] for g in d.get('groups', u'')",
            "              if g and g.startswith(u'group:')]",
            "    roles = [r for r in d.get('groups', u'') if r and r.startswith(u'role:')]",
            "    d['groups'] = groups",
            "    d['roles'] = roles",
            "    return d",
            "",
            "",
            "class UserAddFormView(AddFormView):",
            "    item_type = _(u'User')",
            "    form_options = (('formid', 'deform_user_add'), )",
            "    buttons = (Button('add_user', _(u'Add User')),",
            "               Button('cancel', _(u'Cancel')))",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = user_schema()",
            "        del schema['active']",
            "        schema.add(colander.SchemaNode(",
            "            colander.Boolean(),",
            "            name=u'send_email',",
            "            title=_(u'Send password registration link.'),",
            "            default=True,",
            "            ))",
            "        return schema",
            "",
            "    def add_user_success(self, appstruct):",
            "        appstruct.pop('csrf_token', None)",
            "        _massage_groups_in(appstruct)",
            "        name = appstruct['name'] = appstruct['name'].lower()",
            "        appstruct['email'] = appstruct['email'] and appstruct['email'].lower()",
            "        send_email = appstruct.pop('send_email', False)",
            "        get_principals()[name] = appstruct",
            "        if send_email:",
            "            email_set_password(get_principals()[name], self.request)",
            "        self.request.session.flash(",
            "            _(u'${title} was added.',",
            "              mapping=dict(title=appstruct['title'])), 'success')",
            "        location = self.request.url.split('?')[0] + '?' + urlencode(",
            "            {'extra': name})",
            "        return HTTPFound(location=location)",
            "",
            "",
            "class GroupAddFormView(UserAddFormView):",
            "    item_type = _(u\"Group\")",
            "    form_options = (('formid', 'deform_group_add'), )",
            "    buttons = (Button('add_group', _(u'Add Group')),",
            "               Button('cancel', _(u'Cancel')))",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = group_schema()",
            "        del schema['active']",
            "        return schema",
            "",
            "    def add_group_success(self, appstruct):",
            "        appstruct['name'] = u'group:{0}'.format(appstruct['name'].lower())",
            "        return self.add_user_success(appstruct)",
            "",
            "",
            "@view_config(name='setup-users', permission='admin',",
            "             root_only=True,",
            "             renderer='kotti:templates/site-setup/users.pt')",
            "class UsersManage(FormView):",
            "",
            "    UserAddFormView = UserAddFormView",
            "    GroupAddFormView = GroupAddFormView",
            "",
            "    def __init__(self, context, request):",
            "        super(UsersManage, self).__init__(request)",
            "        self.context = context",
            "",
            "    def __call__(self):",
            "        api = template_api(self.context, self.request,",
            "                           cp_links=CONTROL_PANEL_LINKS)",
            "",
            "        api.page_title = _(u\"User Management\")",
            "",
            "        principals = get_principals()",
            "",
            "        def groups_lister(principal_name, context):",
            "            return principals[principal_name].groups",
            "",
            "        # Handling the user/roles matrix:",
            "        changed = roles_form_handler(",
            "            self.context, self.request, USER_MANAGEMENT_ROLES, groups_lister)",
            "        if changed:",
            "            changed_names = []",
            "            for (principal_name, context, groups) in changed:",
            "                principal = principals[principal_name]",
            "                principal.groups = list(groups)",
            "                changed_names.append(principal_name)",
            "            location = self.request.url.split('?')[0] + '?' + urlencode(",
            "                {'extra': ','.join(changed_names)})",
            "            return HTTPFound(location=location)",
            "",
            "        extra = self.request.params.get('extra') or ()",
            "        if isinstance(extra, string_types):",
            "            extra = extra.split(',')",
            "        search_entries = search_principals(self.request, extra=extra)",
            "        available_roles = [ROLES[role_name]",
            "                           for role_name in USER_MANAGEMENT_ROLES]",
            "",
            "        # Add forms:",
            "        user_addform = self.UserAddFormView(self.context, self.request)()",
            "        if self.request.is_response(user_addform):",
            "            return user_addform",
            "",
            "        group_addform = self.GroupAddFormView(self.context, self.request)()",
            "        if self.request.is_response(group_addform):",
            "            return group_addform",
            "",
            "        if self.request.params.get('add_user'):",
            "            active_tab = 'add_user'",
            "        elif self.request.params.get('add_group'):",
            "            active_tab = 'add_group'",
            "        else:",
            "            active_tab = 'search'",
            "        return {",
            "            'api': api,",
            "            'entries': search_entries,",
            "            'available_roles': available_roles,",
            "            'user_addform': user_addform['form'],",
            "            'group_addform': group_addform['form'],",
            "            'active_tab': active_tab,",
            "        }",
            "",
            "",
            "class UserEditFormView(EditFormView):",
            "    @property",
            "    def success_url(self):",
            "        return self.request.url",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        return user_schema(PrincipalBasic())",
            "",
            "",
            "class UserManageFormView(UserEditFormView):",
            "",
            "    buttons = (Button('save', _(u'Save')),",
            "               Button('cancel', _(u'Cancel')),",
            "               Button('delete', _(u'Delete'), css_class='btn btn-danger'))",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = user_schema()",
            "        del schema['name']",
            "        return schema",
            "",
            "    def before(self, form):",
            "        context = self.context.__dict__.copy()",
            "        context['password'] = u''",
            "        form.appstruct = _massage_groups_out(context)",
            "",
            "    def save_success(self, appstruct):",
            "        if appstruct.get('password'):",
            "            hashed = get_principals().hash_password(appstruct['password'])",
            "            appstruct['password'] = hashed",
            "        else:",
            "            appstruct.pop('password', None)",
            "        _massage_groups_in(appstruct)",
            "        return super(UserManageFormView, self).save_success(appstruct)",
            "",
            "    def cancel_success(self, appstruct):",
            "        self.request.session.flash(_(u'No changes were made.'), 'info')",
            "        location = u'{0}/@@setup-users'.format(self.request.application_url)",
            "        return HTTPFound(location=location)",
            "    cancel_failure = cancel_success",
            "",
            "    def delete_success(self, appstruct):",
            "        location = u'{0}/@@delete-user?name={1}'.format(",
            "            self.request.application_url, self.request.params['name'])",
            "        return HTTPFound(location=location)",
            "",
            "",
            "class GroupManageFormView(UserManageFormView):",
            "",
            "    @staticmethod",
            "    def schema_factory():",
            "        schema = group_schema()",
            "        del schema['name']",
            "        del schema['active']",
            "        return schema",
            "",
            "",
            "@view_config(name='setup-user', permission='admin',",
            "             root_only=True,",
            "             renderer='kotti:templates/site-setup/user.pt')",
            "class UserManage(FormView):",
            "",
            "    GroupManageFormView = GroupManageFormView",
            "    UserManageFormView = UserManageFormView",
            "",
            "    def __init__(self, context, request):",
            "        super(UserManage, self).__init__(request)",
            "        self.context = context",
            "",
            "    def __call__(self):",
            "        user_or_group = self.request.params['name']",
            "        principal = get_principals()[user_or_group]",
            "",
            "        is_group = user_or_group.startswith(\"group:\")",
            "        principal_type = _(u\"Group\") if is_group else _(u\"User\")",
            "",
            "        api = template_api(",
            "            self.context, self.request,",
            "            page_title=_(u\"Edit ${principal_type} ${title}\",",
            "                         mapping=dict(principal_type=principal_type,",
            "                                      title=self.context.title)),",
            "            cp_links=CONTROL_PANEL_LINKS,",
            "            principal=principal)",
            "",
            "        form_view = self.GroupManageFormView if is_group \\",
            "            else self.UserManageFormView",
            "        form = form_view(principal, self.request)()",
            "        if self.request.is_response(form):",
            "            return form",
            "",
            "        return {",
            "            'api': api,",
            "            'form': form['form'],",
            "            }",
            "",
            "",
            "@view_config(name='delete-user', permission='admin',",
            "             root_only=True,",
            "             renderer='kotti:templates/site-setup/delete-user.pt')",
            "def user_delete(context, request):",
            "    principals = get_principals()",
            "",
            "    if 'name' in request.params and request.params['name']:",
            "        user_or_group = request.params['name']",
            "        principal = principals.search(name=user_or_group).first()",
            "        if principal is None:",
            "            request.session.flash(_(u'User was not found.'), 'error')",
            "        else:",
            "            is_group = user_or_group.startswith(\"group:\")",
            "            principal_type = _(u\"Group\") if is_group else _(u\"User\")",
            "",
            "            # We already coming from the confirmation page.",
            "            if 'delete' in request.POST:",
            "                principals.__delitem__(principal.name)",
            "                notify(UserDeleted(principal, request))",
            "                request.session.flash(",
            "                    _(u'${principal_type} ${title} was deleted.',",
            "                      mapping=dict(principal_type=principal_type,",
            "                                   title=principal.title)), 'info')",
            "                location = u'{0}/@@setup-users'.format(request.application_url)",
            "                return HTTPFound(location=location)",
            "",
            "            api = template_api(",
            "                context, request,",
            "                page_title=_(u\"Delete ${principal_type} ${title}\",",
            "                             mapping=dict(principal_type=principal_type,",
            "                                          title=principal.title)),",
            "                principal_type=principal_type,",
            "                principal=principal)",
            "            return {'api': api, }",
            "    else:",
            "        request.session.flash(_(u'No name was given.'), 'error')",
            "",
            "    return {'api': template_api(context, request), }",
            "",
            "",
            "class PreferencesFormView(UserEditFormView):",
            "",
            "    def cancel_success(self, appstruct):",
            "        location = self.request.resource_url(get_root())",
            "        return HTTPFound(location=location)",
            "    cancel_failure = cancel_success",
            "",
            "",
            "@view_config(name='prefs', root_only=True,",
            "             renderer='kotti:templates/edit/simpleform.pt')",
            "class Preferences(FormView):",
            "",
            "    PreferencesFormView = PreferencesFormView",
            "",
            "    def __init__(self, context, request):",
            "        super(Preferences, self).__init__(request)",
            "        self.context = context",
            "",
            "    def __call__(self):",
            "        user = self.request.user",
            "        if user is None:",
            "            raise Forbidden()",
            "",
            "        api = template_api(self.context, self.request)",
            "        api.page_title = _(u\"My preferences - ${title}\",",
            "                           mapping=dict(title=api.site_title))",
            "",
            "        form = self.PreferencesFormView(user, self.request)()",
            "",
            "        if self.request.is_response(form):",
            "            return form",
            "",
            "        return {",
            "            'api': api,",
            "            'form': form['form'],",
            "            'macro': api.macro('kotti:templates/site-setup/master.pt'),",
            "            }",
            "",
            "",
            "def includeme(config):",
            "    \"\"\" Pyramid includeme hook.",
            "",
            "    :param config: app config",
            "    :type config: :class:`pyramid.config.Configurator`",
            "    \"\"\"",
            "",
            "    config.scan(__name__)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "17": []
        },
        "addLocation": []
    },
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from setuptools import setup"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-version = '1.3.1'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+version = '1.3.2.dev0'"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " description = \"A high-level, Pythonic web application framework based on \" \\"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "               \"Pyramid and SQLAlchemy.  It includes an extensible Content \" \\"
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "               \"Management System called the Kotti CMS.\""
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     'filedepot',"
            },
            "9": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     'formencode',"
            },
            "10": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     'html2text',"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    'iso8601<=0.1.11',"
            },
            "12": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     'js.angular',"
            },
            "13": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     'js.bootstrap>=3.0.0',"
            },
            "14": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     'js.deform>=2.0a2-2',"
            },
            "15": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     'js.fineuploader',"
            },
            "16": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     'js.html5shiv',"
            },
            "17": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    'js.jquery',"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    'js.jquery<2.0.0',"
            },
            "19": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     'js.jquery_form',"
            },
            "20": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     'js.jquery_tablednd',"
            },
            "21": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     'js.jquery_timepicker_addon',"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import codecs",
            "import os",
            "",
            "from setuptools import find_packages",
            "from setuptools import setup",
            "",
            "",
            "version = '1.3.1'",
            "description = \"A high-level, Pythonic web application framework based on \" \\",
            "              \"Pyramid and SQLAlchemy.  It includes an extensible Content \" \\",
            "              \"Management System called the Kotti CMS.\"",
            "author = 'Kotti developers'",
            "author_email = 'kotti@googlegroups.com'",
            "url = 'http://kotti.pylonsproject.org/'",
            "keywords = 'kotti web cms wcms pylons pyramid sqlalchemy bootstrap'",
            "license = \"BSD-derived (http://www.repoze.org/LICENSE.txt)\"",
            "",
            "",
            "install_requires = [",
            "    'Babel',",
            "    'Chameleon>=2.7.4',  # Fixes error when raising HTTPFound",
            "    'alembic>=0.8.0',",
            "    'bleach',",
            "    'bleach-whitelist',",
            "    'colander>=1.3.2',",
            "    'deform>=2.0.3',  # >=2.0a1 to support Bootstrap 2",
            "    'docopt',",
            "    'fanstatic>=1.0.0',",
            "    'filedepot',",
            "    'formencode',",
            "    'html2text',",
            "    'js.angular',",
            "    'js.bootstrap>=3.0.0',",
            "    'js.deform>=2.0a2-2',",
            "    'js.fineuploader',",
            "    'js.html5shiv',",
            "    'js.jquery',",
            "    'js.jquery_form',",
            "    'js.jquery_tablednd',",
            "    'js.jquery_timepicker_addon',",
            "    'js.jqueryui>=1.8.24',",
            "    'js.jqueryui_tagit',",
            "    'kotti_image',",
            "    'lingua>=1.3',",
            "    'py_bcrypt',",
            "    'pyramid>=1.8',  # needed for ``request.has_permission``,",
            "    'pyramid_beaker',",
            "    'pyramid_chameleon',",
            "    'pyramid_deform>=0.2a3',  # language and template path config includeme",
            "    'pyramid_mailer',",
            "    'pyramid_tm',",
            "    'pyramid_zcml>=1.1.0',",
            "    'repoze.lru',",
            "    'repoze.workflow>=1.0b1',",
            "    'repoze.zcml>=1.0b1',",
            "    'rfc6266',",
            "    'sqlalchemy>=1.0.0',",
            "    'sqlalchemy-utils',",
            "    'transaction>=1.1.0',",
            "    'unidecode',",
            "    'usersettings',",
            "    'waitress',",
            "    'zope.deprecation',",
            "    'zope.interface',",
            "    'zope.sqlalchemy',",
            "    ]",
            "",
            "tests_require = [",
            "    'WebTest',",
            "    'mock',",
            "    'py>=1.4.29',",
            "    'pyquery',",
            "    'pytest>=3.0.0',",
            "    'pytest-cov',",
            "    'pytest-pep8!=1.0.3',",
            "    'pytest-travis-fold',",
            "    'pytest-virtualenv',",
            "    'pytest-xdist',",
            "    'tox',",
            "    'virtualenv',  # needed for scaffolding tests",
            "    'zope.testbrowser>=5.0.0',",
            "    ]",
            "",
            "development_requires = [",
            "    'check-manifest',",
            "    'pipdeptree',",
            "    'pyramid_debugtoolbar',",
            "]",
            "",
            "docs_require = [",
            "    'Sphinx',",
            "    'docutils',",
            "    'repoze.sphinx.autointerface',",
            "    'sphinx_rtd_theme',",
            "    ]",
            "",
            "setup_requires = [",
            "    'setuptools_git>=0.3',",
            "]",
            "",
            "",
            "here = os.path.abspath(os.path.dirname(__file__))",
            "",
            "def read(*parts):",
            "    \"\"\" Build an absolute path from *parts* and and return the contents of the",
            "    resulting file.  Assume UTF-8 encoding.",
            "",
            "    Copied from",
            "    https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/",
            "    \"\"\"",
            "",
            "    with codecs.open(os.path.join(here, *parts), \"rb\", \"utf-8\") as f:",
            "        return f.read()",
            "",
            "",
            "setup(name='Kotti',",
            "      version=version,",
            "      description=description,",
            "      long_description='\\n\\n'.join([read('README.rst'), read('AUTHORS.txt'),",
            "                                    read('CHANGES.txt'), ]),",
            "      classifiers=[",
            "          # 'Development Status :: 3 - Alpha',",
            "          # 'Development Status :: 4 - Beta',",
            "          'Development Status :: 5 - Production/Stable',",
            "          'Environment :: Web Environment',",
            "          'Framework :: Pylons',",
            "          'Framework :: Pyramid',",
            "          'License :: Repoze Public License',",
            "          'Natural Language :: Dutch',",
            "          'Natural Language :: English',",
            "          'Natural Language :: French',",
            "          'Natural Language :: German',",
            "          'Natural Language :: Italian',",
            "          'Natural Language :: Japanese',",
            "          'Natural Language :: Polish',",
            "          'Natural Language :: Portuguese',",
            "          'Natural Language :: Swedish',",
            "          'Operating System :: POSIX',",
            "          'Operating System :: Unix',",
            "          # 'Programming Language :: JavaScript',",
            "          'Programming Language :: Python',",
            "          'Programming Language :: Python :: 2',",
            "          'Programming Language :: Python :: 2.7',",
            "          # 'Programming Language :: Python :: 3',",
            "          # 'Programming Language :: Python :: 3.3',",
            "          # 'Programming Language :: Python :: 3.4',",
            "          # 'Programming Language :: Python :: 3.5',",
            "          # 'Programming Language :: Python :: 3.6',",
            "          'Programming Language :: SQL',",
            "          'Topic :: Internet',",
            "          'Topic :: Internet :: WWW/HTTP',",
            "          'Topic :: Internet :: WWW/HTTP :: Dynamic Content',",
            "          'Topic :: Internet :: WWW/HTTP :: Dynamic Content :: CGI Tools/Libraries',  # noqa",
            "          'Topic :: Internet :: WWW/HTTP :: WSGI',",
            "          'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',",
            "          'Topic :: Software Development',",
            "          'Topic :: Software Development :: Libraries :: Application Frameworks',  # noqa",
            "      ],",
            "      author=author,",
            "      author_email=author_email,",
            "      url=url,",
            "      keywords=keywords,",
            "      license=license,",
            "      packages=find_packages(),",
            "      include_package_data=True,",
            "      zip_safe=False,",
            "      install_requires=install_requires,",
            "      setup_requires=setup_requires,",
            "      tests_require=tests_require,",
            "      dependency_links=[],",
            "      entry_points={",
            "          'paste.app_factory': [",
            "              'main = kotti:main',",
            "          ],",
            "          'fanstatic.libraries': [",
            "              'kotti = kotti.fanstatic:lib_kotti',",
            "          ],",
            "          'console_scripts': [",
            "              'kotti-migrate = kotti.migrate:kotti_migrate_command',",
            "              'kotti-reset-workflow = kotti.workflow:reset_workflow_command',",
            "              'kotti-migrate-storage = kotti.filedepot:migrate_storages_command',  # noqa",
            "          ],",
            "          'pytest11': [",
            "              'kotti = kotti.tests',",
            "          ],",
            "          'pyramid.scaffold': [",
            "              'kotti=kotti.scaffolds:KottiPackageTemplate',",
            "          ],",
            "      },",
            "      extras_require={",
            "          'testing': tests_require,",
            "          'development': development_requires,",
            "          'docs': docs_require,",
            "          },",
            "      )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import codecs",
            "import os",
            "",
            "from setuptools import find_packages",
            "from setuptools import setup",
            "",
            "",
            "version = '1.3.2.dev0'",
            "description = \"A high-level, Pythonic web application framework based on \" \\",
            "              \"Pyramid and SQLAlchemy.  It includes an extensible Content \" \\",
            "              \"Management System called the Kotti CMS.\"",
            "author = 'Kotti developers'",
            "author_email = 'kotti@googlegroups.com'",
            "url = 'http://kotti.pylonsproject.org/'",
            "keywords = 'kotti web cms wcms pylons pyramid sqlalchemy bootstrap'",
            "license = \"BSD-derived (http://www.repoze.org/LICENSE.txt)\"",
            "",
            "",
            "install_requires = [",
            "    'Babel',",
            "    'Chameleon>=2.7.4',  # Fixes error when raising HTTPFound",
            "    'alembic>=0.8.0',",
            "    'bleach',",
            "    'bleach-whitelist',",
            "    'colander>=1.3.2',",
            "    'deform>=2.0.3',  # >=2.0a1 to support Bootstrap 2",
            "    'docopt',",
            "    'fanstatic>=1.0.0',",
            "    'filedepot',",
            "    'formencode',",
            "    'html2text',",
            "    'iso8601<=0.1.11',",
            "    'js.angular',",
            "    'js.bootstrap>=3.0.0',",
            "    'js.deform>=2.0a2-2',",
            "    'js.fineuploader',",
            "    'js.html5shiv',",
            "    'js.jquery<2.0.0',",
            "    'js.jquery_form',",
            "    'js.jquery_tablednd',",
            "    'js.jquery_timepicker_addon',",
            "    'js.jqueryui>=1.8.24',",
            "    'js.jqueryui_tagit',",
            "    'kotti_image',",
            "    'lingua>=1.3',",
            "    'py_bcrypt',",
            "    'pyramid>=1.8',  # needed for ``request.has_permission``,",
            "    'pyramid_beaker',",
            "    'pyramid_chameleon',",
            "    'pyramid_deform>=0.2a3',  # language and template path config includeme",
            "    'pyramid_mailer',",
            "    'pyramid_tm',",
            "    'pyramid_zcml>=1.1.0',",
            "    'repoze.lru',",
            "    'repoze.workflow>=1.0b1',",
            "    'repoze.zcml>=1.0b1',",
            "    'rfc6266',",
            "    'sqlalchemy>=1.0.0',",
            "    'sqlalchemy-utils',",
            "    'transaction>=1.1.0',",
            "    'unidecode',",
            "    'usersettings',",
            "    'waitress',",
            "    'zope.deprecation',",
            "    'zope.interface',",
            "    'zope.sqlalchemy',",
            "    ]",
            "",
            "tests_require = [",
            "    'WebTest',",
            "    'mock',",
            "    'py>=1.4.29',",
            "    'pyquery',",
            "    'pytest>=3.0.0',",
            "    'pytest-cov',",
            "    'pytest-pep8!=1.0.3',",
            "    'pytest-travis-fold',",
            "    'pytest-virtualenv',",
            "    'pytest-xdist',",
            "    'tox',",
            "    'virtualenv',  # needed for scaffolding tests",
            "    'zope.testbrowser>=5.0.0',",
            "    ]",
            "",
            "development_requires = [",
            "    'check-manifest',",
            "    'pipdeptree',",
            "    'pyramid_debugtoolbar',",
            "]",
            "",
            "docs_require = [",
            "    'Sphinx',",
            "    'docutils',",
            "    'repoze.sphinx.autointerface',",
            "    'sphinx_rtd_theme',",
            "    ]",
            "",
            "setup_requires = [",
            "    'setuptools_git>=0.3',",
            "]",
            "",
            "",
            "here = os.path.abspath(os.path.dirname(__file__))",
            "",
            "def read(*parts):",
            "    \"\"\" Build an absolute path from *parts* and and return the contents of the",
            "    resulting file.  Assume UTF-8 encoding.",
            "",
            "    Copied from",
            "    https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/",
            "    \"\"\"",
            "",
            "    with codecs.open(os.path.join(here, *parts), \"rb\", \"utf-8\") as f:",
            "        return f.read()",
            "",
            "",
            "setup(name='Kotti',",
            "      version=version,",
            "      description=description,",
            "      long_description='\\n\\n'.join([read('README.rst'), read('AUTHORS.txt'),",
            "                                    read('CHANGES.txt'), ]),",
            "      classifiers=[",
            "          # 'Development Status :: 3 - Alpha',",
            "          # 'Development Status :: 4 - Beta',",
            "          'Development Status :: 5 - Production/Stable',",
            "          'Environment :: Web Environment',",
            "          'Framework :: Pylons',",
            "          'Framework :: Pyramid',",
            "          'License :: Repoze Public License',",
            "          'Natural Language :: Dutch',",
            "          'Natural Language :: English',",
            "          'Natural Language :: French',",
            "          'Natural Language :: German',",
            "          'Natural Language :: Italian',",
            "          'Natural Language :: Japanese',",
            "          'Natural Language :: Polish',",
            "          'Natural Language :: Portuguese',",
            "          'Natural Language :: Swedish',",
            "          'Operating System :: POSIX',",
            "          'Operating System :: Unix',",
            "          # 'Programming Language :: JavaScript',",
            "          'Programming Language :: Python',",
            "          'Programming Language :: Python :: 2',",
            "          'Programming Language :: Python :: 2.7',",
            "          # 'Programming Language :: Python :: 3',",
            "          # 'Programming Language :: Python :: 3.3',",
            "          # 'Programming Language :: Python :: 3.4',",
            "          # 'Programming Language :: Python :: 3.5',",
            "          # 'Programming Language :: Python :: 3.6',",
            "          'Programming Language :: SQL',",
            "          'Topic :: Internet',",
            "          'Topic :: Internet :: WWW/HTTP',",
            "          'Topic :: Internet :: WWW/HTTP :: Dynamic Content',",
            "          'Topic :: Internet :: WWW/HTTP :: Dynamic Content :: CGI Tools/Libraries',  # noqa",
            "          'Topic :: Internet :: WWW/HTTP :: WSGI',",
            "          'Topic :: Internet :: WWW/HTTP :: WSGI :: Application',",
            "          'Topic :: Software Development',",
            "          'Topic :: Software Development :: Libraries :: Application Frameworks',  # noqa",
            "      ],",
            "      author=author,",
            "      author_email=author_email,",
            "      url=url,",
            "      keywords=keywords,",
            "      license=license,",
            "      packages=find_packages(),",
            "      include_package_data=True,",
            "      zip_safe=False,",
            "      install_requires=install_requires,",
            "      setup_requires=setup_requires,",
            "      tests_require=tests_require,",
            "      dependency_links=[],",
            "      entry_points={",
            "          'paste.app_factory': [",
            "              'main = kotti:main',",
            "          ],",
            "          'fanstatic.libraries': [",
            "              'kotti = kotti.fanstatic:lib_kotti',",
            "          ],",
            "          'console_scripts': [",
            "              'kotti-migrate = kotti.migrate:kotti_migrate_command',",
            "              'kotti-reset-workflow = kotti.workflow:reset_workflow_command',",
            "              'kotti-migrate-storage = kotti.filedepot:migrate_storages_command',  # noqa",
            "          ],",
            "          'pytest11': [",
            "              'kotti = kotti.tests',",
            "          ],",
            "          'pyramid.scaffold': [",
            "              'kotti=kotti.scaffolds:KottiPackageTemplate',",
            "          ],",
            "      },",
            "      extras_require={",
            "          'testing': tests_require,",
            "          'development': development_requires,",
            "          'docs': docs_require,",
            "          },",
            "      )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": [
                "version"
            ],
            "39": []
        },
        "addLocation": []
    }
}