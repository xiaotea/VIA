{
    "lib/ansible/template/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " from ansible.module_utils.common.text.converters import to_native, to_text, to_bytes"
            },
            "1": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " from ansible.module_utils.common.collections import is_sequence"
            },
            "2": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " from ansible.plugins.loader import filter_loader, lookup_loader, test_loader"
            },
            "3": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ansible.template.native_helpers import ansible_native_concat, ansible_eval_concat, ansible_concat"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+from ansible.template.native_helpers import AnsibleUndefined, ansible_native_concat, ansible_eval_concat, ansible_concat"
            },
            "5": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " from ansible.template.template import AnsibleJ2Template"
            },
            "6": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " from ansible.template.vars import AnsibleJ2Vars"
            },
            "7": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from ansible.utils.display import Display"
            },
            "8": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "     return functools.update_wrapper(wrapper, func)"
            },
            "9": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 313,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 314,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-class AnsibleUndefined(StrictUndefined):"
            },
            "12": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    '''"
            },
            "13": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    A custom Undefined class, which returns further Undefined objects on access,"
            },
            "14": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    rather than throwing an exception."
            },
            "15": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    '''"
            },
            "16": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __getattr__(self, name):"
            },
            "17": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if name == '__UNSAFE__':"
            },
            "18": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # AnsibleUndefined should never be assumed to be unsafe"
            },
            "19": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # This prevents ``hasattr(val, '__UNSAFE__')`` from evaluating to ``True``"
            },
            "20": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise AttributeError(name)"
            },
            "21": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Return original Undefined object to preserve the first failure context"
            },
            "22": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self"
            },
            "23": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "24": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __getitem__(self, key):"
            },
            "25": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Return original Undefined object to preserve the first failure context"
            },
            "26": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self"
            },
            "27": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "28": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __repr__(self):"
            },
            "29": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return 'AnsibleUndefined(hint={0!r}, obj={1!r}, name={2!r})'.format("
            },
            "30": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._undefined_hint,"
            },
            "31": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._undefined_obj,"
            },
            "32": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._undefined_name"
            },
            "33": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "34": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "35": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __contains__(self, item):"
            },
            "36": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Return original Undefined object to preserve the first failure context"
            },
            "37": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self"
            },
            "38": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "40": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 315,
                "PatchRowcode": " class AnsibleContext(Context):"
            },
            "41": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "     '''"
            },
            "42": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "     A custom context, which intercepts resolve_or_missing() calls and sets a flag"
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from __future__ import annotations",
            "",
            "import ast",
            "import datetime",
            "import functools",
            "import os",
            "import pwd",
            "import re",
            "import time",
            "",
            "from collections.abc import Iterator, Sequence, Mapping, MappingView, MutableMapping",
            "from contextlib import contextmanager",
            "from numbers import Number",
            "from traceback import format_exc",
            "",
            "from jinja2.exceptions import TemplateSyntaxError, UndefinedError, SecurityError",
            "from jinja2.loaders import FileSystemLoader",
            "from jinja2.nativetypes import NativeEnvironment",
            "from jinja2.runtime import Context, StrictUndefined",
            "",
            "from ansible import constants as C",
            "from ansible.errors import (",
            "    AnsibleAssertionError,",
            "    AnsibleError,",
            "    AnsibleFilterError,",
            "    AnsibleLookupError,",
            "    AnsibleOptionsError,",
            "    AnsibleUndefinedVariable,",
            ")",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.common.text.converters import to_native, to_text, to_bytes",
            "from ansible.module_utils.common.collections import is_sequence",
            "from ansible.plugins.loader import filter_loader, lookup_loader, test_loader",
            "from ansible.template.native_helpers import ansible_native_concat, ansible_eval_concat, ansible_concat",
            "from ansible.template.template import AnsibleJ2Template",
            "from ansible.template.vars import AnsibleJ2Vars",
            "from ansible.utils.display import Display",
            "from ansible.utils.listify import listify_lookup_plugin_terms",
            "from ansible.utils.native_jinja import NativeJinjaText",
            "from ansible.utils.unsafe_proxy import to_unsafe_text, wrap_var, AnsibleUnsafeText, AnsibleUnsafeBytes, NativeJinjaUnsafeText",
            "",
            "display = Display()",
            "",
            "",
            "__all__ = ['Templar', 'generate_ansible_template_vars']",
            "",
            "# Primitive Types which we don't want Jinja to convert to strings.",
            "NON_TEMPLATED_TYPES = (bool, Number)",
            "",
            "JINJA2_OVERRIDE = '#jinja2:'",
            "",
            "JINJA2_BEGIN_TOKENS = frozenset(('variable_begin', 'block_begin', 'comment_begin', 'raw_begin'))",
            "JINJA2_END_TOKENS = frozenset(('variable_end', 'block_end', 'comment_end', 'raw_end'))",
            "",
            "RANGE_TYPE = type(range(0))",
            "",
            "",
            "def generate_ansible_template_vars(path, fullpath=None, dest_path=None):",
            "",
            "    if fullpath is None:",
            "        b_path = to_bytes(path)",
            "    else:",
            "        b_path = to_bytes(fullpath)",
            "",
            "    try:",
            "        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name",
            "    except (KeyError, TypeError):",
            "        template_uid = os.stat(b_path).st_uid",
            "",
            "    temp_vars = {",
            "        'template_host': to_unsafe_text(os.uname()[1]),",
            "        'template_path': to_unsafe_text(path),",
            "        'template_mtime': datetime.datetime.fromtimestamp(os.path.getmtime(b_path)),",
            "        'template_uid': to_unsafe_text(template_uid),",
            "        'template_run_date': datetime.datetime.now(),",
            "        'template_destpath': wrap_var(to_native(dest_path)) if dest_path else None,",
            "    }",
            "",
            "    if fullpath is None:",
            "        temp_vars['template_fullpath'] = wrap_var(os.path.abspath(path))",
            "    else:",
            "        temp_vars['template_fullpath'] = wrap_var(fullpath)",
            "",
            "    managed_default = C.DEFAULT_MANAGED_STR",
            "    managed_str = managed_default.format(",
            "        host=\"{{ template_host }}\",",
            "        uid=\"{{ template_uid }}\",",
            "        file=\"{{ template_path }}\"",
            "    )",
            "    temp_vars['ansible_managed'] = time.strftime(to_native(managed_str), time.localtime(os.path.getmtime(b_path)))",
            "",
            "    return temp_vars",
            "",
            "",
            "def _escape_backslashes(data, jinja_env):",
            "    \"\"\"Double backslashes within jinja2 expressions",
            "",
            "    A user may enter something like this in a playbook::",
            "",
            "      debug:",
            "        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"",
            "",
            "    The string inside of the {{ gets interpreted multiple times First by yaml.",
            "    Then by python.  And finally by jinja2 as part of it's variable.  Because",
            "    it is processed by both python and jinja2, the backslash escaped",
            "    characters get unescaped twice.  This means that we'd normally have to use",
            "    four backslashes to escape that.  This is painful for playbook authors as",
            "    they have to remember different rules for inside vs outside of a jinja2",
            "    expression (The backslashes outside of the \"{{ }}\" only get processed by",
            "    yaml and python.  So they only need to be escaped once).  The following",
            "    code fixes this by automatically performing the extra quoting of",
            "    backslashes inside of a jinja2 expression.",
            "",
            "    \"\"\"",
            "    if '\\\\' in data and jinja_env.variable_start_string in data:",
            "        new_data = []",
            "        d2 = jinja_env.preprocess(data)",
            "        in_var = False",
            "",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] == 'variable_begin':",
            "                in_var = True",
            "                new_data.append(token[2])",
            "            elif token[1] == 'variable_end':",
            "                in_var = False",
            "                new_data.append(token[2])",
            "            elif in_var and token[1] == 'string':",
            "                # Double backslashes only if we're inside of a jinja2 variable",
            "                new_data.append(token[2].replace('\\\\', '\\\\\\\\'))",
            "            else:",
            "                new_data.append(token[2])",
            "",
            "        data = ''.join(new_data)",
            "",
            "    return data",
            "",
            "",
            "def _create_overlay(data, overrides, jinja_env):",
            "    if overrides is None:",
            "        overrides = {}",
            "",
            "    try:",
            "        has_override_header = data.startswith(JINJA2_OVERRIDE)",
            "    except (TypeError, AttributeError):",
            "        has_override_header = False",
            "",
            "    if overrides or has_override_header:",
            "        overlay = jinja_env.overlay(**overrides)",
            "    else:",
            "        overlay = jinja_env",
            "",
            "    # Get jinja env overrides from template",
            "    if has_override_header:",
            "        eol = data.find('\\n')",
            "        line = data[len(JINJA2_OVERRIDE):eol]",
            "        data = data[eol + 1:]",
            "        for pair in line.split(','):",
            "            if ':' not in pair:",
            "                raise AnsibleError(\"failed to parse jinja2 override '%s'.\"",
            "                                   \" Did you use something different from colon as key-value separator?\" % pair.strip())",
            "            (key, val) = pair.split(':', 1)",
            "            key = key.strip()",
            "            if hasattr(overlay, key):",
            "                setattr(overlay, key, ast.literal_eval(val.strip()))",
            "            else:",
            "                display.warning(f\"Could not find Jinja2 environment setting to override: '{key}'\")",
            "",
            "    return data, overlay",
            "",
            "",
            "def is_possibly_template(data, jinja_env):",
            "    \"\"\"Determines if a string looks like a template, by seeing if it",
            "    contains a jinja2 start delimiter. Does not guarantee that the string",
            "    is actually a template.",
            "",
            "    This is different than ``is_template`` which is more strict.",
            "    This method may return ``True`` on a string that is not templatable.",
            "",
            "    Useful when guarding passing a string for templating, but when",
            "    you want to allow the templating engine to make the final",
            "    assessment which may result in ``TemplateSyntaxError``.",
            "    \"\"\"",
            "    if isinstance(data, string_types):",
            "        for marker in (jinja_env.block_start_string, jinja_env.variable_start_string, jinja_env.comment_start_string):",
            "            if marker in data:",
            "                return True",
            "    return False",
            "",
            "",
            "def is_template(data, jinja_env):",
            "    \"\"\"This function attempts to quickly detect whether a value is a jinja2",
            "    template. To do so, we look for the first 2 matching jinja2 tokens for",
            "    start and end delimiters.",
            "    \"\"\"",
            "    found = None",
            "    start = True",
            "    comment = False",
            "    d2 = jinja_env.preprocess(data)",
            "",
            "    # Quick check to see if this is remotely like a template before doing",
            "    # more expensive investigation.",
            "    if not is_possibly_template(d2, jinja_env):",
            "        return False",
            "",
            "    # This wraps a lot of code, but this is due to lex returning a generator",
            "    # so we may get an exception at any part of the loop",
            "    try:",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] in JINJA2_BEGIN_TOKENS:",
            "                if start and token[1] == 'comment_begin':",
            "                    # Comments can wrap other token types",
            "                    comment = True",
            "                start = False",
            "                # Example: variable_end -> variable",
            "                found = token[1].split('_')[0]",
            "            elif token[1] in JINJA2_END_TOKENS:",
            "                if token[1].split('_')[0] == found:",
            "                    return True",
            "                elif comment:",
            "                    continue",
            "                return False",
            "    except TemplateSyntaxError:",
            "        return False",
            "",
            "    return False",
            "",
            "",
            "def _count_newlines_from_end(in_str):",
            "    '''",
            "    Counts the number of newlines at the end of a string. This is used during",
            "    the jinja2 templating to ensure the count matches the input, since some newlines",
            "    may be thrown away during the templating.",
            "    '''",
            "",
            "    try:",
            "        i = len(in_str)",
            "        j = i - 1",
            "        while in_str[j] == '\\n':",
            "            j -= 1",
            "        return i - 1 - j",
            "    except IndexError:",
            "        # Uncommon cases: zero length string and string containing only newlines",
            "        return i",
            "",
            "",
            "def recursive_check_defined(item):",
            "    from jinja2.runtime import Undefined",
            "",
            "    if isinstance(item, MutableMapping):",
            "        for key in item:",
            "            recursive_check_defined(item[key])",
            "    elif isinstance(item, list):",
            "        for i in item:",
            "            recursive_check_defined(i)",
            "    else:",
            "        if isinstance(item, Undefined):",
            "            raise AnsibleFilterError(\"{0} is undefined\".format(item))",
            "",
            "",
            "def _is_rolled(value):",
            "    \"\"\"Helper method to determine if something is an unrolled generator,",
            "    iterator, or similar object",
            "    \"\"\"",
            "    return (",
            "        isinstance(value, Iterator) or",
            "        isinstance(value, MappingView) or",
            "        isinstance(value, RANGE_TYPE)",
            "    )",
            "",
            "",
            "def _unroll_iterator(func):",
            "    \"\"\"Wrapper function, that intercepts the result of a templating",
            "    and auto unrolls a generator, so that users are not required to",
            "    explicitly use ``|list`` to unroll.",
            "    \"\"\"",
            "    def wrapper(*args, **kwargs):",
            "        ret = func(*args, **kwargs)",
            "        if _is_rolled(ret):",
            "            return list(ret)",
            "        return ret",
            "",
            "    return functools.update_wrapper(wrapper, func)",
            "",
            "",
            "def _wrap_native_text(func):",
            "    \"\"\"Wrapper function, that intercepts the result of a filter",
            "    and wraps it into NativeJinjaText which is then used",
            "    in ``ansible_native_concat`` to indicate that it is a text",
            "    which should not be passed into ``literal_eval``.",
            "    \"\"\"",
            "    def wrapper(*args, **kwargs):",
            "        ret = func(*args, **kwargs)",
            "        return NativeJinjaText(ret)",
            "",
            "    return functools.update_wrapper(wrapper, func)",
            "",
            "",
            "class AnsibleUndefined(StrictUndefined):",
            "    '''",
            "    A custom Undefined class, which returns further Undefined objects on access,",
            "    rather than throwing an exception.",
            "    '''",
            "    def __getattr__(self, name):",
            "        if name == '__UNSAFE__':",
            "            # AnsibleUndefined should never be assumed to be unsafe",
            "            # This prevents ``hasattr(val, '__UNSAFE__')`` from evaluating to ``True``",
            "            raise AttributeError(name)",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __getitem__(self, key):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __repr__(self):",
            "        return 'AnsibleUndefined(hint={0!r}, obj={1!r}, name={2!r})'.format(",
            "            self._undefined_hint,",
            "            self._undefined_obj,",
            "            self._undefined_name",
            "        )",
            "",
            "    def __contains__(self, item):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "",
            "class AnsibleContext(Context):",
            "    '''",
            "    A custom context, which intercepts resolve_or_missing() calls and sets a flag",
            "    internally if any variable lookup returns an AnsibleUnsafe value. This",
            "    flag is checked post-templating, and (when set) will result in the",
            "    final templated result being wrapped in AnsibleUnsafe.",
            "    '''",
            "    _disallowed_callables = frozenset({",
            "        AnsibleUnsafeText._strip_unsafe.__qualname__,",
            "        AnsibleUnsafeBytes._strip_unsafe.__qualname__,",
            "        NativeJinjaUnsafeText._strip_unsafe.__qualname__,",
            "    })",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleContext, self).__init__(*args, **kwargs)",
            "        self.unsafe = False",
            "",
            "    def call(self, obj, *args, **kwargs):",
            "        if getattr(obj, '__qualname__', None) in self._disallowed_callables or obj in self._disallowed_callables:",
            "            raise SecurityError(f\"{obj!r} is not safely callable\")",
            "        return super().call(obj, *args, **kwargs)",
            "",
            "    def _is_unsafe(self, val):",
            "        '''",
            "        Our helper function, which will also recursively check dict and",
            "        list entries due to the fact that they may be repr'd and contain",
            "        a key or value which contains jinja2 syntax and would otherwise",
            "        lose the AnsibleUnsafe value.",
            "        '''",
            "        if isinstance(val, dict):",
            "            for key in val.keys():",
            "                if self._is_unsafe(val[key]):",
            "                    return True",
            "        elif isinstance(val, list):",
            "            for item in val:",
            "                if self._is_unsafe(item):",
            "                    return True",
            "        elif getattr(val, '__UNSAFE__', False) is True:",
            "            return True",
            "        return False",
            "",
            "    def _update_unsafe(self, val):",
            "        if val is not None and not self.unsafe and self._is_unsafe(val):",
            "            self.unsafe = True",
            "",
            "    def resolve_or_missing(self, key):",
            "        val = super(AnsibleContext, self).resolve_or_missing(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "    def get_all(self):",
            "        \"\"\"Return the complete context as a dict including the exported",
            "        variables. For optimizations reasons this might not return an",
            "        actual copy so be careful with using it.",
            "",
            "        This is to prevent from running ``AnsibleJ2Vars`` through dict():",
            "",
            "            ``dict(self.parent, **self.vars)``",
            "",
            "        In Ansible this means that ALL variables would be templated in the",
            "        process of re-creating the parent because ``AnsibleJ2Vars`` templates",
            "        each variable in its ``__getitem__`` method. Instead we re-create the",
            "        parent via ``AnsibleJ2Vars.add_locals`` that creates a new",
            "        ``AnsibleJ2Vars`` copy without templating each variable.",
            "",
            "        This will prevent unnecessarily templating unused variables in cases",
            "        like setting a local variable and passing it to {% include %}",
            "        in a template.",
            "",
            "        Also see ``AnsibleJ2Template``and",
            "        https://github.com/pallets/jinja/commit/d67f0fd4cc2a4af08f51f4466150d49da7798729",
            "        \"\"\"",
            "        if not self.vars:",
            "            return self.parent",
            "        if not self.parent:",
            "            return self.vars",
            "",
            "        if isinstance(self.parent, AnsibleJ2Vars):",
            "            return self.parent.add_locals(self.vars)",
            "        else:",
            "            # can this happen in Ansible?",
            "            return dict(self.parent, **self.vars)",
            "",
            "",
            "class JinjaPluginIntercept(MutableMapping):",
            "    ''' Simulated dict class that loads Jinja2Plugins at request",
            "        otherwise all plugins would need to be loaded a priori.",
            "",
            "        NOTE: plugin_loader still loads all 'builtin/legacy' at",
            "        start so only collection plugins are really at request.",
            "    '''",
            "",
            "    def __init__(self, delegatee, pluginloader, *args, **kwargs):",
            "",
            "        super(JinjaPluginIntercept, self).__init__(*args, **kwargs)",
            "",
            "        self._pluginloader = pluginloader",
            "",
            "        # Jinja environment's mapping of known names (initially just J2 builtins)",
            "        self._delegatee = delegatee",
            "",
            "        # our names take precedence over Jinja's, but let things we've tried to resolve skip the pluginloader",
            "        self._seen_it = set()",
            "",
            "    def __getitem__(self, key):",
            "",
            "        if not isinstance(key, string_types):",
            "            raise ValueError('key must be a string, got %s instead' % type(key))",
            "",
            "        original_exc = None",
            "        if key not in self._seen_it:",
            "            # this looks too early to set this- it isn't. Setting it here keeps requests for Jinja builtins from",
            "            # going through the pluginloader more than once, which is extremely slow for something that won't ever succeed.",
            "            self._seen_it.add(key)",
            "            plugin = None",
            "            try:",
            "                plugin = self._pluginloader.get(key)",
            "            except (AnsibleError, KeyError) as e:",
            "                original_exc = e",
            "            except Exception as e:",
            "                display.vvvv('Unexpected plugin load (%s) exception: %s' % (key, to_native(e)))",
            "                raise e",
            "",
            "            # if a plugin was found/loaded",
            "            if plugin:",
            "                # set in filter cache and avoid expensive plugin load",
            "                self._delegatee[key] = plugin.j2_function",
            "",
            "        # raise template syntax error if we could not find ours or jinja2 one",
            "        try:",
            "            func = self._delegatee[key]",
            "        except KeyError as e:",
            "            self._seen_it.remove(key)",
            "            raise TemplateSyntaxError('Could not load \"%s\": %s' % (key, to_native(original_exc or e)), 0)",
            "",
            "        # if i do have func and it is a filter, it needs wrapping",
            "        if self._pluginloader.type == 'filter':",
            "            # filter need wrapping",
            "            if key in C.STRING_TYPE_FILTERS:",
            "                # avoid literal_eval when you WANT strings",
            "                func = _wrap_native_text(func)",
            "            else:",
            "                # conditionally unroll iterators/generators to avoid having to use `|list` after every filter",
            "                func = _unroll_iterator(func)",
            "",
            "        return func",
            "",
            "    def __setitem__(self, key, value):",
            "        return self._delegatee.__setitem__(key, value)",
            "",
            "    def __delitem__(self, key):",
            "        raise NotImplementedError()",
            "",
            "    def __iter__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return iter(self._delegatee)",
            "",
            "    def __len__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return len(self._delegatee)",
            "",
            "",
            "def _fail_on_undefined(data):",
            "    \"\"\"Recursively find an undefined value in a nested data structure",
            "    and properly raise the undefined exception.",
            "    \"\"\"",
            "    if isinstance(data, Mapping):",
            "        for value in data.values():",
            "            _fail_on_undefined(value)",
            "    elif is_sequence(data):",
            "        for item in data:",
            "            _fail_on_undefined(item)",
            "    else:",
            "        if isinstance(data, StrictUndefined):",
            "            # To actually raise the undefined exception we need to",
            "            # access the undefined object otherwise the exception would",
            "            # be raised on the next access which might not be properly",
            "            # handled.",
            "            # See https://github.com/ansible/ansible/issues/52158",
            "            # and StrictUndefined implementation in upstream Jinja2.",
            "            str(data)",
            "    return data",
            "",
            "",
            "@_unroll_iterator",
            "def _ansible_finalize(thing):",
            "    \"\"\"A custom finalize function for jinja2, which prevents None from being",
            "    returned. This avoids a string of ``\"None\"`` as ``None`` has no",
            "    importance in YAML.",
            "",
            "    The function is decorated with ``_unroll_iterator`` so that users are not",
            "    required to explicitly use ``|list`` to unroll a generator. This only",
            "    affects the scenario where the final result of templating",
            "    is a generator, e.g. ``range``, ``dict.items()`` and so on. Filters",
            "    which can produce a generator in the middle of a template are already",
            "    wrapped with ``_unroll_generator`` in ``JinjaPluginIntercept``.",
            "    \"\"\"",
            "    return thing if _fail_on_undefined(thing) is not None else ''",
            "",
            "",
            "class AnsibleEnvironment(NativeEnvironment):",
            "    '''",
            "    Our custom environment, which simply allows us to override the class-level",
            "    values for the Template and Context classes used by jinja2 internally.",
            "    '''",
            "    context_class = AnsibleContext",
            "    template_class = AnsibleJ2Template",
            "    concat = staticmethod(ansible_eval_concat)  # type: ignore[assignment]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.filters = JinjaPluginIntercept(self.filters, filter_loader)",
            "        self.tests = JinjaPluginIntercept(self.tests, test_loader)",
            "",
            "        self.trim_blocks = True",
            "",
            "        self.undefined = AnsibleUndefined",
            "        self.finalize = _ansible_finalize",
            "",
            "",
            "class AnsibleNativeEnvironment(AnsibleEnvironment):",
            "    concat = staticmethod(ansible_native_concat)  # type: ignore[assignment]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.finalize = _unroll_iterator(_fail_on_undefined)",
            "",
            "",
            "class Templar:",
            "    '''",
            "    The main class for templating, with the main entry-point of template().",
            "    '''",
            "",
            "    def __init__(self, loader, variables=None):",
            "        self._loader = loader",
            "        self._available_variables = {} if variables is None else variables",
            "",
            "        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR",
            "",
            "        environment_class = AnsibleNativeEnvironment if C.DEFAULT_JINJA2_NATIVE else AnsibleEnvironment",
            "",
            "        self.environment = environment_class(",
            "            extensions=self._get_extensions(),",
            "            loader=FileSystemLoader(loader.get_basedir() if loader else '.'),",
            "        )",
            "        self.environment.template_class.environment_class = environment_class",
            "",
            "        # Custom globals",
            "        self.environment.globals['lookup'] = self._lookup",
            "        self.environment.globals['query'] = self.environment.globals['q'] = self._query_lookup",
            "        self.environment.globals['now'] = self._now_datetime",
            "        self.environment.globals['undef'] = self._make_undefined",
            "",
            "        # the current rendering context under which the templar class is working",
            "        self.cur_context = None",
            "",
            "        # this regex is re-compiled each time variable_start_string and variable_end_string are possibly changed",
            "        self._compile_single_var(self.environment)",
            "",
            "        self.jinja2_native = C.DEFAULT_JINJA2_NATIVE",
            "",
            "    def _compile_single_var(self, env):",
            "        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (env.variable_start_string, env.variable_end_string))",
            "",
            "    def copy_with_new_env(self, environment_class=AnsibleEnvironment, **kwargs):",
            "        r\"\"\"Creates a new copy of Templar with a new environment.",
            "",
            "        :kwarg environment_class: Environment class used for creating a new environment.",
            "        :kwarg \\*\\*kwargs: Optional arguments for the new environment that override existing",
            "            environment attributes.",
            "",
            "        :returns: Copy of Templar with updated environment.",
            "        \"\"\"",
            "        # We need to use __new__ to skip __init__, mainly not to create a new",
            "        # environment there only to override it below",
            "        new_env = object.__new__(environment_class)",
            "        new_env.__dict__.update(self.environment.__dict__)",
            "",
            "        new_templar = object.__new__(Templar)",
            "        new_templar.__dict__.update(self.__dict__)",
            "        new_templar.environment = new_env",
            "",
            "        new_templar.jinja2_native = environment_class is AnsibleNativeEnvironment",
            "",
            "        mapping = {",
            "            'available_variables': new_templar,",
            "            'searchpath': new_env.loader,",
            "        }",
            "",
            "        for key, value in kwargs.items():",
            "            obj = mapping.get(key, new_env)",
            "            try:",
            "                if value is not None:",
            "                    setattr(obj, key, value)",
            "            except AttributeError:",
            "                # Ignore invalid attrs",
            "                pass",
            "",
            "        return new_templar",
            "",
            "    def _get_extensions(self):",
            "        '''",
            "        Return jinja2 extensions to load.",
            "",
            "        If some extensions are set via jinja_extensions in ansible.cfg, we try",
            "        to load them with the jinja environment.",
            "        '''",
            "",
            "        jinja_exts = []",
            "        if C.DEFAULT_JINJA2_EXTENSIONS:",
            "            # make sure the configuration directive doesn't contain spaces",
            "            # and split extensions in an array",
            "            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')",
            "",
            "        return jinja_exts",
            "",
            "    @property",
            "    def available_variables(self):",
            "        return self._available_variables",
            "",
            "    @available_variables.setter",
            "    def available_variables(self, variables):",
            "        '''",
            "        Sets the list of template variables this Templar instance will use",
            "        to template things, so we don't have to pass them around between",
            "        internal methods. We also clear the template cache here, as the variables",
            "        are being changed.",
            "        '''",
            "",
            "        if not isinstance(variables, Mapping):",
            "            raise AnsibleAssertionError(\"the type of 'variables' should be a Mapping but was a %s\" % (type(variables)))",
            "        self._available_variables = variables",
            "",
            "    @contextmanager",
            "    def set_temporary_context(self, **kwargs):",
            "        \"\"\"Context manager used to set temporary templating context, without having to worry about resetting",
            "        original values afterward",
            "",
            "        Use a keyword that maps to the attr you are setting. Applies to ``self.environment`` by default, to",
            "        set context on another object, it must be in ``mapping``.",
            "        \"\"\"",
            "        mapping = {",
            "            'available_variables': self,",
            "            'searchpath': self.environment.loader,",
            "        }",
            "        original = {}",
            "",
            "        for key, value in kwargs.items():",
            "            obj = mapping.get(key, self.environment)",
            "            try:",
            "                original[key] = getattr(obj, key)",
            "                if value is not None:",
            "                    setattr(obj, key, value)",
            "            except AttributeError:",
            "                # Ignore invalid attrs",
            "                pass",
            "",
            "        yield",
            "",
            "        for key in original:",
            "            obj = mapping.get(key, self.environment)",
            "            setattr(obj, key, original[key])",
            "",
            "    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None,",
            "                 convert_data=True, static_vars=None, disable_lookups=False):",
            "        '''",
            "        Templates (possibly recursively) any given data as input. If convert_bare is",
            "        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')",
            "        before being sent through the template engine.",
            "        '''",
            "        static_vars = [] if static_vars is None else static_vars",
            "",
            "        # Don't template unsafe variables, just return them.",
            "        if hasattr(variable, '__UNSAFE__'):",
            "            return variable",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        if convert_bare:",
            "            variable = self._convert_bare_variable(variable)",
            "",
            "        if isinstance(variable, string_types):",
            "            if not self.is_possibly_template(variable, overrides):",
            "                return variable",
            "",
            "            # Check to see if the string we are trying to render is just referencing a single",
            "            # var.  In this case we don't want to accidentally change the type of the variable",
            "            # to a string by using the jinja template renderer. We just want to pass it.",
            "            only_one = self.SINGLE_VAR.match(variable)",
            "            if only_one:",
            "                var_name = only_one.group(1)",
            "                if var_name in self._available_variables:",
            "                    resolved_val = self._available_variables[var_name]",
            "                    if isinstance(resolved_val, NON_TEMPLATED_TYPES):",
            "                        return resolved_val",
            "                    elif resolved_val is None:",
            "                        return C.DEFAULT_NULL_REPRESENTATION",
            "",
            "            result = self.do_template(",
            "                variable,",
            "                preserve_trailing_newlines=preserve_trailing_newlines,",
            "                escape_backslashes=escape_backslashes,",
            "                fail_on_undefined=fail_on_undefined,",
            "                overrides=overrides,",
            "                disable_lookups=disable_lookups,",
            "                convert_data=convert_data,",
            "            )",
            "            self._compile_single_var(self.environment)",
            "",
            "            return result",
            "",
            "        elif is_sequence(variable):",
            "            return [self.template(",
            "                v,",
            "                preserve_trailing_newlines=preserve_trailing_newlines,",
            "                fail_on_undefined=fail_on_undefined,",
            "                overrides=overrides,",
            "                disable_lookups=disable_lookups,",
            "            ) for v in variable]",
            "        elif isinstance(variable, Mapping):",
            "            d = {}",
            "            # we don't use iteritems() here to avoid problems if the underlying dict",
            "            # changes sizes due to the templating, which can happen with hostvars",
            "            for k in variable.keys():",
            "                if k not in static_vars:",
            "                    d[k] = self.template(",
            "                        variable[k],",
            "                        preserve_trailing_newlines=preserve_trailing_newlines,",
            "                        fail_on_undefined=fail_on_undefined,",
            "                        overrides=overrides,",
            "                        disable_lookups=disable_lookups,",
            "                    )",
            "                else:",
            "                    d[k] = variable[k]",
            "            return d",
            "        else:",
            "            return variable",
            "",
            "    def is_template(self, data):",
            "        '''lets us know if data has a template'''",
            "        if isinstance(data, string_types):",
            "            return is_template(data, self.environment)",
            "        elif isinstance(data, (list, tuple)):",
            "            for v in data:",
            "                if self.is_template(v):",
            "                    return True",
            "        elif isinstance(data, dict):",
            "            for k in data:",
            "                if self.is_template(k) or self.is_template(data[k]):",
            "                    return True",
            "        return False",
            "",
            "    templatable = is_template",
            "",
            "    def is_possibly_template(self, data, overrides=None):",
            "        data, env = _create_overlay(data, overrides, self.environment)",
            "        return is_possibly_template(data, env)",
            "",
            "    def _convert_bare_variable(self, variable):",
            "        '''",
            "        Wraps a bare string, which may have an attribute portion (ie. foo.bar)",
            "        in jinja2 variable braces so that it is evaluated properly.",
            "        '''",
            "",
            "        if isinstance(variable, string_types):",
            "            contains_filters = \"|\" in variable",
            "            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]",
            "            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:",
            "                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)",
            "",
            "        # the variable didn't meet the conditions to be converted,",
            "        # so just return it as-is",
            "        return variable",
            "",
            "    def _fail_lookup(self, name, *args, **kwargs):",
            "        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)",
            "",
            "    def _now_datetime(self, utc=False, fmt=None):",
            "        '''jinja2 global function to return current datetime, potentially formatted via strftime'''",
            "        if utc:",
            "            now = datetime.datetime.now(datetime.timezone.utc).replace(tzinfo=None)",
            "        else:",
            "            now = datetime.datetime.now()",
            "",
            "        if fmt:",
            "            return now.strftime(fmt)",
            "",
            "        return now",
            "",
            "    def _query_lookup(self, name, /, *args, **kwargs):",
            "        ''' wrapper for lookup, force wantlist true'''",
            "        kwargs['wantlist'] = True",
            "        return self._lookup(name, *args, **kwargs)",
            "",
            "    def _lookup(self, name, /, *args, **kwargs):",
            "        instance = lookup_loader.get(name, loader=self._loader, templar=self)",
            "",
            "        if instance is None:",
            "            raise AnsibleError(\"lookup plugin (%s) not found\" % name)",
            "",
            "        wantlist = kwargs.pop('wantlist', False)",
            "        allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)",
            "        errors = kwargs.pop('errors', 'strict')",
            "",
            "        loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, fail_on_undefined=True, convert_bare=False)",
            "        # safely catch run failures per #5059",
            "        try:",
            "            ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)",
            "        except (AnsibleUndefinedVariable, UndefinedError) as e:",
            "            raise AnsibleUndefinedVariable(e)",
            "        except AnsibleOptionsError as e:",
            "            # invalid options given to lookup, just reraise",
            "            raise e",
            "        except AnsibleLookupError as e:",
            "            # lookup handled error but still decided to bail",
            "            msg = 'Lookup failed but the error is being ignored: %s' % to_native(e)",
            "            if errors == 'warn':",
            "                display.warning(msg)",
            "            elif errors == 'ignore':",
            "                display.display(msg, log_only=True)",
            "            else:",
            "                raise e",
            "            return [] if wantlist else None",
            "        except Exception as e:",
            "            # errors not handled by lookup",
            "            msg = u\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % \\",
            "                  (name, type(e), to_text(e))",
            "            if errors == 'warn':",
            "                display.warning(msg)",
            "            elif errors == 'ignore':",
            "                display.display(msg, log_only=True)",
            "            else:",
            "                display.vvv('exception during Jinja2 execution: {0}'.format(format_exc()))",
            "                raise AnsibleError(to_native(msg), orig_exc=e)",
            "            return [] if wantlist else None",
            "",
            "        if not is_sequence(ran):",
            "            raise AnsibleLookupError(",
            "                f'The lookup plugin \\'{name}\\' was expected to return a list, got \\'{type(ran)}\\' instead. '",
            "                f'The lookup plugin \\'{name}\\' needs to be changed to return a list. '",
            "            )",
            "",
            "        if ran and allow_unsafe is False:",
            "            if self.cur_context:",
            "                self.cur_context.unsafe = True",
            "",
            "            if wantlist:",
            "                return wrap_var(ran)",
            "",
            "            try:",
            "                if isinstance(ran[0], NativeJinjaText):",
            "                    ran = wrap_var(NativeJinjaText(\",\".join(ran)))",
            "                else:",
            "                    ran = wrap_var(\",\".join(ran))",
            "            except TypeError:",
            "                # Lookup Plugins should always return lists.  Throw an error if that's not",
            "                # the case:",
            "                if not isinstance(ran, Sequence):",
            "                    raise AnsibleError(\"The lookup plugin '%s' did not return a list.\"",
            "                                       % name)",
            "",
            "                # The TypeError we can recover from is when the value *inside* of the list",
            "                # is not a string",
            "                if len(ran) == 1:",
            "                    ran = wrap_var(ran[0])",
            "                else:",
            "                    ran = wrap_var(ran)",
            "            except KeyError:",
            "                # Lookup Plugin returned a dict.  Return comma-separated string of keys",
            "                # for backwards compat.",
            "                # FIXME this can be removed when support for non-list return types is removed.",
            "                # See https://github.com/ansible/ansible/pull/77789",
            "                ran = wrap_var(\",\".join(ran))",
            "",
            "        return ran",
            "",
            "    def _make_undefined(self, hint=None):",
            "        from jinja2.runtime import Undefined",
            "",
            "        if hint is None or isinstance(hint, Undefined) or hint == '':",
            "            hint = \"Mandatory variable has not been overridden\"",
            "        return AnsibleUndefined(hint)",
            "",
            "    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False,",
            "                    convert_data=False):",
            "        if self.jinja2_native and not isinstance(data, string_types):",
            "            return data",
            "",
            "        # For preserving the number of input newlines in the output (used",
            "        # later in this method)",
            "        data_newlines = _count_newlines_from_end(data)",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            # NOTE Creating an overlay that lives only inside do_template means that overrides are not applied",
            "            # when templating nested variables in AnsibleJ2Vars where Templar.environment is used, not the overlay.",
            "            data, myenv = _create_overlay(data, overrides, self.environment)",
            "            # in case delimiters change",
            "            self._compile_single_var(myenv)",
            "",
            "            if escape_backslashes:",
            "                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".",
            "                data = _escape_backslashes(data, myenv)",
            "",
            "            try:",
            "                t = myenv.from_string(data)",
            "            except (TemplateSyntaxError, SyntaxError) as e:",
            "                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)), orig_exc=e)",
            "            except Exception as e:",
            "                if 'recursion' in to_native(e):",
            "                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data), orig_exc=e)",
            "                else:",
            "                    return data",
            "",
            "            if disable_lookups:",
            "                t.globals['query'] = t.globals['q'] = t.globals['lookup'] = self._fail_lookup",
            "",
            "            jvars = AnsibleJ2Vars(self, t.globals)",
            "",
            "            # In case this is a recursive call to do_template we need to",
            "            # save/restore cur_context to prevent overriding __UNSAFE__.",
            "            cached_context = self.cur_context",
            "",
            "            # In case this is a recursive call and we set different concat",
            "            # function up the stack, reset it in case the value of convert_data",
            "            # changed in this call",
            "            myenv.concat = myenv.__class__.concat",
            "            # the concat function is set for each Ansible environment,",
            "            # however for convert_data=False we need to use the concat",
            "            # function that avoids any evaluation and set it temporarily",
            "            # on the environment so it is used correctly even when",
            "            # the concat function is called internally in Jinja,",
            "            # most notably for macro execution",
            "            if not self.jinja2_native and not convert_data:",
            "                myenv.concat = ansible_concat",
            "",
            "            self.cur_context = t.new_context(jvars, shared=True)",
            "            rf = t.root_render_func(self.cur_context)",
            "",
            "            try:",
            "                res = myenv.concat(rf)",
            "                unsafe = getattr(self.cur_context, 'unsafe', False)",
            "                if unsafe:",
            "                    res = wrap_var(res)",
            "            except TypeError as te:",
            "                if 'AnsibleUndefined' in to_native(te):",
            "                    errmsg = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)",
            "                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)",
            "                    raise AnsibleUndefinedVariable(errmsg, orig_exc=te)",
            "                else:",
            "                    display.debug(\"failing because of a type error, template data is: %s\" % to_text(data))",
            "                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data), to_native(te)), orig_exc=te)",
            "            finally:",
            "                self.cur_context = cached_context",
            "",
            "            if isinstance(res, string_types) and preserve_trailing_newlines:",
            "                # The low level calls above do not preserve the newline",
            "                # characters at the end of the input data, so we use the",
            "                # calculate the difference in newlines and append them",
            "                # to the resulting output for parity",
            "                #",
            "                # Using Environment's keep_trailing_newline instead would",
            "                # result in change in behavior when trailing newlines",
            "                # would be kept also for included templates, for example:",
            "                # \"Hello {% include 'world.txt' %}!\" would render as",
            "                # \"Hello world\\n!\\n\" instead of \"Hello world!\\n\".",
            "                res_newlines = _count_newlines_from_end(res)",
            "                if data_newlines > res_newlines:",
            "                    res += myenv.newline_sequence * (data_newlines - res_newlines)",
            "                    if unsafe:",
            "                        res = wrap_var(res)",
            "            return res",
            "        except UndefinedError as e:",
            "            if fail_on_undefined:",
            "                raise AnsibleUndefinedVariable(e)",
            "            display.debug(\"Ignoring undefined failure: %s\" % to_text(e))",
            "            return data",
            "        except AnsibleUndefinedVariable as e:",
            "            if fail_on_undefined:",
            "                raise",
            "            display.debug(\"Ignoring undefined failure: %s\" % to_text(e))",
            "            return data",
            "",
            "    # for backwards compatibility in case anyone is using old private method directly",
            "    _do_template = do_template"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from __future__ import annotations",
            "",
            "import ast",
            "import datetime",
            "import functools",
            "import os",
            "import pwd",
            "import re",
            "import time",
            "",
            "from collections.abc import Iterator, Sequence, Mapping, MappingView, MutableMapping",
            "from contextlib import contextmanager",
            "from numbers import Number",
            "from traceback import format_exc",
            "",
            "from jinja2.exceptions import TemplateSyntaxError, UndefinedError, SecurityError",
            "from jinja2.loaders import FileSystemLoader",
            "from jinja2.nativetypes import NativeEnvironment",
            "from jinja2.runtime import Context, StrictUndefined",
            "",
            "from ansible import constants as C",
            "from ansible.errors import (",
            "    AnsibleAssertionError,",
            "    AnsibleError,",
            "    AnsibleFilterError,",
            "    AnsibleLookupError,",
            "    AnsibleOptionsError,",
            "    AnsibleUndefinedVariable,",
            ")",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.common.text.converters import to_native, to_text, to_bytes",
            "from ansible.module_utils.common.collections import is_sequence",
            "from ansible.plugins.loader import filter_loader, lookup_loader, test_loader",
            "from ansible.template.native_helpers import AnsibleUndefined, ansible_native_concat, ansible_eval_concat, ansible_concat",
            "from ansible.template.template import AnsibleJ2Template",
            "from ansible.template.vars import AnsibleJ2Vars",
            "from ansible.utils.display import Display",
            "from ansible.utils.listify import listify_lookup_plugin_terms",
            "from ansible.utils.native_jinja import NativeJinjaText",
            "from ansible.utils.unsafe_proxy import to_unsafe_text, wrap_var, AnsibleUnsafeText, AnsibleUnsafeBytes, NativeJinjaUnsafeText",
            "",
            "display = Display()",
            "",
            "",
            "__all__ = ['Templar', 'generate_ansible_template_vars']",
            "",
            "# Primitive Types which we don't want Jinja to convert to strings.",
            "NON_TEMPLATED_TYPES = (bool, Number)",
            "",
            "JINJA2_OVERRIDE = '#jinja2:'",
            "",
            "JINJA2_BEGIN_TOKENS = frozenset(('variable_begin', 'block_begin', 'comment_begin', 'raw_begin'))",
            "JINJA2_END_TOKENS = frozenset(('variable_end', 'block_end', 'comment_end', 'raw_end'))",
            "",
            "RANGE_TYPE = type(range(0))",
            "",
            "",
            "def generate_ansible_template_vars(path, fullpath=None, dest_path=None):",
            "",
            "    if fullpath is None:",
            "        b_path = to_bytes(path)",
            "    else:",
            "        b_path = to_bytes(fullpath)",
            "",
            "    try:",
            "        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name",
            "    except (KeyError, TypeError):",
            "        template_uid = os.stat(b_path).st_uid",
            "",
            "    temp_vars = {",
            "        'template_host': to_unsafe_text(os.uname()[1]),",
            "        'template_path': to_unsafe_text(path),",
            "        'template_mtime': datetime.datetime.fromtimestamp(os.path.getmtime(b_path)),",
            "        'template_uid': to_unsafe_text(template_uid),",
            "        'template_run_date': datetime.datetime.now(),",
            "        'template_destpath': wrap_var(to_native(dest_path)) if dest_path else None,",
            "    }",
            "",
            "    if fullpath is None:",
            "        temp_vars['template_fullpath'] = wrap_var(os.path.abspath(path))",
            "    else:",
            "        temp_vars['template_fullpath'] = wrap_var(fullpath)",
            "",
            "    managed_default = C.DEFAULT_MANAGED_STR",
            "    managed_str = managed_default.format(",
            "        host=\"{{ template_host }}\",",
            "        uid=\"{{ template_uid }}\",",
            "        file=\"{{ template_path }}\"",
            "    )",
            "    temp_vars['ansible_managed'] = time.strftime(to_native(managed_str), time.localtime(os.path.getmtime(b_path)))",
            "",
            "    return temp_vars",
            "",
            "",
            "def _escape_backslashes(data, jinja_env):",
            "    \"\"\"Double backslashes within jinja2 expressions",
            "",
            "    A user may enter something like this in a playbook::",
            "",
            "      debug:",
            "        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"",
            "",
            "    The string inside of the {{ gets interpreted multiple times First by yaml.",
            "    Then by python.  And finally by jinja2 as part of it's variable.  Because",
            "    it is processed by both python and jinja2, the backslash escaped",
            "    characters get unescaped twice.  This means that we'd normally have to use",
            "    four backslashes to escape that.  This is painful for playbook authors as",
            "    they have to remember different rules for inside vs outside of a jinja2",
            "    expression (The backslashes outside of the \"{{ }}\" only get processed by",
            "    yaml and python.  So they only need to be escaped once).  The following",
            "    code fixes this by automatically performing the extra quoting of",
            "    backslashes inside of a jinja2 expression.",
            "",
            "    \"\"\"",
            "    if '\\\\' in data and jinja_env.variable_start_string in data:",
            "        new_data = []",
            "        d2 = jinja_env.preprocess(data)",
            "        in_var = False",
            "",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] == 'variable_begin':",
            "                in_var = True",
            "                new_data.append(token[2])",
            "            elif token[1] == 'variable_end':",
            "                in_var = False",
            "                new_data.append(token[2])",
            "            elif in_var and token[1] == 'string':",
            "                # Double backslashes only if we're inside of a jinja2 variable",
            "                new_data.append(token[2].replace('\\\\', '\\\\\\\\'))",
            "            else:",
            "                new_data.append(token[2])",
            "",
            "        data = ''.join(new_data)",
            "",
            "    return data",
            "",
            "",
            "def _create_overlay(data, overrides, jinja_env):",
            "    if overrides is None:",
            "        overrides = {}",
            "",
            "    try:",
            "        has_override_header = data.startswith(JINJA2_OVERRIDE)",
            "    except (TypeError, AttributeError):",
            "        has_override_header = False",
            "",
            "    if overrides or has_override_header:",
            "        overlay = jinja_env.overlay(**overrides)",
            "    else:",
            "        overlay = jinja_env",
            "",
            "    # Get jinja env overrides from template",
            "    if has_override_header:",
            "        eol = data.find('\\n')",
            "        line = data[len(JINJA2_OVERRIDE):eol]",
            "        data = data[eol + 1:]",
            "        for pair in line.split(','):",
            "            if ':' not in pair:",
            "                raise AnsibleError(\"failed to parse jinja2 override '%s'.\"",
            "                                   \" Did you use something different from colon as key-value separator?\" % pair.strip())",
            "            (key, val) = pair.split(':', 1)",
            "            key = key.strip()",
            "            if hasattr(overlay, key):",
            "                setattr(overlay, key, ast.literal_eval(val.strip()))",
            "            else:",
            "                display.warning(f\"Could not find Jinja2 environment setting to override: '{key}'\")",
            "",
            "    return data, overlay",
            "",
            "",
            "def is_possibly_template(data, jinja_env):",
            "    \"\"\"Determines if a string looks like a template, by seeing if it",
            "    contains a jinja2 start delimiter. Does not guarantee that the string",
            "    is actually a template.",
            "",
            "    This is different than ``is_template`` which is more strict.",
            "    This method may return ``True`` on a string that is not templatable.",
            "",
            "    Useful when guarding passing a string for templating, but when",
            "    you want to allow the templating engine to make the final",
            "    assessment which may result in ``TemplateSyntaxError``.",
            "    \"\"\"",
            "    if isinstance(data, string_types):",
            "        for marker in (jinja_env.block_start_string, jinja_env.variable_start_string, jinja_env.comment_start_string):",
            "            if marker in data:",
            "                return True",
            "    return False",
            "",
            "",
            "def is_template(data, jinja_env):",
            "    \"\"\"This function attempts to quickly detect whether a value is a jinja2",
            "    template. To do so, we look for the first 2 matching jinja2 tokens for",
            "    start and end delimiters.",
            "    \"\"\"",
            "    found = None",
            "    start = True",
            "    comment = False",
            "    d2 = jinja_env.preprocess(data)",
            "",
            "    # Quick check to see if this is remotely like a template before doing",
            "    # more expensive investigation.",
            "    if not is_possibly_template(d2, jinja_env):",
            "        return False",
            "",
            "    # This wraps a lot of code, but this is due to lex returning a generator",
            "    # so we may get an exception at any part of the loop",
            "    try:",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] in JINJA2_BEGIN_TOKENS:",
            "                if start and token[1] == 'comment_begin':",
            "                    # Comments can wrap other token types",
            "                    comment = True",
            "                start = False",
            "                # Example: variable_end -> variable",
            "                found = token[1].split('_')[0]",
            "            elif token[1] in JINJA2_END_TOKENS:",
            "                if token[1].split('_')[0] == found:",
            "                    return True",
            "                elif comment:",
            "                    continue",
            "                return False",
            "    except TemplateSyntaxError:",
            "        return False",
            "",
            "    return False",
            "",
            "",
            "def _count_newlines_from_end(in_str):",
            "    '''",
            "    Counts the number of newlines at the end of a string. This is used during",
            "    the jinja2 templating to ensure the count matches the input, since some newlines",
            "    may be thrown away during the templating.",
            "    '''",
            "",
            "    try:",
            "        i = len(in_str)",
            "        j = i - 1",
            "        while in_str[j] == '\\n':",
            "            j -= 1",
            "        return i - 1 - j",
            "    except IndexError:",
            "        # Uncommon cases: zero length string and string containing only newlines",
            "        return i",
            "",
            "",
            "def recursive_check_defined(item):",
            "    from jinja2.runtime import Undefined",
            "",
            "    if isinstance(item, MutableMapping):",
            "        for key in item:",
            "            recursive_check_defined(item[key])",
            "    elif isinstance(item, list):",
            "        for i in item:",
            "            recursive_check_defined(i)",
            "    else:",
            "        if isinstance(item, Undefined):",
            "            raise AnsibleFilterError(\"{0} is undefined\".format(item))",
            "",
            "",
            "def _is_rolled(value):",
            "    \"\"\"Helper method to determine if something is an unrolled generator,",
            "    iterator, or similar object",
            "    \"\"\"",
            "    return (",
            "        isinstance(value, Iterator) or",
            "        isinstance(value, MappingView) or",
            "        isinstance(value, RANGE_TYPE)",
            "    )",
            "",
            "",
            "def _unroll_iterator(func):",
            "    \"\"\"Wrapper function, that intercepts the result of a templating",
            "    and auto unrolls a generator, so that users are not required to",
            "    explicitly use ``|list`` to unroll.",
            "    \"\"\"",
            "    def wrapper(*args, **kwargs):",
            "        ret = func(*args, **kwargs)",
            "        if _is_rolled(ret):",
            "            return list(ret)",
            "        return ret",
            "",
            "    return functools.update_wrapper(wrapper, func)",
            "",
            "",
            "def _wrap_native_text(func):",
            "    \"\"\"Wrapper function, that intercepts the result of a filter",
            "    and wraps it into NativeJinjaText which is then used",
            "    in ``ansible_native_concat`` to indicate that it is a text",
            "    which should not be passed into ``literal_eval``.",
            "    \"\"\"",
            "    def wrapper(*args, **kwargs):",
            "        ret = func(*args, **kwargs)",
            "        return NativeJinjaText(ret)",
            "",
            "    return functools.update_wrapper(wrapper, func)",
            "",
            "",
            "class AnsibleContext(Context):",
            "    '''",
            "    A custom context, which intercepts resolve_or_missing() calls and sets a flag",
            "    internally if any variable lookup returns an AnsibleUnsafe value. This",
            "    flag is checked post-templating, and (when set) will result in the",
            "    final templated result being wrapped in AnsibleUnsafe.",
            "    '''",
            "    _disallowed_callables = frozenset({",
            "        AnsibleUnsafeText._strip_unsafe.__qualname__,",
            "        AnsibleUnsafeBytes._strip_unsafe.__qualname__,",
            "        NativeJinjaUnsafeText._strip_unsafe.__qualname__,",
            "    })",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleContext, self).__init__(*args, **kwargs)",
            "        self.unsafe = False",
            "",
            "    def call(self, obj, *args, **kwargs):",
            "        if getattr(obj, '__qualname__', None) in self._disallowed_callables or obj in self._disallowed_callables:",
            "            raise SecurityError(f\"{obj!r} is not safely callable\")",
            "        return super().call(obj, *args, **kwargs)",
            "",
            "    def _is_unsafe(self, val):",
            "        '''",
            "        Our helper function, which will also recursively check dict and",
            "        list entries due to the fact that they may be repr'd and contain",
            "        a key or value which contains jinja2 syntax and would otherwise",
            "        lose the AnsibleUnsafe value.",
            "        '''",
            "        if isinstance(val, dict):",
            "            for key in val.keys():",
            "                if self._is_unsafe(val[key]):",
            "                    return True",
            "        elif isinstance(val, list):",
            "            for item in val:",
            "                if self._is_unsafe(item):",
            "                    return True",
            "        elif getattr(val, '__UNSAFE__', False) is True:",
            "            return True",
            "        return False",
            "",
            "    def _update_unsafe(self, val):",
            "        if val is not None and not self.unsafe and self._is_unsafe(val):",
            "            self.unsafe = True",
            "",
            "    def resolve_or_missing(self, key):",
            "        val = super(AnsibleContext, self).resolve_or_missing(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "    def get_all(self):",
            "        \"\"\"Return the complete context as a dict including the exported",
            "        variables. For optimizations reasons this might not return an",
            "        actual copy so be careful with using it.",
            "",
            "        This is to prevent from running ``AnsibleJ2Vars`` through dict():",
            "",
            "            ``dict(self.parent, **self.vars)``",
            "",
            "        In Ansible this means that ALL variables would be templated in the",
            "        process of re-creating the parent because ``AnsibleJ2Vars`` templates",
            "        each variable in its ``__getitem__`` method. Instead we re-create the",
            "        parent via ``AnsibleJ2Vars.add_locals`` that creates a new",
            "        ``AnsibleJ2Vars`` copy without templating each variable.",
            "",
            "        This will prevent unnecessarily templating unused variables in cases",
            "        like setting a local variable and passing it to {% include %}",
            "        in a template.",
            "",
            "        Also see ``AnsibleJ2Template``and",
            "        https://github.com/pallets/jinja/commit/d67f0fd4cc2a4af08f51f4466150d49da7798729",
            "        \"\"\"",
            "        if not self.vars:",
            "            return self.parent",
            "        if not self.parent:",
            "            return self.vars",
            "",
            "        if isinstance(self.parent, AnsibleJ2Vars):",
            "            return self.parent.add_locals(self.vars)",
            "        else:",
            "            # can this happen in Ansible?",
            "            return dict(self.parent, **self.vars)",
            "",
            "",
            "class JinjaPluginIntercept(MutableMapping):",
            "    ''' Simulated dict class that loads Jinja2Plugins at request",
            "        otherwise all plugins would need to be loaded a priori.",
            "",
            "        NOTE: plugin_loader still loads all 'builtin/legacy' at",
            "        start so only collection plugins are really at request.",
            "    '''",
            "",
            "    def __init__(self, delegatee, pluginloader, *args, **kwargs):",
            "",
            "        super(JinjaPluginIntercept, self).__init__(*args, **kwargs)",
            "",
            "        self._pluginloader = pluginloader",
            "",
            "        # Jinja environment's mapping of known names (initially just J2 builtins)",
            "        self._delegatee = delegatee",
            "",
            "        # our names take precedence over Jinja's, but let things we've tried to resolve skip the pluginloader",
            "        self._seen_it = set()",
            "",
            "    def __getitem__(self, key):",
            "",
            "        if not isinstance(key, string_types):",
            "            raise ValueError('key must be a string, got %s instead' % type(key))",
            "",
            "        original_exc = None",
            "        if key not in self._seen_it:",
            "            # this looks too early to set this- it isn't. Setting it here keeps requests for Jinja builtins from",
            "            # going through the pluginloader more than once, which is extremely slow for something that won't ever succeed.",
            "            self._seen_it.add(key)",
            "            plugin = None",
            "            try:",
            "                plugin = self._pluginloader.get(key)",
            "            except (AnsibleError, KeyError) as e:",
            "                original_exc = e",
            "            except Exception as e:",
            "                display.vvvv('Unexpected plugin load (%s) exception: %s' % (key, to_native(e)))",
            "                raise e",
            "",
            "            # if a plugin was found/loaded",
            "            if plugin:",
            "                # set in filter cache and avoid expensive plugin load",
            "                self._delegatee[key] = plugin.j2_function",
            "",
            "        # raise template syntax error if we could not find ours or jinja2 one",
            "        try:",
            "            func = self._delegatee[key]",
            "        except KeyError as e:",
            "            self._seen_it.remove(key)",
            "            raise TemplateSyntaxError('Could not load \"%s\": %s' % (key, to_native(original_exc or e)), 0)",
            "",
            "        # if i do have func and it is a filter, it needs wrapping",
            "        if self._pluginloader.type == 'filter':",
            "            # filter need wrapping",
            "            if key in C.STRING_TYPE_FILTERS:",
            "                # avoid literal_eval when you WANT strings",
            "                func = _wrap_native_text(func)",
            "            else:",
            "                # conditionally unroll iterators/generators to avoid having to use `|list` after every filter",
            "                func = _unroll_iterator(func)",
            "",
            "        return func",
            "",
            "    def __setitem__(self, key, value):",
            "        return self._delegatee.__setitem__(key, value)",
            "",
            "    def __delitem__(self, key):",
            "        raise NotImplementedError()",
            "",
            "    def __iter__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return iter(self._delegatee)",
            "",
            "    def __len__(self):",
            "        # not strictly accurate since we're not counting dynamically-loaded values",
            "        return len(self._delegatee)",
            "",
            "",
            "def _fail_on_undefined(data):",
            "    \"\"\"Recursively find an undefined value in a nested data structure",
            "    and properly raise the undefined exception.",
            "    \"\"\"",
            "    if isinstance(data, Mapping):",
            "        for value in data.values():",
            "            _fail_on_undefined(value)",
            "    elif is_sequence(data):",
            "        for item in data:",
            "            _fail_on_undefined(item)",
            "    else:",
            "        if isinstance(data, StrictUndefined):",
            "            # To actually raise the undefined exception we need to",
            "            # access the undefined object otherwise the exception would",
            "            # be raised on the next access which might not be properly",
            "            # handled.",
            "            # See https://github.com/ansible/ansible/issues/52158",
            "            # and StrictUndefined implementation in upstream Jinja2.",
            "            str(data)",
            "    return data",
            "",
            "",
            "@_unroll_iterator",
            "def _ansible_finalize(thing):",
            "    \"\"\"A custom finalize function for jinja2, which prevents None from being",
            "    returned. This avoids a string of ``\"None\"`` as ``None`` has no",
            "    importance in YAML.",
            "",
            "    The function is decorated with ``_unroll_iterator`` so that users are not",
            "    required to explicitly use ``|list`` to unroll a generator. This only",
            "    affects the scenario where the final result of templating",
            "    is a generator, e.g. ``range``, ``dict.items()`` and so on. Filters",
            "    which can produce a generator in the middle of a template are already",
            "    wrapped with ``_unroll_generator`` in ``JinjaPluginIntercept``.",
            "    \"\"\"",
            "    return thing if _fail_on_undefined(thing) is not None else ''",
            "",
            "",
            "class AnsibleEnvironment(NativeEnvironment):",
            "    '''",
            "    Our custom environment, which simply allows us to override the class-level",
            "    values for the Template and Context classes used by jinja2 internally.",
            "    '''",
            "    context_class = AnsibleContext",
            "    template_class = AnsibleJ2Template",
            "    concat = staticmethod(ansible_eval_concat)  # type: ignore[assignment]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.filters = JinjaPluginIntercept(self.filters, filter_loader)",
            "        self.tests = JinjaPluginIntercept(self.tests, test_loader)",
            "",
            "        self.trim_blocks = True",
            "",
            "        self.undefined = AnsibleUndefined",
            "        self.finalize = _ansible_finalize",
            "",
            "",
            "class AnsibleNativeEnvironment(AnsibleEnvironment):",
            "    concat = staticmethod(ansible_native_concat)  # type: ignore[assignment]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.finalize = _unroll_iterator(_fail_on_undefined)",
            "",
            "",
            "class Templar:",
            "    '''",
            "    The main class for templating, with the main entry-point of template().",
            "    '''",
            "",
            "    def __init__(self, loader, variables=None):",
            "        self._loader = loader",
            "        self._available_variables = {} if variables is None else variables",
            "",
            "        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR",
            "",
            "        environment_class = AnsibleNativeEnvironment if C.DEFAULT_JINJA2_NATIVE else AnsibleEnvironment",
            "",
            "        self.environment = environment_class(",
            "            extensions=self._get_extensions(),",
            "            loader=FileSystemLoader(loader.get_basedir() if loader else '.'),",
            "        )",
            "        self.environment.template_class.environment_class = environment_class",
            "",
            "        # Custom globals",
            "        self.environment.globals['lookup'] = self._lookup",
            "        self.environment.globals['query'] = self.environment.globals['q'] = self._query_lookup",
            "        self.environment.globals['now'] = self._now_datetime",
            "        self.environment.globals['undef'] = self._make_undefined",
            "",
            "        # the current rendering context under which the templar class is working",
            "        self.cur_context = None",
            "",
            "        # this regex is re-compiled each time variable_start_string and variable_end_string are possibly changed",
            "        self._compile_single_var(self.environment)",
            "",
            "        self.jinja2_native = C.DEFAULT_JINJA2_NATIVE",
            "",
            "    def _compile_single_var(self, env):",
            "        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (env.variable_start_string, env.variable_end_string))",
            "",
            "    def copy_with_new_env(self, environment_class=AnsibleEnvironment, **kwargs):",
            "        r\"\"\"Creates a new copy of Templar with a new environment.",
            "",
            "        :kwarg environment_class: Environment class used for creating a new environment.",
            "        :kwarg \\*\\*kwargs: Optional arguments for the new environment that override existing",
            "            environment attributes.",
            "",
            "        :returns: Copy of Templar with updated environment.",
            "        \"\"\"",
            "        # We need to use __new__ to skip __init__, mainly not to create a new",
            "        # environment there only to override it below",
            "        new_env = object.__new__(environment_class)",
            "        new_env.__dict__.update(self.environment.__dict__)",
            "",
            "        new_templar = object.__new__(Templar)",
            "        new_templar.__dict__.update(self.__dict__)",
            "        new_templar.environment = new_env",
            "",
            "        new_templar.jinja2_native = environment_class is AnsibleNativeEnvironment",
            "",
            "        mapping = {",
            "            'available_variables': new_templar,",
            "            'searchpath': new_env.loader,",
            "        }",
            "",
            "        for key, value in kwargs.items():",
            "            obj = mapping.get(key, new_env)",
            "            try:",
            "                if value is not None:",
            "                    setattr(obj, key, value)",
            "            except AttributeError:",
            "                # Ignore invalid attrs",
            "                pass",
            "",
            "        return new_templar",
            "",
            "    def _get_extensions(self):",
            "        '''",
            "        Return jinja2 extensions to load.",
            "",
            "        If some extensions are set via jinja_extensions in ansible.cfg, we try",
            "        to load them with the jinja environment.",
            "        '''",
            "",
            "        jinja_exts = []",
            "        if C.DEFAULT_JINJA2_EXTENSIONS:",
            "            # make sure the configuration directive doesn't contain spaces",
            "            # and split extensions in an array",
            "            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')",
            "",
            "        return jinja_exts",
            "",
            "    @property",
            "    def available_variables(self):",
            "        return self._available_variables",
            "",
            "    @available_variables.setter",
            "    def available_variables(self, variables):",
            "        '''",
            "        Sets the list of template variables this Templar instance will use",
            "        to template things, so we don't have to pass them around between",
            "        internal methods. We also clear the template cache here, as the variables",
            "        are being changed.",
            "        '''",
            "",
            "        if not isinstance(variables, Mapping):",
            "            raise AnsibleAssertionError(\"the type of 'variables' should be a Mapping but was a %s\" % (type(variables)))",
            "        self._available_variables = variables",
            "",
            "    @contextmanager",
            "    def set_temporary_context(self, **kwargs):",
            "        \"\"\"Context manager used to set temporary templating context, without having to worry about resetting",
            "        original values afterward",
            "",
            "        Use a keyword that maps to the attr you are setting. Applies to ``self.environment`` by default, to",
            "        set context on another object, it must be in ``mapping``.",
            "        \"\"\"",
            "        mapping = {",
            "            'available_variables': self,",
            "            'searchpath': self.environment.loader,",
            "        }",
            "        original = {}",
            "",
            "        for key, value in kwargs.items():",
            "            obj = mapping.get(key, self.environment)",
            "            try:",
            "                original[key] = getattr(obj, key)",
            "                if value is not None:",
            "                    setattr(obj, key, value)",
            "            except AttributeError:",
            "                # Ignore invalid attrs",
            "                pass",
            "",
            "        yield",
            "",
            "        for key in original:",
            "            obj = mapping.get(key, self.environment)",
            "            setattr(obj, key, original[key])",
            "",
            "    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None,",
            "                 convert_data=True, static_vars=None, disable_lookups=False):",
            "        '''",
            "        Templates (possibly recursively) any given data as input. If convert_bare is",
            "        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')",
            "        before being sent through the template engine.",
            "        '''",
            "        static_vars = [] if static_vars is None else static_vars",
            "",
            "        # Don't template unsafe variables, just return them.",
            "        if hasattr(variable, '__UNSAFE__'):",
            "            return variable",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        if convert_bare:",
            "            variable = self._convert_bare_variable(variable)",
            "",
            "        if isinstance(variable, string_types):",
            "            if not self.is_possibly_template(variable, overrides):",
            "                return variable",
            "",
            "            # Check to see if the string we are trying to render is just referencing a single",
            "            # var.  In this case we don't want to accidentally change the type of the variable",
            "            # to a string by using the jinja template renderer. We just want to pass it.",
            "            only_one = self.SINGLE_VAR.match(variable)",
            "            if only_one:",
            "                var_name = only_one.group(1)",
            "                if var_name in self._available_variables:",
            "                    resolved_val = self._available_variables[var_name]",
            "                    if isinstance(resolved_val, NON_TEMPLATED_TYPES):",
            "                        return resolved_val",
            "                    elif resolved_val is None:",
            "                        return C.DEFAULT_NULL_REPRESENTATION",
            "",
            "            result = self.do_template(",
            "                variable,",
            "                preserve_trailing_newlines=preserve_trailing_newlines,",
            "                escape_backslashes=escape_backslashes,",
            "                fail_on_undefined=fail_on_undefined,",
            "                overrides=overrides,",
            "                disable_lookups=disable_lookups,",
            "                convert_data=convert_data,",
            "            )",
            "            self._compile_single_var(self.environment)",
            "",
            "            return result",
            "",
            "        elif is_sequence(variable):",
            "            return [self.template(",
            "                v,",
            "                preserve_trailing_newlines=preserve_trailing_newlines,",
            "                fail_on_undefined=fail_on_undefined,",
            "                overrides=overrides,",
            "                disable_lookups=disable_lookups,",
            "            ) for v in variable]",
            "        elif isinstance(variable, Mapping):",
            "            d = {}",
            "            # we don't use iteritems() here to avoid problems if the underlying dict",
            "            # changes sizes due to the templating, which can happen with hostvars",
            "            for k in variable.keys():",
            "                if k not in static_vars:",
            "                    d[k] = self.template(",
            "                        variable[k],",
            "                        preserve_trailing_newlines=preserve_trailing_newlines,",
            "                        fail_on_undefined=fail_on_undefined,",
            "                        overrides=overrides,",
            "                        disable_lookups=disable_lookups,",
            "                    )",
            "                else:",
            "                    d[k] = variable[k]",
            "            return d",
            "        else:",
            "            return variable",
            "",
            "    def is_template(self, data):",
            "        '''lets us know if data has a template'''",
            "        if isinstance(data, string_types):",
            "            return is_template(data, self.environment)",
            "        elif isinstance(data, (list, tuple)):",
            "            for v in data:",
            "                if self.is_template(v):",
            "                    return True",
            "        elif isinstance(data, dict):",
            "            for k in data:",
            "                if self.is_template(k) or self.is_template(data[k]):",
            "                    return True",
            "        return False",
            "",
            "    templatable = is_template",
            "",
            "    def is_possibly_template(self, data, overrides=None):",
            "        data, env = _create_overlay(data, overrides, self.environment)",
            "        return is_possibly_template(data, env)",
            "",
            "    def _convert_bare_variable(self, variable):",
            "        '''",
            "        Wraps a bare string, which may have an attribute portion (ie. foo.bar)",
            "        in jinja2 variable braces so that it is evaluated properly.",
            "        '''",
            "",
            "        if isinstance(variable, string_types):",
            "            contains_filters = \"|\" in variable",
            "            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]",
            "            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:",
            "                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)",
            "",
            "        # the variable didn't meet the conditions to be converted,",
            "        # so just return it as-is",
            "        return variable",
            "",
            "    def _fail_lookup(self, name, *args, **kwargs):",
            "        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)",
            "",
            "    def _now_datetime(self, utc=False, fmt=None):",
            "        '''jinja2 global function to return current datetime, potentially formatted via strftime'''",
            "        if utc:",
            "            now = datetime.datetime.now(datetime.timezone.utc).replace(tzinfo=None)",
            "        else:",
            "            now = datetime.datetime.now()",
            "",
            "        if fmt:",
            "            return now.strftime(fmt)",
            "",
            "        return now",
            "",
            "    def _query_lookup(self, name, /, *args, **kwargs):",
            "        ''' wrapper for lookup, force wantlist true'''",
            "        kwargs['wantlist'] = True",
            "        return self._lookup(name, *args, **kwargs)",
            "",
            "    def _lookup(self, name, /, *args, **kwargs):",
            "        instance = lookup_loader.get(name, loader=self._loader, templar=self)",
            "",
            "        if instance is None:",
            "            raise AnsibleError(\"lookup plugin (%s) not found\" % name)",
            "",
            "        wantlist = kwargs.pop('wantlist', False)",
            "        allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)",
            "        errors = kwargs.pop('errors', 'strict')",
            "",
            "        loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, fail_on_undefined=True, convert_bare=False)",
            "        # safely catch run failures per #5059",
            "        try:",
            "            ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)",
            "        except (AnsibleUndefinedVariable, UndefinedError) as e:",
            "            raise AnsibleUndefinedVariable(e)",
            "        except AnsibleOptionsError as e:",
            "            # invalid options given to lookup, just reraise",
            "            raise e",
            "        except AnsibleLookupError as e:",
            "            # lookup handled error but still decided to bail",
            "            msg = 'Lookup failed but the error is being ignored: %s' % to_native(e)",
            "            if errors == 'warn':",
            "                display.warning(msg)",
            "            elif errors == 'ignore':",
            "                display.display(msg, log_only=True)",
            "            else:",
            "                raise e",
            "            return [] if wantlist else None",
            "        except Exception as e:",
            "            # errors not handled by lookup",
            "            msg = u\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % \\",
            "                  (name, type(e), to_text(e))",
            "            if errors == 'warn':",
            "                display.warning(msg)",
            "            elif errors == 'ignore':",
            "                display.display(msg, log_only=True)",
            "            else:",
            "                display.vvv('exception during Jinja2 execution: {0}'.format(format_exc()))",
            "                raise AnsibleError(to_native(msg), orig_exc=e)",
            "            return [] if wantlist else None",
            "",
            "        if not is_sequence(ran):",
            "            raise AnsibleLookupError(",
            "                f'The lookup plugin \\'{name}\\' was expected to return a list, got \\'{type(ran)}\\' instead. '",
            "                f'The lookup plugin \\'{name}\\' needs to be changed to return a list. '",
            "            )",
            "",
            "        if ran and allow_unsafe is False:",
            "            if self.cur_context:",
            "                self.cur_context.unsafe = True",
            "",
            "            if wantlist:",
            "                return wrap_var(ran)",
            "",
            "            try:",
            "                if isinstance(ran[0], NativeJinjaText):",
            "                    ran = wrap_var(NativeJinjaText(\",\".join(ran)))",
            "                else:",
            "                    ran = wrap_var(\",\".join(ran))",
            "            except TypeError:",
            "                # Lookup Plugins should always return lists.  Throw an error if that's not",
            "                # the case:",
            "                if not isinstance(ran, Sequence):",
            "                    raise AnsibleError(\"The lookup plugin '%s' did not return a list.\"",
            "                                       % name)",
            "",
            "                # The TypeError we can recover from is when the value *inside* of the list",
            "                # is not a string",
            "                if len(ran) == 1:",
            "                    ran = wrap_var(ran[0])",
            "                else:",
            "                    ran = wrap_var(ran)",
            "            except KeyError:",
            "                # Lookup Plugin returned a dict.  Return comma-separated string of keys",
            "                # for backwards compat.",
            "                # FIXME this can be removed when support for non-list return types is removed.",
            "                # See https://github.com/ansible/ansible/pull/77789",
            "                ran = wrap_var(\",\".join(ran))",
            "",
            "        return ran",
            "",
            "    def _make_undefined(self, hint=None):",
            "        from jinja2.runtime import Undefined",
            "",
            "        if hint is None or isinstance(hint, Undefined) or hint == '':",
            "            hint = \"Mandatory variable has not been overridden\"",
            "        return AnsibleUndefined(hint)",
            "",
            "    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False,",
            "                    convert_data=False):",
            "        if self.jinja2_native and not isinstance(data, string_types):",
            "            return data",
            "",
            "        # For preserving the number of input newlines in the output (used",
            "        # later in this method)",
            "        data_newlines = _count_newlines_from_end(data)",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            # NOTE Creating an overlay that lives only inside do_template means that overrides are not applied",
            "            # when templating nested variables in AnsibleJ2Vars where Templar.environment is used, not the overlay.",
            "            data, myenv = _create_overlay(data, overrides, self.environment)",
            "            # in case delimiters change",
            "            self._compile_single_var(myenv)",
            "",
            "            if escape_backslashes:",
            "                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".",
            "                data = _escape_backslashes(data, myenv)",
            "",
            "            try:",
            "                t = myenv.from_string(data)",
            "            except (TemplateSyntaxError, SyntaxError) as e:",
            "                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)), orig_exc=e)",
            "            except Exception as e:",
            "                if 'recursion' in to_native(e):",
            "                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data), orig_exc=e)",
            "                else:",
            "                    return data",
            "",
            "            if disable_lookups:",
            "                t.globals['query'] = t.globals['q'] = t.globals['lookup'] = self._fail_lookup",
            "",
            "            jvars = AnsibleJ2Vars(self, t.globals)",
            "",
            "            # In case this is a recursive call to do_template we need to",
            "            # save/restore cur_context to prevent overriding __UNSAFE__.",
            "            cached_context = self.cur_context",
            "",
            "            # In case this is a recursive call and we set different concat",
            "            # function up the stack, reset it in case the value of convert_data",
            "            # changed in this call",
            "            myenv.concat = myenv.__class__.concat",
            "            # the concat function is set for each Ansible environment,",
            "            # however for convert_data=False we need to use the concat",
            "            # function that avoids any evaluation and set it temporarily",
            "            # on the environment so it is used correctly even when",
            "            # the concat function is called internally in Jinja,",
            "            # most notably for macro execution",
            "            if not self.jinja2_native and not convert_data:",
            "                myenv.concat = ansible_concat",
            "",
            "            self.cur_context = t.new_context(jvars, shared=True)",
            "            rf = t.root_render_func(self.cur_context)",
            "",
            "            try:",
            "                res = myenv.concat(rf)",
            "                unsafe = getattr(self.cur_context, 'unsafe', False)",
            "                if unsafe:",
            "                    res = wrap_var(res)",
            "            except TypeError as te:",
            "                if 'AnsibleUndefined' in to_native(te):",
            "                    errmsg = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)",
            "                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)",
            "                    raise AnsibleUndefinedVariable(errmsg, orig_exc=te)",
            "                else:",
            "                    display.debug(\"failing because of a type error, template data is: %s\" % to_text(data))",
            "                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data), to_native(te)), orig_exc=te)",
            "            finally:",
            "                self.cur_context = cached_context",
            "",
            "            if isinstance(res, string_types) and preserve_trailing_newlines:",
            "                # The low level calls above do not preserve the newline",
            "                # characters at the end of the input data, so we use the",
            "                # calculate the difference in newlines and append them",
            "                # to the resulting output for parity",
            "                #",
            "                # Using Environment's keep_trailing_newline instead would",
            "                # result in change in behavior when trailing newlines",
            "                # would be kept also for included templates, for example:",
            "                # \"Hello {% include 'world.txt' %}!\" would render as",
            "                # \"Hello world\\n!\\n\" instead of \"Hello world!\\n\".",
            "                res_newlines = _count_newlines_from_end(res)",
            "                if data_newlines > res_newlines:",
            "                    res += myenv.newline_sequence * (data_newlines - res_newlines)",
            "                    if unsafe:",
            "                        res = wrap_var(res)",
            "            return res",
            "        except UndefinedError as e:",
            "            if fail_on_undefined:",
            "                raise AnsibleUndefinedVariable(e)",
            "            display.debug(\"Ignoring undefined failure: %s\" % to_text(e))",
            "            return data",
            "        except AnsibleUndefinedVariable as e:",
            "            if fail_on_undefined:",
            "                raise",
            "            display.debug(\"Ignoring undefined failure: %s\" % to_text(e))",
            "            return data",
            "",
            "    # for backwards compatibility in case anyone is using old private method directly",
            "    _do_template = do_template"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "51": [],
            "315": [
                "AnsibleUndefined"
            ],
            "316": [
                "AnsibleUndefined"
            ],
            "317": [
                "AnsibleUndefined"
            ],
            "318": [
                "AnsibleUndefined"
            ],
            "319": [
                "AnsibleUndefined"
            ],
            "320": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "321": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "322": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "323": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "324": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "325": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "326": [
                "AnsibleUndefined",
                "__getattr__"
            ],
            "327": [
                "AnsibleUndefined"
            ],
            "328": [
                "AnsibleUndefined",
                "__getitem__"
            ],
            "329": [
                "AnsibleUndefined",
                "__getitem__"
            ],
            "330": [
                "AnsibleUndefined",
                "__getitem__"
            ],
            "331": [
                "AnsibleUndefined"
            ],
            "332": [
                "AnsibleUndefined",
                "__repr__"
            ],
            "333": [
                "AnsibleUndefined",
                "__repr__"
            ],
            "334": [
                "AnsibleUndefined",
                "__repr__"
            ],
            "335": [
                "AnsibleUndefined",
                "__repr__"
            ],
            "336": [
                "AnsibleUndefined",
                "__repr__"
            ],
            "337": [
                "AnsibleUndefined",
                "__repr__"
            ],
            "338": [
                "AnsibleUndefined"
            ],
            "339": [
                "AnsibleUndefined",
                "__contains__"
            ],
            "340": [
                "AnsibleUndefined",
                "__contains__"
            ],
            "341": [
                "AnsibleUndefined",
                "__contains__"
            ],
            "342": [],
            "343": []
        },
        "addLocation": []
    },
    "lib/ansible/template/native_helpers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import ast"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from collections.abc import Mapping"
            },
            "4": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from itertools import islice, chain"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from types import GeneratorType"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from ansible.module_utils.common.collections import is_sequence"
            },
            "8": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from ansible.module_utils.common.text.converters import to_text"
            },
            "9": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from ansible.module_utils.six import string_types"
            },
            "10": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from ansible.parsing.yaml.objects import AnsibleVaultEncryptedUnicode"
            },
            "11": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from ansible.utils.native_jinja import NativeJinjaText"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from ansible.utils.unsafe_proxy import wrap_var"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+import ansible.module_utils.compat.typing as t"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from jinja2.runtime import StrictUndefined"
            },
            "16": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " _JSON_MAP = {"
            },
            "19": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         return ast.Constant(value=_JSON_MAP[node.id])"
            },
            "20": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+def _is_unsafe(value: t.Any) -> bool:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    \"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    Our helper function, which will also recursively check dict and"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    list entries due to the fact that they may be repr'd and contain"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    a key or value which contains jinja2 syntax and would otherwise"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    lose the AnsibleUnsafe value."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    \"\"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    to_check = [value]"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    seen = set()"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    while True:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        if not to_check:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            break"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        val = to_check.pop(0)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        val_id = id(val)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        if val_id in seen:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            continue"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        seen.add(val_id)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        if isinstance(val, AnsibleUndefined):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+            continue"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        if isinstance(val, Mapping):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            to_check.extend(val.keys())"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            to_check.extend(val.values())"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        elif is_sequence(val):"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            to_check.extend(val)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        elif getattr(val, '__UNSAFE__', False):"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            return True"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    return False"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " def ansible_eval_concat(nodes):"
            },
            "57": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     \"\"\"Return a string of concatenated compiled nodes. Throw an undefined error"
            },
            "58": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     if any of the nodes is undefined."
            },
            "59": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     if not head:"
            },
            "60": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         return ''"
            },
            "61": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    unsafe = False"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     if len(head) == 1:"
            },
            "65": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         out = head[0]"
            },
            "66": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         if isinstance(out, NativeJinjaText):"
            },
            "68": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             return out"
            },
            "69": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        unsafe = _is_unsafe(out)"
            },
            "71": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         out = to_text(out)"
            },
            "72": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "     else:"
            },
            "73": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         if isinstance(nodes, GeneratorType):"
            },
            "74": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             nodes = chain(head, nodes)"
            },
            "75": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        out = ''.join([to_text(v) for v in nodes])"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        out_values = []"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        for v in nodes:"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            if not unsafe and _is_unsafe(v):"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+                unsafe = True"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            out_values.append(to_text(v))"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        out = ''.join(out_values)"
            },
            "85": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "     # if this looks like a dictionary, list or bool, convert it to such"
            },
            "87": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "     if out.startswith(('{', '[')) or out in ('True', 'False'):"
            },
            "88": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         except (TypeError, ValueError, SyntaxError, MemoryError):"
            },
            "89": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "             pass"
            },
            "90": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    if unsafe:"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        out = wrap_var(out)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     return out"
            },
            "95": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 132,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     Used in Templar.template() when jinja2_native=False and convert_data=False."
            },
            "99": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     \"\"\""
            },
            "100": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return ''.join([to_text(v) for v in nodes])"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    unsafe = False"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    values = []"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    for v in nodes:"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        if not unsafe and _is_unsafe(v):"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            unsafe = True"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        values.append(to_text(v))"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    out = ''.join(values)"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    if unsafe:"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        out = wrap_var(out)"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    return out"
            },
            "114": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "115": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "116": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " def ansible_native_concat(nodes):"
            },
            "117": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "     if not head:"
            },
            "118": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         return None"
            },
            "119": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    unsafe = False"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+"
            },
            "122": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     if len(head) == 1:"
            },
            "123": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "         out = head[0]"
            },
            "124": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " "
            },
            "125": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         # short-circuit literal_eval for anything other than strings"
            },
            "126": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         if not isinstance(out, string_types):"
            },
            "127": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "             return out"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        unsafe = _is_unsafe(out)"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+"
            },
            "131": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     else:"
            },
            "132": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         if isinstance(nodes, GeneratorType):"
            },
            "133": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "             nodes = chain(head, nodes)"
            },
            "134": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        out = ''.join([to_text(v) for v in nodes])"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        out_values = []"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        for v in nodes:"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            if not unsafe and _is_unsafe(v):"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                unsafe = True"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            out_values.append(to_text(v))"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        out = ''.join(out_values)"
            },
            "144": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 201,
                "PatchRowcode": " "
            },
            "145": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "     try:"
            },
            "146": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         evaled = ast.literal_eval("
            },
            "147": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "             ast.parse(out, mode='eval')"
            },
            "148": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         )"
            },
            "149": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "     except (TypeError, ValueError, SyntaxError, MemoryError):"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        if unsafe:"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+            out = wrap_var(out)"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+"
            },
            "153": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         return out"
            },
            "154": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 214,
                "PatchRowcode": " "
            },
            "155": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "     if isinstance(evaled, string_types):"
            },
            "156": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "         quote = out[0]"
            },
            "157": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return f'{quote}{evaled}{quote}'"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        evaled = f'{quote}{evaled}{quote}'"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    if unsafe:"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        evaled = wrap_var(evaled)"
            },
            "162": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "163": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "     return evaled"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+class AnsibleUndefined(StrictUndefined):"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+    \"\"\""
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    A custom Undefined class, which returns further Undefined objects on access,"
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+    rather than throwing an exception."
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    \"\"\""
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+    def __getattr__(self, name):"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        if name == '__UNSAFE__':"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            # AnsibleUndefined should never be assumed to be unsafe"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+            # This prevents ``hasattr(val, '__UNSAFE__')`` from evaluating to ``True``"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+            raise AttributeError(name)"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        # Return original Undefined object to preserve the first failure context"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        return self"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    def __getitem__(self, key):"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+        # Return original Undefined object to preserve the first failure context"
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+        return self"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+    def __repr__(self):"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+        return 'AnsibleUndefined(hint={0!r}, obj={1!r}, name={2!r})'.format("
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+            self._undefined_hint,"
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+            self._undefined_obj,"
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+            self._undefined_name"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+        )"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    def __contains__(self, item):"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        # Return original Undefined object to preserve the first failure context"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        return self"
            }
        },
        "frontPatchFile": [
            "# Copyright: (c) 2018, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import annotations",
            "",
            "",
            "import ast",
            "from itertools import islice, chain",
            "from types import GeneratorType",
            "",
            "from ansible.module_utils.common.text.converters import to_text",
            "from ansible.module_utils.six import string_types",
            "from ansible.parsing.yaml.objects import AnsibleVaultEncryptedUnicode",
            "from ansible.utils.native_jinja import NativeJinjaText",
            "",
            "",
            "_JSON_MAP = {",
            "    \"true\": True,",
            "    \"false\": False,",
            "    \"null\": None,",
            "}",
            "",
            "",
            "class Json2Python(ast.NodeTransformer):",
            "    def visit_Name(self, node):",
            "        if node.id not in _JSON_MAP:",
            "            return node",
            "        return ast.Constant(value=_JSON_MAP[node.id])",
            "",
            "",
            "def ansible_eval_concat(nodes):",
            "    \"\"\"Return a string of concatenated compiled nodes. Throw an undefined error",
            "    if any of the nodes is undefined.",
            "",
            "    If the result of concat appears to be a dictionary, list or bool,",
            "    try and convert it to such using literal_eval, the same mechanism as used",
            "    in jinja2_native.",
            "",
            "    Used in Templar.template() when jinja2_native=False and convert_data=True.",
            "    \"\"\"",
            "    head = list(islice(nodes, 2))",
            "",
            "    if not head:",
            "        return ''",
            "",
            "    if len(head) == 1:",
            "        out = head[0]",
            "",
            "        if isinstance(out, NativeJinjaText):",
            "            return out",
            "",
            "        out = to_text(out)",
            "    else:",
            "        if isinstance(nodes, GeneratorType):",
            "            nodes = chain(head, nodes)",
            "        out = ''.join([to_text(v) for v in nodes])",
            "",
            "    # if this looks like a dictionary, list or bool, convert it to such",
            "    if out.startswith(('{', '[')) or out in ('True', 'False'):",
            "        try:",
            "            out = ast.literal_eval(",
            "                ast.fix_missing_locations(",
            "                    Json2Python().visit(",
            "                        ast.parse(out, mode='eval')",
            "                    )",
            "                )",
            "            )",
            "        except (TypeError, ValueError, SyntaxError, MemoryError):",
            "            pass",
            "",
            "    return out",
            "",
            "",
            "def ansible_concat(nodes):",
            "    \"\"\"Return a string of concatenated compiled nodes. Throw an undefined error",
            "    if any of the nodes is undefined. Other than that it is equivalent to",
            "    Jinja2's default concat function.",
            "",
            "    Used in Templar.template() when jinja2_native=False and convert_data=False.",
            "    \"\"\"",
            "    return ''.join([to_text(v) for v in nodes])",
            "",
            "",
            "def ansible_native_concat(nodes):",
            "    \"\"\"Return a native Python type from the list of compiled nodes. If the",
            "    result is a single node, its value is returned. Otherwise, the nodes are",
            "    concatenated as strings. If the result can be parsed with",
            "    :func:`ast.literal_eval`, the parsed value is returned. Otherwise, the",
            "    string is returned.",
            "",
            "    https://github.com/pallets/jinja/blob/master/src/jinja2/nativetypes.py",
            "    \"\"\"",
            "    head = list(islice(nodes, 2))",
            "",
            "    if not head:",
            "        return None",
            "",
            "    if len(head) == 1:",
            "        out = head[0]",
            "",
            "        # TODO send unvaulted data to literal_eval?",
            "        if isinstance(out, AnsibleVaultEncryptedUnicode):",
            "            return out.data",
            "",
            "        if isinstance(out, NativeJinjaText):",
            "            # Sometimes (e.g. ``| string``) we need to mark variables",
            "            # in a special way so that they remain strings and are not",
            "            # passed into literal_eval.",
            "            # See:",
            "            # https://github.com/ansible/ansible/issues/70831",
            "            # https://github.com/pallets/jinja/issues/1200",
            "            # https://github.com/ansible/ansible/issues/70831#issuecomment-664190894",
            "            return out",
            "",
            "        # short-circuit literal_eval for anything other than strings",
            "        if not isinstance(out, string_types):",
            "            return out",
            "    else:",
            "        if isinstance(nodes, GeneratorType):",
            "            nodes = chain(head, nodes)",
            "        out = ''.join([to_text(v) for v in nodes])",
            "",
            "    try:",
            "        evaled = ast.literal_eval(",
            "            # In Python 3.10+ ast.literal_eval removes leading spaces/tabs",
            "            # from the given string. For backwards compatibility we need to",
            "            # parse the string ourselves without removing leading spaces/tabs.",
            "            ast.parse(out, mode='eval')",
            "        )",
            "    except (TypeError, ValueError, SyntaxError, MemoryError):",
            "        return out",
            "",
            "    if isinstance(evaled, string_types):",
            "        quote = out[0]",
            "        return f'{quote}{evaled}{quote}'",
            "",
            "    return evaled"
        ],
        "afterPatchFile": [
            "# Copyright: (c) 2018, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import annotations",
            "",
            "",
            "import ast",
            "from collections.abc import Mapping",
            "from itertools import islice, chain",
            "from types import GeneratorType",
            "",
            "from ansible.module_utils.common.collections import is_sequence",
            "from ansible.module_utils.common.text.converters import to_text",
            "from ansible.module_utils.six import string_types",
            "from ansible.parsing.yaml.objects import AnsibleVaultEncryptedUnicode",
            "from ansible.utils.native_jinja import NativeJinjaText",
            "from ansible.utils.unsafe_proxy import wrap_var",
            "import ansible.module_utils.compat.typing as t",
            "",
            "from jinja2.runtime import StrictUndefined",
            "",
            "",
            "_JSON_MAP = {",
            "    \"true\": True,",
            "    \"false\": False,",
            "    \"null\": None,",
            "}",
            "",
            "",
            "class Json2Python(ast.NodeTransformer):",
            "    def visit_Name(self, node):",
            "        if node.id not in _JSON_MAP:",
            "            return node",
            "        return ast.Constant(value=_JSON_MAP[node.id])",
            "",
            "",
            "def _is_unsafe(value: t.Any) -> bool:",
            "    \"\"\"",
            "    Our helper function, which will also recursively check dict and",
            "    list entries due to the fact that they may be repr'd and contain",
            "    a key or value which contains jinja2 syntax and would otherwise",
            "    lose the AnsibleUnsafe value.",
            "    \"\"\"",
            "    to_check = [value]",
            "    seen = set()",
            "",
            "    while True:",
            "        if not to_check:",
            "            break",
            "",
            "        val = to_check.pop(0)",
            "        val_id = id(val)",
            "",
            "        if val_id in seen:",
            "            continue",
            "        seen.add(val_id)",
            "",
            "        if isinstance(val, AnsibleUndefined):",
            "            continue",
            "        if isinstance(val, Mapping):",
            "            to_check.extend(val.keys())",
            "            to_check.extend(val.values())",
            "        elif is_sequence(val):",
            "            to_check.extend(val)",
            "        elif getattr(val, '__UNSAFE__', False):",
            "            return True",
            "",
            "    return False",
            "",
            "",
            "def ansible_eval_concat(nodes):",
            "    \"\"\"Return a string of concatenated compiled nodes. Throw an undefined error",
            "    if any of the nodes is undefined.",
            "",
            "    If the result of concat appears to be a dictionary, list or bool,",
            "    try and convert it to such using literal_eval, the same mechanism as used",
            "    in jinja2_native.",
            "",
            "    Used in Templar.template() when jinja2_native=False and convert_data=True.",
            "    \"\"\"",
            "    head = list(islice(nodes, 2))",
            "",
            "    if not head:",
            "        return ''",
            "",
            "    unsafe = False",
            "",
            "    if len(head) == 1:",
            "        out = head[0]",
            "",
            "        if isinstance(out, NativeJinjaText):",
            "            return out",
            "",
            "        unsafe = _is_unsafe(out)",
            "        out = to_text(out)",
            "    else:",
            "        if isinstance(nodes, GeneratorType):",
            "            nodes = chain(head, nodes)",
            "",
            "        out_values = []",
            "        for v in nodes:",
            "            if not unsafe and _is_unsafe(v):",
            "                unsafe = True",
            "",
            "            out_values.append(to_text(v))",
            "",
            "        out = ''.join(out_values)",
            "",
            "    # if this looks like a dictionary, list or bool, convert it to such",
            "    if out.startswith(('{', '[')) or out in ('True', 'False'):",
            "        try:",
            "            out = ast.literal_eval(",
            "                ast.fix_missing_locations(",
            "                    Json2Python().visit(",
            "                        ast.parse(out, mode='eval')",
            "                    )",
            "                )",
            "            )",
            "        except (TypeError, ValueError, SyntaxError, MemoryError):",
            "            pass",
            "",
            "    if unsafe:",
            "        out = wrap_var(out)",
            "",
            "    return out",
            "",
            "",
            "def ansible_concat(nodes):",
            "    \"\"\"Return a string of concatenated compiled nodes. Throw an undefined error",
            "    if any of the nodes is undefined. Other than that it is equivalent to",
            "    Jinja2's default concat function.",
            "",
            "    Used in Templar.template() when jinja2_native=False and convert_data=False.",
            "    \"\"\"",
            "    unsafe = False",
            "    values = []",
            "    for v in nodes:",
            "        if not unsafe and _is_unsafe(v):",
            "            unsafe = True",
            "",
            "        values.append(to_text(v))",
            "",
            "    out = ''.join(values)",
            "    if unsafe:",
            "        out = wrap_var(out)",
            "",
            "    return out",
            "",
            "",
            "def ansible_native_concat(nodes):",
            "    \"\"\"Return a native Python type from the list of compiled nodes. If the",
            "    result is a single node, its value is returned. Otherwise, the nodes are",
            "    concatenated as strings. If the result can be parsed with",
            "    :func:`ast.literal_eval`, the parsed value is returned. Otherwise, the",
            "    string is returned.",
            "",
            "    https://github.com/pallets/jinja/blob/master/src/jinja2/nativetypes.py",
            "    \"\"\"",
            "    head = list(islice(nodes, 2))",
            "",
            "    if not head:",
            "        return None",
            "",
            "    unsafe = False",
            "",
            "    if len(head) == 1:",
            "        out = head[0]",
            "",
            "        # TODO send unvaulted data to literal_eval?",
            "        if isinstance(out, AnsibleVaultEncryptedUnicode):",
            "            return out.data",
            "",
            "        if isinstance(out, NativeJinjaText):",
            "            # Sometimes (e.g. ``| string``) we need to mark variables",
            "            # in a special way so that they remain strings and are not",
            "            # passed into literal_eval.",
            "            # See:",
            "            # https://github.com/ansible/ansible/issues/70831",
            "            # https://github.com/pallets/jinja/issues/1200",
            "            # https://github.com/ansible/ansible/issues/70831#issuecomment-664190894",
            "            return out",
            "",
            "        # short-circuit literal_eval for anything other than strings",
            "        if not isinstance(out, string_types):",
            "            return out",
            "",
            "        unsafe = _is_unsafe(out)",
            "",
            "    else:",
            "        if isinstance(nodes, GeneratorType):",
            "            nodes = chain(head, nodes)",
            "",
            "        out_values = []",
            "        for v in nodes:",
            "            if not unsafe and _is_unsafe(v):",
            "                unsafe = True",
            "",
            "            out_values.append(to_text(v))",
            "",
            "        out = ''.join(out_values)",
            "",
            "    try:",
            "        evaled = ast.literal_eval(",
            "            # In Python 3.10+ ast.literal_eval removes leading spaces/tabs",
            "            # from the given string. For backwards compatibility we need to",
            "            # parse the string ourselves without removing leading spaces/tabs.",
            "            ast.parse(out, mode='eval')",
            "        )",
            "    except (TypeError, ValueError, SyntaxError, MemoryError):",
            "        if unsafe:",
            "            out = wrap_var(out)",
            "",
            "        return out",
            "",
            "    if isinstance(evaled, string_types):",
            "        quote = out[0]",
            "        evaled = f'{quote}{evaled}{quote}'",
            "",
            "    if unsafe:",
            "        evaled = wrap_var(evaled)",
            "",
            "    return evaled",
            "",
            "",
            "class AnsibleUndefined(StrictUndefined):",
            "    \"\"\"",
            "    A custom Undefined class, which returns further Undefined objects on access,",
            "    rather than throwing an exception.",
            "    \"\"\"",
            "    def __getattr__(self, name):",
            "        if name == '__UNSAFE__':",
            "            # AnsibleUndefined should never be assumed to be unsafe",
            "            # This prevents ``hasattr(val, '__UNSAFE__')`` from evaluating to ``True``",
            "            raise AttributeError(name)",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __getitem__(self, key):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self",
            "",
            "    def __repr__(self):",
            "        return 'AnsibleUndefined(hint={0!r}, obj={1!r}, name={2!r})'.format(",
            "            self._undefined_hint,",
            "            self._undefined_obj,",
            "            self._undefined_name",
            "        )",
            "",
            "    def __contains__(self, item):",
            "        # Return original Undefined object to preserve the first failure context",
            "        return self"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "56": [
                "ansible_eval_concat"
            ],
            "81": [
                "ansible_concat"
            ],
            "121": [
                "ansible_native_concat"
            ],
            "135": [
                "ansible_native_concat"
            ]
        },
        "addLocation": [
            "lib.ansible.template.native_helpers.ansible_native_concat",
            "lib.ansible.template.native_helpers.ansible_eval_concat",
            "lib.ansible.template.native_helpers.ansible_concat"
        ]
    },
    "lib/ansible/vars/hostvars.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         return self._find_host(host_name) is not None"
            },
            "1": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     def __iter__(self):"
            },
            "3": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        yield from self._inventory.hosts"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        # include implicit localhost only if it has variables set"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        yield from self._inventory.hosts | {'localhost': self._inventory.localhost} if self._inventory.localhost else {}"
            },
            "6": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     def __len__(self):"
            },
            "8": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return len(self._inventory.hosts)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        # include implicit localhost only if it has variables set"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        return len(self._inventory.hosts) + (1 if self._inventory.localhost else 0)"
            },
            "11": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def __repr__(self):"
            },
            "13": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         out = {}"
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from __future__ import annotations",
            "",
            "from collections.abc import Mapping",
            "from functools import cached_property",
            "",
            "from ansible import constants as C",
            "from ansible.template import Templar, AnsibleUndefined",
            "",
            "",
            "__all__ = ['HostVars', 'HostVarsVars']",
            "",
            "",
            "# Note -- this is a Mapping, not a MutableMapping",
            "class HostVars(Mapping):",
            "    ''' A special view of vars_cache that adds values from the inventory when needed. '''",
            "",
            "    def __init__(self, inventory, variable_manager, loader):",
            "        self._inventory = inventory",
            "        self._loader = loader",
            "        self._variable_manager = variable_manager",
            "        variable_manager._hostvars = self",
            "",
            "    def set_variable_manager(self, variable_manager):",
            "        self._variable_manager = variable_manager",
            "        variable_manager._hostvars = self",
            "",
            "    def set_inventory(self, inventory):",
            "        self._inventory = inventory",
            "",
            "    def _find_host(self, host_name):",
            "        # does not use inventory.hosts so it can create localhost on demand",
            "        return self._inventory.get_host(host_name)",
            "",
            "    def raw_get(self, host_name):",
            "        '''",
            "        Similar to __getitem__, however the returned data is not run through",
            "        the templating engine to expand variables in the hostvars.",
            "        '''",
            "        host = self._find_host(host_name)",
            "        if host is None:",
            "            return AnsibleUndefined(name=\"hostvars['%s']\" % host_name)",
            "",
            "        return self._variable_manager.get_vars(host=host, include_hostvars=False)",
            "",
            "    def __setstate__(self, state):",
            "        self.__dict__.update(state)",
            "",
            "        # Methods __getstate__ and __setstate__ of VariableManager do not",
            "        # preserve _loader and _hostvars attributes to improve pickle",
            "        # performance and memory utilization. Since HostVars holds values",
            "        # of those attributes already, assign them if needed.",
            "        if self._variable_manager._loader is None:",
            "            self._variable_manager._loader = self._loader",
            "",
            "        if self._variable_manager._hostvars is None:",
            "            self._variable_manager._hostvars = self",
            "",
            "    def __getitem__(self, host_name):",
            "        data = self.raw_get(host_name)",
            "        if isinstance(data, AnsibleUndefined):",
            "            return data",
            "        return HostVarsVars(data, loader=self._loader)",
            "",
            "    def set_host_variable(self, host, varname, value):",
            "        self._variable_manager.set_host_variable(host, varname, value)",
            "",
            "    def set_nonpersistent_facts(self, host, facts):",
            "        self._variable_manager.set_nonpersistent_facts(host, facts)",
            "",
            "    def set_host_facts(self, host, facts):",
            "        self._variable_manager.set_host_facts(host, facts)",
            "",
            "    def __contains__(self, host_name):",
            "        # does not use inventory.hosts so it can create localhost on demand",
            "        return self._find_host(host_name) is not None",
            "",
            "    def __iter__(self):",
            "        yield from self._inventory.hosts",
            "",
            "    def __len__(self):",
            "        return len(self._inventory.hosts)",
            "",
            "    def __repr__(self):",
            "        out = {}",
            "        for host in self._inventory.hosts:",
            "            out[host] = self.get(host)",
            "        return repr(out)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # We do not need to deepcopy because HostVars is immutable,",
            "        # however we have to implement the method so we can deepcopy",
            "        # variables' dicts that contain HostVars.",
            "        return self",
            "",
            "",
            "class HostVarsVars(Mapping):",
            "",
            "    def __init__(self, variables, loader):",
            "        self._vars = variables",
            "        self._loader = loader",
            "",
            "    @cached_property",
            "    def _templar(self):",
            "        # NOTE: this only has access to the host's own vars,",
            "        # so templates that depend on vars in other scopes will not work.",
            "        return Templar(variables=self._vars, loader=self._loader)",
            "",
            "    def __getitem__(self, var):",
            "        return self._templar.template(self._vars[var], fail_on_undefined=False, static_vars=C.INTERNAL_STATIC_VARS)",
            "",
            "    def __contains__(self, var):",
            "        return (var in self._vars)",
            "",
            "    def __iter__(self):",
            "        yield from self._vars.keys()",
            "",
            "    def __len__(self):",
            "        return len(self._vars.keys())",
            "",
            "    def __repr__(self):",
            "        return repr(self._templar.template(self._vars, fail_on_undefined=False, static_vars=C.INTERNAL_STATIC_VARS))",
            "",
            "    def __getstate__(self):",
            "        ''' override serialization here to avoid",
            "            pickle issues with templar and Jinja native'''",
            "        state = self.__dict__.copy()",
            "        state.pop('_templar', None)",
            "        return state"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "from __future__ import annotations",
            "",
            "from collections.abc import Mapping",
            "from functools import cached_property",
            "",
            "from ansible import constants as C",
            "from ansible.template import Templar, AnsibleUndefined",
            "",
            "",
            "__all__ = ['HostVars', 'HostVarsVars']",
            "",
            "",
            "# Note -- this is a Mapping, not a MutableMapping",
            "class HostVars(Mapping):",
            "    ''' A special view of vars_cache that adds values from the inventory when needed. '''",
            "",
            "    def __init__(self, inventory, variable_manager, loader):",
            "        self._inventory = inventory",
            "        self._loader = loader",
            "        self._variable_manager = variable_manager",
            "        variable_manager._hostvars = self",
            "",
            "    def set_variable_manager(self, variable_manager):",
            "        self._variable_manager = variable_manager",
            "        variable_manager._hostvars = self",
            "",
            "    def set_inventory(self, inventory):",
            "        self._inventory = inventory",
            "",
            "    def _find_host(self, host_name):",
            "        # does not use inventory.hosts so it can create localhost on demand",
            "        return self._inventory.get_host(host_name)",
            "",
            "    def raw_get(self, host_name):",
            "        '''",
            "        Similar to __getitem__, however the returned data is not run through",
            "        the templating engine to expand variables in the hostvars.",
            "        '''",
            "        host = self._find_host(host_name)",
            "        if host is None:",
            "            return AnsibleUndefined(name=\"hostvars['%s']\" % host_name)",
            "",
            "        return self._variable_manager.get_vars(host=host, include_hostvars=False)",
            "",
            "    def __setstate__(self, state):",
            "        self.__dict__.update(state)",
            "",
            "        # Methods __getstate__ and __setstate__ of VariableManager do not",
            "        # preserve _loader and _hostvars attributes to improve pickle",
            "        # performance and memory utilization. Since HostVars holds values",
            "        # of those attributes already, assign them if needed.",
            "        if self._variable_manager._loader is None:",
            "            self._variable_manager._loader = self._loader",
            "",
            "        if self._variable_manager._hostvars is None:",
            "            self._variable_manager._hostvars = self",
            "",
            "    def __getitem__(self, host_name):",
            "        data = self.raw_get(host_name)",
            "        if isinstance(data, AnsibleUndefined):",
            "            return data",
            "        return HostVarsVars(data, loader=self._loader)",
            "",
            "    def set_host_variable(self, host, varname, value):",
            "        self._variable_manager.set_host_variable(host, varname, value)",
            "",
            "    def set_nonpersistent_facts(self, host, facts):",
            "        self._variable_manager.set_nonpersistent_facts(host, facts)",
            "",
            "    def set_host_facts(self, host, facts):",
            "        self._variable_manager.set_host_facts(host, facts)",
            "",
            "    def __contains__(self, host_name):",
            "        # does not use inventory.hosts so it can create localhost on demand",
            "        return self._find_host(host_name) is not None",
            "",
            "    def __iter__(self):",
            "        # include implicit localhost only if it has variables set",
            "        yield from self._inventory.hosts | {'localhost': self._inventory.localhost} if self._inventory.localhost else {}",
            "",
            "    def __len__(self):",
            "        # include implicit localhost only if it has variables set",
            "        return len(self._inventory.hosts) + (1 if self._inventory.localhost else 0)",
            "",
            "    def __repr__(self):",
            "        out = {}",
            "        for host in self._inventory.hosts:",
            "            out[host] = self.get(host)",
            "        return repr(out)",
            "",
            "    def __deepcopy__(self, memo):",
            "        # We do not need to deepcopy because HostVars is immutable,",
            "        # however we have to implement the method so we can deepcopy",
            "        # variables' dicts that contain HostVars.",
            "        return self",
            "",
            "",
            "class HostVarsVars(Mapping):",
            "",
            "    def __init__(self, variables, loader):",
            "        self._vars = variables",
            "        self._loader = loader",
            "",
            "    @cached_property",
            "    def _templar(self):",
            "        # NOTE: this only has access to the host's own vars,",
            "        # so templates that depend on vars in other scopes will not work.",
            "        return Templar(variables=self._vars, loader=self._loader)",
            "",
            "    def __getitem__(self, var):",
            "        return self._templar.template(self._vars[var], fail_on_undefined=False, static_vars=C.INTERNAL_STATIC_VARS)",
            "",
            "    def __contains__(self, var):",
            "        return (var in self._vars)",
            "",
            "    def __iter__(self):",
            "        yield from self._vars.keys()",
            "",
            "    def __len__(self):",
            "        return len(self._vars.keys())",
            "",
            "    def __repr__(self):",
            "        return repr(self._templar.template(self._vars, fail_on_undefined=False, static_vars=C.INTERNAL_STATIC_VARS))",
            "",
            "    def __getstate__(self):",
            "        ''' override serialization here to avoid",
            "            pickle issues with templar and Jinja native'''",
            "        state = self.__dict__.copy()",
            "        state.pop('_templar', None)",
            "        return state"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "95": [
                "HostVars",
                "__iter__"
            ],
            "98": [
                "HostVars",
                "__len__"
            ]
        },
        "addLocation": []
    }
}