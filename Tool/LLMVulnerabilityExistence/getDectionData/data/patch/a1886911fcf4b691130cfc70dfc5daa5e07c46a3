{
    "lib/ansible/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " DEFAULT_INVENTORY_IGNORE  = get_config(p, DEFAULTS, 'inventory_ignore_extensions', 'ANSIBLE_INVENTORY_IGNORE', [\"~\", \".orig\", \".bak\", \".ini\", \".cfg\", \".retry\", \".pyc\", \".pyo\"], value_type='list')"
            },
            "1": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": " DEFAULT_VAR_COMPRESSION_LEVEL = get_config(p, DEFAULTS, 'var_compression_level', 'ANSIBLE_VAR_COMPRESSION_LEVEL', 0, value_type='integer')"
            },
            "2": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " DEFAULT_INTERNAL_POLL_INTERVAL = get_config(p, DEFAULTS, 'internal_poll_interval', None, 0.001, value_type='float')"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+DEFAULT_ALLOW_UNSAFE_LOOKUPS = get_config(p, DEFAULTS, 'allow_unsafe_lookups', None, False, value_type='boolean')"
            },
            "4": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " ERROR_ON_MISSING_HANDLER  = get_config(p, DEFAULTS, 'error_on_missing_handler', 'ANSIBLE_ERROR_ON_MISSING_HANDLER', True, value_type='boolean')"
            },
            "5": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 239,
                "PatchRowcode": " SHOW_CUSTOM_STATS = get_config(p, DEFAULTS, 'show_custom_stats', 'ANSIBLE_SHOW_CUSTOM_STATS', False, value_type='boolean')"
            },
            "6": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import tempfile",
            "from string import ascii_letters, digits",
            "",
            "from ansible.compat.six import string_types",
            "from ansible.compat.six.moves import configparser",
            "from ansible.errors import AnsibleOptionsError",
            "from ansible.module_utils._text import to_text",
            "from ansible.parsing.quoting import unquote",
            "from ansible.utils.path import makedirs_safe",
            "",
            "BOOL_TRUE = frozenset([ \"true\", \"t\", \"y\", \"1\", \"yes\", \"on\" ])",
            "",
            "def mk_boolean(value):",
            "    ret = value",
            "    if not isinstance(value, bool):",
            "        if value is None:",
            "            ret = False",
            "        ret = (str(value).lower() in BOOL_TRUE)",
            "    return ret",
            "",
            "def shell_expand(path, expand_relative_paths=False):",
            "    '''",
            "    shell_expand is needed as os.path.expanduser does not work",
            "    when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE",
            "    '''",
            "    if path:",
            "        path = os.path.expanduser(os.path.expandvars(path))",
            "        if expand_relative_paths and not path.startswith('/'):",
            "            # paths are always 'relative' to the config?",
            "            if 'CONFIG_FILE' in globals():",
            "                CFGDIR = os.path.dirname(CONFIG_FILE)",
            "                path = os.path.join(CFGDIR, path)",
            "            path = os.path.abspath(path)",
            "    return path",
            "",
            "def get_config(p, section, key, env_var, default, value_type=None, expand_relative_paths=False):",
            "    ''' return a configuration variable with casting",
            "",
            "    :arg p: A ConfigParser object to look for the configuration in",
            "    :arg section: A section of the ini config that should be examined for this section.",
            "    :arg key: The config key to get this config from",
            "    :arg env_var: An Environment variable to check for the config var.  If",
            "        this is set to None then no environment variable will be used.",
            "    :arg default: A default value to assign to the config var if nothing else sets it.",
            "    :kwarg value_type: The type of the value.  This can be any of the following strings:",
            "        :boolean: sets the value to a True or False value",
            "        :integer: Sets the value to an integer or raises a ValueType error",
            "        :float: Sets the value to a float or raises a ValueType error",
            "        :list: Treats the value as a comma separated list.  Split the value",
            "            and return it as a python list.",
            "        :none: Sets the value to None",
            "        :path: Expands any environment variables and tilde's in the value.",
            "        :tmp_path: Create a unique temporary directory inside of the directory",
            "            specified by value and return its path.",
            "        :pathlist: Treat the value as a typical PATH string.  (On POSIX, this",
            "            means colon separated strings.)  Split the value and then expand",
            "            each part for environment variables and tildes.",
            "    :kwarg expand_relative_paths: for pathlist and path types, if this is set",
            "        to True then also change any relative paths into absolute paths.  The",
            "        default is False.",
            "    '''",
            "    value = _get_config(p, section, key, env_var, default)",
            "    if value_type == 'boolean':",
            "        value = mk_boolean(value)",
            "",
            "    elif value:",
            "        if value_type == 'integer':",
            "            value = int(value)",
            "",
            "        elif value_type == 'float':",
            "            value = float(value)",
            "",
            "        elif value_type == 'list':",
            "            if isinstance(value, string_types):",
            "                value = [x.strip() for x in value.split(',')]",
            "",
            "        elif value_type == 'none':",
            "            if value == \"None\":",
            "                value = None",
            "",
            "        elif value_type == 'path':",
            "            value = shell_expand(value, expand_relative_paths=expand_relative_paths)",
            "",
            "        elif value_type == 'tmppath':",
            "            value = shell_expand(value)",
            "            if not os.path.exists(value):",
            "                makedirs_safe(value, 0o700)",
            "            prefix = 'ansible-local-%s' % os.getpid()",
            "            value = tempfile.mkdtemp(prefix=prefix, dir=value)",
            "",
            "        elif value_type == 'pathlist':",
            "            if isinstance(value, string_types):",
            "                value = [shell_expand(x, expand_relative_paths=expand_relative_paths) \\",
            "                         for x in value.split(os.pathsep)]",
            "",
            "        elif isinstance(value, string_types):",
            "            value = unquote(value)",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "def _get_config(p, section, key, env_var, default):",
            "    ''' helper function for get_config '''",
            "    value = default",
            "",
            "    if p is not None:",
            "        try:",
            "            value = p.get(section, key, raw=True)",
            "        except:",
            "            pass",
            "",
            "    if env_var is not None:",
            "        env_value = os.environ.get(env_var, None)",
            "        if env_value is not None:",
            "            value = env_value",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "def load_config_file():",
            "    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''",
            "",
            "    p = configparser.ConfigParser()",
            "",
            "    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)",
            "    if path0 is not None:",
            "        path0 = os.path.expanduser(path0)",
            "        if os.path.isdir(path0):",
            "            path0 += \"/ansible.cfg\"",
            "    try:",
            "        path1 = os.getcwd() + \"/ansible.cfg\"",
            "    except OSError:",
            "        path1 = None",
            "    path2 = os.path.expanduser(\"~/.ansible.cfg\")",
            "    path3 = \"/etc/ansible/ansible.cfg\"",
            "",
            "    for path in [path0, path1, path2, path3]:",
            "        if path is not None and os.path.exists(path):",
            "            try:",
            "                p.read(path)",
            "            except configparser.Error as e:",
            "                raise AnsibleOptionsError(\"Error reading config file: \\n{0}\".format(e))",
            "            return p, path",
            "    return None, ''",
            "",
            "",
            "p, CONFIG_FILE = load_config_file()",
            "",
            "# check all of these extensions when looking for yaml files for things like",
            "# group variables -- really anything we can load",
            "YAML_FILENAME_EXTENSIONS = [ \"\", \".yml\", \".yaml\", \".json\" ]",
            "",
            "# the default whitelist for cow stencils",
            "DEFAULT_COW_WHITELIST = ['bud-frogs', 'bunny', 'cheese', 'daemon', 'default', 'dragon', 'elephant-in-snake', 'elephant',",
            "                         'eyes', 'hellokitty', 'kitty', 'luke-koala', 'meow', 'milk', 'moofasa', 'moose', 'ren', 'sheep',",
            "                         'small', 'stegosaurus', 'stimpy', 'supermilker', 'three-eyes', 'turkey', 'turtle', 'tux', 'udder',",
            "                         'vader-koala', 'vader', 'www',]",
            "",
            "# sections in config file",
            "DEFAULTS='defaults'",
            "",
            "# FIXME: add deprecation warning when these get set",
            "#### DEPRECATED VARS ####",
            "# use more sanely named 'inventory'",
            "DEPRECATED_HOST_LIST  = get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS', '/etc/ansible/hosts', value_type='path')",
            "# this is not used since 0.5 but people might still have in config",
            "DEFAULT_PATTERN           = get_config(p, DEFAULTS, 'pattern', None, None)",
            "# If --tags or --skip-tags is given multiple times on the CLI and this is",
            "# True, merge the lists of tags together.  If False, let the last argument",
            "# overwrite any previous ones.  Behaviour is overwrite through 2.2.  2.3",
            "# overwrites but prints deprecation.  2.4 the default is to merge.",
            "MERGE_MULTIPLE_CLI_TAGS = get_config(p, DEFAULTS, 'merge_multiple_cli_tags', 'ANSIBLE_MERGE_MULTIPLE_CLI_TAGS', False, value_type='boolean')",
            "",
            "#### GENERALLY CONFIGURABLE THINGS ####",
            "DEFAULT_DEBUG             = get_config(p, DEFAULTS, 'debug',            'ANSIBLE_DEBUG',            False, value_type='boolean')",
            "DEFAULT_VERBOSITY         = get_config(p, DEFAULTS, 'verbosity',        'ANSIBLE_VERBOSITY',        0, value_type='integer')",
            "DEFAULT_HOST_LIST         = get_config(p, DEFAULTS,'inventory', 'ANSIBLE_INVENTORY', DEPRECATED_HOST_LIST, value_type='path')",
            "DEFAULT_ROLES_PATH        = get_config(p, DEFAULTS, 'roles_path',       'ANSIBLE_ROLES_PATH',       '/etc/ansible/roles', value_type='pathlist', expand_relative_paths=True)",
            "DEFAULT_REMOTE_TMP        = get_config(p, DEFAULTS, 'remote_tmp',       'ANSIBLE_REMOTE_TEMP',      '~/.ansible/tmp')",
            "DEFAULT_LOCAL_TMP         = get_config(p, DEFAULTS, 'local_tmp',        'ANSIBLE_LOCAL_TEMP',      '~/.ansible/tmp', value_type='tmppath')",
            "DEFAULT_MODULE_NAME       = get_config(p, DEFAULTS, 'module_name',      None,                       'command')",
            "DEFAULT_FACT_PATH         = get_config(p, DEFAULTS, 'fact_path',        'ANSIBLE_FACT_PATH', None, value_type='path')",
            "DEFAULT_FORKS             = get_config(p, DEFAULTS, 'forks',            'ANSIBLE_FORKS',            5, value_type='integer')",
            "DEFAULT_MODULE_ARGS       = get_config(p, DEFAULTS, 'module_args',      'ANSIBLE_MODULE_ARGS',      '')",
            "DEFAULT_MODULE_LANG       = get_config(p, DEFAULTS, 'module_lang',      'ANSIBLE_MODULE_LANG',      os.getenv('LANG', 'en_US.UTF-8'))",
            "DEFAULT_MODULE_SET_LOCALE = get_config(p, DEFAULTS, 'module_set_locale','ANSIBLE_MODULE_SET_LOCALE',False, value_type='boolean')",
            "DEFAULT_MODULE_COMPRESSION= get_config(p, DEFAULTS, 'module_compression', None, 'ZIP_DEFLATED')",
            "DEFAULT_TIMEOUT           = get_config(p, DEFAULTS, 'timeout',          'ANSIBLE_TIMEOUT',          10, value_type='integer')",
            "DEFAULT_POLL_INTERVAL     = get_config(p, DEFAULTS, 'poll_interval',    'ANSIBLE_POLL_INTERVAL',    15, value_type='integer')",
            "DEFAULT_REMOTE_USER       = get_config(p, DEFAULTS, 'remote_user',      'ANSIBLE_REMOTE_USER',      None)",
            "DEFAULT_ASK_PASS          = get_config(p, DEFAULTS, 'ask_pass',  'ANSIBLE_ASK_PASS',    False, value_type='boolean')",
            "DEFAULT_PRIVATE_KEY_FILE  = get_config(p, DEFAULTS, 'private_key_file', 'ANSIBLE_PRIVATE_KEY_FILE', None, value_type='path')",
            "DEFAULT_REMOTE_PORT       = get_config(p, DEFAULTS, 'remote_port',      'ANSIBLE_REMOTE_PORT',      None, value_type='integer')",
            "DEFAULT_ASK_VAULT_PASS    = get_config(p, DEFAULTS, 'ask_vault_pass',    'ANSIBLE_ASK_VAULT_PASS',    False, value_type='boolean')",
            "DEFAULT_VAULT_PASSWORD_FILE = get_config(p, DEFAULTS, 'vault_password_file', 'ANSIBLE_VAULT_PASSWORD_FILE', None, value_type='path')",
            "DEFAULT_TRANSPORT         = get_config(p, DEFAULTS, 'transport',        'ANSIBLE_TRANSPORT',        'smart')",
            "DEFAULT_SCP_IF_SSH        = get_config(p, 'ssh_connection', 'scp_if_ssh',       'ANSIBLE_SCP_IF_SSH',       'smart')",
            "DEFAULT_SFTP_BATCH_MODE   = get_config(p, 'ssh_connection', 'sftp_batch_mode', 'ANSIBLE_SFTP_BATCH_MODE', True, value_type='boolean')",
            "DEFAULT_SSH_TRANSFER_METHOD = get_config(p, 'ssh_connection', 'transfer_method', 'ANSIBLE_SSH_TRANSFER_METHOD', None)",
            "DEFAULT_MANAGED_STR       = get_config(p, DEFAULTS, 'ansible_managed',  None,           'Ansible managed')",
            "DEFAULT_SYSLOG_FACILITY   = get_config(p, DEFAULTS, 'syslog_facility',  'ANSIBLE_SYSLOG_FACILITY', 'LOG_USER')",
            "DEFAULT_KEEP_REMOTE_FILES = get_config(p, DEFAULTS, 'keep_remote_files', 'ANSIBLE_KEEP_REMOTE_FILES', False, value_type='boolean')",
            "DEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')",
            "DEFAULT_PRIVATE_ROLE_VARS = get_config(p, DEFAULTS, 'private_role_vars', 'ANSIBLE_PRIVATE_ROLE_VARS', False, value_type='boolean')",
            "DEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)",
            "DEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')",
            "DEFAULT_GATHERING         = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()",
            "DEFAULT_GATHER_SUBSET     = get_config(p, DEFAULTS, 'gather_subset', 'ANSIBLE_GATHER_SUBSET', 'all').lower()",
            "DEFAULT_GATHER_TIMEOUT    = get_config(p, DEFAULTS, 'gather_timeout', 'ANSIBLE_GATHER_TIMEOUT', 10, value_type='integer')",
            "DEFAULT_LOG_PATH          = get_config(p, DEFAULTS, 'log_path',           'ANSIBLE_LOG_PATH', '', value_type='path')",
            "DEFAULT_FORCE_HANDLERS    = get_config(p, DEFAULTS, 'force_handlers', 'ANSIBLE_FORCE_HANDLERS', False, value_type='boolean')",
            "DEFAULT_INVENTORY_IGNORE  = get_config(p, DEFAULTS, 'inventory_ignore_extensions', 'ANSIBLE_INVENTORY_IGNORE', [\"~\", \".orig\", \".bak\", \".ini\", \".cfg\", \".retry\", \".pyc\", \".pyo\"], value_type='list')",
            "DEFAULT_VAR_COMPRESSION_LEVEL = get_config(p, DEFAULTS, 'var_compression_level', 'ANSIBLE_VAR_COMPRESSION_LEVEL', 0, value_type='integer')",
            "DEFAULT_INTERNAL_POLL_INTERVAL = get_config(p, DEFAULTS, 'internal_poll_interval', None, 0.001, value_type='float')",
            "ERROR_ON_MISSING_HANDLER  = get_config(p, DEFAULTS, 'error_on_missing_handler', 'ANSIBLE_ERROR_ON_MISSING_HANDLER', True, value_type='boolean')",
            "SHOW_CUSTOM_STATS = get_config(p, DEFAULTS, 'show_custom_stats', 'ANSIBLE_SHOW_CUSTOM_STATS', False, value_type='boolean')",
            "",
            "# static includes",
            "DEFAULT_TASK_INCLUDES_STATIC    = get_config(p, DEFAULTS, 'task_includes_static', 'ANSIBLE_TASK_INCLUDES_STATIC', False, value_type='boolean')",
            "DEFAULT_HANDLER_INCLUDES_STATIC = get_config(p, DEFAULTS, 'handler_includes_static', 'ANSIBLE_HANDLER_INCLUDES_STATIC', False, value_type='boolean')",
            "",
            "# disclosure",
            "DEFAULT_NO_LOG           = get_config(p, DEFAULTS, 'no_log', 'ANSIBLE_NO_LOG', False, value_type='boolean')",
            "DEFAULT_NO_TARGET_SYSLOG   = get_config(p, DEFAULTS, 'no_target_syslog', 'ANSIBLE_NO_TARGET_SYSLOG', False, value_type='boolean')",
            "ALLOW_WORLD_READABLE_TMPFILES = get_config(p, DEFAULTS, 'allow_world_readable_tmpfiles', None, False, value_type='boolean')",
            "",
            "# selinux",
            "DEFAULT_SELINUX_SPECIAL_FS = get_config(p, 'selinux', 'special_context_filesystems', None, 'fuse, nfs, vboxsf, ramfs, 9p', value_type='list')",
            "DEFAULT_LIBVIRT_LXC_NOSECLABEL = get_config(p, 'selinux', 'libvirt_lxc_noseclabel', 'LIBVIRT_LXC_NOSECLABEL', False, value_type='boolean')",
            "",
            "### PRIVILEGE ESCALATION ###",
            "# Backwards Compat",
            "DEFAULT_SU                = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, value_type='boolean')",
            "DEFAULT_SU_USER           = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')",
            "DEFAULT_SU_EXE            = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', None)",
            "DEFAULT_SU_FLAGS          = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', None)",
            "DEFAULT_ASK_SU_PASS       = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, value_type='boolean')",
            "DEFAULT_SUDO              = get_config(p, DEFAULTS, 'sudo', 'ANSIBLE_SUDO', False, value_type='boolean')",
            "DEFAULT_SUDO_USER         = get_config(p, DEFAULTS, 'sudo_user',        'ANSIBLE_SUDO_USER',        'root')",
            "DEFAULT_SUDO_EXE          = get_config(p, DEFAULTS, 'sudo_exe', 'ANSIBLE_SUDO_EXE', None)",
            "DEFAULT_SUDO_FLAGS        = get_config(p, DEFAULTS, 'sudo_flags', 'ANSIBLE_SUDO_FLAGS', '-H -S -n')",
            "DEFAULT_ASK_SUDO_PASS     = get_config(p, DEFAULTS, 'ask_sudo_pass',    'ANSIBLE_ASK_SUDO_PASS',    False, value_type='boolean')",
            "",
            "# Become",
            "BECOME_ERROR_STRINGS      = {'sudo': 'Sorry, try again.', 'su': 'Authentication failure', 'pbrun': '', 'pfexec': '', 'doas': 'Permission denied', 'dzdo': '', 'ksu': 'Password incorrect'} #FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS    = {'sudo': 'sorry, a password is required to run sudo', 'su': '', 'pbrun': '', 'pfexec': '', 'doas': 'Authorization required', 'dzdo': '', 'ksu': 'No password given'} #FIXME: deal with i18n",
            "BECOME_METHODS            = ['sudo','su','pbrun','pfexec','doas','dzdo','ksu','runas']",
            "BECOME_ALLOW_SAME_USER    = get_config(p, 'privilege_escalation', 'become_allow_same_user', 'ANSIBLE_BECOME_ALLOW_SAME_USER', False, value_type='boolean')",
            "DEFAULT_BECOME_METHOD     = get_config(p, 'privilege_escalation', 'become_method', 'ANSIBLE_BECOME_METHOD','sudo' if DEFAULT_SUDO else 'su' if DEFAULT_SU else 'sudo' ).lower()",
            "DEFAULT_BECOME            = get_config(p, 'privilege_escalation', 'become', 'ANSIBLE_BECOME',False, value_type='boolean')",
            "DEFAULT_BECOME_USER       = get_config(p, 'privilege_escalation', 'become_user', 'ANSIBLE_BECOME_USER', 'root')",
            "DEFAULT_BECOME_EXE        = get_config(p, 'privilege_escalation', 'become_exe', 'ANSIBLE_BECOME_EXE', None)",
            "DEFAULT_BECOME_FLAGS      = get_config(p, 'privilege_escalation', 'become_flags', 'ANSIBLE_BECOME_FLAGS', None)",
            "DEFAULT_BECOME_ASK_PASS   = get_config(p, 'privilege_escalation', 'become_ask_pass', 'ANSIBLE_BECOME_ASK_PASS', False, value_type='boolean')",
            "",
            "",
            "# PLUGINS",
            "",
            "# Modules that can optimize with_items loops into a single call.  Currently",
            "# these modules must (1) take a \"name\" or \"pkg\" parameter that is a list.  If",
            "# the module takes both, bad things could happen.",
            "# In the future we should probably generalize this even further",
            "# (mapping of param: squash field)",
            "DEFAULT_SQUASH_ACTIONS         = get_config(p, DEFAULTS, 'squash_actions',     'ANSIBLE_SQUASH_ACTIONS', \"apk, apt, dnf, homebrew, openbsd_pkg, pacman, pkgng, yum, zypper\", value_type='list')",
            "# paths",
            "",
            "DEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '~/.ansible/plugins/action:/usr/share/ansible/plugins/action', value_type='pathlist')",
            "DEFAULT_CACHE_PLUGIN_PATH      = get_config(p, DEFAULTS, 'cache_plugins',      'ANSIBLE_CACHE_PLUGINS', '~/.ansible/plugins/cache:/usr/share/ansible/plugins/cache', value_type='pathlist')",
            "DEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '~/.ansible/plugins/callback:/usr/share/ansible/plugins/callback', value_type='pathlist')",
            "DEFAULT_CONNECTION_PLUGIN_PATH = get_config(p, DEFAULTS, 'connection_plugins', 'ANSIBLE_CONNECTION_PLUGINS', '~/.ansible/plugins/connection:/usr/share/ansible/plugins/connection', value_type='pathlist')",
            "DEFAULT_LOOKUP_PLUGIN_PATH     = get_config(p, DEFAULTS, 'lookup_plugins',     'ANSIBLE_LOOKUP_PLUGINS', '~/.ansible/plugins/lookup:/usr/share/ansible/plugins/lookup', value_type='pathlist')",
            "DEFAULT_MODULE_PATH            = get_config(p, DEFAULTS, 'library',            'ANSIBLE_LIBRARY',        None, value_type='pathlist')",
            "DEFAULT_MODULE_UTILS_PATH      = get_config(p, DEFAULTS, 'module_utils',       'ANSIBLE_MODULE_UTILS',   None, value_type='pathlist')",
            "DEFAULT_INVENTORY_PLUGIN_PATH  = get_config(p, DEFAULTS, 'inventory_plugins',  'ANSIBLE_INVENTORY_PLUGINS', '~/.ansible/plugins/inventory:/usr/share/ansible/plugins/inventory', value_type='pathlist')",
            "DEFAULT_VARS_PLUGIN_PATH       = get_config(p, DEFAULTS, 'vars_plugins',       'ANSIBLE_VARS_PLUGINS', '~/.ansible/plugins/vars:/usr/share/ansible/plugins/vars', value_type='pathlist')",
            "DEFAULT_FILTER_PLUGIN_PATH     = get_config(p, DEFAULTS, 'filter_plugins',     'ANSIBLE_FILTER_PLUGINS', '~/.ansible/plugins/filter:/usr/share/ansible/plugins/filter', value_type='pathlist')",
            "DEFAULT_TEST_PLUGIN_PATH       = get_config(p, DEFAULTS, 'test_plugins',       'ANSIBLE_TEST_PLUGINS', '~/.ansible/plugins/test:/usr/share/ansible/plugins/test', value_type='pathlist')",
            "DEFAULT_STRATEGY_PLUGIN_PATH   = get_config(p, DEFAULTS, 'strategy_plugins',   'ANSIBLE_STRATEGY_PLUGINS', '~/.ansible/plugins/strategy:/usr/share/ansible/plugins/strategy', value_type='pathlist')",
            "",
            "NETWORK_GROUP_MODULES          = get_config(p, DEFAULTS, 'network_group_modules','NETWORK_GROUP_MODULES', ['eos', 'nxos', 'ios', 'iosxr', 'junos',",
            "                                                                                                           'vyos', 'sros', 'dellos9', 'dellos10', 'dellos6'],",
            "                                            value_type='list')",
            "",
            "DEFAULT_STRATEGY               = get_config(p, DEFAULTS, 'strategy',           'ANSIBLE_STRATEGY', 'linear')",
            "DEFAULT_STDOUT_CALLBACK        = get_config(p, DEFAULTS, 'stdout_callback',    'ANSIBLE_STDOUT_CALLBACK', 'default')",
            "# cache",
            "CACHE_PLUGIN                   = get_config(p, DEFAULTS, 'fact_caching', 'ANSIBLE_CACHE_PLUGIN', 'memory')",
            "CACHE_PLUGIN_CONNECTION        = get_config(p, DEFAULTS, 'fact_caching_connection', 'ANSIBLE_CACHE_PLUGIN_CONNECTION', None)",
            "CACHE_PLUGIN_PREFIX            = get_config(p, DEFAULTS, 'fact_caching_prefix', 'ANSIBLE_CACHE_PLUGIN_PREFIX', 'ansible_facts')",
            "CACHE_PLUGIN_TIMEOUT           = get_config(p, DEFAULTS, 'fact_caching_timeout', 'ANSIBLE_CACHE_PLUGIN_TIMEOUT', 24 * 60 * 60, value_type='integer')",
            "",
            "# Display",
            "ANSIBLE_FORCE_COLOR            = get_config(p, DEFAULTS, 'force_color', 'ANSIBLE_FORCE_COLOR', None, value_type='boolean')",
            "ANSIBLE_NOCOLOR                = get_config(p, DEFAULTS, 'nocolor', 'ANSIBLE_NOCOLOR', None, value_type='boolean')",
            "ANSIBLE_NOCOWS                 = get_config(p, DEFAULTS, 'nocows', 'ANSIBLE_NOCOWS', None, value_type='boolean')",
            "ANSIBLE_COW_SELECTION          = get_config(p, DEFAULTS, 'cow_selection', 'ANSIBLE_COW_SELECTION', 'default')",
            "ANSIBLE_COW_WHITELIST          = get_config(p, DEFAULTS, 'cow_whitelist', 'ANSIBLE_COW_WHITELIST', DEFAULT_COW_WHITELIST, value_type='list')",
            "DISPLAY_SKIPPED_HOSTS          = get_config(p, DEFAULTS, 'display_skipped_hosts', 'DISPLAY_SKIPPED_HOSTS', True, value_type='boolean')",
            "DEFAULT_UNDEFINED_VAR_BEHAVIOR = get_config(p, DEFAULTS, 'error_on_undefined_vars', 'ANSIBLE_ERROR_ON_UNDEFINED_VARS', True, value_type='boolean')",
            "HOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, value_type='boolean')",
            "SYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, value_type='boolean')",
            "DEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, value_type='boolean')",
            "DEFAULT_CALLABLE_WHITELIST     = get_config(p, DEFAULTS, 'callable_whitelist', 'ANSIBLE_CALLABLE_WHITELIST', [], value_type='list')",
            "COMMAND_WARNINGS               = get_config(p, DEFAULTS, 'command_warnings', 'ANSIBLE_COMMAND_WARNINGS', True, value_type='boolean')",
            "DEFAULT_LOAD_CALLBACK_PLUGINS  = get_config(p, DEFAULTS, 'bin_ansible_callbacks', 'ANSIBLE_LOAD_CALLBACK_PLUGINS', False, value_type='boolean')",
            "DEFAULT_CALLBACK_WHITELIST     = get_config(p, DEFAULTS, 'callback_whitelist', 'ANSIBLE_CALLBACK_WHITELIST', [], value_type='list')",
            "RETRY_FILES_ENABLED            = get_config(p, DEFAULTS, 'retry_files_enabled', 'ANSIBLE_RETRY_FILES_ENABLED', True, value_type='boolean')",
            "RETRY_FILES_SAVE_PATH          = get_config(p, DEFAULTS, 'retry_files_save_path', 'ANSIBLE_RETRY_FILES_SAVE_PATH', None, value_type='path')",
            "DEFAULT_NULL_REPRESENTATION    = get_config(p, DEFAULTS, 'null_representation', 'ANSIBLE_NULL_REPRESENTATION', None, value_type='none')",
            "DISPLAY_ARGS_TO_STDOUT         = get_config(p, DEFAULTS, 'display_args_to_stdout', 'ANSIBLE_DISPLAY_ARGS_TO_STDOUT', False, value_type='boolean')",
            "MAX_FILE_SIZE_FOR_DIFF         = get_config(p, DEFAULTS, 'max_diff_size', 'ANSIBLE_MAX_DIFF_SIZE', 1024*1024, value_type='integer')",
            "",
            "# CONNECTION RELATED",
            "USE_PERSISTENT_CONNECTIONS     = get_config(p, DEFAULTS, 'use_persistent_connections', 'ANSIBLE_USE_PERSISTENT_CONNECTIONS', False, value_type='boolean')",
            "ANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', '-C -o ControlMaster=auto -o ControlPersist=60s')",
            "### WARNING: Someone might be tempted to switch this from percent-formatting",
            "# to .format() in the future.  be sure to read this:",
            "# http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/ and understand",
            "# that it may be a security risk to do so.",
            "ANSIBLE_SSH_CONTROL_PATH       = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH', None)",
            "ANSIBLE_SSH_CONTROL_PATH_DIR   = get_config(p, 'ssh_connection', 'control_path_dir', 'ANSIBLE_SSH_CONTROL_PATH_DIR', u'~/.ansible/cp')",
            "ANSIBLE_SSH_PIPELINING         = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, value_type='boolean')",
            "ANSIBLE_SSH_RETRIES            = get_config(p, 'ssh_connection', 'retries', 'ANSIBLE_SSH_RETRIES', 0, value_type='integer')",
            "ANSIBLE_SSH_EXECUTABLE         = get_config(p, 'ssh_connection', 'ssh_executable', 'ANSIBLE_SSH_EXECUTABLE', 'ssh')",
            "PARAMIKO_RECORD_HOST_KEYS      = get_config(p, 'paramiko_connection', 'record_host_keys', 'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, value_type='boolean')",
            "PARAMIKO_HOST_KEY_AUTO_ADD     = get_config(p, 'paramiko_connection', 'host_key_auto_add', 'ANSIBLE_PARAMIKO_HOST_KEY_AUTO_ADD', False, value_type='boolean')",
            "PARAMIKO_PROXY_COMMAND         = get_config(p, 'paramiko_connection', 'proxy_command', 'ANSIBLE_PARAMIKO_PROXY_COMMAND', None)",
            "PARAMIKO_LOOK_FOR_KEYS         = get_config(p, 'paramiko_connection', 'look_for_keys', 'ANSIBLE_PARAMIKO_LOOK_FOR_KEYS', True, value_type='boolean')",
            "PERSISTENT_CONNECT_TIMEOUT     = get_config(p, 'persistent_connection', 'connect_timeout', 'ANSIBLE_PERSISTENT_CONNECT_TIMEOUT', 30, value_type='integer')",
            "PERSISTENT_CONNECT_RETRIES     = get_config(p, 'persistent_connection', 'connect_retries', 'ANSIBLE_PERSISTENT_CONNECT_RETRIES', 30, value_type='integer')",
            "PERSISTENT_CONNECT_INTERVAL    = get_config(p, 'persistent_connection', 'connect_interval', 'ANSIBLE_PERSISTENT_CONNECT_INTERVAL', 1, value_type='integer')",
            "",
            "# obsolete -- will be formally removed",
            "ACCELERATE_PORT                = get_config(p, 'accelerate', 'accelerate_port', 'ACCELERATE_PORT', 5099, value_type='integer')",
            "ACCELERATE_TIMEOUT             = get_config(p, 'accelerate', 'accelerate_timeout', 'ACCELERATE_TIMEOUT', 30, value_type='integer')",
            "ACCELERATE_CONNECT_TIMEOUT     = get_config(p, 'accelerate', 'accelerate_connect_timeout', 'ACCELERATE_CONNECT_TIMEOUT', 1.0, value_type='float')",
            "ACCELERATE_DAEMON_TIMEOUT      = get_config(p, 'accelerate', 'accelerate_daemon_timeout', 'ACCELERATE_DAEMON_TIMEOUT', 30, value_type='integer')",
            "ACCELERATE_KEYS_DIR            = get_config(p, 'accelerate', 'accelerate_keys_dir', 'ACCELERATE_KEYS_DIR', '~/.fireball.keys')",
            "ACCELERATE_KEYS_DIR_PERMS      = get_config(p, 'accelerate', 'accelerate_keys_dir_perms', 'ACCELERATE_KEYS_DIR_PERMS', '700')",
            "ACCELERATE_KEYS_FILE_PERMS     = get_config(p, 'accelerate', 'accelerate_keys_file_perms', 'ACCELERATE_KEYS_FILE_PERMS', '600')",
            "ACCELERATE_MULTI_KEY           = get_config(p, 'accelerate', 'accelerate_multi_key', 'ACCELERATE_MULTI_KEY', False, value_type='boolean')",
            "PARAMIKO_PTY                   = get_config(p, 'paramiko_connection', 'pty', 'ANSIBLE_PARAMIKO_PTY', True, value_type='boolean')",
            "",
            "# galaxy related",
            "GALAXY_SERVER                  = get_config(p, 'galaxy', 'server', 'ANSIBLE_GALAXY_SERVER', 'https://galaxy.ansible.com')",
            "GALAXY_IGNORE_CERTS            = get_config(p, 'galaxy', 'ignore_certs', 'ANSIBLE_GALAXY_IGNORE', False, value_type='boolean')",
            "# this can be configured to blacklist SCMS but cannot add new ones unless the code is also updated",
            "GALAXY_SCMS                    = get_config(p, 'galaxy', 'scms', 'ANSIBLE_GALAXY_SCMS', 'git, hg', value_type='list')",
            "GALAXY_ROLE_SKELETON = get_config(p, 'galaxy', 'role_skeleton', 'ANSIBLE_GALAXY_ROLE_SKELETON', None, value_type='path')",
            "GALAXY_ROLE_SKELETON_IGNORE = get_config(p, 'galaxy', 'role_skeleton_ignore', 'ANSIBLE_GALAXY_ROLE_SKELETON_IGNORE', ['^.git$', '^.*/.git_keep$'], value_type='list')",
            "",
            "STRING_TYPE_FILTERS = get_config(p, 'jinja2', 'dont_type_filters', 'ANSIBLE_STRING_TYPE_FILTERS', ['string', 'to_json', 'to_nice_json', 'to_yaml', 'ppretty', 'json'], value_type='list' )",
            "",
            "# colors",
            "COLOR_HIGHLIGHT   = get_config(p, 'colors', 'highlight', 'ANSIBLE_COLOR_HIGHLIGHT', 'white')",
            "COLOR_VERBOSE     = get_config(p, 'colors', 'verbose', 'ANSIBLE_COLOR_VERBOSE', 'blue')",
            "COLOR_WARN        = get_config(p, 'colors', 'warn', 'ANSIBLE_COLOR_WARN', 'bright purple')",
            "COLOR_ERROR       = get_config(p, 'colors', 'error', 'ANSIBLE_COLOR_ERROR', 'red')",
            "COLOR_DEBUG       = get_config(p, 'colors', 'debug', 'ANSIBLE_COLOR_DEBUG', 'dark gray')",
            "COLOR_DEPRECATE   = get_config(p, 'colors', 'deprecate', 'ANSIBLE_COLOR_DEPRECATE', 'purple')",
            "COLOR_SKIP        = get_config(p, 'colors', 'skip', 'ANSIBLE_COLOR_SKIP', 'cyan')",
            "COLOR_UNREACHABLE = get_config(p, 'colors', 'unreachable', 'ANSIBLE_COLOR_UNREACHABLE', 'bright red')",
            "COLOR_OK          = get_config(p, 'colors', 'ok', 'ANSIBLE_COLOR_OK', 'green')",
            "COLOR_CHANGED     = get_config(p, 'colors', 'changed', 'ANSIBLE_COLOR_CHANGED', 'yellow')",
            "COLOR_DIFF_ADD    = get_config(p, 'colors', 'diff_add', 'ANSIBLE_COLOR_DIFF_ADD', 'green')",
            "COLOR_DIFF_REMOVE = get_config(p, 'colors', 'diff_remove', 'ANSIBLE_COLOR_DIFF_REMOVE', 'red')",
            "COLOR_DIFF_LINES  = get_config(p, 'colors', 'diff_lines', 'ANSIBLE_COLOR_DIFF_LINES', 'cyan')",
            "",
            "# diff",
            "DIFF_CONTEXT = get_config(p, 'diff', 'context', 'ANSIBLE_DIFF_CONTEXT', 3, value_type='integer')",
            "DIFF_ALWAYS = get_config(p, 'diff', 'always', 'ANSIBLE_DIFF_ALWAYS', False, value_type='bool')",
            "",
            "# non-configurable things",
            "MODULE_REQUIRE_ARGS       = ['command', 'win_command', 'shell', 'win_shell', 'raw', 'script']",
            "MODULE_NO_JSON            = ['command', 'win_command', 'shell', 'win_shell', 'raw']",
            "DEFAULT_BECOME_PASS       = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS         = None",
            "DEFAULT_REMOTE_PASS       = None",
            "DEFAULT_SUBSET            = None",
            "DEFAULT_SU_PASS           = None",
            "VAULT_VERSION_MIN         = 1.0",
            "VAULT_VERSION_MAX         = 1.0",
            "TREE_DIR                  = None",
            "LOCALHOST                 = frozenset(['127.0.0.1', 'localhost', '::1'])",
            "# module search",
            "BLACKLIST_EXTS = ('.pyc', '.swp', '.bak', '~', '.rpm', '.md', '.txt')",
            "IGNORE_FILES = [\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\"]",
            "INTERNAL_RESULT_KEYS      = ['add_host', 'add_group']",
            "RESTRICTED_RESULT_KEYS    = ['ansible_rsync_path', 'ansible_playbook_python']"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import tempfile",
            "from string import ascii_letters, digits",
            "",
            "from ansible.compat.six import string_types",
            "from ansible.compat.six.moves import configparser",
            "from ansible.errors import AnsibleOptionsError",
            "from ansible.module_utils._text import to_text",
            "from ansible.parsing.quoting import unquote",
            "from ansible.utils.path import makedirs_safe",
            "",
            "BOOL_TRUE = frozenset([ \"true\", \"t\", \"y\", \"1\", \"yes\", \"on\" ])",
            "",
            "def mk_boolean(value):",
            "    ret = value",
            "    if not isinstance(value, bool):",
            "        if value is None:",
            "            ret = False",
            "        ret = (str(value).lower() in BOOL_TRUE)",
            "    return ret",
            "",
            "def shell_expand(path, expand_relative_paths=False):",
            "    '''",
            "    shell_expand is needed as os.path.expanduser does not work",
            "    when path is None, which is the default for ANSIBLE_PRIVATE_KEY_FILE",
            "    '''",
            "    if path:",
            "        path = os.path.expanduser(os.path.expandvars(path))",
            "        if expand_relative_paths and not path.startswith('/'):",
            "            # paths are always 'relative' to the config?",
            "            if 'CONFIG_FILE' in globals():",
            "                CFGDIR = os.path.dirname(CONFIG_FILE)",
            "                path = os.path.join(CFGDIR, path)",
            "            path = os.path.abspath(path)",
            "    return path",
            "",
            "def get_config(p, section, key, env_var, default, value_type=None, expand_relative_paths=False):",
            "    ''' return a configuration variable with casting",
            "",
            "    :arg p: A ConfigParser object to look for the configuration in",
            "    :arg section: A section of the ini config that should be examined for this section.",
            "    :arg key: The config key to get this config from",
            "    :arg env_var: An Environment variable to check for the config var.  If",
            "        this is set to None then no environment variable will be used.",
            "    :arg default: A default value to assign to the config var if nothing else sets it.",
            "    :kwarg value_type: The type of the value.  This can be any of the following strings:",
            "        :boolean: sets the value to a True or False value",
            "        :integer: Sets the value to an integer or raises a ValueType error",
            "        :float: Sets the value to a float or raises a ValueType error",
            "        :list: Treats the value as a comma separated list.  Split the value",
            "            and return it as a python list.",
            "        :none: Sets the value to None",
            "        :path: Expands any environment variables and tilde's in the value.",
            "        :tmp_path: Create a unique temporary directory inside of the directory",
            "            specified by value and return its path.",
            "        :pathlist: Treat the value as a typical PATH string.  (On POSIX, this",
            "            means colon separated strings.)  Split the value and then expand",
            "            each part for environment variables and tildes.",
            "    :kwarg expand_relative_paths: for pathlist and path types, if this is set",
            "        to True then also change any relative paths into absolute paths.  The",
            "        default is False.",
            "    '''",
            "    value = _get_config(p, section, key, env_var, default)",
            "    if value_type == 'boolean':",
            "        value = mk_boolean(value)",
            "",
            "    elif value:",
            "        if value_type == 'integer':",
            "            value = int(value)",
            "",
            "        elif value_type == 'float':",
            "            value = float(value)",
            "",
            "        elif value_type == 'list':",
            "            if isinstance(value, string_types):",
            "                value = [x.strip() for x in value.split(',')]",
            "",
            "        elif value_type == 'none':",
            "            if value == \"None\":",
            "                value = None",
            "",
            "        elif value_type == 'path':",
            "            value = shell_expand(value, expand_relative_paths=expand_relative_paths)",
            "",
            "        elif value_type == 'tmppath':",
            "            value = shell_expand(value)",
            "            if not os.path.exists(value):",
            "                makedirs_safe(value, 0o700)",
            "            prefix = 'ansible-local-%s' % os.getpid()",
            "            value = tempfile.mkdtemp(prefix=prefix, dir=value)",
            "",
            "        elif value_type == 'pathlist':",
            "            if isinstance(value, string_types):",
            "                value = [shell_expand(x, expand_relative_paths=expand_relative_paths) \\",
            "                         for x in value.split(os.pathsep)]",
            "",
            "        elif isinstance(value, string_types):",
            "            value = unquote(value)",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "def _get_config(p, section, key, env_var, default):",
            "    ''' helper function for get_config '''",
            "    value = default",
            "",
            "    if p is not None:",
            "        try:",
            "            value = p.get(section, key, raw=True)",
            "        except:",
            "            pass",
            "",
            "    if env_var is not None:",
            "        env_value = os.environ.get(env_var, None)",
            "        if env_value is not None:",
            "            value = env_value",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "def load_config_file():",
            "    ''' Load Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''",
            "",
            "    p = configparser.ConfigParser()",
            "",
            "    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)",
            "    if path0 is not None:",
            "        path0 = os.path.expanduser(path0)",
            "        if os.path.isdir(path0):",
            "            path0 += \"/ansible.cfg\"",
            "    try:",
            "        path1 = os.getcwd() + \"/ansible.cfg\"",
            "    except OSError:",
            "        path1 = None",
            "    path2 = os.path.expanduser(\"~/.ansible.cfg\")",
            "    path3 = \"/etc/ansible/ansible.cfg\"",
            "",
            "    for path in [path0, path1, path2, path3]:",
            "        if path is not None and os.path.exists(path):",
            "            try:",
            "                p.read(path)",
            "            except configparser.Error as e:",
            "                raise AnsibleOptionsError(\"Error reading config file: \\n{0}\".format(e))",
            "            return p, path",
            "    return None, ''",
            "",
            "",
            "p, CONFIG_FILE = load_config_file()",
            "",
            "# check all of these extensions when looking for yaml files for things like",
            "# group variables -- really anything we can load",
            "YAML_FILENAME_EXTENSIONS = [ \"\", \".yml\", \".yaml\", \".json\" ]",
            "",
            "# the default whitelist for cow stencils",
            "DEFAULT_COW_WHITELIST = ['bud-frogs', 'bunny', 'cheese', 'daemon', 'default', 'dragon', 'elephant-in-snake', 'elephant',",
            "                         'eyes', 'hellokitty', 'kitty', 'luke-koala', 'meow', 'milk', 'moofasa', 'moose', 'ren', 'sheep',",
            "                         'small', 'stegosaurus', 'stimpy', 'supermilker', 'three-eyes', 'turkey', 'turtle', 'tux', 'udder',",
            "                         'vader-koala', 'vader', 'www',]",
            "",
            "# sections in config file",
            "DEFAULTS='defaults'",
            "",
            "# FIXME: add deprecation warning when these get set",
            "#### DEPRECATED VARS ####",
            "# use more sanely named 'inventory'",
            "DEPRECATED_HOST_LIST  = get_config(p, DEFAULTS, 'hostfile', 'ANSIBLE_HOSTS', '/etc/ansible/hosts', value_type='path')",
            "# this is not used since 0.5 but people might still have in config",
            "DEFAULT_PATTERN           = get_config(p, DEFAULTS, 'pattern', None, None)",
            "# If --tags or --skip-tags is given multiple times on the CLI and this is",
            "# True, merge the lists of tags together.  If False, let the last argument",
            "# overwrite any previous ones.  Behaviour is overwrite through 2.2.  2.3",
            "# overwrites but prints deprecation.  2.4 the default is to merge.",
            "MERGE_MULTIPLE_CLI_TAGS = get_config(p, DEFAULTS, 'merge_multiple_cli_tags', 'ANSIBLE_MERGE_MULTIPLE_CLI_TAGS', False, value_type='boolean')",
            "",
            "#### GENERALLY CONFIGURABLE THINGS ####",
            "DEFAULT_DEBUG             = get_config(p, DEFAULTS, 'debug',            'ANSIBLE_DEBUG',            False, value_type='boolean')",
            "DEFAULT_VERBOSITY         = get_config(p, DEFAULTS, 'verbosity',        'ANSIBLE_VERBOSITY',        0, value_type='integer')",
            "DEFAULT_HOST_LIST         = get_config(p, DEFAULTS,'inventory', 'ANSIBLE_INVENTORY', DEPRECATED_HOST_LIST, value_type='path')",
            "DEFAULT_ROLES_PATH        = get_config(p, DEFAULTS, 'roles_path',       'ANSIBLE_ROLES_PATH',       '/etc/ansible/roles', value_type='pathlist', expand_relative_paths=True)",
            "DEFAULT_REMOTE_TMP        = get_config(p, DEFAULTS, 'remote_tmp',       'ANSIBLE_REMOTE_TEMP',      '~/.ansible/tmp')",
            "DEFAULT_LOCAL_TMP         = get_config(p, DEFAULTS, 'local_tmp',        'ANSIBLE_LOCAL_TEMP',      '~/.ansible/tmp', value_type='tmppath')",
            "DEFAULT_MODULE_NAME       = get_config(p, DEFAULTS, 'module_name',      None,                       'command')",
            "DEFAULT_FACT_PATH         = get_config(p, DEFAULTS, 'fact_path',        'ANSIBLE_FACT_PATH', None, value_type='path')",
            "DEFAULT_FORKS             = get_config(p, DEFAULTS, 'forks',            'ANSIBLE_FORKS',            5, value_type='integer')",
            "DEFAULT_MODULE_ARGS       = get_config(p, DEFAULTS, 'module_args',      'ANSIBLE_MODULE_ARGS',      '')",
            "DEFAULT_MODULE_LANG       = get_config(p, DEFAULTS, 'module_lang',      'ANSIBLE_MODULE_LANG',      os.getenv('LANG', 'en_US.UTF-8'))",
            "DEFAULT_MODULE_SET_LOCALE = get_config(p, DEFAULTS, 'module_set_locale','ANSIBLE_MODULE_SET_LOCALE',False, value_type='boolean')",
            "DEFAULT_MODULE_COMPRESSION= get_config(p, DEFAULTS, 'module_compression', None, 'ZIP_DEFLATED')",
            "DEFAULT_TIMEOUT           = get_config(p, DEFAULTS, 'timeout',          'ANSIBLE_TIMEOUT',          10, value_type='integer')",
            "DEFAULT_POLL_INTERVAL     = get_config(p, DEFAULTS, 'poll_interval',    'ANSIBLE_POLL_INTERVAL',    15, value_type='integer')",
            "DEFAULT_REMOTE_USER       = get_config(p, DEFAULTS, 'remote_user',      'ANSIBLE_REMOTE_USER',      None)",
            "DEFAULT_ASK_PASS          = get_config(p, DEFAULTS, 'ask_pass',  'ANSIBLE_ASK_PASS',    False, value_type='boolean')",
            "DEFAULT_PRIVATE_KEY_FILE  = get_config(p, DEFAULTS, 'private_key_file', 'ANSIBLE_PRIVATE_KEY_FILE', None, value_type='path')",
            "DEFAULT_REMOTE_PORT       = get_config(p, DEFAULTS, 'remote_port',      'ANSIBLE_REMOTE_PORT',      None, value_type='integer')",
            "DEFAULT_ASK_VAULT_PASS    = get_config(p, DEFAULTS, 'ask_vault_pass',    'ANSIBLE_ASK_VAULT_PASS',    False, value_type='boolean')",
            "DEFAULT_VAULT_PASSWORD_FILE = get_config(p, DEFAULTS, 'vault_password_file', 'ANSIBLE_VAULT_PASSWORD_FILE', None, value_type='path')",
            "DEFAULT_TRANSPORT         = get_config(p, DEFAULTS, 'transport',        'ANSIBLE_TRANSPORT',        'smart')",
            "DEFAULT_SCP_IF_SSH        = get_config(p, 'ssh_connection', 'scp_if_ssh',       'ANSIBLE_SCP_IF_SSH',       'smart')",
            "DEFAULT_SFTP_BATCH_MODE   = get_config(p, 'ssh_connection', 'sftp_batch_mode', 'ANSIBLE_SFTP_BATCH_MODE', True, value_type='boolean')",
            "DEFAULT_SSH_TRANSFER_METHOD = get_config(p, 'ssh_connection', 'transfer_method', 'ANSIBLE_SSH_TRANSFER_METHOD', None)",
            "DEFAULT_MANAGED_STR       = get_config(p, DEFAULTS, 'ansible_managed',  None,           'Ansible managed')",
            "DEFAULT_SYSLOG_FACILITY   = get_config(p, DEFAULTS, 'syslog_facility',  'ANSIBLE_SYSLOG_FACILITY', 'LOG_USER')",
            "DEFAULT_KEEP_REMOTE_FILES = get_config(p, DEFAULTS, 'keep_remote_files', 'ANSIBLE_KEEP_REMOTE_FILES', False, value_type='boolean')",
            "DEFAULT_HASH_BEHAVIOUR    = get_config(p, DEFAULTS, 'hash_behaviour', 'ANSIBLE_HASH_BEHAVIOUR', 'replace')",
            "DEFAULT_PRIVATE_ROLE_VARS = get_config(p, DEFAULTS, 'private_role_vars', 'ANSIBLE_PRIVATE_ROLE_VARS', False, value_type='boolean')",
            "DEFAULT_JINJA2_EXTENSIONS = get_config(p, DEFAULTS, 'jinja2_extensions', 'ANSIBLE_JINJA2_EXTENSIONS', None)",
            "DEFAULT_EXECUTABLE        = get_config(p, DEFAULTS, 'executable', 'ANSIBLE_EXECUTABLE', '/bin/sh')",
            "DEFAULT_GATHERING         = get_config(p, DEFAULTS, 'gathering', 'ANSIBLE_GATHERING', 'implicit').lower()",
            "DEFAULT_GATHER_SUBSET     = get_config(p, DEFAULTS, 'gather_subset', 'ANSIBLE_GATHER_SUBSET', 'all').lower()",
            "DEFAULT_GATHER_TIMEOUT    = get_config(p, DEFAULTS, 'gather_timeout', 'ANSIBLE_GATHER_TIMEOUT', 10, value_type='integer')",
            "DEFAULT_LOG_PATH          = get_config(p, DEFAULTS, 'log_path',           'ANSIBLE_LOG_PATH', '', value_type='path')",
            "DEFAULT_FORCE_HANDLERS    = get_config(p, DEFAULTS, 'force_handlers', 'ANSIBLE_FORCE_HANDLERS', False, value_type='boolean')",
            "DEFAULT_INVENTORY_IGNORE  = get_config(p, DEFAULTS, 'inventory_ignore_extensions', 'ANSIBLE_INVENTORY_IGNORE', [\"~\", \".orig\", \".bak\", \".ini\", \".cfg\", \".retry\", \".pyc\", \".pyo\"], value_type='list')",
            "DEFAULT_VAR_COMPRESSION_LEVEL = get_config(p, DEFAULTS, 'var_compression_level', 'ANSIBLE_VAR_COMPRESSION_LEVEL', 0, value_type='integer')",
            "DEFAULT_INTERNAL_POLL_INTERVAL = get_config(p, DEFAULTS, 'internal_poll_interval', None, 0.001, value_type='float')",
            "DEFAULT_ALLOW_UNSAFE_LOOKUPS = get_config(p, DEFAULTS, 'allow_unsafe_lookups', None, False, value_type='boolean')",
            "ERROR_ON_MISSING_HANDLER  = get_config(p, DEFAULTS, 'error_on_missing_handler', 'ANSIBLE_ERROR_ON_MISSING_HANDLER', True, value_type='boolean')",
            "SHOW_CUSTOM_STATS = get_config(p, DEFAULTS, 'show_custom_stats', 'ANSIBLE_SHOW_CUSTOM_STATS', False, value_type='boolean')",
            "",
            "# static includes",
            "DEFAULT_TASK_INCLUDES_STATIC    = get_config(p, DEFAULTS, 'task_includes_static', 'ANSIBLE_TASK_INCLUDES_STATIC', False, value_type='boolean')",
            "DEFAULT_HANDLER_INCLUDES_STATIC = get_config(p, DEFAULTS, 'handler_includes_static', 'ANSIBLE_HANDLER_INCLUDES_STATIC', False, value_type='boolean')",
            "",
            "# disclosure",
            "DEFAULT_NO_LOG           = get_config(p, DEFAULTS, 'no_log', 'ANSIBLE_NO_LOG', False, value_type='boolean')",
            "DEFAULT_NO_TARGET_SYSLOG   = get_config(p, DEFAULTS, 'no_target_syslog', 'ANSIBLE_NO_TARGET_SYSLOG', False, value_type='boolean')",
            "ALLOW_WORLD_READABLE_TMPFILES = get_config(p, DEFAULTS, 'allow_world_readable_tmpfiles', None, False, value_type='boolean')",
            "",
            "# selinux",
            "DEFAULT_SELINUX_SPECIAL_FS = get_config(p, 'selinux', 'special_context_filesystems', None, 'fuse, nfs, vboxsf, ramfs, 9p', value_type='list')",
            "DEFAULT_LIBVIRT_LXC_NOSECLABEL = get_config(p, 'selinux', 'libvirt_lxc_noseclabel', 'LIBVIRT_LXC_NOSECLABEL', False, value_type='boolean')",
            "",
            "### PRIVILEGE ESCALATION ###",
            "# Backwards Compat",
            "DEFAULT_SU                = get_config(p, DEFAULTS, 'su', 'ANSIBLE_SU', False, value_type='boolean')",
            "DEFAULT_SU_USER           = get_config(p, DEFAULTS, 'su_user', 'ANSIBLE_SU_USER', 'root')",
            "DEFAULT_SU_EXE            = get_config(p, DEFAULTS, 'su_exe', 'ANSIBLE_SU_EXE', None)",
            "DEFAULT_SU_FLAGS          = get_config(p, DEFAULTS, 'su_flags', 'ANSIBLE_SU_FLAGS', None)",
            "DEFAULT_ASK_SU_PASS       = get_config(p, DEFAULTS, 'ask_su_pass', 'ANSIBLE_ASK_SU_PASS', False, value_type='boolean')",
            "DEFAULT_SUDO              = get_config(p, DEFAULTS, 'sudo', 'ANSIBLE_SUDO', False, value_type='boolean')",
            "DEFAULT_SUDO_USER         = get_config(p, DEFAULTS, 'sudo_user',        'ANSIBLE_SUDO_USER',        'root')",
            "DEFAULT_SUDO_EXE          = get_config(p, DEFAULTS, 'sudo_exe', 'ANSIBLE_SUDO_EXE', None)",
            "DEFAULT_SUDO_FLAGS        = get_config(p, DEFAULTS, 'sudo_flags', 'ANSIBLE_SUDO_FLAGS', '-H -S -n')",
            "DEFAULT_ASK_SUDO_PASS     = get_config(p, DEFAULTS, 'ask_sudo_pass',    'ANSIBLE_ASK_SUDO_PASS',    False, value_type='boolean')",
            "",
            "# Become",
            "BECOME_ERROR_STRINGS      = {'sudo': 'Sorry, try again.', 'su': 'Authentication failure', 'pbrun': '', 'pfexec': '', 'doas': 'Permission denied', 'dzdo': '', 'ksu': 'Password incorrect'} #FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS    = {'sudo': 'sorry, a password is required to run sudo', 'su': '', 'pbrun': '', 'pfexec': '', 'doas': 'Authorization required', 'dzdo': '', 'ksu': 'No password given'} #FIXME: deal with i18n",
            "BECOME_METHODS            = ['sudo','su','pbrun','pfexec','doas','dzdo','ksu','runas']",
            "BECOME_ALLOW_SAME_USER    = get_config(p, 'privilege_escalation', 'become_allow_same_user', 'ANSIBLE_BECOME_ALLOW_SAME_USER', False, value_type='boolean')",
            "DEFAULT_BECOME_METHOD     = get_config(p, 'privilege_escalation', 'become_method', 'ANSIBLE_BECOME_METHOD','sudo' if DEFAULT_SUDO else 'su' if DEFAULT_SU else 'sudo' ).lower()",
            "DEFAULT_BECOME            = get_config(p, 'privilege_escalation', 'become', 'ANSIBLE_BECOME',False, value_type='boolean')",
            "DEFAULT_BECOME_USER       = get_config(p, 'privilege_escalation', 'become_user', 'ANSIBLE_BECOME_USER', 'root')",
            "DEFAULT_BECOME_EXE        = get_config(p, 'privilege_escalation', 'become_exe', 'ANSIBLE_BECOME_EXE', None)",
            "DEFAULT_BECOME_FLAGS      = get_config(p, 'privilege_escalation', 'become_flags', 'ANSIBLE_BECOME_FLAGS', None)",
            "DEFAULT_BECOME_ASK_PASS   = get_config(p, 'privilege_escalation', 'become_ask_pass', 'ANSIBLE_BECOME_ASK_PASS', False, value_type='boolean')",
            "",
            "",
            "# PLUGINS",
            "",
            "# Modules that can optimize with_items loops into a single call.  Currently",
            "# these modules must (1) take a \"name\" or \"pkg\" parameter that is a list.  If",
            "# the module takes both, bad things could happen.",
            "# In the future we should probably generalize this even further",
            "# (mapping of param: squash field)",
            "DEFAULT_SQUASH_ACTIONS         = get_config(p, DEFAULTS, 'squash_actions',     'ANSIBLE_SQUASH_ACTIONS', \"apk, apt, dnf, homebrew, openbsd_pkg, pacman, pkgng, yum, zypper\", value_type='list')",
            "# paths",
            "",
            "DEFAULT_ACTION_PLUGIN_PATH     = get_config(p, DEFAULTS, 'action_plugins',     'ANSIBLE_ACTION_PLUGINS', '~/.ansible/plugins/action:/usr/share/ansible/plugins/action', value_type='pathlist')",
            "DEFAULT_CACHE_PLUGIN_PATH      = get_config(p, DEFAULTS, 'cache_plugins',      'ANSIBLE_CACHE_PLUGINS', '~/.ansible/plugins/cache:/usr/share/ansible/plugins/cache', value_type='pathlist')",
            "DEFAULT_CALLBACK_PLUGIN_PATH   = get_config(p, DEFAULTS, 'callback_plugins',   'ANSIBLE_CALLBACK_PLUGINS', '~/.ansible/plugins/callback:/usr/share/ansible/plugins/callback', value_type='pathlist')",
            "DEFAULT_CONNECTION_PLUGIN_PATH = get_config(p, DEFAULTS, 'connection_plugins', 'ANSIBLE_CONNECTION_PLUGINS', '~/.ansible/plugins/connection:/usr/share/ansible/plugins/connection', value_type='pathlist')",
            "DEFAULT_LOOKUP_PLUGIN_PATH     = get_config(p, DEFAULTS, 'lookup_plugins',     'ANSIBLE_LOOKUP_PLUGINS', '~/.ansible/plugins/lookup:/usr/share/ansible/plugins/lookup', value_type='pathlist')",
            "DEFAULT_MODULE_PATH            = get_config(p, DEFAULTS, 'library',            'ANSIBLE_LIBRARY',        None, value_type='pathlist')",
            "DEFAULT_MODULE_UTILS_PATH      = get_config(p, DEFAULTS, 'module_utils',       'ANSIBLE_MODULE_UTILS',   None, value_type='pathlist')",
            "DEFAULT_INVENTORY_PLUGIN_PATH  = get_config(p, DEFAULTS, 'inventory_plugins',  'ANSIBLE_INVENTORY_PLUGINS', '~/.ansible/plugins/inventory:/usr/share/ansible/plugins/inventory', value_type='pathlist')",
            "DEFAULT_VARS_PLUGIN_PATH       = get_config(p, DEFAULTS, 'vars_plugins',       'ANSIBLE_VARS_PLUGINS', '~/.ansible/plugins/vars:/usr/share/ansible/plugins/vars', value_type='pathlist')",
            "DEFAULT_FILTER_PLUGIN_PATH     = get_config(p, DEFAULTS, 'filter_plugins',     'ANSIBLE_FILTER_PLUGINS', '~/.ansible/plugins/filter:/usr/share/ansible/plugins/filter', value_type='pathlist')",
            "DEFAULT_TEST_PLUGIN_PATH       = get_config(p, DEFAULTS, 'test_plugins',       'ANSIBLE_TEST_PLUGINS', '~/.ansible/plugins/test:/usr/share/ansible/plugins/test', value_type='pathlist')",
            "DEFAULT_STRATEGY_PLUGIN_PATH   = get_config(p, DEFAULTS, 'strategy_plugins',   'ANSIBLE_STRATEGY_PLUGINS', '~/.ansible/plugins/strategy:/usr/share/ansible/plugins/strategy', value_type='pathlist')",
            "",
            "NETWORK_GROUP_MODULES          = get_config(p, DEFAULTS, 'network_group_modules','NETWORK_GROUP_MODULES', ['eos', 'nxos', 'ios', 'iosxr', 'junos',",
            "                                                                                                           'vyos', 'sros', 'dellos9', 'dellos10', 'dellos6'],",
            "                                            value_type='list')",
            "",
            "DEFAULT_STRATEGY               = get_config(p, DEFAULTS, 'strategy',           'ANSIBLE_STRATEGY', 'linear')",
            "DEFAULT_STDOUT_CALLBACK        = get_config(p, DEFAULTS, 'stdout_callback',    'ANSIBLE_STDOUT_CALLBACK', 'default')",
            "# cache",
            "CACHE_PLUGIN                   = get_config(p, DEFAULTS, 'fact_caching', 'ANSIBLE_CACHE_PLUGIN', 'memory')",
            "CACHE_PLUGIN_CONNECTION        = get_config(p, DEFAULTS, 'fact_caching_connection', 'ANSIBLE_CACHE_PLUGIN_CONNECTION', None)",
            "CACHE_PLUGIN_PREFIX            = get_config(p, DEFAULTS, 'fact_caching_prefix', 'ANSIBLE_CACHE_PLUGIN_PREFIX', 'ansible_facts')",
            "CACHE_PLUGIN_TIMEOUT           = get_config(p, DEFAULTS, 'fact_caching_timeout', 'ANSIBLE_CACHE_PLUGIN_TIMEOUT', 24 * 60 * 60, value_type='integer')",
            "",
            "# Display",
            "ANSIBLE_FORCE_COLOR            = get_config(p, DEFAULTS, 'force_color', 'ANSIBLE_FORCE_COLOR', None, value_type='boolean')",
            "ANSIBLE_NOCOLOR                = get_config(p, DEFAULTS, 'nocolor', 'ANSIBLE_NOCOLOR', None, value_type='boolean')",
            "ANSIBLE_NOCOWS                 = get_config(p, DEFAULTS, 'nocows', 'ANSIBLE_NOCOWS', None, value_type='boolean')",
            "ANSIBLE_COW_SELECTION          = get_config(p, DEFAULTS, 'cow_selection', 'ANSIBLE_COW_SELECTION', 'default')",
            "ANSIBLE_COW_WHITELIST          = get_config(p, DEFAULTS, 'cow_whitelist', 'ANSIBLE_COW_WHITELIST', DEFAULT_COW_WHITELIST, value_type='list')",
            "DISPLAY_SKIPPED_HOSTS          = get_config(p, DEFAULTS, 'display_skipped_hosts', 'DISPLAY_SKIPPED_HOSTS', True, value_type='boolean')",
            "DEFAULT_UNDEFINED_VAR_BEHAVIOR = get_config(p, DEFAULTS, 'error_on_undefined_vars', 'ANSIBLE_ERROR_ON_UNDEFINED_VARS', True, value_type='boolean')",
            "HOST_KEY_CHECKING              = get_config(p, DEFAULTS, 'host_key_checking',  'ANSIBLE_HOST_KEY_CHECKING',    True, value_type='boolean')",
            "SYSTEM_WARNINGS                = get_config(p, DEFAULTS, 'system_warnings', 'ANSIBLE_SYSTEM_WARNINGS', True, value_type='boolean')",
            "DEPRECATION_WARNINGS           = get_config(p, DEFAULTS, 'deprecation_warnings', 'ANSIBLE_DEPRECATION_WARNINGS', True, value_type='boolean')",
            "DEFAULT_CALLABLE_WHITELIST     = get_config(p, DEFAULTS, 'callable_whitelist', 'ANSIBLE_CALLABLE_WHITELIST', [], value_type='list')",
            "COMMAND_WARNINGS               = get_config(p, DEFAULTS, 'command_warnings', 'ANSIBLE_COMMAND_WARNINGS', True, value_type='boolean')",
            "DEFAULT_LOAD_CALLBACK_PLUGINS  = get_config(p, DEFAULTS, 'bin_ansible_callbacks', 'ANSIBLE_LOAD_CALLBACK_PLUGINS', False, value_type='boolean')",
            "DEFAULT_CALLBACK_WHITELIST     = get_config(p, DEFAULTS, 'callback_whitelist', 'ANSIBLE_CALLBACK_WHITELIST', [], value_type='list')",
            "RETRY_FILES_ENABLED            = get_config(p, DEFAULTS, 'retry_files_enabled', 'ANSIBLE_RETRY_FILES_ENABLED', True, value_type='boolean')",
            "RETRY_FILES_SAVE_PATH          = get_config(p, DEFAULTS, 'retry_files_save_path', 'ANSIBLE_RETRY_FILES_SAVE_PATH', None, value_type='path')",
            "DEFAULT_NULL_REPRESENTATION    = get_config(p, DEFAULTS, 'null_representation', 'ANSIBLE_NULL_REPRESENTATION', None, value_type='none')",
            "DISPLAY_ARGS_TO_STDOUT         = get_config(p, DEFAULTS, 'display_args_to_stdout', 'ANSIBLE_DISPLAY_ARGS_TO_STDOUT', False, value_type='boolean')",
            "MAX_FILE_SIZE_FOR_DIFF         = get_config(p, DEFAULTS, 'max_diff_size', 'ANSIBLE_MAX_DIFF_SIZE', 1024*1024, value_type='integer')",
            "",
            "# CONNECTION RELATED",
            "USE_PERSISTENT_CONNECTIONS     = get_config(p, DEFAULTS, 'use_persistent_connections', 'ANSIBLE_USE_PERSISTENT_CONNECTIONS', False, value_type='boolean')",
            "ANSIBLE_SSH_ARGS               = get_config(p, 'ssh_connection', 'ssh_args', 'ANSIBLE_SSH_ARGS', '-C -o ControlMaster=auto -o ControlPersist=60s')",
            "### WARNING: Someone might be tempted to switch this from percent-formatting",
            "# to .format() in the future.  be sure to read this:",
            "# http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/ and understand",
            "# that it may be a security risk to do so.",
            "ANSIBLE_SSH_CONTROL_PATH       = get_config(p, 'ssh_connection', 'control_path', 'ANSIBLE_SSH_CONTROL_PATH', None)",
            "ANSIBLE_SSH_CONTROL_PATH_DIR   = get_config(p, 'ssh_connection', 'control_path_dir', 'ANSIBLE_SSH_CONTROL_PATH_DIR', u'~/.ansible/cp')",
            "ANSIBLE_SSH_PIPELINING         = get_config(p, 'ssh_connection', 'pipelining', 'ANSIBLE_SSH_PIPELINING', False, value_type='boolean')",
            "ANSIBLE_SSH_RETRIES            = get_config(p, 'ssh_connection', 'retries', 'ANSIBLE_SSH_RETRIES', 0, value_type='integer')",
            "ANSIBLE_SSH_EXECUTABLE         = get_config(p, 'ssh_connection', 'ssh_executable', 'ANSIBLE_SSH_EXECUTABLE', 'ssh')",
            "PARAMIKO_RECORD_HOST_KEYS      = get_config(p, 'paramiko_connection', 'record_host_keys', 'ANSIBLE_PARAMIKO_RECORD_HOST_KEYS', True, value_type='boolean')",
            "PARAMIKO_HOST_KEY_AUTO_ADD     = get_config(p, 'paramiko_connection', 'host_key_auto_add', 'ANSIBLE_PARAMIKO_HOST_KEY_AUTO_ADD', False, value_type='boolean')",
            "PARAMIKO_PROXY_COMMAND         = get_config(p, 'paramiko_connection', 'proxy_command', 'ANSIBLE_PARAMIKO_PROXY_COMMAND', None)",
            "PARAMIKO_LOOK_FOR_KEYS         = get_config(p, 'paramiko_connection', 'look_for_keys', 'ANSIBLE_PARAMIKO_LOOK_FOR_KEYS', True, value_type='boolean')",
            "PERSISTENT_CONNECT_TIMEOUT     = get_config(p, 'persistent_connection', 'connect_timeout', 'ANSIBLE_PERSISTENT_CONNECT_TIMEOUT', 30, value_type='integer')",
            "PERSISTENT_CONNECT_RETRIES     = get_config(p, 'persistent_connection', 'connect_retries', 'ANSIBLE_PERSISTENT_CONNECT_RETRIES', 30, value_type='integer')",
            "PERSISTENT_CONNECT_INTERVAL    = get_config(p, 'persistent_connection', 'connect_interval', 'ANSIBLE_PERSISTENT_CONNECT_INTERVAL', 1, value_type='integer')",
            "",
            "# obsolete -- will be formally removed",
            "ACCELERATE_PORT                = get_config(p, 'accelerate', 'accelerate_port', 'ACCELERATE_PORT', 5099, value_type='integer')",
            "ACCELERATE_TIMEOUT             = get_config(p, 'accelerate', 'accelerate_timeout', 'ACCELERATE_TIMEOUT', 30, value_type='integer')",
            "ACCELERATE_CONNECT_TIMEOUT     = get_config(p, 'accelerate', 'accelerate_connect_timeout', 'ACCELERATE_CONNECT_TIMEOUT', 1.0, value_type='float')",
            "ACCELERATE_DAEMON_TIMEOUT      = get_config(p, 'accelerate', 'accelerate_daemon_timeout', 'ACCELERATE_DAEMON_TIMEOUT', 30, value_type='integer')",
            "ACCELERATE_KEYS_DIR            = get_config(p, 'accelerate', 'accelerate_keys_dir', 'ACCELERATE_KEYS_DIR', '~/.fireball.keys')",
            "ACCELERATE_KEYS_DIR_PERMS      = get_config(p, 'accelerate', 'accelerate_keys_dir_perms', 'ACCELERATE_KEYS_DIR_PERMS', '700')",
            "ACCELERATE_KEYS_FILE_PERMS     = get_config(p, 'accelerate', 'accelerate_keys_file_perms', 'ACCELERATE_KEYS_FILE_PERMS', '600')",
            "ACCELERATE_MULTI_KEY           = get_config(p, 'accelerate', 'accelerate_multi_key', 'ACCELERATE_MULTI_KEY', False, value_type='boolean')",
            "PARAMIKO_PTY                   = get_config(p, 'paramiko_connection', 'pty', 'ANSIBLE_PARAMIKO_PTY', True, value_type='boolean')",
            "",
            "# galaxy related",
            "GALAXY_SERVER                  = get_config(p, 'galaxy', 'server', 'ANSIBLE_GALAXY_SERVER', 'https://galaxy.ansible.com')",
            "GALAXY_IGNORE_CERTS            = get_config(p, 'galaxy', 'ignore_certs', 'ANSIBLE_GALAXY_IGNORE', False, value_type='boolean')",
            "# this can be configured to blacklist SCMS but cannot add new ones unless the code is also updated",
            "GALAXY_SCMS                    = get_config(p, 'galaxy', 'scms', 'ANSIBLE_GALAXY_SCMS', 'git, hg', value_type='list')",
            "GALAXY_ROLE_SKELETON = get_config(p, 'galaxy', 'role_skeleton', 'ANSIBLE_GALAXY_ROLE_SKELETON', None, value_type='path')",
            "GALAXY_ROLE_SKELETON_IGNORE = get_config(p, 'galaxy', 'role_skeleton_ignore', 'ANSIBLE_GALAXY_ROLE_SKELETON_IGNORE', ['^.git$', '^.*/.git_keep$'], value_type='list')",
            "",
            "STRING_TYPE_FILTERS = get_config(p, 'jinja2', 'dont_type_filters', 'ANSIBLE_STRING_TYPE_FILTERS', ['string', 'to_json', 'to_nice_json', 'to_yaml', 'ppretty', 'json'], value_type='list' )",
            "",
            "# colors",
            "COLOR_HIGHLIGHT   = get_config(p, 'colors', 'highlight', 'ANSIBLE_COLOR_HIGHLIGHT', 'white')",
            "COLOR_VERBOSE     = get_config(p, 'colors', 'verbose', 'ANSIBLE_COLOR_VERBOSE', 'blue')",
            "COLOR_WARN        = get_config(p, 'colors', 'warn', 'ANSIBLE_COLOR_WARN', 'bright purple')",
            "COLOR_ERROR       = get_config(p, 'colors', 'error', 'ANSIBLE_COLOR_ERROR', 'red')",
            "COLOR_DEBUG       = get_config(p, 'colors', 'debug', 'ANSIBLE_COLOR_DEBUG', 'dark gray')",
            "COLOR_DEPRECATE   = get_config(p, 'colors', 'deprecate', 'ANSIBLE_COLOR_DEPRECATE', 'purple')",
            "COLOR_SKIP        = get_config(p, 'colors', 'skip', 'ANSIBLE_COLOR_SKIP', 'cyan')",
            "COLOR_UNREACHABLE = get_config(p, 'colors', 'unreachable', 'ANSIBLE_COLOR_UNREACHABLE', 'bright red')",
            "COLOR_OK          = get_config(p, 'colors', 'ok', 'ANSIBLE_COLOR_OK', 'green')",
            "COLOR_CHANGED     = get_config(p, 'colors', 'changed', 'ANSIBLE_COLOR_CHANGED', 'yellow')",
            "COLOR_DIFF_ADD    = get_config(p, 'colors', 'diff_add', 'ANSIBLE_COLOR_DIFF_ADD', 'green')",
            "COLOR_DIFF_REMOVE = get_config(p, 'colors', 'diff_remove', 'ANSIBLE_COLOR_DIFF_REMOVE', 'red')",
            "COLOR_DIFF_LINES  = get_config(p, 'colors', 'diff_lines', 'ANSIBLE_COLOR_DIFF_LINES', 'cyan')",
            "",
            "# diff",
            "DIFF_CONTEXT = get_config(p, 'diff', 'context', 'ANSIBLE_DIFF_CONTEXT', 3, value_type='integer')",
            "DIFF_ALWAYS = get_config(p, 'diff', 'always', 'ANSIBLE_DIFF_ALWAYS', False, value_type='bool')",
            "",
            "# non-configurable things",
            "MODULE_REQUIRE_ARGS       = ['command', 'win_command', 'shell', 'win_shell', 'raw', 'script']",
            "MODULE_NO_JSON            = ['command', 'win_command', 'shell', 'win_shell', 'raw']",
            "DEFAULT_BECOME_PASS       = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS         = None",
            "DEFAULT_REMOTE_PASS       = None",
            "DEFAULT_SUBSET            = None",
            "DEFAULT_SU_PASS           = None",
            "VAULT_VERSION_MIN         = 1.0",
            "VAULT_VERSION_MAX         = 1.0",
            "TREE_DIR                  = None",
            "LOCALHOST                 = frozenset(['127.0.0.1', 'localhost', '::1'])",
            "# module search",
            "BLACKLIST_EXTS = ('.pyc', '.swp', '.bak', '~', '.rpm', '.md', '.txt')",
            "IGNORE_FILES = [\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\"]",
            "INTERNAL_RESULT_KEYS      = ['add_host', 'add_group']",
            "RESTRICTED_RESULT_KEYS    = ['ansible_rsync_path', 'ansible_playbook_python']"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "lib/ansible/template/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "             loader=FileSystemLoader(self._basedir),"
            },
            "1": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         )"
            },
            "2": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        # the current rendering context under which the templar class is working"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        self.cur_context = None"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))"
            },
            "7": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "         self.block_start    = self.environment.block_start_string"
            },
            "9": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 567,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 568,
                "PatchRowcode": "         if instance is not None:"
            },
            "11": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 569,
                "PatchRowcode": "             wantlist = kwargs.pop('wantlist', False)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+            allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)"
            },
            "13": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": 571,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": 572,
                "PatchRowcode": "             from ansible.utils.listify import listify_lookup_plugin_terms"
            },
            "15": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": 573,
                "PatchRowcode": "             loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)"
            },
            "16": {
                "beforePatchRowNumber": 577,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "                     raise AnsibleError(\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % (name, type(e), e))"
            },
            "17": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "                 ran = None"
            },
            "18": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": 583,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if ran:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 584,
                "PatchRowcode": "+            if ran and not allow_unsafe:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 585,
                "PatchRowcode": "+                from ansible.vars.unsafe_proxy import UnsafeProxy, wrap_var"
            },
            "22": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "                 if wantlist:"
            },
            "23": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 587,
                "PatchRowcode": "                     ran = wrap_var(ran)"
            },
            "24": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 588,
                "PatchRowcode": "                 else:"
            },
            "25": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "                         else:"
            },
            "26": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": 595,
                "PatchRowcode": "                             ran = wrap_var(ran)"
            },
            "27": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 596,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+                if self.cur_context:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+                    self.cur_context.unsafe = True"
            },
            "30": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 599,
                "PatchRowcode": "             return ran"
            },
            "31": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 600,
                "PatchRowcode": "         else:"
            },
            "32": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 601,
                "PatchRowcode": "             raise AnsibleError(\"lookup plugin (%s) not found\" % name)"
            },
            "33": {
                "beforePatchRowNumber": 645,
                "afterPatchRowNumber": 652,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 653,
                "PatchRowcode": "             jvars = AnsibleJ2Vars(self, t.globals)"
            },
            "35": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 654,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            new_context = t.new_context(jvars, shared=True)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+            self.cur_context = new_context = t.new_context(jvars, shared=True)"
            },
            "38": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 656,
                "PatchRowcode": "             rf = t.root_render_func(new_context)"
            },
            "39": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 657,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 658,
                "PatchRowcode": "             try:"
            }
        },
        "frontPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import ast",
            "import contextlib",
            "import datetime",
            "import os",
            "import pwd",
            "import re",
            "import time",
            "",
            "from io import StringIO",
            "from numbers import Number",
            "",
            "from jinja2 import Environment",
            "from jinja2.loaders import FileSystemLoader",
            "from jinja2.exceptions import TemplateSyntaxError, UndefinedError",
            "from jinja2.utils import concat as j2_concat",
            "from jinja2.runtime import Context, StrictUndefined",
            "",
            "from ansible import constants as C",
            "from ansible.compat.six import string_types, text_type",
            "from ansible.errors import AnsibleError, AnsibleFilterError, AnsibleUndefinedVariable",
            "from ansible.module_utils._text import to_native, to_text, to_bytes",
            "from ansible.plugins import filter_loader, lookup_loader, test_loader",
            "from ansible.template.safe_eval import safe_eval",
            "from ansible.template.template import AnsibleJ2Template",
            "from ansible.template.vars import AnsibleJ2Vars",
            "from ansible.vars.unsafe_proxy import UnsafeProxy, wrap_var",
            "",
            "try:",
            "    from hashlib import sha1",
            "except ImportError:",
            "    from sha import sha as sha1",
            "",
            "try:",
            "    from __main__ import display",
            "except ImportError:",
            "    from ansible.utils.display import Display",
            "    display = Display()",
            "",
            "__all__ = ['Templar', 'generate_ansible_template_vars']",
            "",
            "# A regex for checking to see if a variable we're trying to",
            "# expand is just a single variable name.",
            "",
            "# Primitive Types which we don't want Jinja to convert to strings.",
            "NON_TEMPLATED_TYPES = ( bool, Number )",
            "",
            "JINJA2_OVERRIDE = '#jinja2:'",
            "",
            "",
            "def generate_ansible_template_vars(path):",
            "",
            "    b_path = to_bytes(path)",
            "    try:",
            "        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name",
            "    except:",
            "        template_uid = os.stat(b_path).st_uid",
            "",
            "    temp_vars = {}",
            "    temp_vars['template_host']     = os.uname()[1]",
            "    temp_vars['template_path']     = b_path",
            "    temp_vars['template_mtime']    = datetime.datetime.fromtimestamp(os.path.getmtime(b_path))",
            "    temp_vars['template_uid']      = template_uid",
            "    temp_vars['template_fullpath'] = os.path.abspath(path)",
            "    temp_vars['template_run_date'] = datetime.datetime.now()",
            "",
            "    managed_default = C.DEFAULT_MANAGED_STR",
            "    managed_str = managed_default.format(",
            "        host = temp_vars['template_host'],",
            "        uid  = temp_vars['template_uid'],",
            "        file = temp_vars['template_path'],",
            "    )",
            "    temp_vars['ansible_managed'] = time.strftime( managed_str, time.localtime(os.path.getmtime(b_path)))",
            "",
            "    return temp_vars",
            "",
            "",
            "def _escape_backslashes(data, jinja_env):",
            "    \"\"\"Double backslashes within jinja2 expressions",
            "",
            "    A user may enter something like this in a playbook::",
            "",
            "      debug:",
            "        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"",
            "",
            "    The string inside of the {{ gets interpreted multiple times First by yaml.",
            "    Then by python.  And finally by jinja2 as part of it's variable.  Because",
            "    it is processed by both python and jinja2, the backslash escaped",
            "    characters get unescaped twice.  This means that we'd normally have to use",
            "    four backslashes to escape that.  This is painful for playbook authors as",
            "    they have to remember different rules for inside vs outside of a jinja2",
            "    expression (The backslashes outside of the \"{{ }}\" only get processed by",
            "    yaml and python.  So they only need to be escaped once).  The following",
            "    code fixes this by automatically performing the extra quoting of",
            "    backslashes inside of a jinja2 expression.",
            "",
            "    \"\"\"",
            "    if '\\\\' in data and '{{' in data:",
            "        new_data = []",
            "        d2 = jinja_env.preprocess(data)",
            "        in_var = False",
            "",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] == 'variable_begin':",
            "                in_var = True",
            "                new_data.append(token[2])",
            "            elif token[1] == 'variable_end':",
            "                in_var = False",
            "                new_data.append(token[2])",
            "            elif in_var and token[1] == 'string':",
            "                # Double backslashes only if we're inside of a jinja2 variable",
            "                new_data.append(token[2].replace('\\\\','\\\\\\\\'))",
            "            else:",
            "                new_data.append(token[2])",
            "",
            "        data = ''.join(new_data)",
            "",
            "    return data",
            "",
            "",
            "def _count_newlines_from_end(in_str):",
            "    '''",
            "    Counts the number of newlines at the end of a string. This is used during",
            "    the jinja2 templating to ensure the count matches the input, since some newlines",
            "    may be thrown away during the templating.",
            "    '''",
            "",
            "    try:",
            "        i = len(in_str)",
            "        j = i -1",
            "        while in_str[j] == '\\n':",
            "            j -= 1",
            "        return i - 1 - j",
            "    except IndexError:",
            "        # Uncommon cases: zero length string and string containing only newlines",
            "        return i",
            "",
            "class AnsibleContext(Context):",
            "    '''",
            "    A custom context, which intercepts resolve() calls and sets a flag",
            "    internally if any variable lookup returns an AnsibleUnsafe value. This",
            "    flag is checked post-templating, and (when set) will result in the",
            "    final templated result being wrapped via UnsafeProxy.",
            "    '''",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleContext, self).__init__(*args, **kwargs)",
            "        self.unsafe = False",
            "",
            "    def _is_unsafe(self, val):",
            "        '''",
            "        Our helper function, which will also recursively check dict and",
            "        list entries due to the fact that they may be repr'd and contain",
            "        a key or value which contains jinja2 syntax and would otherwise",
            "        lose the AnsibleUnsafe value.",
            "        '''",
            "        if isinstance(val, dict):",
            "            for key in val.keys():",
            "                if self._is_unsafe(val[key]):",
            "                    return True",
            "        elif isinstance(val, list):",
            "            for item in val:",
            "                if self._is_unsafe(item):",
            "                    return True",
            "        elif isinstance(val, string_types) and hasattr(val, '__UNSAFE__'):",
            "            return True",
            "        return False",
            "",
            "    def _update_unsafe(self, val):",
            "        if val is not None and not self.unsafe and self._is_unsafe(val):",
            "            self.unsafe = True",
            "",
            "    def resolve(self, key):",
            "        '''",
            "        The intercepted resolve(), which uses the helper above to set the",
            "        internal flag whenever an unsafe variable value is returned.",
            "        '''",
            "        val = super(AnsibleContext, self).resolve(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "    def resolve_or_missing(self, key):",
            "        val = super(AnsibleContext, self).resolve_or_missing(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "class AnsibleEnvironment(Environment):",
            "    '''",
            "    Our custom environment, which simply allows us to override the class-level",
            "    values for the Template and Context classes used by jinja2 internally.",
            "    '''",
            "    context_class = AnsibleContext",
            "    template_class = AnsibleJ2Template",
            "",
            "class Templar:",
            "    '''",
            "    The main class for templating, with the main entry-point of template().",
            "    '''",
            "",
            "    def __init__(self, loader, shared_loader_obj=None, variables=dict()):",
            "        self._loader              = loader",
            "        self._filters             = None",
            "        self._tests               = None",
            "        self._available_variables = variables",
            "        self._cached_result       = {}",
            "",
            "        if loader:",
            "            self._basedir = loader.get_basedir()",
            "        else:",
            "            self._basedir = './'",
            "",
            "        if shared_loader_obj:",
            "            self._filter_loader = getattr(shared_loader_obj, 'filter_loader')",
            "            self._test_loader   = getattr(shared_loader_obj, 'test_loader')",
            "            self._lookup_loader = getattr(shared_loader_obj, 'lookup_loader')",
            "        else:",
            "            self._filter_loader = filter_loader",
            "            self._test_loader   = test_loader",
            "            self._lookup_loader = lookup_loader",
            "",
            "        # flags to determine whether certain failures during templating",
            "        # should result in fatal errors being raised",
            "        self._fail_on_lookup_errors    = True",
            "        self._fail_on_filter_errors    = True",
            "        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR",
            "",
            "        self.environment = AnsibleEnvironment(",
            "            trim_blocks=True,",
            "            undefined=StrictUndefined,",
            "            extensions=self._get_extensions(),",
            "            finalize=self._finalize,",
            "            loader=FileSystemLoader(self._basedir),",
            "        )",
            "",
            "        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))",
            "",
            "        self.block_start    = self.environment.block_start_string",
            "        self.block_end      = self.environment.block_end_string",
            "        self.variable_start = self.environment.variable_start_string",
            "        self.variable_end   = self.environment.variable_end_string",
            "        self._clean_regex   = re.compile(r'(?:%s|%s|%s|%s)' % (self.variable_start, self.block_start, self.block_end, self.variable_end))",
            "        self._no_type_regex = re.compile(r'.*\\|\\s*(?:%s)\\s*(?:%s)?$' % ('|'.join(C.STRING_TYPE_FILTERS), self.variable_end))",
            "",
            "    def _get_filters(self):",
            "        '''",
            "        Returns filter plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._filters is not None:",
            "            return self._filters.copy()",
            "",
            "        plugins = [x for x in self._filter_loader.all()]",
            "",
            "        self._filters = dict()",
            "        for fp in plugins:",
            "            self._filters.update(fp.filters())",
            "        self._filters.update(self._get_tests())",
            "",
            "        return self._filters.copy()",
            "",
            "    def _get_tests(self):",
            "        '''",
            "        Returns tests plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._tests is not None:",
            "            return self._tests.copy()",
            "",
            "        plugins = [x for x in self._test_loader.all()]",
            "",
            "        self._tests = dict()",
            "        for fp in plugins:",
            "            self._tests.update(fp.tests())",
            "",
            "        return self._tests.copy()",
            "",
            "    def _get_extensions(self):",
            "        '''",
            "        Return jinja2 extensions to load.",
            "",
            "        If some extensions are set via jinja_extensions in ansible.cfg, we try",
            "        to load them with the jinja environment.",
            "        '''",
            "",
            "        jinja_exts = []",
            "        if C.DEFAULT_JINJA2_EXTENSIONS:",
            "            # make sure the configuration directive doesn't contain spaces",
            "            # and split extensions in an array",
            "            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')",
            "",
            "        return jinja_exts",
            "",
            "    def _clean_data(self, orig_data):",
            "        ''' remove jinja2 template tags from data '''",
            "",
            "        if hasattr(orig_data, '__ENCRYPTED__'):",
            "            ret = orig_data",
            "",
            "        elif isinstance(orig_data, list):",
            "            clean_list = []",
            "            for list_item in orig_data:",
            "                clean_list.append(self._clean_data(list_item))",
            "            ret = clean_list",
            "",
            "        elif isinstance(orig_data, dict):",
            "            clean_dict = {}",
            "            for k in orig_data:",
            "                clean_dict[self._clean_data(k)] =  self._clean_data(orig_data[k])",
            "            ret = clean_dict",
            "",
            "        elif isinstance(orig_data, string_types):",
            "            # This will error with str data (needs unicode), but all strings should already be converted already.",
            "            # If you get exception, the problem is at the data origin, do not add to_text here.",
            "            with contextlib.closing(StringIO(orig_data)) as data:",
            "                # these variables keep track of opening block locations, as we only",
            "                # want to replace matched pairs of print/block tags",
            "                print_openings = []",
            "                block_openings = []",
            "                for mo in self._clean_regex.finditer(orig_data):",
            "                    token = mo.group(0)",
            "                    token_start = mo.start(0)",
            "",
            "                    if token[0] == self.environment.variable_start_string[0]:",
            "                        if token == self.environment.block_start_string:",
            "                            block_openings.append(token_start)",
            "                        elif token == self.environment.variable_start_string:",
            "                            print_openings.append(token_start)",
            "",
            "                    elif token[1] == self.environment.variable_end_string[1]:",
            "                        prev_idx = None",
            "                        if token == self.environment.block_end_string and block_openings:",
            "                            prev_idx = block_openings.pop()",
            "                        elif token == self.environment.variable_end_string and print_openings:",
            "                            prev_idx = print_openings.pop()",
            "",
            "                        if prev_idx is not None:",
            "                            # replace the opening",
            "                            data.seek(prev_idx, os.SEEK_SET)",
            "                            data.write(to_text(self.environment.comment_start_string))",
            "                            # replace the closing",
            "                            data.seek(token_start, os.SEEK_SET)",
            "                            data.write(to_text(self.environment.comment_end_string))",
            "",
            "                    else:",
            "                        raise AnsibleError(\"Error while cleaning data for safety: unhandled regex match\")",
            "",
            "                ret = data.getvalue()",
            "        else:",
            "            ret = orig_data",
            "",
            "        return ret",
            "",
            "    def set_available_variables(self, variables):",
            "        '''",
            "        Sets the list of template variables this Templar instance will use",
            "        to template things, so we don't have to pass them around between",
            "        internal methods. We also clear the template cache here, as the variables",
            "        are being changed.",
            "        '''",
            "",
            "        assert isinstance(variables, dict)",
            "        self._available_variables = variables",
            "        self._cached_result       = {}",
            "",
            "    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, convert_data=True, static_vars=[''], cache=True, bare_deprecated=True, disable_lookups=False):",
            "        '''",
            "        Templates (possibly recursively) any given data as input. If convert_bare is",
            "        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')",
            "        before being sent through the template engine.",
            "        '''",
            "",
            "        # Don't template unsafe variables, just return them.",
            "        if hasattr(variable, '__UNSAFE__'):",
            "            return variable",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            if convert_bare:",
            "                variable = self._convert_bare_variable(variable, bare_deprecated=bare_deprecated)",
            "",
            "            if isinstance(variable, string_types):",
            "                result = variable",
            "",
            "                if self._contains_vars(variable):",
            "                    # Check to see if the string we are trying to render is just referencing a single",
            "                    # var.  In this case we don't want to accidentally change the type of the variable",
            "                    # to a string by using the jinja template renderer. We just want to pass it.",
            "                    only_one = self.SINGLE_VAR.match(variable)",
            "                    if only_one:",
            "                        var_name = only_one.group(1)",
            "                        if var_name in self._available_variables:",
            "                            resolved_val = self._available_variables[var_name]",
            "                            if isinstance(resolved_val, NON_TEMPLATED_TYPES):",
            "                                return resolved_val",
            "                            elif resolved_val is None:",
            "                                return C.DEFAULT_NULL_REPRESENTATION",
            "",
            "                    # Using a cache in order to prevent template calls with already templated variables",
            "                    sha1_hash = None",
            "                    if cache:",
            "                        variable_hash = sha1(text_type(variable).encode('utf-8'))",
            "                        options_hash  = sha1((text_type(preserve_trailing_newlines) + text_type(escape_backslashes) + text_type(fail_on_undefined) + text_type(overrides)).encode('utf-8'))",
            "                        sha1_hash = variable_hash.hexdigest() + options_hash.hexdigest()",
            "                    if cache and sha1_hash in self._cached_result:",
            "                        result = self._cached_result[sha1_hash]",
            "                    else:",
            "                        result = self.do_template(",
            "                            variable,",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            escape_backslashes=escape_backslashes,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                        )",
            "",
            "                        unsafe = hasattr(result, '__UNSAFE__')",
            "                        if convert_data and not self._no_type_regex.match(variable):",
            "                            # if this looks like a dictionary or list, convert it to such using the safe_eval method",
            "                            if (result.startswith(\"{\") and not result.startswith(self.environment.variable_start_string)) or \\",
            "                                    result.startswith(\"[\") or result in (\"True\", \"False\"):",
            "                                eval_results = safe_eval(result, locals=self._available_variables, include_exceptions=True)",
            "                                if eval_results[1] is None:",
            "                                    result = eval_results[0]",
            "                                    if unsafe:",
            "                                        result = wrap_var(result)",
            "                                else:",
            "                                    # FIXME: if the safe_eval raised an error, should we do something with it?",
            "                                    pass",
            "",
            "                        # we only cache in the case where we have a single variable",
            "                        # name, to make sure we're not putting things which may otherwise",
            "                        # be dynamic in the cache (filters, lookups, etc.)",
            "                        if cache:",
            "                            self._cached_result[sha1_hash] = result",
            "",
            "                return result",
            "",
            "            elif isinstance(variable, (list, tuple)):",
            "                return [self.template(",
            "                    v,",
            "                    preserve_trailing_newlines=preserve_trailing_newlines,",
            "                    fail_on_undefined=fail_on_undefined,",
            "                    overrides=overrides,",
            "                    disable_lookups=disable_lookups,",
            "                    ) for v in variable]",
            "            elif isinstance(variable, dict):",
            "                d = {}",
            "                # we don't use iteritems() here to avoid problems if the underlying dict",
            "                # changes sizes due to the templating, which can happen with hostvars",
            "                for k in variable.keys():",
            "                    if k not in static_vars:",
            "                        d[k] = self.template(",
            "                            variable[k],",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                            )",
            "                    else:",
            "                        d[k] = variable[k]",
            "                return d",
            "            else:",
            "                return variable",
            "",
            "        except AnsibleFilterError:",
            "            if self._fail_on_filter_errors:",
            "                raise",
            "            else:",
            "                return variable",
            "",
            "    def is_template(self, data):",
            "        ''' lets us know if data has a template'''",
            "        if isinstance(data, string_types):",
            "            try:",
            "                new = self.do_template(data, fail_on_undefined=True)",
            "            except (AnsibleUndefinedVariable, UndefinedError):",
            "                return True",
            "            except:",
            "                return False",
            "            return (new != data)",
            "        elif isinstance(data, (list, tuple)):",
            "            for v in data:",
            "                if self.is_template(v):",
            "                    return True",
            "        elif isinstance(data, dict):",
            "            for k in data:",
            "                if self.is_template(k) or self.is_template(data[k]):",
            "                    return True",
            "        return False",
            "",
            "    def templatable(self, data):",
            "        '''",
            "        returns True if the data can be templated w/o errors",
            "        '''",
            "        templatable = True",
            "        try:",
            "            self.template(data)",
            "        except:",
            "            templatable = False",
            "        return templatable",
            "",
            "    def _contains_vars(self, data):",
            "        '''",
            "        returns True if the data contains a variable pattern",
            "        '''",
            "        if isinstance(data, string_types):",
            "            for marker in (self.environment.block_start_string, self.environment.variable_start_string, self.environment.comment_start_string):",
            "                if marker in data:",
            "                    return True",
            "        return False",
            "",
            "    def _convert_bare_variable(self, variable, bare_deprecated):",
            "        '''",
            "        Wraps a bare string, which may have an attribute portion (ie. foo.bar)",
            "        in jinja2 variable braces so that it is evaluated properly.",
            "        '''",
            "",
            "        if isinstance(variable, string_types):",
            "            contains_filters = \"|\" in variable",
            "            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]",
            "            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:",
            "                if bare_deprecated:",
            "                    display.deprecated(\"Using bare variables is deprecated.\"",
            "                            \" Update your playbooks so that the environment value uses the full variable syntax ('%s%s%s')\" %",
            "                            (self.environment.variable_start_string, variable, self.environment.variable_end_string))",
            "                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)",
            "",
            "        # the variable didn't meet the conditions to be converted,",
            "        # so just return it as-is",
            "        return variable",
            "",
            "    def _finalize(self, thing):",
            "        '''",
            "        A custom finalize method for jinja2, which prevents None from being returned",
            "        '''",
            "        return thing if thing is not None else ''",
            "",
            "    def _fail_lookup(self, name, *args, **kwargs):",
            "        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)",
            "",
            "    def _lookup(self, name, *args, **kwargs):",
            "        instance = self._lookup_loader.get(name.lower(), loader=self._loader, templar=self)",
            "",
            "        if instance is not None:",
            "            wantlist = kwargs.pop('wantlist', False)",
            "",
            "            from ansible.utils.listify import listify_lookup_plugin_terms",
            "            loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)",
            "            # safely catch run failures per #5059",
            "            try:",
            "                ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)",
            "            except (AnsibleUndefinedVariable, UndefinedError) as e:",
            "                raise AnsibleUndefinedVariable(e)",
            "            except Exception as e:",
            "                if self._fail_on_lookup_errors:",
            "                    raise AnsibleError(\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % (name, type(e), e))",
            "                ran = None",
            "",
            "            if ran:",
            "                if wantlist:",
            "                    ran = wrap_var(ran)",
            "                else:",
            "                    try:",
            "                        ran = UnsafeProxy(\",\".join(ran))",
            "                    except TypeError:",
            "                        if isinstance(ran, list) and len(ran) == 1:",
            "                            ran = wrap_var(ran[0])",
            "                        else:",
            "                            ran = wrap_var(ran)",
            "",
            "            return ran",
            "        else:",
            "            raise AnsibleError(\"lookup plugin (%s) not found\" % name)",
            "",
            "    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False):",
            "        # For preserving the number of input newlines in the output (used",
            "        # later in this method)",
            "        data_newlines = _count_newlines_from_end(data)",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            # allows template header overrides to change jinja2 options.",
            "            if overrides is None:",
            "                myenv = self.environment.overlay()",
            "            else:",
            "                myenv = self.environment.overlay(overrides)",
            "",
            "            # Get jinja env overrides from template",
            "            if data.startswith(JINJA2_OVERRIDE):",
            "                eol = data.find('\\n')",
            "                line = data[len(JINJA2_OVERRIDE):eol]",
            "                data = data[eol+1:]",
            "                for pair in line.split(','):",
            "                    (key,val) = pair.split(':')",
            "                    key = key.strip()",
            "                    setattr(myenv, key, ast.literal_eval(val.strip()))",
            "",
            "            # Adds Ansible custom filters and tests",
            "            myenv.filters.update(self._get_filters())",
            "            myenv.tests.update(self._get_tests())",
            "",
            "            if escape_backslashes:",
            "                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".",
            "                data = _escape_backslashes(data, myenv)",
            "",
            "            try:",
            "                t = myenv.from_string(data)",
            "            except TemplateSyntaxError as e:",
            "                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)))",
            "            except Exception as e:",
            "                if 'recursion' in to_native(e):",
            "                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data))",
            "                else:",
            "                    return data",
            "",
            "            if disable_lookups:",
            "                t.globals['lookup'] = self._fail_lookup",
            "            else:",
            "                t.globals['lookup'] = self._lookup",
            "",
            "            t.globals['finalize'] = self._finalize",
            "",
            "            jvars = AnsibleJ2Vars(self, t.globals)",
            "",
            "            new_context = t.new_context(jvars, shared=True)",
            "            rf = t.root_render_func(new_context)",
            "",
            "            try:",
            "                res = j2_concat(rf)",
            "                if new_context.unsafe:",
            "                    res = wrap_var(res)",
            "            except TypeError as te:",
            "                if 'StrictUndefined' in to_native(te):",
            "                    errmsg  = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)",
            "                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)",
            "                    raise AnsibleUndefinedVariable(errmsg)",
            "                else:",
            "                    display.debug(\"failing because of a type error, template data is: %s\" % to_native(data))",
            "                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data),to_native(te)))",
            "",
            "            if preserve_trailing_newlines:",
            "                # The low level calls above do not preserve the newline",
            "                # characters at the end of the input data, so we use the",
            "                # calculate the difference in newlines and append them",
            "                # to the resulting output for parity",
            "                #",
            "                # jinja2 added a keep_trailing_newline option in 2.7 when",
            "                # creating an Environment.  That would let us make this code",
            "                # better (remove a single newline if",
            "                # preserve_trailing_newlines is False).  Once we can depend on",
            "                # that version being present, modify our code to set that when",
            "                # initializing self.environment and remove a single trailing",
            "                # newline here if preserve_newlines is False.",
            "                res_newlines = _count_newlines_from_end(res)",
            "                if data_newlines > res_newlines:",
            "                    res += '\\n' * (data_newlines - res_newlines)",
            "            return res",
            "        except (UndefinedError, AnsibleUndefinedVariable) as e:",
            "            if fail_on_undefined:",
            "                raise AnsibleUndefinedVariable(e)",
            "            else:",
            "                #TODO: return warning about undefined var",
            "                return data",
            "",
            "    # for backwards compatibility in case anyone is using old private method directly",
            "    _do_template = do_template"
        ],
        "afterPatchFile": [
            "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "#",
            "# This file is part of Ansible",
            "#",
            "# Ansible is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# Ansible is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import ast",
            "import contextlib",
            "import datetime",
            "import os",
            "import pwd",
            "import re",
            "import time",
            "",
            "from io import StringIO",
            "from numbers import Number",
            "",
            "from jinja2 import Environment",
            "from jinja2.loaders import FileSystemLoader",
            "from jinja2.exceptions import TemplateSyntaxError, UndefinedError",
            "from jinja2.utils import concat as j2_concat",
            "from jinja2.runtime import Context, StrictUndefined",
            "",
            "from ansible import constants as C",
            "from ansible.compat.six import string_types, text_type",
            "from ansible.errors import AnsibleError, AnsibleFilterError, AnsibleUndefinedVariable",
            "from ansible.module_utils._text import to_native, to_text, to_bytes",
            "from ansible.plugins import filter_loader, lookup_loader, test_loader",
            "from ansible.template.safe_eval import safe_eval",
            "from ansible.template.template import AnsibleJ2Template",
            "from ansible.template.vars import AnsibleJ2Vars",
            "from ansible.vars.unsafe_proxy import UnsafeProxy, wrap_var",
            "",
            "try:",
            "    from hashlib import sha1",
            "except ImportError:",
            "    from sha import sha as sha1",
            "",
            "try:",
            "    from __main__ import display",
            "except ImportError:",
            "    from ansible.utils.display import Display",
            "    display = Display()",
            "",
            "__all__ = ['Templar', 'generate_ansible_template_vars']",
            "",
            "# A regex for checking to see if a variable we're trying to",
            "# expand is just a single variable name.",
            "",
            "# Primitive Types which we don't want Jinja to convert to strings.",
            "NON_TEMPLATED_TYPES = ( bool, Number )",
            "",
            "JINJA2_OVERRIDE = '#jinja2:'",
            "",
            "",
            "def generate_ansible_template_vars(path):",
            "",
            "    b_path = to_bytes(path)",
            "    try:",
            "        template_uid = pwd.getpwuid(os.stat(b_path).st_uid).pw_name",
            "    except:",
            "        template_uid = os.stat(b_path).st_uid",
            "",
            "    temp_vars = {}",
            "    temp_vars['template_host']     = os.uname()[1]",
            "    temp_vars['template_path']     = b_path",
            "    temp_vars['template_mtime']    = datetime.datetime.fromtimestamp(os.path.getmtime(b_path))",
            "    temp_vars['template_uid']      = template_uid",
            "    temp_vars['template_fullpath'] = os.path.abspath(path)",
            "    temp_vars['template_run_date'] = datetime.datetime.now()",
            "",
            "    managed_default = C.DEFAULT_MANAGED_STR",
            "    managed_str = managed_default.format(",
            "        host = temp_vars['template_host'],",
            "        uid  = temp_vars['template_uid'],",
            "        file = temp_vars['template_path'],",
            "    )",
            "    temp_vars['ansible_managed'] = time.strftime( managed_str, time.localtime(os.path.getmtime(b_path)))",
            "",
            "    return temp_vars",
            "",
            "",
            "def _escape_backslashes(data, jinja_env):",
            "    \"\"\"Double backslashes within jinja2 expressions",
            "",
            "    A user may enter something like this in a playbook::",
            "",
            "      debug:",
            "        msg: \"Test Case 1\\\\3; {{ test1_name | regex_replace('^(.*)_name$', '\\\\1')}}\"",
            "",
            "    The string inside of the {{ gets interpreted multiple times First by yaml.",
            "    Then by python.  And finally by jinja2 as part of it's variable.  Because",
            "    it is processed by both python and jinja2, the backslash escaped",
            "    characters get unescaped twice.  This means that we'd normally have to use",
            "    four backslashes to escape that.  This is painful for playbook authors as",
            "    they have to remember different rules for inside vs outside of a jinja2",
            "    expression (The backslashes outside of the \"{{ }}\" only get processed by",
            "    yaml and python.  So they only need to be escaped once).  The following",
            "    code fixes this by automatically performing the extra quoting of",
            "    backslashes inside of a jinja2 expression.",
            "",
            "    \"\"\"",
            "    if '\\\\' in data and '{{' in data:",
            "        new_data = []",
            "        d2 = jinja_env.preprocess(data)",
            "        in_var = False",
            "",
            "        for token in jinja_env.lex(d2):",
            "            if token[1] == 'variable_begin':",
            "                in_var = True",
            "                new_data.append(token[2])",
            "            elif token[1] == 'variable_end':",
            "                in_var = False",
            "                new_data.append(token[2])",
            "            elif in_var and token[1] == 'string':",
            "                # Double backslashes only if we're inside of a jinja2 variable",
            "                new_data.append(token[2].replace('\\\\','\\\\\\\\'))",
            "            else:",
            "                new_data.append(token[2])",
            "",
            "        data = ''.join(new_data)",
            "",
            "    return data",
            "",
            "",
            "def _count_newlines_from_end(in_str):",
            "    '''",
            "    Counts the number of newlines at the end of a string. This is used during",
            "    the jinja2 templating to ensure the count matches the input, since some newlines",
            "    may be thrown away during the templating.",
            "    '''",
            "",
            "    try:",
            "        i = len(in_str)",
            "        j = i -1",
            "        while in_str[j] == '\\n':",
            "            j -= 1",
            "        return i - 1 - j",
            "    except IndexError:",
            "        # Uncommon cases: zero length string and string containing only newlines",
            "        return i",
            "",
            "class AnsibleContext(Context):",
            "    '''",
            "    A custom context, which intercepts resolve() calls and sets a flag",
            "    internally if any variable lookup returns an AnsibleUnsafe value. This",
            "    flag is checked post-templating, and (when set) will result in the",
            "    final templated result being wrapped via UnsafeProxy.",
            "    '''",
            "    def __init__(self, *args, **kwargs):",
            "        super(AnsibleContext, self).__init__(*args, **kwargs)",
            "        self.unsafe = False",
            "",
            "    def _is_unsafe(self, val):",
            "        '''",
            "        Our helper function, which will also recursively check dict and",
            "        list entries due to the fact that they may be repr'd and contain",
            "        a key or value which contains jinja2 syntax and would otherwise",
            "        lose the AnsibleUnsafe value.",
            "        '''",
            "        if isinstance(val, dict):",
            "            for key in val.keys():",
            "                if self._is_unsafe(val[key]):",
            "                    return True",
            "        elif isinstance(val, list):",
            "            for item in val:",
            "                if self._is_unsafe(item):",
            "                    return True",
            "        elif isinstance(val, string_types) and hasattr(val, '__UNSAFE__'):",
            "            return True",
            "        return False",
            "",
            "    def _update_unsafe(self, val):",
            "        if val is not None and not self.unsafe and self._is_unsafe(val):",
            "            self.unsafe = True",
            "",
            "    def resolve(self, key):",
            "        '''",
            "        The intercepted resolve(), which uses the helper above to set the",
            "        internal flag whenever an unsafe variable value is returned.",
            "        '''",
            "        val = super(AnsibleContext, self).resolve(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "    def resolve_or_missing(self, key):",
            "        val = super(AnsibleContext, self).resolve_or_missing(key)",
            "        self._update_unsafe(val)",
            "        return val",
            "",
            "class AnsibleEnvironment(Environment):",
            "    '''",
            "    Our custom environment, which simply allows us to override the class-level",
            "    values for the Template and Context classes used by jinja2 internally.",
            "    '''",
            "    context_class = AnsibleContext",
            "    template_class = AnsibleJ2Template",
            "",
            "class Templar:",
            "    '''",
            "    The main class for templating, with the main entry-point of template().",
            "    '''",
            "",
            "    def __init__(self, loader, shared_loader_obj=None, variables=dict()):",
            "        self._loader              = loader",
            "        self._filters             = None",
            "        self._tests               = None",
            "        self._available_variables = variables",
            "        self._cached_result       = {}",
            "",
            "        if loader:",
            "            self._basedir = loader.get_basedir()",
            "        else:",
            "            self._basedir = './'",
            "",
            "        if shared_loader_obj:",
            "            self._filter_loader = getattr(shared_loader_obj, 'filter_loader')",
            "            self._test_loader   = getattr(shared_loader_obj, 'test_loader')",
            "            self._lookup_loader = getattr(shared_loader_obj, 'lookup_loader')",
            "        else:",
            "            self._filter_loader = filter_loader",
            "            self._test_loader   = test_loader",
            "            self._lookup_loader = lookup_loader",
            "",
            "        # flags to determine whether certain failures during templating",
            "        # should result in fatal errors being raised",
            "        self._fail_on_lookup_errors    = True",
            "        self._fail_on_filter_errors    = True",
            "        self._fail_on_undefined_errors = C.DEFAULT_UNDEFINED_VAR_BEHAVIOR",
            "",
            "        self.environment = AnsibleEnvironment(",
            "            trim_blocks=True,",
            "            undefined=StrictUndefined,",
            "            extensions=self._get_extensions(),",
            "            finalize=self._finalize,",
            "            loader=FileSystemLoader(self._basedir),",
            "        )",
            "",
            "        # the current rendering context under which the templar class is working",
            "        self.cur_context = None",
            "",
            "        self.SINGLE_VAR = re.compile(r\"^%s\\s*(\\w*)\\s*%s$\" % (self.environment.variable_start_string, self.environment.variable_end_string))",
            "",
            "        self.block_start    = self.environment.block_start_string",
            "        self.block_end      = self.environment.block_end_string",
            "        self.variable_start = self.environment.variable_start_string",
            "        self.variable_end   = self.environment.variable_end_string",
            "        self._clean_regex   = re.compile(r'(?:%s|%s|%s|%s)' % (self.variable_start, self.block_start, self.block_end, self.variable_end))",
            "        self._no_type_regex = re.compile(r'.*\\|\\s*(?:%s)\\s*(?:%s)?$' % ('|'.join(C.STRING_TYPE_FILTERS), self.variable_end))",
            "",
            "    def _get_filters(self):",
            "        '''",
            "        Returns filter plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._filters is not None:",
            "            return self._filters.copy()",
            "",
            "        plugins = [x for x in self._filter_loader.all()]",
            "",
            "        self._filters = dict()",
            "        for fp in plugins:",
            "            self._filters.update(fp.filters())",
            "        self._filters.update(self._get_tests())",
            "",
            "        return self._filters.copy()",
            "",
            "    def _get_tests(self):",
            "        '''",
            "        Returns tests plugins, after loading and caching them if need be",
            "        '''",
            "",
            "        if self._tests is not None:",
            "            return self._tests.copy()",
            "",
            "        plugins = [x for x in self._test_loader.all()]",
            "",
            "        self._tests = dict()",
            "        for fp in plugins:",
            "            self._tests.update(fp.tests())",
            "",
            "        return self._tests.copy()",
            "",
            "    def _get_extensions(self):",
            "        '''",
            "        Return jinja2 extensions to load.",
            "",
            "        If some extensions are set via jinja_extensions in ansible.cfg, we try",
            "        to load them with the jinja environment.",
            "        '''",
            "",
            "        jinja_exts = []",
            "        if C.DEFAULT_JINJA2_EXTENSIONS:",
            "            # make sure the configuration directive doesn't contain spaces",
            "            # and split extensions in an array",
            "            jinja_exts = C.DEFAULT_JINJA2_EXTENSIONS.replace(\" \", \"\").split(',')",
            "",
            "        return jinja_exts",
            "",
            "    def _clean_data(self, orig_data):",
            "        ''' remove jinja2 template tags from data '''",
            "",
            "        if hasattr(orig_data, '__ENCRYPTED__'):",
            "            ret = orig_data",
            "",
            "        elif isinstance(orig_data, list):",
            "            clean_list = []",
            "            for list_item in orig_data:",
            "                clean_list.append(self._clean_data(list_item))",
            "            ret = clean_list",
            "",
            "        elif isinstance(orig_data, dict):",
            "            clean_dict = {}",
            "            for k in orig_data:",
            "                clean_dict[self._clean_data(k)] =  self._clean_data(orig_data[k])",
            "            ret = clean_dict",
            "",
            "        elif isinstance(orig_data, string_types):",
            "            # This will error with str data (needs unicode), but all strings should already be converted already.",
            "            # If you get exception, the problem is at the data origin, do not add to_text here.",
            "            with contextlib.closing(StringIO(orig_data)) as data:",
            "                # these variables keep track of opening block locations, as we only",
            "                # want to replace matched pairs of print/block tags",
            "                print_openings = []",
            "                block_openings = []",
            "                for mo in self._clean_regex.finditer(orig_data):",
            "                    token = mo.group(0)",
            "                    token_start = mo.start(0)",
            "",
            "                    if token[0] == self.environment.variable_start_string[0]:",
            "                        if token == self.environment.block_start_string:",
            "                            block_openings.append(token_start)",
            "                        elif token == self.environment.variable_start_string:",
            "                            print_openings.append(token_start)",
            "",
            "                    elif token[1] == self.environment.variable_end_string[1]:",
            "                        prev_idx = None",
            "                        if token == self.environment.block_end_string and block_openings:",
            "                            prev_idx = block_openings.pop()",
            "                        elif token == self.environment.variable_end_string and print_openings:",
            "                            prev_idx = print_openings.pop()",
            "",
            "                        if prev_idx is not None:",
            "                            # replace the opening",
            "                            data.seek(prev_idx, os.SEEK_SET)",
            "                            data.write(to_text(self.environment.comment_start_string))",
            "                            # replace the closing",
            "                            data.seek(token_start, os.SEEK_SET)",
            "                            data.write(to_text(self.environment.comment_end_string))",
            "",
            "                    else:",
            "                        raise AnsibleError(\"Error while cleaning data for safety: unhandled regex match\")",
            "",
            "                ret = data.getvalue()",
            "        else:",
            "            ret = orig_data",
            "",
            "        return ret",
            "",
            "    def set_available_variables(self, variables):",
            "        '''",
            "        Sets the list of template variables this Templar instance will use",
            "        to template things, so we don't have to pass them around between",
            "        internal methods. We also clear the template cache here, as the variables",
            "        are being changed.",
            "        '''",
            "",
            "        assert isinstance(variables, dict)",
            "        self._available_variables = variables",
            "        self._cached_result       = {}",
            "",
            "    def template(self, variable, convert_bare=False, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, convert_data=True, static_vars=[''], cache=True, bare_deprecated=True, disable_lookups=False):",
            "        '''",
            "        Templates (possibly recursively) any given data as input. If convert_bare is",
            "        set to True, the given data will be wrapped as a jinja2 variable ('{{foo}}')",
            "        before being sent through the template engine.",
            "        '''",
            "",
            "        # Don't template unsafe variables, just return them.",
            "        if hasattr(variable, '__UNSAFE__'):",
            "            return variable",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            if convert_bare:",
            "                variable = self._convert_bare_variable(variable, bare_deprecated=bare_deprecated)",
            "",
            "            if isinstance(variable, string_types):",
            "                result = variable",
            "",
            "                if self._contains_vars(variable):",
            "                    # Check to see if the string we are trying to render is just referencing a single",
            "                    # var.  In this case we don't want to accidentally change the type of the variable",
            "                    # to a string by using the jinja template renderer. We just want to pass it.",
            "                    only_one = self.SINGLE_VAR.match(variable)",
            "                    if only_one:",
            "                        var_name = only_one.group(1)",
            "                        if var_name in self._available_variables:",
            "                            resolved_val = self._available_variables[var_name]",
            "                            if isinstance(resolved_val, NON_TEMPLATED_TYPES):",
            "                                return resolved_val",
            "                            elif resolved_val is None:",
            "                                return C.DEFAULT_NULL_REPRESENTATION",
            "",
            "                    # Using a cache in order to prevent template calls with already templated variables",
            "                    sha1_hash = None",
            "                    if cache:",
            "                        variable_hash = sha1(text_type(variable).encode('utf-8'))",
            "                        options_hash  = sha1((text_type(preserve_trailing_newlines) + text_type(escape_backslashes) + text_type(fail_on_undefined) + text_type(overrides)).encode('utf-8'))",
            "                        sha1_hash = variable_hash.hexdigest() + options_hash.hexdigest()",
            "                    if cache and sha1_hash in self._cached_result:",
            "                        result = self._cached_result[sha1_hash]",
            "                    else:",
            "                        result = self.do_template(",
            "                            variable,",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            escape_backslashes=escape_backslashes,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                        )",
            "",
            "                        unsafe = hasattr(result, '__UNSAFE__')",
            "                        if convert_data and not self._no_type_regex.match(variable):",
            "                            # if this looks like a dictionary or list, convert it to such using the safe_eval method",
            "                            if (result.startswith(\"{\") and not result.startswith(self.environment.variable_start_string)) or \\",
            "                                    result.startswith(\"[\") or result in (\"True\", \"False\"):",
            "                                eval_results = safe_eval(result, locals=self._available_variables, include_exceptions=True)",
            "                                if eval_results[1] is None:",
            "                                    result = eval_results[0]",
            "                                    if unsafe:",
            "                                        result = wrap_var(result)",
            "                                else:",
            "                                    # FIXME: if the safe_eval raised an error, should we do something with it?",
            "                                    pass",
            "",
            "                        # we only cache in the case where we have a single variable",
            "                        # name, to make sure we're not putting things which may otherwise",
            "                        # be dynamic in the cache (filters, lookups, etc.)",
            "                        if cache:",
            "                            self._cached_result[sha1_hash] = result",
            "",
            "                return result",
            "",
            "            elif isinstance(variable, (list, tuple)):",
            "                return [self.template(",
            "                    v,",
            "                    preserve_trailing_newlines=preserve_trailing_newlines,",
            "                    fail_on_undefined=fail_on_undefined,",
            "                    overrides=overrides,",
            "                    disable_lookups=disable_lookups,",
            "                    ) for v in variable]",
            "            elif isinstance(variable, dict):",
            "                d = {}",
            "                # we don't use iteritems() here to avoid problems if the underlying dict",
            "                # changes sizes due to the templating, which can happen with hostvars",
            "                for k in variable.keys():",
            "                    if k not in static_vars:",
            "                        d[k] = self.template(",
            "                            variable[k],",
            "                            preserve_trailing_newlines=preserve_trailing_newlines,",
            "                            fail_on_undefined=fail_on_undefined,",
            "                            overrides=overrides,",
            "                            disable_lookups=disable_lookups,",
            "                            )",
            "                    else:",
            "                        d[k] = variable[k]",
            "                return d",
            "            else:",
            "                return variable",
            "",
            "        except AnsibleFilterError:",
            "            if self._fail_on_filter_errors:",
            "                raise",
            "            else:",
            "                return variable",
            "",
            "    def is_template(self, data):",
            "        ''' lets us know if data has a template'''",
            "        if isinstance(data, string_types):",
            "            try:",
            "                new = self.do_template(data, fail_on_undefined=True)",
            "            except (AnsibleUndefinedVariable, UndefinedError):",
            "                return True",
            "            except:",
            "                return False",
            "            return (new != data)",
            "        elif isinstance(data, (list, tuple)):",
            "            for v in data:",
            "                if self.is_template(v):",
            "                    return True",
            "        elif isinstance(data, dict):",
            "            for k in data:",
            "                if self.is_template(k) or self.is_template(data[k]):",
            "                    return True",
            "        return False",
            "",
            "    def templatable(self, data):",
            "        '''",
            "        returns True if the data can be templated w/o errors",
            "        '''",
            "        templatable = True",
            "        try:",
            "            self.template(data)",
            "        except:",
            "            templatable = False",
            "        return templatable",
            "",
            "    def _contains_vars(self, data):",
            "        '''",
            "        returns True if the data contains a variable pattern",
            "        '''",
            "        if isinstance(data, string_types):",
            "            for marker in (self.environment.block_start_string, self.environment.variable_start_string, self.environment.comment_start_string):",
            "                if marker in data:",
            "                    return True",
            "        return False",
            "",
            "    def _convert_bare_variable(self, variable, bare_deprecated):",
            "        '''",
            "        Wraps a bare string, which may have an attribute portion (ie. foo.bar)",
            "        in jinja2 variable braces so that it is evaluated properly.",
            "        '''",
            "",
            "        if isinstance(variable, string_types):",
            "            contains_filters = \"|\" in variable",
            "            first_part = variable.split(\"|\")[0].split(\".\")[0].split(\"[\")[0]",
            "            if (contains_filters or first_part in self._available_variables) and self.environment.variable_start_string not in variable:",
            "                if bare_deprecated:",
            "                    display.deprecated(\"Using bare variables is deprecated.\"",
            "                            \" Update your playbooks so that the environment value uses the full variable syntax ('%s%s%s')\" %",
            "                            (self.environment.variable_start_string, variable, self.environment.variable_end_string))",
            "                return \"%s%s%s\" % (self.environment.variable_start_string, variable, self.environment.variable_end_string)",
            "",
            "        # the variable didn't meet the conditions to be converted,",
            "        # so just return it as-is",
            "        return variable",
            "",
            "    def _finalize(self, thing):",
            "        '''",
            "        A custom finalize method for jinja2, which prevents None from being returned",
            "        '''",
            "        return thing if thing is not None else ''",
            "",
            "    def _fail_lookup(self, name, *args, **kwargs):",
            "        raise AnsibleError(\"The lookup `%s` was found, however lookups were disabled from templating\" % name)",
            "",
            "    def _lookup(self, name, *args, **kwargs):",
            "        instance = self._lookup_loader.get(name.lower(), loader=self._loader, templar=self)",
            "",
            "        if instance is not None:",
            "            wantlist = kwargs.pop('wantlist', False)",
            "            allow_unsafe = kwargs.pop('allow_unsafe', C.DEFAULT_ALLOW_UNSAFE_LOOKUPS)",
            "",
            "            from ansible.utils.listify import listify_lookup_plugin_terms",
            "            loop_terms = listify_lookup_plugin_terms(terms=args, templar=self, loader=self._loader, fail_on_undefined=True, convert_bare=False)",
            "            # safely catch run failures per #5059",
            "            try:",
            "                ran = instance.run(loop_terms, variables=self._available_variables, **kwargs)",
            "            except (AnsibleUndefinedVariable, UndefinedError) as e:",
            "                raise AnsibleUndefinedVariable(e)",
            "            except Exception as e:",
            "                if self._fail_on_lookup_errors:",
            "                    raise AnsibleError(\"An unhandled exception occurred while running the lookup plugin '%s'. Error was a %s, original message: %s\" % (name, type(e), e))",
            "                ran = None",
            "",
            "            if ran and not allow_unsafe:",
            "                from ansible.vars.unsafe_proxy import UnsafeProxy, wrap_var",
            "                if wantlist:",
            "                    ran = wrap_var(ran)",
            "                else:",
            "                    try:",
            "                        ran = UnsafeProxy(\",\".join(ran))",
            "                    except TypeError:",
            "                        if isinstance(ran, list) and len(ran) == 1:",
            "                            ran = wrap_var(ran[0])",
            "                        else:",
            "                            ran = wrap_var(ran)",
            "",
            "                if self.cur_context:",
            "                    self.cur_context.unsafe = True",
            "            return ran",
            "        else:",
            "            raise AnsibleError(\"lookup plugin (%s) not found\" % name)",
            "",
            "    def do_template(self, data, preserve_trailing_newlines=True, escape_backslashes=True, fail_on_undefined=None, overrides=None, disable_lookups=False):",
            "        # For preserving the number of input newlines in the output (used",
            "        # later in this method)",
            "        data_newlines = _count_newlines_from_end(data)",
            "",
            "        if fail_on_undefined is None:",
            "            fail_on_undefined = self._fail_on_undefined_errors",
            "",
            "        try:",
            "            # allows template header overrides to change jinja2 options.",
            "            if overrides is None:",
            "                myenv = self.environment.overlay()",
            "            else:",
            "                myenv = self.environment.overlay(overrides)",
            "",
            "            # Get jinja env overrides from template",
            "            if data.startswith(JINJA2_OVERRIDE):",
            "                eol = data.find('\\n')",
            "                line = data[len(JINJA2_OVERRIDE):eol]",
            "                data = data[eol+1:]",
            "                for pair in line.split(','):",
            "                    (key,val) = pair.split(':')",
            "                    key = key.strip()",
            "                    setattr(myenv, key, ast.literal_eval(val.strip()))",
            "",
            "            # Adds Ansible custom filters and tests",
            "            myenv.filters.update(self._get_filters())",
            "            myenv.tests.update(self._get_tests())",
            "",
            "            if escape_backslashes:",
            "                # Allow users to specify backslashes in playbooks as \"\\\\\" instead of as \"\\\\\\\\\".",
            "                data = _escape_backslashes(data, myenv)",
            "",
            "            try:",
            "                t = myenv.from_string(data)",
            "            except TemplateSyntaxError as e:",
            "                raise AnsibleError(\"template error while templating string: %s. String: %s\" % (to_native(e), to_native(data)))",
            "            except Exception as e:",
            "                if 'recursion' in to_native(e):",
            "                    raise AnsibleError(\"recursive loop detected in template string: %s\" % to_native(data))",
            "                else:",
            "                    return data",
            "",
            "            if disable_lookups:",
            "                t.globals['lookup'] = self._fail_lookup",
            "            else:",
            "                t.globals['lookup'] = self._lookup",
            "",
            "            t.globals['finalize'] = self._finalize",
            "",
            "            jvars = AnsibleJ2Vars(self, t.globals)",
            "",
            "            self.cur_context = new_context = t.new_context(jvars, shared=True)",
            "            rf = t.root_render_func(new_context)",
            "",
            "            try:",
            "                res = j2_concat(rf)",
            "                if new_context.unsafe:",
            "                    res = wrap_var(res)",
            "            except TypeError as te:",
            "                if 'StrictUndefined' in to_native(te):",
            "                    errmsg  = \"Unable to look up a name or access an attribute in template string (%s).\\n\" % to_native(data)",
            "                    errmsg += \"Make sure your variable name does not contain invalid characters like '-': %s\" % to_native(te)",
            "                    raise AnsibleUndefinedVariable(errmsg)",
            "                else:",
            "                    display.debug(\"failing because of a type error, template data is: %s\" % to_native(data))",
            "                    raise AnsibleError(\"Unexpected templating type error occurred on (%s): %s\" % (to_native(data),to_native(te)))",
            "",
            "            if preserve_trailing_newlines:",
            "                # The low level calls above do not preserve the newline",
            "                # characters at the end of the input data, so we use the",
            "                # calculate the difference in newlines and append them",
            "                # to the resulting output for parity",
            "                #",
            "                # jinja2 added a keep_trailing_newline option in 2.7 when",
            "                # creating an Environment.  That would let us make this code",
            "                # better (remove a single newline if",
            "                # preserve_trailing_newlines is False).  Once we can depend on",
            "                # that version being present, modify our code to set that when",
            "                # initializing self.environment and remove a single trailing",
            "                # newline here if preserve_newlines is False.",
            "                res_newlines = _count_newlines_from_end(res)",
            "                if data_newlines > res_newlines:",
            "                    res += '\\n' * (data_newlines - res_newlines)",
            "            return res",
            "        except (UndefinedError, AnsibleUndefinedVariable) as e:",
            "            if fail_on_undefined:",
            "                raise AnsibleUndefinedVariable(e)",
            "            else:",
            "                #TODO: return warning about undefined var",
            "                return data",
            "",
            "    # for backwards compatibility in case anyone is using old private method directly",
            "    _do_template = do_template"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "580": [
                "Templar",
                "_lookup"
            ],
            "648": [
                "Templar",
                "do_template"
            ]
        },
        "addLocation": [
            "lib.ansible.template.Templar._cached_result",
            "nova.tests.unit.network.test_neutron.TestAPI",
            "lib.ansible.template.Templar"
        ]
    }
}