{
    "src/OFS/Image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import html"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+import os"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import struct"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from email.generator import _make_boundary"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from io import BytesIO"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from mimetypes import guess_extension"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from urllib.parse import quote"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from xml.dom import minidom"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " import ZPublisher.HTTPRequest"
            },
            "12": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " from ZPublisher.HTTPRequest import FileUpload"
            },
            "13": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+def _get_list_from_env(name, default=None):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    \"\"\"Get list from environment variable."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    Supports splitting on comma or white space."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    Use the default as fallback only when the variable is not set."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    So if the env variable is set to an empty string, this will ignore the"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    default and return an empty list."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    \"\"\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    value = os.environ.get(name)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    if value is None:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        return default or []"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    value = value.strip()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    if \",\" in value:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        return value.split(\",\")"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    return value.split()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+# We have one list for allowed, and one for disallowed inline mimetypes."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+# This is for security purposes."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+# By default we use the allowlist.  We give integrators the option to choose"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+# the denylist via an environment variable."
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+ALLOWED_INLINE_MIMETYPES = _get_list_from_env("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    \"ALLOWED_INLINE_MIMETYPES\","
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    default=["
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        \"image/gif\","
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        # The mimetypes registry lists several for jpeg 2000:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        \"image/jp2\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        \"image/jpeg\","
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        \"image/jpeg2000-image\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        \"image/jpeg2000\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        \"image/jpx\","
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        \"image/png\","
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        \"image/webp\","
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        \"image/x-icon\","
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        \"image/x-jpeg2000-image\","
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        \"text/plain\","
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        # By popular request we allow PDF:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        \"application/pdf\","
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    ]"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+DISALLOWED_INLINE_MIMETYPES = _get_list_from_env("
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    \"DISALLOWED_INLINE_MIMETYPES\","
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    default=["
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        \"application/javascript\","
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        \"application/x-javascript\","
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        \"text/javascript\","
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        \"text/html\","
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        \"image/svg+xml\","
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        \"image/svg+xml-compressed\","
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    ]"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+try:"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    USE_DENYLIST = os.environ.get(\"OFS_IMAGE_USE_DENYLIST\")"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    USE_DENYLIST = bool(int(USE_DENYLIST))"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+except (ValueError, TypeError, AttributeError):"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    USE_DENYLIST = False"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " manage_addFileForm = DTMLFile("
            },
            "74": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "     'dtml/imageAdd',"
            },
            "75": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "     globals(),"
            },
            "76": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     Cacheable"
            },
            "77": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " ):"
            },
            "78": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     \"\"\"A File object is a content object for arbitrary files.\"\"\""
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    # You can control which mimetypes may be shown inline"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    # and which must always be downloaded, for security reasons."
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+    # Make the configuration available on the class."
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    # Then subclasses can override this."
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    use_denylist = USE_DENYLIST"
            },
            "86": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     meta_type = 'File'"
            },
            "88": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     zmi_icon = 'far fa-file-archive'"
            },
            "89": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "                         b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')"
            },
            "90": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "                     return True"
            },
            "91": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 473,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+    def _should_force_download(self):"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+        # If this returns True, the caller should set a"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+        # Content-Disposition header with filename."
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+        mimetype = self.content_type"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        if not mimetype:"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+            return False"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+        if self.use_denylist:"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 481,
                "PatchRowcode": "+            # We explicitly deny a few mimetypes, and allow the rest."
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+            return mimetype in self.disallowed_inline_mimetypes"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+        # Use the allowlist."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+        # We only explicitly allow a few mimetypes, and deny the rest."
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+        return mimetype not in self.allowed_inline_mimetypes"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+"
            },
            "105": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 487,
                "PatchRowcode": "     @security.protected(View)"
            },
            "106": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 488,
                "PatchRowcode": "     def index_html(self, REQUEST, RESPONSE):"
            },
            "107": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 489,
                "PatchRowcode": "         \"\"\""
            },
            "108": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 522,
                "PatchRowcode": "         RESPONSE.setHeader('Content-Length', self.size)"
            },
            "109": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 523,
                "PatchRowcode": "         RESPONSE.setHeader('Accept-Ranges', 'bytes')"
            },
            "110": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 524,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+        if self._should_force_download():"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+            # We need a filename, even a dummy one if needed."
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+            filename = self.getId()"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 528,
                "PatchRowcode": "+            if \".\" not in filename:"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 529,
                "PatchRowcode": "+                # This either returns None or \".some_extension\""
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 530,
                "PatchRowcode": "+                ext = guess_extension(self.content_type, strict=False)"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 531,
                "PatchRowcode": "+                if not ext:"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 532,
                "PatchRowcode": "+                    # image/svg+xml -> svg"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 533,
                "PatchRowcode": "+                    ext = \".\" + self.content_type.split(\"/\")[-1].split(\"+\")[0]"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 534,
                "PatchRowcode": "+                filename += f\"{ext}\""
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 535,
                "PatchRowcode": "+            filename = quote(filename.encode(\"utf8\"))"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 536,
                "PatchRowcode": "+            RESPONSE.setHeader("
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 537,
                "PatchRowcode": "+                \"Content-Disposition\","
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 538,
                "PatchRowcode": "+                f\"attachment; filename*=UTF-8''{filename}\","
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 539,
                "PatchRowcode": "+            )"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 540,
                "PatchRowcode": "+"
            },
            "127": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 541,
                "PatchRowcode": "         if self.ZCacheable_isCachingEnabled():"
            },
            "128": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 542,
                "PatchRowcode": "             result = self.ZCacheable_get(default=None)"
            },
            "129": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 543,
                "PatchRowcode": "             if result is not None:"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Image object",
            "\"\"\"",
            "",
            "import html",
            "import struct",
            "from email.generator import _make_boundary",
            "from io import BytesIO",
            "from xml.dom import minidom",
            "",
            "import ZPublisher.HTTPRequest",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.Permissions import change_images_and_files  # NOQA",
            "from AccessControl.Permissions import view as View",
            "from AccessControl.Permissions import view_management_screens",
            "from AccessControl.Permissions import webdav_access",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from Acquisition import Implicit",
            "from App.special_dtml import DTMLFile",
            "from DateTime.DateTime import DateTime",
            "from OFS.Cache import Cacheable",
            "from OFS.interfaces import IWriteLock",
            "from OFS.PropertyManager import PropertyManager",
            "from OFS.role import RoleManager",
            "from OFS.SimpleItem import Item_w__name__",
            "from OFS.SimpleItem import PathReprProvider",
            "from Persistence import Persistent",
            "from zExceptions import Redirect",
            "from zExceptions import ResourceLockedError",
            "from zope.contenttype import guess_content_type",
            "from zope.datetime import rfc1123_date",
            "from zope.event import notify",
            "from zope.interface import implementer",
            "from zope.lifecycleevent import ObjectCreatedEvent",
            "from zope.lifecycleevent import ObjectModifiedEvent",
            "from ZPublisher import HTTPRangeSupport",
            "from ZPublisher.HTTPRequest import FileUpload",
            "",
            "",
            "manage_addFileForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='File',",
            "    kind='file',",
            ")",
            "",
            "",
            "def manage_addFile(",
            "    self,",
            "    id,",
            "    file=b'',",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"Add a new File object.",
            "",
            "    Creates a new File object 'id' with the contents of 'file'\"\"\"",
            "",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the file without data:",
            "    self._setObject(id, File(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        REQUEST.RESPONSE.redirect(self.absolute_url() + '/manage_main')",
            "",
            "",
            "@implementer(IWriteLock, HTTPRangeSupport.HTTPRangeInterface)",
            "class File(",
            "    PathReprProvider,",
            "    Persistent,",
            "    Implicit,",
            "    PropertyManager,",
            "    RoleManager,",
            "    Item_w__name__,",
            "    Cacheable",
            "):",
            "    \"\"\"A File object is a content object for arbitrary files.\"\"\"",
            "",
            "    meta_type = 'File'",
            "    zmi_icon = 'far fa-file-archive'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    precondition = ''",
            "    size = None",
            "",
            "    manage_editForm = DTMLFile('dtml/fileEdit', globals(),",
            "                               Kind='File', kind='file')",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    manage_options = (({'label': 'Edit', 'action': 'manage_main'},",
            "                       {'label': 'View', 'action': ''})",
            "                      + PropertyManager.manage_options",
            "                      + RoleManager.manage_options",
            "                      + Item_w__name__.manage_options",
            "                      + Cacheable.manage_options)",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string'},",
            "    )",
            "",
            "    def __init__(self, id, title, file, content_type='', precondition=''):",
            "        self.__name__ = id",
            "        self.title = title",
            "        self.precondition = precondition",
            "",
            "        data, size = self._read_data(file)",
            "        content_type = self._get_content_type(file, data, id, content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "    def _if_modified_since_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP If-Modified-Since header handling: return True if",
            "        # we can handle this request by returning a 304 response",
            "        header = REQUEST.get_header('If-Modified-Since', None)",
            "        if header is not None:",
            "            header = header.split(';')[0]",
            "            # Some proxies seem to send invalid date strings for this",
            "            # header. If the date string is not valid, we ignore it",
            "            # rather than raise an error to be generally consistent",
            "            # with common servers such as Apache (which can usually",
            "            # understand the screwy date string as a lucky side effect",
            "            # of the way they parse it).",
            "            # This happens to be what RFC2616 tells us to do in the face of an",
            "            # invalid date.",
            "            try:",
            "                mod_since = int(DateTime(header).timeTime())",
            "            except Exception:",
            "                mod_since = None",
            "            if mod_since is not None:",
            "                if self._p_mtime:",
            "                    last_mod = int(self._p_mtime)",
            "                else:",
            "                    last_mod = 0",
            "                if last_mod > 0 and last_mod <= mod_since:",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setStatus(304)",
            "                    return True",
            "",
            "    def _range_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP Range header handling: return True if we've served a range",
            "        # chunk out of our data.",
            "        range = REQUEST.get_header('Range', None)",
            "        request_range = REQUEST.get_header('Request-Range', None)",
            "        if request_range is not None:",
            "            # Netscape 2 through 4 and MSIE 3 implement a draft version",
            "            # Later on, we need to serve a different mime-type as well.",
            "            range = request_range",
            "        if_range = REQUEST.get_header('If-Range', None)",
            "        if range is not None:",
            "            ranges = HTTPRangeSupport.parseRange(range)",
            "",
            "            if if_range is not None:",
            "                # Only send ranges if the data isn't modified, otherwise send",
            "                # the whole object. Support both ETags and Last-Modified dates!",
            "                if len(if_range) > 1 and if_range[:2] == 'ts':",
            "                    # ETag:",
            "                    if if_range != self.http__etag():",
            "                        # Modified, so send a normal response. We delete",
            "                        # the ranges, which causes us to skip to the 200",
            "                        # response.",
            "                        ranges = None",
            "                else:",
            "                    # Date",
            "                    date = if_range.split(';')[0]",
            "                    try:",
            "                        mod_since = int(DateTime(date).timeTime())",
            "                    except Exception:",
            "                        mod_since = None",
            "                    if mod_since is not None:",
            "                        if self._p_mtime:",
            "                            last_mod = int(self._p_mtime)",
            "                        else:",
            "                            last_mod = 0",
            "                        if last_mod > mod_since:",
            "                            # Modified, so send a normal response. We delete",
            "                            # the ranges, which causes us to skip to the 200",
            "                            # response.",
            "                            ranges = None",
            "",
            "            if ranges:",
            "                # Search for satisfiable ranges.",
            "                satisfiable = 0",
            "                for start, end in ranges:",
            "                    if start < self.size:",
            "                        satisfiable = 1",
            "                        break",
            "",
            "                if not satisfiable:",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range', 'bytes */%d' % self.size",
            "                    )",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', self.size)",
            "                    RESPONSE.setStatus(416)",
            "                    return True",
            "",
            "                ranges = HTTPRangeSupport.expandRanges(ranges, self.size)",
            "",
            "                if len(ranges) == 1:",
            "                    # Easy case, set extra header and return partial set.",
            "                    start, end = ranges[0]",
            "                    size = end - start",
            "",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range',",
            "                        'bytes %d-%d/%d' % (start, end - 1, self.size)",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    if isinstance(data, bytes):",
            "                        RESPONSE.write(data[start:end])",
            "                        return True",
            "",
            "                    # Linked Pdata objects. Urgh.",
            "                    pos = 0",
            "                    while data is not None:",
            "                        length = len(data.data)",
            "                        pos = pos + length",
            "                        if pos > start:",
            "                            # We are within the range",
            "                            lstart = length - (pos - start)",
            "",
            "                            if lstart < 0:",
            "                                lstart = 0",
            "",
            "                            # find the endpoint",
            "                            if end <= pos:",
            "                                lend = length - (pos - end)",
            "",
            "                                # Send and end transmission",
            "                                RESPONSE.write(data[lstart:lend])",
            "                                break",
            "",
            "                            # Not yet at the end, transmit what we have.",
            "                            RESPONSE.write(data[lstart:])",
            "",
            "                        data = data.next",
            "",
            "                    return True",
            "",
            "                else:",
            "                    boundary = _make_boundary()",
            "",
            "                    # Calculate the content length",
            "                    size = (8 + len(boundary)  # End marker length",
            "                            + len(ranges) * (  # Constant lenght per set",
            "                                49 + len(boundary)",
            "                                + len(self.content_type)",
            "                                + len('%d' % self.size)))",
            "                    for start, end in ranges:",
            "                        # Variable length per set",
            "                        size = (size + len('%d%d' % (start, end - 1))",
            "                                + end - start)",
            "",
            "                    # Some clients implement an earlier draft of the spec, they",
            "                    # will only accept x-byteranges.",
            "                    draftprefix = (request_range is not None) and 'x-' or ''",
            "",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader(",
            "                        'Content-Type',",
            "                        f'multipart/{draftprefix}byteranges;'",
            "                        f' boundary={boundary}'",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    # The Pdata map allows us to jump into the Pdata chain",
            "                    # arbitrarily during out-of-order range searching.",
            "                    pdata_map = {}",
            "                    pdata_map[0] = data",
            "",
            "                    for start, end in ranges:",
            "                        RESPONSE.write(",
            "                            b'\\r\\n--'",
            "                            + boundary.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Type: '",
            "                            + self.content_type.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Range: bytes '",
            "                            + str(start).encode('ascii')",
            "                            + b'-'",
            "                            + str(end - 1).encode('ascii')",
            "                            + b'/'",
            "                            + str(self.size).encode('ascii')",
            "                            + b'\\r\\n\\r\\n'",
            "                        )",
            "",
            "                        if isinstance(data, bytes):",
            "                            RESPONSE.write(data[start:end])",
            "",
            "                        else:",
            "                            # Yippee. Linked Pdata objects. The following",
            "                            # calculations allow us to fast-forward through the",
            "                            # Pdata chain without a lot of dereferencing if we",
            "                            # did the work already.",
            "                            first_size = len(pdata_map[0].data)",
            "                            if start < first_size:",
            "                                closest_pos = 0",
            "                            else:",
            "                                closest_pos = (",
            "                                    ((start - first_size) >> 16 << 16)",
            "                                    + first_size",
            "                                )",
            "                            pos = min(closest_pos, max(pdata_map.keys()))",
            "                            data = pdata_map[pos]",
            "",
            "                            while data is not None:",
            "                                length = len(data.data)",
            "                                pos = pos + length",
            "                                if pos > start:",
            "                                    # We are within the range",
            "                                    lstart = length - (pos - start)",
            "",
            "                                    if lstart < 0:",
            "                                        lstart = 0",
            "",
            "                                    # find the endpoint",
            "                                    if end <= pos:",
            "                                        lend = length - (pos - end)",
            "",
            "                                        # Send and loop to next range",
            "                                        RESPONSE.write(data[lstart:lend])",
            "                                        break",
            "",
            "                                    # Not yet at the end,",
            "                                    # transmit what we have.",
            "                                    RESPONSE.write(data[lstart:])",
            "",
            "                                data = data.next",
            "                                # Store a reference to a Pdata chain link",
            "                                # so we don't have to deref during",
            "                                # this request again.",
            "                                pdata_map[pos] = data",
            "",
            "                    # Do not keep the link references around.",
            "                    del pdata_map",
            "",
            "                    RESPONSE.write(",
            "                        b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')",
            "                    return True",
            "",
            "    @security.protected(View)",
            "    def index_html(self, REQUEST, RESPONSE):",
            "        \"\"\"",
            "        The default view of the contents of a File or Image.",
            "",
            "        Returns the contents of the file or image.  Also, sets the",
            "        Content-Type HTTP header to the objects content type.",
            "        \"\"\"",
            "",
            "        if self._if_modified_since_request_handler(REQUEST, RESPONSE):",
            "            # we were able to handle this by returning a 304",
            "            # unfortunately, because the HTTP cache manager uses the cache",
            "            # API, and because 304 responses are required to carry the Expires",
            "            # header for HTTP/1.1, we need to call ZCacheable_set here.",
            "            # This is nonsensical for caches other than the HTTP cache manager",
            "            # unfortunately.",
            "            self.ZCacheable_set(None)",
            "            return b''",
            "",
            "        if self.precondition and hasattr(self, str(self.precondition)):",
            "            # Grab whatever precondition was defined and then",
            "            # execute it.  The precondition will raise an exception",
            "            # if something violates its terms.",
            "            c = getattr(self, str(self.precondition))",
            "            if hasattr(c, 'isDocTemp') and c.isDocTemp:",
            "                c(REQUEST['PARENTS'][1], REQUEST)",
            "            else:",
            "                c()",
            "",
            "        if self._range_request_handler(REQUEST, RESPONSE):",
            "            # we served a chunk of content in response to a range request.",
            "            return b''",
            "",
            "        RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))",
            "        RESPONSE.setHeader('Content-Type', self.content_type)",
            "        RESPONSE.setHeader('Content-Length', self.size)",
            "        RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager and HTTP",
            "                # Accelerated Cache Manager but we will get",
            "                # something implementing the IStreamIterator interface",
            "                # from a \"FileCacheManager\"",
            "                return result",
            "",
            "        self.ZCacheable_set(None)",
            "",
            "        data = self.data",
            "        if isinstance(data, bytes):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "    @security.protected(View)",
            "    def view_image_or_file(self, URL1):",
            "        \"\"\"The default view of the contents of the File or Image.\"\"\"",
            "        raise Redirect(URL1)",
            "",
            "    @security.protected(View)",
            "    def PrincipiaSearchSource(self):",
            "        \"\"\"Allow file objects to be searched.\"\"\"",
            "        if self.content_type.startswith('text/'):",
            "            return bytes(self.data)",
            "        return b''",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, str):",
            "            raise TypeError('Data can only be bytes or file-like. '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "        if size is None:",
            "            size = len(data)",
            "        self.size = size",
            "        self.data = data",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def _get_encoding(self):",
            "        \"\"\"Get the canonical encoding for ZMI.\"\"\"",
            "        return ZPublisher.HTTPRequest.default_encoding",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_edit(",
            "        self,",
            "        title,",
            "        content_type,",
            "        precondition='',",
            "        filedata=None,",
            "        REQUEST=None",
            "    ):",
            "        \"\"\"",
            "        Changes the title and content type attributes of the File or Image.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        self.title = str(title)",
            "        self.content_type = str(content_type)",
            "        if precondition:",
            "            self.precondition = str(precondition)",
            "        elif self.precondition:",
            "            del self.precondition",
            "        if filedata is not None:",
            "            if isinstance(filedata, str):",
            "                filedata = filedata.encode(self._get_encoding())",
            "            self.update_data(filedata, content_type, len(filedata))",
            "        else:",
            "            self.ZCacheable_invalidate()",
            "",
            "        notify(ObjectModifiedEvent(self))",
            "",
            "        if REQUEST:",
            "            message = \"Saved changes.\"",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=message)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_upload(self, file='', REQUEST=None):",
            "        \"\"\"",
            "        Replaces the current contents of the File or Image object with file.",
            "",
            "        The file or images contents are replaced with the contents of 'file'.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        if file:",
            "            data, size = self._read_data(file)",
            "            content_type = self._get_content_type(file, data, self.__name__,",
            "                                                  'application/octet-stream')",
            "            self.update_data(data, content_type, size)",
            "            notify(ObjectModifiedEvent(self))",
            "            msg = 'Saved changes.'",
            "        else:",
            "            msg = 'Please select a file to upload.'",
            "",
            "        if REQUEST:",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=msg)",
            "",
            "    def _get_content_type(self, file, body, id, content_type=None):",
            "        headers = getattr(file, 'headers', None)",
            "        if headers and 'content-type' in headers:",
            "            content_type = headers['content-type']",
            "        else:",
            "            if not isinstance(body, bytes):",
            "                body = body.data",
            "            content_type, enc = guess_content_type(",
            "                getattr(file, 'filename', id), body, content_type)",
            "        return content_type",
            "",
            "    def _read_data(self, file):",
            "        import transaction",
            "",
            "        n = 1 << 16",
            "",
            "        if isinstance(file, str):",
            "            raise ValueError(\"Must be bytes\")",
            "",
            "        if isinstance(file, bytes):",
            "            size = len(file)",
            "            if size < n:",
            "                return (file, size)",
            "            # Big string: cut it into smaller chunks",
            "            file = BytesIO(file)",
            "",
            "        if isinstance(file, FileUpload) and not file:",
            "            raise ValueError('File not specified')",
            "",
            "        if hasattr(file, '__class__') and file.__class__ is Pdata:",
            "            size = len(file)",
            "            return (file, size)",
            "",
            "        seek = file.seek",
            "        read = file.read",
            "",
            "        seek(0, 2)",
            "        size = end = file.tell()",
            "",
            "        if size <= 2 * n:",
            "            seek(0)",
            "            if size < n:",
            "                return read(size), size",
            "            return Pdata(read(size)), size",
            "",
            "        # Make sure we have an _p_jar, even if we are a new object, by",
            "        # doing a sub-transaction commit.",
            "        transaction.savepoint(optimistic=True)",
            "",
            "        if self._p_jar is None:",
            "            # Ugh",
            "            seek(0)",
            "            return Pdata(read(size)), size",
            "",
            "        # Now we're going to build a linked list from back",
            "        # to front to minimize the number of database updates",
            "        # and to allow us to get things out of memory as soon as",
            "        # possible.",
            "        _next = None",
            "        while end > 0:",
            "            pos = end - n",
            "            if pos < n:",
            "                pos = 0  # we always want at least n bytes",
            "            seek(pos)",
            "",
            "            # Create the object and assign it a next pointer",
            "            # in the same transaction, so that there is only",
            "            # a single database update for it.",
            "            data = Pdata(read(end - pos))",
            "            self._p_jar.add(data)",
            "            data.next = _next",
            "",
            "            # Save the object so that we can release its memory.",
            "            transaction.savepoint(optimistic=True)",
            "            data._p_deactivate()",
            "            # The object should be assigned an oid and be a ghost.",
            "            assert data._p_oid is not None",
            "            assert data._p_state == -1",
            "",
            "            _next = data",
            "            end = pos",
            "",
            "        return (_next, size)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def PUT(self, REQUEST, RESPONSE):",
            "        \"\"\"Handle HTTP PUT requests\"\"\"",
            "        self.dav__init(REQUEST, RESPONSE)",
            "        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)",
            "        type = REQUEST.get_header('content-type', None)",
            "",
            "        file = REQUEST['BODYFILE']",
            "",
            "        data, size = self._read_data(file)",
            "        if isinstance(data, str):",
            "            data = data.encode('UTF-8')",
            "        content_type = self._get_content_type(file, data, self.__name__,",
            "                                              type or self.content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "        RESPONSE.setStatus(204)",
            "        return RESPONSE",
            "",
            "    @security.protected(View)",
            "    def get_size(self):",
            "        # Get the size of a file or image.",
            "        # Returns the size of the file or image.",
            "        size = self.size",
            "        if size is None:",
            "            size = len(self.data)",
            "        return size",
            "",
            "    # deprecated; use get_size!",
            "    getSize = get_size",
            "",
            "    @security.protected(View)",
            "    def getContentType(self):",
            "        # Get the content type of a file or image.",
            "        # Returns the content type (MIME type) of a file or image.",
            "        return self.content_type",
            "",
            "    def __bytes__(self):",
            "        return bytes(self.data)",
            "",
            "    def __str__(self):",
            "        \"\"\"In most cases, this is probably not what you want. Use ``bytes``.\"\"\"",
            "        if isinstance(self.data, Pdata):",
            "            return bytes(self.data).decode(self._get_encoding())",
            "        else:",
            "            return self.data.decode(self._get_encoding())",
            "",
            "    def __bool__(self):",
            "        return True",
            "",
            "    __nonzero__ = __bool__",
            "",
            "    def __len__(self):",
            "        data = bytes(self.data)",
            "        return len(data)",
            "",
            "    @security.protected(webdav_access)",
            "    def manage_DAVget(self):",
            "        \"\"\"Return body for WebDAV.\"\"\"",
            "        RESPONSE = self.REQUEST.RESPONSE",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager but we will",
            "                # get something implementing the IStreamIterator interface",
            "                # from FileCacheManager.",
            "                # the content-length is required here by HTTPResponse.",
            "                RESPONSE.setHeader('Content-Length', self.size)",
            "                return result",
            "",
            "        data = self.data",
            "        if isinstance(data, bytes):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "",
            "InitializeClass(File)",
            "",
            "",
            "manage_addImageForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='Image',",
            "    kind='image',",
            ")",
            "",
            "",
            "def manage_addImage(",
            "    self,",
            "    id,",
            "    file,",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"",
            "    Add a new Image object.",
            "",
            "    Creates a new Image object 'id' with the contents of 'file'.",
            "    \"\"\"",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the image without data:",
            "    self._setObject(id, Image(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        try:",
            "            url = self.DestinationURL()",
            "        except Exception:",
            "            url = REQUEST['URL1']",
            "        REQUEST.RESPONSE.redirect('%s/manage_main' % url)",
            "    return id",
            "",
            "",
            "def getImageInfo(data):",
            "    data = bytes(data)",
            "    size = len(data)",
            "    height = -1",
            "    width = -1",
            "    content_type = ''",
            "",
            "    # handle GIFs",
            "    if (size >= 10) and data[:6] in (b'GIF87a', b'GIF89a'):",
            "        # Check to see if content_type is correct",
            "        content_type = 'image/gif'",
            "        w, h = struct.unpack(\"<HH\", data[6:10])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)",
            "    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'",
            "    # and finally the 4-byte width, height",
            "    elif (size >= 24",
            "          and data[:8] == b'\\211PNG\\r\\n\\032\\n'",
            "          and data[12:16] == b'IHDR'):",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[16:24])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # Maybe this is for an older PNG version.",
            "    elif (size >= 16) and (data[:8] == b'\\211PNG\\r\\n\\032\\n'):",
            "        # Check to see if we have the right content type",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[8:16])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # handle JPEGs",
            "    elif (size >= 2) and (data[:2] == b'\\377\\330'):",
            "        content_type = 'image/jpeg'",
            "        jpeg = BytesIO(data)",
            "        jpeg.read(2)",
            "        b = jpeg.read(1)",
            "        try:",
            "            while (b and ord(b) != 0xDA):",
            "                while (ord(b) != 0xFF):",
            "                    b = jpeg.read(1)",
            "                while (ord(b) == 0xFF):",
            "                    b = jpeg.read(1)",
            "                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):",
            "                    jpeg.read(3)",
            "                    h, w = struct.unpack(\">HH\", jpeg.read(4))",
            "                    break",
            "                else:",
            "                    jpeg.read(int(struct.unpack(\">H\", jpeg.read(2))[0]) - 2)",
            "                b = jpeg.read(1)",
            "            width = int(w)",
            "            height = int(h)",
            "        except Exception:",
            "            pass",
            "",
            "    # handle SVGs",
            "    elif (size >= 16) and ((b'<?xml' in data[:16]) or (b'<svg' in data[:16])):",
            "        try:",
            "            xmldoc = minidom.parseString(data)",
            "        except Exception:",
            "            return content_type, width, height",
            "        for svg in xmldoc.getElementsByTagName('svg'):",
            "            w = width",
            "            h = height",
            "            content_type = 'image/svg+xml'",
            "            if 'height' in svg.attributes and 'width' in svg.attributes:",
            "                w = svg.attributes['width'].value",
            "                h = svg.attributes['height'].value",
            "                try:",
            "                    w = int(float(w))",
            "                    h = int(float(h))",
            "                except Exception:",
            "                    if str(w).endswith('px'):",
            "                        w = int(float(w[:-2]))",
            "                        h = int(float(h[:-2]))",
            "                    elif str(w).endswith('mm'):",
            "                        w = int(float(w[:-2]) * 3.7795)",
            "                        h = int(float(h[:-2]) * 3.7795)",
            "                    elif str(w).endswith('cm'):",
            "                        w = int(float(w[:-2]) * 37.795)",
            "                        h = int(float(h[:-2]) * 37.795)",
            "                break",
            "            elif 'viewBox' in svg.attributes:",
            "                viewBox = svg.attributes['viewBox'].value",
            "                viewBox = [int(float(x)) for x in viewBox.split(' ')]",
            "                w = viewBox[2] - viewBox[0]",
            "                h = viewBox[3] - viewBox[1]",
            "            width = int(w)",
            "            height = int(h)",
            "",
            "    return content_type, width, height",
            "",
            "",
            "class Image(File):",
            "    \"\"\"Image objects can be GIF, PNG or JPEG and have the same methods",
            "    as File objects.  Images also have a string representation that",
            "    renders an HTML 'IMG' tag.",
            "    \"\"\"",
            "",
            "    meta_type = 'Image'",
            "    zmi_icon = 'far fa-file-image'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    alt = ''",
            "    height = ''",
            "    width = ''",
            "",
            "    # FIXME: Redundant, already in base class",
            "    security.declareProtected(change_images_and_files, 'manage_edit')  # NOQA: D001,E501",
            "    security.declareProtected(change_images_and_files, 'manage_upload')  # NOQA: D001,E501",
            "    security.declareProtected(View, 'index_html')  # NOQA: D001",
            "    security.declareProtected(View, 'get_size')  # NOQA: D001",
            "    security.declareProtected(View, 'getContentType')  # NOQA: D001",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'alt', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string', 'mode': 'w'},",
            "        {'id': 'height', 'type': 'string'},",
            "        {'id': 'width', 'type': 'string'},",
            "    )",
            "",
            "    manage_options = (",
            "        ({'label': 'Edit', 'action': 'manage_main'},",
            "         {'label': 'View', 'action': 'view_image_or_file'})",
            "        + PropertyManager.manage_options",
            "        + RoleManager.manage_options",
            "        + Item_w__name__.manage_options",
            "        + Cacheable.manage_options",
            "    )",
            "",
            "    manage_editForm = DTMLFile(",
            "        'dtml/imageEdit',",
            "        globals(),",
            "        Kind='Image',",
            "        kind='image',",
            "    )",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(View, 'view_image_or_file')  # NOQA: D001",
            "    view_image_or_file = DTMLFile('dtml/imageView', globals())",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, str):",
            "            raise TypeError('Data can only be bytes or file-like.  '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if size is None:",
            "            size = len(data)",
            "",
            "        self.size = size",
            "        self.data = data",
            "",
            "        ct, width, height = getImageInfo(data)",
            "        if ct:",
            "            content_type = ct",
            "        if width >= 0 and height >= 0:",
            "            self.width = width",
            "            self.height = height",
            "",
            "        # Now we should have the correct content type, or still None",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def __bytes__(self):",
            "        return self.tag().encode('utf-8')",
            "",
            "    def __str__(self):",
            "        return self.tag()",
            "",
            "    @security.protected(View)",
            "    def tag(",
            "        self,",
            "        height=None,",
            "        width=None,",
            "        alt=None,",
            "        scale=0,",
            "        xscale=0,",
            "        yscale=0,",
            "        css_class=None,",
            "        title=None,",
            "        **args",
            "    ):",
            "        \"\"\"Generate an HTML IMG tag for this image, with customization.",
            "",
            "        Arguments to self.tag() can be any valid attributes of an IMG tag.",
            "        'src' will always be an absolute pathname, to prevent redundant",
            "        downloading of images. Defaults are applied intelligently for",
            "        'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',",
            "        and 'yscale' keyword arguments will be used to automatically adjust",
            "        the output height and width values of the image tag.",
            "        #",
            "        Since 'class' is a Python reserved word, it cannot be passed in",
            "        directly in keyword arguments which is a problem if you are",
            "        trying to use 'tag()' to include a CSS class. The tag() method",
            "        will accept a 'css_class' argument that will be converted to",
            "        'class' in the output tag to work around this.",
            "        \"\"\"",
            "        if height is None:",
            "            height = self.height",
            "        if width is None:",
            "            width = self.width",
            "",
            "        # Auto-scaling support",
            "        xdelta = xscale or scale",
            "        ydelta = yscale or scale",
            "",
            "        if xdelta and width:",
            "            width = str(int(round(int(width) * xdelta)))",
            "        if ydelta and height:",
            "            height = str(int(round(int(height) * ydelta)))",
            "",
            "        result = '<img src=\"%s\"' % (self.absolute_url())",
            "",
            "        if alt is None:",
            "            alt = getattr(self, 'alt', '')",
            "        result = f'{result} alt=\"{html.escape(alt, True)}\"'",
            "",
            "        if title is None:",
            "            title = getattr(self, 'title', '')",
            "        result = f'{result} title=\"{html.escape(title, True)}\"'",
            "",
            "        if height:",
            "            result = f'{result} height=\"{height}\"'",
            "",
            "        if width:",
            "            result = f'{result} width=\"{width}\"'",
            "",
            "        if css_class is not None:",
            "            result = f'{result} class=\"{css_class}\"'",
            "",
            "        for key in list(args.keys()):",
            "            value = args.get(key)",
            "            if value:",
            "                result = f'{result} {key}=\"{value}\"'",
            "",
            "        return '%s />' % result",
            "",
            "",
            "InitializeClass(Image)",
            "",
            "",
            "def cookId(id, title, file):",
            "    if not id and hasattr(file, 'filename'):",
            "        filename = file.filename",
            "        title = title or filename",
            "        id = filename[max(filename.rfind('/'),",
            "                          filename.rfind('\\\\'),",
            "                          filename.rfind(':'),",
            "                          ) + 1:]",
            "    return id, title",
            "",
            "",
            "class Pdata(Persistent, Implicit):",
            "    # Wrapper for possibly large data",
            "",
            "    next = None",
            "",
            "    def __init__(self, data):",
            "        self.data = data",
            "",
            "    def __getitem__(self, key):",
            "        return self.data[key]",
            "",
            "    def __len__(self):",
            "        data = bytes(self)",
            "        return len(data)",
            "",
            "    def __bytes__(self):",
            "        _next = self.next",
            "        if _next is None:",
            "            return self.data",
            "",
            "        r = [self.data]",
            "        while _next is not None:",
            "            self = _next",
            "            r.append(self.data)",
            "            _next = self.next",
            "",
            "        return b''.join(r)"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Image object",
            "\"\"\"",
            "",
            "import html",
            "import os",
            "import struct",
            "from email.generator import _make_boundary",
            "from io import BytesIO",
            "from mimetypes import guess_extension",
            "from urllib.parse import quote",
            "from xml.dom import minidom",
            "",
            "import ZPublisher.HTTPRequest",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.Permissions import change_images_and_files  # NOQA",
            "from AccessControl.Permissions import view as View",
            "from AccessControl.Permissions import view_management_screens",
            "from AccessControl.Permissions import webdav_access",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from Acquisition import Implicit",
            "from App.special_dtml import DTMLFile",
            "from DateTime.DateTime import DateTime",
            "from OFS.Cache import Cacheable",
            "from OFS.interfaces import IWriteLock",
            "from OFS.PropertyManager import PropertyManager",
            "from OFS.role import RoleManager",
            "from OFS.SimpleItem import Item_w__name__",
            "from OFS.SimpleItem import PathReprProvider",
            "from Persistence import Persistent",
            "from zExceptions import Redirect",
            "from zExceptions import ResourceLockedError",
            "from zope.contenttype import guess_content_type",
            "from zope.datetime import rfc1123_date",
            "from zope.event import notify",
            "from zope.interface import implementer",
            "from zope.lifecycleevent import ObjectCreatedEvent",
            "from zope.lifecycleevent import ObjectModifiedEvent",
            "from ZPublisher import HTTPRangeSupport",
            "from ZPublisher.HTTPRequest import FileUpload",
            "",
            "",
            "def _get_list_from_env(name, default=None):",
            "    \"\"\"Get list from environment variable.",
            "",
            "    Supports splitting on comma or white space.",
            "    Use the default as fallback only when the variable is not set.",
            "    So if the env variable is set to an empty string, this will ignore the",
            "    default and return an empty list.",
            "    \"\"\"",
            "    value = os.environ.get(name)",
            "    if value is None:",
            "        return default or []",
            "    value = value.strip()",
            "    if \",\" in value:",
            "        return value.split(\",\")",
            "    return value.split()",
            "",
            "",
            "# We have one list for allowed, and one for disallowed inline mimetypes.",
            "# This is for security purposes.",
            "# By default we use the allowlist.  We give integrators the option to choose",
            "# the denylist via an environment variable.",
            "ALLOWED_INLINE_MIMETYPES = _get_list_from_env(",
            "    \"ALLOWED_INLINE_MIMETYPES\",",
            "    default=[",
            "        \"image/gif\",",
            "        # The mimetypes registry lists several for jpeg 2000:",
            "        \"image/jp2\",",
            "        \"image/jpeg\",",
            "        \"image/jpeg2000-image\",",
            "        \"image/jpeg2000\",",
            "        \"image/jpx\",",
            "        \"image/png\",",
            "        \"image/webp\",",
            "        \"image/x-icon\",",
            "        \"image/x-jpeg2000-image\",",
            "        \"text/plain\",",
            "        # By popular request we allow PDF:",
            "        \"application/pdf\",",
            "    ]",
            ")",
            "DISALLOWED_INLINE_MIMETYPES = _get_list_from_env(",
            "    \"DISALLOWED_INLINE_MIMETYPES\",",
            "    default=[",
            "        \"application/javascript\",",
            "        \"application/x-javascript\",",
            "        \"text/javascript\",",
            "        \"text/html\",",
            "        \"image/svg+xml\",",
            "        \"image/svg+xml-compressed\",",
            "    ]",
            ")",
            "try:",
            "    USE_DENYLIST = os.environ.get(\"OFS_IMAGE_USE_DENYLIST\")",
            "    USE_DENYLIST = bool(int(USE_DENYLIST))",
            "except (ValueError, TypeError, AttributeError):",
            "    USE_DENYLIST = False",
            "",
            "",
            "manage_addFileForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='File',",
            "    kind='file',",
            ")",
            "",
            "",
            "def manage_addFile(",
            "    self,",
            "    id,",
            "    file=b'',",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"Add a new File object.",
            "",
            "    Creates a new File object 'id' with the contents of 'file'\"\"\"",
            "",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the file without data:",
            "    self._setObject(id, File(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        REQUEST.RESPONSE.redirect(self.absolute_url() + '/manage_main')",
            "",
            "",
            "@implementer(IWriteLock, HTTPRangeSupport.HTTPRangeInterface)",
            "class File(",
            "    PathReprProvider,",
            "    Persistent,",
            "    Implicit,",
            "    PropertyManager,",
            "    RoleManager,",
            "    Item_w__name__,",
            "    Cacheable",
            "):",
            "    \"\"\"A File object is a content object for arbitrary files.\"\"\"",
            "    # You can control which mimetypes may be shown inline",
            "    # and which must always be downloaded, for security reasons.",
            "    # Make the configuration available on the class.",
            "    # Then subclasses can override this.",
            "    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES",
            "    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES",
            "    use_denylist = USE_DENYLIST",
            "",
            "    meta_type = 'File'",
            "    zmi_icon = 'far fa-file-archive'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    precondition = ''",
            "    size = None",
            "",
            "    manage_editForm = DTMLFile('dtml/fileEdit', globals(),",
            "                               Kind='File', kind='file')",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    manage_options = (({'label': 'Edit', 'action': 'manage_main'},",
            "                       {'label': 'View', 'action': ''})",
            "                      + PropertyManager.manage_options",
            "                      + RoleManager.manage_options",
            "                      + Item_w__name__.manage_options",
            "                      + Cacheable.manage_options)",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string'},",
            "    )",
            "",
            "    def __init__(self, id, title, file, content_type='', precondition=''):",
            "        self.__name__ = id",
            "        self.title = title",
            "        self.precondition = precondition",
            "",
            "        data, size = self._read_data(file)",
            "        content_type = self._get_content_type(file, data, id, content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "    def _if_modified_since_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP If-Modified-Since header handling: return True if",
            "        # we can handle this request by returning a 304 response",
            "        header = REQUEST.get_header('If-Modified-Since', None)",
            "        if header is not None:",
            "            header = header.split(';')[0]",
            "            # Some proxies seem to send invalid date strings for this",
            "            # header. If the date string is not valid, we ignore it",
            "            # rather than raise an error to be generally consistent",
            "            # with common servers such as Apache (which can usually",
            "            # understand the screwy date string as a lucky side effect",
            "            # of the way they parse it).",
            "            # This happens to be what RFC2616 tells us to do in the face of an",
            "            # invalid date.",
            "            try:",
            "                mod_since = int(DateTime(header).timeTime())",
            "            except Exception:",
            "                mod_since = None",
            "            if mod_since is not None:",
            "                if self._p_mtime:",
            "                    last_mod = int(self._p_mtime)",
            "                else:",
            "                    last_mod = 0",
            "                if last_mod > 0 and last_mod <= mod_since:",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setStatus(304)",
            "                    return True",
            "",
            "    def _range_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP Range header handling: return True if we've served a range",
            "        # chunk out of our data.",
            "        range = REQUEST.get_header('Range', None)",
            "        request_range = REQUEST.get_header('Request-Range', None)",
            "        if request_range is not None:",
            "            # Netscape 2 through 4 and MSIE 3 implement a draft version",
            "            # Later on, we need to serve a different mime-type as well.",
            "            range = request_range",
            "        if_range = REQUEST.get_header('If-Range', None)",
            "        if range is not None:",
            "            ranges = HTTPRangeSupport.parseRange(range)",
            "",
            "            if if_range is not None:",
            "                # Only send ranges if the data isn't modified, otherwise send",
            "                # the whole object. Support both ETags and Last-Modified dates!",
            "                if len(if_range) > 1 and if_range[:2] == 'ts':",
            "                    # ETag:",
            "                    if if_range != self.http__etag():",
            "                        # Modified, so send a normal response. We delete",
            "                        # the ranges, which causes us to skip to the 200",
            "                        # response.",
            "                        ranges = None",
            "                else:",
            "                    # Date",
            "                    date = if_range.split(';')[0]",
            "                    try:",
            "                        mod_since = int(DateTime(date).timeTime())",
            "                    except Exception:",
            "                        mod_since = None",
            "                    if mod_since is not None:",
            "                        if self._p_mtime:",
            "                            last_mod = int(self._p_mtime)",
            "                        else:",
            "                            last_mod = 0",
            "                        if last_mod > mod_since:",
            "                            # Modified, so send a normal response. We delete",
            "                            # the ranges, which causes us to skip to the 200",
            "                            # response.",
            "                            ranges = None",
            "",
            "            if ranges:",
            "                # Search for satisfiable ranges.",
            "                satisfiable = 0",
            "                for start, end in ranges:",
            "                    if start < self.size:",
            "                        satisfiable = 1",
            "                        break",
            "",
            "                if not satisfiable:",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range', 'bytes */%d' % self.size",
            "                    )",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', self.size)",
            "                    RESPONSE.setStatus(416)",
            "                    return True",
            "",
            "                ranges = HTTPRangeSupport.expandRanges(ranges, self.size)",
            "",
            "                if len(ranges) == 1:",
            "                    # Easy case, set extra header and return partial set.",
            "                    start, end = ranges[0]",
            "                    size = end - start",
            "",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range',",
            "                        'bytes %d-%d/%d' % (start, end - 1, self.size)",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    if isinstance(data, bytes):",
            "                        RESPONSE.write(data[start:end])",
            "                        return True",
            "",
            "                    # Linked Pdata objects. Urgh.",
            "                    pos = 0",
            "                    while data is not None:",
            "                        length = len(data.data)",
            "                        pos = pos + length",
            "                        if pos > start:",
            "                            # We are within the range",
            "                            lstart = length - (pos - start)",
            "",
            "                            if lstart < 0:",
            "                                lstart = 0",
            "",
            "                            # find the endpoint",
            "                            if end <= pos:",
            "                                lend = length - (pos - end)",
            "",
            "                                # Send and end transmission",
            "                                RESPONSE.write(data[lstart:lend])",
            "                                break",
            "",
            "                            # Not yet at the end, transmit what we have.",
            "                            RESPONSE.write(data[lstart:])",
            "",
            "                        data = data.next",
            "",
            "                    return True",
            "",
            "                else:",
            "                    boundary = _make_boundary()",
            "",
            "                    # Calculate the content length",
            "                    size = (8 + len(boundary)  # End marker length",
            "                            + len(ranges) * (  # Constant lenght per set",
            "                                49 + len(boundary)",
            "                                + len(self.content_type)",
            "                                + len('%d' % self.size)))",
            "                    for start, end in ranges:",
            "                        # Variable length per set",
            "                        size = (size + len('%d%d' % (start, end - 1))",
            "                                + end - start)",
            "",
            "                    # Some clients implement an earlier draft of the spec, they",
            "                    # will only accept x-byteranges.",
            "                    draftprefix = (request_range is not None) and 'x-' or ''",
            "",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader(",
            "                        'Content-Type',",
            "                        f'multipart/{draftprefix}byteranges;'",
            "                        f' boundary={boundary}'",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    # The Pdata map allows us to jump into the Pdata chain",
            "                    # arbitrarily during out-of-order range searching.",
            "                    pdata_map = {}",
            "                    pdata_map[0] = data",
            "",
            "                    for start, end in ranges:",
            "                        RESPONSE.write(",
            "                            b'\\r\\n--'",
            "                            + boundary.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Type: '",
            "                            + self.content_type.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Range: bytes '",
            "                            + str(start).encode('ascii')",
            "                            + b'-'",
            "                            + str(end - 1).encode('ascii')",
            "                            + b'/'",
            "                            + str(self.size).encode('ascii')",
            "                            + b'\\r\\n\\r\\n'",
            "                        )",
            "",
            "                        if isinstance(data, bytes):",
            "                            RESPONSE.write(data[start:end])",
            "",
            "                        else:",
            "                            # Yippee. Linked Pdata objects. The following",
            "                            # calculations allow us to fast-forward through the",
            "                            # Pdata chain without a lot of dereferencing if we",
            "                            # did the work already.",
            "                            first_size = len(pdata_map[0].data)",
            "                            if start < first_size:",
            "                                closest_pos = 0",
            "                            else:",
            "                                closest_pos = (",
            "                                    ((start - first_size) >> 16 << 16)",
            "                                    + first_size",
            "                                )",
            "                            pos = min(closest_pos, max(pdata_map.keys()))",
            "                            data = pdata_map[pos]",
            "",
            "                            while data is not None:",
            "                                length = len(data.data)",
            "                                pos = pos + length",
            "                                if pos > start:",
            "                                    # We are within the range",
            "                                    lstart = length - (pos - start)",
            "",
            "                                    if lstart < 0:",
            "                                        lstart = 0",
            "",
            "                                    # find the endpoint",
            "                                    if end <= pos:",
            "                                        lend = length - (pos - end)",
            "",
            "                                        # Send and loop to next range",
            "                                        RESPONSE.write(data[lstart:lend])",
            "                                        break",
            "",
            "                                    # Not yet at the end,",
            "                                    # transmit what we have.",
            "                                    RESPONSE.write(data[lstart:])",
            "",
            "                                data = data.next",
            "                                # Store a reference to a Pdata chain link",
            "                                # so we don't have to deref during",
            "                                # this request again.",
            "                                pdata_map[pos] = data",
            "",
            "                    # Do not keep the link references around.",
            "                    del pdata_map",
            "",
            "                    RESPONSE.write(",
            "                        b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')",
            "                    return True",
            "",
            "    def _should_force_download(self):",
            "        # If this returns True, the caller should set a",
            "        # Content-Disposition header with filename.",
            "        mimetype = self.content_type",
            "        if not mimetype:",
            "            return False",
            "        if self.use_denylist:",
            "            # We explicitly deny a few mimetypes, and allow the rest.",
            "            return mimetype in self.disallowed_inline_mimetypes",
            "        # Use the allowlist.",
            "        # We only explicitly allow a few mimetypes, and deny the rest.",
            "        return mimetype not in self.allowed_inline_mimetypes",
            "",
            "    @security.protected(View)",
            "    def index_html(self, REQUEST, RESPONSE):",
            "        \"\"\"",
            "        The default view of the contents of a File or Image.",
            "",
            "        Returns the contents of the file or image.  Also, sets the",
            "        Content-Type HTTP header to the objects content type.",
            "        \"\"\"",
            "",
            "        if self._if_modified_since_request_handler(REQUEST, RESPONSE):",
            "            # we were able to handle this by returning a 304",
            "            # unfortunately, because the HTTP cache manager uses the cache",
            "            # API, and because 304 responses are required to carry the Expires",
            "            # header for HTTP/1.1, we need to call ZCacheable_set here.",
            "            # This is nonsensical for caches other than the HTTP cache manager",
            "            # unfortunately.",
            "            self.ZCacheable_set(None)",
            "            return b''",
            "",
            "        if self.precondition and hasattr(self, str(self.precondition)):",
            "            # Grab whatever precondition was defined and then",
            "            # execute it.  The precondition will raise an exception",
            "            # if something violates its terms.",
            "            c = getattr(self, str(self.precondition))",
            "            if hasattr(c, 'isDocTemp') and c.isDocTemp:",
            "                c(REQUEST['PARENTS'][1], REQUEST)",
            "            else:",
            "                c()",
            "",
            "        if self._range_request_handler(REQUEST, RESPONSE):",
            "            # we served a chunk of content in response to a range request.",
            "            return b''",
            "",
            "        RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))",
            "        RESPONSE.setHeader('Content-Type', self.content_type)",
            "        RESPONSE.setHeader('Content-Length', self.size)",
            "        RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "",
            "        if self._should_force_download():",
            "            # We need a filename, even a dummy one if needed.",
            "            filename = self.getId()",
            "            if \".\" not in filename:",
            "                # This either returns None or \".some_extension\"",
            "                ext = guess_extension(self.content_type, strict=False)",
            "                if not ext:",
            "                    # image/svg+xml -> svg",
            "                    ext = \".\" + self.content_type.split(\"/\")[-1].split(\"+\")[0]",
            "                filename += f\"{ext}\"",
            "            filename = quote(filename.encode(\"utf8\"))",
            "            RESPONSE.setHeader(",
            "                \"Content-Disposition\",",
            "                f\"attachment; filename*=UTF-8''{filename}\",",
            "            )",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager and HTTP",
            "                # Accelerated Cache Manager but we will get",
            "                # something implementing the IStreamIterator interface",
            "                # from a \"FileCacheManager\"",
            "                return result",
            "",
            "        self.ZCacheable_set(None)",
            "",
            "        data = self.data",
            "        if isinstance(data, bytes):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "    @security.protected(View)",
            "    def view_image_or_file(self, URL1):",
            "        \"\"\"The default view of the contents of the File or Image.\"\"\"",
            "        raise Redirect(URL1)",
            "",
            "    @security.protected(View)",
            "    def PrincipiaSearchSource(self):",
            "        \"\"\"Allow file objects to be searched.\"\"\"",
            "        if self.content_type.startswith('text/'):",
            "            return bytes(self.data)",
            "        return b''",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, str):",
            "            raise TypeError('Data can only be bytes or file-like. '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "        if size is None:",
            "            size = len(data)",
            "        self.size = size",
            "        self.data = data",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def _get_encoding(self):",
            "        \"\"\"Get the canonical encoding for ZMI.\"\"\"",
            "        return ZPublisher.HTTPRequest.default_encoding",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_edit(",
            "        self,",
            "        title,",
            "        content_type,",
            "        precondition='',",
            "        filedata=None,",
            "        REQUEST=None",
            "    ):",
            "        \"\"\"",
            "        Changes the title and content type attributes of the File or Image.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        self.title = str(title)",
            "        self.content_type = str(content_type)",
            "        if precondition:",
            "            self.precondition = str(precondition)",
            "        elif self.precondition:",
            "            del self.precondition",
            "        if filedata is not None:",
            "            if isinstance(filedata, str):",
            "                filedata = filedata.encode(self._get_encoding())",
            "            self.update_data(filedata, content_type, len(filedata))",
            "        else:",
            "            self.ZCacheable_invalidate()",
            "",
            "        notify(ObjectModifiedEvent(self))",
            "",
            "        if REQUEST:",
            "            message = \"Saved changes.\"",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=message)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_upload(self, file='', REQUEST=None):",
            "        \"\"\"",
            "        Replaces the current contents of the File or Image object with file.",
            "",
            "        The file or images contents are replaced with the contents of 'file'.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        if file:",
            "            data, size = self._read_data(file)",
            "            content_type = self._get_content_type(file, data, self.__name__,",
            "                                                  'application/octet-stream')",
            "            self.update_data(data, content_type, size)",
            "            notify(ObjectModifiedEvent(self))",
            "            msg = 'Saved changes.'",
            "        else:",
            "            msg = 'Please select a file to upload.'",
            "",
            "        if REQUEST:",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=msg)",
            "",
            "    def _get_content_type(self, file, body, id, content_type=None):",
            "        headers = getattr(file, 'headers', None)",
            "        if headers and 'content-type' in headers:",
            "            content_type = headers['content-type']",
            "        else:",
            "            if not isinstance(body, bytes):",
            "                body = body.data",
            "            content_type, enc = guess_content_type(",
            "                getattr(file, 'filename', id), body, content_type)",
            "        return content_type",
            "",
            "    def _read_data(self, file):",
            "        import transaction",
            "",
            "        n = 1 << 16",
            "",
            "        if isinstance(file, str):",
            "            raise ValueError(\"Must be bytes\")",
            "",
            "        if isinstance(file, bytes):",
            "            size = len(file)",
            "            if size < n:",
            "                return (file, size)",
            "            # Big string: cut it into smaller chunks",
            "            file = BytesIO(file)",
            "",
            "        if isinstance(file, FileUpload) and not file:",
            "            raise ValueError('File not specified')",
            "",
            "        if hasattr(file, '__class__') and file.__class__ is Pdata:",
            "            size = len(file)",
            "            return (file, size)",
            "",
            "        seek = file.seek",
            "        read = file.read",
            "",
            "        seek(0, 2)",
            "        size = end = file.tell()",
            "",
            "        if size <= 2 * n:",
            "            seek(0)",
            "            if size < n:",
            "                return read(size), size",
            "            return Pdata(read(size)), size",
            "",
            "        # Make sure we have an _p_jar, even if we are a new object, by",
            "        # doing a sub-transaction commit.",
            "        transaction.savepoint(optimistic=True)",
            "",
            "        if self._p_jar is None:",
            "            # Ugh",
            "            seek(0)",
            "            return Pdata(read(size)), size",
            "",
            "        # Now we're going to build a linked list from back",
            "        # to front to minimize the number of database updates",
            "        # and to allow us to get things out of memory as soon as",
            "        # possible.",
            "        _next = None",
            "        while end > 0:",
            "            pos = end - n",
            "            if pos < n:",
            "                pos = 0  # we always want at least n bytes",
            "            seek(pos)",
            "",
            "            # Create the object and assign it a next pointer",
            "            # in the same transaction, so that there is only",
            "            # a single database update for it.",
            "            data = Pdata(read(end - pos))",
            "            self._p_jar.add(data)",
            "            data.next = _next",
            "",
            "            # Save the object so that we can release its memory.",
            "            transaction.savepoint(optimistic=True)",
            "            data._p_deactivate()",
            "            # The object should be assigned an oid and be a ghost.",
            "            assert data._p_oid is not None",
            "            assert data._p_state == -1",
            "",
            "            _next = data",
            "            end = pos",
            "",
            "        return (_next, size)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def PUT(self, REQUEST, RESPONSE):",
            "        \"\"\"Handle HTTP PUT requests\"\"\"",
            "        self.dav__init(REQUEST, RESPONSE)",
            "        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)",
            "        type = REQUEST.get_header('content-type', None)",
            "",
            "        file = REQUEST['BODYFILE']",
            "",
            "        data, size = self._read_data(file)",
            "        if isinstance(data, str):",
            "            data = data.encode('UTF-8')",
            "        content_type = self._get_content_type(file, data, self.__name__,",
            "                                              type or self.content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "        RESPONSE.setStatus(204)",
            "        return RESPONSE",
            "",
            "    @security.protected(View)",
            "    def get_size(self):",
            "        # Get the size of a file or image.",
            "        # Returns the size of the file or image.",
            "        size = self.size",
            "        if size is None:",
            "            size = len(self.data)",
            "        return size",
            "",
            "    # deprecated; use get_size!",
            "    getSize = get_size",
            "",
            "    @security.protected(View)",
            "    def getContentType(self):",
            "        # Get the content type of a file or image.",
            "        # Returns the content type (MIME type) of a file or image.",
            "        return self.content_type",
            "",
            "    def __bytes__(self):",
            "        return bytes(self.data)",
            "",
            "    def __str__(self):",
            "        \"\"\"In most cases, this is probably not what you want. Use ``bytes``.\"\"\"",
            "        if isinstance(self.data, Pdata):",
            "            return bytes(self.data).decode(self._get_encoding())",
            "        else:",
            "            return self.data.decode(self._get_encoding())",
            "",
            "    def __bool__(self):",
            "        return True",
            "",
            "    __nonzero__ = __bool__",
            "",
            "    def __len__(self):",
            "        data = bytes(self.data)",
            "        return len(data)",
            "",
            "    @security.protected(webdav_access)",
            "    def manage_DAVget(self):",
            "        \"\"\"Return body for WebDAV.\"\"\"",
            "        RESPONSE = self.REQUEST.RESPONSE",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager but we will",
            "                # get something implementing the IStreamIterator interface",
            "                # from FileCacheManager.",
            "                # the content-length is required here by HTTPResponse.",
            "                RESPONSE.setHeader('Content-Length', self.size)",
            "                return result",
            "",
            "        data = self.data",
            "        if isinstance(data, bytes):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "",
            "InitializeClass(File)",
            "",
            "",
            "manage_addImageForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='Image',",
            "    kind='image',",
            ")",
            "",
            "",
            "def manage_addImage(",
            "    self,",
            "    id,",
            "    file,",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"",
            "    Add a new Image object.",
            "",
            "    Creates a new Image object 'id' with the contents of 'file'.",
            "    \"\"\"",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the image without data:",
            "    self._setObject(id, Image(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        try:",
            "            url = self.DestinationURL()",
            "        except Exception:",
            "            url = REQUEST['URL1']",
            "        REQUEST.RESPONSE.redirect('%s/manage_main' % url)",
            "    return id",
            "",
            "",
            "def getImageInfo(data):",
            "    data = bytes(data)",
            "    size = len(data)",
            "    height = -1",
            "    width = -1",
            "    content_type = ''",
            "",
            "    # handle GIFs",
            "    if (size >= 10) and data[:6] in (b'GIF87a', b'GIF89a'):",
            "        # Check to see if content_type is correct",
            "        content_type = 'image/gif'",
            "        w, h = struct.unpack(\"<HH\", data[6:10])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)",
            "    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'",
            "    # and finally the 4-byte width, height",
            "    elif (size >= 24",
            "          and data[:8] == b'\\211PNG\\r\\n\\032\\n'",
            "          and data[12:16] == b'IHDR'):",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[16:24])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # Maybe this is for an older PNG version.",
            "    elif (size >= 16) and (data[:8] == b'\\211PNG\\r\\n\\032\\n'):",
            "        # Check to see if we have the right content type",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[8:16])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # handle JPEGs",
            "    elif (size >= 2) and (data[:2] == b'\\377\\330'):",
            "        content_type = 'image/jpeg'",
            "        jpeg = BytesIO(data)",
            "        jpeg.read(2)",
            "        b = jpeg.read(1)",
            "        try:",
            "            while (b and ord(b) != 0xDA):",
            "                while (ord(b) != 0xFF):",
            "                    b = jpeg.read(1)",
            "                while (ord(b) == 0xFF):",
            "                    b = jpeg.read(1)",
            "                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):",
            "                    jpeg.read(3)",
            "                    h, w = struct.unpack(\">HH\", jpeg.read(4))",
            "                    break",
            "                else:",
            "                    jpeg.read(int(struct.unpack(\">H\", jpeg.read(2))[0]) - 2)",
            "                b = jpeg.read(1)",
            "            width = int(w)",
            "            height = int(h)",
            "        except Exception:",
            "            pass",
            "",
            "    # handle SVGs",
            "    elif (size >= 16) and ((b'<?xml' in data[:16]) or (b'<svg' in data[:16])):",
            "        try:",
            "            xmldoc = minidom.parseString(data)",
            "        except Exception:",
            "            return content_type, width, height",
            "        for svg in xmldoc.getElementsByTagName('svg'):",
            "            w = width",
            "            h = height",
            "            content_type = 'image/svg+xml'",
            "            if 'height' in svg.attributes and 'width' in svg.attributes:",
            "                w = svg.attributes['width'].value",
            "                h = svg.attributes['height'].value",
            "                try:",
            "                    w = int(float(w))",
            "                    h = int(float(h))",
            "                except Exception:",
            "                    if str(w).endswith('px'):",
            "                        w = int(float(w[:-2]))",
            "                        h = int(float(h[:-2]))",
            "                    elif str(w).endswith('mm'):",
            "                        w = int(float(w[:-2]) * 3.7795)",
            "                        h = int(float(h[:-2]) * 3.7795)",
            "                    elif str(w).endswith('cm'):",
            "                        w = int(float(w[:-2]) * 37.795)",
            "                        h = int(float(h[:-2]) * 37.795)",
            "                break",
            "            elif 'viewBox' in svg.attributes:",
            "                viewBox = svg.attributes['viewBox'].value",
            "                viewBox = [int(float(x)) for x in viewBox.split(' ')]",
            "                w = viewBox[2] - viewBox[0]",
            "                h = viewBox[3] - viewBox[1]",
            "            width = int(w)",
            "            height = int(h)",
            "",
            "    return content_type, width, height",
            "",
            "",
            "class Image(File):",
            "    \"\"\"Image objects can be GIF, PNG or JPEG and have the same methods",
            "    as File objects.  Images also have a string representation that",
            "    renders an HTML 'IMG' tag.",
            "    \"\"\"",
            "",
            "    meta_type = 'Image'",
            "    zmi_icon = 'far fa-file-image'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    alt = ''",
            "    height = ''",
            "    width = ''",
            "",
            "    # FIXME: Redundant, already in base class",
            "    security.declareProtected(change_images_and_files, 'manage_edit')  # NOQA: D001,E501",
            "    security.declareProtected(change_images_and_files, 'manage_upload')  # NOQA: D001,E501",
            "    security.declareProtected(View, 'index_html')  # NOQA: D001",
            "    security.declareProtected(View, 'get_size')  # NOQA: D001",
            "    security.declareProtected(View, 'getContentType')  # NOQA: D001",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'alt', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string', 'mode': 'w'},",
            "        {'id': 'height', 'type': 'string'},",
            "        {'id': 'width', 'type': 'string'},",
            "    )",
            "",
            "    manage_options = (",
            "        ({'label': 'Edit', 'action': 'manage_main'},",
            "         {'label': 'View', 'action': 'view_image_or_file'})",
            "        + PropertyManager.manage_options",
            "        + RoleManager.manage_options",
            "        + Item_w__name__.manage_options",
            "        + Cacheable.manage_options",
            "    )",
            "",
            "    manage_editForm = DTMLFile(",
            "        'dtml/imageEdit',",
            "        globals(),",
            "        Kind='Image',",
            "        kind='image',",
            "    )",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(View, 'view_image_or_file')  # NOQA: D001",
            "    view_image_or_file = DTMLFile('dtml/imageView', globals())",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, str):",
            "            raise TypeError('Data can only be bytes or file-like.  '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if size is None:",
            "            size = len(data)",
            "",
            "        self.size = size",
            "        self.data = data",
            "",
            "        ct, width, height = getImageInfo(data)",
            "        if ct:",
            "            content_type = ct",
            "        if width >= 0 and height >= 0:",
            "            self.width = width",
            "            self.height = height",
            "",
            "        # Now we should have the correct content type, or still None",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def __bytes__(self):",
            "        return self.tag().encode('utf-8')",
            "",
            "    def __str__(self):",
            "        return self.tag()",
            "",
            "    @security.protected(View)",
            "    def tag(",
            "        self,",
            "        height=None,",
            "        width=None,",
            "        alt=None,",
            "        scale=0,",
            "        xscale=0,",
            "        yscale=0,",
            "        css_class=None,",
            "        title=None,",
            "        **args",
            "    ):",
            "        \"\"\"Generate an HTML IMG tag for this image, with customization.",
            "",
            "        Arguments to self.tag() can be any valid attributes of an IMG tag.",
            "        'src' will always be an absolute pathname, to prevent redundant",
            "        downloading of images. Defaults are applied intelligently for",
            "        'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',",
            "        and 'yscale' keyword arguments will be used to automatically adjust",
            "        the output height and width values of the image tag.",
            "        #",
            "        Since 'class' is a Python reserved word, it cannot be passed in",
            "        directly in keyword arguments which is a problem if you are",
            "        trying to use 'tag()' to include a CSS class. The tag() method",
            "        will accept a 'css_class' argument that will be converted to",
            "        'class' in the output tag to work around this.",
            "        \"\"\"",
            "        if height is None:",
            "            height = self.height",
            "        if width is None:",
            "            width = self.width",
            "",
            "        # Auto-scaling support",
            "        xdelta = xscale or scale",
            "        ydelta = yscale or scale",
            "",
            "        if xdelta and width:",
            "            width = str(int(round(int(width) * xdelta)))",
            "        if ydelta and height:",
            "            height = str(int(round(int(height) * ydelta)))",
            "",
            "        result = '<img src=\"%s\"' % (self.absolute_url())",
            "",
            "        if alt is None:",
            "            alt = getattr(self, 'alt', '')",
            "        result = f'{result} alt=\"{html.escape(alt, True)}\"'",
            "",
            "        if title is None:",
            "            title = getattr(self, 'title', '')",
            "        result = f'{result} title=\"{html.escape(title, True)}\"'",
            "",
            "        if height:",
            "            result = f'{result} height=\"{height}\"'",
            "",
            "        if width:",
            "            result = f'{result} width=\"{width}\"'",
            "",
            "        if css_class is not None:",
            "            result = f'{result} class=\"{css_class}\"'",
            "",
            "        for key in list(args.keys()):",
            "            value = args.get(key)",
            "            if value:",
            "                result = f'{result} {key}=\"{value}\"'",
            "",
            "        return '%s />' % result",
            "",
            "",
            "InitializeClass(Image)",
            "",
            "",
            "def cookId(id, title, file):",
            "    if not id and hasattr(file, 'filename'):",
            "        filename = file.filename",
            "        title = title or filename",
            "        id = filename[max(filename.rfind('/'),",
            "                          filename.rfind('\\\\'),",
            "                          filename.rfind(':'),",
            "                          ) + 1:]",
            "    return id, title",
            "",
            "",
            "class Pdata(Persistent, Implicit):",
            "    # Wrapper for possibly large data",
            "",
            "    next = None",
            "",
            "    def __init__(self, data):",
            "        self.data = data",
            "",
            "    def __getitem__(self, key):",
            "        return self.data[key]",
            "",
            "    def __len__(self):",
            "        data = bytes(self)",
            "        return len(data)",
            "",
            "    def __bytes__(self):",
            "        _next = self.next",
            "        if _next is None:",
            "            return self.data",
            "",
            "        r = [self.data]",
            "        while _next is not None:",
            "            self = _next",
            "            r.append(self.data)",
            "            _next = self.next",
            "",
            "        return b''.join(r)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.OFS.Image.File.self",
            "src.OFS.Image.File.index_html",
            "src.OFS.Image",
            "pypdf.generic._data_structures",
            "src.OFS.Image.File.manage_options",
            "src.OFS.Image.File._properties"
        ]
    },
    "src/OFS/tests/testFileAndImage.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "         response = request.RESPONSE"
            },
            "1": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         result = self.file.index_html(request, response)"
            },
            "2": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "         self.assertEqual(result, self.data)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        self.assertIsNone(response.getHeader(\"Content-Disposition\"))"
            },
            "4": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 377,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "     def test_interfaces(self):"
            },
            "6": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "         from OFS.Image import Image"
            },
            "7": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "                          ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')"
            },
            "8": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 389,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 390,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+class SVGTests(ImageTests):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+    content_type = 'image/svg+xml'"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+    def testViewImageOrFile(self):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+        result = self.file.index_html(request, response)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+        self.assertEqual("
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+            response.getHeader(\"Content-Disposition\"),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+            \"attachment; filename*=UTF-8''file.svg\","
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+        )"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+    def testViewImageOrFileNonAscii(self):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+        try:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+            factory = getattr(self.app, self.factory)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+            factory('h\u00e4llo',"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+                    file=self.data, content_type=self.content_type)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+            transaction.commit()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        except Exception:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            transaction.abort()"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+            self.connection.close()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+            raise"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+        transaction.begin()"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+        image = getattr(self.app, 'h\u00e4llo')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        result = image.index_html(request, response)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+        self.assertEqual("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+            response.getHeader(\"Content-Disposition\"),"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+        )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+    def testViewImageOrFile_with_denylist(self):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+        self.file.use_denylist = True"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+        result = self.file.index_html(request, response)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+        self.assertEqual("
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 432,
                "PatchRowcode": "+            response.getHeader(\"Content-Disposition\"),"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 433,
                "PatchRowcode": "+            \"attachment; filename*=UTF-8''file.svg\","
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 434,
                "PatchRowcode": "+        )"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 435,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+    def testViewImageOrFile_with_empty_denylist(self):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+        self.file.use_denylist = True"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+        self.file.disallowed_inline_mimetypes = []"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        result = self.file.index_html(request, response)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+        self.assertIsNone(response.getHeader(\"Content-Disposition\"))"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 446,
                "PatchRowcode": " class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):"
            },
            "66": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "     \"\"\"Browser testing ..Image.File\"\"\""
            },
            "67": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 448,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import os",
            "import sys",
            "import time",
            "import unittest",
            "from io import BytesIO",
            "",
            "import OFS.Image",
            "import Testing.testbrowser",
            "import Testing.ZopeTestCase",
            "import transaction",
            "import Zope2",
            "from Acquisition import aq_base",
            "from OFS.Application import Application",
            "from OFS.Cache import ZCM_MANAGERS",
            "from OFS.Image import Pdata",
            "from OFS.SimpleItem import SimpleItem",
            "from Testing.makerequest import makerequest",
            "from zExceptions import Redirect",
            "from zope.component import adapter",
            "from zope.datetime import rfc1123_date",
            "from zope.lifecycleevent.interfaces import IObjectCreatedEvent",
            "from zope.lifecycleevent.interfaces import IObjectModifiedEvent",
            "from ZPublisher.HTTPRequest import HTTPRequest",
            "from ZPublisher.HTTPResponse import HTTPResponse",
            "",
            "",
            "here = os.path.dirname(os.path.abspath(__file__))",
            "filedata = os.path.join(here, 'test.gif')",
            "",
            "Zope2.startup_wsgi()",
            "",
            "",
            "def makeConnection():",
            "    import ZODB",
            "    from ZODB.DemoStorage import DemoStorage",
            "",
            "    s = DemoStorage()",
            "    return ZODB.DB(s).open()",
            "",
            "",
            "def aputrequest(file, content_type):",
            "    resp = HTTPResponse(stdout=sys.stdout)",
            "    environ = {}",
            "    environ['SERVER_NAME'] = 'foo'",
            "    environ['SERVER_PORT'] = '80'",
            "    environ['REQUEST_METHOD'] = 'PUT'",
            "    environ['CONTENT_TYPE'] = content_type",
            "    req = HTTPRequest(stdin=file, environ=environ, response=resp)",
            "    return req",
            "",
            "",
            "class DummyCache:",
            "",
            "    def __init__(self):",
            "        self.clear()",
            "",
            "    def ZCache_set(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.set = (ob, data)",
            "",
            "    def ZCache_get(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.get = ob",
            "        if self.si:",
            "            return self.si",
            "",
            "    def ZCache_invalidate(self, ob):",
            "        self.invalidated = ob",
            "",
            "    def clear(self):",
            "        self.set = None",
            "        self.get = None",
            "        self.invalidated = None",
            "        self.si = None",
            "",
            "    def setStreamIterator(self, si):",
            "        self.si = si",
            "",
            "",
            "ADummyCache = DummyCache()",
            "",
            "",
            "class DummyCacheManager(SimpleItem):",
            "    def ZCacheManager_getCache(self):",
            "        return ADummyCache",
            "",
            "",
            "class EventCatcher:",
            "",
            "    def __init__(self):",
            "        self.created = []",
            "        self.modified = []",
            "        self.setUp()",
            "",
            "    def setUp(self):",
            "        from zope.component import provideHandler",
            "        provideHandler(self.handleCreated)",
            "        provideHandler(self.handleModified)",
            "",
            "    def tearDown(self):",
            "        from zope.component import getSiteManager",
            "        getSiteManager().unregisterHandler(self.handleCreated)",
            "        getSiteManager().unregisterHandler(self.handleModified)",
            "",
            "    def reset(self):",
            "        self.created = []",
            "        self.modified = []",
            "",
            "    @adapter(IObjectCreatedEvent)",
            "    def handleCreated(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.created.append(event)",
            "",
            "    @adapter(IObjectModifiedEvent)",
            "    def handleModified(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.modified.append(event)",
            "",
            "",
            "class FileTests(unittest.TestCase):",
            "    content_type = 'application/octet-stream'",
            "    factory = 'manage_addFile'",
            "",
            "    def setUp(self):",
            "        with open(filedata, 'rb') as fd:",
            "            self.data = fd.read()",
            "        self.connection = makeConnection()",
            "        self.eventCatcher = EventCatcher()",
            "        try:",
            "            r = self.connection.root()",
            "            a = Application()",
            "            r['Application'] = a",
            "            self.root = a",
            "            responseOut = self.responseOut = BytesIO()",
            "            self.app = makerequest(self.root, stdout=responseOut)",
            "            self.app.dcm = DummyCacheManager()",
            "            factory = getattr(self.app, self.factory)",
            "            factory('file',",
            "                    file=self.data, content_type=self.content_type)",
            "            self.app.file.ZCacheable_setManagerId('dcm')",
            "            self.app.file.ZCacheable_setEnabled(enabled=1)",
            "            setattr(self.app, ZCM_MANAGERS, ('dcm',))",
            "            # Hack, we need a _p_mtime for the file, so we make sure that it",
            "            # has one.",
            "            transaction.commit()",
            "        except Exception:",
            "            transaction.abort()",
            "            self.connection.close()",
            "            raise",
            "        transaction.begin()",
            "        self.file = getattr(self.app, 'file')",
            "",
            "        # Since we do the create here, let's test the events here too",
            "        self.assertEqual(1, len(self.eventCatcher.created))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.eventCatcher.reset()",
            "",
            "    def tearDown(self):",
            "        del self.file",
            "        transaction.abort()",
            "        self.connection.close()",
            "        del self.app",
            "        del self.responseOut",
            "        del self.root",
            "        del self.connection",
            "        ADummyCache.clear()",
            "        self.eventCatcher.tearDown()",
            "",
            "    def testViewImageOrFile(self):",
            "        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(b'foo')",
            "        self.assertEqual(self.file.size, 3)",
            "        self.assertEqual(self.file.data, b'foo')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testReadData(self):",
            "        s = b'a' * (2 << 16)",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertIsInstance(data, Pdata)",
            "        self.assertEqual(bytes(data), s)",
            "        self.assertEqual(len(s), len(bytes(data)))",
            "        self.assertEqual(len(s), size)",
            "",
            "    def testBigPdata(self):",
            "        # Test that a big enough string is split into several Pdata",
            "        # From a file",
            "        s = b'a' * (1 << 16) * 3",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertNotEqual(data.next, None)",
            "        # From a string",
            "        data, size = self.file._read_data(s)",
            "        self.assertNotEqual(data.next, None)",
            "",
            "    def testManageEditWithFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageEditWithoutFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUpload(self):",
            "        f = BytesIO(b'jammyjohnson')",
            "        self.file.manage_upload(f)",
            "        self.assertEqual(self.file.data, b'jammyjohnson')",
            "        self.assertEqual(self.file.content_type, 'application/octet-stream')",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUploadWithoutFileData(self):",
            "        self.file.manage_upload()",
            "        self.assertEqual(0, len(self.eventCatcher.modified))",
            "",
            "    def testIfModSince(self):",
            "        now = time.time()",
            "        e = {'SERVER_NAME': 'foo',",
            "             'SERVER_PORT': '80',",
            "             'REQUEST_METHOD': 'GET'}",
            "",
            "        # not modified since",
            "        t_notmod = rfc1123_date(now)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 304)",
            "        self.assertEqual(data, b'')",
            "",
            "        # modified since",
            "        t_mod = rfc1123_date(now - 100)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_mod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 200)",
            "        self.assertEqual(data, bytes(self.file.data))",
            "",
            "    def testPUT(self):",
            "        s = b'# some python\\n'",
            "",
            "        # with content type",
            "        data = BytesIO(s)",
            "        req = aputrequest(data, 'text/x-python')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "        # without content type",
            "        data.seek(0)",
            "        req = aputrequest(data, '')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "    def testIndexHtmlWithPdata(self):",
            "        self.file.manage_upload(b'a' * (2 << 16))  # 128K",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testIndexHtmlWithString(self):",
            "        self.file.manage_upload(b'a' * 100)  # 100 bytes",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testPrincipiaSearchSource_not_text(self):",
            "        data = ''.join([chr(x) for x in range(256)])",
            "        data = data.encode('utf-8')",
            "        self.file.manage_edit('foobar', 'application/octet-stream',",
            "                              filedata=data)",
            "        self.assertEqual(self.file.PrincipiaSearchSource(), b'')",
            "",
            "    def testPrincipiaSearchSource_text(self):",
            "        self.file.manage_edit('foobar', 'text/plain',",
            "                              filedata=b'Now is the time for all good men to '",
            "                                       b'come to the aid of the Party.')",
            "        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())",
            "",
            "    def test_manage_DAVget_binary(self):",
            "        self.assertEqual(self.file.manage_DAVget(), self.data)",
            "",
            "    def test_manage_DAVget_text(self):",
            "        text = (b'Now is the time for all good men to '",
            "                b'come to the aid of the Party.')",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=text)",
            "        self.assertEqual(self.file.manage_DAVget(), text)",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import File",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface",
            "",
            "        verifyClass(HTTPRangeInterface, File)",
            "        verifyClass(IWriteLock, File)",
            "",
            "    def testUnicode(self):",
            "        val = 'some unicode string here'",
            "",
            "        self.assertRaises(TypeError, self.file.update_data,",
            "                          data=val, content_type='text/plain')",
            "",
            "    def test__str__returns_native_string(self):",
            "        small_data = b'small data'",
            "        self.file.manage_upload(file=small_data)",
            "        self.assertEqual(str(self.file), small_data.decode())",
            "",
            "        # Make sure Pdata contents are handled correctly",
            "        big_data = b'a' * (2 << 16)",
            "        self.file.manage_upload(file=big_data)",
            "        self.assertEqual(str(self.file), big_data.decode())",
            "",
            "",
            "class ImageTests(FileTests):",
            "    content_type = 'image/gif'",
            "    factory = 'manage_addImage'",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(self.data)",
            "        self.assertEqual(self.file.size, len(self.data))",
            "        self.assertEqual(self.file.data, self.data)",
            "        self.assertEqual(self.file.width, 16)",
            "        self.assertEqual(self.file.height, 16)",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testTag(self):",
            "        tag_fmt = ('<img src=\"http://nohost/file\" '",
            "                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))",
            "        self.file.manage_changeProperties(title='foo')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))",
            "        self.file.manage_changeProperties(alt='bar')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))",
            "",
            "    testStr = testTag",
            "",
            "    def test__str__returns_native_string(self):",
            "        small_data = b'small data'",
            "        self.file.manage_upload(file=small_data)",
            "        self.assertIsInstance(str(self.file), str)",
            "",
            "        # Make sure Pdata contents are handled correctly",
            "        big_data = b'a' * (2 << 16)",
            "        self.file.manage_upload(file=big_data)",
            "        self.assertIsInstance(str(self.file), str)",
            "",
            "    def testViewImageOrFile(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import Image",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "",
            "        verifyClass(IWriteLock, Image)",
            "",
            "    def test_text_representation_is_tag(self):",
            "        self.assertEqual(str(self.file),",
            "                         '<img src=\"http://nohost/file\"'",
            "                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')",
            "",
            "",
            "class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):",
            "    \"\"\"Browser testing ..Image.File\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        uf = self.app.acl_users",
            "        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])",
            "        self.app.manage_addFile('file')",
            "",
            "        transaction.commit()",
            "        self.browser = Testing.testbrowser.Browser()",
            "        self.browser.login('manager', 'manager_pass')",
            "",
            "    def test_Image__manage_main__1(self):",
            "        \"\"\"It shows the content of text files as text.\"\"\"",
            "        self.app.file.update_data('h\u00e4llo'.encode())",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'h\u00e4llo')",
            "",
            "    def test_Image__manage_main__3(self):",
            "        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"",
            "        self.app.file.update_data('h\u00e4llo'.encode('latin-1'))",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.assertIn(",
            "            \"The file could not be decoded with 'utf-8'.\",",
            "            self.browser.contents)",
            "",
            "    def test_Image__manage_upload__1(self):",
            "        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.browser.getControl(name='file').add_file(",
            "            b'test text file', 'text/plain', 'TestFile.txt')",
            "        self.browser.getControl('Upload File').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        self.assertEqual(",
            "            self.browser.getControl('Content Type').value, 'text/plain')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'test text file')",
            "",
            "    def test_Image__manage_edit__1(self):",
            "        \"\"\"It it possible to change the file's content via browser.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text_1 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_1, '')",
            "        self.browser.getControl(name='filedata:text').value = 'h\u00e4llo'",
            "        self.browser.getControl('Save Changes').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        text_2 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_2, 'h\u00e4llo')"
        ],
        "afterPatchFile": [
            "import os",
            "import sys",
            "import time",
            "import unittest",
            "from io import BytesIO",
            "",
            "import OFS.Image",
            "import Testing.testbrowser",
            "import Testing.ZopeTestCase",
            "import transaction",
            "import Zope2",
            "from Acquisition import aq_base",
            "from OFS.Application import Application",
            "from OFS.Cache import ZCM_MANAGERS",
            "from OFS.Image import Pdata",
            "from OFS.SimpleItem import SimpleItem",
            "from Testing.makerequest import makerequest",
            "from zExceptions import Redirect",
            "from zope.component import adapter",
            "from zope.datetime import rfc1123_date",
            "from zope.lifecycleevent.interfaces import IObjectCreatedEvent",
            "from zope.lifecycleevent.interfaces import IObjectModifiedEvent",
            "from ZPublisher.HTTPRequest import HTTPRequest",
            "from ZPublisher.HTTPResponse import HTTPResponse",
            "",
            "",
            "here = os.path.dirname(os.path.abspath(__file__))",
            "filedata = os.path.join(here, 'test.gif')",
            "",
            "Zope2.startup_wsgi()",
            "",
            "",
            "def makeConnection():",
            "    import ZODB",
            "    from ZODB.DemoStorage import DemoStorage",
            "",
            "    s = DemoStorage()",
            "    return ZODB.DB(s).open()",
            "",
            "",
            "def aputrequest(file, content_type):",
            "    resp = HTTPResponse(stdout=sys.stdout)",
            "    environ = {}",
            "    environ['SERVER_NAME'] = 'foo'",
            "    environ['SERVER_PORT'] = '80'",
            "    environ['REQUEST_METHOD'] = 'PUT'",
            "    environ['CONTENT_TYPE'] = content_type",
            "    req = HTTPRequest(stdin=file, environ=environ, response=resp)",
            "    return req",
            "",
            "",
            "class DummyCache:",
            "",
            "    def __init__(self):",
            "        self.clear()",
            "",
            "    def ZCache_set(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.set = (ob, data)",
            "",
            "    def ZCache_get(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.get = ob",
            "        if self.si:",
            "            return self.si",
            "",
            "    def ZCache_invalidate(self, ob):",
            "        self.invalidated = ob",
            "",
            "    def clear(self):",
            "        self.set = None",
            "        self.get = None",
            "        self.invalidated = None",
            "        self.si = None",
            "",
            "    def setStreamIterator(self, si):",
            "        self.si = si",
            "",
            "",
            "ADummyCache = DummyCache()",
            "",
            "",
            "class DummyCacheManager(SimpleItem):",
            "    def ZCacheManager_getCache(self):",
            "        return ADummyCache",
            "",
            "",
            "class EventCatcher:",
            "",
            "    def __init__(self):",
            "        self.created = []",
            "        self.modified = []",
            "        self.setUp()",
            "",
            "    def setUp(self):",
            "        from zope.component import provideHandler",
            "        provideHandler(self.handleCreated)",
            "        provideHandler(self.handleModified)",
            "",
            "    def tearDown(self):",
            "        from zope.component import getSiteManager",
            "        getSiteManager().unregisterHandler(self.handleCreated)",
            "        getSiteManager().unregisterHandler(self.handleModified)",
            "",
            "    def reset(self):",
            "        self.created = []",
            "        self.modified = []",
            "",
            "    @adapter(IObjectCreatedEvent)",
            "    def handleCreated(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.created.append(event)",
            "",
            "    @adapter(IObjectModifiedEvent)",
            "    def handleModified(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.modified.append(event)",
            "",
            "",
            "class FileTests(unittest.TestCase):",
            "    content_type = 'application/octet-stream'",
            "    factory = 'manage_addFile'",
            "",
            "    def setUp(self):",
            "        with open(filedata, 'rb') as fd:",
            "            self.data = fd.read()",
            "        self.connection = makeConnection()",
            "        self.eventCatcher = EventCatcher()",
            "        try:",
            "            r = self.connection.root()",
            "            a = Application()",
            "            r['Application'] = a",
            "            self.root = a",
            "            responseOut = self.responseOut = BytesIO()",
            "            self.app = makerequest(self.root, stdout=responseOut)",
            "            self.app.dcm = DummyCacheManager()",
            "            factory = getattr(self.app, self.factory)",
            "            factory('file',",
            "                    file=self.data, content_type=self.content_type)",
            "            self.app.file.ZCacheable_setManagerId('dcm')",
            "            self.app.file.ZCacheable_setEnabled(enabled=1)",
            "            setattr(self.app, ZCM_MANAGERS, ('dcm',))",
            "            # Hack, we need a _p_mtime for the file, so we make sure that it",
            "            # has one.",
            "            transaction.commit()",
            "        except Exception:",
            "            transaction.abort()",
            "            self.connection.close()",
            "            raise",
            "        transaction.begin()",
            "        self.file = getattr(self.app, 'file')",
            "",
            "        # Since we do the create here, let's test the events here too",
            "        self.assertEqual(1, len(self.eventCatcher.created))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.eventCatcher.reset()",
            "",
            "    def tearDown(self):",
            "        del self.file",
            "        transaction.abort()",
            "        self.connection.close()",
            "        del self.app",
            "        del self.responseOut",
            "        del self.root",
            "        del self.connection",
            "        ADummyCache.clear()",
            "        self.eventCatcher.tearDown()",
            "",
            "    def testViewImageOrFile(self):",
            "        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(b'foo')",
            "        self.assertEqual(self.file.size, 3)",
            "        self.assertEqual(self.file.data, b'foo')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testReadData(self):",
            "        s = b'a' * (2 << 16)",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertIsInstance(data, Pdata)",
            "        self.assertEqual(bytes(data), s)",
            "        self.assertEqual(len(s), len(bytes(data)))",
            "        self.assertEqual(len(s), size)",
            "",
            "    def testBigPdata(self):",
            "        # Test that a big enough string is split into several Pdata",
            "        # From a file",
            "        s = b'a' * (1 << 16) * 3",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertNotEqual(data.next, None)",
            "        # From a string",
            "        data, size = self.file._read_data(s)",
            "        self.assertNotEqual(data.next, None)",
            "",
            "    def testManageEditWithFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageEditWithoutFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUpload(self):",
            "        f = BytesIO(b'jammyjohnson')",
            "        self.file.manage_upload(f)",
            "        self.assertEqual(self.file.data, b'jammyjohnson')",
            "        self.assertEqual(self.file.content_type, 'application/octet-stream')",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUploadWithoutFileData(self):",
            "        self.file.manage_upload()",
            "        self.assertEqual(0, len(self.eventCatcher.modified))",
            "",
            "    def testIfModSince(self):",
            "        now = time.time()",
            "        e = {'SERVER_NAME': 'foo',",
            "             'SERVER_PORT': '80',",
            "             'REQUEST_METHOD': 'GET'}",
            "",
            "        # not modified since",
            "        t_notmod = rfc1123_date(now)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 304)",
            "        self.assertEqual(data, b'')",
            "",
            "        # modified since",
            "        t_mod = rfc1123_date(now - 100)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_mod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 200)",
            "        self.assertEqual(data, bytes(self.file.data))",
            "",
            "    def testPUT(self):",
            "        s = b'# some python\\n'",
            "",
            "        # with content type",
            "        data = BytesIO(s)",
            "        req = aputrequest(data, 'text/x-python')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "        # without content type",
            "        data.seek(0)",
            "        req = aputrequest(data, '')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "    def testIndexHtmlWithPdata(self):",
            "        self.file.manage_upload(b'a' * (2 << 16))  # 128K",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testIndexHtmlWithString(self):",
            "        self.file.manage_upload(b'a' * 100)  # 100 bytes",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testPrincipiaSearchSource_not_text(self):",
            "        data = ''.join([chr(x) for x in range(256)])",
            "        data = data.encode('utf-8')",
            "        self.file.manage_edit('foobar', 'application/octet-stream',",
            "                              filedata=data)",
            "        self.assertEqual(self.file.PrincipiaSearchSource(), b'')",
            "",
            "    def testPrincipiaSearchSource_text(self):",
            "        self.file.manage_edit('foobar', 'text/plain',",
            "                              filedata=b'Now is the time for all good men to '",
            "                                       b'come to the aid of the Party.')",
            "        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())",
            "",
            "    def test_manage_DAVget_binary(self):",
            "        self.assertEqual(self.file.manage_DAVget(), self.data)",
            "",
            "    def test_manage_DAVget_text(self):",
            "        text = (b'Now is the time for all good men to '",
            "                b'come to the aid of the Party.')",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=text)",
            "        self.assertEqual(self.file.manage_DAVget(), text)",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import File",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface",
            "",
            "        verifyClass(HTTPRangeInterface, File)",
            "        verifyClass(IWriteLock, File)",
            "",
            "    def testUnicode(self):",
            "        val = 'some unicode string here'",
            "",
            "        self.assertRaises(TypeError, self.file.update_data,",
            "                          data=val, content_type='text/plain')",
            "",
            "    def test__str__returns_native_string(self):",
            "        small_data = b'small data'",
            "        self.file.manage_upload(file=small_data)",
            "        self.assertEqual(str(self.file), small_data.decode())",
            "",
            "        # Make sure Pdata contents are handled correctly",
            "        big_data = b'a' * (2 << 16)",
            "        self.file.manage_upload(file=big_data)",
            "        self.assertEqual(str(self.file), big_data.decode())",
            "",
            "",
            "class ImageTests(FileTests):",
            "    content_type = 'image/gif'",
            "    factory = 'manage_addImage'",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(self.data)",
            "        self.assertEqual(self.file.size, len(self.data))",
            "        self.assertEqual(self.file.data, self.data)",
            "        self.assertEqual(self.file.width, 16)",
            "        self.assertEqual(self.file.height, 16)",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testTag(self):",
            "        tag_fmt = ('<img src=\"http://nohost/file\" '",
            "                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))",
            "        self.file.manage_changeProperties(title='foo')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))",
            "        self.file.manage_changeProperties(alt='bar')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))",
            "",
            "    testStr = testTag",
            "",
            "    def test__str__returns_native_string(self):",
            "        small_data = b'small data'",
            "        self.file.manage_upload(file=small_data)",
            "        self.assertIsInstance(str(self.file), str)",
            "",
            "        # Make sure Pdata contents are handled correctly",
            "        big_data = b'a' * (2 << 16)",
            "        self.file.manage_upload(file=big_data)",
            "        self.assertIsInstance(str(self.file), str)",
            "",
            "    def testViewImageOrFile(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertIsNone(response.getHeader(\"Content-Disposition\"))",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import Image",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "",
            "        verifyClass(IWriteLock, Image)",
            "",
            "    def test_text_representation_is_tag(self):",
            "        self.assertEqual(str(self.file),",
            "                         '<img src=\"http://nohost/file\"'",
            "                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')",
            "",
            "",
            "class SVGTests(ImageTests):",
            "    content_type = 'image/svg+xml'",
            "",
            "    def testViewImageOrFile(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertEqual(",
            "            response.getHeader(\"Content-Disposition\"),",
            "            \"attachment; filename*=UTF-8''file.svg\",",
            "        )",
            "",
            "    def testViewImageOrFileNonAscii(self):",
            "        try:",
            "            factory = getattr(self.app, self.factory)",
            "            factory('h\u00e4llo',",
            "                    file=self.data, content_type=self.content_type)",
            "            transaction.commit()",
            "        except Exception:",
            "            transaction.abort()",
            "            self.connection.close()",
            "            raise",
            "        transaction.begin()",
            "        image = getattr(self.app, 'h\u00e4llo')",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = image.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertEqual(",
            "            response.getHeader(\"Content-Disposition\"),",
            "            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\",",
            "        )",
            "",
            "    def testViewImageOrFile_with_denylist(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        self.file.use_denylist = True",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertEqual(",
            "            response.getHeader(\"Content-Disposition\"),",
            "            \"attachment; filename*=UTF-8''file.svg\",",
            "        )",
            "",
            "    def testViewImageOrFile_with_empty_denylist(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        self.file.use_denylist = True",
            "        self.file.disallowed_inline_mimetypes = []",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertIsNone(response.getHeader(\"Content-Disposition\"))",
            "",
            "",
            "class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):",
            "    \"\"\"Browser testing ..Image.File\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        uf = self.app.acl_users",
            "        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])",
            "        self.app.manage_addFile('file')",
            "",
            "        transaction.commit()",
            "        self.browser = Testing.testbrowser.Browser()",
            "        self.browser.login('manager', 'manager_pass')",
            "",
            "    def test_Image__manage_main__1(self):",
            "        \"\"\"It shows the content of text files as text.\"\"\"",
            "        self.app.file.update_data('h\u00e4llo'.encode())",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'h\u00e4llo')",
            "",
            "    def test_Image__manage_main__3(self):",
            "        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"",
            "        self.app.file.update_data('h\u00e4llo'.encode('latin-1'))",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.assertIn(",
            "            \"The file could not be decoded with 'utf-8'.\",",
            "            self.browser.contents)",
            "",
            "    def test_Image__manage_upload__1(self):",
            "        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.browser.getControl(name='file').add_file(",
            "            b'test text file', 'text/plain', 'TestFile.txt')",
            "        self.browser.getControl('Upload File').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        self.assertEqual(",
            "            self.browser.getControl('Content Type').value, 'text/plain')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'test text file')",
            "",
            "    def test_Image__manage_edit__1(self):",
            "        \"\"\"It it possible to change the file's content via browser.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text_1 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_1, '')",
            "        self.browser.getControl(name='filedata:text').value = 'h\u00e4llo'",
            "        self.browser.getControl('Save Changes').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        text_2 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_2, 'h\u00e4llo')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures"
        ]
    }
}