{
    "nautobot/core/settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": 619,
                "PatchRowcode": "     ],"
            },
            "1": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": 620,
                "PatchRowcode": "     \"NETWORK_DRIVERS\": ["
            },
            "2": {
                "beforePatchRowNumber": 621,
                "afterPatchRowNumber": 621,
                "PatchRowcode": "         {},"
            },
            "3": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mark_safe("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+        mark_safe(  # noqa: S308"
            },
            "5": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "             \"Extend or override default Platform.network_driver translations provided by \""
            },
            "6": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "             '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '"
            },
            "7": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "             \"Enter a dictionary in JSON format, for example:\\n\""
            }
        },
        "frontPatchFile": [
            "import os",
            "import platform",
            "import re",
            "import sys",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.settings_funcs import is_truthy, parse_redis_connection  # noqa: F401",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can\u2019t do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "ALLOWED_URL_SCHEMES = (",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            ")",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# By default, Nautobot will permit users to create duplicate prefixes and IP addresses in the global",
            "# table (that is, those which are not assigned to any VRF). This behavior can be disabled by setting",
            "# ENFORCE_GLOBAL_UNIQUE to True.",
            "ENFORCE_GLOBAL_UNIQUE = is_truthy(os.getenv(\"NAUTOBOT_ENFORCE_GLOBAL_UNIQUE\", \"False\"))",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (re.compile(r\"(username|password|passwd|pwd)((?:\\s+is.?|:)?\\s+)\\S+\", re.IGNORECASE), r\"\\1\\2{replacement}\"),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django cryptography",
            "#",
            "",
            "# CRYPTOGRAPHY_BACKEND = cryptography.hazmat.backends.default_backend()",
            "# CRYPTOGRAPHY_DIGEST = cryptography.hazmat.primitives.hashes.SHA256",
            "CRYPTOGRAPHY_KEY = None  # Defaults to SECRET_KEY if unset",
            "CRYPTOGRAPHY_SALT = \"nautobot-cryptography\"",
            "",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "current_major, current_minor = REST_FRAMEWORK_VERSION.split(\".\")",
            "# We support all major.minor API versions from 1.2 to the present latest version.",
            "# This will need to be elaborated upon when we move to version 2.0",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "assert current_major == \"1\", f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {current_major}\"",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{current_major}.{minor}\" for minor in range(2, int(current_minor) + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (\"nautobot.core.api.filter_backends.NautobotFilterBackend\",),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.BulkOperationMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"rest_framework.renderers.JSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (\"rest_framework.parsers.JSONParser\",),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise.",
            "    # This should only change (if at all) with Nautobot major (breaking) releases.",
            "    \"DEFAULT_VERSION\": \"1.2\",",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.utilities.api.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # Each of these StatusModels has bulk and non-bulk serializers, with the same status options,",
            "        # which confounds drf-spectacular's automatic naming of enums, resulting in the below warning:",
            "        #   enum naming encountered a non-optimally resolvable collision for fields named \"status\"",
            "        # By explicitly naming the enums ourselves we avoid this warning.",
            "        \"CableStatusChoices\": \"nautobot.dcim.api.serializers.CableSerializer.status_choices\",",
            "        \"CircuitStatusChoices\": \"nautobot.circuits.api.serializers.CircuitSerializer.status_choices\",",
            "        \"DeviceStatusChoices\": \"nautobot.dcim.api.serializers.DeviceWithConfigContextSerializer.status_choices\",",
            "        \"InterfaceStatusChoices\": \"nautobot.dcim.api.serializers.InterfaceSerializer.status_choices\",",
            "        \"IPAddressStatusChoices\": \"nautobot.ipam.api.serializers.IPAddressSerializer.status_choices\",",
            "        \"LocationStatusChoices\": \"nautobot.dcim.api.serializers.LocationSerializer.status_choices\",",
            "        \"PowerFeedStatusChoices\": \"nautobot.dcim.api.serializers.PowerFeedSerializer.status_choices\",",
            "        \"PrefixStatusChoices\": \"nautobot.ipam.api.serializers.PrefixSerializer.status_choices\",",
            "        \"RackStatusChoices\": \"nautobot.dcim.api.serializers.RackSerializer.status_choices\",",
            "        \"VirtualMachineStatusChoices\": \"nautobot.virtualization.api.serializers.VirtualMachineWithConfigContextSerializer.status_choices\",",
            "        \"VLANStatusChoices\": \"nautobot.ipam.api.serializers.VLANSerializer.status_choices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "# Only PostgresSQL is supported, so database driver is hard-coded. This can",
            "# still be overloaded in custom settings.",
            "# https://docs.djangoproject.com/en/stable/ref/settings/#databases",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\")",
            "",
            "# Default overrides",
            "ALLOWED_HOSTS = os.getenv(\"NAUTOBOT_ALLOWED_HOSTS\", \"\").split(\" \")",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = (\"127.0.0.1\", \"::1\")",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = len(sys.argv) > 1 and sys.argv[1] == \"test\"",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # keep log quiet by default when running unit/integration tests",
            "    LOGGING = {}",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "SHORT_TIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_TIME_FORMAT\", \"H:i:s\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"cacheops\",  # v2 TODO(jathan); Remove cacheops.",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"mptt\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.utilities\",",
            "    \"nautobot.virtualization\",",
            "    \"django_rq\",  # Must come after nautobot.extras to allow overriding management commands",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (os.path.join(BASE_DIR, \"project-static\"),)",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.utilities.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"BANNER_BOTTOM\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ],",
            "    \"BANNER_LOGIN\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of the login page.\",",
            "    ],",
            "    \"BANNER_TOP\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of all pages.\",",
            "    ],",
            "    \"CHANGELOG_RETENTION\": [",
            "        90,",
            "        \"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "    ],",
            "    \"DEPLOYMENT_ID\": [",
            "        \"\",",
            "        \"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "    ],",
            "    \"DISABLE_PREFIX_LIST_HIERARCHY\": [",
            "        False,",
            "        \"Disable rendering parent/child relationships in the IPAM Prefix list view and instead show a flat list.\",",
            "    ],",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": [",
            "        0,",
            "        \"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "    ],",
            "    \"HIDE_RESTRICTED_UI\": [",
            "        False,",
            "        \"If set to True, users with limited permissions will not be shown menu items and home-page elements that \"",
            "        \"they do not have permission to access.\",",
            "    ],",
            "    \"MAX_PAGE_SIZE\": [",
            "        1000,",
            "        \"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "    ],",
            "    \"NETWORK_DRIVERS\": [",
            "        {},",
            "        mark_safe(",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            \"<pre>{\\n\"",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        \"optional_json_field\",",
            "    ],",
            "    \"PAGINATE_COUNT\": [",
            "        50,",
            "        \"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "    ],",
            "    \"PER_PAGE_DEFAULTS\": [",
            "        [25, 50, 100, 250, 500, 1000],",
            "        \"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        \"per_page_defaults_field\",",
            "    ],",
            "    \"PREFER_IPV4\": [",
            "        False,",
            "        \"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": [",
            "        22,",
            "        \"Default height (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": [",
            "        230,",
            "        \"Default width (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RELEASE_CHECK_TIMEOUT\": [",
            "        24 * 3600,",
            "        \"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        \"release_check_timeout_field\",",
            "    ],",
            "    \"RELEASE_CHECK_URL\": [",
            "        \"\",",
            "        \"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        \"release_check_url_field\",",
            "    ],",
            "    \"SUPPORT_MESSAGE\": [",
            "        \"\",",
            "        \"Help message to include on 4xx and 5xx error pages. Markdown is supported.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"],",
            "    \"Rack Elevation Rendering\": [\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"DISABLE_PREFIX_LIST_HIERARCHY\", \"HIDE_RESTRICTED_UI\", \"SUPPORT_MESSAGE\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# v2 TODO(jathan): Remove all cacheops settings.",
            "# The django-cacheops plugin is used to cache querysets. The built-in Django",
            "# caching is not used.",
            "CACHEOPS = {",
            "    \"auth.user\": {\"ops\": \"get\", \"timeout\": 60 * 15},",
            "    \"auth.*\": {\"ops\": (\"fetch\", \"get\")},",
            "    \"auth.permission\": {\"ops\": \"all\"},",
            "    \"circuits.*\": {\"ops\": \"all\"},",
            "    \"dcim.inventoryitem\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.region\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.rackgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.*\": {\"ops\": \"all\"},",
            "    \"ipam.*\": {\"ops\": \"all\"},",
            "    \"extras.*\": {\"ops\": \"all\"},",
            "    \"users.*\": {\"ops\": \"all\"},",
            "    \"tenancy.tenantgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"tenancy.*\": {\"ops\": \"all\"},",
            "    \"virtualization.*\": {\"ops\": \"all\"},",
            "}",
            "CACHEOPS_DEGRADE_ON_FAILURE = True",
            "CACHEOPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CACHEOPS_ENABLED\", \"False\"))",
            "CACHEOPS_REDIS = os.getenv(\"NAUTOBOT_CACHEOPS_REDIS\", parse_redis_connection(redis_database=1))",
            "CACHEOPS_DEFAULTS = {\"timeout\": int(os.getenv(\"NAUTOBOT_CACHEOPS_TIMEOUT\", \"900\"))}",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis. The",
            "# django-rq settings will use the same instance/database by default.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=0),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Django RQ (used for legacy background processesing)",
            "#",
            "",
            "# These defaults utilize the Django caches setting defined for django-redis.",
            "# See: https://github.com/rq/django-rq#support-for-django-redis-and-django-redis-cache",
            "RQ_QUEUES = {",
            "    \"default\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"check_releases\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"custom_fields\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"webhooks\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "}",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results",
            "CELERY_RESULT_BACKEND = os.getenv(\"NAUTOBOT_CELERY_RESULT_BACKEND\", parse_redis_connection(redis_database=0))",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(\",\")",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]"
        ],
        "afterPatchFile": [
            "import os",
            "import platform",
            "import re",
            "import sys",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.settings_funcs import is_truthy, parse_redis_connection  # noqa: F401",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can\u2019t do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "ALLOWED_URL_SCHEMES = (",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            ")",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# By default, Nautobot will permit users to create duplicate prefixes and IP addresses in the global",
            "# table (that is, those which are not assigned to any VRF). This behavior can be disabled by setting",
            "# ENFORCE_GLOBAL_UNIQUE to True.",
            "ENFORCE_GLOBAL_UNIQUE = is_truthy(os.getenv(\"NAUTOBOT_ENFORCE_GLOBAL_UNIQUE\", \"False\"))",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (re.compile(r\"(username|password|passwd|pwd)((?:\\s+is.?|:)?\\s+)\\S+\", re.IGNORECASE), r\"\\1\\2{replacement}\"),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django cryptography",
            "#",
            "",
            "# CRYPTOGRAPHY_BACKEND = cryptography.hazmat.backends.default_backend()",
            "# CRYPTOGRAPHY_DIGEST = cryptography.hazmat.primitives.hashes.SHA256",
            "CRYPTOGRAPHY_KEY = None  # Defaults to SECRET_KEY if unset",
            "CRYPTOGRAPHY_SALT = \"nautobot-cryptography\"",
            "",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "current_major, current_minor = REST_FRAMEWORK_VERSION.split(\".\")",
            "# We support all major.minor API versions from 1.2 to the present latest version.",
            "# This will need to be elaborated upon when we move to version 2.0",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "assert current_major == \"1\", f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {current_major}\"",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{current_major}.{minor}\" for minor in range(2, int(current_minor) + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (\"nautobot.core.api.filter_backends.NautobotFilterBackend\",),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.BulkOperationMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"rest_framework.renderers.JSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (\"rest_framework.parsers.JSONParser\",),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise.",
            "    # This should only change (if at all) with Nautobot major (breaking) releases.",
            "    \"DEFAULT_VERSION\": \"1.2\",",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.utilities.api.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # Each of these StatusModels has bulk and non-bulk serializers, with the same status options,",
            "        # which confounds drf-spectacular's automatic naming of enums, resulting in the below warning:",
            "        #   enum naming encountered a non-optimally resolvable collision for fields named \"status\"",
            "        # By explicitly naming the enums ourselves we avoid this warning.",
            "        \"CableStatusChoices\": \"nautobot.dcim.api.serializers.CableSerializer.status_choices\",",
            "        \"CircuitStatusChoices\": \"nautobot.circuits.api.serializers.CircuitSerializer.status_choices\",",
            "        \"DeviceStatusChoices\": \"nautobot.dcim.api.serializers.DeviceWithConfigContextSerializer.status_choices\",",
            "        \"InterfaceStatusChoices\": \"nautobot.dcim.api.serializers.InterfaceSerializer.status_choices\",",
            "        \"IPAddressStatusChoices\": \"nautobot.ipam.api.serializers.IPAddressSerializer.status_choices\",",
            "        \"LocationStatusChoices\": \"nautobot.dcim.api.serializers.LocationSerializer.status_choices\",",
            "        \"PowerFeedStatusChoices\": \"nautobot.dcim.api.serializers.PowerFeedSerializer.status_choices\",",
            "        \"PrefixStatusChoices\": \"nautobot.ipam.api.serializers.PrefixSerializer.status_choices\",",
            "        \"RackStatusChoices\": \"nautobot.dcim.api.serializers.RackSerializer.status_choices\",",
            "        \"VirtualMachineStatusChoices\": \"nautobot.virtualization.api.serializers.VirtualMachineWithConfigContextSerializer.status_choices\",",
            "        \"VLANStatusChoices\": \"nautobot.ipam.api.serializers.VLANSerializer.status_choices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "# Only PostgresSQL is supported, so database driver is hard-coded. This can",
            "# still be overloaded in custom settings.",
            "# https://docs.djangoproject.com/en/stable/ref/settings/#databases",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\")",
            "",
            "# Default overrides",
            "ALLOWED_HOSTS = os.getenv(\"NAUTOBOT_ALLOWED_HOSTS\", \"\").split(\" \")",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = (\"127.0.0.1\", \"::1\")",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = len(sys.argv) > 1 and sys.argv[1] == \"test\"",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # keep log quiet by default when running unit/integration tests",
            "    LOGGING = {}",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "SHORT_TIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_TIME_FORMAT\", \"H:i:s\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"cacheops\",  # v2 TODO(jathan); Remove cacheops.",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"mptt\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.utilities\",",
            "    \"nautobot.virtualization\",",
            "    \"django_rq\",  # Must come after nautobot.extras to allow overriding management commands",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (os.path.join(BASE_DIR, \"project-static\"),)",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.utilities.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"BANNER_BOTTOM\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ],",
            "    \"BANNER_LOGIN\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of the login page.\",",
            "    ],",
            "    \"BANNER_TOP\": [",
            "        \"\",",
            "        \"Custom HTML to display in a banner at the top of all pages.\",",
            "    ],",
            "    \"CHANGELOG_RETENTION\": [",
            "        90,",
            "        \"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "    ],",
            "    \"DEPLOYMENT_ID\": [",
            "        \"\",",
            "        \"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "    ],",
            "    \"DISABLE_PREFIX_LIST_HIERARCHY\": [",
            "        False,",
            "        \"Disable rendering parent/child relationships in the IPAM Prefix list view and instead show a flat list.\",",
            "    ],",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": [",
            "        0,",
            "        \"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "    ],",
            "    \"HIDE_RESTRICTED_UI\": [",
            "        False,",
            "        \"If set to True, users with limited permissions will not be shown menu items and home-page elements that \"",
            "        \"they do not have permission to access.\",",
            "    ],",
            "    \"MAX_PAGE_SIZE\": [",
            "        1000,",
            "        \"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "    ],",
            "    \"NETWORK_DRIVERS\": [",
            "        {},",
            "        mark_safe(  # noqa: S308",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            \"<pre>{\\n\"",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        \"optional_json_field\",",
            "    ],",
            "    \"PAGINATE_COUNT\": [",
            "        50,",
            "        \"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "    ],",
            "    \"PER_PAGE_DEFAULTS\": [",
            "        [25, 50, 100, 250, 500, 1000],",
            "        \"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        \"per_page_defaults_field\",",
            "    ],",
            "    \"PREFER_IPV4\": [",
            "        False,",
            "        \"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": [",
            "        22,",
            "        \"Default height (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": [",
            "        230,",
            "        \"Default width (in pixels) of a rack unit in a rack elevation diagram\",",
            "    ],",
            "    \"RELEASE_CHECK_TIMEOUT\": [",
            "        24 * 3600,",
            "        \"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        \"release_check_timeout_field\",",
            "    ],",
            "    \"RELEASE_CHECK_URL\": [",
            "        \"\",",
            "        \"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        \"release_check_url_field\",",
            "    ],",
            "    \"SUPPORT_MESSAGE\": [",
            "        \"\",",
            "        \"Help message to include on 4xx and 5xx error pages. Markdown is supported.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"],",
            "    \"Rack Elevation Rendering\": [\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"DISABLE_PREFIX_LIST_HIERARCHY\", \"HIDE_RESTRICTED_UI\", \"SUPPORT_MESSAGE\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# v2 TODO(jathan): Remove all cacheops settings.",
            "# The django-cacheops plugin is used to cache querysets. The built-in Django",
            "# caching is not used.",
            "CACHEOPS = {",
            "    \"auth.user\": {\"ops\": \"get\", \"timeout\": 60 * 15},",
            "    \"auth.*\": {\"ops\": (\"fetch\", \"get\")},",
            "    \"auth.permission\": {\"ops\": \"all\"},",
            "    \"circuits.*\": {\"ops\": \"all\"},",
            "    \"dcim.inventoryitem\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.region\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.rackgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"dcim.*\": {\"ops\": \"all\"},",
            "    \"ipam.*\": {\"ops\": \"all\"},",
            "    \"extras.*\": {\"ops\": \"all\"},",
            "    \"users.*\": {\"ops\": \"all\"},",
            "    \"tenancy.tenantgroup\": None,  # MPTT models are exempt due to raw SQL",
            "    \"tenancy.*\": {\"ops\": \"all\"},",
            "    \"virtualization.*\": {\"ops\": \"all\"},",
            "}",
            "CACHEOPS_DEGRADE_ON_FAILURE = True",
            "CACHEOPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CACHEOPS_ENABLED\", \"False\"))",
            "CACHEOPS_REDIS = os.getenv(\"NAUTOBOT_CACHEOPS_REDIS\", parse_redis_connection(redis_database=1))",
            "CACHEOPS_DEFAULTS = {\"timeout\": int(os.getenv(\"NAUTOBOT_CACHEOPS_TIMEOUT\", \"900\"))}",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis. The",
            "# django-rq settings will use the same instance/database by default.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=0),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Django RQ (used for legacy background processesing)",
            "#",
            "",
            "# These defaults utilize the Django caches setting defined for django-redis.",
            "# See: https://github.com/rq/django-rq#support-for-django-redis-and-django-redis-cache",
            "RQ_QUEUES = {",
            "    \"default\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"check_releases\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"custom_fields\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "    \"webhooks\": {",
            "        \"USE_REDIS_CACHE\": \"default\",",
            "    },",
            "}",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results",
            "CELERY_RESULT_BACKEND = os.getenv(\"NAUTOBOT_CELERY_RESULT_BACKEND\", parse_redis_connection(redis_database=0))",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(\",\")",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "622": []
        },
        "addLocation": []
    },
    "nautobot/core/views/generic.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from django.http import HttpResponse"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django.shortcuts import get_object_or_404, redirect, render"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django.urls import NoReverseMatch, reverse"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from django.utils.http import is_safe_url"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from django.views.generic import View"
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from django_tables2 import RequestConfig"
            },
            "9": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             if not filterset.is_valid():"
            },
            "11": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "                 messages.error("
            },
            "12": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "                     request,"
            },
            "13": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mark_safe(f\"Invalid filters were specified: {filterset.errors}\"),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+                    format_html(\"Invalid filters were specified: {}\", filterset.errors),"
            },
            "15": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "                 )"
            },
            "16": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "                 self.queryset = self.queryset.none()"
            },
            "17": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "                 msg = f\"{verb} {self.queryset.model._meta.verbose_name}\""
            },
            "19": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "                 logger.info(f\"{msg} {obj} (PK: {obj.pk})\")"
            },
            "20": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "                 if hasattr(obj, \"get_absolute_url\"):"
            },
            "21": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)"
            },
            "23": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 464,
                "PatchRowcode": "                 else:"
            },
            "24": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    msg = f\"{msg} {escape(obj)}\""
            },
            "25": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                messages.success(request, mark_safe(msg))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+                    msg = format_html(\"{} {}\", msg, obj)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+                messages.success(request, msg)"
            },
            "28": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 467,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "                 if \"_addanother\" in request.POST:"
            },
            "30": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "                     # If the object has clone_fields, pre-populate a new instance of the form"
            },
            "31": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": 793,
                "PatchRowcode": "                 logger.info(f\"Import object {obj} (PK: {obj.pk})\")"
            },
            "32": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": 794,
                "PatchRowcode": "                 messages.success("
            },
            "33": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": 795,
                "PatchRowcode": "                     request,"
            },
            "34": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mark_safe(f'Imported object: <a href=\"{obj.get_absolute_url()}\">{obj}</a>'),"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 796,
                "PatchRowcode": "+                    format_html('Imported object: <a href=\"{}\">{}</a>', obj.get_absolute_url(), obj),"
            },
            "36": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": 797,
                "PatchRowcode": "                 )"
            },
            "37": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": 798,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": 799,
                "PatchRowcode": "                 if \"_addanother\" in request.POST:"
            }
        },
        "frontPatchFile": [
            "from copy import deepcopy",
            "import logging",
            "import re",
            "",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction, IntegrityError",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput, Textarea",
            "from django.http import HttpResponse",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import escape",
            "from django.utils.http import is_safe_url",
            "from django.utils.safestring import mark_safe",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "",
            "from nautobot.core.forms import SearchForm",
            "from nautobot.core.utilities import check_filter_for_display",
            "from nautobot.extras.models import CustomField, ExportTemplate",
            "from nautobot.extras.models.change_logging import ChangeLoggedModel",
            "from nautobot.utilities.config import get_settings_or_config",
            "from nautobot.utilities.error_handlers import handle_protectederror",
            "from nautobot.utilities.exceptions import AbortTransaction",
            "from nautobot.utilities.forms import (",
            "    BootstrapMixin,",
            "    BulkRenameForm,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    ImportForm,",
            "    TableConfigForm,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.utilities.forms.forms import DynamicFilterFormSet",
            "from nautobot.utilities.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.templatetags.helpers import bettertitle, validated_viewname",
            "from nautobot.utilities.utils import (",
            "    convert_querydict_to_factory_formset_acceptable_querydict,",
            "    csv_format,",
            "    get_route_for_model,",
            "    get_filterable_params_from_filter_params,",
            "    normalize_querydict,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.utilities.views import GetReturnURLMixin, ObjectPermissionRequiredMixin",
            "",
            "",
            "class ObjectView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Retrieve a single object for display.",
            "",
            "    queryset: The base queryset for retrieving the object",
            "    template_name: Name of the template to use",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    def get_template_name(self):",
            "        \"\"\"",
            "        Return self.template_name if set. Otherwise, resolve the template path by model app_label and name.",
            "        \"\"\"",
            "        if self.template_name is not None:",
            "            return self.template_name",
            "        model_opts = self.queryset.model._meta",
            "        return f\"{model_opts.app_label}/{model_opts.model_name}.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request (Request): The current request",
            "            instance (Model): The object being viewed",
            "",
            "        Returns:",
            "            (dict): Additional context data",
            "        \"\"\"",
            "        return {",
            "            \"active_tab\": request.GET.get(\"tab\", \"main\"),",
            "        }",
            "",
            "    # 2.0 TODO: Remove this method in 2.0. Can be retrieved from instance itself now",
            "    # instance.get_changelog_url()",
            "    # Only available on models that support changelogs",
            "    def get_changelog_url(self, instance):",
            "        \"\"\"Return the changelog URL for a given instance.\"\"\"",
            "        meta = self.queryset.model._meta",
            "",
            "        # Don't try to generate a changelog_url for an ObjectChange.",
            "        if meta.model_name == \"objectchange\":",
            "            return None",
            "",
            "        route = get_route_for_model(instance, \"changelog\")",
            "",
            "        # Iterate the pk-like fields and try to get a URL, or return None.",
            "        fields = [\"pk\", \"slug\"]",
            "        for field in fields:",
            "            if not hasattr(instance, field):",
            "                continue",
            "",
            "            try:",
            "                return reverse(route, kwargs={field: getattr(instance, field)})",
            "            except NoReverseMatch:",
            "                continue",
            "",
            "        # This object likely doesn't have a changelog route defined.",
            "        return None",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Generic GET handler for accessing an object by PK or slug",
            "        \"\"\"",
            "        instance = get_object_or_404(self.queryset, **kwargs)",
            "",
            "        changelog_url = None",
            "",
            "        if isinstance(instance, ChangeLoggedModel):",
            "            changelog_url = instance.get_changelog_url()",
            "",
            "        return render(",
            "            request,",
            "            self.get_template_name(),",
            "            {",
            "                \"object\": instance,",
            "                \"verbose_name\": self.queryset.model._meta.verbose_name,",
            "                \"verbose_name_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"changelog_url\": changelog_url,  # 2.0 TODO: Remove in 2.0. This information can be retrieved from the object itself now.",
            "                **self.get_extra_context(request, instance),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectListView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    List a series of objects.",
            "",
            "    queryset: The queryset of objects to display. Note: Prefetching related objects is not necessary, as the",
            "      table will prefetch objects as needed depending on the columns being displayed.",
            "    filter: A django-filter FilterSet that is applied to the queryset",
            "    filter_form: The form used to render filter options",
            "    table: The django-tables2 Table used to render the objects list",
            "    template_name: The name of the template",
            "    non_filter_params: List of query parameters that are **not** used for queryset filtering",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    filterset_form = None",
            "    table = None",
            "    template_name = \"generic/object_list.html\"",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset())",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        yaml_data = [obj.to_yaml() for obj in self.queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def queryset_to_csv(self):",
            "        \"\"\"",
            "        Export the queryset of objects as comma-separated value (CSV), using the model's to_csv() method.",
            "        \"\"\"",
            "        csv_data = []",
            "        custom_field_names = []",
            "",
            "        # Start with the column headers",
            "        headers = self.queryset.model.csv_headers.copy()",
            "",
            "        # Add custom field headers, if any",
            "        if hasattr(self.queryset.model, \"_custom_field_data\"):",
            "            for custom_field in CustomField.objects.get_for_model(self.queryset.model):",
            "                headers.append(\"cf_\" + custom_field.slug)",
            "                # 2.0 TODO: #824 custom_field.slug",
            "                custom_field_names.append(custom_field.name)",
            "",
            "        csv_data.append(\",\".join(headers))",
            "",
            "        # Iterate through the queryset appending each object",
            "        for obj in self.queryset:",
            "            data = obj.to_csv()",
            "",
            "            # 2.0 TODO: #824 use custom_field_slug",
            "            for custom_field_name in custom_field_names:",
            "                data += (obj.cf.get(custom_field_name, \"\"),)",
            "",
            "            csv_data.append(csv_format(data))",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def validate_action_buttons(self, request):",
            "        \"\"\"Verify actions in self.action_buttons are valid view actions.\"\"\"",
            "",
            "        always_valid_actions = (\"export\",)",
            "        valid_actions = []",
            "        invalid_actions = []",
            "        # added check for whether the action_buttons exist because of issue #2107",
            "        if self.action_buttons is None:",
            "            self.action_buttons = []",
            "        for action in self.action_buttons:",
            "            if action in always_valid_actions or validated_viewname(self.queryset.model, action) is not None:",
            "                valid_actions.append(action)",
            "            else:",
            "                invalid_actions.append(action)",
            "        if invalid_actions:",
            "            messages.error(request, f\"Missing views for action(s) {', '.join(invalid_actions)}\")",
            "        return valid_actions",
            "",
            "    def get(self, request):",
            "        model = self.queryset.model",
            "        content_type = ContentType.objects.get_for_model(model)",
            "",
            "        display_filter_params = []",
            "        dynamic_filter_form = None",
            "        filter_form = None",
            "",
            "        if self.filterset:",
            "            filter_params = self.get_filter_params(request)",
            "            filterset = self.filterset(filter_params, self.queryset)",
            "            self.queryset = filterset.qs",
            "            if not filterset.is_valid():",
            "                messages.error(",
            "                    request,",
            "                    mark_safe(f\"Invalid filters were specified: {filterset.errors}\"),",
            "                )",
            "                self.queryset = self.queryset.none()",
            "",
            "            display_filter_params = [",
            "                check_filter_for_display(filterset.filters, field_name, values)",
            "                for field_name, values in filter_params.items()",
            "            ]",
            "",
            "            if request.GET:",
            "                factory_formset_params = convert_querydict_to_factory_formset_acceptable_querydict(",
            "                    request.GET, filterset",
            "                )",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset, data=factory_formset_params)",
            "            else:",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset)",
            "",
            "            if self.filterset_form:",
            "                filter_form = self.filterset_form(filter_params, label_suffix=\"\")",
            "",
            "        # Check for export template rendering",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(self.queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{self.queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Fall back to built-in CSV formatting if export requested but no template specified",
            "        elif \"export\" in request.GET and hasattr(model, \"to_csv\"):",
            "            response = HttpResponse(self.queryset_to_csv(), content_type=\"text/csv\")",
            "            filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{self.queryset.model._meta.verbose_name_plural}.csv\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Provide a hook to tweak the queryset based on the request immediately prior to rendering the object list",
            "        self.queryset = self.alter_queryset(request)",
            "",
            "        # Compile a dictionary indicating which permissions are available to the current user for this model",
            "        permissions = {}",
            "        for action in (\"add\", \"change\", \"delete\", \"view\"):",
            "            perm_name = get_permission_for_model(model, action)",
            "            permissions[action] = request.user.has_perm(perm_name)",
            "",
            "        table = None",
            "        table_config_form = None",
            "        if self.table:",
            "            # Construct the objects table",
            "            # Order By is needed in the table `__init__` method",
            "            order_by = self.request.GET.getlist(\"sort\")",
            "            table = self.table(self.queryset, user=request.user, order_by=order_by)",
            "            if \"pk\" in table.base_columns and (permissions[\"change\"] or permissions[\"delete\"]):",
            "                table.columns.show(\"pk\")",
            "",
            "            # Apply the request context",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(table)",
            "            table_config_form = TableConfigForm(table=table)",
            "            max_page_size = get_settings_or_config(\"MAX_PAGE_SIZE\")",
            "            if max_page_size and paginate[\"per_page\"] > max_page_size:",
            "                messages.warning(",
            "                    request,",
            "                    f'Requested \"per_page\" is too large. No more than {max_page_size} items may be displayed at a time.',",
            "                )",
            "",
            "        # For the search form field, use a custom placeholder.",
            "        q_placeholder = \"Search \" + bettertitle(model._meta.verbose_name_plural)",
            "        search_form = SearchForm(data=request.GET, q_placeholder=q_placeholder)",
            "",
            "        valid_actions = self.validate_action_buttons(request)",
            "",
            "        context = {",
            "            \"content_type\": content_type,",
            "            \"table\": table,",
            "            \"permissions\": permissions,",
            "            \"action_buttons\": valid_actions,",
            "            \"table_config_form\": table_config_form,",
            "            \"filter_params\": display_filter_params,",
            "            \"filter_form\": filter_form,",
            "            \"dynamic_filter_form\": dynamic_filter_form,",
            "            \"search_form\": search_form,",
            "            \"list_url\": validated_viewname(model, \"list\"),",
            "            \"title\": bettertitle(model._meta.verbose_name_plural),",
            "        }",
            "",
            "        # `extra_context()` would require `request` access, however `request` parameter cannot simply be",
            "        # added to `extra_context()` because  this method has been used by multiple apps without any parameters.",
            "        # Changing 'def extra context()' to 'def extra context(request)' might break current methods",
            "        # in plugins and core that either override or implement it without request.",
            "        setattr(self, \"request\", request)",
            "        context.update(self.extra_context())",
            "",
            "        return render(request, self.template_name, context)",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        return self.queryset.all()",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class ObjectEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create or edit a single object.",
            "",
            "    queryset: The base queryset for the object being modified",
            "    model_form: The form used to create or edit the object",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    template_name = \"generic/object_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        # self._permission_action is set by dispatch() to either \"add\" or \"change\" depending on whether",
            "        # we are modifying an existing object or creating a new one.",
            "        return get_permission_for_model(self.queryset.model, self._permission_action)",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by slug, PK, or name, if provided.",
            "        for field in (\"slug\", \"pk\", \"name\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request: The current request",
            "            instance: The object being edited",
            "",
            "        Returns:",
            "            dict",
            "        \"\"\"",
            "        return {}",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed. For example, a parent object can be defined",
            "        # given some parameter from the request URL.",
            "        return obj",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Determine required permission based on whether we are editing an existing object",
            "        self._permission_action = \"change\" if kwargs else \"add\"",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "",
            "        initial_data = normalize_querydict(request.GET, form_class=self.model_form)",
            "        form = self.model_form(instance=obj, initial=initial_data)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.ObjectEditView\")",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'",
            "                else:",
            "                    msg = f\"{msg} {escape(obj)}\"",
            "                messages.success(request, mark_safe(msg))",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete a single object.",
            "",
            "    queryset: The base queryset for the object being deleted",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by slug or PK, or name if provided.",
            "        for field in (\"slug\", \"pk\", \"name\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get(self, request, **kwargs):",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(initial=request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.ObjectDeleteView\")",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                obj.delete()",
            "            except ProtectedError as e:",
            "                logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "                handle_protectederror([obj], request, e)",
            "                return redirect(obj.get_absolute_url())",
            "",
            "            msg = f\"Deleted {self.queryset.model._meta.verbose_name} {obj}\"",
            "            logger.info(msg)",
            "            messages.success(request, msg)",
            "",
            "            return_url = form.cleaned_data.get(\"return_url\")",
            "            if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                return redirect(return_url)",
            "            else:",
            "                return redirect(self.get_return_url(request, obj))",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class BulkCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create new objects in bulk.",
            "",
            "    queryset: Base queryset for the objects being created",
            "    form: Form class which provides the `pattern` field",
            "    model_form: The ModelForm used to create individual objects",
            "    pattern_target: Name of the field to be evaluated as a pattern (if any)",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    pattern_target = \"\"",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        # Set initial values for visible form fields from query args",
            "        initial = {}",
            "        for field in getattr(self.model_form._meta, \"fields\", []):",
            "            if request.GET.get(field):",
            "                initial[field] = request.GET[field]",
            "",
            "        form = self.form()",
            "        model_form = self.model_form(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkCreateView\")",
            "        model = self.queryset.model",
            "        form = self.form(request.POST)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "            pattern = form.cleaned_data[\"pattern\"]",
            "            new_objs = []",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    # Create objects from the expanded. Abort the transaction on the first validation error.",
            "                    for value in pattern:",
            "                        # Reinstantiate the model form each time to avoid overwriting the same instance. Use a mutable",
            "                        # copy of the POST QueryDict so that we can update the target field value.",
            "                        model_form = self.model_form(request.POST.copy())",
            "                        model_form.data[self.pattern_target] = value",
            "",
            "                        # Validate each new object independently.",
            "                        if model_form.is_valid():",
            "                            obj = model_form.save()",
            "                            logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "                            new_objs.append(obj)",
            "                        else:",
            "                            # Copy any errors on the pattern target field to the pattern form.",
            "                            errors = model_form.errors.as_data()",
            "                            if errors.get(self.pattern_target):",
            "                                form.add_error(\"pattern\", errors[self.pattern_target])",
            "                            # Raise an IntegrityError to break the for loop and abort the transaction.",
            "                            raise IntegrityError()",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                    # If we make it to this point, validation has succeeded on all new objects.",
            "                    msg = f\"Added {len(new_objs)} {model._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.path)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            except IntegrityError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object creation failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"obj_type\": model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import a single object (YAML or JSON format).",
            "",
            "    queryset: Base queryset for the objects being created",
            "    model_form: The ModelForm used to create individual objects",
            "    related_object_forms: A dictionary mapping of forms to be used for the creation of related (child) objects",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    related_object_forms = {}",
            "    template_name = \"generic/object_import.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = ImportForm()",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.ObjectImportView\")",
            "        form = ImportForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Import form validation was successful\")",
            "",
            "            # Initialize model form",
            "            data = form.cleaned_data[\"data\"]",
            "            model_form = self.model_form(data)",
            "            restrict_form_fields(model_form, request.user)",
            "",
            "            # Assign default values for any fields which were not specified. We have to do this manually because passing",
            "            # 'initial=' to the form on initialization merely sets default values for the widgets. Since widgets are not",
            "            # used for YAML/JSON import, we first bind the imported data normally, then update the form's data with the",
            "            # applicable field defaults as needed prior to form validation.",
            "            for field_name, field in model_form.fields.items():",
            "                if field_name not in data and hasattr(field, \"initial\"):",
            "                    model_form.data[field_name] = field.initial",
            "",
            "            if model_form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Save the primary object",
            "                        obj = model_form.save()",
            "",
            "                        # Enforce object-level permissions",
            "                        self.queryset.get(pk=obj.pk)",
            "",
            "                        logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "",
            "                        # Iterate through the related object forms (if any), validating and saving each instance.",
            "                        for (",
            "                            field_name,",
            "                            related_object_form,",
            "                        ) in self.related_object_forms.items():",
            "                            logger.debug(\"Processing form for related objects: {related_object_form}\")",
            "",
            "                            related_obj_pks = []",
            "                            for i, rel_obj_data in enumerate(data.get(field_name, [])):",
            "                                f = related_object_form(obj, rel_obj_data)",
            "",
            "                                for subfield_name, field in f.fields.items():",
            "                                    if subfield_name not in rel_obj_data and hasattr(field, \"initial\"):",
            "                                        f.data[subfield_name] = field.initial",
            "",
            "                                if f.is_valid():",
            "                                    related_obj = f.save()",
            "                                    related_obj_pks.append(related_obj.pk)",
            "                                else:",
            "                                    # Replicate errors on the related object form to the primary form for display",
            "                                    for subfield_name, errors in f.errors.items():",
            "                                        for err in errors:",
            "                                            err_msg = f\"{field_name}[{i}] {subfield_name}: {err}\"",
            "                                            model_form.add_error(None, err_msg)",
            "                                    raise AbortTransaction()",
            "",
            "                            # Enforce object-level permissions on related objects",
            "                            model = related_object_form.Meta.model",
            "                            if model.objects.filter(pk__in=related_obj_pks).count() != len(related_obj_pks):",
            "                                raise ObjectDoesNotExist",
            "",
            "                except AbortTransaction:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            if not model_form.errors:",
            "                logger.info(f\"Import object {obj} (PK: {obj.pk})\")",
            "                messages.success(",
            "                    request,",
            "                    mark_safe(f'Imported object: <a href=\"{obj.get_absolute_url()}\">{obj}</a>'),",
            "                )",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            else:",
            "                logger.debug(\"Model form validation failed\")",
            "",
            "                # Replicate model form errors for display",
            "                for field, errors in model_form.errors.items():",
            "                    for err in errors:",
            "                        if field == \"__all__\":",
            "                            form.add_error(None, err)",
            "                        else:",
            "                            form.add_error(None, f\"{field}: {err}\")",
            "",
            "        else:",
            "            logger.debug(\"Import form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import objects in bulk (CSV format).",
            "",
            "    queryset: Base queryset for the model",
            "    model_form: The form used to create each imported object",
            "    table: The django-tables2 Table used to render the list of imported objects",
            "    template_name: The name of the template",
            "    widget_attrs: A dict of attributes to apply to the import widget (e.g. to require a session key)",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_import.html\"",
            "    widget_attrs = {}",
            "",
            "    def _import_form(self, *args, **kwargs):",
            "        class CSVImportForm(BootstrapMixin, Form):",
            "            csv_data = CSVDataField(from_form=self.model_form, widget=Textarea(attrs=self.widget_attrs))",
            "            csv_file = CSVFileField(from_form=self.model_form)",
            "",
            "        return CSVImportForm(*args, **kwargs)",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        \"\"\"",
            "        Provide a hook to modify the object immediately before saving it (e.g. to encrypt secret data).",
            "        \"\"\"",
            "        return obj_form.save()",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": self._import_form(),",
            "                \"fields\": self.model_form().fields,",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-data\",",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkImportView\")",
            "        new_objs = []",
            "        form = self._import_form(request.POST, request.FILES)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                # Iterate through CSV data and bind each row to a new model form instance.",
            "                with transaction.atomic():",
            "                    if request.FILES:",
            "                        field_name = \"csv_file\"",
            "                    else:",
            "                        field_name = \"csv_data\"",
            "                    headers, records = form.cleaned_data[field_name]",
            "                    for row, data in enumerate(records, start=1):",
            "                        obj_form = self.model_form(data, headers=headers)",
            "                        restrict_form_fields(obj_form, request.user)",
            "",
            "                        if obj_form.is_valid():",
            "                            obj = self._save_obj(obj_form, request)",
            "                            new_objs.append(obj)",
            "                        else:",
            "                            for field, err in obj_form.errors.items():",
            "                                form.add_error(field_name, f\"Row {row} {field}: {err[0]}\")",
            "                            raise ValidationError(\"\")",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                # Compile a table containing the imported objects",
            "                obj_table = self.table(new_objs)",
            "",
            "                if new_objs:",
            "                    msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return render(",
            "                        request,",
            "                        \"import_success.html\",",
            "                        {",
            "                            \"table\": obj_table,",
            "                            \"return_url\": self.get_return_url(request),",
            "                        },",
            "                    )",
            "",
            "            except ValidationError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object import failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"fields\": self.model_form().fields,",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-file\" if form.has_error(\"csv_file\") else \"csv-data\",",
            "            },",
            "        )",
            "",
            "",
            "class BulkEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Edit objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being edited",
            "    form: The form class used to edit objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed.",
            "        # For example, a parent object can be defined given some parameter from the request URL.",
            "        return obj",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.BulkEditView\")",
            "        model = self.queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = [obj.pk for obj in self.filterset(request.GET, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        if \"_apply\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "                form_custom_fields = getattr(form, \"custom_fields\", [])",
            "                form_relationships = getattr(form, \"relationships\", [])",
            "                standard_fields = [",
            "                    field",
            "                    for field in form.fields",
            "                    if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "                ]",
            "                nullified_fields = request.POST.getlist(\"_nullify\")",
            "",
            "                # 2.0 TODO: #824 this won't really be needed once obj.cf is indexed by slug rather than by name",
            "                form_cf_to_key = {f\"cf_{cf.slug}\": cf.name for cf in CustomField.objects.get_for_model(model)}",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        updated_objects = []",
            "                        for obj in self.queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                            obj = self.alter_obj(obj, request, [], kwargs)",
            "",
            "                            # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                            for name in standard_fields:",
            "                                try:",
            "                                    model_field = model._meta.get_field(name)",
            "                                except FieldDoesNotExist:",
            "                                    # This form field is used to modify a field rather than set its value directly",
            "                                    model_field = None",
            "",
            "                                # Handle nullification",
            "                                if name in form.nullable_fields and name in nullified_fields:",
            "                                    if isinstance(model_field, ManyToManyField):",
            "                                        getattr(obj, name).set([])",
            "                                    else:",
            "                                        setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "",
            "                                # ManyToManyFields",
            "                                elif isinstance(model_field, ManyToManyField):",
            "                                    if form.cleaned_data[name]:",
            "                                        getattr(obj, name).set(form.cleaned_data[name])",
            "                                # Normal fields",
            "                                elif form.cleaned_data[name] not in (None, \"\"):",
            "                                    setattr(obj, name, form.cleaned_data[name])",
            "",
            "                            # Update custom fields",
            "                            for field_name in form_custom_fields:",
            "                                # 2.0 TODO: #824 when we use slug in obj.cf we can just do obj.cf[field_name[3:]]",
            "                                if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                                    obj.cf[form_cf_to_key[field_name]] = None",
            "                                elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                                    obj.cf[form_cf_to_key[field_name]] = form.cleaned_data[field_name]",
            "",
            "                            obj.full_clean()",
            "                            obj.save()",
            "                            updated_objects.append(obj)",
            "                            logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                            # Add/remove tags",
            "                            if form.cleaned_data.get(\"add_tags\", None):",
            "                                obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                            if form.cleaned_data.get(\"remove_tags\", None):",
            "                                obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                            if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                                # Add/remove relationship associations",
            "                                form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                                form.save_note(instance=obj, user=request.user)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(",
            "                            updated_objects",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    if updated_objects:",
            "                        msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "                        logger.info(msg)",
            "                        messages.success(self.request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                except ValidationError as e:",
            "                    messages.error(self.request, f\"{obj} failed validation: {e}\")",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            # Include the PK list as initial data for the form",
            "            initial_data = {\"pk\": pk_list}",
            "",
            "            # Check for other contextual data needed for the form. We avoid passing all of request.GET because the",
            "            # filter values will conflict with the bulk edit form fields.",
            "            # TODO: Find a better way to accomplish this",
            "            if \"device\" in request.GET:",
            "                initial_data[\"device\"] = request.GET.get(\"device\")",
            "            elif \"device_type\" in request.GET:",
            "                initial_data[\"device_type\"] = request.GET.get(\"device_type\")",
            "",
            "            form = self.form(model, initial=initial_data)",
            "            restrict_form_fields(form, request.user)",
            "",
            "        # Retrieve objects being edited",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(request, f\"No {model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"table\": table,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class BulkRenameView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    An extendable view for renaming objects in bulk.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_bulk_rename.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Create a new Form class from BulkRenameForm",
            "        class _Form(BulkRenameForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput())",
            "",
            "        self.form = _Form",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkRenameView\")",
            "        query_pks = request.POST.getlist(\"pk\")",
            "        selected_objects = self.queryset.filter(pk__in=query_pks) if query_pks else None",
            "",
            "        # selected_objects would return False; if no query_pks or invalid query_pks",
            "        if not selected_objects:",
            "            messages.warning(request, f\"No valid {self.queryset.model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        if \"_preview\" in request.POST or \"_apply\" in request.POST:",
            "            form = self.form(request.POST, initial={\"pk\": query_pks})",
            "            if form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        renamed_pks = []",
            "                        for obj in selected_objects:",
            "                            find = form.cleaned_data[\"find\"]",
            "                            replace = form.cleaned_data[\"replace\"]",
            "                            if form.cleaned_data[\"use_regex\"]:",
            "                                try:",
            "                                    obj.new_name = re.sub(find, replace, obj.name)",
            "                                # Catch regex group reference errors",
            "                                except re.error:",
            "                                    obj.new_name = obj.name",
            "                            else:",
            "                                obj.new_name = obj.name.replace(find, replace)",
            "                            renamed_pks.append(obj.pk)",
            "",
            "                        if \"_apply\" in request.POST:",
            "                            for obj in selected_objects:",
            "                                obj.name = obj.new_name",
            "                                obj.save()",
            "",
            "                            # Enforce constrained permissions",
            "                            if self.queryset.filter(pk__in=renamed_pks).count() != len(selected_objects):",
            "                                raise ObjectDoesNotExist",
            "",
            "                            messages.success(",
            "                                request,",
            "                                f\"Renamed {len(selected_objects)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                            )",
            "                            return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        else:",
            "            form = self.form(initial={\"pk\": query_pks})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"selected_objects\": selected_objects,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"parent_name\": self.get_selected_objects_parents_name(selected_objects),",
            "            },",
            "        )",
            "",
            "    def get_selected_objects_parents_name(self, selected_objects):",
            "        \"\"\"",
            "        Return selected_objects parent name.",
            "",
            "        Args:",
            "            selected_objects: The objects being renamed",
            "        \"\"\"",
            "",
            "        return \"\"",
            "",
            "",
            "class BulkDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being deleted",
            "    form: The form class used to delete objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.BulkDeleteView\")",
            "        model = self.queryset.model",
            "",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = [obj.pk for obj in self.filterset(request.GET, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        form_cls = self.get_form()",
            "",
            "        if \"_confirm\" in request.POST:",
            "            form = form_cls(request.POST)",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                # Delete objects",
            "                queryset = self.queryset.filter(pk__in=pk_list)",
            "",
            "                self.perform_pre_delete(request, queryset)",
            "                try:",
            "                    _, deleted_info = queryset.delete()",
            "                    deleted_count = deleted_info[model._meta.label]",
            "                except ProtectedError as e:",
            "                    logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "                    handle_protectederror(queryset, request, e)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                logger.info(msg)",
            "                messages.success(request, msg)",
            "                return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = form_cls(",
            "                initial={",
            "                    \"pk\": pk_list,",
            "                    \"return_url\": self.get_return_url(request),",
            "                }",
            "            )",
            "",
            "        # Retrieve objects being deleted",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"table\": table,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        pass",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "    def get_form(self):",
            "        \"\"\"",
            "        Provide a standard bulk delete form if none has been specified for the view",
            "        \"\"\"",
            "",
            "        class BulkDeleteForm(ConfirmationForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput)",
            "",
            "        if self.form:",
            "            return self.form",
            "",
            "        return BulkDeleteForm",
            "",
            "",
            "#",
            "# Device/VirtualMachine components",
            "#",
            "",
            "",
            "# TODO: Replace with BulkCreateView",
            "class ComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a Device or VirtualMachine.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = self.form(initial=request.GET)",
            "        model_form = self.model_form(request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"model_form\": model_form,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.ComponentCreateView\")",
            "        form = self.form(request.POST, initial=request.GET)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            new_components = []",
            "            data = deepcopy(request.POST)",
            "",
            "            names = form.cleaned_data[\"name_pattern\"]",
            "            labels = form.cleaned_data.get(\"label_pattern\")",
            "            for i, name in enumerate(names):",
            "                label = labels[i] if labels else None",
            "                # Initialize the individual component form",
            "                data[\"name\"] = name",
            "                data[\"label\"] = label",
            "                if hasattr(form, \"get_iterative_data\"):",
            "                    data.update(form.get_iterative_data(i))",
            "                component_form = self.model_form(data)",
            "",
            "                if component_form.is_valid():",
            "                    new_components.append(component_form)",
            "                else:",
            "                    for field, errors in component_form.errors.as_data().items():",
            "                        # Assign errors on the child form's name/label field to name_pattern/label_pattern on the parent form",
            "                        if field == \"name\":",
            "                            field = \"name_pattern\"",
            "                        elif field == \"label\":",
            "                            field = \"label_pattern\"",
            "                        for e in errors:",
            "                            err_str = \", \".join(e)",
            "                            form.add_error(field, f\"{name}: {err_str}\")",
            "",
            "            if not form.errors:",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Create the new components",
            "                        new_objs = []",
            "                        for component_form in new_components:",
            "                            obj = component_form.save()",
            "                            new_objs.append(obj)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    messages.success(",
            "                        request,",
            "                        f\"Added {len(new_components)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                    )",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.get_full_path())",
            "                    else:",
            "                        return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a set of Devices or VirtualMachines.",
            "    \"\"\"",
            "",
            "    parent_model = None",
            "    parent_field = None",
            "    form = None",
            "    queryset = None",
            "    model_form = None",
            "    filterset = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_add_component.html\"",
            "",
            "    def get_required_permission(self):",
            "        return f\"dcim.add_{self.queryset.model._meta.model_name}\"",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkComponentCreateView\")",
            "        parent_model_name = self.parent_model._meta.verbose_name_plural",
            "        model_name = self.queryset.model._meta.verbose_name_plural",
            "        model = self.queryset.model",
            "",
            "        # Are we editing *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\") and self.filterset is not None:",
            "            pk_list = [obj.pk for obj in self.filterset(request.GET, self.parent_model.objects.only(\"pk\")).qs]",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        selected_objects = self.parent_model.objects.filter(pk__in=pk_list)",
            "        if not selected_objects:",
            "            messages.warning(",
            "                request,",
            "                f\"No {self.parent_model._meta.verbose_name_plural} were selected.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        table = self.table(selected_objects)",
            "",
            "        if \"_create\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                new_components = []",
            "                data = deepcopy(form.cleaned_data)",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        for obj in data[\"pk\"]:",
            "                            names = data[\"name_pattern\"]",
            "                            labels = data[\"label_pattern\"] if \"label_pattern\" in data else None",
            "                            for i, name in enumerate(names):",
            "                                label = labels[i] if labels else None",
            "",
            "                                component_data = {",
            "                                    self.parent_field: obj.pk,",
            "                                    \"name\": name,",
            "                                    \"label\": label,",
            "                                }",
            "                                component_data.update(data)",
            "                                component_form = self.model_form(component_data)",
            "                                if component_form.is_valid():",
            "                                    instance = component_form.save()",
            "                                    logger.debug(f\"Created {instance} on {instance.parent}\")",
            "                                    new_components.append(instance)",
            "                                else:",
            "                                    for (",
            "                                        field,",
            "                                        errors,",
            "                                    ) in component_form.errors.as_data().items():",
            "                                        for e in errors:",
            "                                            err_str = \", \".join(e)",
            "                                            form.add_error(",
            "                                                field,",
            "                                                f\"{obj} {name}: {err_str}\",",
            "                                            )",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_components]).count() != len(",
            "                            new_components",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                except IntegrityError:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "                if not form.errors:",
            "                    msg = f\"Added {len(new_components)} {model_name} to {len(form.cleaned_data['pk'])} {parent_model_name}.\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = self.form(model, initial={\"pk\": pk_list})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"parent_model_name\": parent_model_name,",
            "                \"model_name\": model_name,",
            "                \"table\": table,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )"
        ],
        "afterPatchFile": [
            "from copy import deepcopy",
            "import logging",
            "import re",
            "",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction, IntegrityError",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput, Textarea",
            "from django.http import HttpResponse",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import format_html",
            "from django.utils.http import is_safe_url",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "",
            "from nautobot.core.forms import SearchForm",
            "from nautobot.core.utilities import check_filter_for_display",
            "from nautobot.extras.models import CustomField, ExportTemplate",
            "from nautobot.extras.models.change_logging import ChangeLoggedModel",
            "from nautobot.utilities.config import get_settings_or_config",
            "from nautobot.utilities.error_handlers import handle_protectederror",
            "from nautobot.utilities.exceptions import AbortTransaction",
            "from nautobot.utilities.forms import (",
            "    BootstrapMixin,",
            "    BulkRenameForm,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    ImportForm,",
            "    TableConfigForm,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.utilities.forms.forms import DynamicFilterFormSet",
            "from nautobot.utilities.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.templatetags.helpers import bettertitle, validated_viewname",
            "from nautobot.utilities.utils import (",
            "    convert_querydict_to_factory_formset_acceptable_querydict,",
            "    csv_format,",
            "    get_route_for_model,",
            "    get_filterable_params_from_filter_params,",
            "    normalize_querydict,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.utilities.views import GetReturnURLMixin, ObjectPermissionRequiredMixin",
            "",
            "",
            "class ObjectView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Retrieve a single object for display.",
            "",
            "    queryset: The base queryset for retrieving the object",
            "    template_name: Name of the template to use",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    def get_template_name(self):",
            "        \"\"\"",
            "        Return self.template_name if set. Otherwise, resolve the template path by model app_label and name.",
            "        \"\"\"",
            "        if self.template_name is not None:",
            "            return self.template_name",
            "        model_opts = self.queryset.model._meta",
            "        return f\"{model_opts.app_label}/{model_opts.model_name}.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request (Request): The current request",
            "            instance (Model): The object being viewed",
            "",
            "        Returns:",
            "            (dict): Additional context data",
            "        \"\"\"",
            "        return {",
            "            \"active_tab\": request.GET.get(\"tab\", \"main\"),",
            "        }",
            "",
            "    # 2.0 TODO: Remove this method in 2.0. Can be retrieved from instance itself now",
            "    # instance.get_changelog_url()",
            "    # Only available on models that support changelogs",
            "    def get_changelog_url(self, instance):",
            "        \"\"\"Return the changelog URL for a given instance.\"\"\"",
            "        meta = self.queryset.model._meta",
            "",
            "        # Don't try to generate a changelog_url for an ObjectChange.",
            "        if meta.model_name == \"objectchange\":",
            "            return None",
            "",
            "        route = get_route_for_model(instance, \"changelog\")",
            "",
            "        # Iterate the pk-like fields and try to get a URL, or return None.",
            "        fields = [\"pk\", \"slug\"]",
            "        for field in fields:",
            "            if not hasattr(instance, field):",
            "                continue",
            "",
            "            try:",
            "                return reverse(route, kwargs={field: getattr(instance, field)})",
            "            except NoReverseMatch:",
            "                continue",
            "",
            "        # This object likely doesn't have a changelog route defined.",
            "        return None",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Generic GET handler for accessing an object by PK or slug",
            "        \"\"\"",
            "        instance = get_object_or_404(self.queryset, **kwargs)",
            "",
            "        changelog_url = None",
            "",
            "        if isinstance(instance, ChangeLoggedModel):",
            "            changelog_url = instance.get_changelog_url()",
            "",
            "        return render(",
            "            request,",
            "            self.get_template_name(),",
            "            {",
            "                \"object\": instance,",
            "                \"verbose_name\": self.queryset.model._meta.verbose_name,",
            "                \"verbose_name_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"changelog_url\": changelog_url,  # 2.0 TODO: Remove in 2.0. This information can be retrieved from the object itself now.",
            "                **self.get_extra_context(request, instance),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectListView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    List a series of objects.",
            "",
            "    queryset: The queryset of objects to display. Note: Prefetching related objects is not necessary, as the",
            "      table will prefetch objects as needed depending on the columns being displayed.",
            "    filter: A django-filter FilterSet that is applied to the queryset",
            "    filter_form: The form used to render filter options",
            "    table: The django-tables2 Table used to render the objects list",
            "    template_name: The name of the template",
            "    non_filter_params: List of query parameters that are **not** used for queryset filtering",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    filterset_form = None",
            "    table = None",
            "    template_name = \"generic/object_list.html\"",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset())",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        yaml_data = [obj.to_yaml() for obj in self.queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def queryset_to_csv(self):",
            "        \"\"\"",
            "        Export the queryset of objects as comma-separated value (CSV), using the model's to_csv() method.",
            "        \"\"\"",
            "        csv_data = []",
            "        custom_field_names = []",
            "",
            "        # Start with the column headers",
            "        headers = self.queryset.model.csv_headers.copy()",
            "",
            "        # Add custom field headers, if any",
            "        if hasattr(self.queryset.model, \"_custom_field_data\"):",
            "            for custom_field in CustomField.objects.get_for_model(self.queryset.model):",
            "                headers.append(\"cf_\" + custom_field.slug)",
            "                # 2.0 TODO: #824 custom_field.slug",
            "                custom_field_names.append(custom_field.name)",
            "",
            "        csv_data.append(\",\".join(headers))",
            "",
            "        # Iterate through the queryset appending each object",
            "        for obj in self.queryset:",
            "            data = obj.to_csv()",
            "",
            "            # 2.0 TODO: #824 use custom_field_slug",
            "            for custom_field_name in custom_field_names:",
            "                data += (obj.cf.get(custom_field_name, \"\"),)",
            "",
            "            csv_data.append(csv_format(data))",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def validate_action_buttons(self, request):",
            "        \"\"\"Verify actions in self.action_buttons are valid view actions.\"\"\"",
            "",
            "        always_valid_actions = (\"export\",)",
            "        valid_actions = []",
            "        invalid_actions = []",
            "        # added check for whether the action_buttons exist because of issue #2107",
            "        if self.action_buttons is None:",
            "            self.action_buttons = []",
            "        for action in self.action_buttons:",
            "            if action in always_valid_actions or validated_viewname(self.queryset.model, action) is not None:",
            "                valid_actions.append(action)",
            "            else:",
            "                invalid_actions.append(action)",
            "        if invalid_actions:",
            "            messages.error(request, f\"Missing views for action(s) {', '.join(invalid_actions)}\")",
            "        return valid_actions",
            "",
            "    def get(self, request):",
            "        model = self.queryset.model",
            "        content_type = ContentType.objects.get_for_model(model)",
            "",
            "        display_filter_params = []",
            "        dynamic_filter_form = None",
            "        filter_form = None",
            "",
            "        if self.filterset:",
            "            filter_params = self.get_filter_params(request)",
            "            filterset = self.filterset(filter_params, self.queryset)",
            "            self.queryset = filterset.qs",
            "            if not filterset.is_valid():",
            "                messages.error(",
            "                    request,",
            "                    format_html(\"Invalid filters were specified: {}\", filterset.errors),",
            "                )",
            "                self.queryset = self.queryset.none()",
            "",
            "            display_filter_params = [",
            "                check_filter_for_display(filterset.filters, field_name, values)",
            "                for field_name, values in filter_params.items()",
            "            ]",
            "",
            "            if request.GET:",
            "                factory_formset_params = convert_querydict_to_factory_formset_acceptable_querydict(",
            "                    request.GET, filterset",
            "                )",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset, data=factory_formset_params)",
            "            else:",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset)",
            "",
            "            if self.filterset_form:",
            "                filter_form = self.filterset_form(filter_params, label_suffix=\"\")",
            "",
            "        # Check for export template rendering",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(self.queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{self.queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Fall back to built-in CSV formatting if export requested but no template specified",
            "        elif \"export\" in request.GET and hasattr(model, \"to_csv\"):",
            "            response = HttpResponse(self.queryset_to_csv(), content_type=\"text/csv\")",
            "            filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{self.queryset.model._meta.verbose_name_plural}.csv\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Provide a hook to tweak the queryset based on the request immediately prior to rendering the object list",
            "        self.queryset = self.alter_queryset(request)",
            "",
            "        # Compile a dictionary indicating which permissions are available to the current user for this model",
            "        permissions = {}",
            "        for action in (\"add\", \"change\", \"delete\", \"view\"):",
            "            perm_name = get_permission_for_model(model, action)",
            "            permissions[action] = request.user.has_perm(perm_name)",
            "",
            "        table = None",
            "        table_config_form = None",
            "        if self.table:",
            "            # Construct the objects table",
            "            # Order By is needed in the table `__init__` method",
            "            order_by = self.request.GET.getlist(\"sort\")",
            "            table = self.table(self.queryset, user=request.user, order_by=order_by)",
            "            if \"pk\" in table.base_columns and (permissions[\"change\"] or permissions[\"delete\"]):",
            "                table.columns.show(\"pk\")",
            "",
            "            # Apply the request context",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(table)",
            "            table_config_form = TableConfigForm(table=table)",
            "            max_page_size = get_settings_or_config(\"MAX_PAGE_SIZE\")",
            "            if max_page_size and paginate[\"per_page\"] > max_page_size:",
            "                messages.warning(",
            "                    request,",
            "                    f'Requested \"per_page\" is too large. No more than {max_page_size} items may be displayed at a time.',",
            "                )",
            "",
            "        # For the search form field, use a custom placeholder.",
            "        q_placeholder = \"Search \" + bettertitle(model._meta.verbose_name_plural)",
            "        search_form = SearchForm(data=request.GET, q_placeholder=q_placeholder)",
            "",
            "        valid_actions = self.validate_action_buttons(request)",
            "",
            "        context = {",
            "            \"content_type\": content_type,",
            "            \"table\": table,",
            "            \"permissions\": permissions,",
            "            \"action_buttons\": valid_actions,",
            "            \"table_config_form\": table_config_form,",
            "            \"filter_params\": display_filter_params,",
            "            \"filter_form\": filter_form,",
            "            \"dynamic_filter_form\": dynamic_filter_form,",
            "            \"search_form\": search_form,",
            "            \"list_url\": validated_viewname(model, \"list\"),",
            "            \"title\": bettertitle(model._meta.verbose_name_plural),",
            "        }",
            "",
            "        # `extra_context()` would require `request` access, however `request` parameter cannot simply be",
            "        # added to `extra_context()` because  this method has been used by multiple apps without any parameters.",
            "        # Changing 'def extra context()' to 'def extra context(request)' might break current methods",
            "        # in plugins and core that either override or implement it without request.",
            "        setattr(self, \"request\", request)",
            "        context.update(self.extra_context())",
            "",
            "        return render(request, self.template_name, context)",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        return self.queryset.all()",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class ObjectEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create or edit a single object.",
            "",
            "    queryset: The base queryset for the object being modified",
            "    model_form: The form used to create or edit the object",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    template_name = \"generic/object_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        # self._permission_action is set by dispatch() to either \"add\" or \"change\" depending on whether",
            "        # we are modifying an existing object or creating a new one.",
            "        return get_permission_for_model(self.queryset.model, self._permission_action)",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by slug, PK, or name, if provided.",
            "        for field in (\"slug\", \"pk\", \"name\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request: The current request",
            "            instance: The object being edited",
            "",
            "        Returns:",
            "            dict",
            "        \"\"\"",
            "        return {}",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed. For example, a parent object can be defined",
            "        # given some parameter from the request URL.",
            "        return obj",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Determine required permission based on whether we are editing an existing object",
            "        self._permission_action = \"change\" if kwargs else \"add\"",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "",
            "        initial_data = normalize_querydict(request.GET, form_class=self.model_form)",
            "        form = self.model_form(instance=obj, initial=initial_data)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.ObjectEditView\")",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                if hasattr(obj, \"get_absolute_url\"):",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                else:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete a single object.",
            "",
            "    queryset: The base queryset for the object being deleted",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by slug or PK, or name if provided.",
            "        for field in (\"slug\", \"pk\", \"name\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get(self, request, **kwargs):",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(initial=request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.ObjectDeleteView\")",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                obj.delete()",
            "            except ProtectedError as e:",
            "                logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "                handle_protectederror([obj], request, e)",
            "                return redirect(obj.get_absolute_url())",
            "",
            "            msg = f\"Deleted {self.queryset.model._meta.verbose_name} {obj}\"",
            "            logger.info(msg)",
            "            messages.success(request, msg)",
            "",
            "            return_url = form.cleaned_data.get(\"return_url\")",
            "            if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                return redirect(return_url)",
            "            else:",
            "                return redirect(self.get_return_url(request, obj))",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class BulkCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create new objects in bulk.",
            "",
            "    queryset: Base queryset for the objects being created",
            "    form: Form class which provides the `pattern` field",
            "    model_form: The ModelForm used to create individual objects",
            "    pattern_target: Name of the field to be evaluated as a pattern (if any)",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    pattern_target = \"\"",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        # Set initial values for visible form fields from query args",
            "        initial = {}",
            "        for field in getattr(self.model_form._meta, \"fields\", []):",
            "            if request.GET.get(field):",
            "                initial[field] = request.GET[field]",
            "",
            "        form = self.form()",
            "        model_form = self.model_form(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkCreateView\")",
            "        model = self.queryset.model",
            "        form = self.form(request.POST)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "            pattern = form.cleaned_data[\"pattern\"]",
            "            new_objs = []",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    # Create objects from the expanded. Abort the transaction on the first validation error.",
            "                    for value in pattern:",
            "                        # Reinstantiate the model form each time to avoid overwriting the same instance. Use a mutable",
            "                        # copy of the POST QueryDict so that we can update the target field value.",
            "                        model_form = self.model_form(request.POST.copy())",
            "                        model_form.data[self.pattern_target] = value",
            "",
            "                        # Validate each new object independently.",
            "                        if model_form.is_valid():",
            "                            obj = model_form.save()",
            "                            logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "                            new_objs.append(obj)",
            "                        else:",
            "                            # Copy any errors on the pattern target field to the pattern form.",
            "                            errors = model_form.errors.as_data()",
            "                            if errors.get(self.pattern_target):",
            "                                form.add_error(\"pattern\", errors[self.pattern_target])",
            "                            # Raise an IntegrityError to break the for loop and abort the transaction.",
            "                            raise IntegrityError()",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                    # If we make it to this point, validation has succeeded on all new objects.",
            "                    msg = f\"Added {len(new_objs)} {model._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.path)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            except IntegrityError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object creation failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"obj_type\": model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import a single object (YAML or JSON format).",
            "",
            "    queryset: Base queryset for the objects being created",
            "    model_form: The ModelForm used to create individual objects",
            "    related_object_forms: A dictionary mapping of forms to be used for the creation of related (child) objects",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    related_object_forms = {}",
            "    template_name = \"generic/object_import.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = ImportForm()",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.ObjectImportView\")",
            "        form = ImportForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Import form validation was successful\")",
            "",
            "            # Initialize model form",
            "            data = form.cleaned_data[\"data\"]",
            "            model_form = self.model_form(data)",
            "            restrict_form_fields(model_form, request.user)",
            "",
            "            # Assign default values for any fields which were not specified. We have to do this manually because passing",
            "            # 'initial=' to the form on initialization merely sets default values for the widgets. Since widgets are not",
            "            # used for YAML/JSON import, we first bind the imported data normally, then update the form's data with the",
            "            # applicable field defaults as needed prior to form validation.",
            "            for field_name, field in model_form.fields.items():",
            "                if field_name not in data and hasattr(field, \"initial\"):",
            "                    model_form.data[field_name] = field.initial",
            "",
            "            if model_form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Save the primary object",
            "                        obj = model_form.save()",
            "",
            "                        # Enforce object-level permissions",
            "                        self.queryset.get(pk=obj.pk)",
            "",
            "                        logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "",
            "                        # Iterate through the related object forms (if any), validating and saving each instance.",
            "                        for (",
            "                            field_name,",
            "                            related_object_form,",
            "                        ) in self.related_object_forms.items():",
            "                            logger.debug(\"Processing form for related objects: {related_object_form}\")",
            "",
            "                            related_obj_pks = []",
            "                            for i, rel_obj_data in enumerate(data.get(field_name, [])):",
            "                                f = related_object_form(obj, rel_obj_data)",
            "",
            "                                for subfield_name, field in f.fields.items():",
            "                                    if subfield_name not in rel_obj_data and hasattr(field, \"initial\"):",
            "                                        f.data[subfield_name] = field.initial",
            "",
            "                                if f.is_valid():",
            "                                    related_obj = f.save()",
            "                                    related_obj_pks.append(related_obj.pk)",
            "                                else:",
            "                                    # Replicate errors on the related object form to the primary form for display",
            "                                    for subfield_name, errors in f.errors.items():",
            "                                        for err in errors:",
            "                                            err_msg = f\"{field_name}[{i}] {subfield_name}: {err}\"",
            "                                            model_form.add_error(None, err_msg)",
            "                                    raise AbortTransaction()",
            "",
            "                            # Enforce object-level permissions on related objects",
            "                            model = related_object_form.Meta.model",
            "                            if model.objects.filter(pk__in=related_obj_pks).count() != len(related_obj_pks):",
            "                                raise ObjectDoesNotExist",
            "",
            "                except AbortTransaction:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            if not model_form.errors:",
            "                logger.info(f\"Import object {obj} (PK: {obj.pk})\")",
            "                messages.success(",
            "                    request,",
            "                    format_html('Imported object: <a href=\"{}\">{}</a>', obj.get_absolute_url(), obj),",
            "                )",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            else:",
            "                logger.debug(\"Model form validation failed\")",
            "",
            "                # Replicate model form errors for display",
            "                for field, errors in model_form.errors.items():",
            "                    for err in errors:",
            "                        if field == \"__all__\":",
            "                            form.add_error(None, err)",
            "                        else:",
            "                            form.add_error(None, f\"{field}: {err}\")",
            "",
            "        else:",
            "            logger.debug(\"Import form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import objects in bulk (CSV format).",
            "",
            "    queryset: Base queryset for the model",
            "    model_form: The form used to create each imported object",
            "    table: The django-tables2 Table used to render the list of imported objects",
            "    template_name: The name of the template",
            "    widget_attrs: A dict of attributes to apply to the import widget (e.g. to require a session key)",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_import.html\"",
            "    widget_attrs = {}",
            "",
            "    def _import_form(self, *args, **kwargs):",
            "        class CSVImportForm(BootstrapMixin, Form):",
            "            csv_data = CSVDataField(from_form=self.model_form, widget=Textarea(attrs=self.widget_attrs))",
            "            csv_file = CSVFileField(from_form=self.model_form)",
            "",
            "        return CSVImportForm(*args, **kwargs)",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        \"\"\"",
            "        Provide a hook to modify the object immediately before saving it (e.g. to encrypt secret data).",
            "        \"\"\"",
            "        return obj_form.save()",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": self._import_form(),",
            "                \"fields\": self.model_form().fields,",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-data\",",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkImportView\")",
            "        new_objs = []",
            "        form = self._import_form(request.POST, request.FILES)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                # Iterate through CSV data and bind each row to a new model form instance.",
            "                with transaction.atomic():",
            "                    if request.FILES:",
            "                        field_name = \"csv_file\"",
            "                    else:",
            "                        field_name = \"csv_data\"",
            "                    headers, records = form.cleaned_data[field_name]",
            "                    for row, data in enumerate(records, start=1):",
            "                        obj_form = self.model_form(data, headers=headers)",
            "                        restrict_form_fields(obj_form, request.user)",
            "",
            "                        if obj_form.is_valid():",
            "                            obj = self._save_obj(obj_form, request)",
            "                            new_objs.append(obj)",
            "                        else:",
            "                            for field, err in obj_form.errors.items():",
            "                                form.add_error(field_name, f\"Row {row} {field}: {err[0]}\")",
            "                            raise ValidationError(\"\")",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                # Compile a table containing the imported objects",
            "                obj_table = self.table(new_objs)",
            "",
            "                if new_objs:",
            "                    msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return render(",
            "                        request,",
            "                        \"import_success.html\",",
            "                        {",
            "                            \"table\": obj_table,",
            "                            \"return_url\": self.get_return_url(request),",
            "                        },",
            "                    )",
            "",
            "            except ValidationError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object import failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"fields\": self.model_form().fields,",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-file\" if form.has_error(\"csv_file\") else \"csv-data\",",
            "            },",
            "        )",
            "",
            "",
            "class BulkEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Edit objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being edited",
            "    form: The form class used to edit objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed.",
            "        # For example, a parent object can be defined given some parameter from the request URL.",
            "        return obj",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.BulkEditView\")",
            "        model = self.queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = [obj.pk for obj in self.filterset(request.GET, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        if \"_apply\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "                form_custom_fields = getattr(form, \"custom_fields\", [])",
            "                form_relationships = getattr(form, \"relationships\", [])",
            "                standard_fields = [",
            "                    field",
            "                    for field in form.fields",
            "                    if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "                ]",
            "                nullified_fields = request.POST.getlist(\"_nullify\")",
            "",
            "                # 2.0 TODO: #824 this won't really be needed once obj.cf is indexed by slug rather than by name",
            "                form_cf_to_key = {f\"cf_{cf.slug}\": cf.name for cf in CustomField.objects.get_for_model(model)}",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        updated_objects = []",
            "                        for obj in self.queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                            obj = self.alter_obj(obj, request, [], kwargs)",
            "",
            "                            # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                            for name in standard_fields:",
            "                                try:",
            "                                    model_field = model._meta.get_field(name)",
            "                                except FieldDoesNotExist:",
            "                                    # This form field is used to modify a field rather than set its value directly",
            "                                    model_field = None",
            "",
            "                                # Handle nullification",
            "                                if name in form.nullable_fields and name in nullified_fields:",
            "                                    if isinstance(model_field, ManyToManyField):",
            "                                        getattr(obj, name).set([])",
            "                                    else:",
            "                                        setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "",
            "                                # ManyToManyFields",
            "                                elif isinstance(model_field, ManyToManyField):",
            "                                    if form.cleaned_data[name]:",
            "                                        getattr(obj, name).set(form.cleaned_data[name])",
            "                                # Normal fields",
            "                                elif form.cleaned_data[name] not in (None, \"\"):",
            "                                    setattr(obj, name, form.cleaned_data[name])",
            "",
            "                            # Update custom fields",
            "                            for field_name in form_custom_fields:",
            "                                # 2.0 TODO: #824 when we use slug in obj.cf we can just do obj.cf[field_name[3:]]",
            "                                if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                                    obj.cf[form_cf_to_key[field_name]] = None",
            "                                elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                                    obj.cf[form_cf_to_key[field_name]] = form.cleaned_data[field_name]",
            "",
            "                            obj.full_clean()",
            "                            obj.save()",
            "                            updated_objects.append(obj)",
            "                            logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                            # Add/remove tags",
            "                            if form.cleaned_data.get(\"add_tags\", None):",
            "                                obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                            if form.cleaned_data.get(\"remove_tags\", None):",
            "                                obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                            if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                                # Add/remove relationship associations",
            "                                form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                                form.save_note(instance=obj, user=request.user)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(",
            "                            updated_objects",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    if updated_objects:",
            "                        msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "                        logger.info(msg)",
            "                        messages.success(self.request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                except ValidationError as e:",
            "                    messages.error(self.request, f\"{obj} failed validation: {e}\")",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            # Include the PK list as initial data for the form",
            "            initial_data = {\"pk\": pk_list}",
            "",
            "            # Check for other contextual data needed for the form. We avoid passing all of request.GET because the",
            "            # filter values will conflict with the bulk edit form fields.",
            "            # TODO: Find a better way to accomplish this",
            "            if \"device\" in request.GET:",
            "                initial_data[\"device\"] = request.GET.get(\"device\")",
            "            elif \"device_type\" in request.GET:",
            "                initial_data[\"device_type\"] = request.GET.get(\"device_type\")",
            "",
            "            form = self.form(model, initial=initial_data)",
            "            restrict_form_fields(form, request.user)",
            "",
            "        # Retrieve objects being edited",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(request, f\"No {model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"table\": table,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class BulkRenameView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    An extendable view for renaming objects in bulk.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_bulk_rename.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Create a new Form class from BulkRenameForm",
            "        class _Form(BulkRenameForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput())",
            "",
            "        self.form = _Form",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkRenameView\")",
            "        query_pks = request.POST.getlist(\"pk\")",
            "        selected_objects = self.queryset.filter(pk__in=query_pks) if query_pks else None",
            "",
            "        # selected_objects would return False; if no query_pks or invalid query_pks",
            "        if not selected_objects:",
            "            messages.warning(request, f\"No valid {self.queryset.model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        if \"_preview\" in request.POST or \"_apply\" in request.POST:",
            "            form = self.form(request.POST, initial={\"pk\": query_pks})",
            "            if form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        renamed_pks = []",
            "                        for obj in selected_objects:",
            "                            find = form.cleaned_data[\"find\"]",
            "                            replace = form.cleaned_data[\"replace\"]",
            "                            if form.cleaned_data[\"use_regex\"]:",
            "                                try:",
            "                                    obj.new_name = re.sub(find, replace, obj.name)",
            "                                # Catch regex group reference errors",
            "                                except re.error:",
            "                                    obj.new_name = obj.name",
            "                            else:",
            "                                obj.new_name = obj.name.replace(find, replace)",
            "                            renamed_pks.append(obj.pk)",
            "",
            "                        if \"_apply\" in request.POST:",
            "                            for obj in selected_objects:",
            "                                obj.name = obj.new_name",
            "                                obj.save()",
            "",
            "                            # Enforce constrained permissions",
            "                            if self.queryset.filter(pk__in=renamed_pks).count() != len(selected_objects):",
            "                                raise ObjectDoesNotExist",
            "",
            "                            messages.success(",
            "                                request,",
            "                                f\"Renamed {len(selected_objects)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                            )",
            "                            return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        else:",
            "            form = self.form(initial={\"pk\": query_pks})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"selected_objects\": selected_objects,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"parent_name\": self.get_selected_objects_parents_name(selected_objects),",
            "            },",
            "        )",
            "",
            "    def get_selected_objects_parents_name(self, selected_objects):",
            "        \"\"\"",
            "        Return selected_objects parent name.",
            "",
            "        Args:",
            "            selected_objects: The objects being renamed",
            "        \"\"\"",
            "",
            "        return \"\"",
            "",
            "",
            "class BulkDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being deleted",
            "    form: The form class used to delete objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(\"nautobot.views.BulkDeleteView\")",
            "        model = self.queryset.model",
            "",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = [obj.pk for obj in self.filterset(request.GET, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        form_cls = self.get_form()",
            "",
            "        if \"_confirm\" in request.POST:",
            "            form = form_cls(request.POST)",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                # Delete objects",
            "                queryset = self.queryset.filter(pk__in=pk_list)",
            "",
            "                self.perform_pre_delete(request, queryset)",
            "                try:",
            "                    _, deleted_info = queryset.delete()",
            "                    deleted_count = deleted_info[model._meta.label]",
            "                except ProtectedError as e:",
            "                    logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "                    handle_protectederror(queryset, request, e)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                logger.info(msg)",
            "                messages.success(request, msg)",
            "                return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = form_cls(",
            "                initial={",
            "                    \"pk\": pk_list,",
            "                    \"return_url\": self.get_return_url(request),",
            "                }",
            "            )",
            "",
            "        # Retrieve objects being deleted",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"table\": table,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        pass",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "    def get_form(self):",
            "        \"\"\"",
            "        Provide a standard bulk delete form if none has been specified for the view",
            "        \"\"\"",
            "",
            "        class BulkDeleteForm(ConfirmationForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput)",
            "",
            "        if self.form:",
            "            return self.form",
            "",
            "        return BulkDeleteForm",
            "",
            "",
            "#",
            "# Device/VirtualMachine components",
            "#",
            "",
            "",
            "# TODO: Replace with BulkCreateView",
            "class ComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a Device or VirtualMachine.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = self.form(initial=request.GET)",
            "        model_form = self.model_form(request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"model_form\": model_form,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.ComponentCreateView\")",
            "        form = self.form(request.POST, initial=request.GET)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            new_components = []",
            "            data = deepcopy(request.POST)",
            "",
            "            names = form.cleaned_data[\"name_pattern\"]",
            "            labels = form.cleaned_data.get(\"label_pattern\")",
            "            for i, name in enumerate(names):",
            "                label = labels[i] if labels else None",
            "                # Initialize the individual component form",
            "                data[\"name\"] = name",
            "                data[\"label\"] = label",
            "                if hasattr(form, \"get_iterative_data\"):",
            "                    data.update(form.get_iterative_data(i))",
            "                component_form = self.model_form(data)",
            "",
            "                if component_form.is_valid():",
            "                    new_components.append(component_form)",
            "                else:",
            "                    for field, errors in component_form.errors.as_data().items():",
            "                        # Assign errors on the child form's name/label field to name_pattern/label_pattern on the parent form",
            "                        if field == \"name\":",
            "                            field = \"name_pattern\"",
            "                        elif field == \"label\":",
            "                            field = \"label_pattern\"",
            "                        for e in errors:",
            "                            err_str = \", \".join(e)",
            "                            form.add_error(field, f\"{name}: {err_str}\")",
            "",
            "            if not form.errors:",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Create the new components",
            "                        new_objs = []",
            "                        for component_form in new_components:",
            "                            obj = component_form.save()",
            "                            new_objs.append(obj)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    messages.success(",
            "                        request,",
            "                        f\"Added {len(new_components)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                    )",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.get_full_path())",
            "                    else:",
            "                        return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a set of Devices or VirtualMachines.",
            "    \"\"\"",
            "",
            "    parent_model = None",
            "    parent_field = None",
            "    form = None",
            "    queryset = None",
            "    model_form = None",
            "    filterset = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_add_component.html\"",
            "",
            "    def get_required_permission(self):",
            "        return f\"dcim.add_{self.queryset.model._meta.model_name}\"",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(\"nautobot.views.BulkComponentCreateView\")",
            "        parent_model_name = self.parent_model._meta.verbose_name_plural",
            "        model_name = self.queryset.model._meta.verbose_name_plural",
            "        model = self.queryset.model",
            "",
            "        # Are we editing *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\") and self.filterset is not None:",
            "            pk_list = [obj.pk for obj in self.filterset(request.GET, self.parent_model.objects.only(\"pk\")).qs]",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        selected_objects = self.parent_model.objects.filter(pk__in=pk_list)",
            "        if not selected_objects:",
            "            messages.warning(",
            "                request,",
            "                f\"No {self.parent_model._meta.verbose_name_plural} were selected.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        table = self.table(selected_objects)",
            "",
            "        if \"_create\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                new_components = []",
            "                data = deepcopy(form.cleaned_data)",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        for obj in data[\"pk\"]:",
            "                            names = data[\"name_pattern\"]",
            "                            labels = data[\"label_pattern\"] if \"label_pattern\" in data else None",
            "                            for i, name in enumerate(names):",
            "                                label = labels[i] if labels else None",
            "",
            "                                component_data = {",
            "                                    self.parent_field: obj.pk,",
            "                                    \"name\": name,",
            "                                    \"label\": label,",
            "                                }",
            "                                component_data.update(data)",
            "                                component_form = self.model_form(component_data)",
            "                                if component_form.is_valid():",
            "                                    instance = component_form.save()",
            "                                    logger.debug(f\"Created {instance} on {instance.parent}\")",
            "                                    new_components.append(instance)",
            "                                else:",
            "                                    for (",
            "                                        field,",
            "                                        errors,",
            "                                    ) in component_form.errors.as_data().items():",
            "                                        for e in errors:",
            "                                            err_str = \", \".join(e)",
            "                                            form.add_error(",
            "                                                field,",
            "                                                f\"{obj} {name}: {err_str}\",",
            "                                            )",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_components]).count() != len(",
            "                            new_components",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                except IntegrityError:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "                if not form.errors:",
            "                    msg = f\"Added {len(new_components)} {model_name} to {len(form.cleaned_data['pk'])} {parent_model_name}.\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = self.form(model, initial={\"pk\": pk_list})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"parent_model_name\": parent_model_name,",
            "                \"model_name\": model_name,",
            "                \"table\": table,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": [],
            "21": [],
            "252": [
                "ObjectListView",
                "get"
            ],
            "464": [
                "ObjectEditView",
                "post"
            ],
            "466": [
                "ObjectEditView",
                "post"
            ],
            "467": [
                "ObjectEditView",
                "post"
            ],
            "797": [
                "ObjectImportView",
                "post"
            ]
        },
        "addLocation": []
    },
    "nautobot/core/views/mixins.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from django.shortcuts import get_object_or_404, redirect"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from django.template.loader import select_template, TemplateDoesNotExist"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django.utils.http import is_safe_url"
            },
            "3": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "6": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.views.generic.edit import FormView"
            },
            "7": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from rest_framework import mixins, exceptions"
            },
            "9": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "             if not self.filterset.is_valid():"
            },
            "10": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "                 messages.error("
            },
            "11": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "                     self.request,"
            },
            "12": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mark_safe(f\"Invalid filters were specified: {self.filterset.errors}\"),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+                    format_html(\"Invalid filters were specified: {}\", self.filterset.errors),"
            },
            "14": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "                 )"
            },
            "15": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "                 queryset = queryset.none()"
            },
            "16": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         return queryset"
            },
            "17": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "             msg = f'{\"Created\" if object_created else \"Modified\"} {queryset.model._meta.verbose_name}'"
            },
            "18": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": 624,
                "PatchRowcode": "             self.logger.info(f\"{msg} {obj} (PK: {obj.pk})\")"
            },
            "19": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "             if hasattr(obj, \"get_absolute_url\"):"
            },
            "20": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 626,
                "PatchRowcode": "+                msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)"
            },
            "22": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "             else:"
            },
            "23": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = f\"{msg} { escape(obj)}\""
            },
            "24": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            messages.success(request, mark_safe(msg))"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+                msg = format_html(\"{} {}\", msg, obj)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 629,
                "PatchRowcode": "+            messages.success(request, msg)"
            },
            "27": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 630,
                "PatchRowcode": "             if \"_addanother\" in request.POST:"
            },
            "28": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 631,
                "PatchRowcode": "                 # If the object has clone_fields, pre-populate a new instance of the form"
            },
            "29": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 632,
                "PatchRowcode": "                 if hasattr(obj, \"clone_fields\"):"
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.auth.mixins import AccessMixin",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput, Textarea",
            "from django.http import HttpResponse",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.loader import select_template, TemplateDoesNotExist",
            "from django.utils.http import is_safe_url",
            "from django.utils.html import escape",
            "from django.utils.safestring import mark_safe",
            "from django.views.generic.edit import FormView",
            "",
            "from rest_framework import mixins, exceptions",
            "from rest_framework.decorators import action as drf_action",
            "from rest_framework.parsers import FormParser, MultiPartParser",
            "from rest_framework.response import Response",
            "from rest_framework.viewsets import GenericViewSet",
            "",
            "from drf_spectacular.utils import extend_schema",
            "",
            "from nautobot.core.api.views import BulkDestroyModelMixin, BulkUpdateModelMixin",
            "from nautobot.extras.models import CustomField, ExportTemplate",
            "from nautobot.extras.forms import NoteForm",
            "from nautobot.extras.tables import ObjectChangeTable, NoteTable",
            "from nautobot.utilities.error_handlers import handle_protectederror",
            "from nautobot.utilities.forms import (",
            "    BootstrapMixin,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.core.views.renderers import NautobotHTMLRenderer",
            "from nautobot.utilities.utils import (",
            "    csv_format,",
            "    get_filterable_params_from_filter_params,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.utilities.views import GetReturnURLMixin",
            "",
            "PERMISSIONS_ACTION_MAP = {",
            "    \"list\": \"view\",",
            "    \"retrieve\": \"view\",",
            "    \"destroy\": \"delete\",",
            "    \"create\": \"add\",",
            "    \"update\": \"change\",",
            "    \"bulk_create\": \"add\",",
            "    \"bulk_destroy\": \"delete\",",
            "    \"bulk_update\": \"change\",",
            "    \"changelog\": \"view\",",
            "    \"notes\": \"view\",",
            "}",
            "",
            "",
            "@extend_schema(exclude=True)",
            "class NautobotViewSetMixin(GenericViewSet, AccessMixin, GetReturnURLMixin, FormView):",
            "    \"\"\"",
            "    NautobotViewSetMixin is an aggregation of various mixins from DRF, Django and Nautobot to acheive the desired behavior pattern for NautobotUIViewSet",
            "    \"\"\"",
            "",
            "    renderer_classes = [NautobotHTMLRenderer]",
            "    logger = logging.getLogger(__name__)",
            "    lookup_field = \"slug\"",
            "    # Attributes that need to be specified: form_class, queryset, serializer_class, table_class for most mixins.",
            "    # filterset and filter_params will be initialized in filter_queryset() in ObjectListViewMixin",
            "    filter_params = None",
            "    filterset = None",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    form_class = None",
            "    create_form_class = None",
            "    update_form_class = None",
            "    parser_classes = [FormParser, MultiPartParser]",
            "    queryset = None",
            "    # serializer_class has to be specified to eliminate the need to override retrieve() in the RetrieveModelMixin for now.",
            "    serializer_class = None",
            "    table_class = None",
            "    notes_form_class = NoteForm",
            "",
            "    def get_permissions_for_model(self, model, actions):",
            "        \"\"\"",
            "        Resolve the named permissions for a given model (or instance) and a list of actions (e.g. view or add).",
            "",
            "        :param model: A model or instance",
            "        :param actions: A list of actions to perform on the model",
            "        \"\"\"",
            "        permissions = []",
            "        for action in actions:",
            "            if action not in (\"view\", \"add\", \"change\", \"delete\"):",
            "                raise ValueError(f\"Unsupported action: {action}\")",
            "            permissions.append(f\"{model._meta.app_label}.{action}_{model._meta.model_name}\")",
            "        return permissions",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Obtain the permissions needed to perform certain actions on a model.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        try:",
            "            permissions = [PERMISSIONS_ACTION_MAP[self.action]]",
            "        except KeyError:",
            "            messages.error(",
            "                self.request,",
            "                \"This action is not permitted. Please use the buttons at the bottom of the table for Bulk Delete and Bulk Update\",",
            "            )",
            "        return self.get_permissions_for_model(queryset.model, permissions)",
            "",
            "    def check_permissions(self, request):",
            "        \"\"\"",
            "        Check whether the user has the permissions needed to perform certain actions.",
            "        \"\"\"",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "        # Check that the user has been granted the required permission(s) one by one.",
            "        # In case the permission has `message` or `code`` attribute, we want to include those information in the permission_denied error.",
            "        for permission in permission_required:",
            "            # If the user does not have the permission required, we raise DRF's `NotAuthenticated` or `PermissionDenied` exception",
            "            # which will be handled by self.handle_no_permission() in the UI appropriately in the dispatch() method",
            "            # Cast permission to a list since has_perms() takes a list type parameter.",
            "            if not user.has_perms([permission]):",
            "                self.permission_denied(",
            "                    request,",
            "                    message=getattr(permission, \"message\", None),",
            "                    code=getattr(permission, \"code\", None),",
            "                )",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Override the default dispatch() method to check permissions first.",
            "        Used to determine whether the user has permissions to a view and object-level permissions.",
            "        Using AccessMixin handle_no_permission() to deal with Object-Level permissions and API-Level permissions in one pass.",
            "        \"\"\"",
            "        # self.initialize_request() converts a WSGI request and returns an API request object which can be passed into self.check_permissions()",
            "        # If the user is not authenticated or does not have the permission to perform certain actions,",
            "        # DRF NotAuthenticated or PermissionDenied exception can be raised appropriately and handled by self.handle_no_permission() in the UI.",
            "        # initialize_request() also instantiates self.action which is needed for permission checks.",
            "        api_request = self.initialize_request(request, *args, **kwargs)",
            "        try:",
            "            self.check_permissions(api_request)",
            "        # check_permissions() could raise NotAuthenticated and PermissionDenied Error.",
            "        # We handle them by a single except statement since self.handle_no_permission() is able to handle both errors",
            "        except (exceptions.NotAuthenticated, exceptions.PermissionDenied):",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_table_class(self):",
            "        # Check if self.table_class is specified in the ModelViewSet before performing subsequent actions",
            "        # If not, display an error message",
            "        if self.action == \"notes\":",
            "            return NoteTable",
            "        elif self.action == \"changelog\":",
            "            return ObjectChangeTable",
            "",
            "        assert (",
            "            self.table_class is not None",
            "        ), f\"'{self.__class__.__name__}' should include a `table_class` attribute for bulk operations\"",
            "",
            "        return self.table_class",
            "",
            "    def _process_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_destroy_form() is not implemented\")",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy objects after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_destroy_form() is not implemented\")",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_create_or_update_form() is not implemented\")",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to edit objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_update_form() is not implemented\")",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        \"\"\"",
            "        Helper method to create objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_create_form() is not implemented\")",
            "",
            "    def _handle_object_does_not_exist(self, form):",
            "        msg = \"Object import failed due to object-level permissions violation\"",
            "        self.logger.debug(msg)",
            "        self.has_error = True",
            "        form.add_error(None, msg)",
            "        return form",
            "",
            "    def _handle_not_implemented_error(self):",
            "        # Blanket handler for NotImplementedError raised by form helper functions",
            "        msg = \"Please provide the appropriate mixin before using this helper function\"",
            "        messages.error(self.request, msg)",
            "        self.has_error = True",
            "",
            "    def _handle_validation_error(self, e):",
            "        # For bulk_create/bulk_update view, self.obj is not set since there are multiple",
            "        # The errors will be rendered on the form itself.",
            "        if self.action not in [\"bulk_create\", \"bulk_update\"]:",
            "            messages.error(self.request, f\"{self.obj} failed validation: {e}\")",
            "        self.has_error = True",
            "",
            "    def form_valid(self, form):",
            "        \"\"\"",
            "        Handle valid forms and redirect to success_url.",
            "        \"\"\"",
            "        request = self.request",
            "        self.has_error = False",
            "        queryset = self.get_queryset()",
            "        try:",
            "            if self.action == \"destroy\":",
            "                self._process_destroy_form(form)",
            "            elif self.action == \"bulk_destroy\":",
            "                self._process_bulk_destroy_form(form)",
            "            elif self.action in [\"create\", \"update\"]:",
            "                self._process_create_or_update_form(form)",
            "            elif self.action == \"bulk_update\":",
            "                self._process_bulk_update_form(form)",
            "            elif self.action == \"bulk_create\":",
            "                self.obj_table = self._process_bulk_create_form(form)",
            "        except ValidationError as e:",
            "            self._handle_validation_error(e)",
            "        except ObjectDoesNotExist:",
            "            form = self._handle_object_does_not_exist(form)",
            "        except NotImplementedError:",
            "            self._handle_not_implemented_error()",
            "",
            "        if not self.has_error:",
            "            self.logger.debug(\"Form validation was successful\")",
            "            if self.action == \"bulk_create\":",
            "                return Response(",
            "                    {",
            "                        \"table\": self.obj_table,",
            "                        \"template\": \"import_success.html\",",
            "                    }",
            "                )",
            "            return super().form_valid(form)",
            "        else:",
            "            # render the form with the error message.",
            "            data = {}",
            "            if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "                pk_list = self.pk_list",
            "                table_class = self.get_table_class()",
            "                table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "                if not table.rows:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                    )",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                data.update({\"table\": table})",
            "            data.update({\"form\": form})",
            "            return Response(data)",
            "",
            "    def form_invalid(self, form):",
            "        \"\"\"",
            "        Handle invalid forms.",
            "        \"\"\"",
            "        data = {}",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "            pk_list = self.pk_list",
            "            table_class = self.get_table_class()",
            "            table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "            if not table.rows:",
            "                messages.warning(",
            "                    request,",
            "                    f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                )",
            "                return redirect(self.get_return_url(request))",
            "",
            "            data = {",
            "                \"table\": table,",
            "            }",
            "        data.update({\"form\": form})",
            "        return Response(data)",
            "",
            "    def get_object(self):",
            "        \"\"\"",
            "        Returns the object the view is displaying.",
            "        You may want to override this if you need to provide non-standard",
            "        queryset lookups.  Eg if objects are referenced using multiple",
            "        keyword arguments in the url conf.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        # Perform the lookup filtering.",
            "        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field",
            "        if lookup_url_kwarg not in self.kwargs:",
            "            return queryset.model()",
            "        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}",
            "        obj = get_object_or_404(queryset, **filter_kwargs)",
            "",
            "        return obj",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset_class())",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Get the list of items for this view.",
            "        This must be an iterable, and may be a queryset.",
            "        Defaults to using `self.queryset`.",
            "        This method should always be used rather than accessing `self.queryset`",
            "        directly, as `self.queryset` gets evaluated only once, and those results",
            "        are cached for all subsequent requests.",
            "        Override the original `get_queryset()` to apply permission specific to the user and action.",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        return queryset.restrict(self.request.user, PERMISSIONS_ACTION_MAP[self.action])",
            "",
            "    def get_extra_context(self, request, instance=None):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "        request: The current request",
            "        instance: The object being viewed",
            "        \"\"\"",
            "        return {}",
            "",
            "    def get_template_name(self):",
            "        # Use \"<app>/<model>_<action> if available, else fall back to generic templates",
            "        queryset = self.get_queryset()",
            "        model_opts = queryset.model._meta",
            "        app_label = model_opts.app_label",
            "        action = self.action",
            "",
            "        try:",
            "            template_name = f\"{app_label}/{model_opts.model_name}_{action}.html\"",
            "            select_template([template_name])",
            "        except TemplateDoesNotExist:",
            "            try:",
            "                if action == \"create\":",
            "                    # When the action is `create`, try {object}_update.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_create.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_update.html\"",
            "                    select_template([template_name])",
            "                elif action == \"update\":",
            "                    # When the action is `update`, try {object}_create.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_update.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_create.html\"",
            "                    select_template([template_name])",
            "                else:",
            "                    # No special case fallback, fall back to generic/object_{action}.html",
            "                    raise TemplateDoesNotExist(\"\")",
            "            except TemplateDoesNotExist:",
            "                template_name = f\"generic/object_{action}.html\"",
            "        return template_name",
            "",
            "    def get_form(self, *args, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form for different views if specified.",
            "        If not, return instantiated form using form_class.",
            "        \"\"\"",
            "        form = getattr(self, f\"{self.action}_form\", None)",
            "        if not form:",
            "            form_class = self.get_form_class()",
            "            if not form_class:",
            "                self.logger.debug(f\"{self.action}_form_class is not defined\")",
            "                return None",
            "            form = form_class(*args, **kwargs)",
            "        return form",
            "",
            "    def get_form_class(self, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form_class for different views.",
            "        \"\"\"",
            "",
            "        if self.action in [\"create\", \"update\"]:",
            "            if getattr(self, f\"{self.action}_form_class\"):",
            "                form_class = getattr(self, f\"{self.action}_form_class\")",
            "            else:",
            "                form_class = getattr(self, \"form_class\", None)",
            "        elif self.action == \"bulk_create\":",
            "",
            "            class BulkCreateForm(BootstrapMixin, Form):",
            "                csv_data = CSVDataField(",
            "                    from_form=self.bulk_create_form_class, widget=Textarea(attrs=self.bulk_create_widget_attrs)",
            "                )",
            "                csv_file = CSVFileField(from_form=self.bulk_create_form_class)",
            "",
            "            form_class = BulkCreateForm",
            "        else:",
            "            form_class = getattr(self, f\"{self.action}_form_class\", None)",
            "",
            "        if not form_class:",
            "            if self.action == \"bulk_destroy\":",
            "                queryset = self.get_queryset()",
            "",
            "                class BulkDestroyForm(ConfirmationForm):",
            "                    pk = ModelMultipleChoiceField(queryset=queryset, widget=MultipleHiddenInput)",
            "",
            "                return BulkDestroyForm",
            "            else:",
            "                # Check for request first and then kwargs for form_class specified.",
            "                form_class = self.request.data.get(\"form_class\", None)",
            "                if not form_class:",
            "                    form_class = kwargs.get(\"form_class\", None)",
            "        return form_class",
            "",
            "    def form_save(self, form, **kwargs):",
            "        \"\"\"",
            "        Generic method to save the object from form.",
            "        Should be overriden by user if customization is needed.",
            "        \"\"\"",
            "        return form.save()",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        queryset = self.get_queryset()",
            "        return queryset.all()",
            "",
            "",
            "class ObjectDetailViewMixin(NautobotViewSetMixin, mixins.RetrieveModelMixin):",
            "    \"\"\"",
            "    UI mixin to retrieve a model instance.",
            "    \"\"\"",
            "",
            "",
            "class ObjectListViewMixin(NautobotViewSetMixin, mixins.ListModelMixin):",
            "    \"\"\"",
            "    UI mixin to list a model queryset",
            "    \"\"\"",
            "",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def filter_queryset(self, queryset):",
            "        \"\"\"",
            "        Filter a query with request querystrings.",
            "        \"\"\"",
            "        if self.filterset_class is not None:",
            "            self.filter_params = self.get_filter_params(self.request)",
            "            self.filterset = self.filterset_class(self.filter_params, queryset)",
            "            queryset = self.filterset.qs",
            "            if not self.filterset.is_valid():",
            "                messages.error(",
            "                    self.request,",
            "                    mark_safe(f\"Invalid filters were specified: {self.filterset.errors}\"),",
            "                )",
            "                queryset = queryset.none()",
            "        return queryset",
            "",
            "    def check_for_export(self, request, model, content_type):",
            "        # Check for export template rendering",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"nautobot_{queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Fall back to built-in CSV formatting if export requested but no template specified",
            "        elif \"export\" in request.GET and hasattr(model, \"to_csv\"):",
            "            response = HttpResponse(self.queryset_to_csv(), content_type=\"text/csv\")",
            "            filename = f\"nautobot_{queryset.model._meta.verbose_name_plural}.csv\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        return None",
            "",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        yaml_data = [obj.to_yaml() for obj in queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def queryset_to_csv(self):",
            "        \"\"\"",
            "        Export the queryset of objects as comma-separated value (CSV), using the model's to_csv() method.",
            "        \"\"\"",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        csv_data = []",
            "        custom_fields = []",
            "        # Start with the column headers",
            "        headers = queryset.model.csv_headers.copy()",
            "",
            "        # Add custom field headers, if any",
            "        if hasattr(queryset.model, \"_custom_field_data\"):",
            "            for custom_field in CustomField.objects.get_for_model(queryset.model):",
            "                headers.append(\"cf_\" + custom_field.slug)",
            "                custom_fields.append(custom_field.name)",
            "",
            "        csv_data.append(\",\".join(headers))",
            "",
            "        # Iterate through the queryset appending each object",
            "        for obj in queryset:",
            "            data = obj.to_csv()",
            "",
            "            for custom_field in custom_fields:",
            "                data += (obj.cf.get(custom_field, \"\"),)",
            "",
            "            csv_data.append(csv_format(data))",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def list(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        List the model instances.",
            "        \"\"\"",
            "        context = {}",
            "        if \"export\" in request.GET:",
            "            queryset = self.get_queryset()",
            "            model = queryset.model",
            "            content_type = ContentType.objects.get_for_model(model)",
            "            response = self.check_for_export(request, model, content_type)",
            "            if response is not None:",
            "                return response",
            "        return Response(context)",
            "",
            "",
            "class ObjectDestroyViewMixin(NautobotViewSetMixin, mixins.DestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to destroy a model instance.",
            "    \"\"\"",
            "",
            "    destroy_form_class = ConfirmationForm",
            "",
            "    def _process_destroy_form(self, form):",
            "        request = self.request",
            "        obj = self.obj",
            "        queryset = self.get_queryset()",
            "        try:",
            "            with transaction.atomic():",
            "                obj.delete()",
            "                msg = f\"Deleted {queryset.model._meta.verbose_name} {obj}\"",
            "                self.logger.info(msg)",
            "                messages.success(request, msg)",
            "                self.success_url = self.get_return_url(request, obj)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "            handle_protectederror([obj], request, e)",
            "            self.success_url = obj.get_absolute_url()",
            "",
            "    def destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectDeleteConfirmationForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_destroy() which validates the form and perform the action of delete.",
            "        Override to add more variables to Response",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_destroy(request, **kwargs)",
            "        return Response(context)",
            "",
            "    def perform_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        Function to validate the ObjectDeleteConfirmationForm and to delete the object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectEditViewMixin(NautobotViewSetMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to create or update a model instance.",
            "    \"\"\"",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            object_created = not form.instance.present_in_database",
            "            obj = self.form_save(form)",
            "",
            "            # Check that the new object conforms with any assigned object-level permissions",
            "            queryset.get(pk=obj.pk)",
            "",
            "            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                form.save_note(instance=obj, user=request.user)",
            "",
            "            msg = f'{\"Created\" if object_created else \"Modified\"} {queryset.model._meta.verbose_name}'",
            "            self.logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "            if hasattr(obj, \"get_absolute_url\"):",
            "                msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'",
            "            else:",
            "                msg = f\"{msg} { escape(obj)}\"",
            "            messages.success(request, mark_safe(msg))",
            "            if \"_addanother\" in request.POST:",
            "                # If the object has clone_fields, pre-populate a new instance of the form",
            "                if hasattr(obj, \"clone_fields\"):",
            "                    url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                    self.success_url = url",
            "                self.success_url = request.get_full_path()",
            "            else:",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    self.success_url = return_url",
            "                else:",
            "                    self.success_url = self.get_return_url(request, obj)",
            "",
            "    def create(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_create() which validates the form and perform the action of create.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_create(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's CreateModelMixin.perform_create(self, serializer) API",
            "    def perform_create(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectForm and to create a new object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    def update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectEditForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_update() which validates the form and perform the action of update/partial_update of an existing object.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_update(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's UpdateModelMixin.perform_update(self, serializer) API",
            "    def perform_update(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectEditForm and to update/partial_update an existing object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkDestroyViewMixin(NautobotViewSetMixin, BulkDestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk destroy model instances.",
            "    \"\"\"",
            "",
            "    bulk_destroy_form_class = None",
            "    filterset_class = None",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        request = self.request",
            "        pk_list = self.pk_list",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Delete objects",
            "        queryset = queryset.filter(pk__in=pk_list)",
            "",
            "        try:",
            "            with transaction.atomic():",
            "                deleted_count = queryset.delete()[1][model._meta.label]",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                self.logger.info(msg)",
            "                self.success_url = self.get_return_url(request)",
            "                messages.success(request, msg)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "            handle_protectederror(queryset, request, e)",
            "            self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_destroy().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk destroy.",
            "        \"\"\"",
            "        return self.perform_bulk_destroy(request, **kwargs)",
            "",
            "    def perform_bulk_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        request.POST \"_delete\": Function to render the user selection of objects in a table form/BulkDestroyConfirmationForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_confirm\": Function to validate the table form/BulkDestroyConfirmationForm and to perform the action of bulk destroy. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset_class is not None:",
            "                self.pk_list = [obj.pk for obj in self.filterset_class(request.POST, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                self.pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        form_class = self.get_form_class(**kwargs)",
            "        data = {}",
            "        if \"_confirm\" in request.POST:",
            "            form = form_class(request.POST)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectBulkCreateViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to bulk create model instances.",
            "    \"\"\"",
            "",
            "    bulk_create_active_tab = \"csv-data\"",
            "    bulk_create_form_class = None",
            "    bulk_create_widget_attrs = {}",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        # Iterate through CSV data and bind each row to a new model form instance.",
            "        new_objs = []",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            if request.FILES:",
            "                field_name = \"csv_file\"",
            "                # Set the bulk_create_active_tab to \"csv-file\"",
            "                # In case the form validation fails, the user will be redirected",
            "                # to the tab with errors rendered on the form.",
            "                self.bulk_create_active_tab = \"csv-file\"",
            "            else:",
            "                field_name = \"csv_data\"",
            "            headers, records = form.cleaned_data[field_name]",
            "            for row, data in enumerate(records, start=1):",
            "                obj_form = self.bulk_create_form_class(data, headers=headers)",
            "                restrict_form_fields(obj_form, request.user)",
            "",
            "                if obj_form.is_valid():",
            "                    obj = self.form_save(obj_form)",
            "                    new_objs.append(obj)",
            "                else:",
            "                    for field, err in obj_form.errors.items():",
            "                        form.add_error(field_name, f\"Row {row} {field}: {err[0]}\")",
            "                    raise ValidationError(\"\")",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                raise ObjectDoesNotExist",
            "",
            "        # Compile a table containing the imported objects",
            "        table_class = self.get_table_class()",
            "        obj_table = table_class(new_objs)",
            "        if new_objs:",
            "            msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(request, msg)",
            "        return obj_table",
            "",
            "    def bulk_create(self, request, *args, **kwargs):",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_bulk_create(request)",
            "        return Response(context)",
            "",
            "    def perform_bulk_create(self, request):",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST, request.FILES)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkUpdateViewMixin(NautobotViewSetMixin, BulkUpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk update model instances.",
            "    \"\"\"",
            "",
            "    filterset_class = None",
            "    bulk_update_form_class = None",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        form_custom_fields = getattr(form, \"custom_fields\", [])",
            "        form_relationships = getattr(form, \"relationships\", [])",
            "        # Standard fields are those that are intrinsic to self.model in the form",
            "        # Relationships, custom fields, object_note are extrinsic fields",
            "        # PK is used to identify an existing instance, not to modify the object",
            "        standard_fields = [",
            "            field",
            "            for field in form.fields",
            "            if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "        ]",
            "        nullified_fields = request.POST.getlist(\"_nullify\")",
            "        form_cf_to_key = {f\"cf_{cf.slug}\": cf.name for cf in CustomField.objects.get_for_model(model)}",
            "        with transaction.atomic():",
            "            updated_objects = []",
            "            for obj in queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                self.obj = obj",
            "                # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                for name in standard_fields:",
            "                    try:",
            "                        model_field = model._meta.get_field(name)",
            "                    except FieldDoesNotExist:",
            "                        # This form field is used to modify a field rather than set its value directly",
            "                        model_field = None",
            "                    # Handle nullification",
            "                    if name in form.nullable_fields and name in nullified_fields:",
            "                        if isinstance(model_field, ManyToManyField):",
            "                            getattr(obj, name).set([])",
            "                        else:",
            "                            setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "                    # ManyToManyFields",
            "                    elif isinstance(model_field, ManyToManyField):",
            "                        if form.cleaned_data[name]:",
            "                            getattr(obj, name).set(form.cleaned_data[name])",
            "                    # Normal fields",
            "                    elif form.cleaned_data[name] not in (None, \"\"):",
            "                        setattr(obj, name, form.cleaned_data[name])",
            "                # Update custom fields",
            "                for field_name in form_custom_fields:",
            "                    if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                        obj.cf[form_cf_to_key[field_name]] = None",
            "                    elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                        obj.cf[form_cf_to_key[field_name]] = form.cleaned_data[field_name]",
            "",
            "                obj.validated_save()",
            "                updated_objects.append(obj)",
            "                self.logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                # Add/remove tags",
            "                if form.cleaned_data.get(\"add_tags\", None):",
            "                    obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                if form.cleaned_data.get(\"remove_tags\", None):",
            "                    obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                    # Add/remove relationship associations",
            "                    form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(updated_objects):",
            "                raise ObjectDoesNotExist",
            "        if updated_objects:",
            "            msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(self.request, msg)",
            "        self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_update().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk update.",
            "        \"\"\"",
            "        return self.perform_bulk_update(request, **kwargs)",
            "",
            "    # TODO: this conflicts with BulkUpdateModelMixin.perform_bulk_update(self, objects, update_data, partial)",
            "    def perform_bulk_update(self, request, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        request.POST \"_edit\": Function to render the user selection of objects in a table form/BulkUpdateForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_apply\": Function to validate the table form/BulkUpdateForm and to perform the action of bulk update. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset_class is not None:",
            "                self.pk_list = [obj.pk for obj in self.filterset_class(request.POST, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                self.pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        data = {}",
            "        form_class = self.get_form_class()",
            "        if \"_apply\" in request.POST:",
            "            self.kwargs = kwargs",
            "            form = form_class(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected to update.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectChangeLogViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to list a model's changelog queryset",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def changelog(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)",
            "",
            "",
            "class ObjectNotesViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI Mixin for an Object's Notes.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def notes(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.auth.mixins import AccessMixin",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput, Textarea",
            "from django.http import HttpResponse",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.loader import select_template, TemplateDoesNotExist",
            "from django.utils.http import is_safe_url",
            "from django.utils.html import format_html",
            "from django.views.generic.edit import FormView",
            "",
            "from rest_framework import mixins, exceptions",
            "from rest_framework.decorators import action as drf_action",
            "from rest_framework.parsers import FormParser, MultiPartParser",
            "from rest_framework.response import Response",
            "from rest_framework.viewsets import GenericViewSet",
            "",
            "from drf_spectacular.utils import extend_schema",
            "",
            "from nautobot.core.api.views import BulkDestroyModelMixin, BulkUpdateModelMixin",
            "from nautobot.extras.models import CustomField, ExportTemplate",
            "from nautobot.extras.forms import NoteForm",
            "from nautobot.extras.tables import ObjectChangeTable, NoteTable",
            "from nautobot.utilities.error_handlers import handle_protectederror",
            "from nautobot.utilities.forms import (",
            "    BootstrapMixin,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.core.views.renderers import NautobotHTMLRenderer",
            "from nautobot.utilities.utils import (",
            "    csv_format,",
            "    get_filterable_params_from_filter_params,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.utilities.views import GetReturnURLMixin",
            "",
            "PERMISSIONS_ACTION_MAP = {",
            "    \"list\": \"view\",",
            "    \"retrieve\": \"view\",",
            "    \"destroy\": \"delete\",",
            "    \"create\": \"add\",",
            "    \"update\": \"change\",",
            "    \"bulk_create\": \"add\",",
            "    \"bulk_destroy\": \"delete\",",
            "    \"bulk_update\": \"change\",",
            "    \"changelog\": \"view\",",
            "    \"notes\": \"view\",",
            "}",
            "",
            "",
            "@extend_schema(exclude=True)",
            "class NautobotViewSetMixin(GenericViewSet, AccessMixin, GetReturnURLMixin, FormView):",
            "    \"\"\"",
            "    NautobotViewSetMixin is an aggregation of various mixins from DRF, Django and Nautobot to acheive the desired behavior pattern for NautobotUIViewSet",
            "    \"\"\"",
            "",
            "    renderer_classes = [NautobotHTMLRenderer]",
            "    logger = logging.getLogger(__name__)",
            "    lookup_field = \"slug\"",
            "    # Attributes that need to be specified: form_class, queryset, serializer_class, table_class for most mixins.",
            "    # filterset and filter_params will be initialized in filter_queryset() in ObjectListViewMixin",
            "    filter_params = None",
            "    filterset = None",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    form_class = None",
            "    create_form_class = None",
            "    update_form_class = None",
            "    parser_classes = [FormParser, MultiPartParser]",
            "    queryset = None",
            "    # serializer_class has to be specified to eliminate the need to override retrieve() in the RetrieveModelMixin for now.",
            "    serializer_class = None",
            "    table_class = None",
            "    notes_form_class = NoteForm",
            "",
            "    def get_permissions_for_model(self, model, actions):",
            "        \"\"\"",
            "        Resolve the named permissions for a given model (or instance) and a list of actions (e.g. view or add).",
            "",
            "        :param model: A model or instance",
            "        :param actions: A list of actions to perform on the model",
            "        \"\"\"",
            "        permissions = []",
            "        for action in actions:",
            "            if action not in (\"view\", \"add\", \"change\", \"delete\"):",
            "                raise ValueError(f\"Unsupported action: {action}\")",
            "            permissions.append(f\"{model._meta.app_label}.{action}_{model._meta.model_name}\")",
            "        return permissions",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Obtain the permissions needed to perform certain actions on a model.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        try:",
            "            permissions = [PERMISSIONS_ACTION_MAP[self.action]]",
            "        except KeyError:",
            "            messages.error(",
            "                self.request,",
            "                \"This action is not permitted. Please use the buttons at the bottom of the table for Bulk Delete and Bulk Update\",",
            "            )",
            "        return self.get_permissions_for_model(queryset.model, permissions)",
            "",
            "    def check_permissions(self, request):",
            "        \"\"\"",
            "        Check whether the user has the permissions needed to perform certain actions.",
            "        \"\"\"",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "        # Check that the user has been granted the required permission(s) one by one.",
            "        # In case the permission has `message` or `code`` attribute, we want to include those information in the permission_denied error.",
            "        for permission in permission_required:",
            "            # If the user does not have the permission required, we raise DRF's `NotAuthenticated` or `PermissionDenied` exception",
            "            # which will be handled by self.handle_no_permission() in the UI appropriately in the dispatch() method",
            "            # Cast permission to a list since has_perms() takes a list type parameter.",
            "            if not user.has_perms([permission]):",
            "                self.permission_denied(",
            "                    request,",
            "                    message=getattr(permission, \"message\", None),",
            "                    code=getattr(permission, \"code\", None),",
            "                )",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Override the default dispatch() method to check permissions first.",
            "        Used to determine whether the user has permissions to a view and object-level permissions.",
            "        Using AccessMixin handle_no_permission() to deal with Object-Level permissions and API-Level permissions in one pass.",
            "        \"\"\"",
            "        # self.initialize_request() converts a WSGI request and returns an API request object which can be passed into self.check_permissions()",
            "        # If the user is not authenticated or does not have the permission to perform certain actions,",
            "        # DRF NotAuthenticated or PermissionDenied exception can be raised appropriately and handled by self.handle_no_permission() in the UI.",
            "        # initialize_request() also instantiates self.action which is needed for permission checks.",
            "        api_request = self.initialize_request(request, *args, **kwargs)",
            "        try:",
            "            self.check_permissions(api_request)",
            "        # check_permissions() could raise NotAuthenticated and PermissionDenied Error.",
            "        # We handle them by a single except statement since self.handle_no_permission() is able to handle both errors",
            "        except (exceptions.NotAuthenticated, exceptions.PermissionDenied):",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_table_class(self):",
            "        # Check if self.table_class is specified in the ModelViewSet before performing subsequent actions",
            "        # If not, display an error message",
            "        if self.action == \"notes\":",
            "            return NoteTable",
            "        elif self.action == \"changelog\":",
            "            return ObjectChangeTable",
            "",
            "        assert (",
            "            self.table_class is not None",
            "        ), f\"'{self.__class__.__name__}' should include a `table_class` attribute for bulk operations\"",
            "",
            "        return self.table_class",
            "",
            "    def _process_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_destroy_form() is not implemented\")",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy objects after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_destroy_form() is not implemented\")",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_create_or_update_form() is not implemented\")",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to edit objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_update_form() is not implemented\")",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        \"\"\"",
            "        Helper method to create objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_create_form() is not implemented\")",
            "",
            "    def _handle_object_does_not_exist(self, form):",
            "        msg = \"Object import failed due to object-level permissions violation\"",
            "        self.logger.debug(msg)",
            "        self.has_error = True",
            "        form.add_error(None, msg)",
            "        return form",
            "",
            "    def _handle_not_implemented_error(self):",
            "        # Blanket handler for NotImplementedError raised by form helper functions",
            "        msg = \"Please provide the appropriate mixin before using this helper function\"",
            "        messages.error(self.request, msg)",
            "        self.has_error = True",
            "",
            "    def _handle_validation_error(self, e):",
            "        # For bulk_create/bulk_update view, self.obj is not set since there are multiple",
            "        # The errors will be rendered on the form itself.",
            "        if self.action not in [\"bulk_create\", \"bulk_update\"]:",
            "            messages.error(self.request, f\"{self.obj} failed validation: {e}\")",
            "        self.has_error = True",
            "",
            "    def form_valid(self, form):",
            "        \"\"\"",
            "        Handle valid forms and redirect to success_url.",
            "        \"\"\"",
            "        request = self.request",
            "        self.has_error = False",
            "        queryset = self.get_queryset()",
            "        try:",
            "            if self.action == \"destroy\":",
            "                self._process_destroy_form(form)",
            "            elif self.action == \"bulk_destroy\":",
            "                self._process_bulk_destroy_form(form)",
            "            elif self.action in [\"create\", \"update\"]:",
            "                self._process_create_or_update_form(form)",
            "            elif self.action == \"bulk_update\":",
            "                self._process_bulk_update_form(form)",
            "            elif self.action == \"bulk_create\":",
            "                self.obj_table = self._process_bulk_create_form(form)",
            "        except ValidationError as e:",
            "            self._handle_validation_error(e)",
            "        except ObjectDoesNotExist:",
            "            form = self._handle_object_does_not_exist(form)",
            "        except NotImplementedError:",
            "            self._handle_not_implemented_error()",
            "",
            "        if not self.has_error:",
            "            self.logger.debug(\"Form validation was successful\")",
            "            if self.action == \"bulk_create\":",
            "                return Response(",
            "                    {",
            "                        \"table\": self.obj_table,",
            "                        \"template\": \"import_success.html\",",
            "                    }",
            "                )",
            "            return super().form_valid(form)",
            "        else:",
            "            # render the form with the error message.",
            "            data = {}",
            "            if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "                pk_list = self.pk_list",
            "                table_class = self.get_table_class()",
            "                table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "                if not table.rows:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                    )",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                data.update({\"table\": table})",
            "            data.update({\"form\": form})",
            "            return Response(data)",
            "",
            "    def form_invalid(self, form):",
            "        \"\"\"",
            "        Handle invalid forms.",
            "        \"\"\"",
            "        data = {}",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "            pk_list = self.pk_list",
            "            table_class = self.get_table_class()",
            "            table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "            if not table.rows:",
            "                messages.warning(",
            "                    request,",
            "                    f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                )",
            "                return redirect(self.get_return_url(request))",
            "",
            "            data = {",
            "                \"table\": table,",
            "            }",
            "        data.update({\"form\": form})",
            "        return Response(data)",
            "",
            "    def get_object(self):",
            "        \"\"\"",
            "        Returns the object the view is displaying.",
            "        You may want to override this if you need to provide non-standard",
            "        queryset lookups.  Eg if objects are referenced using multiple",
            "        keyword arguments in the url conf.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        # Perform the lookup filtering.",
            "        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field",
            "        if lookup_url_kwarg not in self.kwargs:",
            "            return queryset.model()",
            "        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}",
            "        obj = get_object_or_404(queryset, **filter_kwargs)",
            "",
            "        return obj",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset_class())",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Get the list of items for this view.",
            "        This must be an iterable, and may be a queryset.",
            "        Defaults to using `self.queryset`.",
            "        This method should always be used rather than accessing `self.queryset`",
            "        directly, as `self.queryset` gets evaluated only once, and those results",
            "        are cached for all subsequent requests.",
            "        Override the original `get_queryset()` to apply permission specific to the user and action.",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        return queryset.restrict(self.request.user, PERMISSIONS_ACTION_MAP[self.action])",
            "",
            "    def get_extra_context(self, request, instance=None):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "        request: The current request",
            "        instance: The object being viewed",
            "        \"\"\"",
            "        return {}",
            "",
            "    def get_template_name(self):",
            "        # Use \"<app>/<model>_<action> if available, else fall back to generic templates",
            "        queryset = self.get_queryset()",
            "        model_opts = queryset.model._meta",
            "        app_label = model_opts.app_label",
            "        action = self.action",
            "",
            "        try:",
            "            template_name = f\"{app_label}/{model_opts.model_name}_{action}.html\"",
            "            select_template([template_name])",
            "        except TemplateDoesNotExist:",
            "            try:",
            "                if action == \"create\":",
            "                    # When the action is `create`, try {object}_update.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_create.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_update.html\"",
            "                    select_template([template_name])",
            "                elif action == \"update\":",
            "                    # When the action is `update`, try {object}_create.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_update.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_create.html\"",
            "                    select_template([template_name])",
            "                else:",
            "                    # No special case fallback, fall back to generic/object_{action}.html",
            "                    raise TemplateDoesNotExist(\"\")",
            "            except TemplateDoesNotExist:",
            "                template_name = f\"generic/object_{action}.html\"",
            "        return template_name",
            "",
            "    def get_form(self, *args, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form for different views if specified.",
            "        If not, return instantiated form using form_class.",
            "        \"\"\"",
            "        form = getattr(self, f\"{self.action}_form\", None)",
            "        if not form:",
            "            form_class = self.get_form_class()",
            "            if not form_class:",
            "                self.logger.debug(f\"{self.action}_form_class is not defined\")",
            "                return None",
            "            form = form_class(*args, **kwargs)",
            "        return form",
            "",
            "    def get_form_class(self, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form_class for different views.",
            "        \"\"\"",
            "",
            "        if self.action in [\"create\", \"update\"]:",
            "            if getattr(self, f\"{self.action}_form_class\"):",
            "                form_class = getattr(self, f\"{self.action}_form_class\")",
            "            else:",
            "                form_class = getattr(self, \"form_class\", None)",
            "        elif self.action == \"bulk_create\":",
            "",
            "            class BulkCreateForm(BootstrapMixin, Form):",
            "                csv_data = CSVDataField(",
            "                    from_form=self.bulk_create_form_class, widget=Textarea(attrs=self.bulk_create_widget_attrs)",
            "                )",
            "                csv_file = CSVFileField(from_form=self.bulk_create_form_class)",
            "",
            "            form_class = BulkCreateForm",
            "        else:",
            "            form_class = getattr(self, f\"{self.action}_form_class\", None)",
            "",
            "        if not form_class:",
            "            if self.action == \"bulk_destroy\":",
            "                queryset = self.get_queryset()",
            "",
            "                class BulkDestroyForm(ConfirmationForm):",
            "                    pk = ModelMultipleChoiceField(queryset=queryset, widget=MultipleHiddenInput)",
            "",
            "                return BulkDestroyForm",
            "            else:",
            "                # Check for request first and then kwargs for form_class specified.",
            "                form_class = self.request.data.get(\"form_class\", None)",
            "                if not form_class:",
            "                    form_class = kwargs.get(\"form_class\", None)",
            "        return form_class",
            "",
            "    def form_save(self, form, **kwargs):",
            "        \"\"\"",
            "        Generic method to save the object from form.",
            "        Should be overriden by user if customization is needed.",
            "        \"\"\"",
            "        return form.save()",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        queryset = self.get_queryset()",
            "        return queryset.all()",
            "",
            "",
            "class ObjectDetailViewMixin(NautobotViewSetMixin, mixins.RetrieveModelMixin):",
            "    \"\"\"",
            "    UI mixin to retrieve a model instance.",
            "    \"\"\"",
            "",
            "",
            "class ObjectListViewMixin(NautobotViewSetMixin, mixins.ListModelMixin):",
            "    \"\"\"",
            "    UI mixin to list a model queryset",
            "    \"\"\"",
            "",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def filter_queryset(self, queryset):",
            "        \"\"\"",
            "        Filter a query with request querystrings.",
            "        \"\"\"",
            "        if self.filterset_class is not None:",
            "            self.filter_params = self.get_filter_params(self.request)",
            "            self.filterset = self.filterset_class(self.filter_params, queryset)",
            "            queryset = self.filterset.qs",
            "            if not self.filterset.is_valid():",
            "                messages.error(",
            "                    self.request,",
            "                    format_html(\"Invalid filters were specified: {}\", self.filterset.errors),",
            "                )",
            "                queryset = queryset.none()",
            "        return queryset",
            "",
            "    def check_for_export(self, request, model, content_type):",
            "        # Check for export template rendering",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"nautobot_{queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Fall back to built-in CSV formatting if export requested but no template specified",
            "        elif \"export\" in request.GET and hasattr(model, \"to_csv\"):",
            "            response = HttpResponse(self.queryset_to_csv(), content_type=\"text/csv\")",
            "            filename = f\"nautobot_{queryset.model._meta.verbose_name_plural}.csv\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        return None",
            "",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        yaml_data = [obj.to_yaml() for obj in queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def queryset_to_csv(self):",
            "        \"\"\"",
            "        Export the queryset of objects as comma-separated value (CSV), using the model's to_csv() method.",
            "        \"\"\"",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        csv_data = []",
            "        custom_fields = []",
            "        # Start with the column headers",
            "        headers = queryset.model.csv_headers.copy()",
            "",
            "        # Add custom field headers, if any",
            "        if hasattr(queryset.model, \"_custom_field_data\"):",
            "            for custom_field in CustomField.objects.get_for_model(queryset.model):",
            "                headers.append(\"cf_\" + custom_field.slug)",
            "                custom_fields.append(custom_field.name)",
            "",
            "        csv_data.append(\",\".join(headers))",
            "",
            "        # Iterate through the queryset appending each object",
            "        for obj in queryset:",
            "            data = obj.to_csv()",
            "",
            "            for custom_field in custom_fields:",
            "                data += (obj.cf.get(custom_field, \"\"),)",
            "",
            "            csv_data.append(csv_format(data))",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def list(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        List the model instances.",
            "        \"\"\"",
            "        context = {}",
            "        if \"export\" in request.GET:",
            "            queryset = self.get_queryset()",
            "            model = queryset.model",
            "            content_type = ContentType.objects.get_for_model(model)",
            "            response = self.check_for_export(request, model, content_type)",
            "            if response is not None:",
            "                return response",
            "        return Response(context)",
            "",
            "",
            "class ObjectDestroyViewMixin(NautobotViewSetMixin, mixins.DestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to destroy a model instance.",
            "    \"\"\"",
            "",
            "    destroy_form_class = ConfirmationForm",
            "",
            "    def _process_destroy_form(self, form):",
            "        request = self.request",
            "        obj = self.obj",
            "        queryset = self.get_queryset()",
            "        try:",
            "            with transaction.atomic():",
            "                obj.delete()",
            "                msg = f\"Deleted {queryset.model._meta.verbose_name} {obj}\"",
            "                self.logger.info(msg)",
            "                messages.success(request, msg)",
            "                self.success_url = self.get_return_url(request, obj)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "            handle_protectederror([obj], request, e)",
            "            self.success_url = obj.get_absolute_url()",
            "",
            "    def destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectDeleteConfirmationForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_destroy() which validates the form and perform the action of delete.",
            "        Override to add more variables to Response",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_destroy(request, **kwargs)",
            "        return Response(context)",
            "",
            "    def perform_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        Function to validate the ObjectDeleteConfirmationForm and to delete the object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectEditViewMixin(NautobotViewSetMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to create or update a model instance.",
            "    \"\"\"",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            object_created = not form.instance.present_in_database",
            "            obj = self.form_save(form)",
            "",
            "            # Check that the new object conforms with any assigned object-level permissions",
            "            queryset.get(pk=obj.pk)",
            "",
            "            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                form.save_note(instance=obj, user=request.user)",
            "",
            "            msg = f'{\"Created\" if object_created else \"Modified\"} {queryset.model._meta.verbose_name}'",
            "            self.logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "            if hasattr(obj, \"get_absolute_url\"):",
            "                msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "            else:",
            "                msg = format_html(\"{} {}\", msg, obj)",
            "            messages.success(request, msg)",
            "            if \"_addanother\" in request.POST:",
            "                # If the object has clone_fields, pre-populate a new instance of the form",
            "                if hasattr(obj, \"clone_fields\"):",
            "                    url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                    self.success_url = url",
            "                self.success_url = request.get_full_path()",
            "            else:",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    self.success_url = return_url",
            "                else:",
            "                    self.success_url = self.get_return_url(request, obj)",
            "",
            "    def create(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_create() which validates the form and perform the action of create.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_create(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's CreateModelMixin.perform_create(self, serializer) API",
            "    def perform_create(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectForm and to create a new object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    def update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectEditForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_update() which validates the form and perform the action of update/partial_update of an existing object.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_update(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's UpdateModelMixin.perform_update(self, serializer) API",
            "    def perform_update(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectEditForm and to update/partial_update an existing object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkDestroyViewMixin(NautobotViewSetMixin, BulkDestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk destroy model instances.",
            "    \"\"\"",
            "",
            "    bulk_destroy_form_class = None",
            "    filterset_class = None",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        request = self.request",
            "        pk_list = self.pk_list",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Delete objects",
            "        queryset = queryset.filter(pk__in=pk_list)",
            "",
            "        try:",
            "            with transaction.atomic():",
            "                deleted_count = queryset.delete()[1][model._meta.label]",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                self.logger.info(msg)",
            "                self.success_url = self.get_return_url(request)",
            "                messages.success(request, msg)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "            handle_protectederror(queryset, request, e)",
            "            self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_destroy().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk destroy.",
            "        \"\"\"",
            "        return self.perform_bulk_destroy(request, **kwargs)",
            "",
            "    def perform_bulk_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        request.POST \"_delete\": Function to render the user selection of objects in a table form/BulkDestroyConfirmationForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_confirm\": Function to validate the table form/BulkDestroyConfirmationForm and to perform the action of bulk destroy. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset_class is not None:",
            "                self.pk_list = [obj.pk for obj in self.filterset_class(request.POST, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                self.pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        form_class = self.get_form_class(**kwargs)",
            "        data = {}",
            "        if \"_confirm\" in request.POST:",
            "            form = form_class(request.POST)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectBulkCreateViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to bulk create model instances.",
            "    \"\"\"",
            "",
            "    bulk_create_active_tab = \"csv-data\"",
            "    bulk_create_form_class = None",
            "    bulk_create_widget_attrs = {}",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        # Iterate through CSV data and bind each row to a new model form instance.",
            "        new_objs = []",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            if request.FILES:",
            "                field_name = \"csv_file\"",
            "                # Set the bulk_create_active_tab to \"csv-file\"",
            "                # In case the form validation fails, the user will be redirected",
            "                # to the tab with errors rendered on the form.",
            "                self.bulk_create_active_tab = \"csv-file\"",
            "            else:",
            "                field_name = \"csv_data\"",
            "            headers, records = form.cleaned_data[field_name]",
            "            for row, data in enumerate(records, start=1):",
            "                obj_form = self.bulk_create_form_class(data, headers=headers)",
            "                restrict_form_fields(obj_form, request.user)",
            "",
            "                if obj_form.is_valid():",
            "                    obj = self.form_save(obj_form)",
            "                    new_objs.append(obj)",
            "                else:",
            "                    for field, err in obj_form.errors.items():",
            "                        form.add_error(field_name, f\"Row {row} {field}: {err[0]}\")",
            "                    raise ValidationError(\"\")",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                raise ObjectDoesNotExist",
            "",
            "        # Compile a table containing the imported objects",
            "        table_class = self.get_table_class()",
            "        obj_table = table_class(new_objs)",
            "        if new_objs:",
            "            msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(request, msg)",
            "        return obj_table",
            "",
            "    def bulk_create(self, request, *args, **kwargs):",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_bulk_create(request)",
            "        return Response(context)",
            "",
            "    def perform_bulk_create(self, request):",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST, request.FILES)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkUpdateViewMixin(NautobotViewSetMixin, BulkUpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk update model instances.",
            "    \"\"\"",
            "",
            "    filterset_class = None",
            "    bulk_update_form_class = None",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        form_custom_fields = getattr(form, \"custom_fields\", [])",
            "        form_relationships = getattr(form, \"relationships\", [])",
            "        # Standard fields are those that are intrinsic to self.model in the form",
            "        # Relationships, custom fields, object_note are extrinsic fields",
            "        # PK is used to identify an existing instance, not to modify the object",
            "        standard_fields = [",
            "            field",
            "            for field in form.fields",
            "            if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "        ]",
            "        nullified_fields = request.POST.getlist(\"_nullify\")",
            "        form_cf_to_key = {f\"cf_{cf.slug}\": cf.name for cf in CustomField.objects.get_for_model(model)}",
            "        with transaction.atomic():",
            "            updated_objects = []",
            "            for obj in queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                self.obj = obj",
            "                # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                for name in standard_fields:",
            "                    try:",
            "                        model_field = model._meta.get_field(name)",
            "                    except FieldDoesNotExist:",
            "                        # This form field is used to modify a field rather than set its value directly",
            "                        model_field = None",
            "                    # Handle nullification",
            "                    if name in form.nullable_fields and name in nullified_fields:",
            "                        if isinstance(model_field, ManyToManyField):",
            "                            getattr(obj, name).set([])",
            "                        else:",
            "                            setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "                    # ManyToManyFields",
            "                    elif isinstance(model_field, ManyToManyField):",
            "                        if form.cleaned_data[name]:",
            "                            getattr(obj, name).set(form.cleaned_data[name])",
            "                    # Normal fields",
            "                    elif form.cleaned_data[name] not in (None, \"\"):",
            "                        setattr(obj, name, form.cleaned_data[name])",
            "                # Update custom fields",
            "                for field_name in form_custom_fields:",
            "                    if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                        obj.cf[form_cf_to_key[field_name]] = None",
            "                    elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                        obj.cf[form_cf_to_key[field_name]] = form.cleaned_data[field_name]",
            "",
            "                obj.validated_save()",
            "                updated_objects.append(obj)",
            "                self.logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                # Add/remove tags",
            "                if form.cleaned_data.get(\"add_tags\", None):",
            "                    obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                if form.cleaned_data.get(\"remove_tags\", None):",
            "                    obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                    # Add/remove relationship associations",
            "                    form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(updated_objects):",
            "                raise ObjectDoesNotExist",
            "        if updated_objects:",
            "            msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(self.request, msg)",
            "        self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_update().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk update.",
            "        \"\"\"",
            "        return self.perform_bulk_update(request, **kwargs)",
            "",
            "    # TODO: this conflicts with BulkUpdateModelMixin.perform_bulk_update(self, objects, update_data, partial)",
            "    def perform_bulk_update(self, request, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        request.POST \"_edit\": Function to render the user selection of objects in a table form/BulkUpdateForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_apply\": Function to validate the table form/BulkUpdateForm and to perform the action of bulk update. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset_class is not None:",
            "                self.pk_list = [obj.pk for obj in self.filterset_class(request.POST, model.objects.only(\"pk\")).qs]",
            "            else:",
            "                self.pk_list = model.objects.values_list(\"pk\", flat=True)",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        data = {}",
            "        form_class = self.get_form_class()",
            "        if \"_apply\" in request.POST:",
            "            self.kwargs = kwargs",
            "            form = form_class(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected to update.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectChangeLogViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to list a model's changelog queryset",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def changelog(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)",
            "",
            "",
            "class ObjectNotesViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI Mixin for an Object's Notes.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def notes(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "18": [],
            "19": [],
            "465": [
                "ObjectListViewMixin",
                "filter_queryset"
            ],
            "627": [
                "ObjectEditViewMixin",
                "_process_create_or_update_form"
            ],
            "629": [
                "ObjectEditViewMixin",
                "_process_create_or_update_form"
            ],
            "630": [
                "ObjectEditViewMixin",
                "_process_create_or_update_form"
            ]
        },
        "addLocation": []
    },
    "nautobot/dcim/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         model = Site"
            },
            "1": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         fields = Site.csv_headers"
            },
            "2": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "         help_texts = {"
            },
            "3": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"time_zone\": mark_safe("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+            \"time_zone\": mark_safe(  # noqa: S308"
            },
            "5": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "                 'Time zone (<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">available options</a>)'"
            },
            "6": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "             )"
            },
            "7": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "         }"
            },
            "8": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "         feature=\"locations\","
            },
            "9": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "         required=False,"
            },
            "10": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "         choices_as_strings=True,"
            },
            "11": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=mark_safe("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+        help_text=mark_safe(  # noqa: S308"
            },
            "13": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "             \"The object types to which this status applies. Multiple values \""
            },
            "14": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 452,
                "PatchRowcode": "             \"must be comma-separated and wrapped in double quotes. (e.g. \""
            },
            "15": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": 453,
                "PatchRowcode": "             '<code>\"dcim.device,dcim.rack\"</code>)'"
            },
            "16": {
                "beforePatchRowNumber": 636,
                "afterPatchRowNumber": 636,
                "PatchRowcode": "         model = RackRole"
            },
            "17": {
                "beforePatchRowNumber": 637,
                "afterPatchRowNumber": 637,
                "PatchRowcode": "         fields = RackRole.csv_headers"
            },
            "18": {
                "beforePatchRowNumber": 638,
                "afterPatchRowNumber": 638,
                "PatchRowcode": "         help_texts = {"
            },
            "19": {
                "beforePatchRowNumber": 639,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308"
            },
            "21": {
                "beforePatchRowNumber": 640,
                "afterPatchRowNumber": 640,
                "PatchRowcode": "         }"
            },
            "22": {
                "beforePatchRowNumber": 641,
                "afterPatchRowNumber": 641,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 642,
                "afterPatchRowNumber": 642,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 1768,
                "afterPatchRowNumber": 1768,
                "PatchRowcode": "         model = DeviceRole"
            },
            "25": {
                "beforePatchRowNumber": 1769,
                "afterPatchRowNumber": 1769,
                "PatchRowcode": "         fields = DeviceRole.csv_headers"
            },
            "26": {
                "beforePatchRowNumber": 1770,
                "afterPatchRowNumber": 1770,
                "PatchRowcode": "         help_texts = {"
            },
            "27": {
                "beforePatchRowNumber": 1771,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1771,
                "PatchRowcode": "+            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308"
            },
            "29": {
                "beforePatchRowNumber": 1772,
                "afterPatchRowNumber": 1772,
                "PatchRowcode": "         }"
            },
            "30": {
                "beforePatchRowNumber": 1773,
                "afterPatchRowNumber": 1773,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 1774,
                "afterPatchRowNumber": 1774,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 3855,
                "afterPatchRowNumber": 3855,
                "PatchRowcode": "             \"length_unit\","
            },
            "33": {
                "beforePatchRowNumber": 3856,
                "afterPatchRowNumber": 3856,
                "PatchRowcode": "         ]"
            },
            "34": {
                "beforePatchRowNumber": 3857,
                "afterPatchRowNumber": 3857,
                "PatchRowcode": "         help_texts = {"
            },
            "35": {
                "beforePatchRowNumber": 3858,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3858,
                "PatchRowcode": "+            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308"
            },
            "37": {
                "beforePatchRowNumber": 3859,
                "afterPatchRowNumber": 3859,
                "PatchRowcode": "             \"status\": \"Connection status\","
            },
            "38": {
                "beforePatchRowNumber": 3860,
                "afterPatchRowNumber": 3860,
                "PatchRowcode": "         }"
            },
            "39": {
                "beforePatchRowNumber": 3861,
                "afterPatchRowNumber": 3861,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import re",
            "",
            "from django import forms",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.postgres.forms.array import SimpleArrayField",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.db.models import Q",
            "from django.utils.safestring import mark_safe",
            "from netaddr import EUI",
            "from netaddr.core import AddrFormatError",
            "from timezone_field import TimeZoneFormField",
            "",
            "from nautobot.circuits.models import Circuit, CircuitTermination, Provider",
            "from nautobot.dcim.form_mixins import (",
            "    LocatableModelBulkEditFormMixin,",
            "    LocatableModelCSVFormMixin,",
            "    LocatableModelFilterFormMixin,",
            "    LocatableModelFormMixin,",
            ")",
            "from nautobot.extras.forms import (",
            "    CustomFieldModelBulkEditFormMixin,",
            "    CustomFieldModelCSVForm,",
            "    NautobotBulkEditForm,",
            "    NautobotModelForm,",
            "    NautobotFilterForm,",
            "    NoteModelFormMixin,",
            "    LocalContextFilterForm,",
            "    LocalContextModelForm,",
            "    LocalContextModelBulkEditForm,",
            "    StatusModelBulkEditFormMixin,",
            "    StatusModelCSVFormMixin,",
            "    StatusModelFilterFormMixin,",
            "    TagsBulkEditFormMixin,",
            ")",
            "from nautobot.extras.models import SecretsGroup, Status",
            "from nautobot.ipam.constants import BGP_ASN_MAX, BGP_ASN_MIN",
            "from nautobot.ipam.models import IPAddress, VLAN",
            "from nautobot.tenancy.forms import TenancyFilterForm, TenancyForm",
            "from nautobot.tenancy.models import Tenant, TenantGroup",
            "from nautobot.utilities.forms import (",
            "    APISelect,",
            "    APISelectMultiple,",
            "    add_blank_choice,",
            "    BootstrapMixin,",
            "    BulkEditNullBooleanSelect,",
            "    ColorSelect,",
            "    CommentField,",
            "    CSVChoiceField,",
            "    CSVContentTypeField,",
            "    CSVModelChoiceField,",
            "    CSVMultipleContentTypeField,",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    ExpandableNameField,",
            "    form_from_model,",
            "    MultipleContentTypeField,",
            "    NumericArrayField,",
            "    SelectWithPK,",
            "    SmallTextarea,",
            "    SlugField,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    TagFilterField,",
            ")",
            "from nautobot.utilities.forms.constants import BOOLEAN_WITH_BLANK_CHOICES",
            "from nautobot.virtualization.models import Cluster, ClusterGroup",
            "from .choices import (",
            "    CableLengthUnitChoices,",
            "    CableTypeChoices,",
            "    ConsolePortTypeChoices,",
            "    DeviceFaceChoices,",
            "    DeviceRedundancyGroupFailoverStrategyChoices,",
            "    InterfaceModeChoices,",
            "    InterfaceRedundancyGroupProtocolChoices,",
            "    InterfaceTypeChoices,",
            "    PortTypeChoices,",
            "    PowerFeedPhaseChoices,",
            "    PowerFeedSupplyChoices,",
            "    PowerFeedTypeChoices,",
            "    PowerOutletFeedLegChoices,",
            "    PowerOutletTypeChoices,",
            "    PowerPortTypeChoices,",
            "    RackDimensionUnitChoices,",
            "    RackTypeChoices,",
            "    RackWidthChoices,",
            "    SubdeviceRoleChoices,",
            ")",
            "from .constants import (",
            "    CABLE_TERMINATION_MODELS,",
            "    INTERFACE_MTU_MAX,",
            "    INTERFACE_MTU_MIN,",
            "    NONCONNECTABLE_IFACE_TYPES,",
            "    REARPORT_POSITIONS_MAX,",
            "    REARPORT_POSITIONS_MIN,",
            ")",
            "",
            "from .models import (",
            "    Cable,",
            "    DeviceBay,",
            "    DeviceBayTemplate,",
            "    DeviceRedundancyGroup,",
            "    ConsolePort,",
            "    ConsolePortTemplate,",
            "    ConsoleServerPort,",
            "    ConsoleServerPortTemplate,",
            "    Device,",
            "    DeviceRole,",
            "    DeviceType,",
            "    FrontPort,",
            "    FrontPortTemplate,",
            "    Interface,",
            "    InterfaceRedundancyGroup,",
            "    InterfaceRedundancyGroupAssociation,",
            "    InterfaceTemplate,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    InventoryItem,",
            "    Platform,",
            "    PowerFeed,",
            "    PowerOutlet,",
            "    PowerOutletTemplate,",
            "    PowerPanel,",
            "    PowerPort,",
            "    PowerPortTemplate,",
            "    Rack,",
            "    RackGroup,",
            "    RackReservation,",
            "    RackRole,",
            "    RearPort,",
            "    RearPortTemplate,",
            "    Region,",
            "    Site,",
            "    VirtualChassis,",
            ")",
            "",
            "DEVICE_BY_PK_RE = r\"{\\d+\\}\"",
            "",
            "INTERFACE_MODE_HELP_TEXT = \"\"\"",
            "Access: One untagged VLAN<br />",
            "Tagged: One untagged VLAN and/or one or more tagged VLANs<br />",
            "Tagged (All): Implies all VLANs are available (w/optional untagged VLAN)",
            "\"\"\"",
            "",
            "",
            "def get_device_by_name_or_pk(name):",
            "    \"\"\"",
            "    Attempt to retrieve a device by either its name or primary key ('{pk}').",
            "    \"\"\"",
            "    if re.match(DEVICE_BY_PK_RE, name):",
            "        pk = name.strip(\"{}\")",
            "        device = Device.objects.get(pk=pk)",
            "    else:",
            "        device = Device.objects.get(name=name)",
            "    return device",
            "",
            "",
            "class ConnectCableExcludeIDMixin:",
            "    def __init__(self, *args, exclude_id=None, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if exclude_id is not None:",
            "            self.fields[\"termination_b_id\"].widget.add_query_param(\"id__n\", str(exclude_id))",
            "",
            "",
            "class DeviceComponentFilterForm(NautobotFilterForm):",
            "    field_order = [\"q\", \"region\", \"site\"]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "class InterfaceCommonForm(forms.Form):",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        parent_field = \"device\" if \"device\" in self.cleaned_data else \"virtual_machine\"",
            "        tagged_vlans = self.cleaned_data[\"tagged_vlans\"]",
            "        mode = self.cleaned_data[\"mode\"]",
            "",
            "        # Untagged interfaces cannot be assigned tagged VLANs",
            "        if mode == InterfaceModeChoices.MODE_ACCESS and tagged_vlans:",
            "            raise forms.ValidationError({\"mode\": \"An access interface cannot have tagged VLANs assigned.\"})",
            "",
            "        if mode != InterfaceModeChoices.MODE_TAGGED and tagged_vlans:",
            "            raise forms.ValidationError({\"tagged_vlans\": f\"Clear tagged_vlans to set mode to {self.mode}\"})",
            "",
            "        # Remove all tagged VLAN assignments from \"tagged all\" interfaces",
            "        elif mode == InterfaceModeChoices.MODE_TAGGED_ALL:",
            "            self.cleaned_data[\"tagged_vlans\"] = []",
            "",
            "        # Validate tagged VLANs; must be a global VLAN or in the same site",
            "        elif mode == InterfaceModeChoices.MODE_TAGGED:",
            "            valid_sites = [None, self.cleaned_data[parent_field].site]",
            "            invalid_vlans = [str(v) for v in tagged_vlans if v.site not in valid_sites]",
            "",
            "            if invalid_vlans:",
            "                raise forms.ValidationError(",
            "                    {",
            "                        \"tagged_vlans\": f\"The tagged VLANs ({', '.join(invalid_vlans)}) must belong to the same site as \"",
            "                        f\"the interface's parent device/VM, or they must be global\"",
            "                    }",
            "                )",
            "",
            "",
            "class ComponentForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    Subclass this form when facilitating the creation of one or more device component or component templates based on",
            "    a name pattern.",
            "    \"\"\"",
            "",
            "    name_pattern = ExpandableNameField(label=\"Name\")",
            "    label_pattern = ExpandableNameField(",
            "        label=\"Label\",",
            "        required=False,",
            "        help_text=\"Alphanumeric ranges are supported. (Must match the number of names being created.)\",",
            "    )",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate that the number of components being created from both the name_pattern and label_pattern are equal",
            "        if self.cleaned_data[\"label_pattern\"]:",
            "            name_pattern_count = len(self.cleaned_data[\"name_pattern\"])",
            "            label_pattern_count = len(self.cleaned_data[\"label_pattern\"])",
            "            if name_pattern_count != label_pattern_count:",
            "                raise forms.ValidationError(",
            "                    {",
            "                        \"label_pattern\": f\"The provided name pattern will create {name_pattern_count} components, however \"",
            "                        f\"{label_pattern_count} labels will be generated. These counts must match.\"",
            "                    },",
            "                    code=\"label_pattern_mismatch\",",
            "                )",
            "",
            "",
            "#",
            "# Fields",
            "#",
            "",
            "",
            "class MACAddressField(forms.Field):",
            "    widget = forms.CharField",
            "    default_error_messages = {",
            "        \"invalid\": \"MAC address must be in EUI-48 format\",",
            "    }",
            "",
            "    def to_python(self, value):",
            "        value = super().to_python(value)",
            "",
            "        # Validate MAC address format",
            "        try:",
            "            value = EUI(value.strip())",
            "        except AddrFormatError:",
            "            raise forms.ValidationError(self.error_messages[\"invalid\"], code=\"invalid\")",
            "",
            "        return value",
            "",
            "",
            "#",
            "# Regions",
            "#",
            "",
            "",
            "class RegionForm(NautobotModelForm):",
            "    parent = DynamicModelChoiceField(queryset=Region.objects.all(), required=False)",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Region",
            "        fields = (",
            "            \"parent\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "class RegionCSVForm(CustomFieldModelCSVForm):",
            "    parent = CSVModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of parent region\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Region",
            "        fields = Region.csv_headers",
            "",
            "",
            "class RegionFilterForm(NautobotFilterForm):",
            "    model = Site",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Sites",
            "#",
            "",
            "",
            "class SiteForm(NautobotModelForm, TenancyForm):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False)",
            "    slug = SlugField()",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = Site",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"status\",",
            "            \"region\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"facility\",",
            "            \"asn\",",
            "            \"time_zone\",",
            "            \"description\",",
            "            \"physical_address\",",
            "            \"shipping_address\",",
            "            \"latitude\",",
            "            \"longitude\",",
            "            \"contact_name\",",
            "            \"contact_phone\",",
            "            \"contact_email\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"physical_address\": SmallTextarea(",
            "                attrs={",
            "                    \"rows\": 3,",
            "                }",
            "            ),",
            "            \"shipping_address\": SmallTextarea(",
            "                attrs={",
            "                    \"rows\": 3,",
            "                }",
            "            ),",
            "            \"time_zone\": StaticSelect2(),",
            "        }",
            "        help_texts = {",
            "            \"name\": \"Full name of the site\",",
            "            \"facility\": \"Data center provider and facility (e.g. Equinix NY7)\",",
            "            \"asn\": \"BGP autonomous system number\",",
            "            \"time_zone\": \"Local time zone\",",
            "            \"description\": \"Short description (will appear in sites list)\",",
            "            \"physical_address\": \"Physical location of the building (e.g. for GPS)\",",
            "            \"shipping_address\": \"If different from the physical address\",",
            "            \"latitude\": \"Latitude in decimal format (xx.yyyyyy)\",",
            "            \"longitude\": \"Longitude in decimal format (xx.yyyyyy)\",",
            "        }",
            "",
            "",
            "class SiteCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    region = CSVModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned region\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Site",
            "        fields = Site.csv_headers",
            "        help_texts = {",
            "            \"time_zone\": mark_safe(",
            "                'Time zone (<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">available options</a>)'",
            "            )",
            "        }",
            "",
            "",
            "class SiteBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Site.objects.all(), widget=forms.MultipleHiddenInput)",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False)",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    asn = forms.IntegerField(min_value=BGP_ASN_MIN, max_value=BGP_ASN_MAX, required=False, label=\"ASN\")",
            "    description = forms.CharField(max_length=100, required=False)",
            "    time_zone = TimeZoneFormField(",
            "        choices=add_blank_choice(TimeZoneFormField().choices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"region\",",
            "            \"tenant\",",
            "            \"asn\",",
            "            \"description\",",
            "            \"time_zone\",",
            "        ]",
            "",
            "",
            "class SiteFilterForm(NautobotFilterForm, TenancyFilterForm, StatusModelFilterFormMixin):",
            "    model = Site",
            "    field_order = [\"q\", \"status\", \"region\", \"tenant_group\", \"tenant\"]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# LocationTypes",
            "#",
            "",
            "",
            "class LocationTypeForm(NautobotModelForm):",
            "    parent = DynamicModelChoiceField(queryset=LocationType.objects.all(), required=False)",
            "    slug = SlugField()",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"locations\",",
            "        help_text=\"The object type(s) that can be associated to a Location of this type\",",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        model = LocationType",
            "        fields = (\"parent\", \"name\", \"slug\", \"description\", \"nestable\", \"content_types\")",
            "",
            "",
            "class LocationTypeCSVForm(CustomFieldModelCSVForm):",
            "    parent = CSVModelChoiceField(",
            "        queryset=LocationType.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of parent location type\",",
            "    )",
            "    content_types = CSVMultipleContentTypeField(",
            "        feature=\"locations\",",
            "        required=False,",
            "        choices_as_strings=True,",
            "        help_text=mark_safe(",
            "            \"The object types to which this status applies. Multiple values \"",
            "            \"must be comma-separated and wrapped in double quotes. (e.g. \"",
            "            '<code>\"dcim.device,dcim.rack\"</code>)'",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = LocationType",
            "        fields = LocationType.csv_headers",
            "",
            "",
            "class LocationTypeFilterForm(NautobotFilterForm):",
            "    model = LocationType",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(feature=\"locations\", choices_as_strings=True, required=False)",
            "",
            "",
            "#",
            "# Locations",
            "#",
            "",
            "",
            "class LocationForm(NautobotModelForm, TenancyForm):",
            "    slug = SlugField(slug_source=(\"parent\", \"name\"))",
            "    location_type = DynamicModelChoiceField(queryset=LocationType.objects.all())",
            "    parent = DynamicModelChoiceField(",
            "        queryset=Location.objects.all(),",
            "        query_params={\"child_location_type\": \"$location_type\"},",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "    )",
            "    site = DynamicModelChoiceField(queryset=Site.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        model = Location",
            "        fields = [",
            "            \"location_type\",",
            "            \"parent\",",
            "            \"site\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"status\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class LocationBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Location.objects.all(), widget=forms.MultipleHiddenInput)",
            "    # location_type is not editable on existing instances",
            "    parent = DynamicModelChoiceField(queryset=Location.objects.all(), required=False)",
            "    site = DynamicModelChoiceField(queryset=Site.objects.all(), required=False)",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"parent\",",
            "            \"site\",",
            "            \"tenant\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class LocationCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    location_type = CSVModelChoiceField(",
            "        queryset=LocationType.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Location type\",",
            "    )",
            "    parent = CSVModelChoiceField(",
            "        queryset=Location.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent location\",",
            "    )",
            "    site = CSVModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent site\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Location",
            "        fields = Location.csv_headers",
            "",
            "",
            "class LocationFilterForm(NautobotFilterForm, StatusModelFilterFormMixin, TenancyFilterForm):",
            "    model = Location",
            "    field_order = [\"q\", \"location_type\", \"parent\", \"subtree\", \"base_site\", \"status\", \"tenant_group\", \"tenant\", \"tag\"]",
            "",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    location_type = DynamicModelMultipleChoiceField(",
            "        queryset=LocationType.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    parent = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    subtree = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    base_site = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), to_field_name=\"slug\", required=False)",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Rack groups",
            "#",
            "",
            "",
            "class RackGroupForm(LocatableModelFormMixin, NautobotModelForm):",
            "    parent = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = RackGroup",
            "        fields = (",
            "            \"region\",",
            "            \"site\",",
            "            \"location\",",
            "            \"parent\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "class RackGroupCSVForm(LocatableModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    parent = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent rack group\",",
            "        error_messages={",
            "            \"invalid_choice\": \"Rack group not found.\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = RackGroup",
            "        fields = RackGroup.csv_headers",
            "",
            "",
            "class RackGroupFilterForm(NautobotFilterForm, LocatableModelFilterFormMixin):",
            "    model = RackGroup",
            "    parent = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={",
            "            \"region\": \"$region\",",
            "            \"site\": \"$site\",",
            "        },",
            "    )",
            "",
            "",
            "#",
            "# Rack roles",
            "#",
            "",
            "",
            "class RackRoleForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = RackRole",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"color\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class RackRoleCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = RackRole",
            "        fields = RackRole.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),",
            "        }",
            "",
            "",
            "#",
            "# Racks",
            "#",
            "",
            "",
            "class RackForm(LocatableModelFormMixin, NautobotModelForm, TenancyForm):",
            "    group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    role = DynamicModelChoiceField(queryset=RackRole.objects.all(), required=False)",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = Rack",
            "        fields = [",
            "            \"region\",",
            "            \"site\",",
            "            \"location\",",
            "            \"group\",",
            "            \"name\",",
            "            \"facility_id\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"status\",",
            "            \"role\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"type\",",
            "            \"width\",",
            "            \"u_height\",",
            "            \"desc_units\",",
            "            \"outer_width\",",
            "            \"outer_depth\",",
            "            \"outer_unit\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        help_texts = {",
            "            \"site\": \"The site at which the rack exists\",",
            "            \"location\": \"The specific location of the rack\",",
            "            \"name\": \"Organizational rack name\",",
            "            \"facility_id\": \"The unique rack ID assigned by the facility\",",
            "            \"u_height\": \"Height in rack units\",",
            "        }",
            "        widgets = {",
            "            \"type\": StaticSelect2(),",
            "            \"width\": StaticSelect2(),",
            "            \"outer_unit\": StaticSelect2(),",
            "        }",
            "",
            "    def clean(self):",
            "        cleaned_data = self.cleaned_data",
            "        site = cleaned_data.get(\"site\")",
            "",
            "        if self.instance and self.instance.present_in_database and site != self.instance.site:",
            "            # If the site is changed, the rack post save signal attempts to update the rack devices,",
            "            # which may result in an Exception if the updated devices conflict with existing devices at this site.",
            "            # To avoid an unhandled exception in the signal, check for this scenario here.",
            "            duplicate_devices = set()",
            "            for device in self.instance.devices.all():",
            "                qs = Device.objects.exclude(pk=device.pk).filter(site=site, tenant=device.tenant, name=device.name)",
            "                if qs.exists():",
            "                    duplicate_devices.add(qs.first().name)",
            "            if duplicate_devices:",
            "                raise ValidationError(",
            "                    {",
            "                        \"site\": f\"Device(s) {sorted(duplicate_devices)} already exist in site {site} and \"",
            "                        \"would conflict with same-named devices in this rack.\"",
            "                    }",
            "                )",
            "        return super().clean()",
            "",
            "",
            "class RackCSVForm(LocatableModelCSVFormMixin, StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    group = CSVModelChoiceField(queryset=RackGroup.objects.all(), required=False, to_field_name=\"name\")",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of assigned tenant\",",
            "    )",
            "    role = CSVModelChoiceField(",
            "        queryset=RackRole.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of assigned role\",",
            "    )",
            "    type = CSVChoiceField(choices=RackTypeChoices, required=False, help_text=\"Rack type\")",
            "    width = forms.ChoiceField(choices=RackWidthChoices, help_text=\"Rail-to-rail width (in inches)\")",
            "    outer_unit = CSVChoiceField(",
            "        choices=RackDimensionUnitChoices,",
            "        required=False,",
            "        help_text=\"Unit for outer dimensions\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Rack",
            "        fields = Rack.csv_headers",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"group\"].queryset = self.fields[\"group\"].queryset.filter(**params)",
            "",
            "",
            "class RackBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    LocatableModelBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Rack.objects.all(), widget=forms.MultipleHiddenInput)",
            "    group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    role = DynamicModelChoiceField(queryset=RackRole.objects.all(), required=False)",
            "    serial = forms.CharField(max_length=255, required=False, label=\"Serial Number\")",
            "    asset_tag = forms.CharField(max_length=50, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(RackTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    width = forms.ChoiceField(",
            "        choices=add_blank_choice(RackWidthChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    u_height = forms.IntegerField(required=False, label=\"Height (U)\")",
            "    desc_units = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect, label=\"Descending units\")",
            "    outer_width = forms.IntegerField(required=False, min_value=1)",
            "    outer_depth = forms.IntegerField(required=False, min_value=1)",
            "    outer_unit = forms.ChoiceField(",
            "        choices=add_blank_choice(RackDimensionUnitChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    comments = CommentField(widget=SmallTextarea, label=\"Comments\")",
            "",
            "    class Meta:",
            "        model = Rack",
            "        nullable_fields = [",
            "            \"location\",",
            "            \"group\",",
            "            \"tenant\",",
            "            \"role\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"outer_width\",",
            "            \"outer_depth\",",
            "            \"outer_unit\",",
            "            \"comments\",",
            "        ]",
            "",
            "",
            "class RackFilterForm(NautobotFilterForm, LocatableModelFilterFormMixin, TenancyFilterForm, StatusModelFilterFormMixin):",
            "    model = Rack",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"location\",",
            "        \"group_id\",",
            "        \"status\",",
            "        \"role\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "    ]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        label=\"Rack group\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    type = forms.MultipleChoiceField(choices=RackTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    width = forms.MultipleChoiceField(choices=RackWidthChoices, required=False, widget=StaticSelect2Multiple())",
            "    role = DynamicModelMultipleChoiceField(",
            "        queryset=RackRole.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Rack elevations",
            "#",
            "",
            "",
            "class RackElevationFilterForm(RackFilterForm):",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"group_id\",",
            "        \"id\",",
            "        \"status\",",
            "        \"role\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "    ]",
            "    id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        label=\"Rack\",",
            "        required=False,",
            "        query_params={",
            "            \"site\": \"$site\",",
            "            \"group_id\": \"$group_id\",",
            "        },",
            "    )",
            "",
            "",
            "#",
            "# Rack reservations",
            "#",
            "",
            "",
            "class RackReservationForm(NautobotModelForm, TenancyForm):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False, initial_params={\"sites\": \"$site\"})",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"group_id\": \"$rack_group\",",
            "        },",
            "    )",
            "    units = NumericArrayField(",
            "        base_field=forms.IntegerField(),",
            "        help_text=\"Comma-separated list of numeric unit IDs. A range may be specified using a hyphen.\",",
            "    )",
            "    user = forms.ModelChoiceField(queryset=get_user_model().objects.order_by(\"username\"), widget=StaticSelect2())",
            "",
            "    class Meta:",
            "        model = RackReservation",
            "        fields = [",
            "            \"rack\",",
            "            \"units\",",
            "            \"user\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class RackReservationCSVForm(CustomFieldModelCSVForm):",
            "    site = CSVModelChoiceField(queryset=Site.objects.all(), to_field_name=\"name\", help_text=\"Parent site\")",
            "    rack_group = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack's group (if any)\",",
            "    )",
            "    rack = CSVModelChoiceField(queryset=Rack.objects.all(), to_field_name=\"name\", help_text=\"Rack\")",
            "    units = SimpleArrayField(",
            "        base_field=forms.IntegerField(),",
            "        required=True,",
            "        help_text=\"Comma-separated list of individual unit numbers\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "",
            "    class Meta:",
            "        model = RackReservation",
            "        fields = (\"site\", \"rack_group\", \"rack\", \"units\", \"tenant\", \"description\")",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit rack_group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "            # Limit rack queryset by assigned site and group",
            "            params = {",
            "                f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\"),",
            "                f\"group__{self.fields['rack_group'].to_field_name}\": data.get(\"rack_group\"),",
            "            }",
            "            self.fields[\"rack\"].queryset = self.fields[\"rack\"].queryset.filter(**params)",
            "",
            "",
            "class RackReservationBulkEditForm(TagsBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=RackReservation.objects.all(), widget=forms.MultipleHiddenInput())",
            "    user = forms.ModelChoiceField(",
            "        queryset=get_user_model().objects.order_by(\"username\"),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "class RackReservationFilterForm(NautobotFilterForm, TenancyFilterForm):",
            "    model = RackReservation",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"group_id\",",
            "        \"user_id\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "    ]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.select_related(\"site\"),",
            "        required=False,",
            "        label=\"Rack group\",",
            "        null_option=\"None\",",
            "    )",
            "    user_id = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Manufacturers",
            "#",
            "",
            "",
            "class ManufacturerForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Manufacturer",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class ManufacturerCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = Manufacturer",
            "        fields = Manufacturer.csv_headers",
            "",
            "",
            "#",
            "# Device types",
            "#",
            "",
            "",
            "class DeviceTypeForm(NautobotModelForm):",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all())",
            "    slug = SlugField(slug_source=\"model\")",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = DeviceType",
            "        fields = [",
            "            \"manufacturer\",",
            "            \"model\",",
            "            \"slug\",",
            "            \"part_number\",",
            "            \"u_height\",",
            "            \"is_full_depth\",",
            "            \"subdevice_role\",",
            "            \"front_image\",",
            "            \"rear_image\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"subdevice_role\": StaticSelect2(),",
            "            # Exclude SVG images (unsupported by PIL)",
            "            \"front_image\": forms.ClearableFileInput(",
            "                attrs={\"accept\": \"image/bmp,image/gif,image/jpeg,image/png,image/tiff\"}",
            "            ),",
            "            \"rear_image\": forms.ClearableFileInput(",
            "                attrs={\"accept\": \"image/bmp,image/gif,image/jpeg,image/png,image/tiff\"}",
            "            ),",
            "        }",
            "",
            "",
            "class DeviceTypeImportForm(BootstrapMixin, forms.ModelForm):",
            "    manufacturer = forms.ModelChoiceField(queryset=Manufacturer.objects.all(), to_field_name=\"name\")",
            "",
            "    class Meta:",
            "        model = DeviceType",
            "        fields = [",
            "            \"manufacturer\",",
            "            \"model\",",
            "            \"slug\",",
            "            \"part_number\",",
            "            \"u_height\",",
            "            \"is_full_depth\",",
            "            \"subdevice_role\",",
            "            \"comments\",",
            "        ]",
            "",
            "",
            "class DeviceTypeBulkEditForm(TagsBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceType.objects.all(), widget=forms.MultipleHiddenInput())",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    u_height = forms.IntegerField(required=False)",
            "    is_full_depth = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect(), label=\"Is full depth\")",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "class DeviceTypeFilterForm(NautobotFilterForm):",
            "    model = DeviceType",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    manufacturer = DynamicModelMultipleChoiceField(",
            "        queryset=Manufacturer.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    subdevice_role = forms.MultipleChoiceField(",
            "        choices=add_blank_choice(SubdeviceRoleChoices),",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "    console_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    console_server_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console server ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_outlets = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power outlets\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    interfaces = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has interfaces\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    pass_through_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has pass-through ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Device component templates",
            "#",
            "",
            "",
            "class ComponentTemplateCreateForm(ComponentForm):",
            "    \"\"\"",
            "    Base form for the creation of device component templates (subclassed from ComponentTemplateModel).",
            "    \"\"\"",
            "",
            "    manufacturer = DynamicModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        required=False,",
            "        initial_params={\"device_types\": \"device_type\"},",
            "    )",
            "    device_type = DynamicModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        query_params={\"manufacturer_id\": \"$manufacturer\"},",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "",
            "class ConsolePortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsolePortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsolePortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(ConsolePortTypeChoices), widget=StaticSelect2())",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class ConsolePortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConsolePortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"description\"]",
            "",
            "",
            "class ConsoleServerPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsoleServerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsoleServerPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(ConsolePortTypeChoices), widget=StaticSelect2())",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class ConsoleServerPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=ConsoleServerPortTemplate.objects.all(),",
            "        widget=forms.MultipleHiddenInput(),",
            "    )",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"description\"]",
            "",
            "",
            "class PowerPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = PowerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class PowerPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(PowerPortTypeChoices), required=False)",
            "    maximum_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Maximum power draw (watts)\")",
            "    allocated_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Allocated power draw (watts)\")",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"maximum_draw\",",
            "        \"allocated_draw\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class PowerPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerPortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerPortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    maximum_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Maximum power draw (watts)\")",
            "    allocated_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Allocated power draw (watts)\")",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class PowerOutletTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = PowerOutletTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"power_port\",",
            "            \"feed_leg\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port choices to current DeviceType",
            "        if hasattr(self.instance, \"device_type\"):",
            "            self.fields[\"power_port\"].queryset = PowerPortTemplate.objects.filter(device_type=self.instance.device_type)",
            "",
            "",
            "class PowerOutletTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(PowerOutletTypeChoices), required=False)",
            "    power_port = forms.ModelChoiceField(queryset=PowerPortTemplate.objects.all(), required=False)",
            "    feed_leg = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletFeedLegChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"power_port\",",
            "        \"feed_leg\",",
            "        \"description\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port choices to current DeviceType",
            "        device_type = DeviceType.objects.get(pk=self.initial.get(\"device_type\") or self.data.get(\"device_type\"))",
            "        self.fields[\"power_port\"].queryset = PowerPortTemplate.objects.filter(device_type=device_type)",
            "",
            "",
            "class PowerOutletTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerOutletTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    device_type = forms.ModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        required=False,",
            "        disabled=True,",
            "        widget=forms.HiddenInput(),",
            "    )",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    power_port = forms.ModelChoiceField(queryset=PowerPortTemplate.objects.all(), required=False)",
            "    feed_leg = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletFeedLegChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"power_port\", \"feed_leg\", \"description\"]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port queryset to PowerPortTemplates which belong to the parent DeviceType",
            "        if \"device_type\" in self.initial:",
            "            device_type = DeviceType.objects.filter(pk=self.initial[\"device_type\"]).first()",
            "            self.fields[\"power_port\"].queryset = PowerPortTemplate.objects.filter(device_type=device_type)",
            "        else:",
            "            self.fields[\"power_port\"].choices = ()",
            "            self.fields[\"power_port\"].widget.attrs[\"disabled\"] = True",
            "",
            "",
            "class InterfaceTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = InterfaceTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"mgmt_only\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class InterfaceTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=InterfaceTypeChoices, widget=StaticSelect2())",
            "    mgmt_only = forms.BooleanField(required=False, label=\"Management only\")",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"mgmt_only\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class InterfaceTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=InterfaceTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(InterfaceTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    mgmt_only = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect, label=\"Management only\")",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class FrontPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = FrontPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"rear_port\",",
            "            \"rear_port_position\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "            \"rear_port\": StaticSelect2(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit rear_port choices to current DeviceType",
            "        if hasattr(self.instance, \"device_type\"):",
            "            self.fields[\"rear_port\"].queryset = RearPortTemplate.objects.filter(device_type=self.instance.device_type)",
            "",
            "",
            "class FrontPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=PortTypeChoices, widget=StaticSelect2())",
            "    rear_port_set = forms.MultipleChoiceField(",
            "        choices=[],",
            "        label=\"Rear ports\",",
            "        help_text=\"Select one rear port assignment for each front port being created.\",",
            "    )",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"rear_port_set\",",
            "        \"description\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        device_type = DeviceType.objects.get(pk=self.initial.get(\"device_type\") or self.data.get(\"device_type\"))",
            "",
            "        # Determine which rear port positions are occupied. These will be excluded from the list of available mappings.",
            "        occupied_port_positions = [",
            "            (front_port.rear_port_id, front_port.rear_port_position)",
            "            for front_port in device_type.frontporttemplates.all()",
            "        ]",
            "",
            "        # Populate rear port choices",
            "        choices = []",
            "        rear_ports = RearPortTemplate.objects.filter(device_type=device_type)",
            "        for rear_port in rear_ports:",
            "            for i in range(1, rear_port.positions + 1):",
            "                if (rear_port.pk, i) not in occupied_port_positions:",
            "                    choices.append(",
            "                        (",
            "                            f\"{rear_port.pk}:{i}\",",
            "                            f\"{rear_port.name}:{i}\",",
            "                        )",
            "                    )",
            "        self.fields[\"rear_port_set\"].choices = choices",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate that the number of ports being created equals the number of selected (rear port, position) tuples",
            "        front_port_count = len(self.cleaned_data[\"name_pattern\"])",
            "        rear_port_count = len(self.cleaned_data[\"rear_port_set\"])",
            "        if front_port_count != rear_port_count:",
            "            raise forms.ValidationError(",
            "                {",
            "                    \"rear_port_set\": (",
            "                        f\"The provided name pattern will create {front_port_count} ports, \"",
            "                        f\"however {rear_port_count} rear port assignments were selected. These counts must match.\"",
            "                    )",
            "                }",
            "            )",
            "",
            "    def get_iterative_data(self, iteration):",
            "        # Assign rear port and position from selected set",
            "        rear_port, position = self.cleaned_data[\"rear_port_set\"][iteration].split(\":\")",
            "",
            "        return {",
            "            \"rear_port\": rear_port,",
            "            \"rear_port_position\": int(position),",
            "        }",
            "",
            "",
            "class FrontPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=FrontPortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "class RearPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = RearPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"positions\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class RearPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=PortTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    positions = forms.IntegerField(",
            "        min_value=REARPORT_POSITIONS_MIN,",
            "        max_value=REARPORT_POSITIONS_MAX,",
            "        initial=1,",
            "        help_text=\"The number of front ports which may be mapped to each rear port\",",
            "    )",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"positions\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class RearPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=RearPortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "class DeviceBayTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = DeviceBayTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class DeviceBayTemplateCreateForm(ComponentTemplateCreateForm):",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class DeviceBayTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceBayTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = (\"label\", \"description\")",
            "",
            "",
            "#",
            "# Component template import forms",
            "#",
            "",
            "",
            "class ComponentTemplateImportForm(BootstrapMixin, CustomFieldModelCSVForm):",
            "    def __init__(self, device_type, data=None, *args, **kwargs):",
            "        # Must pass the parent DeviceType on form initialization",
            "        data.update(",
            "            {",
            "                \"device_type\": device_type.pk,",
            "            }",
            "        )",
            "",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "    def clean_device_type(self):",
            "        data = self.cleaned_data[\"device_type\"]",
            "",
            "        # Limit fields referencing other components to the parent DeviceType",
            "        for field_name, field in self.fields.items():",
            "            if isinstance(field, forms.ModelChoiceField) and field_name != \"device_type\":",
            "                field.queryset = field.queryset.filter(device_type=data)",
            "",
            "        return data",
            "",
            "",
            "class ConsolePortTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = ConsolePortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "        ]",
            "",
            "",
            "class ConsoleServerPortTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = ConsoleServerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "        ]",
            "",
            "",
            "class PowerPortTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = PowerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "        ]",
            "",
            "",
            "class PowerOutletTemplateImportForm(ComponentTemplateImportForm):",
            "    power_port = forms.ModelChoiceField(queryset=PowerPortTemplate.objects.all(), to_field_name=\"name\", required=False)",
            "",
            "    class Meta:",
            "        model = PowerOutletTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"power_port\",",
            "            \"feed_leg\",",
            "        ]",
            "",
            "",
            "class InterfaceTemplateImportForm(ComponentTemplateImportForm):",
            "    type = forms.ChoiceField(choices=InterfaceTypeChoices.CHOICES)",
            "",
            "    class Meta:",
            "        model = InterfaceTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"mgmt_only\",",
            "        ]",
            "",
            "",
            "class FrontPortTemplateImportForm(ComponentTemplateImportForm):",
            "    type = forms.ChoiceField(choices=PortTypeChoices.CHOICES)",
            "    rear_port = forms.ModelChoiceField(queryset=RearPortTemplate.objects.all(), to_field_name=\"name\", required=False)",
            "",
            "    class Meta:",
            "        model = FrontPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"type\",",
            "            \"rear_port\",",
            "            \"rear_port_position\",",
            "        ]",
            "",
            "",
            "class RearPortTemplateImportForm(ComponentTemplateImportForm):",
            "    type = forms.ChoiceField(choices=PortTypeChoices.CHOICES)",
            "",
            "    class Meta:",
            "        model = RearPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"type\",",
            "            \"positions\",",
            "        ]",
            "",
            "",
            "class DeviceBayTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = DeviceBayTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "        ]",
            "",
            "",
            "#",
            "# Device roles",
            "#",
            "",
            "",
            "class DeviceRoleForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = DeviceRole",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"color\",",
            "            \"vm_role\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class DeviceRoleCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = DeviceRole",
            "        fields = DeviceRole.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),",
            "        }",
            "",
            "",
            "#",
            "# Platforms",
            "#",
            "",
            "",
            "class PlatformForm(NautobotModelForm):",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    slug = SlugField(max_length=64)",
            "",
            "    class Meta:",
            "        model = Platform",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"manufacturer\",",
            "            \"network_driver\",",
            "            \"napalm_driver\",",
            "            \"napalm_args\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"napalm_args\": SmallTextarea(),",
            "        }",
            "",
            "",
            "class PlatformCSVForm(CustomFieldModelCSVForm):",
            "    manufacturer = CSVModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Limit platform assignments to this manufacturer\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Platform",
            "        fields = Platform.csv_headers",
            "",
            "",
            "#",
            "# Devices",
            "#",
            "",
            "",
            "class DeviceForm(LocatableModelFormMixin, NautobotModelForm, TenancyForm, LocalContextModelForm):",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "        initial_params={\"racks\": \"$rack\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"group_id\": \"$rack_group\",",
            "        },",
            "    )",
            "    device_redundancy_group = DynamicModelChoiceField(queryset=DeviceRedundancyGroup.objects.all(), required=False)",
            "    position = forms.IntegerField(",
            "        required=False,",
            "        help_text=\"The lowest-numbered unit occupied by the device\",",
            "        widget=APISelect(",
            "            api_url=\"/api/dcim/racks/{{rack}}/elevation/\",",
            "            attrs={",
            "                \"disabled-indicator\": \"device\",",
            "                \"data-query-param-face\": '[\"$face\"]',",
            "            },",
            "        ),",
            "    )",
            "    manufacturer = DynamicModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        required=False,",
            "        initial_params={\"device_types\": \"$device_type\"},",
            "    )",
            "    device_type = DynamicModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        query_params={\"manufacturer_id\": \"$manufacturer\"},",
            "    )",
            "    device_role = DynamicModelChoiceField(queryset=DeviceRole.objects.all())",
            "    platform = DynamicModelChoiceField(",
            "        queryset=Platform.objects.all(),",
            "        required=False,",
            "        query_params={\"manufacturer_id\": [\"$manufacturer\", \"null\"]},",
            "    )",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "    cluster_group = DynamicModelChoiceField(",
            "        queryset=ClusterGroup.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        initial_params={\"clusters\": \"$cluster\"},",
            "    )",
            "    cluster = DynamicModelChoiceField(",
            "        queryset=Cluster.objects.all(),",
            "        required=False,",
            "        query_params={\"group_id\": \"$cluster_group\"},",
            "    )",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = Device",
            "        fields = [",
            "            \"name\",",
            "            \"device_role\",",
            "            \"device_type\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"site\",",
            "            \"location\",",
            "            \"rack\",",
            "            \"device_redundancy_group\",",
            "            \"device_redundancy_group_priority\",",
            "            \"position\",",
            "            \"face\",",
            "            \"status\",",
            "            \"platform\",",
            "            \"primary_ip4\",",
            "            \"primary_ip6\",",
            "            \"secrets_group\",",
            "            \"cluster_group\",",
            "            \"cluster\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"comments\",",
            "            \"tags\",",
            "            \"local_context_data\",",
            "            \"local_context_schema\",",
            "        ]",
            "        help_texts = {",
            "            \"device_role\": \"The function this device serves\",",
            "            \"serial\": \"Chassis serial number\",",
            "            \"local_context_data\": \"Local config context data overwrites all source contexts in the final rendered \"",
            "            \"config context\",",
            "        }",
            "        widgets = {",
            "            \"face\": StaticSelect2(),",
            "            \"primary_ip4\": StaticSelect2(),",
            "            \"primary_ip6\": StaticSelect2(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if self.instance.present_in_database:",
            "            # Compile list of choices for primary IPv4 and IPv6 addresses",
            "            for family in [4, 6]:",
            "                ip_choices = [(None, \"---------\")]",
            "",
            "                # Gather PKs of all interfaces belonging to this Device or a peer VirtualChassis member",
            "                interface_ids = self.instance.vc_interfaces.values_list(\"pk\", flat=True)",
            "",
            "                # Collect interface IPs",
            "                # v2 TODO(jathan): Replace prefetch_related with select_related",
            "                interface_ips = (",
            "                    IPAddress.objects.ip_family(family)",
            "                    .filter(",
            "                        assigned_object_type=ContentType.objects.get_for_model(Interface),",
            "                        assigned_object_id__in=interface_ids,",
            "                    )",
            "                    .prefetch_related(\"assigned_object\")",
            "                )",
            "                if interface_ips:",
            "                    ip_list = [(ip.id, f\"{ip.address} ({ip.assigned_object})\") for ip in interface_ips]",
            "                    ip_choices.append((\"Interface IPs\", ip_list))",
            "                # Collect NAT IPs",
            "                # v2 TODO(jathan): Replace prefetch_related with select_related",
            "                nat_ips = (",
            "                    IPAddress.objects.select_related(\"nat_inside\")",
            "                    .ip_family(family)",
            "                    .filter(",
            "                        nat_inside__assigned_object_type=ContentType.objects.get_for_model(Interface),",
            "                        nat_inside__assigned_object_id__in=interface_ids,",
            "                    )",
            "                    .prefetch_related(\"assigned_object\")",
            "                )",
            "                if nat_ips:",
            "                    ip_list = [(ip.id, f\"{ip.address} (NAT)\") for ip in nat_ips]",
            "                    ip_choices.append((\"NAT IPs\", ip_list))",
            "                self.fields[f\"primary_ip{family}\"].choices = ip_choices",
            "",
            "            # If editing an existing device, exclude it from the list of occupied rack units. This ensures that a device",
            "            # can be flipped from one face to another.",
            "            self.fields[\"position\"].widget.add_query_param(\"exclude\", self.instance.pk)",
            "",
            "            # Limit platform by manufacturer",
            "            self.fields[\"platform\"].queryset = Platform.objects.filter(",
            "                Q(manufacturer__isnull=True) | Q(manufacturer=self.instance.device_type.manufacturer)",
            "            )",
            "",
            "            # Disable rack assignment if this is a child device installed in a parent device",
            "            if self.instance.device_type.is_child_device and hasattr(self.instance, \"parent_bay\"):",
            "                self.fields[\"site\"].disabled = True",
            "                self.fields[\"rack\"].disabled = True",
            "                self.initial[\"site\"] = self.instance.parent_bay.device.site_id",
            "                self.initial[\"rack\"] = self.instance.parent_bay.device.rack_id",
            "",
            "        else:",
            "            # An object that doesn't exist yet can't have any IPs assigned to it",
            "            self.fields[\"primary_ip4\"].choices = []",
            "            self.fields[\"primary_ip4\"].widget.attrs[\"readonly\"] = True",
            "            self.fields[\"primary_ip6\"].choices = []",
            "            self.fields[\"primary_ip6\"].widget.attrs[\"readonly\"] = True",
            "",
            "        # Rack position",
            "        position = self.data.get(\"position\") or self.initial.get(\"position\")",
            "        if position:",
            "            self.fields[\"position\"].widget.choices = [(position, f\"U{position}\")]",
            "",
            "",
            "class BaseDeviceCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    device_role = CSVModelChoiceField(",
            "        queryset=DeviceRole.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned role\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "    manufacturer = CSVModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Device type manufacturer\",",
            "    )",
            "    device_type = CSVModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        to_field_name=\"model\",",
            "        help_text=\"Device type model\",",
            "    )",
            "    platform = CSVModelChoiceField(",
            "        queryset=Platform.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned platform\",",
            "    )",
            "    cluster = CSVModelChoiceField(",
            "        queryset=Cluster.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Virtualization cluster\",",
            "    )",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Secrets group\",",
            "    )",
            "",
            "    class Meta:",
            "        fields = []",
            "        model = Device",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit device type queryset by manufacturer",
            "            params = {f\"manufacturer__{self.fields['manufacturer'].to_field_name}\": data.get(\"manufacturer\")}",
            "            self.fields[\"device_type\"].queryset = self.fields[\"device_type\"].queryset.filter(**params)",
            "",
            "",
            "class DeviceCSVForm(LocatableModelCSVFormMixin, BaseDeviceCSVForm):",
            "    rack_group = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack's group (if any)\",",
            "    )",
            "    rack = CSVModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Assigned rack\",",
            "    )",
            "    face = CSVChoiceField(choices=DeviceFaceChoices, required=False, help_text=\"Mounted rack face\")",
            "    device_redundancy_group = CSVModelChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        help_text=\"Associated device redundancy group (slug)\",",
            "    )",
            "",
            "    class Meta(BaseDeviceCSVForm.Meta):",
            "        fields = [",
            "            \"name\",",
            "            \"device_role\",",
            "            \"tenant\",",
            "            \"manufacturer\",",
            "            \"device_type\",",
            "            \"platform\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"status\",",
            "            \"site\",",
            "            \"location\",",
            "            \"rack_group\",",
            "            \"rack\",",
            "            \"position\",",
            "            \"face\",",
            "            \"device_redundancy_group\",",
            "            \"device_redundancy_group_priority\",",
            "            \"cluster\",",
            "            \"comments\",",
            "        ]",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit rack_group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "            # Limit rack queryset by assigned site and group",
            "            params = {",
            "                f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\"),",
            "                f\"group__{self.fields['rack_group'].to_field_name}\": data.get(\"rack_group\"),",
            "            }",
            "            self.fields[\"rack\"].queryset = self.fields[\"rack\"].queryset.filter(**params)",
            "",
            "            # 2.0 TODO: limit location queryset by assigned site",
            "",
            "",
            "class ChildDeviceCSVForm(BaseDeviceCSVForm):",
            "    parent = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\", help_text=\"Parent device\")",
            "    device_bay = CSVModelChoiceField(",
            "        queryset=DeviceBay.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Device bay in which this device is installed\",",
            "    )",
            "",
            "    class Meta(BaseDeviceCSVForm.Meta):",
            "        fields = [",
            "            \"name\",",
            "            \"device_role\",",
            "            \"tenant\",",
            "            \"manufacturer\",",
            "            \"device_type\",",
            "            \"platform\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"status\",",
            "            \"parent\",",
            "            \"device_bay\",",
            "            \"cluster\",",
            "            \"comments\",",
            "        ]",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit device bay queryset by parent device",
            "            params = {f\"device__{self.fields['parent'].to_field_name}\": data.get(\"parent\")}",
            "            self.fields[\"device_bay\"].queryset = self.fields[\"device_bay\"].queryset.filter(**params)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Set parent_bay reverse relationship",
            "        device_bay = self.cleaned_data.get(\"device_bay\")",
            "        if device_bay:",
            "            self.instance.parent_bay = device_bay",
            "",
            "        # Inherit site and rack from parent device",
            "        parent = self.cleaned_data.get(\"parent\")",
            "        if parent:",
            "            self.instance.site = parent.site",
            "            self.instance.rack = parent.rack",
            "",
            "",
            "class DeviceBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    LocatableModelBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "    LocalContextModelBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Device.objects.all(), widget=forms.MultipleHiddenInput())",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    device_type = DynamicModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        required=False,",
            "        query_params={\"manufacturer_id\": \"$manufacturer\"},",
            "    )",
            "    rack = DynamicModelChoiceField(queryset=Rack.objects.all(), required=False)",
            "    position = forms.IntegerField(required=False)",
            "    face = forms.ChoiceField(",
            "        required=False,",
            "        choices=add_blank_choice(DeviceFaceChoices),",
            "        widget=StaticSelect2(),",
            "    )",
            "    rack_group = DynamicModelChoiceField(queryset=RackGroup.objects.all(), required=False)",
            "    device_role = DynamicModelChoiceField(queryset=DeviceRole.objects.all(), required=False)",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    platform = DynamicModelChoiceField(queryset=Platform.objects.all(), required=False)",
            "    serial = forms.CharField(max_length=255, required=False, label=\"Serial Number\")",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "    device_redundancy_group = DynamicModelChoiceField(queryset=DeviceRedundancyGroup.objects.all(), required=False)",
            "    device_redundancy_group_priority = forms.IntegerField(required=False, min_value=1)",
            "",
            "    class Meta:",
            "        model = Device",
            "        nullable_fields = [",
            "            \"location\",",
            "            \"tenant\",",
            "            \"platform\",",
            "            \"serial\",",
            "            \"rack\",",
            "            \"position\",",
            "            \"face\",",
            "            \"rack_group\",",
            "            \"secrets_group\",",
            "            \"device_redundancy_group\",",
            "            \"device_redundancy_group_priority\",",
            "        ]",
            "",
            "    def __init__(self, *args, **kwrags):",
            "        super().__init__(*args, **kwrags)",
            "",
            "        # Disable position because only setting null value is required",
            "        self.fields[\"position\"].disabled = True",
            "",
            "",
            "class DeviceFilterForm(",
            "    NautobotFilterForm,",
            "    LocalContextFilterForm,",
            "    LocatableModelFilterFormMixin,",
            "    TenancyFilterForm,",
            "    StatusModelFilterFormMixin,",
            "):",
            "    model = Device",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"location\",",
            "        \"rack_group_id\",",
            "        \"rack_id\",",
            "        \"status\",",
            "        \"role\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "        \"manufacturer_id\",",
            "        \"device_type_id\",",
            "        \"mac_address\",",
            "        \"has_primary_ip\",",
            "    ]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    rack_group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        label=\"Rack group\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    rack_id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        label=\"Rack\",",
            "        null_option=\"None\",",
            "        query_params={",
            "            \"site\": \"$site\",",
            "            \"group_id\": \"$rack_group_id\",",
            "        },",
            "    )",
            "    role = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), to_field_name=\"slug\", required=False)",
            "    manufacturer = DynamicModelMultipleChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        label=\"Manufacturer\",",
            "    )",
            "    device_type_id = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        required=False,",
            "        label=\"Model\",",
            "        query_params={\"manufacturer\": \"$manufacturer\"},",
            "    )",
            "    platform = DynamicModelMultipleChoiceField(",
            "        queryset=Platform.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    mac_address = forms.CharField(required=False, label=\"MAC address\")",
            "    device_redundancy_group = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    device_redundancy_group_priority = forms.IntegerField(min_value=1, required=False)",
            "    has_primary_ip = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has a primary IP\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    virtual_chassis_member = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Virtual chassis member\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    console_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    console_server_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console server ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_outlets = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power outlets\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    interfaces = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has interfaces\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    pass_through_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has pass-through ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Device components",
            "#",
            "",
            "",
            "class ComponentCreateForm(ComponentForm):",
            "    \"\"\"",
            "    Base form for the creation of device components (models subclassed from ComponentModel).",
            "    \"\"\"",
            "",
            "    device = DynamicModelChoiceField(queryset=Device.objects.all())",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "",
            "class DeviceBulkAddComponentForm(ComponentForm, CustomFieldModelBulkEditFormMixin):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Device.objects.all(), widget=forms.MultipleHiddenInput())",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "#",
            "# Console ports",
            "#",
            "",
            "",
            "class ConsolePortFilterForm(DeviceComponentFilterForm):",
            "    model = ConsolePort",
            "    type = forms.MultipleChoiceField(choices=ConsolePortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class ConsolePortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsolePort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsolePortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class ConsolePortBulkCreateForm(form_from_model(ConsolePort, [\"type\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (\"name_pattern\", \"label_pattern\", \"type\", \"description\", \"tags\")",
            "",
            "",
            "class ConsolePortBulkEditForm(",
            "    form_from_model(ConsolePort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConsolePort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class ConsolePortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=ConsolePortTypeChoices, required=False, help_text=\"Port type\")",
            "",
            "    class Meta:",
            "        model = ConsolePort",
            "        fields = ConsolePort.csv_headers",
            "",
            "",
            "#",
            "# Console server ports",
            "#",
            "",
            "",
            "class ConsoleServerPortFilterForm(DeviceComponentFilterForm):",
            "    model = ConsoleServerPort",
            "    type = forms.MultipleChoiceField(choices=ConsolePortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class ConsoleServerPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsoleServerPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsoleServerPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class ConsoleServerPortBulkCreateForm(form_from_model(ConsoleServerPort, [\"type\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (\"name_pattern\", \"label_pattern\", \"type\", \"description\", \"tags\")",
            "",
            "",
            "class ConsoleServerPortBulkEditForm(",
            "    form_from_model(ConsoleServerPort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConsoleServerPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class ConsoleServerPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=ConsolePortTypeChoices, required=False, help_text=\"Port type\")",
            "",
            "    class Meta:",
            "        model = ConsoleServerPort",
            "        fields = ConsoleServerPort.csv_headers",
            "",
            "",
            "#",
            "# Power ports",
            "#",
            "",
            "",
            "class PowerPortFilterForm(DeviceComponentFilterForm):",
            "    model = PowerPort",
            "    type = forms.MultipleChoiceField(choices=PowerPortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class PowerPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = PowerPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class PowerPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerPortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    maximum_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Maximum draw in watts\")",
            "    allocated_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Allocated draw in watts\")",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"maximum_draw\",",
            "        \"allocated_draw\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class PowerPortBulkCreateForm(",
            "    form_from_model(PowerPort, [\"type\", \"maximum_draw\", \"allocated_draw\", \"tags\"]),",
            "    DeviceBulkAddComponentForm,",
            "):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"maximum_draw\",",
            "        \"allocated_draw\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class PowerPortBulkEditForm(",
            "    form_from_model(PowerPort, [\"label\", \"type\", \"maximum_draw\", \"allocated_draw\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class PowerPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=PowerPortTypeChoices, required=False, help_text=\"Port type\")",
            "",
            "    class Meta:",
            "        model = PowerPort",
            "        fields = PowerPort.csv_headers",
            "",
            "",
            "#",
            "# Power outlets",
            "#",
            "",
            "",
            "class PowerOutletFilterForm(DeviceComponentFilterForm):",
            "    model = PowerOutlet",
            "    type = forms.MultipleChoiceField(choices=PowerOutletTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class PowerOutletForm(NautobotModelForm):",
            "    power_port = forms.ModelChoiceField(queryset=PowerPort.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        model = PowerOutlet",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"power_port\",",
            "            \"feed_leg\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port choices to the local device",
            "        if hasattr(self.instance, \"device\"):",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device=self.instance.device)",
            "",
            "",
            "class PowerOutletCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    power_port = forms.ModelChoiceField(queryset=PowerPort.objects.all(), required=False)",
            "    feed_leg = forms.ChoiceField(choices=add_blank_choice(PowerOutletFeedLegChoices), required=False)",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"power_port\",",
            "        \"feed_leg\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port queryset to PowerPorts which belong to the parent Device",
            "        device = Device.objects.get(pk=self.initial.get(\"device\") or self.data.get(\"device\"))",
            "        self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device=device)",
            "",
            "",
            "class PowerOutletBulkCreateForm(form_from_model(PowerOutlet, [\"type\", \"feed_leg\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"feed_leg\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class PowerOutletBulkEditForm(",
            "    form_from_model(PowerOutlet, [\"label\", \"type\", \"feed_leg\", \"power_port\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerOutlet.objects.all(), widget=forms.MultipleHiddenInput())",
            "    device = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        disabled=True,",
            "        widget=forms.HiddenInput(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"feed_leg\", \"power_port\", \"description\"]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port queryset to PowerPorts which belong to the parent Device",
            "        if \"device\" in self.initial:",
            "            device = Device.objects.filter(pk=self.initial[\"device\"]).first()",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device=device)",
            "        else:",
            "            self.fields[\"power_port\"].choices = ()",
            "            self.fields[\"power_port\"].widget.attrs[\"disabled\"] = True",
            "",
            "",
            "class PowerOutletCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=PowerOutletTypeChoices, required=False, help_text=\"Outlet type\")",
            "    power_port = CSVModelChoiceField(",
            "        queryset=PowerPort.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Local power port which feeds this outlet\",",
            "    )",
            "    feed_leg = CSVChoiceField(",
            "        choices=PowerOutletFeedLegChoices,",
            "        required=False,",
            "        help_text=\"Electrical phase (for three-phase circuits)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = PowerOutlet",
            "        fields = PowerOutlet.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit PowerPort choices to those belonging to this device (or VC master)",
            "        if self.is_bound:",
            "            try:",
            "                device = self.fields[\"device\"].to_python(self.data[\"device\"])",
            "            except forms.ValidationError:",
            "                device = None",
            "        else:",
            "            try:",
            "                device = self.instance.device",
            "            except Device.DoesNotExist:",
            "                device = None",
            "",
            "        if device:",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device__in=[device, device.get_vc_master()])",
            "        else:",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.none()",
            "",
            "",
            "#",
            "# Interfaces",
            "#",
            "",
            "",
            "class InterfaceFilterForm(DeviceComponentFilterForm, StatusModelFilterFormMixin):",
            "    model = Interface",
            "    type = forms.MultipleChoiceField(choices=InterfaceTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    mgmt_only = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    mac_address = forms.CharField(required=False, label=\"MAC address\")",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class InterfaceForm(InterfaceCommonForm, NautobotModelForm):",
            "    parent_interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        label=\"Parent interface\",",
            "        query_params={",
            "            \"kind\": \"physical\",",
            "        },",
            "        help_text=\"Assigned parent interface\",",
            "    )",
            "    bridge = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        label=\"Bridge interface\",",
            "        help_text=\"Assigned bridge interface\",",
            "    )",
            "    lag = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        label=\"LAG interface\",",
            "        query_params={",
            "            \"type\": InterfaceTypeChoices.TYPE_LAG,",
            "        },",
            "        help_text=\"Assigned LAG interface\",",
            "    )",
            "    untagged_vlan = DynamicModelChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        label=\"Untagged VLAN\",",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "    tagged_vlans = DynamicModelMultipleChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        label=\"Tagged VLANs\",",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = Interface",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"enabled\",",
            "            \"parent_interface\",",
            "            \"bridge\",",
            "            \"lag\",",
            "            \"mac_address\",",
            "            \"mtu\",",
            "            \"mgmt_only\",",
            "            \"description\",",
            "            \"mode\",",
            "            \"untagged_vlan\",",
            "            \"tagged_vlans\",",
            "            \"tags\",",
            "            \"status\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "            \"mode\": StaticSelect2(),",
            "        }",
            "        labels = {",
            "            \"mode\": \"802.1Q Mode\",",
            "        }",
            "        help_texts = {",
            "            \"mode\": INTERFACE_MODE_HELP_TEXT,",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if self.is_bound:",
            "            device = Device.objects.get(pk=self.data[\"device\"])",
            "        else:",
            "            device = self.instance.device",
            "",
            "        # Restrict parent/bridge/LAG interface assignment by device",
            "        self.fields[\"parent_interface\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "        self.fields[\"bridge\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "        self.fields[\"lag\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "",
            "        # Add current site to VLANs query params",
            "        self.fields[\"untagged_vlan\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "        self.fields[\"tagged_vlans\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "",
            "",
            "class InterfaceCreateForm(ComponentCreateForm, InterfaceCommonForm):",
            "    type = forms.ChoiceField(",
            "        choices=InterfaceTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    status = DynamicModelChoiceField(",
            "        queryset=Status.objects.all(),",
            "        query_params={",
            "            \"content_types\": Interface._meta.label_lower,",
            "        },",
            "    )",
            "    enabled = forms.BooleanField(required=False, initial=True)",
            "    parent_interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"device_with_common_vc\": \"$device\",",
            "            \"kind\": \"physical\",",
            "        },",
            "        help_text=\"Assigned parent interface\",",
            "    )",
            "    bridge = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"device_with_common_vc\": \"$device\",",
            "        },",
            "        help_text=\"Assigned bridge interface\",",
            "    )",
            "    lag = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"device_with_common_vc\": \"$device\",",
            "            \"type\": InterfaceTypeChoices.TYPE_LAG,",
            "        },",
            "        help_text=\"Assigned LAG interface\",",
            "    )",
            "    mtu = forms.IntegerField(",
            "        required=False,",
            "        min_value=INTERFACE_MTU_MIN,",
            "        max_value=INTERFACE_MTU_MAX,",
            "        label=\"MTU\",",
            "    )",
            "    mac_address = forms.CharField(required=False, label=\"MAC Address\")",
            "    mgmt_only = forms.BooleanField(",
            "        required=False,",
            "        label=\"Management only\",",
            "        help_text=\"This interface is used only for out-of-band management\",",
            "    )",
            "    mode = forms.ChoiceField(",
            "        choices=add_blank_choice(InterfaceModeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    untagged_vlan = DynamicModelChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={",
            "            \"available_on_device\": \"$device\",",
            "        },",
            "    )",
            "    tagged_vlans = DynamicModelMultipleChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={\"available_on_device\": \"$device\"},",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"status\",",
            "        \"type\",",
            "        \"enabled\",",
            "        \"parent_interface\",",
            "        \"bridge\",",
            "        \"lag\",",
            "        \"mtu\",",
            "        \"mac_address\",",
            "        \"description\",",
            "        \"mgmt_only\",",
            "        \"mode\",",
            "        \"untagged_vlan\",",
            "        \"tagged_vlans\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InterfaceBulkCreateForm(",
            "    form_from_model(Interface, [\"enabled\", \"mtu\", \"mgmt_only\", \"mode\", \"tags\"]),",
            "    DeviceBulkAddComponentForm,",
            "):",
            "    type = forms.ChoiceField(",
            "        choices=InterfaceTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    status = DynamicModelChoiceField(",
            "        required=True,",
            "        queryset=Status.objects.all(),",
            "        query_params={\"content_types\": Interface._meta.label_lower},",
            "    )",
            "",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"status\",",
            "        \"type\",",
            "        \"enabled\",",
            "        \"mtu\",",
            "        \"mgmt_only\",",
            "        \"description\",",
            "        \"mode\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InterfaceBulkEditForm(",
            "    form_from_model(",
            "        Interface, [\"label\", \"type\", \"parent_interface\", \"bridge\", \"lag\", \"mac_address\", \"mtu\", \"description\", \"mode\"]",
            "    ),",
            "    TagsBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Interface.objects.all(), widget=forms.MultipleHiddenInput())",
            "    device = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        disabled=True,",
            "        widget=forms.HiddenInput(),",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect)",
            "    parent_interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"kind\": \"physical\",",
            "        },",
            "    )",
            "    bridge = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "    )",
            "    lag = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"type\": InterfaceTypeChoices.TYPE_LAG,",
            "        },",
            "    )",
            "    mgmt_only = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect, label=\"Management only\")",
            "    untagged_vlan = DynamicModelChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "    tagged_vlans = DynamicModelMultipleChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"label\",",
            "            \"parent_interface\",",
            "            \"bridge\",",
            "            \"lag\",",
            "            \"mac_address\",",
            "            \"mtu\",",
            "            \"description\",",
            "            \"mode\",",
            "            \"untagged_vlan\",",
            "            \"tagged_vlans\",",
            "        ]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit LAG choices to interfaces which belong to the parent device (or VC master)",
            "        if \"device\" in self.initial:",
            "            device = Device.objects.filter(pk=self.initial[\"device\"]).first()",
            "",
            "            # Restrict parent/bridge/LAG interface assignment by device",
            "            self.fields[\"parent_interface\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "            self.fields[\"bridge\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "            self.fields[\"lag\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "",
            "            # Add current site to VLANs query params",
            "            self.fields[\"untagged_vlan\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "            self.fields[\"tagged_vlans\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "        else:",
            "            # See netbox-community/netbox#4523",
            "            if \"pk\" in self.initial:",
            "                site = None",
            "                interfaces = Interface.objects.filter(pk__in=self.initial[\"pk\"]).select_related(\"device__site\")",
            "",
            "                # Check interface sites.  First interface should set site, further interfaces will either continue the",
            "                # loop or reset back to no site and break the loop.",
            "                for interface in interfaces:",
            "                    if site is None:",
            "                        site = interface.device.site",
            "                    elif interface.device.site is not site:",
            "                        site = None",
            "                        break",
            "",
            "                if site is not None:",
            "                    self.fields[\"untagged_vlan\"].widget.add_query_param(\"site_id\", site.pk)",
            "                    self.fields[\"tagged_vlans\"].widget.add_query_param(\"site_id\", site.pk)",
            "",
            "            self.fields[\"parent_interface\"].choices = ()",
            "            self.fields[\"parent_interface\"].widget.attrs[\"disabled\"] = True",
            "            self.fields[\"bridge\"].choices = ()",
            "            self.fields[\"bridge\"].widget.attrs[\"disabled\"] = True",
            "            self.fields[\"lag\"].choices = ()",
            "            self.fields[\"lag\"].widget.attrs[\"disabled\"] = True",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Untagged interfaces cannot be assigned tagged VLANs",
            "        if self.cleaned_data[\"mode\"] == InterfaceModeChoices.MODE_ACCESS and self.cleaned_data[\"tagged_vlans\"]:",
            "            raise forms.ValidationError({\"mode\": \"An access interface cannot have tagged VLANs assigned.\"})",
            "",
            "        # Remove all tagged VLAN assignments from \"tagged all\" interfaces",
            "        elif self.cleaned_data[\"mode\"] == InterfaceModeChoices.MODE_TAGGED_ALL:",
            "            self.cleaned_data[\"tagged_vlans\"] = []",
            "",
            "",
            "class InterfaceCSVForm(CustomFieldModelCSVForm, StatusModelCSVFormMixin):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    parent_interface = CSVModelChoiceField(",
            "        queryset=Interface.objects.all(), required=False, to_field_name=\"name\", help_text=\"Parent interface\"",
            "    )",
            "    bridge = CSVModelChoiceField(",
            "        queryset=Interface.objects.all(), required=False, to_field_name=\"name\", help_text=\"Bridge interface\"",
            "    )",
            "    lag = CSVModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent LAG interface\",",
            "    )",
            "    type = CSVChoiceField(choices=InterfaceTypeChoices, help_text=\"Physical medium\")",
            "    mode = CSVChoiceField(",
            "        choices=InterfaceModeChoices,",
            "        required=False,",
            "        help_text=\"IEEE 802.1Q operational mode (for L2 interfaces)\",",
            "    )",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit choices for parent, bridge, and LAG interfaces to the assigned device (or VC)",
            "            device_name = data.get(\"device\")",
            "            if device_name is not None:",
            "                device = Device.objects.filter(name=device_name).first()",
            "",
            "                filter_by = Q(device=device)",
            "",
            "                if device and device.virtual_chassis:",
            "                    filter_by |= Q(device__virtual_chassis=device.virtual_chassis)",
            "",
            "                self.fields[\"parent_interface\"].queryset = (",
            "                    self.fields[\"parent_interface\"]",
            "                    .queryset.filter(Q(filter_by))",
            "                    .exclude(type__in=NONCONNECTABLE_IFACE_TYPES)",
            "                )",
            "                self.fields[\"bridge\"].queryset = self.fields[\"bridge\"].queryset.filter(filter_by)",
            "",
            "                filter_by &= Q(type=InterfaceTypeChoices.TYPE_LAG)",
            "                self.fields[\"lag\"].queryset = self.fields[\"lag\"].queryset.filter(filter_by)",
            "            else:",
            "                self.fields[\"parent_interface\"].queryset = self.fields[\"parent_interface\"].queryset.none()",
            "                self.fields[\"bridge\"].queryset = self.fields[\"bridge\"].queryset.none()",
            "                self.fields[\"lag\"].queryset = self.fields[\"lag\"].queryset.none()",
            "",
            "    class Meta:",
            "        model = Interface",
            "        fields = Interface.csv_headers",
            "",
            "    def clean_enabled(self):",
            "        # Make sure enabled is True when it's not included in the uploaded data",
            "        if \"enabled\" not in self.data:",
            "            return True",
            "        else:",
            "            return self.cleaned_data[\"enabled\"]",
            "",
            "",
            "#",
            "# Front pass-through ports",
            "#",
            "",
            "",
            "class FrontPortFilterForm(DeviceComponentFilterForm):",
            "    model = FrontPort",
            "    type = forms.MultipleChoiceField(choices=PortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class FrontPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = FrontPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"rear_port\",",
            "            \"rear_port_position\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "            \"rear_port\": StaticSelect2(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit RearPort choices to the local device",
            "        if hasattr(self.instance, \"device\"):",
            "            self.fields[\"rear_port\"].queryset = self.fields[\"rear_port\"].queryset.filter(device=self.instance.device)",
            "",
            "",
            "# TODO: Merge with FrontPortTemplateCreateForm to remove duplicate logic",
            "class FrontPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=PortTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    rear_port_set = forms.MultipleChoiceField(",
            "        choices=[],",
            "        label=\"Rear ports\",",
            "        help_text=\"Select one rear port assignment for each front port being created.\",",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"rear_port_set\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        device = Device.objects.get(pk=self.initial.get(\"device\") or self.data.get(\"device\"))",
            "",
            "        # Determine which rear port positions are occupied. These will be excluded from the list of available",
            "        # mappings.",
            "        occupied_port_positions = [",
            "            (front_port.rear_port_id, front_port.rear_port_position) for front_port in device.frontports.all()",
            "        ]",
            "",
            "        # Populate rear port choices",
            "        choices = []",
            "        rear_ports = RearPort.objects.filter(device=device)",
            "        for rear_port in rear_ports:",
            "            for i in range(1, rear_port.positions + 1):",
            "                if (rear_port.pk, i) not in occupied_port_positions:",
            "                    choices.append(",
            "                        (",
            "                            f\"{rear_port.pk}:{i}\",",
            "                            f\"{rear_port.name}:{i}\",",
            "                        )",
            "                    )",
            "        self.fields[\"rear_port_set\"].choices = choices",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate that the number of ports being created equals the number of selected (rear port, position) tuples",
            "        front_port_count = len(self.cleaned_data[\"name_pattern\"])",
            "        rear_port_count = len(self.cleaned_data[\"rear_port_set\"])",
            "        if front_port_count != rear_port_count:",
            "            raise forms.ValidationError(",
            "                {",
            "                    \"rear_port_set\": (",
            "                        f\"The provided name pattern will create {front_port_count} ports, \"",
            "                        f\"however {rear_port_count} rear port assignments were selected. These counts must match.\"",
            "                    )",
            "                }",
            "            )",
            "",
            "    def get_iterative_data(self, iteration):",
            "        # Assign rear port and position from selected set",
            "        rear_port, position = self.cleaned_data[\"rear_port_set\"][iteration].split(\":\")",
            "",
            "        return {",
            "            \"rear_port\": rear_port,",
            "            \"rear_port_position\": int(position),",
            "        }",
            "",
            "",
            "# class FrontPortBulkCreateForm(",
            "#     form_from_model(FrontPort, ['label', 'type', 'description', 'tags']),",
            "#     DeviceBulkAddComponentForm",
            "# ):",
            "#     pass",
            "",
            "",
            "class FrontPortBulkEditForm(",
            "    form_from_model(FrontPort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=FrontPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class FrontPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    rear_port = CSVModelChoiceField(",
            "        queryset=RearPort.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Corresponding rear port\",",
            "    )",
            "    type = CSVChoiceField(choices=PortTypeChoices, help_text=\"Physical medium classification\")",
            "",
            "    class Meta:",
            "        model = FrontPort",
            "        fields = FrontPort.csv_headers",
            "        help_texts = {",
            "            \"rear_port_position\": \"Mapped position on corresponding rear port\",",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit RearPort choices to those belonging to this device (or VC master)",
            "        if self.is_bound:",
            "            try:",
            "                device = self.fields[\"device\"].to_python(self.data[\"device\"])",
            "            except forms.ValidationError:",
            "                device = None",
            "        else:",
            "            try:",
            "                device = self.instance.device",
            "            except Device.DoesNotExist:",
            "                device = None",
            "",
            "        if device:",
            "            self.fields[\"rear_port\"].queryset = RearPort.objects.filter(device__in=[device, device.get_vc_master()])",
            "        else:",
            "            self.fields[\"rear_port\"].queryset = RearPort.objects.none()",
            "",
            "",
            "#",
            "# Rear pass-through ports",
            "#",
            "",
            "",
            "class RearPortFilterForm(DeviceComponentFilterForm):",
            "    model = RearPort",
            "    type = forms.MultipleChoiceField(choices=PortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class RearPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = RearPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"positions\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class RearPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=PortTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    positions = forms.IntegerField(",
            "        min_value=REARPORT_POSITIONS_MIN,",
            "        max_value=REARPORT_POSITIONS_MAX,",
            "        initial=1,",
            "        help_text=\"The number of front ports which may be mapped to each rear port\",",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"positions\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class RearPortBulkCreateForm(form_from_model(RearPort, [\"type\", \"positions\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"positions\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class RearPortBulkEditForm(",
            "    form_from_model(RearPort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=RearPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class RearPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(",
            "        help_text=\"Physical medium classification\",",
            "        choices=PortTypeChoices,",
            "    )",
            "",
            "    class Meta:",
            "        model = RearPort",
            "        fields = RearPort.csv_headers",
            "        help_texts = {\"positions\": \"Number of front ports which may be mapped\"}",
            "",
            "",
            "#",
            "# Device bays",
            "#",
            "",
            "",
            "class DeviceBayFilterForm(DeviceComponentFilterForm):",
            "    model = DeviceBay",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class DeviceBayForm(NautobotModelForm):",
            "    class Meta:",
            "        model = DeviceBay",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class DeviceBayCreateForm(ComponentCreateForm):",
            "    field_order = (\"device\", \"name_pattern\", \"label_pattern\", \"description\", \"tags\")",
            "",
            "",
            "class PopulateDeviceBayForm(BootstrapMixin, forms.Form):",
            "    installed_device = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        label=\"Child Device\",",
            "        help_text=\"Child devices must first be created and assigned to the site/rack of the parent device.\",",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    def __init__(self, device_bay, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.fields[\"installed_device\"].queryset = Device.objects.filter(",
            "            site=device_bay.device.site,",
            "            rack=device_bay.device.rack,",
            "            parent_bay__isnull=True,",
            "            device_type__u_height=0,",
            "            device_type__subdevice_role=SubdeviceRoleChoices.ROLE_CHILD,",
            "        ).exclude(pk=device_bay.device.pk)",
            "",
            "",
            "class DeviceBayBulkCreateForm(form_from_model(DeviceBay, [\"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (\"name_pattern\", \"label_pattern\", \"description\", \"tags\")",
            "",
            "",
            "class DeviceBayBulkEditForm(",
            "    form_from_model(DeviceBay, [\"label\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceBay.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class DeviceBayCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    installed_device = CSVModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Child device installed within this bay\",",
            "        error_messages={",
            "            \"invalid_choice\": \"Child device not found.\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = DeviceBay",
            "        fields = DeviceBay.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit installed device choices to devices of the correct type and location",
            "        if self.is_bound:",
            "            try:",
            "                device = self.fields[\"device\"].to_python(self.data[\"device\"])",
            "            except forms.ValidationError:",
            "                device = None",
            "        else:",
            "            try:",
            "                device = self.instance.device",
            "            except Device.DoesNotExist:",
            "                device = None",
            "",
            "        if device:",
            "            self.fields[\"installed_device\"].queryset = Device.objects.filter(",
            "                site=device.site,",
            "                rack=device.rack,",
            "                parent_bay__isnull=True,",
            "                device_type__u_height=0,",
            "                device_type__subdevice_role=SubdeviceRoleChoices.ROLE_CHILD,",
            "            ).exclude(pk=device.pk)",
            "        else:",
            "            self.fields[\"installed_device\"].queryset = Interface.objects.none()",
            "",
            "",
            "#",
            "# Inventory items",
            "#",
            "",
            "",
            "class InventoryItemForm(NautobotModelForm):",
            "    device = DynamicModelChoiceField(queryset=Device.objects.all())",
            "    parent = DynamicModelChoiceField(",
            "        queryset=InventoryItem.objects.all(),",
            "        required=False,",
            "        query_params={\"device_id\": \"$device\"},",
            "    )",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        model = InventoryItem",
            "        fields = [",
            "            \"device\",",
            "            \"parent\",",
            "            \"name\",",
            "            \"label\",",
            "            \"manufacturer\",",
            "            \"part_id\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class InventoryItemCreateForm(ComponentCreateForm):",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    parent = DynamicModelChoiceField(",
            "        queryset=InventoryItem.objects.all(),",
            "        required=False,",
            "        query_params={\"device_id\": \"$device\"},",
            "    )",
            "    part_id = forms.CharField(max_length=50, required=False, label=\"Part ID\")",
            "    serial = forms.CharField(",
            "        max_length=255,",
            "        required=False,",
            "    )",
            "    asset_tag = forms.CharField(",
            "        max_length=50,",
            "        required=False,",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"parent\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"manufacturer\",",
            "        \"part_id\",",
            "        \"serial\",",
            "        \"asset_tag\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InventoryItemCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    manufacturer = CSVModelChoiceField(queryset=Manufacturer.objects.all(), to_field_name=\"name\", required=False)",
            "",
            "    class Meta:",
            "        model = InventoryItem",
            "        fields = InventoryItem.csv_headers",
            "",
            "",
            "class InventoryItemBulkCreateForm(",
            "    form_from_model(InventoryItem, [\"manufacturer\", \"part_id\", \"serial\", \"asset_tag\", \"discovered\", \"tags\"]),",
            "    DeviceBulkAddComponentForm,",
            "):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"manufacturer\",",
            "        \"part_id\",",
            "        \"serial\",",
            "        \"asset_tag\",",
            "        \"discovered\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InventoryItemBulkEditForm(",
            "    form_from_model(InventoryItem, [\"label\", \"manufacturer\", \"part_id\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=InventoryItem.objects.all(), widget=forms.MultipleHiddenInput())",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"manufacturer\", \"part_id\", \"description\"]",
            "",
            "",
            "class InventoryItemFilterForm(DeviceComponentFilterForm):",
            "    model = InventoryItem",
            "    manufacturer = DynamicModelMultipleChoiceField(",
            "        queryset=Manufacturer.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    serial = forms.CharField(required=False)",
            "    asset_tag = forms.CharField(required=False)",
            "    discovered = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Cables",
            "#",
            "",
            "",
            "class ConnectCableToDeviceForm(ConnectCableExcludeIDMixin, NautobotModelForm):",
            "    \"\"\"",
            "    Base form for connecting a Cable to a Device component",
            "    \"\"\"",
            "",
            "    termination_b_region = DynamicModelChoiceField(queryset=Region.objects.all(), label=\"Region\", required=False)",
            "    termination_b_site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        label=\"Site\",",
            "        required=False,",
            "        query_params={\"region_id\": \"$termination_b_region\"},",
            "    )",
            "    termination_b_rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        label=\"Rack\",",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$termination_b_site\"},",
            "    )",
            "    termination_b_device = DynamicModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        label=\"Device\",",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$termination_b_site\",",
            "            \"rack_id\": \"$termination_b_rack\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"termination_b_region\",",
            "            \"termination_b_site\",",
            "            \"termination_b_rack\",",
            "            \"termination_b_device\",",
            "            \"termination_b_id\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"type\": StaticSelect2,",
            "            \"length_unit\": StaticSelect2,",
            "        }",
            "        help_texts = {",
            "            \"status\": \"Connection status\",",
            "        }",
            "",
            "    def clean_termination_b_id(self):",
            "        # Return the PK rather than the object",
            "        return getattr(self.cleaned_data[\"termination_b_id\"], \"pk\", None)",
            "",
            "",
            "class ConnectCableToConsolePortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=ConsolePort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToConsoleServerPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=ConsoleServerPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToPowerPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=PowerPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToPowerOutletForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=PowerOutlet.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToInterfaceForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={",
            "            \"device_id\": \"$termination_b_device\",",
            "            \"kind\": \"physical\",",
            "        },",
            "    )",
            "",
            "",
            "class ConnectCableToFrontPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=FrontPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToRearPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=RearPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToCircuitTerminationForm(ConnectCableExcludeIDMixin, NautobotModelForm):",
            "    termination_b_provider = DynamicModelChoiceField(queryset=Provider.objects.all(), label=\"Provider\", required=False)",
            "    termination_b_region = DynamicModelChoiceField(queryset=Region.objects.all(), label=\"Region\", required=False)",
            "    termination_b_site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        label=\"Site\",",
            "        required=False,",
            "        query_params={\"region_id\": \"$termination_b_region\"},",
            "    )",
            "    termination_b_circuit = DynamicModelChoiceField(",
            "        queryset=Circuit.objects.all(),",
            "        label=\"Circuit\",",
            "        query_params={",
            "            \"provider_id\": \"$termination_b_provider\",",
            "            \"site_id\": \"$termination_b_site\",",
            "        },",
            "    )",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=CircuitTermination.objects.all(),",
            "        label=\"Side\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"circuit_id\": \"$termination_b_circuit\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"termination_b_provider\",",
            "            \"termination_b_region\",",
            "            \"termination_b_site\",",
            "            \"termination_b_circuit\",",
            "            \"termination_b_id\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean_termination_b_id(self):",
            "        # Return the PK rather than the object",
            "        return getattr(self.cleaned_data[\"termination_b_id\"], \"pk\", None)",
            "",
            "",
            "class ConnectCableToPowerFeedForm(ConnectCableExcludeIDMixin, NautobotModelForm):",
            "    termination_b_region = DynamicModelChoiceField(queryset=Region.objects.all(), label=\"Region\", required=False)",
            "    termination_b_site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        label=\"Site\",",
            "        required=False,",
            "        query_params={\"region_id\": \"$termination_b_region\"},",
            "    )",
            "    termination_b_rackgroup = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        label=\"Rack Group\",",
            "        required=False,",
            "        query_params={\"site_id\": \"$termination_b_site\"},",
            "    )",
            "    termination_b_powerpanel = DynamicModelChoiceField(",
            "        queryset=PowerPanel.objects.all(),",
            "        label=\"Power Panel\",",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$termination_b_site\",",
            "            \"rack_group_id\": \"$termination_b_rackgroup\",",
            "        },",
            "    )",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=PowerFeed.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"power_panel_id\": \"$termination_b_powerpanel\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"termination_b_rackgroup\",",
            "            \"termination_b_powerpanel\",",
            "            \"termination_b_id\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean_termination_b_id(self):",
            "        # Return the PK rather than the object",
            "        return getattr(self.cleaned_data[\"termination_b_id\"], \"pk\", None)",
            "",
            "",
            "class CableForm(NautobotModelForm):",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"type\": StaticSelect2,",
            "            \"length_unit\": StaticSelect2,",
            "        }",
            "        error_messages = {\"length\": {\"max_value\": \"Maximum length is 32767 (any unit)\"}}",
            "",
            "",
            "class CableCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    # Termination A",
            "    side_a_device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\", help_text=\"Side A device\")",
            "    side_a_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        limit_choices_to=CABLE_TERMINATION_MODELS,",
            "        help_text=\"Side A type\",",
            "    )",
            "    side_a_name = forms.CharField(help_text=\"Side A component name\")",
            "",
            "    # Termination B",
            "    side_b_device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\", help_text=\"Side B device\")",
            "    side_b_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        limit_choices_to=CABLE_TERMINATION_MODELS,",
            "        help_text=\"Side B type\",",
            "    )",
            "    side_b_name = forms.CharField(help_text=\"Side B component name\")",
            "",
            "    # Cable attributes",
            "    type = CSVChoiceField(",
            "        choices=CableTypeChoices,",
            "        required=False,",
            "        help_text=\"Physical medium classification\",",
            "    )",
            "    length_unit = CSVChoiceField(choices=CableLengthUnitChoices, required=False, help_text=\"Length unit\")",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"side_a_device\",",
            "            \"side_a_type\",",
            "            \"side_a_name\",",
            "            \"side_b_device\",",
            "            \"side_b_type\",",
            "            \"side_b_name\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "        ]",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),",
            "            \"status\": \"Connection status\",",
            "        }",
            "",
            "    def _clean_side(self, side):",
            "        \"\"\"",
            "        Derive a Cable's A/B termination objects.",
            "",
            "        :param side: 'a' or 'b'",
            "        \"\"\"",
            "        assert side in \"ab\", f\"Invalid side designation: {side}\"",
            "",
            "        device = self.cleaned_data.get(f\"side_{side}_device\")",
            "        content_type = self.cleaned_data.get(f\"side_{side}_type\")",
            "        name = self.cleaned_data.get(f\"side_{side}_name\")",
            "        if not device or not content_type or not name:",
            "            return None",
            "",
            "        model = content_type.model_class()",
            "        try:",
            "            termination_object = model.objects.get(device=device, name=name)",
            "            if termination_object.cable is not None:",
            "                raise forms.ValidationError(f\"Side {side.upper()}: {device} {termination_object} is already connected\")",
            "        except ObjectDoesNotExist:",
            "            raise forms.ValidationError(f\"{side.upper()} side termination not found: {device} {name}\")",
            "",
            "        setattr(self.instance, f\"termination_{side}\", termination_object)",
            "        return termination_object",
            "",
            "    def clean_side_a_name(self):",
            "        return self._clean_side(\"a\")",
            "",
            "    def clean_side_b_name(self):",
            "        return self._clean_side(\"b\")",
            "",
            "    def clean_length_unit(self):",
            "        # Avoid trying to save as NULL",
            "        length_unit = self.cleaned_data.get(\"length_unit\", None)",
            "        return length_unit if length_unit is not None else \"\"",
            "",
            "    def add_error(self, field, error):",
            "        # Edge Case: some fields in error are not properties in this instance",
            "        #   e.g: termination_a_id not an property in CableCSVForm, This would raise a ValueError Exception",
            "        # Solution: convert those fields to its equivalent in CableCSVForm",
            "        #   e.g: termination_a_id > side_a_name",
            "",
            "        final_error = error",
            "        if hasattr(error, \"error_dict\"):",
            "            error_dict = error.error_dict",
            "            termination_keys = [key for key in error_dict.keys() if key.startswith(\"termination\")]",
            "            for error_field in termination_keys:",
            "                side_value = error_field.split(\"_\")[1]",
            "                error_msg = error_dict.pop(error_field)",
            "                error_dict[f\"side_{side_value}_name\"] = error_msg",
            "",
            "            final_error = ValidationError(error_dict)",
            "        super().add_error(field, final_error)",
            "",
            "",
            "class CableBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Cable.objects.all(), widget=forms.MultipleHiddenInput)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(CableTypeChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    label = forms.CharField(max_length=100, required=False)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())  # RGB color code",
            "    length = forms.IntegerField(min_value=1, required=False)",
            "    length_unit = forms.ChoiceField(",
            "        choices=add_blank_choice(CableLengthUnitChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "        ]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate length/unit",
            "        length = self.cleaned_data.get(\"length\")",
            "        length_unit = self.cleaned_data.get(\"length_unit\")",
            "        if length and not length_unit:",
            "            raise forms.ValidationError({\"length_unit\": \"Must specify a unit when setting length\"})",
            "",
            "",
            "class CableFilterForm(BootstrapMixin, StatusModelFilterFormMixin, forms.Form):",
            "    model = Cable",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), to_field_name=\"slug\", required=False)",
            "    rack_id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        label=\"Rack\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    type = forms.MultipleChoiceField(",
            "        choices=add_blank_choice(CableTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())  # RGB color code",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={",
            "            \"site\": \"$site\",",
            "            \"tenant\": \"$tenant\",",
            "            \"rack_id\": \"$rack_id\",",
            "        },",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Connections",
            "#",
            "",
            "",
            "class ConsoleConnectionFilterForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "class PowerConnectionFilterForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "class InterfaceConnectionFilterForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "#",
            "# Virtual chassis",
            "#",
            "",
            "",
            "class DeviceSelectionForm(forms.Form):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Device.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "",
            "class VirtualChassisCreateForm(NautobotModelForm):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False, initial_params={\"sites\": \"$site\"})",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    members = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"rack_id\": \"$rack\",",
            "        },",
            "    )",
            "    initial_position = forms.IntegerField(",
            "        initial=1,",
            "        required=False,",
            "        help_text=\"Position of the first member device. Increases by one for each additional member.\",",
            "    )",
            "",
            "    class Meta:",
            "        model = VirtualChassis",
            "        fields = [",
            "            \"name\",",
            "            \"domain\",",
            "            \"region\",",
            "            \"site\",",
            "            \"rack\",",
            "            \"members\",",
            "            \"initial_position\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def save(self, *args, **kwargs):",
            "        instance = super().save(*args, **kwargs)",
            "",
            "        # Assign VC members",
            "        if instance.present_in_database:",
            "            initial_position = self.cleaned_data.get(\"initial_position\") or 1",
            "            for i, member in enumerate(self.cleaned_data[\"members\"], start=initial_position):",
            "                member.virtual_chassis = instance",
            "                member.vc_position = i",
            "                member.save()",
            "",
            "        return instance",
            "",
            "",
            "class VirtualChassisForm(NautobotModelForm):",
            "    master = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        model = VirtualChassis",
            "        fields = [",
            "            \"name\",",
            "            \"domain\",",
            "            \"master\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"master\": SelectWithPK(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.fields[\"master\"].queryset = Device.objects.filter(virtual_chassis=self.instance)",
            "",
            "",
            "class BaseVCMemberFormSet(forms.BaseModelFormSet):",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Check for duplicate VC position values",
            "        vc_position_list = []",
            "        for form in self.forms:",
            "            vc_position = form.cleaned_data.get(\"vc_position\")",
            "            if vc_position:",
            "                if vc_position in vc_position_list:",
            "                    error_msg = f\"A virtual chassis member already exists in position {vc_position}.\"",
            "                    form.add_error(\"vc_position\", error_msg)",
            "                vc_position_list.append(vc_position)",
            "",
            "",
            "class DeviceVCMembershipForm(forms.ModelForm):",
            "    class Meta:",
            "        model = Device",
            "        fields = [",
            "            \"vc_position\",",
            "            \"vc_priority\",",
            "        ]",
            "        labels = {",
            "            \"vc_position\": \"Position\",",
            "            \"vc_priority\": \"Priority\",",
            "        }",
            "",
            "    def __init__(self, validate_vc_position=False, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Require VC position (only required when the Device is a VirtualChassis member)",
            "        self.fields[\"vc_position\"].required = True",
            "",
            "        # Validation of vc_position is optional. This is only required when adding a new member to an existing",
            "        # VirtualChassis. Otherwise, vc_position validation is handled by BaseVCMemberFormSet.",
            "        self.validate_vc_position = validate_vc_position",
            "",
            "    def clean_vc_position(self):",
            "        vc_position = self.cleaned_data[\"vc_position\"]",
            "",
            "        if self.validate_vc_position:",
            "            conflicting_members = Device.objects.filter(",
            "                virtual_chassis=self.instance.virtual_chassis, vc_position=vc_position",
            "            )",
            "            if conflicting_members.exists():",
            "                raise forms.ValidationError(f\"A virtual chassis member already exists in position {vc_position}.\")",
            "",
            "        return vc_position",
            "",
            "",
            "class VCMemberSelectForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False, initial_params={\"sites\": \"$site\"})",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    device = DynamicModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"rack_id\": \"$rack\",",
            "            \"virtual_chassis_id\": \"null\",",
            "        },",
            "    )",
            "",
            "    def clean_device(self):",
            "        device = self.cleaned_data[\"device\"]",
            "        if device.virtual_chassis is not None:",
            "            raise forms.ValidationError(f\"Device {device} is already assigned to a virtual chassis.\")",
            "        return device",
            "",
            "",
            "class VirtualChassisBulkEditForm(TagsBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=VirtualChassis.objects.all(), widget=forms.MultipleHiddenInput())",
            "    domain = forms.CharField(max_length=30, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"domain\"]",
            "",
            "",
            "class VirtualChassisCSVForm(CustomFieldModelCSVForm):",
            "    master = CSVModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Master device\",",
            "    )",
            "",
            "    class Meta:",
            "        model = VirtualChassis",
            "        fields = VirtualChassis.csv_headers",
            "",
            "",
            "class VirtualChassisFilterForm(NautobotFilterForm):",
            "    model = VirtualChassis",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    tenant_group = DynamicModelMultipleChoiceField(",
            "        queryset=TenantGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"group\": \"$tenant_group\"},",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Power panels",
            "#",
            "",
            "",
            "class PowerPanelForm(LocatableModelFormMixin, NautobotModelForm):",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = PowerPanel",
            "        fields = [",
            "            \"region\",",
            "            \"site\",",
            "            \"location\",",
            "            \"rack_group\",",
            "            \"name\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class PowerPanelCSVForm(LocatableModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    rack_group = CSVModelChoiceField(queryset=RackGroup.objects.all(), required=False, to_field_name=\"name\")",
            "",
            "    class Meta:",
            "        model = PowerPanel",
            "        fields = PowerPanel.csv_headers",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "",
            "class PowerPanelBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    LocatableModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerPanel.objects.all(), widget=forms.MultipleHiddenInput)",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = PowerPanel",
            "        nullable_fields = [\"location\", \"rack_group\"]",
            "",
            "",
            "class PowerPanelFilterForm(NautobotFilterForm, LocatableModelFilterFormMixin):",
            "    model = PowerPanel",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    rack_group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        label=\"Rack group (ID)\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Power feeds",
            "#",
            "",
            "",
            "class PowerFeedForm(NautobotModelForm):",
            "    region = DynamicModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "        initial_params={\"sites__powerpanel\": \"$power_panel\"},",
            "    )",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        initial_params={\"powerpanel\": \"$power_panel\"},",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    power_panel = DynamicModelChoiceField(queryset=PowerPanel.objects.all(), query_params={\"site_id\": \"$site\"})",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = PowerFeed",
            "        fields = [",
            "            \"region\",",
            "            \"site\",",
            "            \"power_panel\",",
            "            \"rack\",",
            "            \"name\",",
            "            \"status\",",
            "            \"type\",",
            "            \"supply\",",
            "            \"phase\",",
            "            \"voltage\",",
            "            \"amperage\",",
            "            \"max_utilization\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"type\": StaticSelect2(),",
            "            \"supply\": StaticSelect2(),",
            "            \"phase\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class PowerFeedCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    site = CSVModelChoiceField(queryset=Site.objects.all(), to_field_name=\"name\", help_text=\"Assigned site\")",
            "    power_panel = CSVModelChoiceField(",
            "        queryset=PowerPanel.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Upstream power panel\",",
            "    )",
            "    rack_group = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack's group (if any)\",",
            "    )",
            "    rack = CSVModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack\",",
            "    )",
            "    type = CSVChoiceField(choices=PowerFeedTypeChoices, required=False, help_text=\"Primary or redundant\")",
            "    supply = CSVChoiceField(choices=PowerFeedSupplyChoices, required=False, help_text=\"Supply type (AC/DC)\")",
            "    phase = CSVChoiceField(choices=PowerFeedPhaseChoices, required=False, help_text=\"Single or three-phase\")",
            "",
            "    class Meta:",
            "        model = PowerFeed",
            "        fields = PowerFeed.csv_headers",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit power_panel queryset by site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"power_panel\"].queryset = self.fields[\"power_panel\"].queryset.filter(**params)",
            "",
            "            # Limit rack_group queryset by site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "            # Limit rack queryset by site and group",
            "            params = {",
            "                f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\"),",
            "                f\"group__{self.fields['rack_group'].to_field_name}\": data.get(\"rack_group\"),",
            "            }",
            "            self.fields[\"rack\"].queryset = self.fields[\"rack\"].queryset.filter(**params)",
            "",
            "",
            "class PowerFeedBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerFeed.objects.all(), widget=forms.MultipleHiddenInput)",
            "    power_panel = DynamicModelChoiceField(queryset=PowerPanel.objects.all(), required=False)",
            "    rack = DynamicModelChoiceField(queryset=Rack.objects.all(), required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedTypeChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    supply = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedSupplyChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    phase = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedPhaseChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    voltage = forms.IntegerField(required=False)",
            "    amperage = forms.IntegerField(required=False)",
            "    max_utilization = forms.IntegerField(required=False)",
            "    comments = CommentField(widget=SmallTextarea, label=\"Comments\")",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"rackgroup\",",
            "            \"comments\",",
            "        ]",
            "",
            "",
            "class PowerFeedFilterForm(NautobotFilterForm, StatusModelFilterFormMixin):",
            "    model = PowerFeed",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    power_panel_id = DynamicModelMultipleChoiceField(",
            "        queryset=PowerPanel.objects.all(),",
            "        required=False,",
            "        label=\"Power panel\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    rack_id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        label=\"Rack\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    supply = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedSupplyChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    phase = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedPhaseChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    voltage = forms.IntegerField(required=False)",
            "    amperage = forms.IntegerField(required=False)",
            "    max_utilization = forms.IntegerField(required=False)",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class DeviceRedundancyGroupForm(NautobotModelForm):",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "    comments = CommentField()",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = DeviceRedundancyGroup",
            "        fields = \"__all__\"",
            "        widgets = {\"failover_strategy\": StaticSelect2()}",
            "",
            "",
            "class DeviceRedundancyGroupFilterForm(NautobotFilterForm, StatusModelFilterFormMixin):",
            "    model = DeviceRedundancyGroup",
            "    field_order = [\"q\", \"name\"]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    failover_strategy = forms.ChoiceField(",
            "        choices=add_blank_choice(DeviceRedundancyGroupFailoverStrategyChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    secrets_group = DynamicModelMultipleChoiceField(",
            "        queryset=SecretsGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class DeviceRedundancyGroupBulkEditForm(",
            "    TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm, LocalContextModelBulkEditForm",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceRedundancyGroup.objects.all(), widget=forms.MultipleHiddenInput)",
            "    failover_strategy = forms.ChoiceField(",
            "        choices=add_blank_choice(DeviceRedundancyGroupFailoverStrategyChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), to_field_name=\"name\", required=False)",
            "    comments = CommentField(widget=SmallTextarea, label=\"Comments\")",
            "",
            "    class Meta:",
            "        model = DeviceRedundancyGroup",
            "        nullable_fields = [",
            "            \"failover_strategy\",",
            "            \"secrets_group\",",
            "        ]",
            "",
            "",
            "class DeviceRedundancyGroupCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    failover_strategy = CSVChoiceField(",
            "        choices=DeviceRedundancyGroupFailoverStrategyChoices, required=False, help_text=\"Failover Strategy\"",
            "    )",
            "",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Secrets group\",",
            "    )",
            "",
            "    class Meta:",
            "        model = DeviceRedundancyGroup",
            "        fields = DeviceRedundancyGroup.csv_headers",
            "",
            "",
            "#",
            "# Interface Redundancy Groups",
            "#",
            "",
            "",
            "class InterfaceRedundancyGroupForm(NautobotModelForm):",
            "    \"\"\"InterfaceRedundancyGroup create/edit form.\"\"\"",
            "",
            "    protocol_group_id = forms.CharField(",
            "        label=\"Protocol Group ID\",",
            "        help_text=\"Specify a group identifier, such as the VRRP group ID.\",",
            "        required=False,",
            "    )",
            "    virtual_ip = DynamicModelChoiceField(",
            "        queryset=IPAddress.objects.all(),",
            "        required=False,",
            "    )",
            "    secrets_group = DynamicModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        model = InterfaceRedundancyGroup",
            "        fields = [",
            "            \"name\",",
            "            \"description\",",
            "            \"status\",",
            "            \"virtual_ip\",",
            "            \"protocol\",",
            "            \"protocol_group_id\",",
            "            \"secrets_group\",",
            "        ]",
            "",
            "",
            "class InterfaceRedundancyGroupCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Secrets group\",",
            "    )",
            "    virtual_ip = CSVModelChoiceField(",
            "        queryset=IPAddress.objects.all(),",
            "        required=False,",
            "        to_field_name=\"address\",",
            "        help_text=\"Virtual IP Address\",",
            "    )",
            "",
            "    class Meta:",
            "        model = InterfaceRedundancyGroup",
            "        fields = InterfaceRedundancyGroup.csv_headers",
            "",
            "",
            "class InterfaceRedundancyGroupAssociationForm(BootstrapMixin, NoteModelFormMixin):",
            "    \"\"\"InterfaceRedundancyGroupAssociation create/edit form.\"\"\"",
            "",
            "    region = DynamicModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "    )",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    device = DynamicModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"rack_id\": \"$rack\",",
            "        },",
            "    )",
            "    interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        query_params={\"device_id\": \"$device\"},",
            "        help_text=\"Choose an interface to add to the Redundancy Group.\",",
            "    )",
            "    interface_redundancy_group = DynamicModelChoiceField(",
            "        queryset=InterfaceRedundancyGroup.objects.all(),",
            "        help_text=\"Choose a Interface Redundancy Group.\",",
            "    )",
            "    priority = forms.IntegerField(",
            "        min_value=1,",
            "        help_text=\"Specify the interface priority as an integer.\",",
            "    )",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        model = InterfaceRedundancyGroupAssociation",
            "        fields = [",
            "            \"interface_redundancy_group\",",
            "            \"region\",",
            "            \"site\",",
            "            \"rack\",",
            "            \"device\",",
            "            \"interface\",",
            "            \"priority\",",
            "        ]",
            "",
            "",
            "class InterfaceRedundancyGroupBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    \"\"\"InterfaceRedundancyGroup bulk edit form.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=InterfaceRedundancyGroup.objects.all(),",
            "        widget=forms.MultipleHiddenInput,",
            "    )",
            "    protocol = forms.ChoiceField(choices=InterfaceRedundancyGroupProtocolChoices)",
            "    description = forms.CharField(required=False)",
            "    virtual_ip = DynamicModelChoiceField(queryset=IPAddress.objects.all(), required=False)",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        nullable_fields = [",
            "            \"protocol\",",
            "            \"description\",",
            "            \"virtual_ip\",",
            "            \"secrets_group\",",
            "        ]",
            "",
            "",
            "class InterfaceRedundancyGroupFilterForm(BootstrapMixin, StatusModelFilterFormMixin, forms.ModelForm):",
            "    \"\"\"Filter form to filter searches.\"\"\"",
            "",
            "    model = InterfaceRedundancyGroup",
            "    q = forms.CharField(",
            "        required=False,",
            "        label=\"Search\",",
            "        help_text=\"Search within Name.\",",
            "    )",
            "    name = forms.CharField(required=False, label=\"Name\")",
            "    interfaces = DynamicModelMultipleChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "    )",
            "    virtual_ip = DynamicModelMultipleChoiceField(",
            "        queryset=IPAddress.objects.all(),",
            "        required=False,",
            "    )",
            "    secrets_group = DynamicModelMultipleChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "    )",
            "    protocol = forms.ChoiceField(",
            "        choices=InterfaceRedundancyGroupProtocolChoices,",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        model = InterfaceRedundancyGroup",
            "        # Define the fields above for ordering and widget purposes",
            "        fields = [",
            "            \"q\",",
            "            \"name\",",
            "            \"description\",",
            "            \"interfaces\",",
            "            \"virtual_ip\",",
            "            \"secrets_group\",",
            "            \"protocol\",",
            "        ]"
        ],
        "afterPatchFile": [
            "import re",
            "",
            "from django import forms",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.postgres.forms.array import SimpleArrayField",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.db.models import Q",
            "from django.utils.safestring import mark_safe",
            "from netaddr import EUI",
            "from netaddr.core import AddrFormatError",
            "from timezone_field import TimeZoneFormField",
            "",
            "from nautobot.circuits.models import Circuit, CircuitTermination, Provider",
            "from nautobot.dcim.form_mixins import (",
            "    LocatableModelBulkEditFormMixin,",
            "    LocatableModelCSVFormMixin,",
            "    LocatableModelFilterFormMixin,",
            "    LocatableModelFormMixin,",
            ")",
            "from nautobot.extras.forms import (",
            "    CustomFieldModelBulkEditFormMixin,",
            "    CustomFieldModelCSVForm,",
            "    NautobotBulkEditForm,",
            "    NautobotModelForm,",
            "    NautobotFilterForm,",
            "    NoteModelFormMixin,",
            "    LocalContextFilterForm,",
            "    LocalContextModelForm,",
            "    LocalContextModelBulkEditForm,",
            "    StatusModelBulkEditFormMixin,",
            "    StatusModelCSVFormMixin,",
            "    StatusModelFilterFormMixin,",
            "    TagsBulkEditFormMixin,",
            ")",
            "from nautobot.extras.models import SecretsGroup, Status",
            "from nautobot.ipam.constants import BGP_ASN_MAX, BGP_ASN_MIN",
            "from nautobot.ipam.models import IPAddress, VLAN",
            "from nautobot.tenancy.forms import TenancyFilterForm, TenancyForm",
            "from nautobot.tenancy.models import Tenant, TenantGroup",
            "from nautobot.utilities.forms import (",
            "    APISelect,",
            "    APISelectMultiple,",
            "    add_blank_choice,",
            "    BootstrapMixin,",
            "    BulkEditNullBooleanSelect,",
            "    ColorSelect,",
            "    CommentField,",
            "    CSVChoiceField,",
            "    CSVContentTypeField,",
            "    CSVModelChoiceField,",
            "    CSVMultipleContentTypeField,",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    ExpandableNameField,",
            "    form_from_model,",
            "    MultipleContentTypeField,",
            "    NumericArrayField,",
            "    SelectWithPK,",
            "    SmallTextarea,",
            "    SlugField,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    TagFilterField,",
            ")",
            "from nautobot.utilities.forms.constants import BOOLEAN_WITH_BLANK_CHOICES",
            "from nautobot.virtualization.models import Cluster, ClusterGroup",
            "from .choices import (",
            "    CableLengthUnitChoices,",
            "    CableTypeChoices,",
            "    ConsolePortTypeChoices,",
            "    DeviceFaceChoices,",
            "    DeviceRedundancyGroupFailoverStrategyChoices,",
            "    InterfaceModeChoices,",
            "    InterfaceRedundancyGroupProtocolChoices,",
            "    InterfaceTypeChoices,",
            "    PortTypeChoices,",
            "    PowerFeedPhaseChoices,",
            "    PowerFeedSupplyChoices,",
            "    PowerFeedTypeChoices,",
            "    PowerOutletFeedLegChoices,",
            "    PowerOutletTypeChoices,",
            "    PowerPortTypeChoices,",
            "    RackDimensionUnitChoices,",
            "    RackTypeChoices,",
            "    RackWidthChoices,",
            "    SubdeviceRoleChoices,",
            ")",
            "from .constants import (",
            "    CABLE_TERMINATION_MODELS,",
            "    INTERFACE_MTU_MAX,",
            "    INTERFACE_MTU_MIN,",
            "    NONCONNECTABLE_IFACE_TYPES,",
            "    REARPORT_POSITIONS_MAX,",
            "    REARPORT_POSITIONS_MIN,",
            ")",
            "",
            "from .models import (",
            "    Cable,",
            "    DeviceBay,",
            "    DeviceBayTemplate,",
            "    DeviceRedundancyGroup,",
            "    ConsolePort,",
            "    ConsolePortTemplate,",
            "    ConsoleServerPort,",
            "    ConsoleServerPortTemplate,",
            "    Device,",
            "    DeviceRole,",
            "    DeviceType,",
            "    FrontPort,",
            "    FrontPortTemplate,",
            "    Interface,",
            "    InterfaceRedundancyGroup,",
            "    InterfaceRedundancyGroupAssociation,",
            "    InterfaceTemplate,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    InventoryItem,",
            "    Platform,",
            "    PowerFeed,",
            "    PowerOutlet,",
            "    PowerOutletTemplate,",
            "    PowerPanel,",
            "    PowerPort,",
            "    PowerPortTemplate,",
            "    Rack,",
            "    RackGroup,",
            "    RackReservation,",
            "    RackRole,",
            "    RearPort,",
            "    RearPortTemplate,",
            "    Region,",
            "    Site,",
            "    VirtualChassis,",
            ")",
            "",
            "DEVICE_BY_PK_RE = r\"{\\d+\\}\"",
            "",
            "INTERFACE_MODE_HELP_TEXT = \"\"\"",
            "Access: One untagged VLAN<br />",
            "Tagged: One untagged VLAN and/or one or more tagged VLANs<br />",
            "Tagged (All): Implies all VLANs are available (w/optional untagged VLAN)",
            "\"\"\"",
            "",
            "",
            "def get_device_by_name_or_pk(name):",
            "    \"\"\"",
            "    Attempt to retrieve a device by either its name or primary key ('{pk}').",
            "    \"\"\"",
            "    if re.match(DEVICE_BY_PK_RE, name):",
            "        pk = name.strip(\"{}\")",
            "        device = Device.objects.get(pk=pk)",
            "    else:",
            "        device = Device.objects.get(name=name)",
            "    return device",
            "",
            "",
            "class ConnectCableExcludeIDMixin:",
            "    def __init__(self, *args, exclude_id=None, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if exclude_id is not None:",
            "            self.fields[\"termination_b_id\"].widget.add_query_param(\"id__n\", str(exclude_id))",
            "",
            "",
            "class DeviceComponentFilterForm(NautobotFilterForm):",
            "    field_order = [\"q\", \"region\", \"site\"]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "class InterfaceCommonForm(forms.Form):",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        parent_field = \"device\" if \"device\" in self.cleaned_data else \"virtual_machine\"",
            "        tagged_vlans = self.cleaned_data[\"tagged_vlans\"]",
            "        mode = self.cleaned_data[\"mode\"]",
            "",
            "        # Untagged interfaces cannot be assigned tagged VLANs",
            "        if mode == InterfaceModeChoices.MODE_ACCESS and tagged_vlans:",
            "            raise forms.ValidationError({\"mode\": \"An access interface cannot have tagged VLANs assigned.\"})",
            "",
            "        if mode != InterfaceModeChoices.MODE_TAGGED and tagged_vlans:",
            "            raise forms.ValidationError({\"tagged_vlans\": f\"Clear tagged_vlans to set mode to {self.mode}\"})",
            "",
            "        # Remove all tagged VLAN assignments from \"tagged all\" interfaces",
            "        elif mode == InterfaceModeChoices.MODE_TAGGED_ALL:",
            "            self.cleaned_data[\"tagged_vlans\"] = []",
            "",
            "        # Validate tagged VLANs; must be a global VLAN or in the same site",
            "        elif mode == InterfaceModeChoices.MODE_TAGGED:",
            "            valid_sites = [None, self.cleaned_data[parent_field].site]",
            "            invalid_vlans = [str(v) for v in tagged_vlans if v.site not in valid_sites]",
            "",
            "            if invalid_vlans:",
            "                raise forms.ValidationError(",
            "                    {",
            "                        \"tagged_vlans\": f\"The tagged VLANs ({', '.join(invalid_vlans)}) must belong to the same site as \"",
            "                        f\"the interface's parent device/VM, or they must be global\"",
            "                    }",
            "                )",
            "",
            "",
            "class ComponentForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    Subclass this form when facilitating the creation of one or more device component or component templates based on",
            "    a name pattern.",
            "    \"\"\"",
            "",
            "    name_pattern = ExpandableNameField(label=\"Name\")",
            "    label_pattern = ExpandableNameField(",
            "        label=\"Label\",",
            "        required=False,",
            "        help_text=\"Alphanumeric ranges are supported. (Must match the number of names being created.)\",",
            "    )",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate that the number of components being created from both the name_pattern and label_pattern are equal",
            "        if self.cleaned_data[\"label_pattern\"]:",
            "            name_pattern_count = len(self.cleaned_data[\"name_pattern\"])",
            "            label_pattern_count = len(self.cleaned_data[\"label_pattern\"])",
            "            if name_pattern_count != label_pattern_count:",
            "                raise forms.ValidationError(",
            "                    {",
            "                        \"label_pattern\": f\"The provided name pattern will create {name_pattern_count} components, however \"",
            "                        f\"{label_pattern_count} labels will be generated. These counts must match.\"",
            "                    },",
            "                    code=\"label_pattern_mismatch\",",
            "                )",
            "",
            "",
            "#",
            "# Fields",
            "#",
            "",
            "",
            "class MACAddressField(forms.Field):",
            "    widget = forms.CharField",
            "    default_error_messages = {",
            "        \"invalid\": \"MAC address must be in EUI-48 format\",",
            "    }",
            "",
            "    def to_python(self, value):",
            "        value = super().to_python(value)",
            "",
            "        # Validate MAC address format",
            "        try:",
            "            value = EUI(value.strip())",
            "        except AddrFormatError:",
            "            raise forms.ValidationError(self.error_messages[\"invalid\"], code=\"invalid\")",
            "",
            "        return value",
            "",
            "",
            "#",
            "# Regions",
            "#",
            "",
            "",
            "class RegionForm(NautobotModelForm):",
            "    parent = DynamicModelChoiceField(queryset=Region.objects.all(), required=False)",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Region",
            "        fields = (",
            "            \"parent\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "class RegionCSVForm(CustomFieldModelCSVForm):",
            "    parent = CSVModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of parent region\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Region",
            "        fields = Region.csv_headers",
            "",
            "",
            "class RegionFilterForm(NautobotFilterForm):",
            "    model = Site",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Sites",
            "#",
            "",
            "",
            "class SiteForm(NautobotModelForm, TenancyForm):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False)",
            "    slug = SlugField()",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = Site",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"status\",",
            "            \"region\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"facility\",",
            "            \"asn\",",
            "            \"time_zone\",",
            "            \"description\",",
            "            \"physical_address\",",
            "            \"shipping_address\",",
            "            \"latitude\",",
            "            \"longitude\",",
            "            \"contact_name\",",
            "            \"contact_phone\",",
            "            \"contact_email\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"physical_address\": SmallTextarea(",
            "                attrs={",
            "                    \"rows\": 3,",
            "                }",
            "            ),",
            "            \"shipping_address\": SmallTextarea(",
            "                attrs={",
            "                    \"rows\": 3,",
            "                }",
            "            ),",
            "            \"time_zone\": StaticSelect2(),",
            "        }",
            "        help_texts = {",
            "            \"name\": \"Full name of the site\",",
            "            \"facility\": \"Data center provider and facility (e.g. Equinix NY7)\",",
            "            \"asn\": \"BGP autonomous system number\",",
            "            \"time_zone\": \"Local time zone\",",
            "            \"description\": \"Short description (will appear in sites list)\",",
            "            \"physical_address\": \"Physical location of the building (e.g. for GPS)\",",
            "            \"shipping_address\": \"If different from the physical address\",",
            "            \"latitude\": \"Latitude in decimal format (xx.yyyyyy)\",",
            "            \"longitude\": \"Longitude in decimal format (xx.yyyyyy)\",",
            "        }",
            "",
            "",
            "class SiteCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    region = CSVModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned region\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Site",
            "        fields = Site.csv_headers",
            "        help_texts = {",
            "            \"time_zone\": mark_safe(  # noqa: S308",
            "                'Time zone (<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\">available options</a>)'",
            "            )",
            "        }",
            "",
            "",
            "class SiteBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Site.objects.all(), widget=forms.MultipleHiddenInput)",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False)",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    asn = forms.IntegerField(min_value=BGP_ASN_MIN, max_value=BGP_ASN_MAX, required=False, label=\"ASN\")",
            "    description = forms.CharField(max_length=100, required=False)",
            "    time_zone = TimeZoneFormField(",
            "        choices=add_blank_choice(TimeZoneFormField().choices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"region\",",
            "            \"tenant\",",
            "            \"asn\",",
            "            \"description\",",
            "            \"time_zone\",",
            "        ]",
            "",
            "",
            "class SiteFilterForm(NautobotFilterForm, TenancyFilterForm, StatusModelFilterFormMixin):",
            "    model = Site",
            "    field_order = [\"q\", \"status\", \"region\", \"tenant_group\", \"tenant\"]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# LocationTypes",
            "#",
            "",
            "",
            "class LocationTypeForm(NautobotModelForm):",
            "    parent = DynamicModelChoiceField(queryset=LocationType.objects.all(), required=False)",
            "    slug = SlugField()",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"locations\",",
            "        help_text=\"The object type(s) that can be associated to a Location of this type\",",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        model = LocationType",
            "        fields = (\"parent\", \"name\", \"slug\", \"description\", \"nestable\", \"content_types\")",
            "",
            "",
            "class LocationTypeCSVForm(CustomFieldModelCSVForm):",
            "    parent = CSVModelChoiceField(",
            "        queryset=LocationType.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of parent location type\",",
            "    )",
            "    content_types = CSVMultipleContentTypeField(",
            "        feature=\"locations\",",
            "        required=False,",
            "        choices_as_strings=True,",
            "        help_text=mark_safe(  # noqa: S308",
            "            \"The object types to which this status applies. Multiple values \"",
            "            \"must be comma-separated and wrapped in double quotes. (e.g. \"",
            "            '<code>\"dcim.device,dcim.rack\"</code>)'",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = LocationType",
            "        fields = LocationType.csv_headers",
            "",
            "",
            "class LocationTypeFilterForm(NautobotFilterForm):",
            "    model = LocationType",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(feature=\"locations\", choices_as_strings=True, required=False)",
            "",
            "",
            "#",
            "# Locations",
            "#",
            "",
            "",
            "class LocationForm(NautobotModelForm, TenancyForm):",
            "    slug = SlugField(slug_source=(\"parent\", \"name\"))",
            "    location_type = DynamicModelChoiceField(queryset=LocationType.objects.all())",
            "    parent = DynamicModelChoiceField(",
            "        queryset=Location.objects.all(),",
            "        query_params={\"child_location_type\": \"$location_type\"},",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "    )",
            "    site = DynamicModelChoiceField(queryset=Site.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        model = Location",
            "        fields = [",
            "            \"location_type\",",
            "            \"parent\",",
            "            \"site\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"status\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class LocationBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Location.objects.all(), widget=forms.MultipleHiddenInput)",
            "    # location_type is not editable on existing instances",
            "    parent = DynamicModelChoiceField(queryset=Location.objects.all(), required=False)",
            "    site = DynamicModelChoiceField(queryset=Site.objects.all(), required=False)",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"parent\",",
            "            \"site\",",
            "            \"tenant\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class LocationCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    location_type = CSVModelChoiceField(",
            "        queryset=LocationType.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Location type\",",
            "    )",
            "    parent = CSVModelChoiceField(",
            "        queryset=Location.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent location\",",
            "    )",
            "    site = CSVModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent site\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Location",
            "        fields = Location.csv_headers",
            "",
            "",
            "class LocationFilterForm(NautobotFilterForm, StatusModelFilterFormMixin, TenancyFilterForm):",
            "    model = Location",
            "    field_order = [\"q\", \"location_type\", \"parent\", \"subtree\", \"base_site\", \"status\", \"tenant_group\", \"tenant\", \"tag\"]",
            "",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    location_type = DynamicModelMultipleChoiceField(",
            "        queryset=LocationType.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    parent = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    subtree = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    base_site = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), to_field_name=\"slug\", required=False)",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Rack groups",
            "#",
            "",
            "",
            "class RackGroupForm(LocatableModelFormMixin, NautobotModelForm):",
            "    parent = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = RackGroup",
            "        fields = (",
            "            \"region\",",
            "            \"site\",",
            "            \"location\",",
            "            \"parent\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "class RackGroupCSVForm(LocatableModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    parent = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent rack group\",",
            "        error_messages={",
            "            \"invalid_choice\": \"Rack group not found.\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = RackGroup",
            "        fields = RackGroup.csv_headers",
            "",
            "",
            "class RackGroupFilterForm(NautobotFilterForm, LocatableModelFilterFormMixin):",
            "    model = RackGroup",
            "    parent = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={",
            "            \"region\": \"$region\",",
            "            \"site\": \"$site\",",
            "        },",
            "    )",
            "",
            "",
            "#",
            "# Rack roles",
            "#",
            "",
            "",
            "class RackRoleForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = RackRole",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"color\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class RackRoleCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = RackRole",
            "        fields = RackRole.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "#",
            "# Racks",
            "#",
            "",
            "",
            "class RackForm(LocatableModelFormMixin, NautobotModelForm, TenancyForm):",
            "    group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    role = DynamicModelChoiceField(queryset=RackRole.objects.all(), required=False)",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = Rack",
            "        fields = [",
            "            \"region\",",
            "            \"site\",",
            "            \"location\",",
            "            \"group\",",
            "            \"name\",",
            "            \"facility_id\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"status\",",
            "            \"role\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"type\",",
            "            \"width\",",
            "            \"u_height\",",
            "            \"desc_units\",",
            "            \"outer_width\",",
            "            \"outer_depth\",",
            "            \"outer_unit\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        help_texts = {",
            "            \"site\": \"The site at which the rack exists\",",
            "            \"location\": \"The specific location of the rack\",",
            "            \"name\": \"Organizational rack name\",",
            "            \"facility_id\": \"The unique rack ID assigned by the facility\",",
            "            \"u_height\": \"Height in rack units\",",
            "        }",
            "        widgets = {",
            "            \"type\": StaticSelect2(),",
            "            \"width\": StaticSelect2(),",
            "            \"outer_unit\": StaticSelect2(),",
            "        }",
            "",
            "    def clean(self):",
            "        cleaned_data = self.cleaned_data",
            "        site = cleaned_data.get(\"site\")",
            "",
            "        if self.instance and self.instance.present_in_database and site != self.instance.site:",
            "            # If the site is changed, the rack post save signal attempts to update the rack devices,",
            "            # which may result in an Exception if the updated devices conflict with existing devices at this site.",
            "            # To avoid an unhandled exception in the signal, check for this scenario here.",
            "            duplicate_devices = set()",
            "            for device in self.instance.devices.all():",
            "                qs = Device.objects.exclude(pk=device.pk).filter(site=site, tenant=device.tenant, name=device.name)",
            "                if qs.exists():",
            "                    duplicate_devices.add(qs.first().name)",
            "            if duplicate_devices:",
            "                raise ValidationError(",
            "                    {",
            "                        \"site\": f\"Device(s) {sorted(duplicate_devices)} already exist in site {site} and \"",
            "                        \"would conflict with same-named devices in this rack.\"",
            "                    }",
            "                )",
            "        return super().clean()",
            "",
            "",
            "class RackCSVForm(LocatableModelCSVFormMixin, StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    group = CSVModelChoiceField(queryset=RackGroup.objects.all(), required=False, to_field_name=\"name\")",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of assigned tenant\",",
            "    )",
            "    role = CSVModelChoiceField(",
            "        queryset=RackRole.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Name of assigned role\",",
            "    )",
            "    type = CSVChoiceField(choices=RackTypeChoices, required=False, help_text=\"Rack type\")",
            "    width = forms.ChoiceField(choices=RackWidthChoices, help_text=\"Rail-to-rail width (in inches)\")",
            "    outer_unit = CSVChoiceField(",
            "        choices=RackDimensionUnitChoices,",
            "        required=False,",
            "        help_text=\"Unit for outer dimensions\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Rack",
            "        fields = Rack.csv_headers",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"group\"].queryset = self.fields[\"group\"].queryset.filter(**params)",
            "",
            "",
            "class RackBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    LocatableModelBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Rack.objects.all(), widget=forms.MultipleHiddenInput)",
            "    group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    role = DynamicModelChoiceField(queryset=RackRole.objects.all(), required=False)",
            "    serial = forms.CharField(max_length=255, required=False, label=\"Serial Number\")",
            "    asset_tag = forms.CharField(max_length=50, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(RackTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    width = forms.ChoiceField(",
            "        choices=add_blank_choice(RackWidthChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    u_height = forms.IntegerField(required=False, label=\"Height (U)\")",
            "    desc_units = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect, label=\"Descending units\")",
            "    outer_width = forms.IntegerField(required=False, min_value=1)",
            "    outer_depth = forms.IntegerField(required=False, min_value=1)",
            "    outer_unit = forms.ChoiceField(",
            "        choices=add_blank_choice(RackDimensionUnitChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    comments = CommentField(widget=SmallTextarea, label=\"Comments\")",
            "",
            "    class Meta:",
            "        model = Rack",
            "        nullable_fields = [",
            "            \"location\",",
            "            \"group\",",
            "            \"tenant\",",
            "            \"role\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"outer_width\",",
            "            \"outer_depth\",",
            "            \"outer_unit\",",
            "            \"comments\",",
            "        ]",
            "",
            "",
            "class RackFilterForm(NautobotFilterForm, LocatableModelFilterFormMixin, TenancyFilterForm, StatusModelFilterFormMixin):",
            "    model = Rack",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"location\",",
            "        \"group_id\",",
            "        \"status\",",
            "        \"role\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "    ]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        label=\"Rack group\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    type = forms.MultipleChoiceField(choices=RackTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    width = forms.MultipleChoiceField(choices=RackWidthChoices, required=False, widget=StaticSelect2Multiple())",
            "    role = DynamicModelMultipleChoiceField(",
            "        queryset=RackRole.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Rack elevations",
            "#",
            "",
            "",
            "class RackElevationFilterForm(RackFilterForm):",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"group_id\",",
            "        \"id\",",
            "        \"status\",",
            "        \"role\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "    ]",
            "    id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        label=\"Rack\",",
            "        required=False,",
            "        query_params={",
            "            \"site\": \"$site\",",
            "            \"group_id\": \"$group_id\",",
            "        },",
            "    )",
            "",
            "",
            "#",
            "# Rack reservations",
            "#",
            "",
            "",
            "class RackReservationForm(NautobotModelForm, TenancyForm):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False, initial_params={\"sites\": \"$site\"})",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"group_id\": \"$rack_group\",",
            "        },",
            "    )",
            "    units = NumericArrayField(",
            "        base_field=forms.IntegerField(),",
            "        help_text=\"Comma-separated list of numeric unit IDs. A range may be specified using a hyphen.\",",
            "    )",
            "    user = forms.ModelChoiceField(queryset=get_user_model().objects.order_by(\"username\"), widget=StaticSelect2())",
            "",
            "    class Meta:",
            "        model = RackReservation",
            "        fields = [",
            "            \"rack\",",
            "            \"units\",",
            "            \"user\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class RackReservationCSVForm(CustomFieldModelCSVForm):",
            "    site = CSVModelChoiceField(queryset=Site.objects.all(), to_field_name=\"name\", help_text=\"Parent site\")",
            "    rack_group = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack's group (if any)\",",
            "    )",
            "    rack = CSVModelChoiceField(queryset=Rack.objects.all(), to_field_name=\"name\", help_text=\"Rack\")",
            "    units = SimpleArrayField(",
            "        base_field=forms.IntegerField(),",
            "        required=True,",
            "        help_text=\"Comma-separated list of individual unit numbers\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "",
            "    class Meta:",
            "        model = RackReservation",
            "        fields = (\"site\", \"rack_group\", \"rack\", \"units\", \"tenant\", \"description\")",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit rack_group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "            # Limit rack queryset by assigned site and group",
            "            params = {",
            "                f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\"),",
            "                f\"group__{self.fields['rack_group'].to_field_name}\": data.get(\"rack_group\"),",
            "            }",
            "            self.fields[\"rack\"].queryset = self.fields[\"rack\"].queryset.filter(**params)",
            "",
            "",
            "class RackReservationBulkEditForm(TagsBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=RackReservation.objects.all(), widget=forms.MultipleHiddenInput())",
            "    user = forms.ModelChoiceField(",
            "        queryset=get_user_model().objects.order_by(\"username\"),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "class RackReservationFilterForm(NautobotFilterForm, TenancyFilterForm):",
            "    model = RackReservation",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"group_id\",",
            "        \"user_id\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "    ]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.select_related(\"site\"),",
            "        required=False,",
            "        label=\"Rack group\",",
            "        null_option=\"None\",",
            "    )",
            "    user_id = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Manufacturers",
            "#",
            "",
            "",
            "class ManufacturerForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Manufacturer",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class ManufacturerCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = Manufacturer",
            "        fields = Manufacturer.csv_headers",
            "",
            "",
            "#",
            "# Device types",
            "#",
            "",
            "",
            "class DeviceTypeForm(NautobotModelForm):",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all())",
            "    slug = SlugField(slug_source=\"model\")",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = DeviceType",
            "        fields = [",
            "            \"manufacturer\",",
            "            \"model\",",
            "            \"slug\",",
            "            \"part_number\",",
            "            \"u_height\",",
            "            \"is_full_depth\",",
            "            \"subdevice_role\",",
            "            \"front_image\",",
            "            \"rear_image\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"subdevice_role\": StaticSelect2(),",
            "            # Exclude SVG images (unsupported by PIL)",
            "            \"front_image\": forms.ClearableFileInput(",
            "                attrs={\"accept\": \"image/bmp,image/gif,image/jpeg,image/png,image/tiff\"}",
            "            ),",
            "            \"rear_image\": forms.ClearableFileInput(",
            "                attrs={\"accept\": \"image/bmp,image/gif,image/jpeg,image/png,image/tiff\"}",
            "            ),",
            "        }",
            "",
            "",
            "class DeviceTypeImportForm(BootstrapMixin, forms.ModelForm):",
            "    manufacturer = forms.ModelChoiceField(queryset=Manufacturer.objects.all(), to_field_name=\"name\")",
            "",
            "    class Meta:",
            "        model = DeviceType",
            "        fields = [",
            "            \"manufacturer\",",
            "            \"model\",",
            "            \"slug\",",
            "            \"part_number\",",
            "            \"u_height\",",
            "            \"is_full_depth\",",
            "            \"subdevice_role\",",
            "            \"comments\",",
            "        ]",
            "",
            "",
            "class DeviceTypeBulkEditForm(TagsBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceType.objects.all(), widget=forms.MultipleHiddenInput())",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    u_height = forms.IntegerField(required=False)",
            "    is_full_depth = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect(), label=\"Is full depth\")",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "class DeviceTypeFilterForm(NautobotFilterForm):",
            "    model = DeviceType",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    manufacturer = DynamicModelMultipleChoiceField(",
            "        queryset=Manufacturer.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    subdevice_role = forms.MultipleChoiceField(",
            "        choices=add_blank_choice(SubdeviceRoleChoices),",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "    console_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    console_server_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console server ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_outlets = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power outlets\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    interfaces = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has interfaces\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    pass_through_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has pass-through ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Device component templates",
            "#",
            "",
            "",
            "class ComponentTemplateCreateForm(ComponentForm):",
            "    \"\"\"",
            "    Base form for the creation of device component templates (subclassed from ComponentTemplateModel).",
            "    \"\"\"",
            "",
            "    manufacturer = DynamicModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        required=False,",
            "        initial_params={\"device_types\": \"device_type\"},",
            "    )",
            "    device_type = DynamicModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        query_params={\"manufacturer_id\": \"$manufacturer\"},",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "",
            "class ConsolePortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsolePortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsolePortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(ConsolePortTypeChoices), widget=StaticSelect2())",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class ConsolePortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConsolePortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"description\"]",
            "",
            "",
            "class ConsoleServerPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsoleServerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsoleServerPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(ConsolePortTypeChoices), widget=StaticSelect2())",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class ConsoleServerPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=ConsoleServerPortTemplate.objects.all(),",
            "        widget=forms.MultipleHiddenInput(),",
            "    )",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"description\"]",
            "",
            "",
            "class PowerPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = PowerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class PowerPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(PowerPortTypeChoices), required=False)",
            "    maximum_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Maximum power draw (watts)\")",
            "    allocated_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Allocated power draw (watts)\")",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"maximum_draw\",",
            "        \"allocated_draw\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class PowerPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerPortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerPortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    maximum_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Maximum power draw (watts)\")",
            "    allocated_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Allocated power draw (watts)\")",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class PowerOutletTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = PowerOutletTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"power_port\",",
            "            \"feed_leg\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port choices to current DeviceType",
            "        if hasattr(self.instance, \"device_type\"):",
            "            self.fields[\"power_port\"].queryset = PowerPortTemplate.objects.filter(device_type=self.instance.device_type)",
            "",
            "",
            "class PowerOutletTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=add_blank_choice(PowerOutletTypeChoices), required=False)",
            "    power_port = forms.ModelChoiceField(queryset=PowerPortTemplate.objects.all(), required=False)",
            "    feed_leg = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletFeedLegChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"power_port\",",
            "        \"feed_leg\",",
            "        \"description\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port choices to current DeviceType",
            "        device_type = DeviceType.objects.get(pk=self.initial.get(\"device_type\") or self.data.get(\"device_type\"))",
            "        self.fields[\"power_port\"].queryset = PowerPortTemplate.objects.filter(device_type=device_type)",
            "",
            "",
            "class PowerOutletTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerOutletTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    device_type = forms.ModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        required=False,",
            "        disabled=True,",
            "        widget=forms.HiddenInput(),",
            "    )",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    power_port = forms.ModelChoiceField(queryset=PowerPortTemplate.objects.all(), required=False)",
            "    feed_leg = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletFeedLegChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"power_port\", \"feed_leg\", \"description\"]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port queryset to PowerPortTemplates which belong to the parent DeviceType",
            "        if \"device_type\" in self.initial:",
            "            device_type = DeviceType.objects.filter(pk=self.initial[\"device_type\"]).first()",
            "            self.fields[\"power_port\"].queryset = PowerPortTemplate.objects.filter(device_type=device_type)",
            "        else:",
            "            self.fields[\"power_port\"].choices = ()",
            "            self.fields[\"power_port\"].widget.attrs[\"disabled\"] = True",
            "",
            "",
            "class InterfaceTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = InterfaceTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"mgmt_only\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class InterfaceTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=InterfaceTypeChoices, widget=StaticSelect2())",
            "    mgmt_only = forms.BooleanField(required=False, label=\"Management only\")",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"mgmt_only\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class InterfaceTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=InterfaceTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(InterfaceTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    mgmt_only = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect, label=\"Management only\")",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class FrontPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = FrontPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"rear_port\",",
            "            \"rear_port_position\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "            \"rear_port\": StaticSelect2(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit rear_port choices to current DeviceType",
            "        if hasattr(self.instance, \"device_type\"):",
            "            self.fields[\"rear_port\"].queryset = RearPortTemplate.objects.filter(device_type=self.instance.device_type)",
            "",
            "",
            "class FrontPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(choices=PortTypeChoices, widget=StaticSelect2())",
            "    rear_port_set = forms.MultipleChoiceField(",
            "        choices=[],",
            "        label=\"Rear ports\",",
            "        help_text=\"Select one rear port assignment for each front port being created.\",",
            "    )",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"rear_port_set\",",
            "        \"description\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        device_type = DeviceType.objects.get(pk=self.initial.get(\"device_type\") or self.data.get(\"device_type\"))",
            "",
            "        # Determine which rear port positions are occupied. These will be excluded from the list of available mappings.",
            "        occupied_port_positions = [",
            "            (front_port.rear_port_id, front_port.rear_port_position)",
            "            for front_port in device_type.frontporttemplates.all()",
            "        ]",
            "",
            "        # Populate rear port choices",
            "        choices = []",
            "        rear_ports = RearPortTemplate.objects.filter(device_type=device_type)",
            "        for rear_port in rear_ports:",
            "            for i in range(1, rear_port.positions + 1):",
            "                if (rear_port.pk, i) not in occupied_port_positions:",
            "                    choices.append(",
            "                        (",
            "                            f\"{rear_port.pk}:{i}\",",
            "                            f\"{rear_port.name}:{i}\",",
            "                        )",
            "                    )",
            "        self.fields[\"rear_port_set\"].choices = choices",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate that the number of ports being created equals the number of selected (rear port, position) tuples",
            "        front_port_count = len(self.cleaned_data[\"name_pattern\"])",
            "        rear_port_count = len(self.cleaned_data[\"rear_port_set\"])",
            "        if front_port_count != rear_port_count:",
            "            raise forms.ValidationError(",
            "                {",
            "                    \"rear_port_set\": (",
            "                        f\"The provided name pattern will create {front_port_count} ports, \"",
            "                        f\"however {rear_port_count} rear port assignments were selected. These counts must match.\"",
            "                    )",
            "                }",
            "            )",
            "",
            "    def get_iterative_data(self, iteration):",
            "        # Assign rear port and position from selected set",
            "        rear_port, position = self.cleaned_data[\"rear_port_set\"][iteration].split(\":\")",
            "",
            "        return {",
            "            \"rear_port\": rear_port,",
            "            \"rear_port_position\": int(position),",
            "        }",
            "",
            "",
            "class FrontPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=FrontPortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "class RearPortTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = RearPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"positions\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class RearPortTemplateCreateForm(ComponentTemplateCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=PortTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    positions = forms.IntegerField(",
            "        min_value=REARPORT_POSITIONS_MIN,",
            "        max_value=REARPORT_POSITIONS_MAX,",
            "        initial=1,",
            "        help_text=\"The number of front ports which may be mapped to each rear port\",",
            "    )",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"positions\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class RearPortTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=RearPortTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "class DeviceBayTemplateForm(NautobotModelForm):",
            "    class Meta:",
            "        model = DeviceBayTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"device_type\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class DeviceBayTemplateCreateForm(ComponentTemplateCreateForm):",
            "    field_order = (",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"description\",",
            "    )",
            "",
            "",
            "class DeviceBayTemplateBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceBayTemplate.objects.all(), widget=forms.MultipleHiddenInput())",
            "    label = forms.CharField(max_length=64, required=False)",
            "    description = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = (\"label\", \"description\")",
            "",
            "",
            "#",
            "# Component template import forms",
            "#",
            "",
            "",
            "class ComponentTemplateImportForm(BootstrapMixin, CustomFieldModelCSVForm):",
            "    def __init__(self, device_type, data=None, *args, **kwargs):",
            "        # Must pass the parent DeviceType on form initialization",
            "        data.update(",
            "            {",
            "                \"device_type\": device_type.pk,",
            "            }",
            "        )",
            "",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "    def clean_device_type(self):",
            "        data = self.cleaned_data[\"device_type\"]",
            "",
            "        # Limit fields referencing other components to the parent DeviceType",
            "        for field_name, field in self.fields.items():",
            "            if isinstance(field, forms.ModelChoiceField) and field_name != \"device_type\":",
            "                field.queryset = field.queryset.filter(device_type=data)",
            "",
            "        return data",
            "",
            "",
            "class ConsolePortTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = ConsolePortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "        ]",
            "",
            "",
            "class ConsoleServerPortTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = ConsoleServerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "        ]",
            "",
            "",
            "class PowerPortTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = PowerPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "        ]",
            "",
            "",
            "class PowerOutletTemplateImportForm(ComponentTemplateImportForm):",
            "    power_port = forms.ModelChoiceField(queryset=PowerPortTemplate.objects.all(), to_field_name=\"name\", required=False)",
            "",
            "    class Meta:",
            "        model = PowerOutletTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"power_port\",",
            "            \"feed_leg\",",
            "        ]",
            "",
            "",
            "class InterfaceTemplateImportForm(ComponentTemplateImportForm):",
            "    type = forms.ChoiceField(choices=InterfaceTypeChoices.CHOICES)",
            "",
            "    class Meta:",
            "        model = InterfaceTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"mgmt_only\",",
            "        ]",
            "",
            "",
            "class FrontPortTemplateImportForm(ComponentTemplateImportForm):",
            "    type = forms.ChoiceField(choices=PortTypeChoices.CHOICES)",
            "    rear_port = forms.ModelChoiceField(queryset=RearPortTemplate.objects.all(), to_field_name=\"name\", required=False)",
            "",
            "    class Meta:",
            "        model = FrontPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"type\",",
            "            \"rear_port\",",
            "            \"rear_port_position\",",
            "        ]",
            "",
            "",
            "class RearPortTemplateImportForm(ComponentTemplateImportForm):",
            "    type = forms.ChoiceField(choices=PortTypeChoices.CHOICES)",
            "",
            "    class Meta:",
            "        model = RearPortTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "            \"type\",",
            "            \"positions\",",
            "        ]",
            "",
            "",
            "class DeviceBayTemplateImportForm(ComponentTemplateImportForm):",
            "    class Meta:",
            "        model = DeviceBayTemplate",
            "        fields = [",
            "            \"device_type\",",
            "            \"name\",",
            "        ]",
            "",
            "",
            "#",
            "# Device roles",
            "#",
            "",
            "",
            "class DeviceRoleForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = DeviceRole",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"color\",",
            "            \"vm_role\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class DeviceRoleCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = DeviceRole",
            "        fields = DeviceRole.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "#",
            "# Platforms",
            "#",
            "",
            "",
            "class PlatformForm(NautobotModelForm):",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    slug = SlugField(max_length=64)",
            "",
            "    class Meta:",
            "        model = Platform",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"manufacturer\",",
            "            \"network_driver\",",
            "            \"napalm_driver\",",
            "            \"napalm_args\",",
            "            \"description\",",
            "        ]",
            "        widgets = {",
            "            \"napalm_args\": SmallTextarea(),",
            "        }",
            "",
            "",
            "class PlatformCSVForm(CustomFieldModelCSVForm):",
            "    manufacturer = CSVModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Limit platform assignments to this manufacturer\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Platform",
            "        fields = Platform.csv_headers",
            "",
            "",
            "#",
            "# Devices",
            "#",
            "",
            "",
            "class DeviceForm(LocatableModelFormMixin, NautobotModelForm, TenancyForm, LocalContextModelForm):",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "        initial_params={\"racks\": \"$rack\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"group_id\": \"$rack_group\",",
            "        },",
            "    )",
            "    device_redundancy_group = DynamicModelChoiceField(queryset=DeviceRedundancyGroup.objects.all(), required=False)",
            "    position = forms.IntegerField(",
            "        required=False,",
            "        help_text=\"The lowest-numbered unit occupied by the device\",",
            "        widget=APISelect(",
            "            api_url=\"/api/dcim/racks/{{rack}}/elevation/\",",
            "            attrs={",
            "                \"disabled-indicator\": \"device\",",
            "                \"data-query-param-face\": '[\"$face\"]',",
            "            },",
            "        ),",
            "    )",
            "    manufacturer = DynamicModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        required=False,",
            "        initial_params={\"device_types\": \"$device_type\"},",
            "    )",
            "    device_type = DynamicModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        query_params={\"manufacturer_id\": \"$manufacturer\"},",
            "    )",
            "    device_role = DynamicModelChoiceField(queryset=DeviceRole.objects.all())",
            "    platform = DynamicModelChoiceField(",
            "        queryset=Platform.objects.all(),",
            "        required=False,",
            "        query_params={\"manufacturer_id\": [\"$manufacturer\", \"null\"]},",
            "    )",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "    cluster_group = DynamicModelChoiceField(",
            "        queryset=ClusterGroup.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        initial_params={\"clusters\": \"$cluster\"},",
            "    )",
            "    cluster = DynamicModelChoiceField(",
            "        queryset=Cluster.objects.all(),",
            "        required=False,",
            "        query_params={\"group_id\": \"$cluster_group\"},",
            "    )",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = Device",
            "        fields = [",
            "            \"name\",",
            "            \"device_role\",",
            "            \"device_type\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"site\",",
            "            \"location\",",
            "            \"rack\",",
            "            \"device_redundancy_group\",",
            "            \"device_redundancy_group_priority\",",
            "            \"position\",",
            "            \"face\",",
            "            \"status\",",
            "            \"platform\",",
            "            \"primary_ip4\",",
            "            \"primary_ip6\",",
            "            \"secrets_group\",",
            "            \"cluster_group\",",
            "            \"cluster\",",
            "            \"tenant_group\",",
            "            \"tenant\",",
            "            \"comments\",",
            "            \"tags\",",
            "            \"local_context_data\",",
            "            \"local_context_schema\",",
            "        ]",
            "        help_texts = {",
            "            \"device_role\": \"The function this device serves\",",
            "            \"serial\": \"Chassis serial number\",",
            "            \"local_context_data\": \"Local config context data overwrites all source contexts in the final rendered \"",
            "            \"config context\",",
            "        }",
            "        widgets = {",
            "            \"face\": StaticSelect2(),",
            "            \"primary_ip4\": StaticSelect2(),",
            "            \"primary_ip6\": StaticSelect2(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if self.instance.present_in_database:",
            "            # Compile list of choices for primary IPv4 and IPv6 addresses",
            "            for family in [4, 6]:",
            "                ip_choices = [(None, \"---------\")]",
            "",
            "                # Gather PKs of all interfaces belonging to this Device or a peer VirtualChassis member",
            "                interface_ids = self.instance.vc_interfaces.values_list(\"pk\", flat=True)",
            "",
            "                # Collect interface IPs",
            "                # v2 TODO(jathan): Replace prefetch_related with select_related",
            "                interface_ips = (",
            "                    IPAddress.objects.ip_family(family)",
            "                    .filter(",
            "                        assigned_object_type=ContentType.objects.get_for_model(Interface),",
            "                        assigned_object_id__in=interface_ids,",
            "                    )",
            "                    .prefetch_related(\"assigned_object\")",
            "                )",
            "                if interface_ips:",
            "                    ip_list = [(ip.id, f\"{ip.address} ({ip.assigned_object})\") for ip in interface_ips]",
            "                    ip_choices.append((\"Interface IPs\", ip_list))",
            "                # Collect NAT IPs",
            "                # v2 TODO(jathan): Replace prefetch_related with select_related",
            "                nat_ips = (",
            "                    IPAddress.objects.select_related(\"nat_inside\")",
            "                    .ip_family(family)",
            "                    .filter(",
            "                        nat_inside__assigned_object_type=ContentType.objects.get_for_model(Interface),",
            "                        nat_inside__assigned_object_id__in=interface_ids,",
            "                    )",
            "                    .prefetch_related(\"assigned_object\")",
            "                )",
            "                if nat_ips:",
            "                    ip_list = [(ip.id, f\"{ip.address} (NAT)\") for ip in nat_ips]",
            "                    ip_choices.append((\"NAT IPs\", ip_list))",
            "                self.fields[f\"primary_ip{family}\"].choices = ip_choices",
            "",
            "            # If editing an existing device, exclude it from the list of occupied rack units. This ensures that a device",
            "            # can be flipped from one face to another.",
            "            self.fields[\"position\"].widget.add_query_param(\"exclude\", self.instance.pk)",
            "",
            "            # Limit platform by manufacturer",
            "            self.fields[\"platform\"].queryset = Platform.objects.filter(",
            "                Q(manufacturer__isnull=True) | Q(manufacturer=self.instance.device_type.manufacturer)",
            "            )",
            "",
            "            # Disable rack assignment if this is a child device installed in a parent device",
            "            if self.instance.device_type.is_child_device and hasattr(self.instance, \"parent_bay\"):",
            "                self.fields[\"site\"].disabled = True",
            "                self.fields[\"rack\"].disabled = True",
            "                self.initial[\"site\"] = self.instance.parent_bay.device.site_id",
            "                self.initial[\"rack\"] = self.instance.parent_bay.device.rack_id",
            "",
            "        else:",
            "            # An object that doesn't exist yet can't have any IPs assigned to it",
            "            self.fields[\"primary_ip4\"].choices = []",
            "            self.fields[\"primary_ip4\"].widget.attrs[\"readonly\"] = True",
            "            self.fields[\"primary_ip6\"].choices = []",
            "            self.fields[\"primary_ip6\"].widget.attrs[\"readonly\"] = True",
            "",
            "        # Rack position",
            "        position = self.data.get(\"position\") or self.initial.get(\"position\")",
            "        if position:",
            "            self.fields[\"position\"].widget.choices = [(position, f\"U{position}\")]",
            "",
            "",
            "class BaseDeviceCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    device_role = CSVModelChoiceField(",
            "        queryset=DeviceRole.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned role\",",
            "    )",
            "    tenant = CSVModelChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned tenant\",",
            "    )",
            "    manufacturer = CSVModelChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Device type manufacturer\",",
            "    )",
            "    device_type = CSVModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        to_field_name=\"model\",",
            "        help_text=\"Device type model\",",
            "    )",
            "    platform = CSVModelChoiceField(",
            "        queryset=Platform.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Assigned platform\",",
            "    )",
            "    cluster = CSVModelChoiceField(",
            "        queryset=Cluster.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Virtualization cluster\",",
            "    )",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Secrets group\",",
            "    )",
            "",
            "    class Meta:",
            "        fields = []",
            "        model = Device",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit device type queryset by manufacturer",
            "            params = {f\"manufacturer__{self.fields['manufacturer'].to_field_name}\": data.get(\"manufacturer\")}",
            "            self.fields[\"device_type\"].queryset = self.fields[\"device_type\"].queryset.filter(**params)",
            "",
            "",
            "class DeviceCSVForm(LocatableModelCSVFormMixin, BaseDeviceCSVForm):",
            "    rack_group = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack's group (if any)\",",
            "    )",
            "    rack = CSVModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Assigned rack\",",
            "    )",
            "    face = CSVChoiceField(choices=DeviceFaceChoices, required=False, help_text=\"Mounted rack face\")",
            "    device_redundancy_group = CSVModelChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        help_text=\"Associated device redundancy group (slug)\",",
            "    )",
            "",
            "    class Meta(BaseDeviceCSVForm.Meta):",
            "        fields = [",
            "            \"name\",",
            "            \"device_role\",",
            "            \"tenant\",",
            "            \"manufacturer\",",
            "            \"device_type\",",
            "            \"platform\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"status\",",
            "            \"site\",",
            "            \"location\",",
            "            \"rack_group\",",
            "            \"rack\",",
            "            \"position\",",
            "            \"face\",",
            "            \"device_redundancy_group\",",
            "            \"device_redundancy_group_priority\",",
            "            \"cluster\",",
            "            \"comments\",",
            "        ]",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit rack_group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "            # Limit rack queryset by assigned site and group",
            "            params = {",
            "                f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\"),",
            "                f\"group__{self.fields['rack_group'].to_field_name}\": data.get(\"rack_group\"),",
            "            }",
            "            self.fields[\"rack\"].queryset = self.fields[\"rack\"].queryset.filter(**params)",
            "",
            "            # 2.0 TODO: limit location queryset by assigned site",
            "",
            "",
            "class ChildDeviceCSVForm(BaseDeviceCSVForm):",
            "    parent = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\", help_text=\"Parent device\")",
            "    device_bay = CSVModelChoiceField(",
            "        queryset=DeviceBay.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Device bay in which this device is installed\",",
            "    )",
            "",
            "    class Meta(BaseDeviceCSVForm.Meta):",
            "        fields = [",
            "            \"name\",",
            "            \"device_role\",",
            "            \"tenant\",",
            "            \"manufacturer\",",
            "            \"device_type\",",
            "            \"platform\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"status\",",
            "            \"parent\",",
            "            \"device_bay\",",
            "            \"cluster\",",
            "            \"comments\",",
            "        ]",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit device bay queryset by parent device",
            "            params = {f\"device__{self.fields['parent'].to_field_name}\": data.get(\"parent\")}",
            "            self.fields[\"device_bay\"].queryset = self.fields[\"device_bay\"].queryset.filter(**params)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Set parent_bay reverse relationship",
            "        device_bay = self.cleaned_data.get(\"device_bay\")",
            "        if device_bay:",
            "            self.instance.parent_bay = device_bay",
            "",
            "        # Inherit site and rack from parent device",
            "        parent = self.cleaned_data.get(\"parent\")",
            "        if parent:",
            "            self.instance.site = parent.site",
            "            self.instance.rack = parent.rack",
            "",
            "",
            "class DeviceBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    LocatableModelBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "    LocalContextModelBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Device.objects.all(), widget=forms.MultipleHiddenInput())",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    device_type = DynamicModelChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        required=False,",
            "        query_params={\"manufacturer_id\": \"$manufacturer\"},",
            "    )",
            "    rack = DynamicModelChoiceField(queryset=Rack.objects.all(), required=False)",
            "    position = forms.IntegerField(required=False)",
            "    face = forms.ChoiceField(",
            "        required=False,",
            "        choices=add_blank_choice(DeviceFaceChoices),",
            "        widget=StaticSelect2(),",
            "    )",
            "    rack_group = DynamicModelChoiceField(queryset=RackGroup.objects.all(), required=False)",
            "    device_role = DynamicModelChoiceField(queryset=DeviceRole.objects.all(), required=False)",
            "    tenant = DynamicModelChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    platform = DynamicModelChoiceField(queryset=Platform.objects.all(), required=False)",
            "    serial = forms.CharField(max_length=255, required=False, label=\"Serial Number\")",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "    device_redundancy_group = DynamicModelChoiceField(queryset=DeviceRedundancyGroup.objects.all(), required=False)",
            "    device_redundancy_group_priority = forms.IntegerField(required=False, min_value=1)",
            "",
            "    class Meta:",
            "        model = Device",
            "        nullable_fields = [",
            "            \"location\",",
            "            \"tenant\",",
            "            \"platform\",",
            "            \"serial\",",
            "            \"rack\",",
            "            \"position\",",
            "            \"face\",",
            "            \"rack_group\",",
            "            \"secrets_group\",",
            "            \"device_redundancy_group\",",
            "            \"device_redundancy_group_priority\",",
            "        ]",
            "",
            "    def __init__(self, *args, **kwrags):",
            "        super().__init__(*args, **kwrags)",
            "",
            "        # Disable position because only setting null value is required",
            "        self.fields[\"position\"].disabled = True",
            "",
            "",
            "class DeviceFilterForm(",
            "    NautobotFilterForm,",
            "    LocalContextFilterForm,",
            "    LocatableModelFilterFormMixin,",
            "    TenancyFilterForm,",
            "    StatusModelFilterFormMixin,",
            "):",
            "    model = Device",
            "    field_order = [",
            "        \"q\",",
            "        \"region\",",
            "        \"site\",",
            "        \"location\",",
            "        \"rack_group_id\",",
            "        \"rack_id\",",
            "        \"status\",",
            "        \"role\",",
            "        \"tenant_group\",",
            "        \"tenant\",",
            "        \"manufacturer_id\",",
            "        \"device_type_id\",",
            "        \"mac_address\",",
            "        \"has_primary_ip\",",
            "    ]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    rack_group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        label=\"Rack group\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    rack_id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        label=\"Rack\",",
            "        null_option=\"None\",",
            "        query_params={",
            "            \"site\": \"$site\",",
            "            \"group_id\": \"$rack_group_id\",",
            "        },",
            "    )",
            "    role = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), to_field_name=\"slug\", required=False)",
            "    manufacturer = DynamicModelMultipleChoiceField(",
            "        queryset=Manufacturer.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        label=\"Manufacturer\",",
            "    )",
            "    device_type_id = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceType.objects.all(),",
            "        required=False,",
            "        label=\"Model\",",
            "        query_params={\"manufacturer\": \"$manufacturer\"},",
            "    )",
            "    platform = DynamicModelMultipleChoiceField(",
            "        queryset=Platform.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    mac_address = forms.CharField(required=False, label=\"MAC address\")",
            "    device_redundancy_group = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    device_redundancy_group_priority = forms.IntegerField(min_value=1, required=False)",
            "    has_primary_ip = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has a primary IP\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    virtual_chassis_member = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Virtual chassis member\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    console_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    console_server_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has console server ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    power_outlets = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has power outlets\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    interfaces = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has interfaces\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    pass_through_ports = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has pass-through ports\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Device components",
            "#",
            "",
            "",
            "class ComponentCreateForm(ComponentForm):",
            "    \"\"\"",
            "    Base form for the creation of device components (models subclassed from ComponentModel).",
            "    \"\"\"",
            "",
            "    device = DynamicModelChoiceField(queryset=Device.objects.all())",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "",
            "class DeviceBulkAddComponentForm(ComponentForm, CustomFieldModelBulkEditFormMixin):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Device.objects.all(), widget=forms.MultipleHiddenInput())",
            "    description = forms.CharField(max_length=100, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "#",
            "# Console ports",
            "#",
            "",
            "",
            "class ConsolePortFilterForm(DeviceComponentFilterForm):",
            "    model = ConsolePort",
            "    type = forms.MultipleChoiceField(choices=ConsolePortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class ConsolePortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsolePort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsolePortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class ConsolePortBulkCreateForm(form_from_model(ConsolePort, [\"type\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (\"name_pattern\", \"label_pattern\", \"type\", \"description\", \"tags\")",
            "",
            "",
            "class ConsolePortBulkEditForm(",
            "    form_from_model(ConsolePort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConsolePort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class ConsolePortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=ConsolePortTypeChoices, required=False, help_text=\"Port type\")",
            "",
            "    class Meta:",
            "        model = ConsolePort",
            "        fields = ConsolePort.csv_headers",
            "",
            "",
            "#",
            "# Console server ports",
            "#",
            "",
            "",
            "class ConsoleServerPortFilterForm(DeviceComponentFilterForm):",
            "    model = ConsoleServerPort",
            "    type = forms.MultipleChoiceField(choices=ConsolePortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class ConsoleServerPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = ConsoleServerPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class ConsoleServerPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(ConsolePortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class ConsoleServerPortBulkCreateForm(form_from_model(ConsoleServerPort, [\"type\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (\"name_pattern\", \"label_pattern\", \"type\", \"description\", \"tags\")",
            "",
            "",
            "class ConsoleServerPortBulkEditForm(",
            "    form_from_model(ConsoleServerPort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConsoleServerPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class ConsoleServerPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=ConsolePortTypeChoices, required=False, help_text=\"Port type\")",
            "",
            "    class Meta:",
            "        model = ConsoleServerPort",
            "        fields = ConsoleServerPort.csv_headers",
            "",
            "",
            "#",
            "# Power ports",
            "#",
            "",
            "",
            "class PowerPortFilterForm(DeviceComponentFilterForm):",
            "    model = PowerPort",
            "    type = forms.MultipleChoiceField(choices=PowerPortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class PowerPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = PowerPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"maximum_draw\",",
            "            \"allocated_draw\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class PowerPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerPortTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    maximum_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Maximum draw in watts\")",
            "    allocated_draw = forms.IntegerField(min_value=1, required=False, help_text=\"Allocated draw in watts\")",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"maximum_draw\",",
            "        \"allocated_draw\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class PowerPortBulkCreateForm(",
            "    form_from_model(PowerPort, [\"type\", \"maximum_draw\", \"allocated_draw\", \"tags\"]),",
            "    DeviceBulkAddComponentForm,",
            "):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"maximum_draw\",",
            "        \"allocated_draw\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class PowerPortBulkEditForm(",
            "    form_from_model(PowerPort, [\"label\", \"type\", \"maximum_draw\", \"allocated_draw\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class PowerPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=PowerPortTypeChoices, required=False, help_text=\"Port type\")",
            "",
            "    class Meta:",
            "        model = PowerPort",
            "        fields = PowerPort.csv_headers",
            "",
            "",
            "#",
            "# Power outlets",
            "#",
            "",
            "",
            "class PowerOutletFilterForm(DeviceComponentFilterForm):",
            "    model = PowerOutlet",
            "    type = forms.MultipleChoiceField(choices=PowerOutletTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class PowerOutletForm(NautobotModelForm):",
            "    power_port = forms.ModelChoiceField(queryset=PowerPort.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        model = PowerOutlet",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"power_port\",",
            "            \"feed_leg\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port choices to the local device",
            "        if hasattr(self.instance, \"device\"):",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device=self.instance.device)",
            "",
            "",
            "class PowerOutletCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerOutletTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    power_port = forms.ModelChoiceField(queryset=PowerPort.objects.all(), required=False)",
            "    feed_leg = forms.ChoiceField(choices=add_blank_choice(PowerOutletFeedLegChoices), required=False)",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"power_port\",",
            "        \"feed_leg\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port queryset to PowerPorts which belong to the parent Device",
            "        device = Device.objects.get(pk=self.initial.get(\"device\") or self.data.get(\"device\"))",
            "        self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device=device)",
            "",
            "",
            "class PowerOutletBulkCreateForm(form_from_model(PowerOutlet, [\"type\", \"feed_leg\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"feed_leg\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class PowerOutletBulkEditForm(",
            "    form_from_model(PowerOutlet, [\"label\", \"type\", \"feed_leg\", \"power_port\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerOutlet.objects.all(), widget=forms.MultipleHiddenInput())",
            "    device = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        disabled=True,",
            "        widget=forms.HiddenInput(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"type\", \"feed_leg\", \"power_port\", \"description\"]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit power_port queryset to PowerPorts which belong to the parent Device",
            "        if \"device\" in self.initial:",
            "            device = Device.objects.filter(pk=self.initial[\"device\"]).first()",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device=device)",
            "        else:",
            "            self.fields[\"power_port\"].choices = ()",
            "            self.fields[\"power_port\"].widget.attrs[\"disabled\"] = True",
            "",
            "",
            "class PowerOutletCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(choices=PowerOutletTypeChoices, required=False, help_text=\"Outlet type\")",
            "    power_port = CSVModelChoiceField(",
            "        queryset=PowerPort.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Local power port which feeds this outlet\",",
            "    )",
            "    feed_leg = CSVChoiceField(",
            "        choices=PowerOutletFeedLegChoices,",
            "        required=False,",
            "        help_text=\"Electrical phase (for three-phase circuits)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = PowerOutlet",
            "        fields = PowerOutlet.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit PowerPort choices to those belonging to this device (or VC master)",
            "        if self.is_bound:",
            "            try:",
            "                device = self.fields[\"device\"].to_python(self.data[\"device\"])",
            "            except forms.ValidationError:",
            "                device = None",
            "        else:",
            "            try:",
            "                device = self.instance.device",
            "            except Device.DoesNotExist:",
            "                device = None",
            "",
            "        if device:",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.filter(device__in=[device, device.get_vc_master()])",
            "        else:",
            "            self.fields[\"power_port\"].queryset = PowerPort.objects.none()",
            "",
            "",
            "#",
            "# Interfaces",
            "#",
            "",
            "",
            "class InterfaceFilterForm(DeviceComponentFilterForm, StatusModelFilterFormMixin):",
            "    model = Interface",
            "    type = forms.MultipleChoiceField(choices=InterfaceTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    mgmt_only = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    mac_address = forms.CharField(required=False, label=\"MAC address\")",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class InterfaceForm(InterfaceCommonForm, NautobotModelForm):",
            "    parent_interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        label=\"Parent interface\",",
            "        query_params={",
            "            \"kind\": \"physical\",",
            "        },",
            "        help_text=\"Assigned parent interface\",",
            "    )",
            "    bridge = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        label=\"Bridge interface\",",
            "        help_text=\"Assigned bridge interface\",",
            "    )",
            "    lag = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        label=\"LAG interface\",",
            "        query_params={",
            "            \"type\": InterfaceTypeChoices.TYPE_LAG,",
            "        },",
            "        help_text=\"Assigned LAG interface\",",
            "    )",
            "    untagged_vlan = DynamicModelChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        label=\"Untagged VLAN\",",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "    tagged_vlans = DynamicModelMultipleChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        label=\"Tagged VLANs\",",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = Interface",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"enabled\",",
            "            \"parent_interface\",",
            "            \"bridge\",",
            "            \"lag\",",
            "            \"mac_address\",",
            "            \"mtu\",",
            "            \"mgmt_only\",",
            "            \"description\",",
            "            \"mode\",",
            "            \"untagged_vlan\",",
            "            \"tagged_vlans\",",
            "            \"tags\",",
            "            \"status\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "            \"mode\": StaticSelect2(),",
            "        }",
            "        labels = {",
            "            \"mode\": \"802.1Q Mode\",",
            "        }",
            "        help_texts = {",
            "            \"mode\": INTERFACE_MODE_HELP_TEXT,",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if self.is_bound:",
            "            device = Device.objects.get(pk=self.data[\"device\"])",
            "        else:",
            "            device = self.instance.device",
            "",
            "        # Restrict parent/bridge/LAG interface assignment by device",
            "        self.fields[\"parent_interface\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "        self.fields[\"bridge\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "        self.fields[\"lag\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "",
            "        # Add current site to VLANs query params",
            "        self.fields[\"untagged_vlan\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "        self.fields[\"tagged_vlans\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "",
            "",
            "class InterfaceCreateForm(ComponentCreateForm, InterfaceCommonForm):",
            "    type = forms.ChoiceField(",
            "        choices=InterfaceTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    status = DynamicModelChoiceField(",
            "        queryset=Status.objects.all(),",
            "        query_params={",
            "            \"content_types\": Interface._meta.label_lower,",
            "        },",
            "    )",
            "    enabled = forms.BooleanField(required=False, initial=True)",
            "    parent_interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"device_with_common_vc\": \"$device\",",
            "            \"kind\": \"physical\",",
            "        },",
            "        help_text=\"Assigned parent interface\",",
            "    )",
            "    bridge = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"device_with_common_vc\": \"$device\",",
            "        },",
            "        help_text=\"Assigned bridge interface\",",
            "    )",
            "    lag = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"device_with_common_vc\": \"$device\",",
            "            \"type\": InterfaceTypeChoices.TYPE_LAG,",
            "        },",
            "        help_text=\"Assigned LAG interface\",",
            "    )",
            "    mtu = forms.IntegerField(",
            "        required=False,",
            "        min_value=INTERFACE_MTU_MIN,",
            "        max_value=INTERFACE_MTU_MAX,",
            "        label=\"MTU\",",
            "    )",
            "    mac_address = forms.CharField(required=False, label=\"MAC Address\")",
            "    mgmt_only = forms.BooleanField(",
            "        required=False,",
            "        label=\"Management only\",",
            "        help_text=\"This interface is used only for out-of-band management\",",
            "    )",
            "    mode = forms.ChoiceField(",
            "        choices=add_blank_choice(InterfaceModeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    untagged_vlan = DynamicModelChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={",
            "            \"available_on_device\": \"$device\",",
            "        },",
            "    )",
            "    tagged_vlans = DynamicModelMultipleChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={\"available_on_device\": \"$device\"},",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"status\",",
            "        \"type\",",
            "        \"enabled\",",
            "        \"parent_interface\",",
            "        \"bridge\",",
            "        \"lag\",",
            "        \"mtu\",",
            "        \"mac_address\",",
            "        \"description\",",
            "        \"mgmt_only\",",
            "        \"mode\",",
            "        \"untagged_vlan\",",
            "        \"tagged_vlans\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InterfaceBulkCreateForm(",
            "    form_from_model(Interface, [\"enabled\", \"mtu\", \"mgmt_only\", \"mode\", \"tags\"]),",
            "    DeviceBulkAddComponentForm,",
            "):",
            "    type = forms.ChoiceField(",
            "        choices=InterfaceTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    status = DynamicModelChoiceField(",
            "        required=True,",
            "        queryset=Status.objects.all(),",
            "        query_params={\"content_types\": Interface._meta.label_lower},",
            "    )",
            "",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"status\",",
            "        \"type\",",
            "        \"enabled\",",
            "        \"mtu\",",
            "        \"mgmt_only\",",
            "        \"description\",",
            "        \"mode\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InterfaceBulkEditForm(",
            "    form_from_model(",
            "        Interface, [\"label\", \"type\", \"parent_interface\", \"bridge\", \"lag\", \"mac_address\", \"mtu\", \"description\", \"mode\"]",
            "    ),",
            "    TagsBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Interface.objects.all(), widget=forms.MultipleHiddenInput())",
            "    device = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        disabled=True,",
            "        widget=forms.HiddenInput(),",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect)",
            "    parent_interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"kind\": \"physical\",",
            "        },",
            "    )",
            "    bridge = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "    )",
            "    lag = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"type\": InterfaceTypeChoices.TYPE_LAG,",
            "        },",
            "    )",
            "    mgmt_only = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect, label=\"Management only\")",
            "    untagged_vlan = DynamicModelChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "    tagged_vlans = DynamicModelMultipleChoiceField(",
            "        queryset=VLAN.objects.all(),",
            "        required=False,",
            "        brief_mode=False,",
            "        query_params={",
            "            \"site_id\": \"null\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"label\",",
            "            \"parent_interface\",",
            "            \"bridge\",",
            "            \"lag\",",
            "            \"mac_address\",",
            "            \"mtu\",",
            "            \"description\",",
            "            \"mode\",",
            "            \"untagged_vlan\",",
            "            \"tagged_vlans\",",
            "        ]",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit LAG choices to interfaces which belong to the parent device (or VC master)",
            "        if \"device\" in self.initial:",
            "            device = Device.objects.filter(pk=self.initial[\"device\"]).first()",
            "",
            "            # Restrict parent/bridge/LAG interface assignment by device",
            "            self.fields[\"parent_interface\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "            self.fields[\"bridge\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "            self.fields[\"lag\"].widget.add_query_param(\"device_with_common_vc\", device.pk)",
            "",
            "            # Add current site to VLANs query params",
            "            self.fields[\"untagged_vlan\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "            self.fields[\"tagged_vlans\"].widget.add_query_param(\"site_id\", device.site.pk)",
            "        else:",
            "            # See netbox-community/netbox#4523",
            "            if \"pk\" in self.initial:",
            "                site = None",
            "                interfaces = Interface.objects.filter(pk__in=self.initial[\"pk\"]).select_related(\"device__site\")",
            "",
            "                # Check interface sites.  First interface should set site, further interfaces will either continue the",
            "                # loop or reset back to no site and break the loop.",
            "                for interface in interfaces:",
            "                    if site is None:",
            "                        site = interface.device.site",
            "                    elif interface.device.site is not site:",
            "                        site = None",
            "                        break",
            "",
            "                if site is not None:",
            "                    self.fields[\"untagged_vlan\"].widget.add_query_param(\"site_id\", site.pk)",
            "                    self.fields[\"tagged_vlans\"].widget.add_query_param(\"site_id\", site.pk)",
            "",
            "            self.fields[\"parent_interface\"].choices = ()",
            "            self.fields[\"parent_interface\"].widget.attrs[\"disabled\"] = True",
            "            self.fields[\"bridge\"].choices = ()",
            "            self.fields[\"bridge\"].widget.attrs[\"disabled\"] = True",
            "            self.fields[\"lag\"].choices = ()",
            "            self.fields[\"lag\"].widget.attrs[\"disabled\"] = True",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Untagged interfaces cannot be assigned tagged VLANs",
            "        if self.cleaned_data[\"mode\"] == InterfaceModeChoices.MODE_ACCESS and self.cleaned_data[\"tagged_vlans\"]:",
            "            raise forms.ValidationError({\"mode\": \"An access interface cannot have tagged VLANs assigned.\"})",
            "",
            "        # Remove all tagged VLAN assignments from \"tagged all\" interfaces",
            "        elif self.cleaned_data[\"mode\"] == InterfaceModeChoices.MODE_TAGGED_ALL:",
            "            self.cleaned_data[\"tagged_vlans\"] = []",
            "",
            "",
            "class InterfaceCSVForm(CustomFieldModelCSVForm, StatusModelCSVFormMixin):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    parent_interface = CSVModelChoiceField(",
            "        queryset=Interface.objects.all(), required=False, to_field_name=\"name\", help_text=\"Parent interface\"",
            "    )",
            "    bridge = CSVModelChoiceField(",
            "        queryset=Interface.objects.all(), required=False, to_field_name=\"name\", help_text=\"Bridge interface\"",
            "    )",
            "    lag = CSVModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Parent LAG interface\",",
            "    )",
            "    type = CSVChoiceField(choices=InterfaceTypeChoices, help_text=\"Physical medium\")",
            "    mode = CSVChoiceField(",
            "        choices=InterfaceModeChoices,",
            "        required=False,",
            "        help_text=\"IEEE 802.1Q operational mode (for L2 interfaces)\",",
            "    )",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit choices for parent, bridge, and LAG interfaces to the assigned device (or VC)",
            "            device_name = data.get(\"device\")",
            "            if device_name is not None:",
            "                device = Device.objects.filter(name=device_name).first()",
            "",
            "                filter_by = Q(device=device)",
            "",
            "                if device and device.virtual_chassis:",
            "                    filter_by |= Q(device__virtual_chassis=device.virtual_chassis)",
            "",
            "                self.fields[\"parent_interface\"].queryset = (",
            "                    self.fields[\"parent_interface\"]",
            "                    .queryset.filter(Q(filter_by))",
            "                    .exclude(type__in=NONCONNECTABLE_IFACE_TYPES)",
            "                )",
            "                self.fields[\"bridge\"].queryset = self.fields[\"bridge\"].queryset.filter(filter_by)",
            "",
            "                filter_by &= Q(type=InterfaceTypeChoices.TYPE_LAG)",
            "                self.fields[\"lag\"].queryset = self.fields[\"lag\"].queryset.filter(filter_by)",
            "            else:",
            "                self.fields[\"parent_interface\"].queryset = self.fields[\"parent_interface\"].queryset.none()",
            "                self.fields[\"bridge\"].queryset = self.fields[\"bridge\"].queryset.none()",
            "                self.fields[\"lag\"].queryset = self.fields[\"lag\"].queryset.none()",
            "",
            "    class Meta:",
            "        model = Interface",
            "        fields = Interface.csv_headers",
            "",
            "    def clean_enabled(self):",
            "        # Make sure enabled is True when it's not included in the uploaded data",
            "        if \"enabled\" not in self.data:",
            "            return True",
            "        else:",
            "            return self.cleaned_data[\"enabled\"]",
            "",
            "",
            "#",
            "# Front pass-through ports",
            "#",
            "",
            "",
            "class FrontPortFilterForm(DeviceComponentFilterForm):",
            "    model = FrontPort",
            "    type = forms.MultipleChoiceField(choices=PortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class FrontPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = FrontPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"rear_port\",",
            "            \"rear_port_position\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "            \"rear_port\": StaticSelect2(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit RearPort choices to the local device",
            "        if hasattr(self.instance, \"device\"):",
            "            self.fields[\"rear_port\"].queryset = self.fields[\"rear_port\"].queryset.filter(device=self.instance.device)",
            "",
            "",
            "# TODO: Merge with FrontPortTemplateCreateForm to remove duplicate logic",
            "class FrontPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=PortTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    rear_port_set = forms.MultipleChoiceField(",
            "        choices=[],",
            "        label=\"Rear ports\",",
            "        help_text=\"Select one rear port assignment for each front port being created.\",",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"rear_port_set\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        device = Device.objects.get(pk=self.initial.get(\"device\") or self.data.get(\"device\"))",
            "",
            "        # Determine which rear port positions are occupied. These will be excluded from the list of available",
            "        # mappings.",
            "        occupied_port_positions = [",
            "            (front_port.rear_port_id, front_port.rear_port_position) for front_port in device.frontports.all()",
            "        ]",
            "",
            "        # Populate rear port choices",
            "        choices = []",
            "        rear_ports = RearPort.objects.filter(device=device)",
            "        for rear_port in rear_ports:",
            "            for i in range(1, rear_port.positions + 1):",
            "                if (rear_port.pk, i) not in occupied_port_positions:",
            "                    choices.append(",
            "                        (",
            "                            f\"{rear_port.pk}:{i}\",",
            "                            f\"{rear_port.name}:{i}\",",
            "                        )",
            "                    )",
            "        self.fields[\"rear_port_set\"].choices = choices",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate that the number of ports being created equals the number of selected (rear port, position) tuples",
            "        front_port_count = len(self.cleaned_data[\"name_pattern\"])",
            "        rear_port_count = len(self.cleaned_data[\"rear_port_set\"])",
            "        if front_port_count != rear_port_count:",
            "            raise forms.ValidationError(",
            "                {",
            "                    \"rear_port_set\": (",
            "                        f\"The provided name pattern will create {front_port_count} ports, \"",
            "                        f\"however {rear_port_count} rear port assignments were selected. These counts must match.\"",
            "                    )",
            "                }",
            "            )",
            "",
            "    def get_iterative_data(self, iteration):",
            "        # Assign rear port and position from selected set",
            "        rear_port, position = self.cleaned_data[\"rear_port_set\"][iteration].split(\":\")",
            "",
            "        return {",
            "            \"rear_port\": rear_port,",
            "            \"rear_port_position\": int(position),",
            "        }",
            "",
            "",
            "# class FrontPortBulkCreateForm(",
            "#     form_from_model(FrontPort, ['label', 'type', 'description', 'tags']),",
            "#     DeviceBulkAddComponentForm",
            "# ):",
            "#     pass",
            "",
            "",
            "class FrontPortBulkEditForm(",
            "    form_from_model(FrontPort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=FrontPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class FrontPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    rear_port = CSVModelChoiceField(",
            "        queryset=RearPort.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Corresponding rear port\",",
            "    )",
            "    type = CSVChoiceField(choices=PortTypeChoices, help_text=\"Physical medium classification\")",
            "",
            "    class Meta:",
            "        model = FrontPort",
            "        fields = FrontPort.csv_headers",
            "        help_texts = {",
            "            \"rear_port_position\": \"Mapped position on corresponding rear port\",",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit RearPort choices to those belonging to this device (or VC master)",
            "        if self.is_bound:",
            "            try:",
            "                device = self.fields[\"device\"].to_python(self.data[\"device\"])",
            "            except forms.ValidationError:",
            "                device = None",
            "        else:",
            "            try:",
            "                device = self.instance.device",
            "            except Device.DoesNotExist:",
            "                device = None",
            "",
            "        if device:",
            "            self.fields[\"rear_port\"].queryset = RearPort.objects.filter(device__in=[device, device.get_vc_master()])",
            "        else:",
            "            self.fields[\"rear_port\"].queryset = RearPort.objects.none()",
            "",
            "",
            "#",
            "# Rear pass-through ports",
            "#",
            "",
            "",
            "class RearPortFilterForm(DeviceComponentFilterForm):",
            "    model = RearPort",
            "    type = forms.MultipleChoiceField(choices=PortTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class RearPortForm(NautobotModelForm):",
            "    class Meta:",
            "        model = RearPort",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"type\",",
            "            \"positions\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "            \"type\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class RearPortCreateForm(ComponentCreateForm):",
            "    type = forms.ChoiceField(",
            "        choices=PortTypeChoices,",
            "        widget=StaticSelect2(),",
            "    )",
            "    positions = forms.IntegerField(",
            "        min_value=REARPORT_POSITIONS_MIN,",
            "        max_value=REARPORT_POSITIONS_MAX,",
            "        initial=1,",
            "        help_text=\"The number of front ports which may be mapped to each rear port\",",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"positions\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class RearPortBulkCreateForm(form_from_model(RearPort, [\"type\", \"positions\", \"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"type\",",
            "        \"positions\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class RearPortBulkEditForm(",
            "    form_from_model(RearPort, [\"label\", \"type\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=RearPort.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class RearPortCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    type = CSVChoiceField(",
            "        help_text=\"Physical medium classification\",",
            "        choices=PortTypeChoices,",
            "    )",
            "",
            "    class Meta:",
            "        model = RearPort",
            "        fields = RearPort.csv_headers",
            "        help_texts = {\"positions\": \"Number of front ports which may be mapped\"}",
            "",
            "",
            "#",
            "# Device bays",
            "#",
            "",
            "",
            "class DeviceBayFilterForm(DeviceComponentFilterForm):",
            "    model = DeviceBay",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class DeviceBayForm(NautobotModelForm):",
            "    class Meta:",
            "        model = DeviceBay",
            "        fields = [",
            "            \"device\",",
            "            \"name\",",
            "            \"label\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"device\": forms.HiddenInput(),",
            "        }",
            "",
            "",
            "class DeviceBayCreateForm(ComponentCreateForm):",
            "    field_order = (\"device\", \"name_pattern\", \"label_pattern\", \"description\", \"tags\")",
            "",
            "",
            "class PopulateDeviceBayForm(BootstrapMixin, forms.Form):",
            "    installed_device = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        label=\"Child Device\",",
            "        help_text=\"Child devices must first be created and assigned to the site/rack of the parent device.\",",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    def __init__(self, device_bay, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.fields[\"installed_device\"].queryset = Device.objects.filter(",
            "            site=device_bay.device.site,",
            "            rack=device_bay.device.rack,",
            "            parent_bay__isnull=True,",
            "            device_type__u_height=0,",
            "            device_type__subdevice_role=SubdeviceRoleChoices.ROLE_CHILD,",
            "        ).exclude(pk=device_bay.device.pk)",
            "",
            "",
            "class DeviceBayBulkCreateForm(form_from_model(DeviceBay, [\"tags\"]), DeviceBulkAddComponentForm):",
            "    field_order = (\"name_pattern\", \"label_pattern\", \"description\", \"tags\")",
            "",
            "",
            "class DeviceBayBulkEditForm(",
            "    form_from_model(DeviceBay, [\"label\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceBay.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"description\"]",
            "",
            "",
            "class DeviceBayCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    installed_device = CSVModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Child device installed within this bay\",",
            "        error_messages={",
            "            \"invalid_choice\": \"Child device not found.\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = DeviceBay",
            "        fields = DeviceBay.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Limit installed device choices to devices of the correct type and location",
            "        if self.is_bound:",
            "            try:",
            "                device = self.fields[\"device\"].to_python(self.data[\"device\"])",
            "            except forms.ValidationError:",
            "                device = None",
            "        else:",
            "            try:",
            "                device = self.instance.device",
            "            except Device.DoesNotExist:",
            "                device = None",
            "",
            "        if device:",
            "            self.fields[\"installed_device\"].queryset = Device.objects.filter(",
            "                site=device.site,",
            "                rack=device.rack,",
            "                parent_bay__isnull=True,",
            "                device_type__u_height=0,",
            "                device_type__subdevice_role=SubdeviceRoleChoices.ROLE_CHILD,",
            "            ).exclude(pk=device.pk)",
            "        else:",
            "            self.fields[\"installed_device\"].queryset = Interface.objects.none()",
            "",
            "",
            "#",
            "# Inventory items",
            "#",
            "",
            "",
            "class InventoryItemForm(NautobotModelForm):",
            "    device = DynamicModelChoiceField(queryset=Device.objects.all())",
            "    parent = DynamicModelChoiceField(",
            "        queryset=InventoryItem.objects.all(),",
            "        required=False,",
            "        query_params={\"device_id\": \"$device\"},",
            "    )",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        model = InventoryItem",
            "        fields = [",
            "            \"device\",",
            "            \"parent\",",
            "            \"name\",",
            "            \"label\",",
            "            \"manufacturer\",",
            "            \"part_id\",",
            "            \"serial\",",
            "            \"asset_tag\",",
            "            \"description\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class InventoryItemCreateForm(ComponentCreateForm):",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "    parent = DynamicModelChoiceField(",
            "        queryset=InventoryItem.objects.all(),",
            "        required=False,",
            "        query_params={\"device_id\": \"$device\"},",
            "    )",
            "    part_id = forms.CharField(max_length=50, required=False, label=\"Part ID\")",
            "    serial = forms.CharField(",
            "        max_length=255,",
            "        required=False,",
            "    )",
            "    asset_tag = forms.CharField(",
            "        max_length=50,",
            "        required=False,",
            "    )",
            "    field_order = (",
            "        \"device\",",
            "        \"parent\",",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"manufacturer\",",
            "        \"part_id\",",
            "        \"serial\",",
            "        \"asset_tag\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InventoryItemCSVForm(CustomFieldModelCSVForm):",
            "    device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\")",
            "    manufacturer = CSVModelChoiceField(queryset=Manufacturer.objects.all(), to_field_name=\"name\", required=False)",
            "",
            "    class Meta:",
            "        model = InventoryItem",
            "        fields = InventoryItem.csv_headers",
            "",
            "",
            "class InventoryItemBulkCreateForm(",
            "    form_from_model(InventoryItem, [\"manufacturer\", \"part_id\", \"serial\", \"asset_tag\", \"discovered\", \"tags\"]),",
            "    DeviceBulkAddComponentForm,",
            "):",
            "    field_order = (",
            "        \"name_pattern\",",
            "        \"label_pattern\",",
            "        \"manufacturer\",",
            "        \"part_id\",",
            "        \"serial\",",
            "        \"asset_tag\",",
            "        \"discovered\",",
            "        \"description\",",
            "        \"tags\",",
            "    )",
            "",
            "",
            "class InventoryItemBulkEditForm(",
            "    form_from_model(InventoryItem, [\"label\", \"manufacturer\", \"part_id\", \"description\"]),",
            "    TagsBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=InventoryItem.objects.all(), widget=forms.MultipleHiddenInput())",
            "    manufacturer = DynamicModelChoiceField(queryset=Manufacturer.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"label\", \"manufacturer\", \"part_id\", \"description\"]",
            "",
            "",
            "class InventoryItemFilterForm(DeviceComponentFilterForm):",
            "    model = InventoryItem",
            "    manufacturer = DynamicModelMultipleChoiceField(",
            "        queryset=Manufacturer.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    serial = forms.CharField(required=False)",
            "    asset_tag = forms.CharField(required=False)",
            "    discovered = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Cables",
            "#",
            "",
            "",
            "class ConnectCableToDeviceForm(ConnectCableExcludeIDMixin, NautobotModelForm):",
            "    \"\"\"",
            "    Base form for connecting a Cable to a Device component",
            "    \"\"\"",
            "",
            "    termination_b_region = DynamicModelChoiceField(queryset=Region.objects.all(), label=\"Region\", required=False)",
            "    termination_b_site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        label=\"Site\",",
            "        required=False,",
            "        query_params={\"region_id\": \"$termination_b_region\"},",
            "    )",
            "    termination_b_rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        label=\"Rack\",",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$termination_b_site\"},",
            "    )",
            "    termination_b_device = DynamicModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        label=\"Device\",",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$termination_b_site\",",
            "            \"rack_id\": \"$termination_b_rack\",",
            "        },",
            "    )",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"termination_b_region\",",
            "            \"termination_b_site\",",
            "            \"termination_b_rack\",",
            "            \"termination_b_device\",",
            "            \"termination_b_id\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"type\": StaticSelect2,",
            "            \"length_unit\": StaticSelect2,",
            "        }",
            "        help_texts = {",
            "            \"status\": \"Connection status\",",
            "        }",
            "",
            "    def clean_termination_b_id(self):",
            "        # Return the PK rather than the object",
            "        return getattr(self.cleaned_data[\"termination_b_id\"], \"pk\", None)",
            "",
            "",
            "class ConnectCableToConsolePortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=ConsolePort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToConsoleServerPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=ConsoleServerPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToPowerPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=PowerPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToPowerOutletForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=PowerOutlet.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToInterfaceForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={",
            "            \"device_id\": \"$termination_b_device\",",
            "            \"kind\": \"physical\",",
            "        },",
            "    )",
            "",
            "",
            "class ConnectCableToFrontPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=FrontPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToRearPortForm(ConnectCableToDeviceForm):",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=RearPort.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"device_id\": \"$termination_b_device\"},",
            "    )",
            "",
            "",
            "class ConnectCableToCircuitTerminationForm(ConnectCableExcludeIDMixin, NautobotModelForm):",
            "    termination_b_provider = DynamicModelChoiceField(queryset=Provider.objects.all(), label=\"Provider\", required=False)",
            "    termination_b_region = DynamicModelChoiceField(queryset=Region.objects.all(), label=\"Region\", required=False)",
            "    termination_b_site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        label=\"Site\",",
            "        required=False,",
            "        query_params={\"region_id\": \"$termination_b_region\"},",
            "    )",
            "    termination_b_circuit = DynamicModelChoiceField(",
            "        queryset=Circuit.objects.all(),",
            "        label=\"Circuit\",",
            "        query_params={",
            "            \"provider_id\": \"$termination_b_provider\",",
            "            \"site_id\": \"$termination_b_site\",",
            "        },",
            "    )",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=CircuitTermination.objects.all(),",
            "        label=\"Side\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"circuit_id\": \"$termination_b_circuit\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"termination_b_provider\",",
            "            \"termination_b_region\",",
            "            \"termination_b_site\",",
            "            \"termination_b_circuit\",",
            "            \"termination_b_id\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean_termination_b_id(self):",
            "        # Return the PK rather than the object",
            "        return getattr(self.cleaned_data[\"termination_b_id\"], \"pk\", None)",
            "",
            "",
            "class ConnectCableToPowerFeedForm(ConnectCableExcludeIDMixin, NautobotModelForm):",
            "    termination_b_region = DynamicModelChoiceField(queryset=Region.objects.all(), label=\"Region\", required=False)",
            "    termination_b_site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        label=\"Site\",",
            "        required=False,",
            "        query_params={\"region_id\": \"$termination_b_region\"},",
            "    )",
            "    termination_b_rackgroup = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        label=\"Rack Group\",",
            "        required=False,",
            "        query_params={\"site_id\": \"$termination_b_site\"},",
            "    )",
            "    termination_b_powerpanel = DynamicModelChoiceField(",
            "        queryset=PowerPanel.objects.all(),",
            "        label=\"Power Panel\",",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$termination_b_site\",",
            "            \"rack_group_id\": \"$termination_b_rackgroup\",",
            "        },",
            "    )",
            "    termination_b_id = DynamicModelChoiceField(",
            "        queryset=PowerFeed.objects.all(),",
            "        label=\"Name\",",
            "        disabled_indicator=\"cable\",",
            "        query_params={\"power_panel_id\": \"$termination_b_powerpanel\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"termination_b_rackgroup\",",
            "            \"termination_b_powerpanel\",",
            "            \"termination_b_id\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean_termination_b_id(self):",
            "        # Return the PK rather than the object",
            "        return getattr(self.cleaned_data[\"termination_b_id\"], \"pk\", None)",
            "",
            "",
            "class CableForm(NautobotModelForm):",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"type\": StaticSelect2,",
            "            \"length_unit\": StaticSelect2,",
            "        }",
            "        error_messages = {\"length\": {\"max_value\": \"Maximum length is 32767 (any unit)\"}}",
            "",
            "",
            "class CableCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    # Termination A",
            "    side_a_device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\", help_text=\"Side A device\")",
            "    side_a_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        limit_choices_to=CABLE_TERMINATION_MODELS,",
            "        help_text=\"Side A type\",",
            "    )",
            "    side_a_name = forms.CharField(help_text=\"Side A component name\")",
            "",
            "    # Termination B",
            "    side_b_device = CSVModelChoiceField(queryset=Device.objects.all(), to_field_name=\"name\", help_text=\"Side B device\")",
            "    side_b_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        limit_choices_to=CABLE_TERMINATION_MODELS,",
            "        help_text=\"Side B type\",",
            "    )",
            "    side_b_name = forms.CharField(help_text=\"Side B component name\")",
            "",
            "    # Cable attributes",
            "    type = CSVChoiceField(",
            "        choices=CableTypeChoices,",
            "        required=False,",
            "        help_text=\"Physical medium classification\",",
            "    )",
            "    length_unit = CSVChoiceField(choices=CableLengthUnitChoices, required=False, help_text=\"Length unit\")",
            "",
            "    class Meta:",
            "        model = Cable",
            "        fields = [",
            "            \"side_a_device\",",
            "            \"side_a_type\",",
            "            \"side_a_name\",",
            "            \"side_b_device\",",
            "            \"side_b_type\",",
            "            \"side_b_name\",",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "            \"length_unit\",",
            "        ]",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "            \"status\": \"Connection status\",",
            "        }",
            "",
            "    def _clean_side(self, side):",
            "        \"\"\"",
            "        Derive a Cable's A/B termination objects.",
            "",
            "        :param side: 'a' or 'b'",
            "        \"\"\"",
            "        assert side in \"ab\", f\"Invalid side designation: {side}\"",
            "",
            "        device = self.cleaned_data.get(f\"side_{side}_device\")",
            "        content_type = self.cleaned_data.get(f\"side_{side}_type\")",
            "        name = self.cleaned_data.get(f\"side_{side}_name\")",
            "        if not device or not content_type or not name:",
            "            return None",
            "",
            "        model = content_type.model_class()",
            "        try:",
            "            termination_object = model.objects.get(device=device, name=name)",
            "            if termination_object.cable is not None:",
            "                raise forms.ValidationError(f\"Side {side.upper()}: {device} {termination_object} is already connected\")",
            "        except ObjectDoesNotExist:",
            "            raise forms.ValidationError(f\"{side.upper()} side termination not found: {device} {name}\")",
            "",
            "        setattr(self.instance, f\"termination_{side}\", termination_object)",
            "        return termination_object",
            "",
            "    def clean_side_a_name(self):",
            "        return self._clean_side(\"a\")",
            "",
            "    def clean_side_b_name(self):",
            "        return self._clean_side(\"b\")",
            "",
            "    def clean_length_unit(self):",
            "        # Avoid trying to save as NULL",
            "        length_unit = self.cleaned_data.get(\"length_unit\", None)",
            "        return length_unit if length_unit is not None else \"\"",
            "",
            "    def add_error(self, field, error):",
            "        # Edge Case: some fields in error are not properties in this instance",
            "        #   e.g: termination_a_id not an property in CableCSVForm, This would raise a ValueError Exception",
            "        # Solution: convert those fields to its equivalent in CableCSVForm",
            "        #   e.g: termination_a_id > side_a_name",
            "",
            "        final_error = error",
            "        if hasattr(error, \"error_dict\"):",
            "            error_dict = error.error_dict",
            "            termination_keys = [key for key in error_dict.keys() if key.startswith(\"termination\")]",
            "            for error_field in termination_keys:",
            "                side_value = error_field.split(\"_\")[1]",
            "                error_msg = error_dict.pop(error_field)",
            "                error_dict[f\"side_{side_value}_name\"] = error_msg",
            "",
            "            final_error = ValidationError(error_dict)",
            "        super().add_error(field, final_error)",
            "",
            "",
            "class CableBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Cable.objects.all(), widget=forms.MultipleHiddenInput)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(CableTypeChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    label = forms.CharField(max_length=100, required=False)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())  # RGB color code",
            "    length = forms.IntegerField(min_value=1, required=False)",
            "    length_unit = forms.ChoiceField(",
            "        choices=add_blank_choice(CableLengthUnitChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"type\",",
            "            \"status\",",
            "            \"label\",",
            "            \"color\",",
            "            \"length\",",
            "        ]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate length/unit",
            "        length = self.cleaned_data.get(\"length\")",
            "        length_unit = self.cleaned_data.get(\"length_unit\")",
            "        if length and not length_unit:",
            "            raise forms.ValidationError({\"length_unit\": \"Must specify a unit when setting length\"})",
            "",
            "",
            "class CableFilterForm(BootstrapMixin, StatusModelFilterFormMixin, forms.Form):",
            "    model = Cable",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), to_field_name=\"slug\", required=False)",
            "    rack_id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        label=\"Rack\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    type = forms.MultipleChoiceField(",
            "        choices=add_blank_choice(CableTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())  # RGB color code",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={",
            "            \"site\": \"$site\",",
            "            \"tenant\": \"$tenant\",",
            "            \"rack_id\": \"$rack_id\",",
            "        },",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Connections",
            "#",
            "",
            "",
            "class ConsoleConnectionFilterForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "class PowerConnectionFilterForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "class InterfaceConnectionFilterForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    device_id = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        label=\"Device\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "",
            "",
            "#",
            "# Virtual chassis",
            "#",
            "",
            "",
            "class DeviceSelectionForm(forms.Form):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Device.objects.all(), widget=forms.MultipleHiddenInput())",
            "",
            "",
            "class VirtualChassisCreateForm(NautobotModelForm):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False, initial_params={\"sites\": \"$site\"})",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    members = DynamicModelMultipleChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"rack_id\": \"$rack\",",
            "        },",
            "    )",
            "    initial_position = forms.IntegerField(",
            "        initial=1,",
            "        required=False,",
            "        help_text=\"Position of the first member device. Increases by one for each additional member.\",",
            "    )",
            "",
            "    class Meta:",
            "        model = VirtualChassis",
            "        fields = [",
            "            \"name\",",
            "            \"domain\",",
            "            \"region\",",
            "            \"site\",",
            "            \"rack\",",
            "            \"members\",",
            "            \"initial_position\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def save(self, *args, **kwargs):",
            "        instance = super().save(*args, **kwargs)",
            "",
            "        # Assign VC members",
            "        if instance.present_in_database:",
            "            initial_position = self.cleaned_data.get(\"initial_position\") or 1",
            "            for i, member in enumerate(self.cleaned_data[\"members\"], start=initial_position):",
            "                member.virtual_chassis = instance",
            "                member.vc_position = i",
            "                member.save()",
            "",
            "        return instance",
            "",
            "",
            "class VirtualChassisForm(NautobotModelForm):",
            "    master = forms.ModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        model = VirtualChassis",
            "        fields = [",
            "            \"name\",",
            "            \"domain\",",
            "            \"master\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"master\": SelectWithPK(),",
            "        }",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        self.fields[\"master\"].queryset = Device.objects.filter(virtual_chassis=self.instance)",
            "",
            "",
            "class BaseVCMemberFormSet(forms.BaseModelFormSet):",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Check for duplicate VC position values",
            "        vc_position_list = []",
            "        for form in self.forms:",
            "            vc_position = form.cleaned_data.get(\"vc_position\")",
            "            if vc_position:",
            "                if vc_position in vc_position_list:",
            "                    error_msg = f\"A virtual chassis member already exists in position {vc_position}.\"",
            "                    form.add_error(\"vc_position\", error_msg)",
            "                vc_position_list.append(vc_position)",
            "",
            "",
            "class DeviceVCMembershipForm(forms.ModelForm):",
            "    class Meta:",
            "        model = Device",
            "        fields = [",
            "            \"vc_position\",",
            "            \"vc_priority\",",
            "        ]",
            "        labels = {",
            "            \"vc_position\": \"Position\",",
            "            \"vc_priority\": \"Priority\",",
            "        }",
            "",
            "    def __init__(self, validate_vc_position=False, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Require VC position (only required when the Device is a VirtualChassis member)",
            "        self.fields[\"vc_position\"].required = True",
            "",
            "        # Validation of vc_position is optional. This is only required when adding a new member to an existing",
            "        # VirtualChassis. Otherwise, vc_position validation is handled by BaseVCMemberFormSet.",
            "        self.validate_vc_position = validate_vc_position",
            "",
            "    def clean_vc_position(self):",
            "        vc_position = self.cleaned_data[\"vc_position\"]",
            "",
            "        if self.validate_vc_position:",
            "            conflicting_members = Device.objects.filter(",
            "                virtual_chassis=self.instance.virtual_chassis, vc_position=vc_position",
            "            )",
            "            if conflicting_members.exists():",
            "                raise forms.ValidationError(f\"A virtual chassis member already exists in position {vc_position}.\")",
            "",
            "        return vc_position",
            "",
            "",
            "class VCMemberSelectForm(BootstrapMixin, forms.Form):",
            "    region = DynamicModelChoiceField(queryset=Region.objects.all(), required=False, initial_params={\"sites\": \"$site\"})",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    device = DynamicModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"rack_id\": \"$rack\",",
            "            \"virtual_chassis_id\": \"null\",",
            "        },",
            "    )",
            "",
            "    def clean_device(self):",
            "        device = self.cleaned_data[\"device\"]",
            "        if device.virtual_chassis is not None:",
            "            raise forms.ValidationError(f\"Device {device} is already assigned to a virtual chassis.\")",
            "        return device",
            "",
            "",
            "class VirtualChassisBulkEditForm(TagsBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=VirtualChassis.objects.all(), widget=forms.MultipleHiddenInput())",
            "    domain = forms.CharField(max_length=30, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"domain\"]",
            "",
            "",
            "class VirtualChassisCSVForm(CustomFieldModelCSVForm):",
            "    master = CSVModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Master device\",",
            "    )",
            "",
            "    class Meta:",
            "        model = VirtualChassis",
            "        fields = VirtualChassis.csv_headers",
            "",
            "",
            "class VirtualChassisFilterForm(NautobotFilterForm):",
            "    model = VirtualChassis",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    tenant_group = DynamicModelMultipleChoiceField(",
            "        queryset=TenantGroup.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(",
            "        queryset=Tenant.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"group\": \"$tenant_group\"},",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Power panels",
            "#",
            "",
            "",
            "class PowerPanelForm(LocatableModelFormMixin, NautobotModelForm):",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = PowerPanel",
            "        fields = [",
            "            \"region\",",
            "            \"site\",",
            "            \"location\",",
            "            \"rack_group\",",
            "            \"name\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class PowerPanelCSVForm(LocatableModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    rack_group = CSVModelChoiceField(queryset=RackGroup.objects.all(), required=False, to_field_name=\"name\")",
            "",
            "    class Meta:",
            "        model = PowerPanel",
            "        fields = PowerPanel.csv_headers",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit group queryset by assigned site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "",
            "class PowerPanelBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    LocatableModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerPanel.objects.all(), widget=forms.MultipleHiddenInput)",
            "    rack_group = DynamicModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = PowerPanel",
            "        nullable_fields = [\"location\", \"rack_group\"]",
            "",
            "",
            "class PowerPanelFilterForm(NautobotFilterForm, LocatableModelFilterFormMixin):",
            "    model = PowerPanel",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    rack_group_id = DynamicModelMultipleChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        required=False,",
            "        label=\"Rack group (ID)\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "#",
            "# Power feeds",
            "#",
            "",
            "",
            "class PowerFeedForm(NautobotModelForm):",
            "    region = DynamicModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "        initial_params={\"sites__powerpanel\": \"$power_panel\"},",
            "    )",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        initial_params={\"powerpanel\": \"$power_panel\"},",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    power_panel = DynamicModelChoiceField(queryset=PowerPanel.objects.all(), query_params={\"site_id\": \"$site\"})",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    comments = CommentField()",
            "",
            "    class Meta:",
            "        model = PowerFeed",
            "        fields = [",
            "            \"region\",",
            "            \"site\",",
            "            \"power_panel\",",
            "            \"rack\",",
            "            \"name\",",
            "            \"status\",",
            "            \"type\",",
            "            \"supply\",",
            "            \"phase\",",
            "            \"voltage\",",
            "            \"amperage\",",
            "            \"max_utilization\",",
            "            \"comments\",",
            "            \"tags\",",
            "        ]",
            "        widgets = {",
            "            \"type\": StaticSelect2(),",
            "            \"supply\": StaticSelect2(),",
            "            \"phase\": StaticSelect2(),",
            "        }",
            "",
            "",
            "class PowerFeedCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    site = CSVModelChoiceField(queryset=Site.objects.all(), to_field_name=\"name\", help_text=\"Assigned site\")",
            "    power_panel = CSVModelChoiceField(",
            "        queryset=PowerPanel.objects.all(),",
            "        to_field_name=\"name\",",
            "        help_text=\"Upstream power panel\",",
            "    )",
            "    rack_group = CSVModelChoiceField(",
            "        queryset=RackGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack's group (if any)\",",
            "    )",
            "    rack = CSVModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Rack\",",
            "    )",
            "    type = CSVChoiceField(choices=PowerFeedTypeChoices, required=False, help_text=\"Primary or redundant\")",
            "    supply = CSVChoiceField(choices=PowerFeedSupplyChoices, required=False, help_text=\"Supply type (AC/DC)\")",
            "    phase = CSVChoiceField(choices=PowerFeedPhaseChoices, required=False, help_text=\"Single or three-phase\")",
            "",
            "    class Meta:",
            "        model = PowerFeed",
            "        fields = PowerFeed.csv_headers",
            "",
            "    def __init__(self, data=None, *args, **kwargs):",
            "        super().__init__(data, *args, **kwargs)",
            "",
            "        if data:",
            "            # Limit power_panel queryset by site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"power_panel\"].queryset = self.fields[\"power_panel\"].queryset.filter(**params)",
            "",
            "            # Limit rack_group queryset by site",
            "            params = {f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\")}",
            "            self.fields[\"rack_group\"].queryset = self.fields[\"rack_group\"].queryset.filter(**params)",
            "",
            "            # Limit rack queryset by site and group",
            "            params = {",
            "                f\"site__{self.fields['site'].to_field_name}\": data.get(\"site\"),",
            "                f\"group__{self.fields['rack_group'].to_field_name}\": data.get(\"rack_group\"),",
            "            }",
            "            self.fields[\"rack\"].queryset = self.fields[\"rack\"].queryset.filter(**params)",
            "",
            "",
            "class PowerFeedBulkEditForm(TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=PowerFeed.objects.all(), widget=forms.MultipleHiddenInput)",
            "    power_panel = DynamicModelChoiceField(queryset=PowerPanel.objects.all(), required=False)",
            "    rack = DynamicModelChoiceField(queryset=Rack.objects.all(), required=False)",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedTypeChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    supply = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedSupplyChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    phase = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedPhaseChoices),",
            "        required=False,",
            "        initial=\"\",",
            "        widget=StaticSelect2(),",
            "    )",
            "    voltage = forms.IntegerField(required=False)",
            "    amperage = forms.IntegerField(required=False)",
            "    max_utilization = forms.IntegerField(required=False)",
            "    comments = CommentField(widget=SmallTextarea, label=\"Comments\")",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"rackgroup\",",
            "            \"comments\",",
            "        ]",
            "",
            "",
            "class PowerFeedFilterForm(NautobotFilterForm, StatusModelFilterFormMixin):",
            "    model = PowerFeed",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(",
            "        queryset=Site.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "        query_params={\"region\": \"$region\"},",
            "    )",
            "    power_panel_id = DynamicModelMultipleChoiceField(",
            "        queryset=PowerPanel.objects.all(),",
            "        required=False,",
            "        label=\"Power panel\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    rack_id = DynamicModelMultipleChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        label=\"Rack\",",
            "        null_option=\"None\",",
            "        query_params={\"site\": \"$site\"},",
            "    )",
            "    type = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedTypeChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    supply = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedSupplyChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    phase = forms.ChoiceField(",
            "        choices=add_blank_choice(PowerFeedPhaseChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    voltage = forms.IntegerField(required=False)",
            "    amperage = forms.IntegerField(required=False)",
            "    max_utilization = forms.IntegerField(required=False)",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class DeviceRedundancyGroupForm(NautobotModelForm):",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "    comments = CommentField()",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = DeviceRedundancyGroup",
            "        fields = \"__all__\"",
            "        widgets = {\"failover_strategy\": StaticSelect2()}",
            "",
            "",
            "class DeviceRedundancyGroupFilterForm(NautobotFilterForm, StatusModelFilterFormMixin):",
            "    model = DeviceRedundancyGroup",
            "    field_order = [\"q\", \"name\"]",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    failover_strategy = forms.ChoiceField(",
            "        choices=add_blank_choice(DeviceRedundancyGroupFailoverStrategyChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    secrets_group = DynamicModelMultipleChoiceField(",
            "        queryset=SecretsGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class DeviceRedundancyGroupBulkEditForm(",
            "    TagsBulkEditFormMixin, StatusModelBulkEditFormMixin, NautobotBulkEditForm, LocalContextModelBulkEditForm",
            "):",
            "    pk = forms.ModelMultipleChoiceField(queryset=DeviceRedundancyGroup.objects.all(), widget=forms.MultipleHiddenInput)",
            "    failover_strategy = forms.ChoiceField(",
            "        choices=add_blank_choice(DeviceRedundancyGroupFailoverStrategyChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), to_field_name=\"name\", required=False)",
            "    comments = CommentField(widget=SmallTextarea, label=\"Comments\")",
            "",
            "    class Meta:",
            "        model = DeviceRedundancyGroup",
            "        nullable_fields = [",
            "            \"failover_strategy\",",
            "            \"secrets_group\",",
            "        ]",
            "",
            "",
            "class DeviceRedundancyGroupCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    failover_strategy = CSVChoiceField(",
            "        choices=DeviceRedundancyGroupFailoverStrategyChoices, required=False, help_text=\"Failover Strategy\"",
            "    )",
            "",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Secrets group\",",
            "    )",
            "",
            "    class Meta:",
            "        model = DeviceRedundancyGroup",
            "        fields = DeviceRedundancyGroup.csv_headers",
            "",
            "",
            "#",
            "# Interface Redundancy Groups",
            "#",
            "",
            "",
            "class InterfaceRedundancyGroupForm(NautobotModelForm):",
            "    \"\"\"InterfaceRedundancyGroup create/edit form.\"\"\"",
            "",
            "    protocol_group_id = forms.CharField(",
            "        label=\"Protocol Group ID\",",
            "        help_text=\"Specify a group identifier, such as the VRRP group ID.\",",
            "        required=False,",
            "    )",
            "    virtual_ip = DynamicModelChoiceField(",
            "        queryset=IPAddress.objects.all(),",
            "        required=False,",
            "    )",
            "    secrets_group = DynamicModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        model = InterfaceRedundancyGroup",
            "        fields = [",
            "            \"name\",",
            "            \"description\",",
            "            \"status\",",
            "            \"virtual_ip\",",
            "            \"protocol\",",
            "            \"protocol_group_id\",",
            "            \"secrets_group\",",
            "        ]",
            "",
            "",
            "class InterfaceRedundancyGroupCSVForm(StatusModelCSVFormMixin, CustomFieldModelCSVForm):",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "        to_field_name=\"name\",",
            "        help_text=\"Secrets group\",",
            "    )",
            "    virtual_ip = CSVModelChoiceField(",
            "        queryset=IPAddress.objects.all(),",
            "        required=False,",
            "        to_field_name=\"address\",",
            "        help_text=\"Virtual IP Address\",",
            "    )",
            "",
            "    class Meta:",
            "        model = InterfaceRedundancyGroup",
            "        fields = InterfaceRedundancyGroup.csv_headers",
            "",
            "",
            "class InterfaceRedundancyGroupAssociationForm(BootstrapMixin, NoteModelFormMixin):",
            "    \"\"\"InterfaceRedundancyGroupAssociation create/edit form.\"\"\"",
            "",
            "    region = DynamicModelChoiceField(",
            "        queryset=Region.objects.all(),",
            "        required=False,",
            "    )",
            "    site = DynamicModelChoiceField(",
            "        queryset=Site.objects.all(),",
            "        required=False,",
            "        query_params={\"region_id\": \"$region\"},",
            "    )",
            "    rack = DynamicModelChoiceField(",
            "        queryset=Rack.objects.all(),",
            "        required=False,",
            "        null_option=\"None\",",
            "        query_params={\"site_id\": \"$site\"},",
            "    )",
            "    device = DynamicModelChoiceField(",
            "        queryset=Device.objects.all(),",
            "        required=False,",
            "        query_params={",
            "            \"site_id\": \"$site\",",
            "            \"rack_id\": \"$rack\",",
            "        },",
            "    )",
            "    interface = DynamicModelChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        query_params={\"device_id\": \"$device\"},",
            "        help_text=\"Choose an interface to add to the Redundancy Group.\",",
            "    )",
            "    interface_redundancy_group = DynamicModelChoiceField(",
            "        queryset=InterfaceRedundancyGroup.objects.all(),",
            "        help_text=\"Choose a Interface Redundancy Group.\",",
            "    )",
            "    priority = forms.IntegerField(",
            "        min_value=1,",
            "        help_text=\"Specify the interface priority as an integer.\",",
            "    )",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        model = InterfaceRedundancyGroupAssociation",
            "        fields = [",
            "            \"interface_redundancy_group\",",
            "            \"region\",",
            "            \"site\",",
            "            \"rack\",",
            "            \"device\",",
            "            \"interface\",",
            "            \"priority\",",
            "        ]",
            "",
            "",
            "class InterfaceRedundancyGroupBulkEditForm(",
            "    TagsBulkEditFormMixin,",
            "    StatusModelBulkEditFormMixin,",
            "    NautobotBulkEditForm,",
            "):",
            "    \"\"\"InterfaceRedundancyGroup bulk edit form.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=InterfaceRedundancyGroup.objects.all(),",
            "        widget=forms.MultipleHiddenInput,",
            "    )",
            "    protocol = forms.ChoiceField(choices=InterfaceRedundancyGroupProtocolChoices)",
            "    description = forms.CharField(required=False)",
            "    virtual_ip = DynamicModelChoiceField(queryset=IPAddress.objects.all(), required=False)",
            "    secrets_group = DynamicModelChoiceField(queryset=SecretsGroup.objects.all(), required=False)",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        nullable_fields = [",
            "            \"protocol\",",
            "            \"description\",",
            "            \"virtual_ip\",",
            "            \"secrets_group\",",
            "        ]",
            "",
            "",
            "class InterfaceRedundancyGroupFilterForm(BootstrapMixin, StatusModelFilterFormMixin, forms.ModelForm):",
            "    \"\"\"Filter form to filter searches.\"\"\"",
            "",
            "    model = InterfaceRedundancyGroup",
            "    q = forms.CharField(",
            "        required=False,",
            "        label=\"Search\",",
            "        help_text=\"Search within Name.\",",
            "    )",
            "    name = forms.CharField(required=False, label=\"Name\")",
            "    interfaces = DynamicModelMultipleChoiceField(",
            "        queryset=Interface.objects.all(),",
            "        required=False,",
            "    )",
            "    virtual_ip = DynamicModelMultipleChoiceField(",
            "        queryset=IPAddress.objects.all(),",
            "        required=False,",
            "    )",
            "    secrets_group = DynamicModelMultipleChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        required=False,",
            "    )",
            "    protocol = forms.ChoiceField(",
            "        choices=InterfaceRedundancyGroupProtocolChoices,",
            "        required=False,",
            "    )",
            "",
            "    class Meta:",
            "        \"\"\"Meta attributes.\"\"\"",
            "",
            "        model = InterfaceRedundancyGroup",
            "        # Define the fields above for ordering and widget purposes",
            "        fields = [",
            "            \"q\",",
            "            \"name\",",
            "            \"description\",",
            "            \"interfaces\",",
            "            \"virtual_ip\",",
            "            \"secrets_group\",",
            "            \"protocol\",",
            "        ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "384": [
                "SiteCSVForm",
                "Meta"
            ],
            "450": [
                "LocationTypeCSVForm"
            ],
            "639": [
                "RackRoleCSVForm",
                "Meta"
            ],
            "1771": [
                "DeviceRoleCSVForm",
                "Meta"
            ],
            "3858": [
                "CableCSVForm",
                "Meta"
            ]
        },
        "addLocation": []
    },
    "nautobot/dcim/models/devices.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.core.validators import MaxValueValidator, MinValueValidator"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.db import models"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.db.models import F, ProtectedError, Q"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.functional import cached_property"
            },
            "4": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from django.urls import reverse"
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from django.utils.functional import cached_property"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from nautobot.dcim.choices import DeviceFaceChoices, DeviceRedundancyGroupFailoverStrategyChoices, SubdeviceRoleChoices"
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from nautobot.dcim.models.device_components import ("
            },
            "11": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "                 url = f\"{reverse('dcim:device_list')}?manufacturer_id={self.manufacturer_id}&device_type_id={self.pk}\""
            },
            "12": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "                 raise ValidationError("
            },
            "13": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "                     {"
            },
            "14": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        \"u_height\": mark_safe("
            },
            "15": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            f'Unable to set 0U height: Found <a href=\"{url}\">{racked_instance_count} instances</a> already '"
            },
            "16": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            f\"mounted within racks.\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+                        \"u_height\": format_html("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+                            \"Unable to set 0U height: \""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+                            'Found <a href=\"{}\">{} instances</a> already mounted within racks.',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+                            url,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                            racked_instance_count,"
            },
            "22": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "                         )"
            },
            "23": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "                     }"
            },
            "24": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "                 )"
            }
        },
        "frontPatchFile": [
            "from collections import OrderedDict",
            "",
            "import yaml",
            "from django.contrib.contenttypes.fields import GenericRelation",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.validators import MaxValueValidator, MinValueValidator",
            "from django.db import models",
            "from django.db.models import F, ProtectedError, Q",
            "from django.utils.functional import cached_property",
            "from django.urls import reverse",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.dcim.choices import DeviceFaceChoices, DeviceRedundancyGroupFailoverStrategyChoices, SubdeviceRoleChoices",
            "from nautobot.dcim.models.device_components import (",
            "    ConsolePort,",
            "    ConsoleServerPort,",
            "    DeviceBay,",
            "    FrontPort,",
            "    Interface,",
            "    PowerOutlet,",
            "    PowerPort,",
            "    RearPort,",
            ")",
            "from nautobot.dcim.utils import get_all_network_driver_mappings",
            "from nautobot.extras.models import ConfigContextModel, StatusModel",
            "from nautobot.extras.querysets import ConfigContextModelQuerySet",
            "from nautobot.extras.utils import extras_features",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models.generics import OrganizationalModel, PrimaryModel",
            "from nautobot.utilities.choices import ColorChoices",
            "from nautobot.utilities.config import get_settings_or_config",
            "from nautobot.utilities.fields import ColorField, NaturalOrderingField",
            "",
            "",
            "__all__ = (",
            "    \"Device\",",
            "    \"DeviceRedundancyGroup\",",
            "    \"DeviceRole\",",
            "    \"DeviceType\",",
            "    \"Manufacturer\",",
            "    \"Platform\",",
            "    \"VirtualChassis\",",
            ")",
            "",
            "",
            "#",
            "# Device Types",
            "#",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_validators\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class Manufacturer(OrganizationalModel):",
            "    \"\"\"",
            "    A Manufacturer represents a company which produces hardware devices; for example, Juniper or Dell.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    description = models.CharField(max_length=200, blank=True)",
            "",
            "    csv_headers = [\"name\", \"slug\", \"description\"]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:manufacturer\", args=[self.slug])",
            "",
            "    def to_csv(self):",
            "        return (self.name, self.slug, self.description)",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class DeviceType(PrimaryModel):",
            "    \"\"\"",
            "    A DeviceType represents a particular make (Manufacturer) and model of device. It specifies rack height and depth, as",
            "    well as high-level functional role(s).",
            "",
            "    Each DeviceType can have an arbitrary number of component templates assigned to it, which define console, power, and",
            "    interface objects. For example, a Juniper EX4300-48T DeviceType would have:",
            "",
            "      * 1 ConsolePortTemplate",
            "      * 2 PowerPortTemplates",
            "      * 48 InterfaceTemplates",
            "",
            "    When a new Device of this type is created, the appropriate console, power, and interface objects (as defined by the",
            "    DeviceType) are automatically created as well.",
            "    \"\"\"",
            "",
            "    manufacturer = models.ForeignKey(to=\"dcim.Manufacturer\", on_delete=models.PROTECT, related_name=\"device_types\")",
            "    model = models.CharField(max_length=100)",
            "    # 2.0 TODO: Remove unique=None to make slug globally unique. This would be a breaking change.",
            "    slug = AutoSlugField(populate_from=\"model\", unique=None, db_index=True)",
            "    part_number = models.CharField(max_length=50, blank=True, help_text=\"Discrete part number (optional)\")",
            "    # 2.0 TODO: Profile filtering on this field if it could benefit from an index",
            "    u_height = models.PositiveSmallIntegerField(default=1, verbose_name=\"Height (U)\")",
            "    # todoindex:",
            "    is_full_depth = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"Is full depth\",",
            "        help_text=\"Device consumes both front and rear rack faces\",",
            "    )",
            "    # todoindex:",
            "    subdevice_role = models.CharField(",
            "        max_length=50,",
            "        choices=SubdeviceRoleChoices,",
            "        blank=True,",
            "        verbose_name=\"Parent/child status\",",
            "        help_text=\"Parent devices house child devices in device bays. Leave blank \"",
            "        \"if this device type is neither a parent nor a child.\",",
            "    )",
            "    front_image = models.ImageField(upload_to=\"devicetype-images\", blank=True)",
            "    rear_image = models.ImageField(upload_to=\"devicetype-images\", blank=True)",
            "    comments = models.TextField(blank=True)",
            "",
            "    clone_fields = [",
            "        \"manufacturer\",",
            "        \"u_height\",",
            "        \"is_full_depth\",",
            "        \"subdevice_role\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = [\"manufacturer\", \"model\"]",
            "        unique_together = [",
            "            [\"manufacturer\", \"model\"],",
            "            # 2.0 TODO: Remove unique_together to make slug globally unique. This would be a breaking change.",
            "            [\"manufacturer\", \"slug\"],",
            "        ]",
            "",
            "    def __str__(self):",
            "        return self.model",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Save a copy of u_height for validation in clean()",
            "        self._original_u_height = self.u_height if self.present_in_database else 1",
            "",
            "        # Save references to the original front/rear images",
            "        self._original_front_image = self.front_image if self.present_in_database else None",
            "        self._original_rear_image = self.rear_image if self.present_in_database else None",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:devicetype\", args=[self.pk])",
            "",
            "    def to_yaml(self):",
            "        data = OrderedDict(",
            "            (",
            "                (\"manufacturer\", self.manufacturer.name),",
            "                (\"model\", self.model),",
            "                (\"slug\", self.slug),",
            "                (\"part_number\", self.part_number),",
            "                (\"u_height\", self.u_height),",
            "                (\"is_full_depth\", self.is_full_depth),",
            "                (\"subdevice_role\", self.subdevice_role),",
            "                (\"comments\", self.comments),",
            "            )",
            "        )",
            "",
            "        # Component templates",
            "        if self.consoleporttemplates.exists():",
            "            data[\"console-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                }",
            "                for c in self.consoleporttemplates.all()",
            "            ]",
            "        if self.consoleserverporttemplates.exists():",
            "            data[\"console-server-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                }",
            "                for c in self.consoleserverporttemplates.all()",
            "            ]",
            "        if self.powerporttemplates.exists():",
            "            data[\"power-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"maximum_draw\": c.maximum_draw,",
            "                    \"allocated_draw\": c.allocated_draw,",
            "                }",
            "                for c in self.powerporttemplates.all()",
            "            ]",
            "        if self.poweroutlettemplates.exists():",
            "            data[\"power-outlets\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"power_port\": c.power_port.name if c.power_port else None,",
            "                    \"feed_leg\": c.feed_leg,",
            "                }",
            "                for c in self.poweroutlettemplates.all()",
            "            ]",
            "        if self.interfacetemplates.exists():",
            "            data[\"interfaces\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"mgmt_only\": c.mgmt_only,",
            "                }",
            "                for c in self.interfacetemplates.all()",
            "            ]",
            "        if self.frontporttemplates.exists():",
            "            data[\"front-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"rear_port\": c.rear_port.name,",
            "                    \"rear_port_position\": c.rear_port_position,",
            "                }",
            "                for c in self.frontporttemplates.all()",
            "            ]",
            "        if self.rearporttemplates.exists():",
            "            data[\"rear-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"positions\": c.positions,",
            "                }",
            "                for c in self.rearporttemplates.all()",
            "            ]",
            "        if self.devicebaytemplates.exists():",
            "            data[\"device-bays\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                }",
            "                for c in self.devicebaytemplates.all()",
            "            ]",
            "",
            "        return yaml.dump(dict(data), sort_keys=False, allow_unicode=True)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # If editing an existing DeviceType to have a larger u_height, first validate that *all* instances of it have",
            "        # room to expand within their racks. This validation will impose a very high performance penalty when there are",
            "        # many instances to check, but increasing the u_height of a DeviceType should be a very rare occurrence.",
            "        if self.present_in_database and self.u_height > self._original_u_height:",
            "            for d in Device.objects.filter(device_type=self, position__isnull=False):",
            "                face_required = None if self.is_full_depth else d.face",
            "                u_available = d.rack.get_available_units(",
            "                    u_height=self.u_height, rack_face=face_required, exclude=[d.pk]",
            "                )",
            "                if d.position not in u_available:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"u_height\": f\"Device {d} in rack {d.rack} does not have sufficient space to accommodate a height of {self.u_height}U\"",
            "                        }",
            "                    )",
            "",
            "        # If modifying the height of an existing DeviceType to 0U, check for any instances assigned to a rack position.",
            "        elif self.present_in_database and self._original_u_height > 0 and self.u_height == 0:",
            "            racked_instance_count = Device.objects.filter(device_type=self, position__isnull=False).count()",
            "            if racked_instance_count:",
            "                url = f\"{reverse('dcim:device_list')}?manufacturer_id={self.manufacturer_id}&device_type_id={self.pk}\"",
            "                raise ValidationError(",
            "                    {",
            "                        \"u_height\": mark_safe(",
            "                            f'Unable to set 0U height: Found <a href=\"{url}\">{racked_instance_count} instances</a> already '",
            "                            f\"mounted within racks.\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "        if (self.subdevice_role != SubdeviceRoleChoices.ROLE_PARENT) and self.devicebaytemplates.count():",
            "            raise ValidationError(",
            "                {",
            "                    \"subdevice_role\": \"Must delete all device bay templates associated with this device before \"",
            "                    \"declassifying it as a parent device.\"",
            "                }",
            "            )",
            "",
            "        if self.u_height and self.subdevice_role == SubdeviceRoleChoices.ROLE_CHILD:",
            "            raise ValidationError({\"u_height\": \"Child device types must be 0U.\"})",
            "",
            "    def save(self, *args, **kwargs):",
            "        super().save(*args, **kwargs)",
            "",
            "        # Delete any previously uploaded image files that are no longer in use",
            "        if self._original_front_image and self.front_image != self._original_front_image:",
            "            self._original_front_image.delete(save=False)",
            "        if self._original_rear_image and self.rear_image != self._original_rear_image:",
            "            self._original_rear_image.delete(save=False)",
            "",
            "    def delete(self, *args, **kwargs):",
            "        super().delete(*args, **kwargs)",
            "",
            "        # Delete any uploaded image files",
            "        if self.front_image:",
            "            self.front_image.delete(save=False)",
            "        if self.rear_image:",
            "            self.rear_image.delete(save=False)",
            "",
            "    @property",
            "    def display(self):",
            "        return f\"{self.manufacturer.name} {self.model}\"",
            "",
            "    @property",
            "    def is_parent_device(self):",
            "        return self.subdevice_role == SubdeviceRoleChoices.ROLE_PARENT",
            "",
            "    @property",
            "    def is_child_device(self):",
            "        return self.subdevice_role == SubdeviceRoleChoices.ROLE_CHILD",
            "",
            "",
            "#",
            "# Devices",
            "#",
            "",
            "",
            "@extras_features(\"custom_fields\", \"custom_validators\", \"relationships\", \"graphql\")",
            "class DeviceRole(OrganizationalModel):",
            "    \"\"\"",
            "    Devices are organized by functional role; for example, \"Core Switch\" or \"File Server\". Each DeviceRole is assigned a",
            "    color to be used when displaying rack elevations. The vm_role field determines whether the role is applicable to",
            "    virtual machines as well.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    color = ColorField(default=ColorChoices.COLOR_GREY)",
            "    # todoindex:",
            "    vm_role = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"VM Role\",",
            "        help_text=\"Virtual machines may be assigned to this role\",",
            "    )",
            "    description = models.CharField(",
            "        max_length=200,",
            "        blank=True,",
            "    )",
            "",
            "    csv_headers = [\"name\", \"slug\", \"color\", \"vm_role\", \"description\"]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:devicerole\", args=[self.slug])",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.slug,",
            "            self.color,",
            "            self.vm_role,",
            "            self.description,",
            "        )",
            "",
            "",
            "@extras_features(\"custom_fields\", \"custom_validators\", \"relationships\", \"graphql\")",
            "class Platform(OrganizationalModel):",
            "    \"\"\"",
            "    Platform refers to the software or firmware running on a Device. For example, \"Cisco IOS-XR\" or \"Juniper Junos\".",
            "",
            "    Nautobot uses Platforms to determine how to interact with devices when pulling inventory data or other information",
            "    by specifying a network driver; `netutils` is then used to derive library-specific driver information from this.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    manufacturer = models.ForeignKey(",
            "        to=\"dcim.Manufacturer\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"platforms\",",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"Optionally limit this platform to devices of a certain manufacturer\",",
            "    )",
            "    network_driver = models.CharField(",
            "        max_length=100,",
            "        blank=True,",
            "        help_text=(",
            "            \"The normalized network driver to use when interacting with devices, e.g. cisco_ios, arista_eos, etc.\"",
            "            \" Library-specific driver names will be derived from this setting as appropriate\"",
            "        ),",
            "    )",
            "    napalm_driver = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"NAPALM driver\",",
            "        help_text=\"The name of the NAPALM driver to use when Nautobot internals interact with devices\",",
            "    )",
            "    napalm_args = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"NAPALM arguments\",",
            "        help_text=\"Additional arguments to pass when initiating the NAPALM driver (JSON format)\",",
            "    )",
            "    description = models.CharField(max_length=200, blank=True)",
            "",
            "    @cached_property",
            "    def network_driver_mappings(self):",
            "        \"\"\"Dictionary of library-specific network drivers derived from network_driver by netutils library mapping or NETWORK_DRIVERS setting.\"\"\"",
            "",
            "        network_driver_mappings = get_all_network_driver_mappings()",
            "        return network_driver_mappings.get(self.network_driver, {})",
            "",
            "    csv_headers = [",
            "        \"name\",",
            "        \"slug\",",
            "        \"manufacturer\",",
            "        \"napalm_driver\",",
            "        \"napalm_args\",",
            "        \"network_driver\",",
            "        \"description\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:platform\", args=[self.slug])",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.slug,",
            "            self.manufacturer.name if self.manufacturer else None,",
            "            self.napalm_driver,",
            "            self.napalm_args,",
            "            self.network_driver,",
            "            self.description,",
            "        )",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"dynamic_groups\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"locations\",",
            "    \"relationships\",",
            "    \"statuses\",",
            "    \"webhooks\",",
            ")",
            "class Device(PrimaryModel, ConfigContextModel, StatusModel):",
            "    \"\"\"",
            "    A Device represents a piece of physical hardware. Each Device is assigned a DeviceType,",
            "    DeviceRole, and (optionally) a Platform. Device names are not required, however if one is set it must be unique.",
            "",
            "    Each Device must be assigned to a Site and/or Location, and optionally to a Rack within that.",
            "    Associating a device with a particular rack face or unit is optional (for example, vertically mounted PDUs",
            "    do not consume rack units).",
            "",
            "    When a new Device is created, console/power/interface/device bay components are created along with it as dictated",
            "    by the component templates assigned to its DeviceType. Components can also be added, modified, or deleted after the",
            "    creation of a Device.",
            "    \"\"\"",
            "",
            "    device_type = models.ForeignKey(to=\"dcim.DeviceType\", on_delete=models.PROTECT, related_name=\"instances\")",
            "    device_role = models.ForeignKey(to=\"dcim.DeviceRole\", on_delete=models.PROTECT, related_name=\"devices\")",
            "    tenant = models.ForeignKey(",
            "        to=\"tenancy.Tenant\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    platform = models.ForeignKey(",
            "        to=\"dcim.Platform\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    name = models.CharField(max_length=64, blank=True, null=True, db_index=True)",
            "    _name = NaturalOrderingField(target_field=\"name\", max_length=100, blank=True, null=True, db_index=True)",
            "    serial = models.CharField(max_length=255, blank=True, verbose_name=\"Serial number\", db_index=True)",
            "    asset_tag = models.CharField(",
            "        max_length=100,",
            "        blank=True,",
            "        null=True,",
            "        unique=True,",
            "        verbose_name=\"Asset tag\",",
            "        help_text=\"A unique tag used to identify this device\",",
            "    )",
            "    site = models.ForeignKey(to=\"dcim.Site\", on_delete=models.PROTECT, related_name=\"devices\")",
            "    location = models.ForeignKey(",
            "        to=\"dcim.Location\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    rack = models.ForeignKey(",
            "        to=\"dcim.Rack\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    # 2.0 TODO: Profile filtering on this field if it could benefit from an index",
            "    position = models.PositiveSmallIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        validators=[MinValueValidator(1)],",
            "        verbose_name=\"Position (U)\",",
            "        help_text=\"The lowest-numbered unit occupied by the device\",",
            "    )",
            "    # todoindex:",
            "    face = models.CharField(max_length=50, blank=True, choices=DeviceFaceChoices, verbose_name=\"Rack face\")",
            "    primary_ip4 = models.OneToOneField(",
            "        to=\"ipam.IPAddress\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"primary_ip4_for\",",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Primary IPv4\",",
            "    )",
            "    primary_ip6 = models.OneToOneField(",
            "        to=\"ipam.IPAddress\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"primary_ip6_for\",",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Primary IPv6\",",
            "    )",
            "    cluster = models.ForeignKey(",
            "        to=\"virtualization.Cluster\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    virtual_chassis = models.ForeignKey(",
            "        to=\"VirtualChassis\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"members\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    device_redundancy_group = models.ForeignKey(",
            "        to=\"dcim.DeviceRedundancyGroup\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"members\",",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Device Redundancy Group\",",
            "    )",
            "    device_redundancy_group_priority = models.PositiveSmallIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        validators=[MinValueValidator(1)],",
            "        verbose_name=\"Device Redundancy Group Priority\",",
            "        help_text=\"The priority the device has in the device redundancy group.\",",
            "    )",
            "    # 2.0 TODO: Profile filtering on this field if it could benefit from an index",
            "    vc_position = models.PositiveSmallIntegerField(blank=True, null=True, validators=[MaxValueValidator(255)])",
            "    vc_priority = models.PositiveSmallIntegerField(blank=True, null=True, validators=[MaxValueValidator(255)])",
            "    comments = models.TextField(blank=True)",
            "    images = GenericRelation(to=\"extras.ImageAttachment\")",
            "",
            "    secrets_group = models.ForeignKey(",
            "        to=\"extras.SecretsGroup\",",
            "        on_delete=models.SET_NULL,",
            "        default=None,",
            "        blank=True,",
            "        null=True,",
            "    )",
            "",
            "    objects = ConfigContextModelQuerySet.as_manager()",
            "",
            "    csv_headers = [",
            "        \"name\",",
            "        \"device_role\",",
            "        \"tenant\",",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"platform\",",
            "        \"serial\",",
            "        \"asset_tag\",",
            "        \"status\",",
            "        \"site\",",
            "        \"location\",",
            "        \"rack_group\",",
            "        \"rack_name\",",
            "        \"position\",",
            "        \"face\",",
            "        \"device_redundancy_group\",",
            "        \"device_redundancy_group_priority\",",
            "        \"secrets_group\",",
            "        \"primary_ip\",",
            "        \"comments\",",
            "    ]",
            "    clone_fields = [",
            "        \"device_type\",",
            "        \"device_role\",",
            "        \"tenant\",",
            "        \"platform\",",
            "        \"site\",",
            "        \"location\",",
            "        \"rack\",",
            "        \"status\",",
            "        \"cluster\",",
            "        \"secrets_group\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = (\"_name\",)  # Name may be null",
            "        unique_together = (",
            "            (\"site\", \"tenant\", \"name\"),  # See validate_unique below",
            "            (\"rack\", \"position\", \"face\"),",
            "            (\"virtual_chassis\", \"vc_position\"),",
            "        )",
            "",
            "    def __str__(self):",
            "        return self.display or super().__str__()",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:device\", args=[self.pk])",
            "",
            "    def validate_unique(self, exclude=None):",
            "        # Check for a duplicate name on a device assigned to the same Site and no Tenant. This is necessary",
            "        # because Django does not consider two NULL fields to be equal, and thus will not trigger a violation",
            "        # of the uniqueness constraint without manual intervention.",
            "        if self.name and hasattr(self, \"site\") and self.tenant is None:",
            "            if Device.objects.exclude(pk=self.pk).filter(name=self.name, site=self.site, tenant__isnull=True):",
            "                raise ValidationError({\"name\": \"A device with this name already exists.\"})",
            "",
            "        super().validate_unique(exclude)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate site/rack combination",
            "        if self.rack and self.site != self.rack.site:",
            "            raise ValidationError(",
            "                {",
            "                    \"rack\": f\"Rack {self.rack} does not belong to site {self.site}.\",",
            "                }",
            "            )",
            "",
            "        # Validate location",
            "        if self.location is not None:",
            "            if self.location.base_site != self.site:",
            "                raise ValidationError(",
            "                    {\"location\": f'Location \"{self.location}\" does not belong to site \"{self.site}\".'}",
            "                )",
            "",
            "            if self.rack is not None and self.rack.location is not None and self.rack.location != self.location:",
            "                raise ValidationError({\"rack\": f'Rack \"{self.rack}\" does not belong to location \"{self.location}\".'})",
            "",
            "            # self.cluster is validated somewhat later, see below",
            "",
            "            if ContentType.objects.get_for_model(self) not in self.location.location_type.content_types.all():",
            "                raise ValidationError(",
            "                    {\"location\": f'Devices may not associate to locations of type \"{self.location.location_type}\".'}",
            "                )",
            "",
            "        if self.rack is None:",
            "            if self.face:",
            "                raise ValidationError(",
            "                    {",
            "                        \"face\": \"Cannot select a rack face without assigning a rack.\",",
            "                    }",
            "                )",
            "            if self.position:",
            "                raise ValidationError(",
            "                    {",
            "                        \"position\": \"Cannot select a rack position without assigning a rack.\",",
            "                    }",
            "                )",
            "",
            "        # Validate position/face combination",
            "        if self.position and not self.face:",
            "            raise ValidationError(",
            "                {",
            "                    \"face\": \"Must specify rack face when defining rack position.\",",
            "                }",
            "            )",
            "",
            "        # Prevent 0U devices from being assigned to a specific position",
            "        if self.position and self.device_type.u_height == 0:",
            "            raise ValidationError(",
            "                {\"position\": f\"A U0 device type ({self.device_type}) cannot be assigned to a rack position.\"}",
            "            )",
            "",
            "        if self.rack:",
            "            try:",
            "                # Child devices cannot be assigned to a rack face/unit",
            "                if self.device_type.is_child_device and self.face:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"face\": \"Child device types cannot be assigned to a rack face. This is an attribute of the \"",
            "                            \"parent device.\"",
            "                        }",
            "                    )",
            "                if self.device_type.is_child_device and self.position:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"position\": \"Child device types cannot be assigned to a rack position. This is an attribute of \"",
            "                            \"the parent device.\"",
            "                        }",
            "                    )",
            "",
            "                # Validate rack space",
            "                rack_face = self.face if not self.device_type.is_full_depth else None",
            "                exclude_list = [self.pk] if self.present_in_database else []",
            "                available_units = self.rack.get_available_units(",
            "                    u_height=self.device_type.u_height,",
            "                    rack_face=rack_face,",
            "                    exclude=exclude_list,",
            "                )",
            "                if self.position and self.position not in available_units:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"position\": f\"U{self.position} is already occupied or does not have sufficient space to \"",
            "                            f\"accommodate this device type: {self.device_type} ({self.device_type.u_height}U)\"",
            "                        }",
            "                    )",
            "",
            "            except DeviceType.DoesNotExist:",
            "                pass",
            "",
            "        # Validate primary IP addresses",
            "        vc_interfaces = self.vc_interfaces.all()",
            "        if self.primary_ip4:",
            "            if self.primary_ip4.family != 4:",
            "                raise ValidationError({\"primary_ip4\": f\"{self.primary_ip4} is not an IPv4 address.\"})",
            "            if self.primary_ip4.assigned_object in vc_interfaces:",
            "                pass",
            "            elif (",
            "                self.primary_ip4.nat_inside is not None and self.primary_ip4.nat_inside.assigned_object in vc_interfaces",
            "            ):",
            "                pass",
            "            else:",
            "                raise ValidationError(",
            "                    {\"primary_ip4\": f\"The specified IP address ({self.primary_ip4}) is not assigned to this device.\"}",
            "                )",
            "        if self.primary_ip6:",
            "            if self.primary_ip6.family != 6:",
            "                raise ValidationError({\"primary_ip6\": f\"{self.primary_ip6} is not an IPv6 address.\"})",
            "            if self.primary_ip6.assigned_object in vc_interfaces:",
            "                pass",
            "            elif (",
            "                self.primary_ip6.nat_inside is not None and self.primary_ip6.nat_inside.assigned_object in vc_interfaces",
            "            ):",
            "                pass",
            "            else:",
            "                raise ValidationError(",
            "                    {\"primary_ip6\": f\"The specified IP address ({self.primary_ip6}) is not assigned to this device.\"}",
            "                )",
            "",
            "        # Validate manufacturer/platform",
            "        if hasattr(self, \"device_type\") and self.platform:",
            "            if self.platform.manufacturer and self.platform.manufacturer != self.device_type.manufacturer:",
            "                raise ValidationError(",
            "                    {",
            "                        \"platform\": (",
            "                            f\"The assigned platform is limited to {self.platform.manufacturer} device types, \"",
            "                            f\"but this device's type belongs to {self.device_type.manufacturer}.\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "        # A Device can only be assigned to a Cluster in the same Site (or no Site)",
            "        if self.cluster and self.cluster.site is not None and self.cluster.site != self.site:",
            "            raise ValidationError(",
            "                {\"cluster\": f\"The assigned cluster belongs to a different site ({self.cluster.site})\"}",
            "            )",
            "",
            "        # A Device can only be assigned to a Cluster in the same location or parent location, if any",
            "        if (",
            "            self.cluster is not None",
            "            and self.location is not None",
            "            and self.cluster.location is not None",
            "            and self.cluster.location not in self.location.ancestors(include_self=True)",
            "        ):",
            "            raise ValidationError(",
            "                {\"cluster\": f\"The assigned cluster belongs to a location that does not include {self.location}.\"}",
            "            )",
            "",
            "        # Validate virtual chassis assignment",
            "        if self.virtual_chassis and self.vc_position is None:",
            "            raise ValidationError(",
            "                {\"vc_position\": \"A device assigned to a virtual chassis must have its position defined.\"}",
            "            )",
            "",
            "        # Validate device isn't being removed from a virtual chassis when it is the master",
            "        if not self.virtual_chassis and self.present_in_database:",
            "            existing_virtual_chassis = Device.objects.get(id=self.id).virtual_chassis",
            "            if existing_virtual_chassis and existing_virtual_chassis.master == self:",
            "                raise ValidationError(",
            "                    {",
            "                        \"virtual_chassis\": f\"The master device for the virtual chassis ({ existing_virtual_chassis}) may not be removed\"",
            "                    }",
            "                )",
            "",
            "        if self.device_redundancy_group_priority is not None and self.device_redundancy_group is None:",
            "            raise ValidationError(",
            "                {",
            "                    \"device_redundancy_group_priority\": \"Must assign a redundancy group when defining a redundancy group priority.\"",
            "                }",
            "            )",
            "",
            "    def save(self, *args, **kwargs):",
            "        is_new = not self.present_in_database",
            "",
            "        super().save(*args, **kwargs)",
            "",
            "        # If this is a new Device, instantiate all related components per the DeviceType definition",
            "        if is_new:",
            "            self.create_components()",
            "",
            "        # Update Site and Rack assignment for any child Devices",
            "        devices = Device.objects.filter(parent_bay__device=self)",
            "        for device in devices:",
            "            device.site = self.site",
            "            device.rack = self.rack",
            "            device.save()",
            "",
            "    def create_components(self):",
            "        \"\"\"Create device components from the device type definition.\"\"\"",
            "        # The order of these is significant as",
            "        # - PowerOutlet depends on PowerPort",
            "        # - FrontPort depends on FrontPort",
            "        component_models = [",
            "            (ConsolePort, self.device_type.consoleporttemplates.all()),",
            "            (ConsoleServerPort, self.device_type.consoleserverporttemplates.all()),",
            "            (PowerPort, self.device_type.powerporttemplates.all()),",
            "            (PowerOutlet, self.device_type.poweroutlettemplates.all()),",
            "            (Interface, self.device_type.interfacetemplates.all()),",
            "            (RearPort, self.device_type.rearporttemplates.all()),",
            "            (FrontPort, self.device_type.frontporttemplates.all()),",
            "            (DeviceBay, self.device_type.devicebaytemplates.all()),",
            "        ]",
            "        instantiated_components = []",
            "        for model, templates in component_models:",
            "            model.objects.bulk_create([x.instantiate(self) for x in templates])",
            "        return instantiated_components",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name or \"\",",
            "            self.device_role.name,",
            "            self.tenant.name if self.tenant else None,",
            "            self.device_type.manufacturer.name,",
            "            self.device_type.model,",
            "            self.platform.name if self.platform else None,",
            "            self.serial,",
            "            self.asset_tag,",
            "            self.get_status_display(),",
            "            self.site.name,",
            "            self.location.name if self.location else None,",
            "            self.rack.group.name if self.rack and self.rack.group else None,",
            "            self.rack.name if self.rack else None,",
            "            self.position,",
            "            self.get_face_display(),",
            "            self.device_redundancy_group.slug if self.device_redundancy_group else None,",
            "            self.device_redundancy_group_priority,",
            "            self.secrets_group.name if self.secrets_group else None,",
            "            self.primary_ip if self.primary_ip else None,",
            "            self.comments,",
            "        )",
            "",
            "    @property",
            "    def display(self):",
            "        if self.name:",
            "            return self.name",
            "        elif self.virtual_chassis:",
            "            return f\"{self.virtual_chassis.name}:{self.vc_position} ({self.pk})\"",
            "        elif self.device_type:",
            "            return f\"{self.device_type.manufacturer} {self.device_type.model} ({self.pk})\"",
            "        else:",
            "            return \"\"  # Device has not yet been created",
            "",
            "    @property",
            "    def identifier(self):",
            "        \"\"\"",
            "        Return the device name if set; otherwise return the Device's primary key as {pk}",
            "        \"\"\"",
            "        if self.name is not None:",
            "            return self.name",
            "        return f\"{{{self.pk}}}\"",
            "",
            "    @property",
            "    def primary_ip(self):",
            "        if get_settings_or_config(\"PREFER_IPV4\") and self.primary_ip4:",
            "            return self.primary_ip4",
            "        elif self.primary_ip6:",
            "            return self.primary_ip6",
            "        elif self.primary_ip4:",
            "            return self.primary_ip4",
            "        else:",
            "            return None",
            "",
            "    def get_vc_master(self):",
            "        \"\"\"",
            "        If this Device is a VirtualChassis member, return the VC master. Otherwise, return None.",
            "        \"\"\"",
            "        return self.virtual_chassis.master if self.virtual_chassis else None",
            "",
            "    @property",
            "    def vc_interfaces(self):",
            "        \"\"\"",
            "        Return a QuerySet matching all Interfaces assigned to this Device or, if this Device is a VC master, to another",
            "        Device belonging to the same VirtualChassis.",
            "        \"\"\"",
            "        filter_q = Q(device=self)",
            "        if self.virtual_chassis and self.virtual_chassis.master == self:",
            "            filter_q |= Q(device__virtual_chassis=self.virtual_chassis, mgmt_only=False)",
            "        return Interface.objects.filter(filter_q)",
            "",
            "    @property",
            "    def common_vc_interfaces(self):",
            "        \"\"\"",
            "        Return a QuerySet matching all Interfaces assigned to this Device or,",
            "        if this Device belongs to a VirtualChassis, it returns all interfaces belonging Devices with same VirtualChassis",
            "        \"\"\"",
            "        if self.virtual_chassis:",
            "            return self.virtual_chassis.member_interfaces",
            "        return self.interfaces",
            "",
            "    def get_cables(self, pk_list=False):",
            "        \"\"\"",
            "        Return a QuerySet or PK list matching all Cables connected to a component of this Device.",
            "        \"\"\"",
            "        from .cables import Cable",
            "",
            "        cable_pks = []",
            "        for component_model in [",
            "            ConsolePort,",
            "            ConsoleServerPort,",
            "            PowerPort,",
            "            PowerOutlet,",
            "            Interface,",
            "            FrontPort,",
            "            RearPort,",
            "        ]:",
            "            cable_pks += component_model.objects.filter(device=self, cable__isnull=False).values_list(",
            "                \"cable\", flat=True",
            "            )",
            "        if pk_list:",
            "            return cable_pks",
            "        return Cable.objects.filter(pk__in=cable_pks)",
            "",
            "    def get_children(self):",
            "        \"\"\"",
            "        Return the set of child Devices installed in DeviceBays within this Device.",
            "        \"\"\"",
            "        return Device.objects.filter(parent_bay__device=self.pk)",
            "",
            "",
            "#",
            "# Virtual chassis",
            "#",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class VirtualChassis(PrimaryModel):",
            "    \"\"\"",
            "    A collection of Devices which operate with a shared control plane (e.g. a switch stack).",
            "    \"\"\"",
            "",
            "    master = models.OneToOneField(",
            "        to=\"Device\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"vc_master_for\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    name = models.CharField(max_length=64, db_index=True)",
            "    domain = models.CharField(max_length=30, blank=True)",
            "",
            "    csv_headers = [\"name\", \"domain\", \"master\"]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "        verbose_name_plural = \"virtual chassis\"",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:virtualchassis\", kwargs={\"pk\": self.pk})",
            "",
            "    @property",
            "    def member_interfaces(self):",
            "        \"\"\"Return a list of Interfaces common to all member devices.\"\"\"",
            "        return Interface.objects.filter(pk__in=self.members.values_list(\"interfaces\", flat=True))",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Verify that the selected master device has been assigned to this VirtualChassis. (Skip when creating a new",
            "        # VirtualChassis.)",
            "        if self.present_in_database and self.master and self.master not in self.members.all():",
            "            raise ValidationError(",
            "                {\"master\": f\"The selected master ({self.master}) is not assigned to this virtual chassis.\"}",
            "            )",
            "",
            "    def delete(self, *args, **kwargs):",
            "        # Check for LAG interfaces split across member chassis",
            "        interfaces = Interface.objects.filter(device__in=self.members.all(), lag__isnull=False).exclude(",
            "            lag__device=F(\"device\")",
            "        )",
            "        if interfaces:",
            "            raise ProtectedError(",
            "                f\"Unable to delete virtual chassis {self}. There are member interfaces which form a cross-chassis LAG\",",
            "                interfaces,",
            "            )",
            "",
            "        return super().delete(*args, **kwargs)",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.domain,",
            "            self.master.name if self.master else None,",
            "        )",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"dynamic_groups\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"statuses\",",
            "    \"webhooks\",",
            ")",
            "class DeviceRedundancyGroup(PrimaryModel, StatusModel):",
            "    \"\"\"",
            "    A DeviceRedundancyGroup represents a logical grouping of physical hardware for the purposes of high-availability.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    description = models.CharField(max_length=200, blank=True)",
            "",
            "    failover_strategy = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        choices=DeviceRedundancyGroupFailoverStrategyChoices,",
            "        verbose_name=\"Failover strategy\",",
            "    )",
            "",
            "    comments = models.TextField(blank=True)",
            "",
            "    secrets_group = models.ForeignKey(",
            "        to=\"extras.SecretsGroup\",",
            "        on_delete=models.SET_NULL,",
            "        default=None,",
            "        blank=True,",
            "        null=True,",
            "    )",
            "",
            "    clone_fields = [",
            "        \"failover_strategy\",",
            "        \"status\",",
            "        \"secrets_group\",",
            "    ]",
            "",
            "    csv_headers = [\"name\", \"failover_strategy\", \"status\", \"secrets_group\", \"comments\"]",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)",
            "",
            "    @property",
            "    def members_sorted(self):",
            "        return self.members.order_by(\"device_redundancy_group_priority\")",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:deviceredundancygroup\", args=[self.slug])",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.failover_strategy,",
            "            self.get_status_display(),",
            "            self.secrets_group.name if self.secrets_group else None,",
            "            self.comments,",
            "        )"
        ],
        "afterPatchFile": [
            "from collections import OrderedDict",
            "",
            "import yaml",
            "from django.contrib.contenttypes.fields import GenericRelation",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.validators import MaxValueValidator, MinValueValidator",
            "from django.db import models",
            "from django.db.models import F, ProtectedError, Q",
            "from django.urls import reverse",
            "from django.utils.functional import cached_property",
            "from django.utils.html import format_html",
            "",
            "from nautobot.dcim.choices import DeviceFaceChoices, DeviceRedundancyGroupFailoverStrategyChoices, SubdeviceRoleChoices",
            "from nautobot.dcim.models.device_components import (",
            "    ConsolePort,",
            "    ConsoleServerPort,",
            "    DeviceBay,",
            "    FrontPort,",
            "    Interface,",
            "    PowerOutlet,",
            "    PowerPort,",
            "    RearPort,",
            ")",
            "from nautobot.dcim.utils import get_all_network_driver_mappings",
            "from nautobot.extras.models import ConfigContextModel, StatusModel",
            "from nautobot.extras.querysets import ConfigContextModelQuerySet",
            "from nautobot.extras.utils import extras_features",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models.generics import OrganizationalModel, PrimaryModel",
            "from nautobot.utilities.choices import ColorChoices",
            "from nautobot.utilities.config import get_settings_or_config",
            "from nautobot.utilities.fields import ColorField, NaturalOrderingField",
            "",
            "",
            "__all__ = (",
            "    \"Device\",",
            "    \"DeviceRedundancyGroup\",",
            "    \"DeviceRole\",",
            "    \"DeviceType\",",
            "    \"Manufacturer\",",
            "    \"Platform\",",
            "    \"VirtualChassis\",",
            ")",
            "",
            "",
            "#",
            "# Device Types",
            "#",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_validators\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class Manufacturer(OrganizationalModel):",
            "    \"\"\"",
            "    A Manufacturer represents a company which produces hardware devices; for example, Juniper or Dell.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    description = models.CharField(max_length=200, blank=True)",
            "",
            "    csv_headers = [\"name\", \"slug\", \"description\"]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:manufacturer\", args=[self.slug])",
            "",
            "    def to_csv(self):",
            "        return (self.name, self.slug, self.description)",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class DeviceType(PrimaryModel):",
            "    \"\"\"",
            "    A DeviceType represents a particular make (Manufacturer) and model of device. It specifies rack height and depth, as",
            "    well as high-level functional role(s).",
            "",
            "    Each DeviceType can have an arbitrary number of component templates assigned to it, which define console, power, and",
            "    interface objects. For example, a Juniper EX4300-48T DeviceType would have:",
            "",
            "      * 1 ConsolePortTemplate",
            "      * 2 PowerPortTemplates",
            "      * 48 InterfaceTemplates",
            "",
            "    When a new Device of this type is created, the appropriate console, power, and interface objects (as defined by the",
            "    DeviceType) are automatically created as well.",
            "    \"\"\"",
            "",
            "    manufacturer = models.ForeignKey(to=\"dcim.Manufacturer\", on_delete=models.PROTECT, related_name=\"device_types\")",
            "    model = models.CharField(max_length=100)",
            "    # 2.0 TODO: Remove unique=None to make slug globally unique. This would be a breaking change.",
            "    slug = AutoSlugField(populate_from=\"model\", unique=None, db_index=True)",
            "    part_number = models.CharField(max_length=50, blank=True, help_text=\"Discrete part number (optional)\")",
            "    # 2.0 TODO: Profile filtering on this field if it could benefit from an index",
            "    u_height = models.PositiveSmallIntegerField(default=1, verbose_name=\"Height (U)\")",
            "    # todoindex:",
            "    is_full_depth = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"Is full depth\",",
            "        help_text=\"Device consumes both front and rear rack faces\",",
            "    )",
            "    # todoindex:",
            "    subdevice_role = models.CharField(",
            "        max_length=50,",
            "        choices=SubdeviceRoleChoices,",
            "        blank=True,",
            "        verbose_name=\"Parent/child status\",",
            "        help_text=\"Parent devices house child devices in device bays. Leave blank \"",
            "        \"if this device type is neither a parent nor a child.\",",
            "    )",
            "    front_image = models.ImageField(upload_to=\"devicetype-images\", blank=True)",
            "    rear_image = models.ImageField(upload_to=\"devicetype-images\", blank=True)",
            "    comments = models.TextField(blank=True)",
            "",
            "    clone_fields = [",
            "        \"manufacturer\",",
            "        \"u_height\",",
            "        \"is_full_depth\",",
            "        \"subdevice_role\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = [\"manufacturer\", \"model\"]",
            "        unique_together = [",
            "            [\"manufacturer\", \"model\"],",
            "            # 2.0 TODO: Remove unique_together to make slug globally unique. This would be a breaking change.",
            "            [\"manufacturer\", \"slug\"],",
            "        ]",
            "",
            "    def __str__(self):",
            "        return self.model",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Save a copy of u_height for validation in clean()",
            "        self._original_u_height = self.u_height if self.present_in_database else 1",
            "",
            "        # Save references to the original front/rear images",
            "        self._original_front_image = self.front_image if self.present_in_database else None",
            "        self._original_rear_image = self.rear_image if self.present_in_database else None",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:devicetype\", args=[self.pk])",
            "",
            "    def to_yaml(self):",
            "        data = OrderedDict(",
            "            (",
            "                (\"manufacturer\", self.manufacturer.name),",
            "                (\"model\", self.model),",
            "                (\"slug\", self.slug),",
            "                (\"part_number\", self.part_number),",
            "                (\"u_height\", self.u_height),",
            "                (\"is_full_depth\", self.is_full_depth),",
            "                (\"subdevice_role\", self.subdevice_role),",
            "                (\"comments\", self.comments),",
            "            )",
            "        )",
            "",
            "        # Component templates",
            "        if self.consoleporttemplates.exists():",
            "            data[\"console-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                }",
            "                for c in self.consoleporttemplates.all()",
            "            ]",
            "        if self.consoleserverporttemplates.exists():",
            "            data[\"console-server-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                }",
            "                for c in self.consoleserverporttemplates.all()",
            "            ]",
            "        if self.powerporttemplates.exists():",
            "            data[\"power-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"maximum_draw\": c.maximum_draw,",
            "                    \"allocated_draw\": c.allocated_draw,",
            "                }",
            "                for c in self.powerporttemplates.all()",
            "            ]",
            "        if self.poweroutlettemplates.exists():",
            "            data[\"power-outlets\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"power_port\": c.power_port.name if c.power_port else None,",
            "                    \"feed_leg\": c.feed_leg,",
            "                }",
            "                for c in self.poweroutlettemplates.all()",
            "            ]",
            "        if self.interfacetemplates.exists():",
            "            data[\"interfaces\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"mgmt_only\": c.mgmt_only,",
            "                }",
            "                for c in self.interfacetemplates.all()",
            "            ]",
            "        if self.frontporttemplates.exists():",
            "            data[\"front-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"rear_port\": c.rear_port.name,",
            "                    \"rear_port_position\": c.rear_port_position,",
            "                }",
            "                for c in self.frontporttemplates.all()",
            "            ]",
            "        if self.rearporttemplates.exists():",
            "            data[\"rear-ports\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                    \"type\": c.type,",
            "                    \"positions\": c.positions,",
            "                }",
            "                for c in self.rearporttemplates.all()",
            "            ]",
            "        if self.devicebaytemplates.exists():",
            "            data[\"device-bays\"] = [",
            "                {",
            "                    \"name\": c.name,",
            "                }",
            "                for c in self.devicebaytemplates.all()",
            "            ]",
            "",
            "        return yaml.dump(dict(data), sort_keys=False, allow_unicode=True)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # If editing an existing DeviceType to have a larger u_height, first validate that *all* instances of it have",
            "        # room to expand within their racks. This validation will impose a very high performance penalty when there are",
            "        # many instances to check, but increasing the u_height of a DeviceType should be a very rare occurrence.",
            "        if self.present_in_database and self.u_height > self._original_u_height:",
            "            for d in Device.objects.filter(device_type=self, position__isnull=False):",
            "                face_required = None if self.is_full_depth else d.face",
            "                u_available = d.rack.get_available_units(",
            "                    u_height=self.u_height, rack_face=face_required, exclude=[d.pk]",
            "                )",
            "                if d.position not in u_available:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"u_height\": f\"Device {d} in rack {d.rack} does not have sufficient space to accommodate a height of {self.u_height}U\"",
            "                        }",
            "                    )",
            "",
            "        # If modifying the height of an existing DeviceType to 0U, check for any instances assigned to a rack position.",
            "        elif self.present_in_database and self._original_u_height > 0 and self.u_height == 0:",
            "            racked_instance_count = Device.objects.filter(device_type=self, position__isnull=False).count()",
            "            if racked_instance_count:",
            "                url = f\"{reverse('dcim:device_list')}?manufacturer_id={self.manufacturer_id}&device_type_id={self.pk}\"",
            "                raise ValidationError(",
            "                    {",
            "                        \"u_height\": format_html(",
            "                            \"Unable to set 0U height: \"",
            "                            'Found <a href=\"{}\">{} instances</a> already mounted within racks.',",
            "                            url,",
            "                            racked_instance_count,",
            "                        )",
            "                    }",
            "                )",
            "",
            "        if (self.subdevice_role != SubdeviceRoleChoices.ROLE_PARENT) and self.devicebaytemplates.count():",
            "            raise ValidationError(",
            "                {",
            "                    \"subdevice_role\": \"Must delete all device bay templates associated with this device before \"",
            "                    \"declassifying it as a parent device.\"",
            "                }",
            "            )",
            "",
            "        if self.u_height and self.subdevice_role == SubdeviceRoleChoices.ROLE_CHILD:",
            "            raise ValidationError({\"u_height\": \"Child device types must be 0U.\"})",
            "",
            "    def save(self, *args, **kwargs):",
            "        super().save(*args, **kwargs)",
            "",
            "        # Delete any previously uploaded image files that are no longer in use",
            "        if self._original_front_image and self.front_image != self._original_front_image:",
            "            self._original_front_image.delete(save=False)",
            "        if self._original_rear_image and self.rear_image != self._original_rear_image:",
            "            self._original_rear_image.delete(save=False)",
            "",
            "    def delete(self, *args, **kwargs):",
            "        super().delete(*args, **kwargs)",
            "",
            "        # Delete any uploaded image files",
            "        if self.front_image:",
            "            self.front_image.delete(save=False)",
            "        if self.rear_image:",
            "            self.rear_image.delete(save=False)",
            "",
            "    @property",
            "    def display(self):",
            "        return f\"{self.manufacturer.name} {self.model}\"",
            "",
            "    @property",
            "    def is_parent_device(self):",
            "        return self.subdevice_role == SubdeviceRoleChoices.ROLE_PARENT",
            "",
            "    @property",
            "    def is_child_device(self):",
            "        return self.subdevice_role == SubdeviceRoleChoices.ROLE_CHILD",
            "",
            "",
            "#",
            "# Devices",
            "#",
            "",
            "",
            "@extras_features(\"custom_fields\", \"custom_validators\", \"relationships\", \"graphql\")",
            "class DeviceRole(OrganizationalModel):",
            "    \"\"\"",
            "    Devices are organized by functional role; for example, \"Core Switch\" or \"File Server\". Each DeviceRole is assigned a",
            "    color to be used when displaying rack elevations. The vm_role field determines whether the role is applicable to",
            "    virtual machines as well.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    color = ColorField(default=ColorChoices.COLOR_GREY)",
            "    # todoindex:",
            "    vm_role = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"VM Role\",",
            "        help_text=\"Virtual machines may be assigned to this role\",",
            "    )",
            "    description = models.CharField(",
            "        max_length=200,",
            "        blank=True,",
            "    )",
            "",
            "    csv_headers = [\"name\", \"slug\", \"color\", \"vm_role\", \"description\"]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:devicerole\", args=[self.slug])",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.slug,",
            "            self.color,",
            "            self.vm_role,",
            "            self.description,",
            "        )",
            "",
            "",
            "@extras_features(\"custom_fields\", \"custom_validators\", \"relationships\", \"graphql\")",
            "class Platform(OrganizationalModel):",
            "    \"\"\"",
            "    Platform refers to the software or firmware running on a Device. For example, \"Cisco IOS-XR\" or \"Juniper Junos\".",
            "",
            "    Nautobot uses Platforms to determine how to interact with devices when pulling inventory data or other information",
            "    by specifying a network driver; `netutils` is then used to derive library-specific driver information from this.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    manufacturer = models.ForeignKey(",
            "        to=\"dcim.Manufacturer\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"platforms\",",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"Optionally limit this platform to devices of a certain manufacturer\",",
            "    )",
            "    network_driver = models.CharField(",
            "        max_length=100,",
            "        blank=True,",
            "        help_text=(",
            "            \"The normalized network driver to use when interacting with devices, e.g. cisco_ios, arista_eos, etc.\"",
            "            \" Library-specific driver names will be derived from this setting as appropriate\"",
            "        ),",
            "    )",
            "    napalm_driver = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"NAPALM driver\",",
            "        help_text=\"The name of the NAPALM driver to use when Nautobot internals interact with devices\",",
            "    )",
            "    napalm_args = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"NAPALM arguments\",",
            "        help_text=\"Additional arguments to pass when initiating the NAPALM driver (JSON format)\",",
            "    )",
            "    description = models.CharField(max_length=200, blank=True)",
            "",
            "    @cached_property",
            "    def network_driver_mappings(self):",
            "        \"\"\"Dictionary of library-specific network drivers derived from network_driver by netutils library mapping or NETWORK_DRIVERS setting.\"\"\"",
            "",
            "        network_driver_mappings = get_all_network_driver_mappings()",
            "        return network_driver_mappings.get(self.network_driver, {})",
            "",
            "    csv_headers = [",
            "        \"name\",",
            "        \"slug\",",
            "        \"manufacturer\",",
            "        \"napalm_driver\",",
            "        \"napalm_args\",",
            "        \"network_driver\",",
            "        \"description\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:platform\", args=[self.slug])",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.slug,",
            "            self.manufacturer.name if self.manufacturer else None,",
            "            self.napalm_driver,",
            "            self.napalm_args,",
            "            self.network_driver,",
            "            self.description,",
            "        )",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"dynamic_groups\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"locations\",",
            "    \"relationships\",",
            "    \"statuses\",",
            "    \"webhooks\",",
            ")",
            "class Device(PrimaryModel, ConfigContextModel, StatusModel):",
            "    \"\"\"",
            "    A Device represents a piece of physical hardware. Each Device is assigned a DeviceType,",
            "    DeviceRole, and (optionally) a Platform. Device names are not required, however if one is set it must be unique.",
            "",
            "    Each Device must be assigned to a Site and/or Location, and optionally to a Rack within that.",
            "    Associating a device with a particular rack face or unit is optional (for example, vertically mounted PDUs",
            "    do not consume rack units).",
            "",
            "    When a new Device is created, console/power/interface/device bay components are created along with it as dictated",
            "    by the component templates assigned to its DeviceType. Components can also be added, modified, or deleted after the",
            "    creation of a Device.",
            "    \"\"\"",
            "",
            "    device_type = models.ForeignKey(to=\"dcim.DeviceType\", on_delete=models.PROTECT, related_name=\"instances\")",
            "    device_role = models.ForeignKey(to=\"dcim.DeviceRole\", on_delete=models.PROTECT, related_name=\"devices\")",
            "    tenant = models.ForeignKey(",
            "        to=\"tenancy.Tenant\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    platform = models.ForeignKey(",
            "        to=\"dcim.Platform\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    name = models.CharField(max_length=64, blank=True, null=True, db_index=True)",
            "    _name = NaturalOrderingField(target_field=\"name\", max_length=100, blank=True, null=True, db_index=True)",
            "    serial = models.CharField(max_length=255, blank=True, verbose_name=\"Serial number\", db_index=True)",
            "    asset_tag = models.CharField(",
            "        max_length=100,",
            "        blank=True,",
            "        null=True,",
            "        unique=True,",
            "        verbose_name=\"Asset tag\",",
            "        help_text=\"A unique tag used to identify this device\",",
            "    )",
            "    site = models.ForeignKey(to=\"dcim.Site\", on_delete=models.PROTECT, related_name=\"devices\")",
            "    location = models.ForeignKey(",
            "        to=\"dcim.Location\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    rack = models.ForeignKey(",
            "        to=\"dcim.Rack\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    # 2.0 TODO: Profile filtering on this field if it could benefit from an index",
            "    position = models.PositiveSmallIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        validators=[MinValueValidator(1)],",
            "        verbose_name=\"Position (U)\",",
            "        help_text=\"The lowest-numbered unit occupied by the device\",",
            "    )",
            "    # todoindex:",
            "    face = models.CharField(max_length=50, blank=True, choices=DeviceFaceChoices, verbose_name=\"Rack face\")",
            "    primary_ip4 = models.OneToOneField(",
            "        to=\"ipam.IPAddress\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"primary_ip4_for\",",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Primary IPv4\",",
            "    )",
            "    primary_ip6 = models.OneToOneField(",
            "        to=\"ipam.IPAddress\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"primary_ip6_for\",",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Primary IPv6\",",
            "    )",
            "    cluster = models.ForeignKey(",
            "        to=\"virtualization.Cluster\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"devices\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    virtual_chassis = models.ForeignKey(",
            "        to=\"VirtualChassis\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"members\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    device_redundancy_group = models.ForeignKey(",
            "        to=\"dcim.DeviceRedundancyGroup\",",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"members\",",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Device Redundancy Group\",",
            "    )",
            "    device_redundancy_group_priority = models.PositiveSmallIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        validators=[MinValueValidator(1)],",
            "        verbose_name=\"Device Redundancy Group Priority\",",
            "        help_text=\"The priority the device has in the device redundancy group.\",",
            "    )",
            "    # 2.0 TODO: Profile filtering on this field if it could benefit from an index",
            "    vc_position = models.PositiveSmallIntegerField(blank=True, null=True, validators=[MaxValueValidator(255)])",
            "    vc_priority = models.PositiveSmallIntegerField(blank=True, null=True, validators=[MaxValueValidator(255)])",
            "    comments = models.TextField(blank=True)",
            "    images = GenericRelation(to=\"extras.ImageAttachment\")",
            "",
            "    secrets_group = models.ForeignKey(",
            "        to=\"extras.SecretsGroup\",",
            "        on_delete=models.SET_NULL,",
            "        default=None,",
            "        blank=True,",
            "        null=True,",
            "    )",
            "",
            "    objects = ConfigContextModelQuerySet.as_manager()",
            "",
            "    csv_headers = [",
            "        \"name\",",
            "        \"device_role\",",
            "        \"tenant\",",
            "        \"manufacturer\",",
            "        \"device_type\",",
            "        \"platform\",",
            "        \"serial\",",
            "        \"asset_tag\",",
            "        \"status\",",
            "        \"site\",",
            "        \"location\",",
            "        \"rack_group\",",
            "        \"rack_name\",",
            "        \"position\",",
            "        \"face\",",
            "        \"device_redundancy_group\",",
            "        \"device_redundancy_group_priority\",",
            "        \"secrets_group\",",
            "        \"primary_ip\",",
            "        \"comments\",",
            "    ]",
            "    clone_fields = [",
            "        \"device_type\",",
            "        \"device_role\",",
            "        \"tenant\",",
            "        \"platform\",",
            "        \"site\",",
            "        \"location\",",
            "        \"rack\",",
            "        \"status\",",
            "        \"cluster\",",
            "        \"secrets_group\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = (\"_name\",)  # Name may be null",
            "        unique_together = (",
            "            (\"site\", \"tenant\", \"name\"),  # See validate_unique below",
            "            (\"rack\", \"position\", \"face\"),",
            "            (\"virtual_chassis\", \"vc_position\"),",
            "        )",
            "",
            "    def __str__(self):",
            "        return self.display or super().__str__()",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:device\", args=[self.pk])",
            "",
            "    def validate_unique(self, exclude=None):",
            "        # Check for a duplicate name on a device assigned to the same Site and no Tenant. This is necessary",
            "        # because Django does not consider two NULL fields to be equal, and thus will not trigger a violation",
            "        # of the uniqueness constraint without manual intervention.",
            "        if self.name and hasattr(self, \"site\") and self.tenant is None:",
            "            if Device.objects.exclude(pk=self.pk).filter(name=self.name, site=self.site, tenant__isnull=True):",
            "                raise ValidationError({\"name\": \"A device with this name already exists.\"})",
            "",
            "        super().validate_unique(exclude)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Validate site/rack combination",
            "        if self.rack and self.site != self.rack.site:",
            "            raise ValidationError(",
            "                {",
            "                    \"rack\": f\"Rack {self.rack} does not belong to site {self.site}.\",",
            "                }",
            "            )",
            "",
            "        # Validate location",
            "        if self.location is not None:",
            "            if self.location.base_site != self.site:",
            "                raise ValidationError(",
            "                    {\"location\": f'Location \"{self.location}\" does not belong to site \"{self.site}\".'}",
            "                )",
            "",
            "            if self.rack is not None and self.rack.location is not None and self.rack.location != self.location:",
            "                raise ValidationError({\"rack\": f'Rack \"{self.rack}\" does not belong to location \"{self.location}\".'})",
            "",
            "            # self.cluster is validated somewhat later, see below",
            "",
            "            if ContentType.objects.get_for_model(self) not in self.location.location_type.content_types.all():",
            "                raise ValidationError(",
            "                    {\"location\": f'Devices may not associate to locations of type \"{self.location.location_type}\".'}",
            "                )",
            "",
            "        if self.rack is None:",
            "            if self.face:",
            "                raise ValidationError(",
            "                    {",
            "                        \"face\": \"Cannot select a rack face without assigning a rack.\",",
            "                    }",
            "                )",
            "            if self.position:",
            "                raise ValidationError(",
            "                    {",
            "                        \"position\": \"Cannot select a rack position without assigning a rack.\",",
            "                    }",
            "                )",
            "",
            "        # Validate position/face combination",
            "        if self.position and not self.face:",
            "            raise ValidationError(",
            "                {",
            "                    \"face\": \"Must specify rack face when defining rack position.\",",
            "                }",
            "            )",
            "",
            "        # Prevent 0U devices from being assigned to a specific position",
            "        if self.position and self.device_type.u_height == 0:",
            "            raise ValidationError(",
            "                {\"position\": f\"A U0 device type ({self.device_type}) cannot be assigned to a rack position.\"}",
            "            )",
            "",
            "        if self.rack:",
            "            try:",
            "                # Child devices cannot be assigned to a rack face/unit",
            "                if self.device_type.is_child_device and self.face:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"face\": \"Child device types cannot be assigned to a rack face. This is an attribute of the \"",
            "                            \"parent device.\"",
            "                        }",
            "                    )",
            "                if self.device_type.is_child_device and self.position:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"position\": \"Child device types cannot be assigned to a rack position. This is an attribute of \"",
            "                            \"the parent device.\"",
            "                        }",
            "                    )",
            "",
            "                # Validate rack space",
            "                rack_face = self.face if not self.device_type.is_full_depth else None",
            "                exclude_list = [self.pk] if self.present_in_database else []",
            "                available_units = self.rack.get_available_units(",
            "                    u_height=self.device_type.u_height,",
            "                    rack_face=rack_face,",
            "                    exclude=exclude_list,",
            "                )",
            "                if self.position and self.position not in available_units:",
            "                    raise ValidationError(",
            "                        {",
            "                            \"position\": f\"U{self.position} is already occupied or does not have sufficient space to \"",
            "                            f\"accommodate this device type: {self.device_type} ({self.device_type.u_height}U)\"",
            "                        }",
            "                    )",
            "",
            "            except DeviceType.DoesNotExist:",
            "                pass",
            "",
            "        # Validate primary IP addresses",
            "        vc_interfaces = self.vc_interfaces.all()",
            "        if self.primary_ip4:",
            "            if self.primary_ip4.family != 4:",
            "                raise ValidationError({\"primary_ip4\": f\"{self.primary_ip4} is not an IPv4 address.\"})",
            "            if self.primary_ip4.assigned_object in vc_interfaces:",
            "                pass",
            "            elif (",
            "                self.primary_ip4.nat_inside is not None and self.primary_ip4.nat_inside.assigned_object in vc_interfaces",
            "            ):",
            "                pass",
            "            else:",
            "                raise ValidationError(",
            "                    {\"primary_ip4\": f\"The specified IP address ({self.primary_ip4}) is not assigned to this device.\"}",
            "                )",
            "        if self.primary_ip6:",
            "            if self.primary_ip6.family != 6:",
            "                raise ValidationError({\"primary_ip6\": f\"{self.primary_ip6} is not an IPv6 address.\"})",
            "            if self.primary_ip6.assigned_object in vc_interfaces:",
            "                pass",
            "            elif (",
            "                self.primary_ip6.nat_inside is not None and self.primary_ip6.nat_inside.assigned_object in vc_interfaces",
            "            ):",
            "                pass",
            "            else:",
            "                raise ValidationError(",
            "                    {\"primary_ip6\": f\"The specified IP address ({self.primary_ip6}) is not assigned to this device.\"}",
            "                )",
            "",
            "        # Validate manufacturer/platform",
            "        if hasattr(self, \"device_type\") and self.platform:",
            "            if self.platform.manufacturer and self.platform.manufacturer != self.device_type.manufacturer:",
            "                raise ValidationError(",
            "                    {",
            "                        \"platform\": (",
            "                            f\"The assigned platform is limited to {self.platform.manufacturer} device types, \"",
            "                            f\"but this device's type belongs to {self.device_type.manufacturer}.\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "        # A Device can only be assigned to a Cluster in the same Site (or no Site)",
            "        if self.cluster and self.cluster.site is not None and self.cluster.site != self.site:",
            "            raise ValidationError(",
            "                {\"cluster\": f\"The assigned cluster belongs to a different site ({self.cluster.site})\"}",
            "            )",
            "",
            "        # A Device can only be assigned to a Cluster in the same location or parent location, if any",
            "        if (",
            "            self.cluster is not None",
            "            and self.location is not None",
            "            and self.cluster.location is not None",
            "            and self.cluster.location not in self.location.ancestors(include_self=True)",
            "        ):",
            "            raise ValidationError(",
            "                {\"cluster\": f\"The assigned cluster belongs to a location that does not include {self.location}.\"}",
            "            )",
            "",
            "        # Validate virtual chassis assignment",
            "        if self.virtual_chassis and self.vc_position is None:",
            "            raise ValidationError(",
            "                {\"vc_position\": \"A device assigned to a virtual chassis must have its position defined.\"}",
            "            )",
            "",
            "        # Validate device isn't being removed from a virtual chassis when it is the master",
            "        if not self.virtual_chassis and self.present_in_database:",
            "            existing_virtual_chassis = Device.objects.get(id=self.id).virtual_chassis",
            "            if existing_virtual_chassis and existing_virtual_chassis.master == self:",
            "                raise ValidationError(",
            "                    {",
            "                        \"virtual_chassis\": f\"The master device for the virtual chassis ({ existing_virtual_chassis}) may not be removed\"",
            "                    }",
            "                )",
            "",
            "        if self.device_redundancy_group_priority is not None and self.device_redundancy_group is None:",
            "            raise ValidationError(",
            "                {",
            "                    \"device_redundancy_group_priority\": \"Must assign a redundancy group when defining a redundancy group priority.\"",
            "                }",
            "            )",
            "",
            "    def save(self, *args, **kwargs):",
            "        is_new = not self.present_in_database",
            "",
            "        super().save(*args, **kwargs)",
            "",
            "        # If this is a new Device, instantiate all related components per the DeviceType definition",
            "        if is_new:",
            "            self.create_components()",
            "",
            "        # Update Site and Rack assignment for any child Devices",
            "        devices = Device.objects.filter(parent_bay__device=self)",
            "        for device in devices:",
            "            device.site = self.site",
            "            device.rack = self.rack",
            "            device.save()",
            "",
            "    def create_components(self):",
            "        \"\"\"Create device components from the device type definition.\"\"\"",
            "        # The order of these is significant as",
            "        # - PowerOutlet depends on PowerPort",
            "        # - FrontPort depends on FrontPort",
            "        component_models = [",
            "            (ConsolePort, self.device_type.consoleporttemplates.all()),",
            "            (ConsoleServerPort, self.device_type.consoleserverporttemplates.all()),",
            "            (PowerPort, self.device_type.powerporttemplates.all()),",
            "            (PowerOutlet, self.device_type.poweroutlettemplates.all()),",
            "            (Interface, self.device_type.interfacetemplates.all()),",
            "            (RearPort, self.device_type.rearporttemplates.all()),",
            "            (FrontPort, self.device_type.frontporttemplates.all()),",
            "            (DeviceBay, self.device_type.devicebaytemplates.all()),",
            "        ]",
            "        instantiated_components = []",
            "        for model, templates in component_models:",
            "            model.objects.bulk_create([x.instantiate(self) for x in templates])",
            "        return instantiated_components",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name or \"\",",
            "            self.device_role.name,",
            "            self.tenant.name if self.tenant else None,",
            "            self.device_type.manufacturer.name,",
            "            self.device_type.model,",
            "            self.platform.name if self.platform else None,",
            "            self.serial,",
            "            self.asset_tag,",
            "            self.get_status_display(),",
            "            self.site.name,",
            "            self.location.name if self.location else None,",
            "            self.rack.group.name if self.rack and self.rack.group else None,",
            "            self.rack.name if self.rack else None,",
            "            self.position,",
            "            self.get_face_display(),",
            "            self.device_redundancy_group.slug if self.device_redundancy_group else None,",
            "            self.device_redundancy_group_priority,",
            "            self.secrets_group.name if self.secrets_group else None,",
            "            self.primary_ip if self.primary_ip else None,",
            "            self.comments,",
            "        )",
            "",
            "    @property",
            "    def display(self):",
            "        if self.name:",
            "            return self.name",
            "        elif self.virtual_chassis:",
            "            return f\"{self.virtual_chassis.name}:{self.vc_position} ({self.pk})\"",
            "        elif self.device_type:",
            "            return f\"{self.device_type.manufacturer} {self.device_type.model} ({self.pk})\"",
            "        else:",
            "            return \"\"  # Device has not yet been created",
            "",
            "    @property",
            "    def identifier(self):",
            "        \"\"\"",
            "        Return the device name if set; otherwise return the Device's primary key as {pk}",
            "        \"\"\"",
            "        if self.name is not None:",
            "            return self.name",
            "        return f\"{{{self.pk}}}\"",
            "",
            "    @property",
            "    def primary_ip(self):",
            "        if get_settings_or_config(\"PREFER_IPV4\") and self.primary_ip4:",
            "            return self.primary_ip4",
            "        elif self.primary_ip6:",
            "            return self.primary_ip6",
            "        elif self.primary_ip4:",
            "            return self.primary_ip4",
            "        else:",
            "            return None",
            "",
            "    def get_vc_master(self):",
            "        \"\"\"",
            "        If this Device is a VirtualChassis member, return the VC master. Otherwise, return None.",
            "        \"\"\"",
            "        return self.virtual_chassis.master if self.virtual_chassis else None",
            "",
            "    @property",
            "    def vc_interfaces(self):",
            "        \"\"\"",
            "        Return a QuerySet matching all Interfaces assigned to this Device or, if this Device is a VC master, to another",
            "        Device belonging to the same VirtualChassis.",
            "        \"\"\"",
            "        filter_q = Q(device=self)",
            "        if self.virtual_chassis and self.virtual_chassis.master == self:",
            "            filter_q |= Q(device__virtual_chassis=self.virtual_chassis, mgmt_only=False)",
            "        return Interface.objects.filter(filter_q)",
            "",
            "    @property",
            "    def common_vc_interfaces(self):",
            "        \"\"\"",
            "        Return a QuerySet matching all Interfaces assigned to this Device or,",
            "        if this Device belongs to a VirtualChassis, it returns all interfaces belonging Devices with same VirtualChassis",
            "        \"\"\"",
            "        if self.virtual_chassis:",
            "            return self.virtual_chassis.member_interfaces",
            "        return self.interfaces",
            "",
            "    def get_cables(self, pk_list=False):",
            "        \"\"\"",
            "        Return a QuerySet or PK list matching all Cables connected to a component of this Device.",
            "        \"\"\"",
            "        from .cables import Cable",
            "",
            "        cable_pks = []",
            "        for component_model in [",
            "            ConsolePort,",
            "            ConsoleServerPort,",
            "            PowerPort,",
            "            PowerOutlet,",
            "            Interface,",
            "            FrontPort,",
            "            RearPort,",
            "        ]:",
            "            cable_pks += component_model.objects.filter(device=self, cable__isnull=False).values_list(",
            "                \"cable\", flat=True",
            "            )",
            "        if pk_list:",
            "            return cable_pks",
            "        return Cable.objects.filter(pk__in=cable_pks)",
            "",
            "    def get_children(self):",
            "        \"\"\"",
            "        Return the set of child Devices installed in DeviceBays within this Device.",
            "        \"\"\"",
            "        return Device.objects.filter(parent_bay__device=self.pk)",
            "",
            "",
            "#",
            "# Virtual chassis",
            "#",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"webhooks\",",
            ")",
            "class VirtualChassis(PrimaryModel):",
            "    \"\"\"",
            "    A collection of Devices which operate with a shared control plane (e.g. a switch stack).",
            "    \"\"\"",
            "",
            "    master = models.OneToOneField(",
            "        to=\"Device\",",
            "        on_delete=models.PROTECT,",
            "        related_name=\"vc_master_for\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    name = models.CharField(max_length=64, db_index=True)",
            "    domain = models.CharField(max_length=30, blank=True)",
            "",
            "    csv_headers = [\"name\", \"domain\", \"master\"]",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "        verbose_name_plural = \"virtual chassis\"",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:virtualchassis\", kwargs={\"pk\": self.pk})",
            "",
            "    @property",
            "    def member_interfaces(self):",
            "        \"\"\"Return a list of Interfaces common to all member devices.\"\"\"",
            "        return Interface.objects.filter(pk__in=self.members.values_list(\"interfaces\", flat=True))",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Verify that the selected master device has been assigned to this VirtualChassis. (Skip when creating a new",
            "        # VirtualChassis.)",
            "        if self.present_in_database and self.master and self.master not in self.members.all():",
            "            raise ValidationError(",
            "                {\"master\": f\"The selected master ({self.master}) is not assigned to this virtual chassis.\"}",
            "            )",
            "",
            "    def delete(self, *args, **kwargs):",
            "        # Check for LAG interfaces split across member chassis",
            "        interfaces = Interface.objects.filter(device__in=self.members.all(), lag__isnull=False).exclude(",
            "            lag__device=F(\"device\")",
            "        )",
            "        if interfaces:",
            "            raise ProtectedError(",
            "                f\"Unable to delete virtual chassis {self}. There are member interfaces which form a cross-chassis LAG\",",
            "                interfaces,",
            "            )",
            "",
            "        return super().delete(*args, **kwargs)",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.domain,",
            "            self.master.name if self.master else None,",
            "        )",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_links\",",
            "    \"custom_validators\",",
            "    \"dynamic_groups\",",
            "    \"export_templates\",",
            "    \"graphql\",",
            "    \"relationships\",",
            "    \"statuses\",",
            "    \"webhooks\",",
            ")",
            "class DeviceRedundancyGroup(PrimaryModel, StatusModel):",
            "    \"\"\"",
            "    A DeviceRedundancyGroup represents a logical grouping of physical hardware for the purposes of high-availability.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    description = models.CharField(max_length=200, blank=True)",
            "",
            "    failover_strategy = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        choices=DeviceRedundancyGroupFailoverStrategyChoices,",
            "        verbose_name=\"Failover strategy\",",
            "    )",
            "",
            "    comments = models.TextField(blank=True)",
            "",
            "    secrets_group = models.ForeignKey(",
            "        to=\"extras.SecretsGroup\",",
            "        on_delete=models.SET_NULL,",
            "        default=None,",
            "        blank=True,",
            "        null=True,",
            "    )",
            "",
            "    clone_fields = [",
            "        \"failover_strategy\",",
            "        \"status\",",
            "        \"secrets_group\",",
            "    ]",
            "",
            "    csv_headers = [\"name\", \"failover_strategy\", \"status\", \"secrets_group\", \"comments\"]",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)",
            "",
            "    @property",
            "    def members_sorted(self):",
            "        return self.members.order_by(\"device_redundancy_group_priority\")",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"dcim:deviceredundancygroup\", args=[self.slug])",
            "",
            "    def to_csv(self):",
            "        return (",
            "            self.name,",
            "            self.failover_strategy,",
            "            self.get_status_display(),",
            "            self.secrets_group.name if self.secrets_group else None,",
            "            self.comments,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "13": [],
            "282": [
                "DeviceType",
                "clean"
            ],
            "283": [
                "DeviceType",
                "clean"
            ],
            "284": [
                "DeviceType",
                "clean"
            ]
        },
        "addLocation": []
    },
    "nautobot/dcim/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     modelformset_factory,"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " )"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from django.shortcuts import get_object_or_404, redirect, render"
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from django.views.generic import View"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django_tables2 import RequestConfig"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 2961,
                "afterPatchRowNumber": 2960,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 2962,
                "afterPatchRowNumber": 2961,
                "PatchRowcode": "             if membership_form.is_valid():"
            },
            "11": {
                "beforePatchRowNumber": 2963,
                "afterPatchRowNumber": 2962,
                "PatchRowcode": "                 membership_form.save()"
            },
            "12": {
                "beforePatchRowNumber": 2964,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = f'Added member <a href=\"{device.get_absolute_url()}\">{escape(device)}</a>'"
            },
            "13": {
                "beforePatchRowNumber": 2965,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                messages.success(request, mark_safe(msg))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2963,
                "PatchRowcode": "+                msg = format_html('Added member <a href=\"{}\">{}</a>', device.get_absolute_url(), device)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2964,
                "PatchRowcode": "+                messages.success(request, msg)"
            },
            "16": {
                "beforePatchRowNumber": 2966,
                "afterPatchRowNumber": 2965,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 2967,
                "afterPatchRowNumber": 2966,
                "PatchRowcode": "                 if \"_addanother\" in request.POST:"
            },
            "18": {
                "beforePatchRowNumber": 2968,
                "afterPatchRowNumber": 2967,
                "PatchRowcode": "                     return redirect(request.get_full_path())"
            },
            "19": {
                "beforePatchRowNumber": 3011,
                "afterPatchRowNumber": 3010,
                "PatchRowcode": "         # Protect master device from being removed"
            },
            "20": {
                "beforePatchRowNumber": 3012,
                "afterPatchRowNumber": 3011,
                "PatchRowcode": "         virtual_chassis = VirtualChassis.objects.filter(master=device).first()"
            },
            "21": {
                "beforePatchRowNumber": 3013,
                "afterPatchRowNumber": 3012,
                "PatchRowcode": "         if virtual_chassis is not None:"
            },
            "22": {
                "beforePatchRowNumber": 3014,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = f\"Unable to remove master device {escape(device)} from the virtual chassis.\""
            },
            "23": {
                "beforePatchRowNumber": 3015,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            messages.error(request, mark_safe(msg))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3013,
                "PatchRowcode": "+            msg = format_html(\"Unable to remove master device {} from the virtual chassis.\", device)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3014,
                "PatchRowcode": "+            messages.error(request, msg)"
            },
            "26": {
                "beforePatchRowNumber": 3016,
                "afterPatchRowNumber": 3015,
                "PatchRowcode": "             return redirect(device.get_absolute_url())"
            },
            "27": {
                "beforePatchRowNumber": 3017,
                "afterPatchRowNumber": 3016,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 3018,
                "afterPatchRowNumber": 3017,
                "PatchRowcode": "         if form.is_valid():"
            }
        },
        "frontPatchFile": [
            "import uuid",
            "from collections import OrderedDict, namedtuple",
            "",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.paginator import EmptyPage, PageNotAnInteger",
            "from django.db import transaction",
            "from django.db.models import F, Prefetch",
            "from django.forms import (",
            "    ModelMultipleChoiceField,",
            "    MultipleHiddenInput,",
            "    modelformset_factory,",
            ")",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.utils.html import escape",
            "from django.utils.safestring import mark_safe",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "",
            "from nautobot.circuits.models import Circuit",
            "from nautobot.core.views import generic",
            "from nautobot.core.views.mixins import ObjectDestroyViewMixin, ObjectEditViewMixin",
            "from nautobot.core.views.viewsets import NautobotUIViewSet",
            "from nautobot.dcim.utils import get_network_driver_mapping_tool_names, get_all_network_driver_mappings",
            "from nautobot.extras.views import ObjectChangeLogView, ObjectConfigContextView, ObjectDynamicGroupsView",
            "from nautobot.ipam.models import IPAddress, Prefix, Service, VLAN",
            "from nautobot.ipam.tables import InterfaceIPAddressTable, InterfaceVLANTable",
            "from nautobot.utilities.forms import ConfirmationForm",
            "from nautobot.utilities.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.utils import csv_format, count_related",
            "from nautobot.utilities.views import GetReturnURLMixin, ObjectPermissionRequiredMixin",
            "from nautobot.virtualization.models import VirtualMachine",
            "from . import filters, forms, tables",
            "from .api import serializers",
            "from .choices import DeviceFaceChoices",
            "from .constants import NONCONNECTABLE_IFACE_TYPES",
            "from .models import (",
            "    Cable,",
            "    CablePath,",
            "    ConsolePort,",
            "    ConsolePortTemplate,",
            "    ConsoleServerPort,",
            "    ConsoleServerPortTemplate,",
            "    Device,",
            "    DeviceBay,",
            "    DeviceBayTemplate,",
            "    DeviceRedundancyGroup,",
            "    DeviceRole,",
            "    DeviceType,",
            "    FrontPort,",
            "    FrontPortTemplate,",
            "    Interface,",
            "    InterfaceRedundancyGroup,",
            "    InterfaceRedundancyGroupAssociation,",
            "    InterfaceTemplate,",
            "    InventoryItem,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    PathEndpoint,",
            "    Platform,",
            "    PowerFeed,",
            "    PowerOutlet,",
            "    PowerOutletTemplate,",
            "    PowerPanel,",
            "    PowerPort,",
            "    PowerPortTemplate,",
            "    Rack,",
            "    RackGroup,",
            "    RackReservation,",
            "    RackRole,",
            "    RearPort,",
            "    RearPortTemplate,",
            "    Region,",
            "    Site,",
            "    VirtualChassis,",
            ")",
            "",
            "",
            "class BulkDisconnectView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    An extendable view for disconnection console/power/interface components in bulk.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"dcim/bulk_disconnect.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Create a new Form class from ConfirmationForm",
            "        class _Form(ConfirmationForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput())",
            "",
            "        self.form = _Form",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def post(self, request):",
            "        selected_objects = []",
            "        return_url = self.get_return_url(request)",
            "",
            "        if \"_confirm\" in request.POST:",
            "            form = self.form(request.POST)",
            "",
            "            if form.is_valid():",
            "                with transaction.atomic():",
            "                    count = 0",
            "                    for obj in self.queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                        if obj.cable is None:",
            "                            continue",
            "                        obj.cable.delete()",
            "                        count += 1",
            "",
            "                messages.success(",
            "                    request,",
            "                    f\"Disconnected {count} {self.queryset.model._meta.verbose_name_plural}\",",
            "                )",
            "",
            "                return redirect(return_url)",
            "",
            "        else:",
            "            form = self.form(initial={\"pk\": request.POST.getlist(\"pk\")})",
            "            selected_objects = self.queryset.filter(pk__in=form.initial[\"pk\"])",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"selected_objects\": selected_objects,",
            "                \"return_url\": return_url,",
            "            },",
            "        )",
            "",
            "",
            "class BaseDeviceComponentsBulkRenameView(generic.BulkRenameView):",
            "    def get_selected_objects_parents_name(self, selected_objects):",
            "        selected_object = selected_objects.first()",
            "        if selected_object and selected_object.device:",
            "            return selected_object.device.name",
            "        return None",
            "",
            "",
            "#",
            "# Regions",
            "#",
            "",
            "",
            "class RegionListView(generic.ObjectListView):",
            "    queryset = Region.objects.add_related_count(Region.objects.all(), Site, \"region\", \"site_count\", cumulative=True)",
            "    filterset = filters.RegionFilterSet",
            "    filterset_form = forms.RegionFilterForm",
            "    table = tables.RegionTable",
            "",
            "",
            "class RegionView(generic.ObjectView):",
            "    queryset = Region.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Sites",
            "        sites = (",
            "            Site.objects.restrict(request.user, \"view\")",
            "            .filter(region__in=instance.get_descendants(include_self=True))",
            "            .select_related(\"region\", \"tenant\")",
            "            .prefetch_related(\"parent\")",
            "        )",
            "",
            "        sites_table = tables.SiteTable(sites)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(sites_table)",
            "",
            "        return {",
            "            \"sites_table\": sites_table,",
            "        }",
            "",
            "",
            "class RegionEditView(generic.ObjectEditView):",
            "    queryset = Region.objects.all()",
            "    model_form = forms.RegionForm",
            "",
            "",
            "class RegionDeleteView(generic.ObjectDeleteView):",
            "    queryset = Region.objects.all()",
            "",
            "",
            "class RegionBulkImportView(generic.BulkImportView):",
            "    queryset = Region.objects.all()",
            "    model_form = forms.RegionCSVForm",
            "    table = tables.RegionTable",
            "",
            "",
            "class RegionBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Region.objects.add_related_count(Region.objects.all(), Site, \"region\", \"site_count\", cumulative=True)",
            "    filterset = filters.RegionFilterSet",
            "    table = tables.RegionTable",
            "",
            "",
            "#",
            "# Sites",
            "#",
            "",
            "",
            "class SiteListView(generic.ObjectListView):",
            "    queryset = Site.objects.all()",
            "    filterset = filters.SiteFilterSet",
            "    filterset_form = forms.SiteFilterForm",
            "    table = tables.SiteTable",
            "",
            "",
            "class SiteView(generic.ObjectView):",
            "    queryset = Site.objects.select_related(\"region\", \"tenant__group\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        stats = {",
            "            \"rack_count\": Rack.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"device_count\": Device.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"prefix_count\": Prefix.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"vlan_count\": VLAN.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"circuit_count\": Circuit.objects.restrict(request.user, \"view\").filter(terminations__site=instance).count(),",
            "            \"vm_count\": VirtualMachine.objects.restrict(request.user, \"view\").filter(cluster__site=instance).count(),",
            "        }",
            "        rack_groups = (",
            "            RackGroup.objects.add_related_count(RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True)",
            "            .restrict(request.user, \"view\")",
            "            .filter(site=instance)",
            "        )",
            "        locations = (",
            "            Location.objects.restrict(request.user, \"view\")",
            "            .filter(site=instance)",
            "            .select_related(\"parent\", \"location_type\")",
            "        )",
            "",
            "        locations_table = tables.LocationTable(locations)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(locations_table)",
            "",
            "        return {",
            "            \"locations_table\": locations_table,",
            "            \"stats\": stats,",
            "            \"rack_groups\": rack_groups,",
            "        }",
            "",
            "",
            "class SiteEditView(generic.ObjectEditView):",
            "    queryset = Site.objects.all()",
            "    model_form = forms.SiteForm",
            "    template_name = \"dcim/site_edit.html\"",
            "",
            "",
            "class SiteDeleteView(generic.ObjectDeleteView):",
            "    queryset = Site.objects.all()",
            "",
            "",
            "class SiteBulkImportView(generic.BulkImportView):",
            "    queryset = Site.objects.all()",
            "    model_form = forms.SiteCSVForm",
            "    table = tables.SiteTable",
            "",
            "",
            "class SiteBulkEditView(generic.BulkEditView):",
            "    queryset = Site.objects.select_related(\"region\", \"tenant\")",
            "    filterset = filters.SiteFilterSet",
            "    table = tables.SiteTable",
            "    form = forms.SiteBulkEditForm",
            "",
            "",
            "class SiteBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Site.objects.select_related(\"region\", \"tenant\")",
            "    filterset = filters.SiteFilterSet",
            "    table = tables.SiteTable",
            "",
            "",
            "#",
            "# LocationTypes",
            "#",
            "",
            "",
            "class LocationTypeListView(generic.ObjectListView):",
            "    queryset = LocationType.objects.with_tree_fields()",
            "    filterset = filters.LocationTypeFilterSet",
            "    filterset_form = forms.LocationTypeFilterForm",
            "    table = tables.LocationTypeTable",
            "",
            "",
            "class LocationTypeView(generic.ObjectView):",
            "    queryset = LocationType.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        children = LocationType.objects.restrict(request.user, \"view\").filter(parent=instance).select_related(\"parent\")",
            "        locations = (",
            "            Location.objects.restrict(request.user, \"view\")",
            "            .filter(location_type=instance)",
            "            .select_related(\"parent\", \"location_type\")",
            "        )",
            "",
            "        children_table = tables.LocationTypeTable(children)",
            "        locations_table = tables.LocationTable(locations)",
            "        locations_table.columns.hide(\"location_type\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(children_table)",
            "        RequestConfig(request, paginate).configure(locations_table)",
            "",
            "        return {",
            "            \"children_table\": children_table,",
            "            \"locations_table\": locations_table,",
            "        }",
            "",
            "",
            "class LocationTypeEditView(generic.ObjectEditView):",
            "    queryset = LocationType.objects.all()",
            "    model_form = forms.LocationTypeForm",
            "",
            "",
            "class LocationTypeDeleteView(generic.ObjectDeleteView):",
            "    queryset = LocationType.objects.all()",
            "",
            "",
            "class LocationTypeBulkImportView(generic.BulkImportView):",
            "    queryset = LocationType.objects.all()",
            "    model_form = forms.LocationTypeCSVForm",
            "    table = tables.LocationTypeTable",
            "",
            "",
            "class LocationTypeBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = LocationType.objects.all()",
            "    filterset = filters.LocationTypeFilterSet",
            "    table = tables.LocationTypeTable",
            "",
            "",
            "#",
            "# Locations",
            "#",
            "",
            "",
            "class LocationListView(generic.ObjectListView):",
            "    queryset = Location.objects.select_related(\"location_type\", \"parent\", \"site\", \"tenant\")",
            "    filterset = filters.LocationFilterSet",
            "    filterset_form = forms.LocationFilterForm",
            "    table = tables.LocationTable",
            "",
            "",
            "class LocationView(generic.ObjectView):",
            "    queryset = Location.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_locations = (",
            "            instance.descendants(include_self=True).restrict(request.user, \"view\").values_list(\"pk\", flat=True)",
            "        )",
            "        stats = {",
            "            \"rack_count\": Rack.objects.restrict(request.user, \"view\").filter(location__in=related_locations).count(),",
            "            \"device_count\": Device.objects.restrict(request.user, \"view\")",
            "            .filter(location__in=related_locations)",
            "            .count(),",
            "            \"prefix_count\": Prefix.objects.restrict(request.user, \"view\")",
            "            .filter(location__in=related_locations)",
            "            .count(),",
            "            \"vlan_count\": VLAN.objects.restrict(request.user, \"view\").filter(location__in=related_locations).count(),",
            "            \"circuit_count\": Circuit.objects.restrict(request.user, \"view\")",
            "            .filter(terminations__location__in=related_locations)",
            "            .count(),",
            "            \"vm_count\": VirtualMachine.objects.restrict(request.user, \"view\")",
            "            .filter(cluster__location__in=related_locations)",
            "            .count(),",
            "        }",
            "        rack_groups = (",
            "            RackGroup.objects.add_related_count(RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True)",
            "            .restrict(request.user, \"view\")",
            "            .filter(location__in=related_locations)",
            "        )",
            "        children = (",
            "            Location.objects.restrict(request.user, \"view\")",
            "            .filter(parent=instance)",
            "            .select_related(\"parent\", \"location_type\")",
            "        )",
            "",
            "        children_table = tables.LocationTable(children)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(children_table)",
            "",
            "        return {",
            "            \"children_table\": children_table,",
            "            \"rack_groups\": rack_groups,",
            "            \"stats\": stats,",
            "        }",
            "",
            "",
            "class LocationEditView(generic.ObjectEditView):",
            "    queryset = Location.objects.all()",
            "    model_form = forms.LocationForm",
            "    template_name = \"dcim/location_edit.html\"",
            "",
            "",
            "class LocationDeleteView(generic.ObjectDeleteView):",
            "    queryset = Location.objects.all()",
            "",
            "",
            "class LocationBulkEditView(generic.BulkEditView):",
            "    queryset = Location.objects.select_related(\"location_type\", \"parent\", \"site\", \"tenant\")",
            "    filterset = filters.LocationFilterSet",
            "    table = tables.LocationTable",
            "    form = forms.LocationBulkEditForm",
            "",
            "",
            "class LocationBulkImportView(generic.BulkImportView):",
            "    queryset = Location.objects.all()",
            "    model_form = forms.LocationCSVForm",
            "    table = tables.LocationTable",
            "",
            "",
            "class LocationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Location.objects.select_related(\"location_type\", \"parent\", \"site\", \"tenant\")",
            "    filterset = filters.LocationFilterSet",
            "    table = tables.LocationTable",
            "",
            "",
            "#",
            "# Rack groups",
            "#",
            "",
            "",
            "class RackGroupListView(generic.ObjectListView):",
            "    queryset = RackGroup.objects.add_related_count(",
            "        RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True",
            "    )",
            "    filterset = filters.RackGroupFilterSet",
            "    filterset_form = forms.RackGroupFilterForm",
            "    table = tables.RackGroupTable",
            "",
            "",
            "class RackGroupView(generic.ObjectView):",
            "    queryset = RackGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Racks",
            "        racks = (",
            "            Rack.objects.restrict(request.user, \"view\")",
            "            .filter(group__in=instance.get_descendants(include_self=True))",
            "            .select_related(\"role\", \"site\", \"tenant\")",
            "        )",
            "",
            "        rack_table = tables.RackTable(racks)",
            "        rack_table.columns.hide(\"group\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(rack_table)",
            "",
            "        return {",
            "            \"rack_table\": rack_table,",
            "        }",
            "",
            "",
            "class RackGroupEditView(generic.ObjectEditView):",
            "    queryset = RackGroup.objects.all()",
            "    model_form = forms.RackGroupForm",
            "",
            "",
            "class RackGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = RackGroup.objects.all()",
            "",
            "",
            "class RackGroupBulkImportView(generic.BulkImportView):",
            "    queryset = RackGroup.objects.all()",
            "    model_form = forms.RackGroupCSVForm",
            "    table = tables.RackGroupTable",
            "",
            "",
            "class RackGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RackGroup.objects.add_related_count(",
            "        RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True",
            "    ).select_related(\"site\")",
            "    filterset = filters.RackGroupFilterSet",
            "    table = tables.RackGroupTable",
            "",
            "",
            "#",
            "# Rack roles",
            "#",
            "",
            "",
            "class RackRoleListView(generic.ObjectListView):",
            "    queryset = RackRole.objects.annotate(rack_count=count_related(Rack, \"role\"))",
            "    filterset = filters.RackRoleFilterSet",
            "    table = tables.RackRoleTable",
            "",
            "",
            "class RackRoleView(generic.ObjectView):",
            "    queryset = RackRole.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Racks",
            "        racks = (",
            "            Rack.objects.restrict(request.user, \"view\").filter(role=instance).select_related(\"group\", \"site\", \"tenant\")",
            "        )",
            "",
            "        rack_table = tables.RackTable(racks)",
            "        rack_table.columns.hide(\"role\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(rack_table)",
            "",
            "        return {",
            "            \"rack_table\": rack_table,",
            "        }",
            "",
            "",
            "class RackRoleEditView(generic.ObjectEditView):",
            "    queryset = RackRole.objects.all()",
            "    model_form = forms.RackRoleForm",
            "",
            "",
            "class RackRoleDeleteView(generic.ObjectDeleteView):",
            "    queryset = RackRole.objects.all()",
            "",
            "",
            "class RackRoleBulkImportView(generic.BulkImportView):",
            "    queryset = RackRole.objects.all()",
            "    model_form = forms.RackRoleCSVForm",
            "    table = tables.RackRoleTable",
            "",
            "",
            "class RackRoleBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RackRole.objects.annotate(rack_count=count_related(Rack, \"role\"))",
            "    table = tables.RackRoleTable",
            "",
            "",
            "#",
            "# Racks",
            "#",
            "",
            "",
            "class RackListView(generic.ObjectListView):",
            "    queryset = (",
            "        Rack.objects.select_related(\"site\", \"group\", \"tenant\", \"role\")",
            "        .prefetch_related(\"devices__device_type\")",
            "        .annotate(device_count=count_related(Device, \"rack\"))",
            "    )",
            "    filterset = filters.RackFilterSet",
            "    filterset_form = forms.RackFilterForm",
            "    table = tables.RackDetailTable",
            "",
            "",
            "class RackElevationListView(generic.ObjectListView):",
            "    \"\"\"",
            "    Display a set of rack elevations side-by-side.",
            "    \"\"\"",
            "",
            "    queryset = Rack.objects.select_related(\"role\")",
            "    non_filter_params = (",
            "        *generic.ObjectListView.non_filter_params,",
            "        \"face\",  # render front or rear of racks?",
            "        \"reverse\",  # control of ordering",
            "    )",
            "    filterset = filters.RackFilterSet",
            "    action_buttons = []",
            "    template_name = \"dcim/rack_elevation_list.html\"",
            "",
            "    def extra_context(self):",
            "        racks = self.queryset",
            "        request = self.request",
            "        total_count = racks.count()",
            "",
            "        # Determine ordering",
            "        racks_reverse = bool(request.GET.get(\"reverse\", False))",
            "        if racks_reverse:",
            "            racks = racks.reverse()",
            "",
            "        # Pagination",
            "        per_page = get_paginate_count(request)",
            "        page_number = request.GET.get(\"page\", 1)",
            "        paginator = EnhancedPaginator(racks, per_page)",
            "        try:",
            "            page = paginator.page(page_number)",
            "        except PageNotAnInteger:",
            "            page = paginator.page(1)",
            "        except EmptyPage:",
            "            page = paginator.page(paginator.num_pages)",
            "",
            "        # Determine rack face",
            "        rack_face = request.GET.get(\"face\", DeviceFaceChoices.FACE_FRONT)",
            "        if rack_face not in DeviceFaceChoices.values():",
            "            rack_face = DeviceFaceChoices.FACE_FRONT",
            "",
            "        return {",
            "            \"paginator\": paginator,",
            "            \"page\": page,",
            "            \"total_count\": total_count,",
            "            \"reverse\": racks_reverse,",
            "            \"rack_face\": rack_face,",
            "            \"title\": \"Rack Elevation\",",
            "            \"list_url\": \"dcim:rack_elevation_list\",",
            "        }",
            "",
            "",
            "class RackView(generic.ObjectView):",
            "    queryset = Rack.objects.select_related(\"site__region\", \"tenant__group\", \"group\", \"role\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Get 0U and child devices located within the rack",
            "        nonracked_devices = Device.objects.filter(rack=instance, position__isnull=True).select_related(",
            "            \"device_type__manufacturer\"",
            "        )",
            "",
            "        peer_racks = Rack.objects.restrict(request.user, \"view\").filter(site=instance.site)",
            "",
            "        if instance.group:",
            "            peer_racks = peer_racks.filter(group=instance.group)",
            "        else:",
            "            peer_racks = peer_racks.filter(group__isnull=True)",
            "        next_rack = peer_racks.filter(name__gt=instance.name).order_by(\"name\").first()",
            "        prev_rack = peer_racks.filter(name__lt=instance.name).order_by(\"-name\").first()",
            "",
            "        reservations = RackReservation.objects.restrict(request.user, \"view\").filter(rack=instance)",
            "        power_feeds = (",
            "            PowerFeed.objects.restrict(request.user, \"view\").filter(rack=instance).select_related(\"power_panel\")",
            "        )",
            "",
            "        device_count = Device.objects.restrict(request.user, \"view\").filter(rack=instance).count()",
            "",
            "        return {",
            "            \"device_count\": device_count,",
            "            \"reservations\": reservations,",
            "            \"power_feeds\": power_feeds,",
            "            \"nonracked_devices\": nonracked_devices,",
            "            \"next_rack\": next_rack,",
            "            \"prev_rack\": prev_rack,",
            "        }",
            "",
            "",
            "class RackEditView(generic.ObjectEditView):",
            "    queryset = Rack.objects.all()",
            "    model_form = forms.RackForm",
            "    template_name = \"dcim/rack_edit.html\"",
            "",
            "",
            "class RackDeleteView(generic.ObjectDeleteView):",
            "    queryset = Rack.objects.all()",
            "",
            "",
            "class RackBulkImportView(generic.BulkImportView):",
            "    queryset = Rack.objects.all()",
            "    model_form = forms.RackCSVForm",
            "    table = tables.RackTable",
            "",
            "",
            "class RackBulkEditView(generic.BulkEditView):",
            "    queryset = Rack.objects.select_related(\"site\", \"group\", \"tenant\", \"role\")",
            "    filterset = filters.RackFilterSet",
            "    table = tables.RackTable",
            "    form = forms.RackBulkEditForm",
            "",
            "",
            "class RackBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Rack.objects.select_related(\"site\", \"group\", \"tenant\", \"role\")",
            "    filterset = filters.RackFilterSet",
            "    table = tables.RackTable",
            "",
            "",
            "#",
            "# Rack reservations",
            "#",
            "",
            "",
            "class RackReservationListView(generic.ObjectListView):",
            "    queryset = RackReservation.objects.all()",
            "    filterset = filters.RackReservationFilterSet",
            "    filterset_form = forms.RackReservationFilterForm",
            "    table = tables.RackReservationTable",
            "",
            "",
            "class RackReservationView(generic.ObjectView):",
            "    queryset = RackReservation.objects.select_related(\"rack\")",
            "",
            "",
            "class RackReservationEditView(generic.ObjectEditView):",
            "    queryset = RackReservation.objects.all()",
            "    model_form = forms.RackReservationForm",
            "    template_name = \"dcim/rackreservation_edit.html\"",
            "",
            "    def alter_obj(self, obj, request, args, kwargs):",
            "        if not obj.present_in_database:",
            "            if \"rack\" in request.GET:",
            "                obj.rack = get_object_or_404(Rack, pk=request.GET.get(\"rack\"))",
            "            obj.user = request.user",
            "        return obj",
            "",
            "",
            "class RackReservationDeleteView(generic.ObjectDeleteView):",
            "    queryset = RackReservation.objects.all()",
            "",
            "",
            "class RackReservationImportView(generic.BulkImportView):",
            "    queryset = RackReservation.objects.all()",
            "    model_form = forms.RackReservationCSVForm",
            "    table = tables.RackReservationTable",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        \"\"\"",
            "        Assign the currently authenticated user to the RackReservation.",
            "        \"\"\"",
            "        instance = obj_form.save(commit=False)",
            "        instance.user = request.user",
            "        instance.save()",
            "",
            "        return instance",
            "",
            "",
            "class RackReservationBulkEditView(generic.BulkEditView):",
            "    queryset = RackReservation.objects.select_related(\"rack\", \"user\")",
            "    filterset = filters.RackReservationFilterSet",
            "    table = tables.RackReservationTable",
            "    form = forms.RackReservationBulkEditForm",
            "",
            "",
            "class RackReservationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RackReservation.objects.select_related(\"rack\", \"user\")",
            "    filterset = filters.RackReservationFilterSet",
            "    table = tables.RackReservationTable",
            "",
            "",
            "#",
            "# Manufacturers",
            "#",
            "",
            "",
            "class ManufacturerListView(generic.ObjectListView):",
            "    queryset = Manufacturer.objects.annotate(",
            "        devicetype_count=count_related(DeviceType, \"manufacturer\"),",
            "        inventoryitem_count=count_related(InventoryItem, \"manufacturer\"),",
            "        platform_count=count_related(Platform, \"manufacturer\"),",
            "    )",
            "    filterset = filters.ManufacturerFilterSet",
            "    table = tables.ManufacturerTable",
            "",
            "",
            "class ManufacturerView(generic.ObjectView):",
            "    queryset = Manufacturer.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Devices",
            "        devices = (",
            "            Device.objects.restrict(request.user, \"view\")",
            "            .filter(device_type__manufacturer=instance)",
            "            .select_related(\"status\", \"site\", \"tenant\", \"device_role\", \"rack\", \"device_type\")",
            "        )",
            "",
            "        device_table = tables.DeviceTable(devices)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        return {",
            "            \"device_table\": device_table,",
            "        }",
            "",
            "",
            "class ManufacturerEditView(generic.ObjectEditView):",
            "    queryset = Manufacturer.objects.all()",
            "    model_form = forms.ManufacturerForm",
            "",
            "",
            "class ManufacturerDeleteView(generic.ObjectDeleteView):",
            "    queryset = Manufacturer.objects.all()",
            "",
            "",
            "class ManufacturerBulkImportView(generic.BulkImportView):",
            "    queryset = Manufacturer.objects.all()",
            "    model_form = forms.ManufacturerCSVForm",
            "    table = tables.ManufacturerTable",
            "",
            "",
            "class ManufacturerBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Manufacturer.objects.annotate(devicetype_count=count_related(DeviceType, \"manufacturer\"))",
            "    table = tables.ManufacturerTable",
            "",
            "",
            "#",
            "# Device types",
            "#",
            "",
            "",
            "class DeviceTypeListView(generic.ObjectListView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\").annotate(",
            "        instance_count=count_related(Device, \"device_type\")",
            "    )",
            "    filterset = filters.DeviceTypeFilterSet",
            "    filterset_form = forms.DeviceTypeFilterForm",
            "    table = tables.DeviceTypeTable",
            "",
            "",
            "class DeviceTypeView(generic.ObjectView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        instance_count = Device.objects.restrict(request.user).filter(device_type=instance).count()",
            "",
            "        # Component tables",
            "        consoleport_table = tables.ConsolePortTemplateTable(",
            "            ConsolePortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        consoleserverport_table = tables.ConsoleServerPortTemplateTable(",
            "            ConsoleServerPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        powerport_table = tables.PowerPortTemplateTable(",
            "            PowerPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        poweroutlet_table = tables.PowerOutletTemplateTable(",
            "            PowerOutletTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        interface_table = tables.InterfaceTemplateTable(",
            "            list(InterfaceTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance)),",
            "            orderable=False,",
            "        )",
            "        front_port_table = tables.FrontPortTemplateTable(",
            "            FrontPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        rear_port_table = tables.RearPortTemplateTable(",
            "            RearPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        devicebay_table = tables.DeviceBayTemplateTable(",
            "            DeviceBayTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        if request.user.has_perm(\"dcim.change_devicetype\"):",
            "            consoleport_table.columns.show(\"pk\")",
            "            consoleserverport_table.columns.show(\"pk\")",
            "            powerport_table.columns.show(\"pk\")",
            "            poweroutlet_table.columns.show(\"pk\")",
            "            interface_table.columns.show(\"pk\")",
            "            front_port_table.columns.show(\"pk\")",
            "            rear_port_table.columns.show(\"pk\")",
            "            devicebay_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"instance_count\": instance_count,",
            "            \"consoleport_table\": consoleport_table,",
            "            \"consoleserverport_table\": consoleserverport_table,",
            "            \"powerport_table\": powerport_table,",
            "            \"poweroutlet_table\": poweroutlet_table,",
            "            \"interface_table\": interface_table,",
            "            \"front_port_table\": front_port_table,",
            "            \"rear_port_table\": rear_port_table,",
            "            \"devicebay_table\": devicebay_table,",
            "        }",
            "",
            "",
            "class DeviceTypeEditView(generic.ObjectEditView):",
            "    queryset = DeviceType.objects.all()",
            "    model_form = forms.DeviceTypeForm",
            "    template_name = \"dcim/devicetype_edit.html\"",
            "",
            "",
            "class DeviceTypeDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceType.objects.all()",
            "",
            "",
            "class DeviceTypeImportView(generic.ObjectImportView):",
            "    additional_permissions = [",
            "        \"dcim.add_devicetype\",",
            "        \"dcim.add_consoleporttemplate\",",
            "        \"dcim.add_consoleserverporttemplate\",",
            "        \"dcim.add_powerporttemplate\",",
            "        \"dcim.add_poweroutlettemplate\",",
            "        \"dcim.add_interfacetemplate\",",
            "        \"dcim.add_frontporttemplate\",",
            "        \"dcim.add_rearporttemplate\",",
            "        \"dcim.add_devicebaytemplate\",",
            "    ]",
            "    queryset = DeviceType.objects.all()",
            "    model_form = forms.DeviceTypeImportForm",
            "    related_object_forms = OrderedDict(",
            "        (",
            "            (\"console-ports\", forms.ConsolePortTemplateImportForm),",
            "            (\"console-server-ports\", forms.ConsoleServerPortTemplateImportForm),",
            "            (\"power-ports\", forms.PowerPortTemplateImportForm),",
            "            (\"power-outlets\", forms.PowerOutletTemplateImportForm),",
            "            (\"interfaces\", forms.InterfaceTemplateImportForm),",
            "            (\"rear-ports\", forms.RearPortTemplateImportForm),",
            "            (\"front-ports\", forms.FrontPortTemplateImportForm),",
            "            (\"device-bays\", forms.DeviceBayTemplateImportForm),",
            "        )",
            "    )",
            "",
            "",
            "class DeviceTypeBulkEditView(generic.BulkEditView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\").annotate(",
            "        instance_count=count_related(Device, \"device_type\")",
            "    )",
            "    filterset = filters.DeviceTypeFilterSet",
            "    table = tables.DeviceTypeTable",
            "    form = forms.DeviceTypeBulkEditForm",
            "",
            "",
            "class DeviceTypeBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\").annotate(",
            "        instance_count=count_related(Device, \"device_type\")",
            "    )",
            "    filterset = filters.DeviceTypeFilterSet",
            "    table = tables.DeviceTypeTable",
            "",
            "",
            "#",
            "# Console port templates",
            "#",
            "",
            "",
            "class ConsolePortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    form = forms.ConsolePortTemplateCreateForm",
            "    model_form = forms.ConsolePortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsolePortTemplateEditView(generic.ObjectEditView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    model_form = forms.ConsolePortTemplateForm",
            "",
            "",
            "class ConsolePortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "",
            "",
            "class ConsolePortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    table = tables.ConsolePortTemplateTable",
            "    form = forms.ConsolePortTemplateBulkEditForm",
            "",
            "",
            "class ConsolePortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "",
            "",
            "class ConsolePortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    table = tables.ConsolePortTemplateTable",
            "",
            "",
            "#",
            "# Console server port templates",
            "#",
            "",
            "",
            "class ConsoleServerPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    form = forms.ConsoleServerPortTemplateCreateForm",
            "    model_form = forms.ConsoleServerPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsoleServerPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    model_form = forms.ConsoleServerPortTemplateForm",
            "",
            "",
            "class ConsoleServerPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "",
            "",
            "class ConsoleServerPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    table = tables.ConsoleServerPortTemplateTable",
            "    form = forms.ConsoleServerPortTemplateBulkEditForm",
            "",
            "",
            "class ConsoleServerPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "",
            "",
            "class ConsoleServerPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    table = tables.ConsoleServerPortTemplateTable",
            "",
            "",
            "#",
            "# Power port templates",
            "#",
            "",
            "",
            "class PowerPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    form = forms.PowerPortTemplateCreateForm",
            "    model_form = forms.PowerPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    model_form = forms.PowerPortTemplateForm",
            "",
            "",
            "class PowerPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "",
            "",
            "class PowerPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    table = tables.PowerPortTemplateTable",
            "    form = forms.PowerPortTemplateBulkEditForm",
            "",
            "",
            "class PowerPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "",
            "",
            "class PowerPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    table = tables.PowerPortTemplateTable",
            "",
            "",
            "#",
            "# Power outlet templates",
            "#",
            "",
            "",
            "class PowerOutletTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    form = forms.PowerOutletTemplateCreateForm",
            "    model_form = forms.PowerOutletTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerOutletTemplateEditView(generic.ObjectEditView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    model_form = forms.PowerOutletTemplateForm",
            "",
            "",
            "class PowerOutletTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "",
            "",
            "class PowerOutletTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    table = tables.PowerOutletTemplateTable",
            "    form = forms.PowerOutletTemplateBulkEditForm",
            "",
            "",
            "class PowerOutletTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "",
            "",
            "class PowerOutletTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    table = tables.PowerOutletTemplateTable",
            "",
            "",
            "#",
            "# Interface templates",
            "#",
            "",
            "",
            "class InterfaceTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    form = forms.InterfaceTemplateCreateForm",
            "    model_form = forms.InterfaceTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class InterfaceTemplateEditView(generic.ObjectEditView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    model_form = forms.InterfaceTemplateForm",
            "",
            "",
            "class InterfaceTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "",
            "",
            "class InterfaceTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    table = tables.InterfaceTemplateTable",
            "    form = forms.InterfaceTemplateBulkEditForm",
            "",
            "",
            "class InterfaceTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "",
            "",
            "class InterfaceTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    table = tables.InterfaceTemplateTable",
            "",
            "",
            "#",
            "# Front port templates",
            "#",
            "",
            "",
            "class FrontPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    form = forms.FrontPortTemplateCreateForm",
            "    model_form = forms.FrontPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class FrontPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    model_form = forms.FrontPortTemplateForm",
            "",
            "",
            "class FrontPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "",
            "",
            "class FrontPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    table = tables.FrontPortTemplateTable",
            "    form = forms.FrontPortTemplateBulkEditForm",
            "",
            "",
            "class FrontPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "",
            "",
            "class FrontPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    table = tables.FrontPortTemplateTable",
            "",
            "",
            "#",
            "# Rear port templates",
            "#",
            "",
            "",
            "class RearPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    form = forms.RearPortTemplateCreateForm",
            "    model_form = forms.RearPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class RearPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    model_form = forms.RearPortTemplateForm",
            "",
            "",
            "class RearPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = RearPortTemplate.objects.all()",
            "",
            "",
            "class RearPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    table = tables.RearPortTemplateTable",
            "    form = forms.RearPortTemplateBulkEditForm",
            "",
            "",
            "class RearPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = RearPortTemplate.objects.all()",
            "",
            "",
            "class RearPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    table = tables.RearPortTemplateTable",
            "",
            "",
            "#",
            "# Device bay templates",
            "#",
            "",
            "",
            "class DeviceBayTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    form = forms.DeviceBayTemplateCreateForm",
            "    model_form = forms.DeviceBayTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class DeviceBayTemplateEditView(generic.ObjectEditView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    model_form = forms.DeviceBayTemplateForm",
            "",
            "",
            "class DeviceBayTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "",
            "",
            "class DeviceBayTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    table = tables.DeviceBayTemplateTable",
            "    form = forms.DeviceBayTemplateBulkEditForm",
            "",
            "",
            "class DeviceBayTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "",
            "",
            "class DeviceBayTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    table = tables.DeviceBayTemplateTable",
            "",
            "",
            "#",
            "# Device roles",
            "#",
            "",
            "",
            "class DeviceRoleListView(generic.ObjectListView):",
            "    queryset = DeviceRole.objects.annotate(",
            "        device_count=count_related(Device, \"device_role\"),",
            "        vm_count=count_related(VirtualMachine, \"role\"),",
            "    )",
            "    filterset = filters.DeviceRoleFilterSet",
            "    table = tables.DeviceRoleTable",
            "",
            "",
            "class DeviceRoleView(generic.ObjectView):",
            "    queryset = DeviceRole.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Devices",
            "        devices = (",
            "            Device.objects.restrict(request.user, \"view\")",
            "            .filter(device_role=instance)",
            "            .select_related(\"status\", \"site\", \"tenant\", \"rack\", \"device_type\")",
            "        )",
            "",
            "        device_table = tables.DeviceTable(devices)",
            "        device_table.columns.hide(\"device_role\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        return {",
            "            \"device_table\": device_table,",
            "        }",
            "",
            "",
            "class DeviceRoleEditView(generic.ObjectEditView):",
            "    queryset = DeviceRole.objects.all()",
            "    model_form = forms.DeviceRoleForm",
            "",
            "",
            "class DeviceRoleDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceRole.objects.all()",
            "",
            "",
            "class DeviceRoleBulkImportView(generic.BulkImportView):",
            "    queryset = DeviceRole.objects.all()",
            "    model_form = forms.DeviceRoleCSVForm",
            "    table = tables.DeviceRoleTable",
            "",
            "",
            "class DeviceRoleBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceRole.objects.all()",
            "    table = tables.DeviceRoleTable",
            "",
            "",
            "#",
            "# Platforms",
            "#",
            "",
            "",
            "class PlatformListView(generic.ObjectListView):",
            "    queryset = Platform.objects.annotate(",
            "        device_count=count_related(Device, \"platform\"),",
            "        vm_count=count_related(VirtualMachine, \"platform\"),",
            "    )",
            "    filterset = filters.PlatformFilterSet",
            "    table = tables.PlatformTable",
            "",
            "",
            "class PlatformView(generic.ObjectView):",
            "    queryset = Platform.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Devices",
            "        devices = (",
            "            Device.objects.restrict(request.user, \"view\")",
            "            .filter(platform=instance)",
            "            .select_related(\"status\", \"site\", \"tenant\", \"rack\", \"device_type\", \"device_role\")",
            "        )",
            "",
            "        device_table = tables.DeviceTable(devices)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        return {",
            "            \"device_table\": device_table,",
            "            \"network_driver_tool_names\": get_network_driver_mapping_tool_names(),",
            "        }",
            "",
            "",
            "class PlatformEditView(generic.ObjectEditView):",
            "    queryset = Platform.objects.all()",
            "    model_form = forms.PlatformForm",
            "    template_name = \"dcim/platform_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"network_driver_names\": sorted(get_all_network_driver_mappings().keys())}",
            "",
            "",
            "class PlatformDeleteView(generic.ObjectDeleteView):",
            "    queryset = Platform.objects.all()",
            "",
            "",
            "class PlatformBulkImportView(generic.BulkImportView):",
            "    queryset = Platform.objects.all()",
            "    model_form = forms.PlatformCSVForm",
            "    table = tables.PlatformTable",
            "",
            "",
            "class PlatformBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Platform.objects.all()",
            "    table = tables.PlatformTable",
            "",
            "",
            "#",
            "# Devices",
            "#",
            "",
            "",
            "class DeviceListView(generic.ObjectListView):",
            "    queryset = Device.objects.all()",
            "    filterset = filters.DeviceFilterSet",
            "    filterset_form = forms.DeviceFilterForm",
            "    table = tables.DeviceTable",
            "    template_name = \"dcim/device_list.html\"",
            "",
            "",
            "class DeviceView(generic.ObjectView):",
            "    queryset = Device.objects.select_related(",
            "        \"site__region\",",
            "        \"rack__group\",",
            "        \"tenant__group\",",
            "        \"device_role\",",
            "        \"platform\",",
            "        \"primary_ip4\",",
            "        \"primary_ip6\",",
            "        \"status\",",
            "    )",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # VirtualChassis members",
            "        if instance.virtual_chassis is not None:",
            "            vc_members = (",
            "                Device.objects.restrict(request.user, \"view\")",
            "                .filter(virtual_chassis=instance.virtual_chassis)",
            "                .order_by(\"vc_position\")",
            "            )",
            "        else:",
            "            vc_members = []",
            "",
            "        # Services",
            "        services = Service.objects.restrict(request.user, \"view\").filter(device=instance)",
            "",
            "        return {",
            "            \"services\": services,",
            "            \"vc_members\": vc_members,",
            "            \"active_tab\": \"device\",",
            "        }",
            "",
            "",
            "class DeviceConsolePortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/consoleports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        consoleports = (",
            "            ConsolePort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        consoleport_table = tables.DeviceConsolePortTable(data=consoleports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_consoleport\") or request.user.has_perm(\"dcim.delete_consoleport\"):",
            "            consoleport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"consoleport_table\": consoleport_table,",
            "            \"active_tab\": \"console-ports\",",
            "        }",
            "",
            "",
            "class DeviceConsoleServerPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/consoleserverports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        consoleserverports = (",
            "            ConsoleServerPort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        consoleserverport_table = tables.DeviceConsoleServerPortTable(",
            "            data=consoleserverports, user=request.user, orderable=False",
            "        )",
            "        if request.user.has_perm(\"dcim.change_consoleserverport\") or request.user.has_perm(",
            "            \"dcim.delete_consoleserverport\"",
            "        ):",
            "            consoleserverport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"consoleserverport_table\": consoleserverport_table,",
            "            \"active_tab\": \"console-server-ports\",",
            "        }",
            "",
            "",
            "class DevicePowerPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/powerports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        powerports = (",
            "            PowerPort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        powerport_table = tables.DevicePowerPortTable(data=powerports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_powerport\") or request.user.has_perm(\"dcim.delete_powerport\"):",
            "            powerport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"powerport_table\": powerport_table,",
            "            \"active_tab\": \"power-ports\",",
            "        }",
            "",
            "",
            "class DevicePowerOutletsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/poweroutlets.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        poweroutlets = (",
            "            PowerOutlet.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\", \"power_port\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        poweroutlet_table = tables.DevicePowerOutletTable(data=poweroutlets, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_poweroutlet\") or request.user.has_perm(\"dcim.delete_poweroutlet\"):",
            "            poweroutlet_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"poweroutlet_table\": poweroutlet_table,",
            "            \"active_tab\": \"power-outlets\",",
            "        }",
            "",
            "",
            "class DeviceInterfacesView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/interfaces.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        interfaces = (",
            "            instance.vc_interfaces.restrict(request.user, \"view\")",
            "            .prefetch_related(",
            "                Prefetch(\"ip_addresses\", queryset=IPAddress.objects.restrict(request.user)),",
            "                Prefetch(\"member_interfaces\", queryset=Interface.objects.restrict(request.user)),",
            "                \"_path__destination\",",
            "                \"tags\",",
            "            )",
            "            .select_related(\"lag\", \"cable\")",
            "        )",
            "        interface_table = tables.DeviceInterfaceTable(data=interfaces, user=request.user, orderable=False)",
            "        if VirtualChassis.objects.filter(master=instance).exists():",
            "            interface_table.columns.show(\"device\")",
            "        if request.user.has_perm(\"dcim.change_interface\") or request.user.has_perm(\"dcim.delete_interface\"):",
            "            interface_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"interface_table\": interface_table,",
            "            \"active_tab\": \"interfaces\",",
            "        }",
            "",
            "",
            "class DeviceFrontPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/frontports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        frontports = (",
            "            FrontPort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\", \"rear_port\")",
            "        )",
            "        frontport_table = tables.DeviceFrontPortTable(data=frontports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_frontport\") or request.user.has_perm(\"dcim.delete_frontport\"):",
            "            frontport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"frontport_table\": frontport_table,",
            "            \"active_tab\": \"front-ports\",",
            "        }",
            "",
            "",
            "class DeviceRearPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/rearports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        rearports = RearPort.objects.restrict(request.user, \"view\").filter(device=instance).select_related(\"cable\")",
            "        rearport_table = tables.DeviceRearPortTable(data=rearports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_rearport\") or request.user.has_perm(\"dcim.delete_rearport\"):",
            "            rearport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"rearport_table\": rearport_table,",
            "            \"active_tab\": \"rear-ports\",",
            "        }",
            "",
            "",
            "class DeviceDeviceBaysView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/devicebays.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        devicebays = (",
            "            DeviceBay.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(",
            "                \"installed_device__device_type__manufacturer\",",
            "            )",
            "        )",
            "        devicebay_table = tables.DeviceDeviceBayTable(data=devicebays, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_devicebay\") or request.user.has_perm(\"dcim.delete_devicebay\"):",
            "            devicebay_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"devicebay_table\": devicebay_table,",
            "            \"active_tab\": \"device-bays\",",
            "        }",
            "",
            "",
            "class DeviceInventoryView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/inventory.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        inventoryitems = (",
            "            InventoryItem.objects.restrict(request.user, \"view\").filter(device=instance).select_related(\"manufacturer\")",
            "        )",
            "        inventoryitem_table = tables.DeviceInventoryItemTable(data=inventoryitems, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_inventoryitem\") or request.user.has_perm(\"dcim.delete_inventoryitem\"):",
            "            inventoryitem_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"inventoryitem_table\": inventoryitem_table,",
            "            \"active_tab\": \"inventory\",",
            "        }",
            "",
            "",
            "class DeviceStatusView(generic.ObjectView):",
            "    additional_permissions = [\"dcim.napalm_read_device\"]",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/status.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"active_tab\": \"status\",",
            "        }",
            "",
            "",
            "class DeviceLLDPNeighborsView(generic.ObjectView):",
            "    additional_permissions = [\"dcim.napalm_read_device\"]",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/lldp_neighbors.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        interfaces = (",
            "            instance.vc_interfaces.restrict(request.user, \"view\")",
            "            .prefetch_related(\"_path__destination\")",
            "            .exclude(type__in=NONCONNECTABLE_IFACE_TYPES)",
            "        )",
            "",
            "        return {",
            "            \"interfaces\": interfaces,",
            "            \"active_tab\": \"lldp-neighbors\",",
            "        }",
            "",
            "",
            "class DeviceConfigView(generic.ObjectView):",
            "    additional_permissions = [\"dcim.napalm_read_device\"]",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/config.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"active_tab\": \"config\",",
            "        }",
            "",
            "",
            "class DeviceConfigContextView(ObjectConfigContextView):",
            "    queryset = Device.objects.annotate_config_context_data()",
            "    base_template = \"dcim/device/base.html\"",
            "",
            "",
            "class DeviceChangeLogView(ObjectChangeLogView):",
            "    base_template = \"dcim/device/base.html\"",
            "",
            "",
            "class DeviceDynamicGroupsView(ObjectDynamicGroupsView):",
            "    base_template = \"dcim/device/base.html\"",
            "",
            "",
            "class DeviceEditView(generic.ObjectEditView):",
            "    queryset = Device.objects.all()",
            "    model_form = forms.DeviceForm",
            "    template_name = \"dcim/device_edit.html\"",
            "",
            "",
            "class DeviceDeleteView(generic.ObjectDeleteView):",
            "    queryset = Device.objects.all()",
            "",
            "",
            "class DeviceBulkImportView(generic.BulkImportView):",
            "    queryset = Device.objects.all()",
            "    model_form = forms.DeviceCSVForm",
            "    table = tables.DeviceImportTable",
            "    template_name = \"dcim/device_import.html\"",
            "",
            "",
            "class ChildDeviceBulkImportView(generic.BulkImportView):",
            "    queryset = Device.objects.all()",
            "    model_form = forms.ChildDeviceCSVForm",
            "    table = tables.DeviceImportTable",
            "    template_name = \"dcim/device_import_child.html\"",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        obj = obj_form.save()",
            "",
            "        # Save the reverse relation to the parent device bay",
            "        device_bay = obj.parent_bay",
            "        device_bay.installed_device = obj",
            "        device_bay.save()",
            "",
            "        return obj",
            "",
            "",
            "class DeviceBulkEditView(generic.BulkEditView):",
            "    queryset = Device.objects.select_related(",
            "        \"tenant\", \"site\", \"rack\", \"device_role\", \"device_type__manufacturer\", \"secrets_group\", \"device_redundancy_group\"",
            "    )",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    form = forms.DeviceBulkEditForm",
            "",
            "",
            "class DeviceBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Device.objects.select_related(\"tenant\", \"site\", \"rack\", \"device_role\", \"device_type__manufacturer\")",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "",
            "",
            "#",
            "# Console ports",
            "#",
            "",
            "",
            "class ConsolePortListView(generic.ObjectListView):",
            "    queryset = ConsolePort.objects.all()",
            "    filterset = filters.ConsolePortFilterSet",
            "    filterset_form = forms.ConsolePortFilterForm",
            "    table = tables.ConsolePortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class ConsolePortView(generic.ObjectView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_consoleports\"}",
            "",
            "",
            "class ConsolePortCreateView(generic.ComponentCreateView):",
            "    queryset = ConsolePort.objects.all()",
            "    form = forms.ConsolePortCreateForm",
            "    model_form = forms.ConsolePortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsolePortEditView(generic.ObjectEditView):",
            "    queryset = ConsolePort.objects.all()",
            "    model_form = forms.ConsolePortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class ConsolePortDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "",
            "class ConsolePortBulkImportView(generic.BulkImportView):",
            "    queryset = ConsolePort.objects.all()",
            "    model_form = forms.ConsolePortCSVForm",
            "    table = tables.ConsolePortTable",
            "",
            "",
            "class ConsolePortBulkEditView(generic.BulkEditView):",
            "    queryset = ConsolePort.objects.all()",
            "    filterset = filters.ConsolePortFilterSet",
            "    table = tables.ConsolePortTable",
            "    form = forms.ConsolePortBulkEditForm",
            "",
            "",
            "class ConsolePortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "",
            "class ConsolePortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "",
            "class ConsolePortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsolePort.objects.all()",
            "    filterset = filters.ConsolePortFilterSet",
            "    table = tables.ConsolePortTable",
            "",
            "",
            "#",
            "# Console server ports",
            "#",
            "",
            "",
            "class ConsoleServerPortListView(generic.ObjectListView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    filterset = filters.ConsoleServerPortFilterSet",
            "    filterset_form = forms.ConsoleServerPortFilterForm",
            "    table = tables.ConsoleServerPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class ConsoleServerPortView(generic.ObjectView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_consoleserverports\"}",
            "",
            "",
            "class ConsoleServerPortCreateView(generic.ComponentCreateView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    form = forms.ConsoleServerPortCreateForm",
            "    model_form = forms.ConsoleServerPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsoleServerPortEditView(generic.ObjectEditView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    model_form = forms.ConsoleServerPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class ConsoleServerPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "",
            "class ConsoleServerPortBulkImportView(generic.BulkImportView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    model_form = forms.ConsoleServerPortCSVForm",
            "    table = tables.ConsoleServerPortTable",
            "",
            "",
            "class ConsoleServerPortBulkEditView(generic.BulkEditView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    filterset = filters.ConsoleServerPortFilterSet",
            "    table = tables.ConsoleServerPortTable",
            "    form = forms.ConsoleServerPortBulkEditForm",
            "",
            "",
            "class ConsoleServerPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "",
            "class ConsoleServerPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "",
            "class ConsoleServerPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    filterset = filters.ConsoleServerPortFilterSet",
            "    table = tables.ConsoleServerPortTable",
            "",
            "",
            "#",
            "# Power ports",
            "#",
            "",
            "",
            "class PowerPortListView(generic.ObjectListView):",
            "    queryset = PowerPort.objects.all()",
            "    filterset = filters.PowerPortFilterSet",
            "    filterset_form = forms.PowerPortFilterForm",
            "    table = tables.PowerPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class PowerPortView(generic.ObjectView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_powerports\"}",
            "",
            "",
            "class PowerPortCreateView(generic.ComponentCreateView):",
            "    queryset = PowerPort.objects.all()",
            "    form = forms.PowerPortCreateForm",
            "    model_form = forms.PowerPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerPortEditView(generic.ObjectEditView):",
            "    queryset = PowerPort.objects.all()",
            "    model_form = forms.PowerPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class PowerPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "",
            "class PowerPortBulkImportView(generic.BulkImportView):",
            "    queryset = PowerPort.objects.all()",
            "    model_form = forms.PowerPortCSVForm",
            "    table = tables.PowerPortTable",
            "",
            "",
            "class PowerPortBulkEditView(generic.BulkEditView):",
            "    queryset = PowerPort.objects.all()",
            "    filterset = filters.PowerPortFilterSet",
            "    table = tables.PowerPortTable",
            "    form = forms.PowerPortBulkEditForm",
            "",
            "",
            "class PowerPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "",
            "class PowerPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "",
            "class PowerPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerPort.objects.all()",
            "    filterset = filters.PowerPortFilterSet",
            "    table = tables.PowerPortTable",
            "",
            "",
            "#",
            "# Power outlets",
            "#",
            "",
            "",
            "class PowerOutletListView(generic.ObjectListView):",
            "    queryset = PowerOutlet.objects.all()",
            "    filterset = filters.PowerOutletFilterSet",
            "    filterset_form = forms.PowerOutletFilterForm",
            "    table = tables.PowerOutletTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class PowerOutletView(generic.ObjectView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_poweroutlets\"}",
            "",
            "",
            "class PowerOutletCreateView(generic.ComponentCreateView):",
            "    queryset = PowerOutlet.objects.all()",
            "    form = forms.PowerOutletCreateForm",
            "    model_form = forms.PowerOutletForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerOutletEditView(generic.ObjectEditView):",
            "    queryset = PowerOutlet.objects.all()",
            "    model_form = forms.PowerOutletForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class PowerOutletDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "",
            "class PowerOutletBulkImportView(generic.BulkImportView):",
            "    queryset = PowerOutlet.objects.all()",
            "    model_form = forms.PowerOutletCSVForm",
            "    table = tables.PowerOutletTable",
            "",
            "",
            "class PowerOutletBulkEditView(generic.BulkEditView):",
            "    queryset = PowerOutlet.objects.all()",
            "    filterset = filters.PowerOutletFilterSet",
            "    table = tables.PowerOutletTable",
            "    form = forms.PowerOutletBulkEditForm",
            "",
            "",
            "class PowerOutletBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "",
            "class PowerOutletBulkDisconnectView(BulkDisconnectView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "",
            "class PowerOutletBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerOutlet.objects.all()",
            "    filterset = filters.PowerOutletFilterSet",
            "    table = tables.PowerOutletTable",
            "",
            "",
            "#",
            "# Interfaces",
            "#",
            "",
            "",
            "class InterfaceListView(generic.ObjectListView):",
            "    queryset = Interface.objects.all()",
            "    filterset = filters.InterfaceFilterSet",
            "    filterset_form = forms.InterfaceFilterForm",
            "    table = tables.InterfaceTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class InterfaceView(generic.ObjectView):",
            "    queryset = Interface.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Get assigned IP addresses",
            "        ipaddress_table = InterfaceIPAddressTable(",
            "            data=instance.ip_addresses.restrict(request.user, \"view\").select_related(\"vrf\", \"tenant\"),",
            "            orderable=False,",
            "        )",
            "",
            "        # Get child interfaces",
            "        child_interfaces = instance.child_interfaces.restrict(request.user, \"view\")",
            "        child_interfaces_tables = tables.InterfaceTable(child_interfaces, orderable=False, exclude=(\"device\",))",
            "",
            "        # Get assigned VLANs and annotate whether each is tagged or untagged",
            "        vlans = []",
            "        if instance.untagged_vlan is not None:",
            "            vlans.append(instance.untagged_vlan)",
            "            vlans[0].tagged = False",
            "",
            "        for vlan in instance.tagged_vlans.restrict(request.user).select_related(\"site\", \"group\", \"tenant\", \"role\"):",
            "            vlan.tagged = True",
            "            vlans.append(vlan)",
            "        vlan_table = InterfaceVLANTable(interface=instance, data=vlans, orderable=False)",
            "",
            "        redundancy_table = self._get_interface_redundancy_groups_table(request, instance)",
            "",
            "        return {",
            "            \"ipaddress_table\": ipaddress_table,",
            "            \"vlan_table\": vlan_table,",
            "            \"breadcrumb_url\": \"dcim:device_interfaces\",",
            "            \"child_interfaces_table\": child_interfaces_tables,",
            "            \"redundancy_table\": redundancy_table,",
            "        }",
            "",
            "    def _get_interface_redundancy_groups_table(self, request, instance):",
            "        \"\"\"Return a table of assigned Interface Redundancy Groups.\"\"\"",
            "        queryset = instance.interface_redundancy_group_associations.restrict(request.user)",
            "        queryset = queryset.select_related(\"interface_redundancy_group\")",
            "        queryset = queryset.order_by(\"interface_redundancy_group\", \"priority\")",
            "        column_sequence = (",
            "            \"interface_redundancy_group\",",
            "            \"priority\",",
            "            \"interface_redundancy_group__status\",",
            "            \"interface_redundancy_group__protocol\",",
            "            \"interface_redundancy_group__protocol_group_id\",",
            "            \"interface_redundancy_group__virtual_ip\",",
            "        )",
            "        table = tables.InterfaceRedundancyGroupAssociationTable(",
            "            data=queryset,",
            "            sequence=column_sequence,",
            "            orderable=False,",
            "        )",
            "        for field in column_sequence:",
            "            table.columns.show(field)",
            "        return table",
            "",
            "",
            "class InterfaceCreateView(generic.ComponentCreateView):",
            "    queryset = Interface.objects.all()",
            "    form = forms.InterfaceCreateForm",
            "    model_form = forms.InterfaceForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class InterfaceEditView(generic.ObjectEditView):",
            "    queryset = Interface.objects.all()",
            "    model_form = forms.InterfaceForm",
            "    template_name = \"dcim/interface_edit.html\"",
            "",
            "",
            "class InterfaceDeleteView(generic.ObjectDeleteView):",
            "    queryset = Interface.objects.all()",
            "    template_name = \"dcim/device_interface_delete.html\"",
            "",
            "",
            "class InterfaceBulkImportView(generic.BulkImportView):",
            "    queryset = Interface.objects.all()",
            "    model_form = forms.InterfaceCSVForm",
            "    table = tables.InterfaceTable",
            "",
            "",
            "class InterfaceBulkEditView(generic.BulkEditView):",
            "    queryset = Interface.objects.all()",
            "    filterset = filters.InterfaceFilterSet",
            "    table = tables.InterfaceTable",
            "    form = forms.InterfaceBulkEditForm",
            "",
            "",
            "class InterfaceBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = Interface.objects.all()",
            "",
            "",
            "class InterfaceBulkDisconnectView(BulkDisconnectView):",
            "    queryset = Interface.objects.all()",
            "",
            "",
            "class InterfaceBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Interface.objects.all()",
            "    filterset = filters.InterfaceFilterSet",
            "    table = tables.InterfaceTable",
            "    template_name = \"dcim/interface_bulk_delete.html\"",
            "",
            "",
            "#",
            "# Front ports",
            "#",
            "",
            "",
            "class FrontPortListView(generic.ObjectListView):",
            "    queryset = FrontPort.objects.all()",
            "    filterset = filters.FrontPortFilterSet",
            "    filterset_form = forms.FrontPortFilterForm",
            "    table = tables.FrontPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class FrontPortView(generic.ObjectView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_frontports\"}",
            "",
            "",
            "class FrontPortCreateView(generic.ComponentCreateView):",
            "    queryset = FrontPort.objects.all()",
            "    form = forms.FrontPortCreateForm",
            "    model_form = forms.FrontPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class FrontPortEditView(generic.ObjectEditView):",
            "    queryset = FrontPort.objects.all()",
            "    model_form = forms.FrontPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class FrontPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "",
            "class FrontPortBulkImportView(generic.BulkImportView):",
            "    queryset = FrontPort.objects.all()",
            "    model_form = forms.FrontPortCSVForm",
            "    table = tables.FrontPortTable",
            "",
            "",
            "class FrontPortBulkEditView(generic.BulkEditView):",
            "    queryset = FrontPort.objects.all()",
            "    filterset = filters.FrontPortFilterSet",
            "    table = tables.FrontPortTable",
            "    form = forms.FrontPortBulkEditForm",
            "",
            "",
            "class FrontPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "",
            "class FrontPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "",
            "class FrontPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = FrontPort.objects.all()",
            "    filterset = filters.FrontPortFilterSet",
            "    table = tables.FrontPortTable",
            "",
            "",
            "#",
            "# Rear ports",
            "#",
            "",
            "",
            "class RearPortListView(generic.ObjectListView):",
            "    queryset = RearPort.objects.all()",
            "    filterset = filters.RearPortFilterSet",
            "    filterset_form = forms.RearPortFilterForm",
            "    table = tables.RearPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class RearPortView(generic.ObjectView):",
            "    queryset = RearPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_rearports\"}",
            "",
            "",
            "class RearPortCreateView(generic.ComponentCreateView):",
            "    queryset = RearPort.objects.all()",
            "    form = forms.RearPortCreateForm",
            "    model_form = forms.RearPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class RearPortEditView(generic.ObjectEditView):",
            "    queryset = RearPort.objects.all()",
            "    model_form = forms.RearPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class RearPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = RearPort.objects.all()",
            "",
            "",
            "class RearPortBulkImportView(generic.BulkImportView):",
            "    queryset = RearPort.objects.all()",
            "    model_form = forms.RearPortCSVForm",
            "    table = tables.RearPortTable",
            "",
            "",
            "class RearPortBulkEditView(generic.BulkEditView):",
            "    queryset = RearPort.objects.all()",
            "    filterset = filters.RearPortFilterSet",
            "    table = tables.RearPortTable",
            "    form = forms.RearPortBulkEditForm",
            "",
            "",
            "class RearPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = RearPort.objects.all()",
            "",
            "",
            "class RearPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = RearPort.objects.all()",
            "",
            "",
            "class RearPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RearPort.objects.all()",
            "    filterset = filters.RearPortFilterSet",
            "    table = tables.RearPortTable",
            "",
            "",
            "#",
            "# Device bays",
            "#",
            "",
            "",
            "class DeviceBayListView(generic.ObjectListView):",
            "    queryset = DeviceBay.objects.all()",
            "    filterset = filters.DeviceBayFilterSet",
            "    filterset_form = forms.DeviceBayFilterForm",
            "    table = tables.DeviceBayTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class DeviceBayView(generic.ObjectView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_devicebays\"}",
            "",
            "",
            "class DeviceBayCreateView(generic.ComponentCreateView):",
            "    queryset = DeviceBay.objects.all()",
            "    form = forms.DeviceBayCreateForm",
            "    model_form = forms.DeviceBayForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class DeviceBayEditView(generic.ObjectEditView):",
            "    queryset = DeviceBay.objects.all()",
            "    model_form = forms.DeviceBayForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class DeviceBayDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "",
            "class DeviceBayPopulateView(generic.ObjectEditView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = forms.PopulateDeviceBayForm(device_bay)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_populate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = forms.PopulateDeviceBayForm(device_bay, request.POST)",
            "",
            "        if form.is_valid():",
            "            device_bay.installed_device = form.cleaned_data[\"installed_device\"]",
            "            device_bay.save()",
            "            messages.success(",
            "                request,",
            "                f\"Added {device_bay.installed_device} to {device_bay}.\",",
            "            )",
            "",
            "            return redirect(\"dcim:device\", pk=device_bay.device.pk)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_populate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "",
            "class DeviceBayDepopulateView(generic.ObjectEditView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = ConfirmationForm()",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_depopulate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            removed_device = device_bay.installed_device",
            "            device_bay.installed_device = None",
            "            device_bay.save()",
            "            messages.success(",
            "                request,",
            "                f\"Removed {removed_device} from {device_bay}.\",",
            "            )",
            "",
            "            return redirect(\"dcim:device\", pk=device_bay.device.pk)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_depopulate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "",
            "class DeviceBayBulkImportView(generic.BulkImportView):",
            "    queryset = DeviceBay.objects.all()",
            "    model_form = forms.DeviceBayCSVForm",
            "    table = tables.DeviceBayTable",
            "",
            "",
            "class DeviceBayBulkEditView(generic.BulkEditView):",
            "    queryset = DeviceBay.objects.all()",
            "    filterset = filters.DeviceBayFilterSet",
            "    table = tables.DeviceBayTable",
            "    form = forms.DeviceBayBulkEditForm",
            "",
            "",
            "class DeviceBayBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "",
            "class DeviceBayBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceBay.objects.all()",
            "    filterset = filters.DeviceBayFilterSet",
            "    table = tables.DeviceBayTable",
            "",
            "",
            "#",
            "# Inventory items",
            "#",
            "",
            "",
            "class InventoryItemListView(generic.ObjectListView):",
            "    queryset = InventoryItem.objects.all()",
            "    filterset = filters.InventoryItemFilterSet",
            "    filterset_form = forms.InventoryItemFilterForm",
            "    table = tables.InventoryItemTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class InventoryItemView(generic.ObjectView):",
            "    queryset = InventoryItem.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_inventory\"}",
            "",
            "",
            "class InventoryItemEditView(generic.ObjectEditView):",
            "    queryset = InventoryItem.objects.all()",
            "    model_form = forms.InventoryItemForm",
            "",
            "",
            "class InventoryItemCreateView(generic.ComponentCreateView):",
            "    queryset = InventoryItem.objects.all()",
            "    form = forms.InventoryItemCreateForm",
            "    model_form = forms.InventoryItemForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class InventoryItemDeleteView(generic.ObjectDeleteView):",
            "    queryset = InventoryItem.objects.all()",
            "",
            "",
            "class InventoryItemBulkImportView(generic.BulkImportView):",
            "    queryset = InventoryItem.objects.all()",
            "    model_form = forms.InventoryItemCSVForm",
            "    table = tables.InventoryItemTable",
            "",
            "",
            "class InventoryItemBulkEditView(generic.BulkEditView):",
            "    queryset = InventoryItem.objects.select_related(\"device\", \"manufacturer\")",
            "    filterset = filters.InventoryItemFilterSet",
            "    table = tables.InventoryItemTable",
            "    form = forms.InventoryItemBulkEditForm",
            "",
            "",
            "class InventoryItemBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = InventoryItem.objects.all()",
            "",
            "",
            "class InventoryItemBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = InventoryItem.objects.select_related(\"device\", \"manufacturer\")",
            "    table = tables.InventoryItemTable",
            "    template_name = \"dcim/inventoryitem_bulk_delete.html\"",
            "",
            "",
            "#",
            "# Bulk Device component creation",
            "#",
            "",
            "",
            "class DeviceBulkAddConsolePortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.ConsolePortBulkCreateForm",
            "    queryset = ConsolePort.objects.all()",
            "    model_form = forms.ConsolePortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddConsoleServerPortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.ConsoleServerPortBulkCreateForm",
            "    queryset = ConsoleServerPort.objects.all()",
            "    model_form = forms.ConsoleServerPortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddPowerPortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.PowerPortBulkCreateForm",
            "    queryset = PowerPort.objects.all()",
            "    model_form = forms.PowerPortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddPowerOutletView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.PowerOutletBulkCreateForm",
            "    queryset = PowerOutlet.objects.all()",
            "    model_form = forms.PowerOutletForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddInterfaceView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.InterfaceBulkCreateForm",
            "    queryset = Interface.objects.all()",
            "    model_form = forms.InterfaceForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "# class DeviceBulkAddFrontPortView(generic.BulkComponentCreateView):",
            "#     parent_model = Device",
            "#     parent_field = 'device'",
            "#     form = forms.FrontPortBulkCreateForm",
            "#     queryset = FrontPort.objects.all()",
            "#     model_form = forms.FrontPortForm",
            "#     filterset = filters.DeviceFilterSet",
            "#     table = tables.DeviceTable",
            "#     default_return_url = 'dcim:device_list'",
            "",
            "",
            "class DeviceBulkAddRearPortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.RearPortBulkCreateForm",
            "    queryset = RearPort.objects.all()",
            "    model_form = forms.RearPortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddDeviceBayView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.DeviceBayBulkCreateForm",
            "    queryset = DeviceBay.objects.all()",
            "    model_form = forms.DeviceBayForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddInventoryItemView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.InventoryItemBulkCreateForm",
            "    queryset = InventoryItem.objects.all()",
            "    model_form = forms.InventoryItemForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "#",
            "# Cables",
            "#",
            "",
            "",
            "class CableListView(generic.ObjectListView):",
            "    queryset = Cable.objects.all()",
            "    filterset = filters.CableFilterSet",
            "    filterset_form = forms.CableFilterForm",
            "    table = tables.CableTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class CableView(generic.ObjectView):",
            "    queryset = Cable.objects.all()",
            "",
            "",
            "class PathTraceView(generic.ObjectView):",
            "    \"\"\"",
            "    Trace a cable path beginning from the given path endpoint (origin).",
            "    \"\"\"",
            "",
            "    additional_permissions = [\"dcim.view_cable\"]",
            "    template_name = \"dcim/cable_trace.html\"",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        model = kwargs.pop(\"model\")",
            "        self.queryset = model.objects.all()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_paths = []",
            "",
            "        # If tracing a PathEndpoint, locate the CablePath (if one exists) by its origin",
            "        if isinstance(instance, PathEndpoint):",
            "            path = instance._path",
            "",
            "        # Otherwise, find all CablePaths which traverse the specified object",
            "        else:",
            "            related_paths = CablePath.objects.filter(path__contains=instance).prefetch_related(\"origin\")",
            "            # Check for specification of a particular path (when tracing pass-through ports)",
            "",
            "            cablepath_id = request.GET.get(\"cablepath_id\")",
            "            if cablepath_id is not None:",
            "                try:",
            "                    path_id = uuid.UUID(cablepath_id)",
            "                except (AttributeError, TypeError, ValueError):",
            "                    path_id = None",
            "                try:",
            "                    path = related_paths.get(pk=path_id)",
            "                except CablePath.DoesNotExist:",
            "                    path = related_paths.first()",
            "            else:",
            "                path = related_paths.first()",
            "",
            "        return {",
            "            \"path\": path,",
            "            \"related_paths\": related_paths,",
            "            \"total_length\": path.get_total_length() if path else None,",
            "        }",
            "",
            "",
            "class CableCreateView(generic.ObjectEditView):",
            "    queryset = Cable.objects.all()",
            "    template_name = \"dcim/cable_connect.html\"",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Set the model_form class based on the type of component being connected",
            "        self.model_form = {",
            "            \"console-port\": forms.ConnectCableToConsolePortForm,",
            "            \"console-server-port\": forms.ConnectCableToConsoleServerPortForm,",
            "            \"power-port\": forms.ConnectCableToPowerPortForm,",
            "            \"power-outlet\": forms.ConnectCableToPowerOutletForm,",
            "            \"interface\": forms.ConnectCableToInterfaceForm,",
            "            \"front-port\": forms.ConnectCableToFrontPortForm,",
            "            \"rear-port\": forms.ConnectCableToRearPortForm,",
            "            \"power-feed\": forms.ConnectCableToPowerFeedForm,",
            "            \"circuit-termination\": forms.ConnectCableToCircuitTerminationForm,",
            "        }[kwargs.get(\"termination_b_type\")]",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        termination_a_type = url_kwargs.get(\"termination_a_type\")",
            "        termination_a_id = url_kwargs.get(\"termination_a_id\")",
            "        termination_b_type_name = url_kwargs.get(\"termination_b_type\")",
            "        self.termination_b_type = ContentType.objects.get(model=termination_b_type_name.replace(\"-\", \"\"))",
            "",
            "        # Initialize Cable termination attributes",
            "        obj.termination_a = termination_a_type.objects.get(pk=termination_a_id)",
            "        obj.termination_b_type = self.termination_b_type",
            "",
            "        return obj",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "",
            "        # Parse initial data manually to avoid setting field values as lists",
            "        initial_data = {k: request.GET[k] for k in request.GET}",
            "",
            "        # Set initial site and rack based on side A termination (if not already set)",
            "        termination_a_site = getattr(obj.termination_a.parent, \"site\", None)",
            "        if termination_a_site and \"termination_b_region\" not in initial_data:",
            "            initial_data[\"termination_b_region\"] = termination_a_site.region",
            "        if \"termination_b_site\" not in initial_data:",
            "            initial_data[\"termination_b_site\"] = termination_a_site",
            "        if \"termination_b_rack\" not in initial_data:",
            "            initial_data[\"termination_b_rack\"] = getattr(obj.termination_a.parent, \"rack\", None)",
            "",
            "        form = self.model_form(exclude_id=kwargs.get(\"termination_a_id\"), instance=obj, initial=initial_data)",
            "",
            "        # the following builds up a CSS query selector to match all drop-downs",
            "        # in the termination_b form except the termination_b_id. this is necessary to reset the termination_b_id",
            "        # drop-down whenever any of these drop-downs' values changes. this cannot be hardcoded because the form is",
            "        # selected dynamically and therefore the fields change depending on the value of termination_b_type (L2358)",
            "        js_select_onchange_query = \", \".join(",
            "            [",
            "                f\"select#id_{field_name}\"",
            "                for field_name, field in form.fields.items()",
            "                # include all termination_b_* fields:",
            "                if field_name.startswith(\"termination_b\")",
            "                # exclude termination_b_id:",
            "                and field_name != \"termination_b_id\"",
            "                # include only HTML select fields:",
            "                and field.widget.input_type == \"select\"",
            "            ]",
            "        )",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": Cable._meta.verbose_name,",
            "                \"termination_b_type\": self.termination_b_type.name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"js_select_onchange_query\": js_select_onchange_query,",
            "            },",
            "        )",
            "",
            "",
            "class CableEditView(generic.ObjectEditView):",
            "    queryset = Cable.objects.all()",
            "    model_form = forms.CableForm",
            "    template_name = \"dcim/cable_edit.html\"",
            "",
            "",
            "class CableDeleteView(generic.ObjectDeleteView):",
            "    queryset = Cable.objects.all()",
            "",
            "",
            "class CableBulkImportView(generic.BulkImportView):",
            "    queryset = Cable.objects.all()",
            "    model_form = forms.CableCSVForm",
            "    table = tables.CableTable",
            "",
            "",
            "class CableBulkEditView(generic.BulkEditView):",
            "    queryset = Cable.objects.prefetch_related(\"termination_a\", \"termination_b\")",
            "    filterset = filters.CableFilterSet",
            "    table = tables.CableTable",
            "    form = forms.CableBulkEditForm",
            "",
            "",
            "class CableBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Cable.objects.prefetch_related(\"termination_a\", \"termination_b\")",
            "    filterset = filters.CableFilterSet",
            "    table = tables.CableTable",
            "",
            "",
            "#",
            "# Connections",
            "#",
            "",
            "",
            "class ConnectionsListView(generic.ObjectListView):",
            "    CSVRow = namedtuple(\"CSVRow\", [\"device\", \"name\", \"dest_device\", \"dest_name\", \"reachable\"])",
            "",
            "    def queryset_to_csv_body_data(self):",
            "        \"\"\"",
            "        The headers may differ from view to view but the formatting of the CSV data is the same.",
            "        \"\"\"",
            "        csv_body_data = []",
            "        for obj in self.queryset:",
            "            # The connected endpoint may or may not be associated with a Device (e.g., CircuitTerminations are not)",
            "            # and may or may not have a name of its own (e.g., CircuitTerminations do not)",
            "            dest_device = None",
            "            dest_name = None",
            "            if obj.connected_endpoint:",
            "                if hasattr(obj.connected_endpoint, \"device\"):",
            "                    dest_device = obj.connected_endpoint.device.identifier",
            "                if hasattr(obj.connected_endpoint, \"name\"):",
            "                    dest_name = obj.connected_endpoint.name",
            "",
            "            # In the case where a connection exists between two like endpoints,",
            "            # for consistency of output we want to ensure that it's always represented as",
            "            # (\"device a\", \"interface a\", \"device b\", \"interface b\") rather than",
            "            # (\"device b\", \"interface b\", \"device a\", \"interface a\")",
            "            if obj.__class__ == obj.connected_endpoint.__class__ and (",
            "                obj.device.identifier > obj.connected_endpoint.device.identifier",
            "                or (",
            "                    obj.device.identifier == obj.connected_endpoint.device.identifier",
            "                    and obj.name > obj.connected_endpoint.name",
            "                )",
            "            ):",
            "                # Swap the two endpoints around for consistent output as described above",
            "                row = self.CSVRow(",
            "                    device=dest_device,",
            "                    name=dest_name,",
            "                    dest_device=obj.device.identifier,",
            "                    dest_name=obj.name,",
            "                    reachable=str(obj.path.is_active),",
            "                )",
            "            else:",
            "                # Existing order of endpoints is fine and correct",
            "                row = self.CSVRow(",
            "                    device=obj.device.identifier,",
            "                    name=obj.name,",
            "                    dest_device=dest_device,",
            "                    dest_name=dest_name,",
            "                    reachable=str(obj.path.is_active),",
            "                )",
            "",
            "            csv_body_data.append(csv_format(row))",
            "",
            "        return sorted(csv_body_data)",
            "",
            "",
            "class ConsoleConnectionsListView(ConnectionsListView):",
            "    queryset = ConsolePort.objects.filter(_path__isnull=False)",
            "    filterset = filters.ConsoleConnectionFilterSet",
            "    filterset_form = forms.ConsoleConnectionFilterForm",
            "    table = tables.ConsoleConnectionTable",
            "    action_buttons = (\"export\",)",
            "",
            "    def queryset_to_csv(self):",
            "        csv_data = [",
            "            # Headers",
            "            \",\".join([\"device\", \"console_port\", \"console_server\", \"port\", \"reachable\"])",
            "        ]",
            "        csv_data.extend(self.queryset_to_csv_body_data())",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"title\": \"Console Connections\",",
            "            \"list_url\": \"dcim:console_connections_list\",",
            "            \"search_form\": None,  # ConsoleConnectionFilterSet do not support q filter",
            "        }",
            "",
            "",
            "class PowerConnectionsListView(ConnectionsListView):",
            "    queryset = PowerPort.objects.filter(_path__isnull=False)",
            "    filterset = filters.PowerConnectionFilterSet",
            "    filterset_form = forms.PowerConnectionFilterForm",
            "    table = tables.PowerConnectionTable",
            "    action_buttons = (\"export\",)",
            "",
            "    def queryset_to_csv(self):",
            "        csv_data = [",
            "            # Headers",
            "            \",\".join([\"device\", \"power_port\", \"pdu\", \"outlet\", \"reachable\"])",
            "        ]",
            "        csv_data.extend(self.queryset_to_csv_body_data())",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"title\": \"Power Connections\",",
            "            \"list_url\": \"dcim:power_connections_list\",",
            "            \"search_form\": None,  # PowerConnectionFilterSet do not support q filter",
            "        }",
            "",
            "",
            "class InterfaceConnectionsListView(ConnectionsListView):",
            "    queryset = None  # This gets set initially in init (See `get_queryset()`)",
            "    filterset = filters.InterfaceConnectionFilterSet",
            "    filterset_form = forms.InterfaceConnectionFilterForm",
            "    table = tables.InterfaceConnectionTable",
            "    action_buttons = (\"export\",)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.get_queryset()  # Populate self.queryset after init.",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        This is a required so that the call to `ContentType.objects.get_for_model` does not result in a circular import.",
            "        \"\"\"",
            "        qs = Interface.objects.filter(_path__isnull=False).exclude(",
            "            # If an Interface is connected to another Interface, avoid returning both (A, B) and (B, A)",
            "            # Unfortunately we can't use something consistent to pick which pair to exclude (such as device or name)",
            "            # as _path.destination is a GenericForeignKey without a corresponding GenericRelation and so cannot be",
            "            # used for reverse querying.",
            "            # The below at least ensures uniqueness, but doesn't guarantee whether we get (A, B) or (B, A);",
            "            # we fix it up to be consistently (A, B) in queryset_to_csv_body_data().",
            "            # TODO: this is very problematic when filtering the view via FilterSet - if the filterset matches (A), then",
            "            #       the connection will appear in the table, but if it only matches (B) then the connection will not!",
            "            _path__destination_type=ContentType.objects.get_for_model(Interface),",
            "            pk__lt=F(\"_path__destination_id\"),",
            "        )",
            "        if self.queryset is None:",
            "            self.queryset = qs",
            "",
            "        return self.queryset",
            "",
            "    def queryset_to_csv(self):",
            "        csv_data = [",
            "            # Headers",
            "            \",\".join([\"device_a\", \"interface_a\", \"device_b\", \"interface_b\", \"reachable\"])",
            "        ]",
            "        csv_data.extend(self.queryset_to_csv_body_data())",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"title\": \"Interface Connections\",",
            "            \"list_url\": \"dcim:interface_connections_list\",",
            "            \"search_form\": None,  # InterfaceConnectionFilterSet do not support q filter",
            "        }",
            "",
            "",
            "#",
            "# Virtual chassis",
            "#",
            "",
            "",
            "class VirtualChassisListView(generic.ObjectListView):",
            "    queryset = VirtualChassis.objects.select_related(\"master\").annotate(",
            "        member_count=count_related(Device, \"virtual_chassis\")",
            "    )",
            "    table = tables.VirtualChassisTable",
            "    filterset = filters.VirtualChassisFilterSet",
            "    filterset_form = forms.VirtualChassisFilterForm",
            "",
            "",
            "class VirtualChassisView(generic.ObjectView):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        members = Device.objects.restrict(request.user).filter(virtual_chassis=instance)",
            "",
            "        return {",
            "            \"members\": members,",
            "        }",
            "",
            "",
            "class VirtualChassisCreateView(generic.ObjectEditView):",
            "    queryset = VirtualChassis.objects.all()",
            "    model_form = forms.VirtualChassisCreateForm",
            "    template_name = \"dcim/virtualchassis_add.html\"",
            "",
            "",
            "class VirtualChassisEditView(ObjectPermissionRequiredMixin, GetReturnURLMixin, View):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"dcim.change_virtualchassis\"",
            "",
            "    def get(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "        VCMemberFormSet = modelformset_factory(",
            "            model=Device,",
            "            form=forms.DeviceVCMembershipForm,",
            "            formset=forms.BaseVCMemberFormSet,",
            "            extra=0,",
            "        )",
            "        members_queryset = virtual_chassis.members.select_related(\"rack\").order_by(\"vc_position\")",
            "",
            "        vc_form = forms.VirtualChassisForm(instance=virtual_chassis)",
            "        vc_form.fields[\"master\"].queryset = members_queryset",
            "        formset = VCMemberFormSet(queryset=members_queryset)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_edit.html\",",
            "            {",
            "                \"vc_form\": vc_form,",
            "                \"formset\": formset,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "    def post(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "        VCMemberFormSet = modelformset_factory(",
            "            model=Device,",
            "            form=forms.DeviceVCMembershipForm,",
            "            formset=forms.BaseVCMemberFormSet,",
            "            extra=0,",
            "        )",
            "        members_queryset = virtual_chassis.members.select_related(\"rack\").order_by(\"vc_position\")",
            "",
            "        vc_form = forms.VirtualChassisForm(request.POST, instance=virtual_chassis)",
            "        vc_form.fields[\"master\"].queryset = members_queryset",
            "        formset = VCMemberFormSet(request.POST, queryset=members_queryset)",
            "",
            "        if vc_form.is_valid() and formset.is_valid():",
            "            with transaction.atomic():",
            "                # Save the VirtualChassis",
            "                vc_form.save()",
            "",
            "                # Nullify the vc_position of each member first to allow reordering without raising an IntegrityError on",
            "                # duplicate positions. Then save each member instance.",
            "                members = formset.save(commit=False)",
            "                devices = Device.objects.filter(pk__in=[m.pk for m in members])",
            "                for device in devices:",
            "                    device.vc_position = None",
            "                    device.save()",
            "                for member in members:",
            "                    member.save()",
            "",
            "            return redirect(virtual_chassis.get_absolute_url())",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_edit.html\",",
            "            {",
            "                \"vc_form\": vc_form,",
            "                \"formset\": formset,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "",
            "class VirtualChassisDeleteView(generic.ObjectDeleteView):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "",
            "class VirtualChassisAddMemberView(ObjectPermissionRequiredMixin, GetReturnURLMixin, View):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"dcim.change_virtualchassis\"",
            "",
            "    def get(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        initial_data = {k: request.GET[k] for k in request.GET}",
            "        member_select_form = forms.VCMemberSelectForm(initial=initial_data)",
            "        membership_form = forms.DeviceVCMembershipForm(initial=initial_data)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_add_member.html\",",
            "            {",
            "                \"virtual_chassis\": virtual_chassis,",
            "                \"member_select_form\": member_select_form,",
            "                \"membership_form\": membership_form,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "    def post(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        member_select_form = forms.VCMemberSelectForm(request.POST)",
            "",
            "        if member_select_form.is_valid():",
            "            device = member_select_form.cleaned_data[\"device\"]",
            "            device.virtual_chassis = virtual_chassis",
            "            data = {k: request.POST[k] for k in [\"vc_position\", \"vc_priority\"]}",
            "            membership_form = forms.DeviceVCMembershipForm(data=data, validate_vc_position=True, instance=device)",
            "",
            "            if membership_form.is_valid():",
            "                membership_form.save()",
            "                msg = f'Added member <a href=\"{device.get_absolute_url()}\">{escape(device)}</a>'",
            "                messages.success(request, mark_safe(msg))",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    return redirect(request.get_full_path())",
            "",
            "                return redirect(self.get_return_url(request, device))",
            "",
            "        else:",
            "            membership_form = forms.DeviceVCMembershipForm(data=request.POST)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_add_member.html\",",
            "            {",
            "                \"virtual_chassis\": virtual_chassis,",
            "                \"member_select_form\": member_select_form,",
            "                \"membership_form\": membership_form,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "",
            "class VirtualChassisRemoveMemberView(ObjectPermissionRequiredMixin, GetReturnURLMixin, View):",
            "    queryset = Device.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"dcim.change_device\"",
            "",
            "    def get(self, request, pk):",
            "        device = get_object_or_404(self.queryset, pk=pk, virtual_chassis__isnull=False)",
            "        form = ConfirmationForm(initial=request.GET)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_remove_member.html\",",
            "            {",
            "                \"device\": device,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device),",
            "            },",
            "        )",
            "",
            "    def post(self, request, pk):",
            "        device = get_object_or_404(self.queryset, pk=pk, virtual_chassis__isnull=False)",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        # Protect master device from being removed",
            "        virtual_chassis = VirtualChassis.objects.filter(master=device).first()",
            "        if virtual_chassis is not None:",
            "            msg = f\"Unable to remove master device {escape(device)} from the virtual chassis.\"",
            "            messages.error(request, mark_safe(msg))",
            "            return redirect(device.get_absolute_url())",
            "",
            "        if form.is_valid():",
            "            devices = Device.objects.filter(pk=device.pk)",
            "            for device in devices:",
            "                device.virtual_chassis = None",
            "                device.vc_position = None",
            "                device.vc_priority = None",
            "                device.save()",
            "",
            "            msg = f\"Removed {device} from virtual chassis {device.virtual_chassis}\"",
            "            messages.success(request, msg)",
            "",
            "            return redirect(self.get_return_url(request, device))",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_remove_member.html\",",
            "            {",
            "                \"device\": device,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device),",
            "            },",
            "        )",
            "",
            "",
            "class VirtualChassisBulkImportView(generic.BulkImportView):",
            "    queryset = VirtualChassis.objects.all()",
            "    model_form = forms.VirtualChassisCSVForm",
            "    table = tables.VirtualChassisTable",
            "",
            "",
            "class VirtualChassisBulkEditView(generic.BulkEditView):",
            "    queryset = VirtualChassis.objects.all()",
            "    filterset = filters.VirtualChassisFilterSet",
            "    table = tables.VirtualChassisTable",
            "    form = forms.VirtualChassisBulkEditForm",
            "",
            "",
            "class VirtualChassisBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = VirtualChassis.objects.all()",
            "    filterset = filters.VirtualChassisFilterSet",
            "    table = tables.VirtualChassisTable",
            "",
            "",
            "#",
            "# Power panels",
            "#",
            "",
            "",
            "class PowerPanelListView(generic.ObjectListView):",
            "    queryset = PowerPanel.objects.select_related(\"site\", \"rack_group\").annotate(",
            "        powerfeed_count=count_related(PowerFeed, \"power_panel\")",
            "    )",
            "    filterset = filters.PowerPanelFilterSet",
            "    filterset_form = forms.PowerPanelFilterForm",
            "    table = tables.PowerPanelTable",
            "",
            "",
            "class PowerPanelView(generic.ObjectView):",
            "    queryset = PowerPanel.objects.prefetch_related(\"site\", \"rack_group\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        power_feeds = PowerFeed.objects.restrict(request.user).filter(power_panel=instance).select_related(\"rack\")",
            "        powerfeed_table = tables.PowerFeedTable(data=power_feeds, orderable=False)",
            "        powerfeed_table.exclude = [\"power_panel\"]",
            "",
            "        return {",
            "            \"powerfeed_table\": powerfeed_table,",
            "        }",
            "",
            "",
            "class PowerPanelEditView(generic.ObjectEditView):",
            "    queryset = PowerPanel.objects.all()",
            "    model_form = forms.PowerPanelForm",
            "    template_name = \"dcim/powerpanel_edit.html\"",
            "",
            "",
            "class PowerPanelDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerPanel.objects.all()",
            "",
            "",
            "class PowerPanelBulkImportView(generic.BulkImportView):",
            "    queryset = PowerPanel.objects.all()",
            "    model_form = forms.PowerPanelCSVForm",
            "    table = tables.PowerPanelTable",
            "",
            "",
            "class PowerPanelBulkEditView(generic.BulkEditView):",
            "    queryset = PowerPanel.objects.select_related(\"site\", \"rack_group\")",
            "    filterset = filters.PowerPanelFilterSet",
            "    table = tables.PowerPanelTable",
            "    form = forms.PowerPanelBulkEditForm",
            "",
            "",
            "class PowerPanelBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerPanel.objects.select_related(\"site\", \"rack_group\").annotate(",
            "        powerfeed_count=count_related(PowerFeed, \"power_panel\")",
            "    )",
            "    filterset = filters.PowerPanelFilterSet",
            "    table = tables.PowerPanelTable",
            "",
            "",
            "#",
            "# Power feeds",
            "#",
            "",
            "",
            "class PowerFeedListView(generic.ObjectListView):",
            "    queryset = PowerFeed.objects.all()",
            "    filterset = filters.PowerFeedFilterSet",
            "    filterset_form = forms.PowerFeedFilterForm",
            "    table = tables.PowerFeedTable",
            "",
            "",
            "class PowerFeedView(generic.ObjectView):",
            "    queryset = PowerFeed.objects.select_related(\"power_panel\", \"rack\")",
            "",
            "",
            "class PowerFeedEditView(generic.ObjectEditView):",
            "    queryset = PowerFeed.objects.all()",
            "    model_form = forms.PowerFeedForm",
            "    template_name = \"dcim/powerfeed_edit.html\"",
            "",
            "",
            "class PowerFeedDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerFeed.objects.all()",
            "",
            "",
            "class PowerFeedBulkImportView(generic.BulkImportView):",
            "    queryset = PowerFeed.objects.all()",
            "    model_form = forms.PowerFeedCSVForm",
            "    table = tables.PowerFeedTable",
            "",
            "",
            "class PowerFeedBulkEditView(generic.BulkEditView):",
            "    queryset = PowerFeed.objects.select_related(\"power_panel\", \"rack\")",
            "    filterset = filters.PowerFeedFilterSet",
            "    table = tables.PowerFeedTable",
            "    form = forms.PowerFeedBulkEditForm",
            "",
            "",
            "class PowerFeedBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerFeed.objects.select_related(\"power_panel\", \"rack\")",
            "    filterset = filters.PowerFeedFilterSet",
            "    table = tables.PowerFeedTable",
            "",
            "",
            "class DeviceRedundancyGroupUIViewSet(NautobotUIViewSet):",
            "    bulk_create_form_class = forms.DeviceRedundancyGroupCSVForm",
            "    bulk_update_form_class = forms.DeviceRedundancyGroupBulkEditForm",
            "    filterset_class = filters.DeviceRedundancyGroupFilterSet",
            "    filterset_form_class = forms.DeviceRedundancyGroupFilterForm",
            "    form_class = forms.DeviceRedundancyGroupForm",
            "    queryset = (",
            "        DeviceRedundancyGroup.objects.select_related(\"status\")",
            "        .prefetch_related(\"members\")",
            "        .annotate(member_count=count_related(Device, \"device_redundancy_group\"))",
            "    )",
            "    serializer_class = serializers.DeviceRedundancyGroupSerializer",
            "    table_class = tables.DeviceRedundancyGroupTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "",
            "        if self.action == \"retrieve\" and instance:",
            "            members = instance.members_sorted.restrict(request.user)",
            "            members_table = tables.DeviceTable(members)",
            "            members_table.columns.show(\"device_redundancy_group_priority\")",
            "            context[\"members_table\"] = members_table",
            "        return context",
            "",
            "",
            "class InterfaceRedundancyGroupUIViewSet(NautobotUIViewSet):",
            "    \"\"\"ViewSet for the InterfaceRedundancyGroup model.\"\"\"",
            "",
            "    bulk_create_form_class = forms.InterfaceRedundancyGroupCSVForm",
            "    bulk_update_form_class = forms.InterfaceRedundancyGroupBulkEditForm",
            "    filterset_class = filters.InterfaceRedundancyGroupFilterSet",
            "    filterset_form_class = forms.InterfaceRedundancyGroupFilterForm",
            "    form_class = forms.InterfaceRedundancyGroupForm",
            "    queryset = InterfaceRedundancyGroup.objects.select_related(\"status\")",
            "    queryset = queryset.prefetch_related(\"interfaces\")",
            "    queryset = queryset.annotate(",
            "        interface_count=count_related(Interface, \"interface_redundancy_groups\"),",
            "    )",
            "    serializer_class = serializers.InterfaceRedundancyGroupSerializer",
            "    table_class = tables.InterfaceRedundancyGroupTable",
            "    lookup_field = \"pk\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"Return additional panels for display.\"\"\"",
            "        context = super().get_extra_context(request, instance)",
            "        if instance and self.action == \"retrieve\":",
            "            interface_table = self._get_interface_redundancy_groups_table(request, instance)",
            "            context[\"interface_table\"] = interface_table",
            "        return context",
            "",
            "    def _get_interface_redundancy_groups_table(self, request, instance):",
            "        \"\"\"Return a table of assigned Interfaces.\"\"\"",
            "        queryset = instance.interface_redundancy_group_associations.restrict(request.user)",
            "        queryset = queryset.prefetch_related(\"interface\")",
            "        queryset = queryset.order_by(\"priority\")",
            "        column_sequence = (",
            "            \"interface__device\",",
            "            \"interface\",",
            "            \"priority\",",
            "            \"interface__status\",",
            "            \"interface__enabled\",",
            "            \"interface__ip_addresses\",",
            "            \"interface__type\",",
            "            \"interface__description\",",
            "            \"interface__label\",",
            "        )",
            "        table = tables.InterfaceRedundancyGroupAssociationTable(",
            "            data=queryset,",
            "            sequence=column_sequence,",
            "            orderable=False,",
            "        )",
            "        for column_name in column_sequence:",
            "            table.columns.show(column_name)",
            "        return table",
            "",
            "",
            "class InterfaceRedundancyGroupAssociationUIViewSet(ObjectEditViewMixin, ObjectDestroyViewMixin):",
            "    queryset = InterfaceRedundancyGroupAssociation.objects.all()",
            "    form_class = forms.InterfaceRedundancyGroupAssociationForm",
            "    template_name = \"dcim/interfaceredundancygroupassociation_create.html\"",
            "    lookup_field = \"pk\""
        ],
        "afterPatchFile": [
            "import uuid",
            "from collections import OrderedDict, namedtuple",
            "",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.paginator import EmptyPage, PageNotAnInteger",
            "from django.db import transaction",
            "from django.db.models import F, Prefetch",
            "from django.forms import (",
            "    ModelMultipleChoiceField,",
            "    MultipleHiddenInput,",
            "    modelformset_factory,",
            ")",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.utils.html import format_html",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "",
            "from nautobot.circuits.models import Circuit",
            "from nautobot.core.views import generic",
            "from nautobot.core.views.mixins import ObjectDestroyViewMixin, ObjectEditViewMixin",
            "from nautobot.core.views.viewsets import NautobotUIViewSet",
            "from nautobot.dcim.utils import get_network_driver_mapping_tool_names, get_all_network_driver_mappings",
            "from nautobot.extras.views import ObjectChangeLogView, ObjectConfigContextView, ObjectDynamicGroupsView",
            "from nautobot.ipam.models import IPAddress, Prefix, Service, VLAN",
            "from nautobot.ipam.tables import InterfaceIPAddressTable, InterfaceVLANTable",
            "from nautobot.utilities.forms import ConfirmationForm",
            "from nautobot.utilities.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.utilities.permissions import get_permission_for_model",
            "from nautobot.utilities.utils import csv_format, count_related",
            "from nautobot.utilities.views import GetReturnURLMixin, ObjectPermissionRequiredMixin",
            "from nautobot.virtualization.models import VirtualMachine",
            "from . import filters, forms, tables",
            "from .api import serializers",
            "from .choices import DeviceFaceChoices",
            "from .constants import NONCONNECTABLE_IFACE_TYPES",
            "from .models import (",
            "    Cable,",
            "    CablePath,",
            "    ConsolePort,",
            "    ConsolePortTemplate,",
            "    ConsoleServerPort,",
            "    ConsoleServerPortTemplate,",
            "    Device,",
            "    DeviceBay,",
            "    DeviceBayTemplate,",
            "    DeviceRedundancyGroup,",
            "    DeviceRole,",
            "    DeviceType,",
            "    FrontPort,",
            "    FrontPortTemplate,",
            "    Interface,",
            "    InterfaceRedundancyGroup,",
            "    InterfaceRedundancyGroupAssociation,",
            "    InterfaceTemplate,",
            "    InventoryItem,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    PathEndpoint,",
            "    Platform,",
            "    PowerFeed,",
            "    PowerOutlet,",
            "    PowerOutletTemplate,",
            "    PowerPanel,",
            "    PowerPort,",
            "    PowerPortTemplate,",
            "    Rack,",
            "    RackGroup,",
            "    RackReservation,",
            "    RackRole,",
            "    RearPort,",
            "    RearPortTemplate,",
            "    Region,",
            "    Site,",
            "    VirtualChassis,",
            ")",
            "",
            "",
            "class BulkDisconnectView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    An extendable view for disconnection console/power/interface components in bulk.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"dcim/bulk_disconnect.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Create a new Form class from ConfirmationForm",
            "        class _Form(ConfirmationForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput())",
            "",
            "        self.form = _Form",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def post(self, request):",
            "        selected_objects = []",
            "        return_url = self.get_return_url(request)",
            "",
            "        if \"_confirm\" in request.POST:",
            "            form = self.form(request.POST)",
            "",
            "            if form.is_valid():",
            "                with transaction.atomic():",
            "                    count = 0",
            "                    for obj in self.queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                        if obj.cable is None:",
            "                            continue",
            "                        obj.cable.delete()",
            "                        count += 1",
            "",
            "                messages.success(",
            "                    request,",
            "                    f\"Disconnected {count} {self.queryset.model._meta.verbose_name_plural}\",",
            "                )",
            "",
            "                return redirect(return_url)",
            "",
            "        else:",
            "            form = self.form(initial={\"pk\": request.POST.getlist(\"pk\")})",
            "            selected_objects = self.queryset.filter(pk__in=form.initial[\"pk\"])",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"selected_objects\": selected_objects,",
            "                \"return_url\": return_url,",
            "            },",
            "        )",
            "",
            "",
            "class BaseDeviceComponentsBulkRenameView(generic.BulkRenameView):",
            "    def get_selected_objects_parents_name(self, selected_objects):",
            "        selected_object = selected_objects.first()",
            "        if selected_object and selected_object.device:",
            "            return selected_object.device.name",
            "        return None",
            "",
            "",
            "#",
            "# Regions",
            "#",
            "",
            "",
            "class RegionListView(generic.ObjectListView):",
            "    queryset = Region.objects.add_related_count(Region.objects.all(), Site, \"region\", \"site_count\", cumulative=True)",
            "    filterset = filters.RegionFilterSet",
            "    filterset_form = forms.RegionFilterForm",
            "    table = tables.RegionTable",
            "",
            "",
            "class RegionView(generic.ObjectView):",
            "    queryset = Region.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Sites",
            "        sites = (",
            "            Site.objects.restrict(request.user, \"view\")",
            "            .filter(region__in=instance.get_descendants(include_self=True))",
            "            .select_related(\"region\", \"tenant\")",
            "            .prefetch_related(\"parent\")",
            "        )",
            "",
            "        sites_table = tables.SiteTable(sites)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(sites_table)",
            "",
            "        return {",
            "            \"sites_table\": sites_table,",
            "        }",
            "",
            "",
            "class RegionEditView(generic.ObjectEditView):",
            "    queryset = Region.objects.all()",
            "    model_form = forms.RegionForm",
            "",
            "",
            "class RegionDeleteView(generic.ObjectDeleteView):",
            "    queryset = Region.objects.all()",
            "",
            "",
            "class RegionBulkImportView(generic.BulkImportView):",
            "    queryset = Region.objects.all()",
            "    model_form = forms.RegionCSVForm",
            "    table = tables.RegionTable",
            "",
            "",
            "class RegionBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Region.objects.add_related_count(Region.objects.all(), Site, \"region\", \"site_count\", cumulative=True)",
            "    filterset = filters.RegionFilterSet",
            "    table = tables.RegionTable",
            "",
            "",
            "#",
            "# Sites",
            "#",
            "",
            "",
            "class SiteListView(generic.ObjectListView):",
            "    queryset = Site.objects.all()",
            "    filterset = filters.SiteFilterSet",
            "    filterset_form = forms.SiteFilterForm",
            "    table = tables.SiteTable",
            "",
            "",
            "class SiteView(generic.ObjectView):",
            "    queryset = Site.objects.select_related(\"region\", \"tenant__group\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        stats = {",
            "            \"rack_count\": Rack.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"device_count\": Device.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"prefix_count\": Prefix.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"vlan_count\": VLAN.objects.restrict(request.user, \"view\").filter(site=instance).count(),",
            "            \"circuit_count\": Circuit.objects.restrict(request.user, \"view\").filter(terminations__site=instance).count(),",
            "            \"vm_count\": VirtualMachine.objects.restrict(request.user, \"view\").filter(cluster__site=instance).count(),",
            "        }",
            "        rack_groups = (",
            "            RackGroup.objects.add_related_count(RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True)",
            "            .restrict(request.user, \"view\")",
            "            .filter(site=instance)",
            "        )",
            "        locations = (",
            "            Location.objects.restrict(request.user, \"view\")",
            "            .filter(site=instance)",
            "            .select_related(\"parent\", \"location_type\")",
            "        )",
            "",
            "        locations_table = tables.LocationTable(locations)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(locations_table)",
            "",
            "        return {",
            "            \"locations_table\": locations_table,",
            "            \"stats\": stats,",
            "            \"rack_groups\": rack_groups,",
            "        }",
            "",
            "",
            "class SiteEditView(generic.ObjectEditView):",
            "    queryset = Site.objects.all()",
            "    model_form = forms.SiteForm",
            "    template_name = \"dcim/site_edit.html\"",
            "",
            "",
            "class SiteDeleteView(generic.ObjectDeleteView):",
            "    queryset = Site.objects.all()",
            "",
            "",
            "class SiteBulkImportView(generic.BulkImportView):",
            "    queryset = Site.objects.all()",
            "    model_form = forms.SiteCSVForm",
            "    table = tables.SiteTable",
            "",
            "",
            "class SiteBulkEditView(generic.BulkEditView):",
            "    queryset = Site.objects.select_related(\"region\", \"tenant\")",
            "    filterset = filters.SiteFilterSet",
            "    table = tables.SiteTable",
            "    form = forms.SiteBulkEditForm",
            "",
            "",
            "class SiteBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Site.objects.select_related(\"region\", \"tenant\")",
            "    filterset = filters.SiteFilterSet",
            "    table = tables.SiteTable",
            "",
            "",
            "#",
            "# LocationTypes",
            "#",
            "",
            "",
            "class LocationTypeListView(generic.ObjectListView):",
            "    queryset = LocationType.objects.with_tree_fields()",
            "    filterset = filters.LocationTypeFilterSet",
            "    filterset_form = forms.LocationTypeFilterForm",
            "    table = tables.LocationTypeTable",
            "",
            "",
            "class LocationTypeView(generic.ObjectView):",
            "    queryset = LocationType.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        children = LocationType.objects.restrict(request.user, \"view\").filter(parent=instance).select_related(\"parent\")",
            "        locations = (",
            "            Location.objects.restrict(request.user, \"view\")",
            "            .filter(location_type=instance)",
            "            .select_related(\"parent\", \"location_type\")",
            "        )",
            "",
            "        children_table = tables.LocationTypeTable(children)",
            "        locations_table = tables.LocationTable(locations)",
            "        locations_table.columns.hide(\"location_type\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(children_table)",
            "        RequestConfig(request, paginate).configure(locations_table)",
            "",
            "        return {",
            "            \"children_table\": children_table,",
            "            \"locations_table\": locations_table,",
            "        }",
            "",
            "",
            "class LocationTypeEditView(generic.ObjectEditView):",
            "    queryset = LocationType.objects.all()",
            "    model_form = forms.LocationTypeForm",
            "",
            "",
            "class LocationTypeDeleteView(generic.ObjectDeleteView):",
            "    queryset = LocationType.objects.all()",
            "",
            "",
            "class LocationTypeBulkImportView(generic.BulkImportView):",
            "    queryset = LocationType.objects.all()",
            "    model_form = forms.LocationTypeCSVForm",
            "    table = tables.LocationTypeTable",
            "",
            "",
            "class LocationTypeBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = LocationType.objects.all()",
            "    filterset = filters.LocationTypeFilterSet",
            "    table = tables.LocationTypeTable",
            "",
            "",
            "#",
            "# Locations",
            "#",
            "",
            "",
            "class LocationListView(generic.ObjectListView):",
            "    queryset = Location.objects.select_related(\"location_type\", \"parent\", \"site\", \"tenant\")",
            "    filterset = filters.LocationFilterSet",
            "    filterset_form = forms.LocationFilterForm",
            "    table = tables.LocationTable",
            "",
            "",
            "class LocationView(generic.ObjectView):",
            "    queryset = Location.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_locations = (",
            "            instance.descendants(include_self=True).restrict(request.user, \"view\").values_list(\"pk\", flat=True)",
            "        )",
            "        stats = {",
            "            \"rack_count\": Rack.objects.restrict(request.user, \"view\").filter(location__in=related_locations).count(),",
            "            \"device_count\": Device.objects.restrict(request.user, \"view\")",
            "            .filter(location__in=related_locations)",
            "            .count(),",
            "            \"prefix_count\": Prefix.objects.restrict(request.user, \"view\")",
            "            .filter(location__in=related_locations)",
            "            .count(),",
            "            \"vlan_count\": VLAN.objects.restrict(request.user, \"view\").filter(location__in=related_locations).count(),",
            "            \"circuit_count\": Circuit.objects.restrict(request.user, \"view\")",
            "            .filter(terminations__location__in=related_locations)",
            "            .count(),",
            "            \"vm_count\": VirtualMachine.objects.restrict(request.user, \"view\")",
            "            .filter(cluster__location__in=related_locations)",
            "            .count(),",
            "        }",
            "        rack_groups = (",
            "            RackGroup.objects.add_related_count(RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True)",
            "            .restrict(request.user, \"view\")",
            "            .filter(location__in=related_locations)",
            "        )",
            "        children = (",
            "            Location.objects.restrict(request.user, \"view\")",
            "            .filter(parent=instance)",
            "            .select_related(\"parent\", \"location_type\")",
            "        )",
            "",
            "        children_table = tables.LocationTable(children)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(children_table)",
            "",
            "        return {",
            "            \"children_table\": children_table,",
            "            \"rack_groups\": rack_groups,",
            "            \"stats\": stats,",
            "        }",
            "",
            "",
            "class LocationEditView(generic.ObjectEditView):",
            "    queryset = Location.objects.all()",
            "    model_form = forms.LocationForm",
            "    template_name = \"dcim/location_edit.html\"",
            "",
            "",
            "class LocationDeleteView(generic.ObjectDeleteView):",
            "    queryset = Location.objects.all()",
            "",
            "",
            "class LocationBulkEditView(generic.BulkEditView):",
            "    queryset = Location.objects.select_related(\"location_type\", \"parent\", \"site\", \"tenant\")",
            "    filterset = filters.LocationFilterSet",
            "    table = tables.LocationTable",
            "    form = forms.LocationBulkEditForm",
            "",
            "",
            "class LocationBulkImportView(generic.BulkImportView):",
            "    queryset = Location.objects.all()",
            "    model_form = forms.LocationCSVForm",
            "    table = tables.LocationTable",
            "",
            "",
            "class LocationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Location.objects.select_related(\"location_type\", \"parent\", \"site\", \"tenant\")",
            "    filterset = filters.LocationFilterSet",
            "    table = tables.LocationTable",
            "",
            "",
            "#",
            "# Rack groups",
            "#",
            "",
            "",
            "class RackGroupListView(generic.ObjectListView):",
            "    queryset = RackGroup.objects.add_related_count(",
            "        RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True",
            "    )",
            "    filterset = filters.RackGroupFilterSet",
            "    filterset_form = forms.RackGroupFilterForm",
            "    table = tables.RackGroupTable",
            "",
            "",
            "class RackGroupView(generic.ObjectView):",
            "    queryset = RackGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Racks",
            "        racks = (",
            "            Rack.objects.restrict(request.user, \"view\")",
            "            .filter(group__in=instance.get_descendants(include_self=True))",
            "            .select_related(\"role\", \"site\", \"tenant\")",
            "        )",
            "",
            "        rack_table = tables.RackTable(racks)",
            "        rack_table.columns.hide(\"group\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(rack_table)",
            "",
            "        return {",
            "            \"rack_table\": rack_table,",
            "        }",
            "",
            "",
            "class RackGroupEditView(generic.ObjectEditView):",
            "    queryset = RackGroup.objects.all()",
            "    model_form = forms.RackGroupForm",
            "",
            "",
            "class RackGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = RackGroup.objects.all()",
            "",
            "",
            "class RackGroupBulkImportView(generic.BulkImportView):",
            "    queryset = RackGroup.objects.all()",
            "    model_form = forms.RackGroupCSVForm",
            "    table = tables.RackGroupTable",
            "",
            "",
            "class RackGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RackGroup.objects.add_related_count(",
            "        RackGroup.objects.all(), Rack, \"group\", \"rack_count\", cumulative=True",
            "    ).select_related(\"site\")",
            "    filterset = filters.RackGroupFilterSet",
            "    table = tables.RackGroupTable",
            "",
            "",
            "#",
            "# Rack roles",
            "#",
            "",
            "",
            "class RackRoleListView(generic.ObjectListView):",
            "    queryset = RackRole.objects.annotate(rack_count=count_related(Rack, \"role\"))",
            "    filterset = filters.RackRoleFilterSet",
            "    table = tables.RackRoleTable",
            "",
            "",
            "class RackRoleView(generic.ObjectView):",
            "    queryset = RackRole.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Racks",
            "        racks = (",
            "            Rack.objects.restrict(request.user, \"view\").filter(role=instance).select_related(\"group\", \"site\", \"tenant\")",
            "        )",
            "",
            "        rack_table = tables.RackTable(racks)",
            "        rack_table.columns.hide(\"role\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(rack_table)",
            "",
            "        return {",
            "            \"rack_table\": rack_table,",
            "        }",
            "",
            "",
            "class RackRoleEditView(generic.ObjectEditView):",
            "    queryset = RackRole.objects.all()",
            "    model_form = forms.RackRoleForm",
            "",
            "",
            "class RackRoleDeleteView(generic.ObjectDeleteView):",
            "    queryset = RackRole.objects.all()",
            "",
            "",
            "class RackRoleBulkImportView(generic.BulkImportView):",
            "    queryset = RackRole.objects.all()",
            "    model_form = forms.RackRoleCSVForm",
            "    table = tables.RackRoleTable",
            "",
            "",
            "class RackRoleBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RackRole.objects.annotate(rack_count=count_related(Rack, \"role\"))",
            "    table = tables.RackRoleTable",
            "",
            "",
            "#",
            "# Racks",
            "#",
            "",
            "",
            "class RackListView(generic.ObjectListView):",
            "    queryset = (",
            "        Rack.objects.select_related(\"site\", \"group\", \"tenant\", \"role\")",
            "        .prefetch_related(\"devices__device_type\")",
            "        .annotate(device_count=count_related(Device, \"rack\"))",
            "    )",
            "    filterset = filters.RackFilterSet",
            "    filterset_form = forms.RackFilterForm",
            "    table = tables.RackDetailTable",
            "",
            "",
            "class RackElevationListView(generic.ObjectListView):",
            "    \"\"\"",
            "    Display a set of rack elevations side-by-side.",
            "    \"\"\"",
            "",
            "    queryset = Rack.objects.select_related(\"role\")",
            "    non_filter_params = (",
            "        *generic.ObjectListView.non_filter_params,",
            "        \"face\",  # render front or rear of racks?",
            "        \"reverse\",  # control of ordering",
            "    )",
            "    filterset = filters.RackFilterSet",
            "    action_buttons = []",
            "    template_name = \"dcim/rack_elevation_list.html\"",
            "",
            "    def extra_context(self):",
            "        racks = self.queryset",
            "        request = self.request",
            "        total_count = racks.count()",
            "",
            "        # Determine ordering",
            "        racks_reverse = bool(request.GET.get(\"reverse\", False))",
            "        if racks_reverse:",
            "            racks = racks.reverse()",
            "",
            "        # Pagination",
            "        per_page = get_paginate_count(request)",
            "        page_number = request.GET.get(\"page\", 1)",
            "        paginator = EnhancedPaginator(racks, per_page)",
            "        try:",
            "            page = paginator.page(page_number)",
            "        except PageNotAnInteger:",
            "            page = paginator.page(1)",
            "        except EmptyPage:",
            "            page = paginator.page(paginator.num_pages)",
            "",
            "        # Determine rack face",
            "        rack_face = request.GET.get(\"face\", DeviceFaceChoices.FACE_FRONT)",
            "        if rack_face not in DeviceFaceChoices.values():",
            "            rack_face = DeviceFaceChoices.FACE_FRONT",
            "",
            "        return {",
            "            \"paginator\": paginator,",
            "            \"page\": page,",
            "            \"total_count\": total_count,",
            "            \"reverse\": racks_reverse,",
            "            \"rack_face\": rack_face,",
            "            \"title\": \"Rack Elevation\",",
            "            \"list_url\": \"dcim:rack_elevation_list\",",
            "        }",
            "",
            "",
            "class RackView(generic.ObjectView):",
            "    queryset = Rack.objects.select_related(\"site__region\", \"tenant__group\", \"group\", \"role\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Get 0U and child devices located within the rack",
            "        nonracked_devices = Device.objects.filter(rack=instance, position__isnull=True).select_related(",
            "            \"device_type__manufacturer\"",
            "        )",
            "",
            "        peer_racks = Rack.objects.restrict(request.user, \"view\").filter(site=instance.site)",
            "",
            "        if instance.group:",
            "            peer_racks = peer_racks.filter(group=instance.group)",
            "        else:",
            "            peer_racks = peer_racks.filter(group__isnull=True)",
            "        next_rack = peer_racks.filter(name__gt=instance.name).order_by(\"name\").first()",
            "        prev_rack = peer_racks.filter(name__lt=instance.name).order_by(\"-name\").first()",
            "",
            "        reservations = RackReservation.objects.restrict(request.user, \"view\").filter(rack=instance)",
            "        power_feeds = (",
            "            PowerFeed.objects.restrict(request.user, \"view\").filter(rack=instance).select_related(\"power_panel\")",
            "        )",
            "",
            "        device_count = Device.objects.restrict(request.user, \"view\").filter(rack=instance).count()",
            "",
            "        return {",
            "            \"device_count\": device_count,",
            "            \"reservations\": reservations,",
            "            \"power_feeds\": power_feeds,",
            "            \"nonracked_devices\": nonracked_devices,",
            "            \"next_rack\": next_rack,",
            "            \"prev_rack\": prev_rack,",
            "        }",
            "",
            "",
            "class RackEditView(generic.ObjectEditView):",
            "    queryset = Rack.objects.all()",
            "    model_form = forms.RackForm",
            "    template_name = \"dcim/rack_edit.html\"",
            "",
            "",
            "class RackDeleteView(generic.ObjectDeleteView):",
            "    queryset = Rack.objects.all()",
            "",
            "",
            "class RackBulkImportView(generic.BulkImportView):",
            "    queryset = Rack.objects.all()",
            "    model_form = forms.RackCSVForm",
            "    table = tables.RackTable",
            "",
            "",
            "class RackBulkEditView(generic.BulkEditView):",
            "    queryset = Rack.objects.select_related(\"site\", \"group\", \"tenant\", \"role\")",
            "    filterset = filters.RackFilterSet",
            "    table = tables.RackTable",
            "    form = forms.RackBulkEditForm",
            "",
            "",
            "class RackBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Rack.objects.select_related(\"site\", \"group\", \"tenant\", \"role\")",
            "    filterset = filters.RackFilterSet",
            "    table = tables.RackTable",
            "",
            "",
            "#",
            "# Rack reservations",
            "#",
            "",
            "",
            "class RackReservationListView(generic.ObjectListView):",
            "    queryset = RackReservation.objects.all()",
            "    filterset = filters.RackReservationFilterSet",
            "    filterset_form = forms.RackReservationFilterForm",
            "    table = tables.RackReservationTable",
            "",
            "",
            "class RackReservationView(generic.ObjectView):",
            "    queryset = RackReservation.objects.select_related(\"rack\")",
            "",
            "",
            "class RackReservationEditView(generic.ObjectEditView):",
            "    queryset = RackReservation.objects.all()",
            "    model_form = forms.RackReservationForm",
            "    template_name = \"dcim/rackreservation_edit.html\"",
            "",
            "    def alter_obj(self, obj, request, args, kwargs):",
            "        if not obj.present_in_database:",
            "            if \"rack\" in request.GET:",
            "                obj.rack = get_object_or_404(Rack, pk=request.GET.get(\"rack\"))",
            "            obj.user = request.user",
            "        return obj",
            "",
            "",
            "class RackReservationDeleteView(generic.ObjectDeleteView):",
            "    queryset = RackReservation.objects.all()",
            "",
            "",
            "class RackReservationImportView(generic.BulkImportView):",
            "    queryset = RackReservation.objects.all()",
            "    model_form = forms.RackReservationCSVForm",
            "    table = tables.RackReservationTable",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        \"\"\"",
            "        Assign the currently authenticated user to the RackReservation.",
            "        \"\"\"",
            "        instance = obj_form.save(commit=False)",
            "        instance.user = request.user",
            "        instance.save()",
            "",
            "        return instance",
            "",
            "",
            "class RackReservationBulkEditView(generic.BulkEditView):",
            "    queryset = RackReservation.objects.select_related(\"rack\", \"user\")",
            "    filterset = filters.RackReservationFilterSet",
            "    table = tables.RackReservationTable",
            "    form = forms.RackReservationBulkEditForm",
            "",
            "",
            "class RackReservationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RackReservation.objects.select_related(\"rack\", \"user\")",
            "    filterset = filters.RackReservationFilterSet",
            "    table = tables.RackReservationTable",
            "",
            "",
            "#",
            "# Manufacturers",
            "#",
            "",
            "",
            "class ManufacturerListView(generic.ObjectListView):",
            "    queryset = Manufacturer.objects.annotate(",
            "        devicetype_count=count_related(DeviceType, \"manufacturer\"),",
            "        inventoryitem_count=count_related(InventoryItem, \"manufacturer\"),",
            "        platform_count=count_related(Platform, \"manufacturer\"),",
            "    )",
            "    filterset = filters.ManufacturerFilterSet",
            "    table = tables.ManufacturerTable",
            "",
            "",
            "class ManufacturerView(generic.ObjectView):",
            "    queryset = Manufacturer.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Devices",
            "        devices = (",
            "            Device.objects.restrict(request.user, \"view\")",
            "            .filter(device_type__manufacturer=instance)",
            "            .select_related(\"status\", \"site\", \"tenant\", \"device_role\", \"rack\", \"device_type\")",
            "        )",
            "",
            "        device_table = tables.DeviceTable(devices)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        return {",
            "            \"device_table\": device_table,",
            "        }",
            "",
            "",
            "class ManufacturerEditView(generic.ObjectEditView):",
            "    queryset = Manufacturer.objects.all()",
            "    model_form = forms.ManufacturerForm",
            "",
            "",
            "class ManufacturerDeleteView(generic.ObjectDeleteView):",
            "    queryset = Manufacturer.objects.all()",
            "",
            "",
            "class ManufacturerBulkImportView(generic.BulkImportView):",
            "    queryset = Manufacturer.objects.all()",
            "    model_form = forms.ManufacturerCSVForm",
            "    table = tables.ManufacturerTable",
            "",
            "",
            "class ManufacturerBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Manufacturer.objects.annotate(devicetype_count=count_related(DeviceType, \"manufacturer\"))",
            "    table = tables.ManufacturerTable",
            "",
            "",
            "#",
            "# Device types",
            "#",
            "",
            "",
            "class DeviceTypeListView(generic.ObjectListView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\").annotate(",
            "        instance_count=count_related(Device, \"device_type\")",
            "    )",
            "    filterset = filters.DeviceTypeFilterSet",
            "    filterset_form = forms.DeviceTypeFilterForm",
            "    table = tables.DeviceTypeTable",
            "",
            "",
            "class DeviceTypeView(generic.ObjectView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        instance_count = Device.objects.restrict(request.user).filter(device_type=instance).count()",
            "",
            "        # Component tables",
            "        consoleport_table = tables.ConsolePortTemplateTable(",
            "            ConsolePortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        consoleserverport_table = tables.ConsoleServerPortTemplateTable(",
            "            ConsoleServerPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        powerport_table = tables.PowerPortTemplateTable(",
            "            PowerPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        poweroutlet_table = tables.PowerOutletTemplateTable(",
            "            PowerOutletTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        interface_table = tables.InterfaceTemplateTable(",
            "            list(InterfaceTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance)),",
            "            orderable=False,",
            "        )",
            "        front_port_table = tables.FrontPortTemplateTable(",
            "            FrontPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        rear_port_table = tables.RearPortTemplateTable(",
            "            RearPortTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        devicebay_table = tables.DeviceBayTemplateTable(",
            "            DeviceBayTemplate.objects.restrict(request.user, \"view\").filter(device_type=instance),",
            "            orderable=False,",
            "        )",
            "        if request.user.has_perm(\"dcim.change_devicetype\"):",
            "            consoleport_table.columns.show(\"pk\")",
            "            consoleserverport_table.columns.show(\"pk\")",
            "            powerport_table.columns.show(\"pk\")",
            "            poweroutlet_table.columns.show(\"pk\")",
            "            interface_table.columns.show(\"pk\")",
            "            front_port_table.columns.show(\"pk\")",
            "            rear_port_table.columns.show(\"pk\")",
            "            devicebay_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"instance_count\": instance_count,",
            "            \"consoleport_table\": consoleport_table,",
            "            \"consoleserverport_table\": consoleserverport_table,",
            "            \"powerport_table\": powerport_table,",
            "            \"poweroutlet_table\": poweroutlet_table,",
            "            \"interface_table\": interface_table,",
            "            \"front_port_table\": front_port_table,",
            "            \"rear_port_table\": rear_port_table,",
            "            \"devicebay_table\": devicebay_table,",
            "        }",
            "",
            "",
            "class DeviceTypeEditView(generic.ObjectEditView):",
            "    queryset = DeviceType.objects.all()",
            "    model_form = forms.DeviceTypeForm",
            "    template_name = \"dcim/devicetype_edit.html\"",
            "",
            "",
            "class DeviceTypeDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceType.objects.all()",
            "",
            "",
            "class DeviceTypeImportView(generic.ObjectImportView):",
            "    additional_permissions = [",
            "        \"dcim.add_devicetype\",",
            "        \"dcim.add_consoleporttemplate\",",
            "        \"dcim.add_consoleserverporttemplate\",",
            "        \"dcim.add_powerporttemplate\",",
            "        \"dcim.add_poweroutlettemplate\",",
            "        \"dcim.add_interfacetemplate\",",
            "        \"dcim.add_frontporttemplate\",",
            "        \"dcim.add_rearporttemplate\",",
            "        \"dcim.add_devicebaytemplate\",",
            "    ]",
            "    queryset = DeviceType.objects.all()",
            "    model_form = forms.DeviceTypeImportForm",
            "    related_object_forms = OrderedDict(",
            "        (",
            "            (\"console-ports\", forms.ConsolePortTemplateImportForm),",
            "            (\"console-server-ports\", forms.ConsoleServerPortTemplateImportForm),",
            "            (\"power-ports\", forms.PowerPortTemplateImportForm),",
            "            (\"power-outlets\", forms.PowerOutletTemplateImportForm),",
            "            (\"interfaces\", forms.InterfaceTemplateImportForm),",
            "            (\"rear-ports\", forms.RearPortTemplateImportForm),",
            "            (\"front-ports\", forms.FrontPortTemplateImportForm),",
            "            (\"device-bays\", forms.DeviceBayTemplateImportForm),",
            "        )",
            "    )",
            "",
            "",
            "class DeviceTypeBulkEditView(generic.BulkEditView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\").annotate(",
            "        instance_count=count_related(Device, \"device_type\")",
            "    )",
            "    filterset = filters.DeviceTypeFilterSet",
            "    table = tables.DeviceTypeTable",
            "    form = forms.DeviceTypeBulkEditForm",
            "",
            "",
            "class DeviceTypeBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceType.objects.select_related(\"manufacturer\").annotate(",
            "        instance_count=count_related(Device, \"device_type\")",
            "    )",
            "    filterset = filters.DeviceTypeFilterSet",
            "    table = tables.DeviceTypeTable",
            "",
            "",
            "#",
            "# Console port templates",
            "#",
            "",
            "",
            "class ConsolePortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    form = forms.ConsolePortTemplateCreateForm",
            "    model_form = forms.ConsolePortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsolePortTemplateEditView(generic.ObjectEditView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    model_form = forms.ConsolePortTemplateForm",
            "",
            "",
            "class ConsolePortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "",
            "",
            "class ConsolePortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    table = tables.ConsolePortTemplateTable",
            "    form = forms.ConsolePortTemplateBulkEditForm",
            "",
            "",
            "class ConsolePortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "",
            "",
            "class ConsolePortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsolePortTemplate.objects.all()",
            "    table = tables.ConsolePortTemplateTable",
            "",
            "",
            "#",
            "# Console server port templates",
            "#",
            "",
            "",
            "class ConsoleServerPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    form = forms.ConsoleServerPortTemplateCreateForm",
            "    model_form = forms.ConsoleServerPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsoleServerPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    model_form = forms.ConsoleServerPortTemplateForm",
            "",
            "",
            "class ConsoleServerPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "",
            "",
            "class ConsoleServerPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    table = tables.ConsoleServerPortTemplateTable",
            "    form = forms.ConsoleServerPortTemplateBulkEditForm",
            "",
            "",
            "class ConsoleServerPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "",
            "",
            "class ConsoleServerPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsoleServerPortTemplate.objects.all()",
            "    table = tables.ConsoleServerPortTemplateTable",
            "",
            "",
            "#",
            "# Power port templates",
            "#",
            "",
            "",
            "class PowerPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    form = forms.PowerPortTemplateCreateForm",
            "    model_form = forms.PowerPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    model_form = forms.PowerPortTemplateForm",
            "",
            "",
            "class PowerPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "",
            "",
            "class PowerPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    table = tables.PowerPortTemplateTable",
            "    form = forms.PowerPortTemplateBulkEditForm",
            "",
            "",
            "class PowerPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "",
            "",
            "class PowerPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerPortTemplate.objects.all()",
            "    table = tables.PowerPortTemplateTable",
            "",
            "",
            "#",
            "# Power outlet templates",
            "#",
            "",
            "",
            "class PowerOutletTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    form = forms.PowerOutletTemplateCreateForm",
            "    model_form = forms.PowerOutletTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerOutletTemplateEditView(generic.ObjectEditView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    model_form = forms.PowerOutletTemplateForm",
            "",
            "",
            "class PowerOutletTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "",
            "",
            "class PowerOutletTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    table = tables.PowerOutletTemplateTable",
            "    form = forms.PowerOutletTemplateBulkEditForm",
            "",
            "",
            "class PowerOutletTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "",
            "",
            "class PowerOutletTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerOutletTemplate.objects.all()",
            "    table = tables.PowerOutletTemplateTable",
            "",
            "",
            "#",
            "# Interface templates",
            "#",
            "",
            "",
            "class InterfaceTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    form = forms.InterfaceTemplateCreateForm",
            "    model_form = forms.InterfaceTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class InterfaceTemplateEditView(generic.ObjectEditView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    model_form = forms.InterfaceTemplateForm",
            "",
            "",
            "class InterfaceTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "",
            "",
            "class InterfaceTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    table = tables.InterfaceTemplateTable",
            "    form = forms.InterfaceTemplateBulkEditForm",
            "",
            "",
            "class InterfaceTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "",
            "",
            "class InterfaceTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = InterfaceTemplate.objects.all()",
            "    table = tables.InterfaceTemplateTable",
            "",
            "",
            "#",
            "# Front port templates",
            "#",
            "",
            "",
            "class FrontPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    form = forms.FrontPortTemplateCreateForm",
            "    model_form = forms.FrontPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class FrontPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    model_form = forms.FrontPortTemplateForm",
            "",
            "",
            "class FrontPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "",
            "",
            "class FrontPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    table = tables.FrontPortTemplateTable",
            "    form = forms.FrontPortTemplateBulkEditForm",
            "",
            "",
            "class FrontPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "",
            "",
            "class FrontPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = FrontPortTemplate.objects.all()",
            "    table = tables.FrontPortTemplateTable",
            "",
            "",
            "#",
            "# Rear port templates",
            "#",
            "",
            "",
            "class RearPortTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    form = forms.RearPortTemplateCreateForm",
            "    model_form = forms.RearPortTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class RearPortTemplateEditView(generic.ObjectEditView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    model_form = forms.RearPortTemplateForm",
            "",
            "",
            "class RearPortTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = RearPortTemplate.objects.all()",
            "",
            "",
            "class RearPortTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    table = tables.RearPortTemplateTable",
            "    form = forms.RearPortTemplateBulkEditForm",
            "",
            "",
            "class RearPortTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = RearPortTemplate.objects.all()",
            "",
            "",
            "class RearPortTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RearPortTemplate.objects.all()",
            "    table = tables.RearPortTemplateTable",
            "",
            "",
            "#",
            "# Device bay templates",
            "#",
            "",
            "",
            "class DeviceBayTemplateCreateView(generic.ComponentCreateView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    form = forms.DeviceBayTemplateCreateForm",
            "    model_form = forms.DeviceBayTemplateForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class DeviceBayTemplateEditView(generic.ObjectEditView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    model_form = forms.DeviceBayTemplateForm",
            "",
            "",
            "class DeviceBayTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "",
            "",
            "class DeviceBayTemplateBulkEditView(generic.BulkEditView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    table = tables.DeviceBayTemplateTable",
            "    form = forms.DeviceBayTemplateBulkEditForm",
            "",
            "",
            "class DeviceBayTemplateBulkRenameView(generic.BulkRenameView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "",
            "",
            "class DeviceBayTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceBayTemplate.objects.all()",
            "    table = tables.DeviceBayTemplateTable",
            "",
            "",
            "#",
            "# Device roles",
            "#",
            "",
            "",
            "class DeviceRoleListView(generic.ObjectListView):",
            "    queryset = DeviceRole.objects.annotate(",
            "        device_count=count_related(Device, \"device_role\"),",
            "        vm_count=count_related(VirtualMachine, \"role\"),",
            "    )",
            "    filterset = filters.DeviceRoleFilterSet",
            "    table = tables.DeviceRoleTable",
            "",
            "",
            "class DeviceRoleView(generic.ObjectView):",
            "    queryset = DeviceRole.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Devices",
            "        devices = (",
            "            Device.objects.restrict(request.user, \"view\")",
            "            .filter(device_role=instance)",
            "            .select_related(\"status\", \"site\", \"tenant\", \"rack\", \"device_type\")",
            "        )",
            "",
            "        device_table = tables.DeviceTable(devices)",
            "        device_table.columns.hide(\"device_role\")",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        return {",
            "            \"device_table\": device_table,",
            "        }",
            "",
            "",
            "class DeviceRoleEditView(generic.ObjectEditView):",
            "    queryset = DeviceRole.objects.all()",
            "    model_form = forms.DeviceRoleForm",
            "",
            "",
            "class DeviceRoleDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceRole.objects.all()",
            "",
            "",
            "class DeviceRoleBulkImportView(generic.BulkImportView):",
            "    queryset = DeviceRole.objects.all()",
            "    model_form = forms.DeviceRoleCSVForm",
            "    table = tables.DeviceRoleTable",
            "",
            "",
            "class DeviceRoleBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceRole.objects.all()",
            "    table = tables.DeviceRoleTable",
            "",
            "",
            "#",
            "# Platforms",
            "#",
            "",
            "",
            "class PlatformListView(generic.ObjectListView):",
            "    queryset = Platform.objects.annotate(",
            "        device_count=count_related(Device, \"platform\"),",
            "        vm_count=count_related(VirtualMachine, \"platform\"),",
            "    )",
            "    filterset = filters.PlatformFilterSet",
            "    table = tables.PlatformTable",
            "",
            "",
            "class PlatformView(generic.ObjectView):",
            "    queryset = Platform.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Devices",
            "        devices = (",
            "            Device.objects.restrict(request.user, \"view\")",
            "            .filter(platform=instance)",
            "            .select_related(\"status\", \"site\", \"tenant\", \"rack\", \"device_type\", \"device_role\")",
            "        )",
            "",
            "        device_table = tables.DeviceTable(devices)",
            "",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        return {",
            "            \"device_table\": device_table,",
            "            \"network_driver_tool_names\": get_network_driver_mapping_tool_names(),",
            "        }",
            "",
            "",
            "class PlatformEditView(generic.ObjectEditView):",
            "    queryset = Platform.objects.all()",
            "    model_form = forms.PlatformForm",
            "    template_name = \"dcim/platform_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"network_driver_names\": sorted(get_all_network_driver_mappings().keys())}",
            "",
            "",
            "class PlatformDeleteView(generic.ObjectDeleteView):",
            "    queryset = Platform.objects.all()",
            "",
            "",
            "class PlatformBulkImportView(generic.BulkImportView):",
            "    queryset = Platform.objects.all()",
            "    model_form = forms.PlatformCSVForm",
            "    table = tables.PlatformTable",
            "",
            "",
            "class PlatformBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Platform.objects.all()",
            "    table = tables.PlatformTable",
            "",
            "",
            "#",
            "# Devices",
            "#",
            "",
            "",
            "class DeviceListView(generic.ObjectListView):",
            "    queryset = Device.objects.all()",
            "    filterset = filters.DeviceFilterSet",
            "    filterset_form = forms.DeviceFilterForm",
            "    table = tables.DeviceTable",
            "    template_name = \"dcim/device_list.html\"",
            "",
            "",
            "class DeviceView(generic.ObjectView):",
            "    queryset = Device.objects.select_related(",
            "        \"site__region\",",
            "        \"rack__group\",",
            "        \"tenant__group\",",
            "        \"device_role\",",
            "        \"platform\",",
            "        \"primary_ip4\",",
            "        \"primary_ip6\",",
            "        \"status\",",
            "    )",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # VirtualChassis members",
            "        if instance.virtual_chassis is not None:",
            "            vc_members = (",
            "                Device.objects.restrict(request.user, \"view\")",
            "                .filter(virtual_chassis=instance.virtual_chassis)",
            "                .order_by(\"vc_position\")",
            "            )",
            "        else:",
            "            vc_members = []",
            "",
            "        # Services",
            "        services = Service.objects.restrict(request.user, \"view\").filter(device=instance)",
            "",
            "        return {",
            "            \"services\": services,",
            "            \"vc_members\": vc_members,",
            "            \"active_tab\": \"device\",",
            "        }",
            "",
            "",
            "class DeviceConsolePortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/consoleports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        consoleports = (",
            "            ConsolePort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        consoleport_table = tables.DeviceConsolePortTable(data=consoleports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_consoleport\") or request.user.has_perm(\"dcim.delete_consoleport\"):",
            "            consoleport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"consoleport_table\": consoleport_table,",
            "            \"active_tab\": \"console-ports\",",
            "        }",
            "",
            "",
            "class DeviceConsoleServerPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/consoleserverports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        consoleserverports = (",
            "            ConsoleServerPort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        consoleserverport_table = tables.DeviceConsoleServerPortTable(",
            "            data=consoleserverports, user=request.user, orderable=False",
            "        )",
            "        if request.user.has_perm(\"dcim.change_consoleserverport\") or request.user.has_perm(",
            "            \"dcim.delete_consoleserverport\"",
            "        ):",
            "            consoleserverport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"consoleserverport_table\": consoleserverport_table,",
            "            \"active_tab\": \"console-server-ports\",",
            "        }",
            "",
            "",
            "class DevicePowerPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/powerports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        powerports = (",
            "            PowerPort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        powerport_table = tables.DevicePowerPortTable(data=powerports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_powerport\") or request.user.has_perm(\"dcim.delete_powerport\"):",
            "            powerport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"powerport_table\": powerport_table,",
            "            \"active_tab\": \"power-ports\",",
            "        }",
            "",
            "",
            "class DevicePowerOutletsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/poweroutlets.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        poweroutlets = (",
            "            PowerOutlet.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\", \"power_port\")",
            "            .prefetch_related(\"_path__destination\")",
            "        )",
            "        poweroutlet_table = tables.DevicePowerOutletTable(data=poweroutlets, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_poweroutlet\") or request.user.has_perm(\"dcim.delete_poweroutlet\"):",
            "            poweroutlet_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"poweroutlet_table\": poweroutlet_table,",
            "            \"active_tab\": \"power-outlets\",",
            "        }",
            "",
            "",
            "class DeviceInterfacesView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/interfaces.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        interfaces = (",
            "            instance.vc_interfaces.restrict(request.user, \"view\")",
            "            .prefetch_related(",
            "                Prefetch(\"ip_addresses\", queryset=IPAddress.objects.restrict(request.user)),",
            "                Prefetch(\"member_interfaces\", queryset=Interface.objects.restrict(request.user)),",
            "                \"_path__destination\",",
            "                \"tags\",",
            "            )",
            "            .select_related(\"lag\", \"cable\")",
            "        )",
            "        interface_table = tables.DeviceInterfaceTable(data=interfaces, user=request.user, orderable=False)",
            "        if VirtualChassis.objects.filter(master=instance).exists():",
            "            interface_table.columns.show(\"device\")",
            "        if request.user.has_perm(\"dcim.change_interface\") or request.user.has_perm(\"dcim.delete_interface\"):",
            "            interface_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"interface_table\": interface_table,",
            "            \"active_tab\": \"interfaces\",",
            "        }",
            "",
            "",
            "class DeviceFrontPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/frontports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        frontports = (",
            "            FrontPort.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(\"cable\", \"rear_port\")",
            "        )",
            "        frontport_table = tables.DeviceFrontPortTable(data=frontports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_frontport\") or request.user.has_perm(\"dcim.delete_frontport\"):",
            "            frontport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"frontport_table\": frontport_table,",
            "            \"active_tab\": \"front-ports\",",
            "        }",
            "",
            "",
            "class DeviceRearPortsView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/rearports.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        rearports = RearPort.objects.restrict(request.user, \"view\").filter(device=instance).select_related(\"cable\")",
            "        rearport_table = tables.DeviceRearPortTable(data=rearports, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_rearport\") or request.user.has_perm(\"dcim.delete_rearport\"):",
            "            rearport_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"rearport_table\": rearport_table,",
            "            \"active_tab\": \"rear-ports\",",
            "        }",
            "",
            "",
            "class DeviceDeviceBaysView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/devicebays.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        devicebays = (",
            "            DeviceBay.objects.restrict(request.user, \"view\")",
            "            .filter(device=instance)",
            "            .select_related(",
            "                \"installed_device__device_type__manufacturer\",",
            "            )",
            "        )",
            "        devicebay_table = tables.DeviceDeviceBayTable(data=devicebays, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_devicebay\") or request.user.has_perm(\"dcim.delete_devicebay\"):",
            "            devicebay_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"devicebay_table\": devicebay_table,",
            "            \"active_tab\": \"device-bays\",",
            "        }",
            "",
            "",
            "class DeviceInventoryView(generic.ObjectView):",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/inventory.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        inventoryitems = (",
            "            InventoryItem.objects.restrict(request.user, \"view\").filter(device=instance).select_related(\"manufacturer\")",
            "        )",
            "        inventoryitem_table = tables.DeviceInventoryItemTable(data=inventoryitems, user=request.user, orderable=False)",
            "        if request.user.has_perm(\"dcim.change_inventoryitem\") or request.user.has_perm(\"dcim.delete_inventoryitem\"):",
            "            inventoryitem_table.columns.show(\"pk\")",
            "",
            "        return {",
            "            \"inventoryitem_table\": inventoryitem_table,",
            "            \"active_tab\": \"inventory\",",
            "        }",
            "",
            "",
            "class DeviceStatusView(generic.ObjectView):",
            "    additional_permissions = [\"dcim.napalm_read_device\"]",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/status.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"active_tab\": \"status\",",
            "        }",
            "",
            "",
            "class DeviceLLDPNeighborsView(generic.ObjectView):",
            "    additional_permissions = [\"dcim.napalm_read_device\"]",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/lldp_neighbors.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        interfaces = (",
            "            instance.vc_interfaces.restrict(request.user, \"view\")",
            "            .prefetch_related(\"_path__destination\")",
            "            .exclude(type__in=NONCONNECTABLE_IFACE_TYPES)",
            "        )",
            "",
            "        return {",
            "            \"interfaces\": interfaces,",
            "            \"active_tab\": \"lldp-neighbors\",",
            "        }",
            "",
            "",
            "class DeviceConfigView(generic.ObjectView):",
            "    additional_permissions = [\"dcim.napalm_read_device\"]",
            "    queryset = Device.objects.all()",
            "    template_name = \"dcim/device/config.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"active_tab\": \"config\",",
            "        }",
            "",
            "",
            "class DeviceConfigContextView(ObjectConfigContextView):",
            "    queryset = Device.objects.annotate_config_context_data()",
            "    base_template = \"dcim/device/base.html\"",
            "",
            "",
            "class DeviceChangeLogView(ObjectChangeLogView):",
            "    base_template = \"dcim/device/base.html\"",
            "",
            "",
            "class DeviceDynamicGroupsView(ObjectDynamicGroupsView):",
            "    base_template = \"dcim/device/base.html\"",
            "",
            "",
            "class DeviceEditView(generic.ObjectEditView):",
            "    queryset = Device.objects.all()",
            "    model_form = forms.DeviceForm",
            "    template_name = \"dcim/device_edit.html\"",
            "",
            "",
            "class DeviceDeleteView(generic.ObjectDeleteView):",
            "    queryset = Device.objects.all()",
            "",
            "",
            "class DeviceBulkImportView(generic.BulkImportView):",
            "    queryset = Device.objects.all()",
            "    model_form = forms.DeviceCSVForm",
            "    table = tables.DeviceImportTable",
            "    template_name = \"dcim/device_import.html\"",
            "",
            "",
            "class ChildDeviceBulkImportView(generic.BulkImportView):",
            "    queryset = Device.objects.all()",
            "    model_form = forms.ChildDeviceCSVForm",
            "    table = tables.DeviceImportTable",
            "    template_name = \"dcim/device_import_child.html\"",
            "",
            "    def _save_obj(self, obj_form, request):",
            "        obj = obj_form.save()",
            "",
            "        # Save the reverse relation to the parent device bay",
            "        device_bay = obj.parent_bay",
            "        device_bay.installed_device = obj",
            "        device_bay.save()",
            "",
            "        return obj",
            "",
            "",
            "class DeviceBulkEditView(generic.BulkEditView):",
            "    queryset = Device.objects.select_related(",
            "        \"tenant\", \"site\", \"rack\", \"device_role\", \"device_type__manufacturer\", \"secrets_group\", \"device_redundancy_group\"",
            "    )",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    form = forms.DeviceBulkEditForm",
            "",
            "",
            "class DeviceBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Device.objects.select_related(\"tenant\", \"site\", \"rack\", \"device_role\", \"device_type__manufacturer\")",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "",
            "",
            "#",
            "# Console ports",
            "#",
            "",
            "",
            "class ConsolePortListView(generic.ObjectListView):",
            "    queryset = ConsolePort.objects.all()",
            "    filterset = filters.ConsolePortFilterSet",
            "    filterset_form = forms.ConsolePortFilterForm",
            "    table = tables.ConsolePortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class ConsolePortView(generic.ObjectView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_consoleports\"}",
            "",
            "",
            "class ConsolePortCreateView(generic.ComponentCreateView):",
            "    queryset = ConsolePort.objects.all()",
            "    form = forms.ConsolePortCreateForm",
            "    model_form = forms.ConsolePortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsolePortEditView(generic.ObjectEditView):",
            "    queryset = ConsolePort.objects.all()",
            "    model_form = forms.ConsolePortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class ConsolePortDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "",
            "class ConsolePortBulkImportView(generic.BulkImportView):",
            "    queryset = ConsolePort.objects.all()",
            "    model_form = forms.ConsolePortCSVForm",
            "    table = tables.ConsolePortTable",
            "",
            "",
            "class ConsolePortBulkEditView(generic.BulkEditView):",
            "    queryset = ConsolePort.objects.all()",
            "    filterset = filters.ConsolePortFilterSet",
            "    table = tables.ConsolePortTable",
            "    form = forms.ConsolePortBulkEditForm",
            "",
            "",
            "class ConsolePortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "",
            "class ConsolePortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = ConsolePort.objects.all()",
            "",
            "",
            "class ConsolePortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsolePort.objects.all()",
            "    filterset = filters.ConsolePortFilterSet",
            "    table = tables.ConsolePortTable",
            "",
            "",
            "#",
            "# Console server ports",
            "#",
            "",
            "",
            "class ConsoleServerPortListView(generic.ObjectListView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    filterset = filters.ConsoleServerPortFilterSet",
            "    filterset_form = forms.ConsoleServerPortFilterForm",
            "    table = tables.ConsoleServerPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class ConsoleServerPortView(generic.ObjectView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_consoleserverports\"}",
            "",
            "",
            "class ConsoleServerPortCreateView(generic.ComponentCreateView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    form = forms.ConsoleServerPortCreateForm",
            "    model_form = forms.ConsoleServerPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class ConsoleServerPortEditView(generic.ObjectEditView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    model_form = forms.ConsoleServerPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class ConsoleServerPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "",
            "class ConsoleServerPortBulkImportView(generic.BulkImportView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    model_form = forms.ConsoleServerPortCSVForm",
            "    table = tables.ConsoleServerPortTable",
            "",
            "",
            "class ConsoleServerPortBulkEditView(generic.BulkEditView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    filterset = filters.ConsoleServerPortFilterSet",
            "    table = tables.ConsoleServerPortTable",
            "    form = forms.ConsoleServerPortBulkEditForm",
            "",
            "",
            "class ConsoleServerPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "",
            "class ConsoleServerPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "",
            "",
            "class ConsoleServerPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConsoleServerPort.objects.all()",
            "    filterset = filters.ConsoleServerPortFilterSet",
            "    table = tables.ConsoleServerPortTable",
            "",
            "",
            "#",
            "# Power ports",
            "#",
            "",
            "",
            "class PowerPortListView(generic.ObjectListView):",
            "    queryset = PowerPort.objects.all()",
            "    filterset = filters.PowerPortFilterSet",
            "    filterset_form = forms.PowerPortFilterForm",
            "    table = tables.PowerPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class PowerPortView(generic.ObjectView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_powerports\"}",
            "",
            "",
            "class PowerPortCreateView(generic.ComponentCreateView):",
            "    queryset = PowerPort.objects.all()",
            "    form = forms.PowerPortCreateForm",
            "    model_form = forms.PowerPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerPortEditView(generic.ObjectEditView):",
            "    queryset = PowerPort.objects.all()",
            "    model_form = forms.PowerPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class PowerPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "",
            "class PowerPortBulkImportView(generic.BulkImportView):",
            "    queryset = PowerPort.objects.all()",
            "    model_form = forms.PowerPortCSVForm",
            "    table = tables.PowerPortTable",
            "",
            "",
            "class PowerPortBulkEditView(generic.BulkEditView):",
            "    queryset = PowerPort.objects.all()",
            "    filterset = filters.PowerPortFilterSet",
            "    table = tables.PowerPortTable",
            "    form = forms.PowerPortBulkEditForm",
            "",
            "",
            "class PowerPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "",
            "class PowerPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = PowerPort.objects.all()",
            "",
            "",
            "class PowerPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerPort.objects.all()",
            "    filterset = filters.PowerPortFilterSet",
            "    table = tables.PowerPortTable",
            "",
            "",
            "#",
            "# Power outlets",
            "#",
            "",
            "",
            "class PowerOutletListView(generic.ObjectListView):",
            "    queryset = PowerOutlet.objects.all()",
            "    filterset = filters.PowerOutletFilterSet",
            "    filterset_form = forms.PowerOutletFilterForm",
            "    table = tables.PowerOutletTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class PowerOutletView(generic.ObjectView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_poweroutlets\"}",
            "",
            "",
            "class PowerOutletCreateView(generic.ComponentCreateView):",
            "    queryset = PowerOutlet.objects.all()",
            "    form = forms.PowerOutletCreateForm",
            "    model_form = forms.PowerOutletForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class PowerOutletEditView(generic.ObjectEditView):",
            "    queryset = PowerOutlet.objects.all()",
            "    model_form = forms.PowerOutletForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class PowerOutletDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "",
            "class PowerOutletBulkImportView(generic.BulkImportView):",
            "    queryset = PowerOutlet.objects.all()",
            "    model_form = forms.PowerOutletCSVForm",
            "    table = tables.PowerOutletTable",
            "",
            "",
            "class PowerOutletBulkEditView(generic.BulkEditView):",
            "    queryset = PowerOutlet.objects.all()",
            "    filterset = filters.PowerOutletFilterSet",
            "    table = tables.PowerOutletTable",
            "    form = forms.PowerOutletBulkEditForm",
            "",
            "",
            "class PowerOutletBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "",
            "class PowerOutletBulkDisconnectView(BulkDisconnectView):",
            "    queryset = PowerOutlet.objects.all()",
            "",
            "",
            "class PowerOutletBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerOutlet.objects.all()",
            "    filterset = filters.PowerOutletFilterSet",
            "    table = tables.PowerOutletTable",
            "",
            "",
            "#",
            "# Interfaces",
            "#",
            "",
            "",
            "class InterfaceListView(generic.ObjectListView):",
            "    queryset = Interface.objects.all()",
            "    filterset = filters.InterfaceFilterSet",
            "    filterset_form = forms.InterfaceFilterForm",
            "    table = tables.InterfaceTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class InterfaceView(generic.ObjectView):",
            "    queryset = Interface.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Get assigned IP addresses",
            "        ipaddress_table = InterfaceIPAddressTable(",
            "            data=instance.ip_addresses.restrict(request.user, \"view\").select_related(\"vrf\", \"tenant\"),",
            "            orderable=False,",
            "        )",
            "",
            "        # Get child interfaces",
            "        child_interfaces = instance.child_interfaces.restrict(request.user, \"view\")",
            "        child_interfaces_tables = tables.InterfaceTable(child_interfaces, orderable=False, exclude=(\"device\",))",
            "",
            "        # Get assigned VLANs and annotate whether each is tagged or untagged",
            "        vlans = []",
            "        if instance.untagged_vlan is not None:",
            "            vlans.append(instance.untagged_vlan)",
            "            vlans[0].tagged = False",
            "",
            "        for vlan in instance.tagged_vlans.restrict(request.user).select_related(\"site\", \"group\", \"tenant\", \"role\"):",
            "            vlan.tagged = True",
            "            vlans.append(vlan)",
            "        vlan_table = InterfaceVLANTable(interface=instance, data=vlans, orderable=False)",
            "",
            "        redundancy_table = self._get_interface_redundancy_groups_table(request, instance)",
            "",
            "        return {",
            "            \"ipaddress_table\": ipaddress_table,",
            "            \"vlan_table\": vlan_table,",
            "            \"breadcrumb_url\": \"dcim:device_interfaces\",",
            "            \"child_interfaces_table\": child_interfaces_tables,",
            "            \"redundancy_table\": redundancy_table,",
            "        }",
            "",
            "    def _get_interface_redundancy_groups_table(self, request, instance):",
            "        \"\"\"Return a table of assigned Interface Redundancy Groups.\"\"\"",
            "        queryset = instance.interface_redundancy_group_associations.restrict(request.user)",
            "        queryset = queryset.select_related(\"interface_redundancy_group\")",
            "        queryset = queryset.order_by(\"interface_redundancy_group\", \"priority\")",
            "        column_sequence = (",
            "            \"interface_redundancy_group\",",
            "            \"priority\",",
            "            \"interface_redundancy_group__status\",",
            "            \"interface_redundancy_group__protocol\",",
            "            \"interface_redundancy_group__protocol_group_id\",",
            "            \"interface_redundancy_group__virtual_ip\",",
            "        )",
            "        table = tables.InterfaceRedundancyGroupAssociationTable(",
            "            data=queryset,",
            "            sequence=column_sequence,",
            "            orderable=False,",
            "        )",
            "        for field in column_sequence:",
            "            table.columns.show(field)",
            "        return table",
            "",
            "",
            "class InterfaceCreateView(generic.ComponentCreateView):",
            "    queryset = Interface.objects.all()",
            "    form = forms.InterfaceCreateForm",
            "    model_form = forms.InterfaceForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class InterfaceEditView(generic.ObjectEditView):",
            "    queryset = Interface.objects.all()",
            "    model_form = forms.InterfaceForm",
            "    template_name = \"dcim/interface_edit.html\"",
            "",
            "",
            "class InterfaceDeleteView(generic.ObjectDeleteView):",
            "    queryset = Interface.objects.all()",
            "    template_name = \"dcim/device_interface_delete.html\"",
            "",
            "",
            "class InterfaceBulkImportView(generic.BulkImportView):",
            "    queryset = Interface.objects.all()",
            "    model_form = forms.InterfaceCSVForm",
            "    table = tables.InterfaceTable",
            "",
            "",
            "class InterfaceBulkEditView(generic.BulkEditView):",
            "    queryset = Interface.objects.all()",
            "    filterset = filters.InterfaceFilterSet",
            "    table = tables.InterfaceTable",
            "    form = forms.InterfaceBulkEditForm",
            "",
            "",
            "class InterfaceBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = Interface.objects.all()",
            "",
            "",
            "class InterfaceBulkDisconnectView(BulkDisconnectView):",
            "    queryset = Interface.objects.all()",
            "",
            "",
            "class InterfaceBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Interface.objects.all()",
            "    filterset = filters.InterfaceFilterSet",
            "    table = tables.InterfaceTable",
            "    template_name = \"dcim/interface_bulk_delete.html\"",
            "",
            "",
            "#",
            "# Front ports",
            "#",
            "",
            "",
            "class FrontPortListView(generic.ObjectListView):",
            "    queryset = FrontPort.objects.all()",
            "    filterset = filters.FrontPortFilterSet",
            "    filterset_form = forms.FrontPortFilterForm",
            "    table = tables.FrontPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class FrontPortView(generic.ObjectView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_frontports\"}",
            "",
            "",
            "class FrontPortCreateView(generic.ComponentCreateView):",
            "    queryset = FrontPort.objects.all()",
            "    form = forms.FrontPortCreateForm",
            "    model_form = forms.FrontPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class FrontPortEditView(generic.ObjectEditView):",
            "    queryset = FrontPort.objects.all()",
            "    model_form = forms.FrontPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class FrontPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "",
            "class FrontPortBulkImportView(generic.BulkImportView):",
            "    queryset = FrontPort.objects.all()",
            "    model_form = forms.FrontPortCSVForm",
            "    table = tables.FrontPortTable",
            "",
            "",
            "class FrontPortBulkEditView(generic.BulkEditView):",
            "    queryset = FrontPort.objects.all()",
            "    filterset = filters.FrontPortFilterSet",
            "    table = tables.FrontPortTable",
            "    form = forms.FrontPortBulkEditForm",
            "",
            "",
            "class FrontPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "",
            "class FrontPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = FrontPort.objects.all()",
            "",
            "",
            "class FrontPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = FrontPort.objects.all()",
            "    filterset = filters.FrontPortFilterSet",
            "    table = tables.FrontPortTable",
            "",
            "",
            "#",
            "# Rear ports",
            "#",
            "",
            "",
            "class RearPortListView(generic.ObjectListView):",
            "    queryset = RearPort.objects.all()",
            "    filterset = filters.RearPortFilterSet",
            "    filterset_form = forms.RearPortFilterForm",
            "    table = tables.RearPortTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class RearPortView(generic.ObjectView):",
            "    queryset = RearPort.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_rearports\"}",
            "",
            "",
            "class RearPortCreateView(generic.ComponentCreateView):",
            "    queryset = RearPort.objects.all()",
            "    form = forms.RearPortCreateForm",
            "    model_form = forms.RearPortForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class RearPortEditView(generic.ObjectEditView):",
            "    queryset = RearPort.objects.all()",
            "    model_form = forms.RearPortForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class RearPortDeleteView(generic.ObjectDeleteView):",
            "    queryset = RearPort.objects.all()",
            "",
            "",
            "class RearPortBulkImportView(generic.BulkImportView):",
            "    queryset = RearPort.objects.all()",
            "    model_form = forms.RearPortCSVForm",
            "    table = tables.RearPortTable",
            "",
            "",
            "class RearPortBulkEditView(generic.BulkEditView):",
            "    queryset = RearPort.objects.all()",
            "    filterset = filters.RearPortFilterSet",
            "    table = tables.RearPortTable",
            "    form = forms.RearPortBulkEditForm",
            "",
            "",
            "class RearPortBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = RearPort.objects.all()",
            "",
            "",
            "class RearPortBulkDisconnectView(BulkDisconnectView):",
            "    queryset = RearPort.objects.all()",
            "",
            "",
            "class RearPortBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RearPort.objects.all()",
            "    filterset = filters.RearPortFilterSet",
            "    table = tables.RearPortTable",
            "",
            "",
            "#",
            "# Device bays",
            "#",
            "",
            "",
            "class DeviceBayListView(generic.ObjectListView):",
            "    queryset = DeviceBay.objects.all()",
            "    filterset = filters.DeviceBayFilterSet",
            "    filterset_form = forms.DeviceBayFilterForm",
            "    table = tables.DeviceBayTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class DeviceBayView(generic.ObjectView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_devicebays\"}",
            "",
            "",
            "class DeviceBayCreateView(generic.ComponentCreateView):",
            "    queryset = DeviceBay.objects.all()",
            "    form = forms.DeviceBayCreateForm",
            "    model_form = forms.DeviceBayForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class DeviceBayEditView(generic.ObjectEditView):",
            "    queryset = DeviceBay.objects.all()",
            "    model_form = forms.DeviceBayForm",
            "    template_name = \"dcim/device_component_edit.html\"",
            "",
            "",
            "class DeviceBayDeleteView(generic.ObjectDeleteView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "",
            "class DeviceBayPopulateView(generic.ObjectEditView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = forms.PopulateDeviceBayForm(device_bay)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_populate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = forms.PopulateDeviceBayForm(device_bay, request.POST)",
            "",
            "        if form.is_valid():",
            "            device_bay.installed_device = form.cleaned_data[\"installed_device\"]",
            "            device_bay.save()",
            "            messages.success(",
            "                request,",
            "                f\"Added {device_bay.installed_device} to {device_bay}.\",",
            "            )",
            "",
            "            return redirect(\"dcim:device\", pk=device_bay.device.pk)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_populate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "",
            "class DeviceBayDepopulateView(generic.ObjectEditView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = ConfirmationForm()",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_depopulate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        device_bay = get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            removed_device = device_bay.installed_device",
            "            device_bay.installed_device = None",
            "            device_bay.save()",
            "            messages.success(",
            "                request,",
            "                f\"Removed {removed_device} from {device_bay}.\",",
            "            )",
            "",
            "            return redirect(\"dcim:device\", pk=device_bay.device.pk)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/devicebay_depopulate.html\",",
            "            {",
            "                \"device_bay\": device_bay,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device_bay),",
            "            },",
            "        )",
            "",
            "",
            "class DeviceBayBulkImportView(generic.BulkImportView):",
            "    queryset = DeviceBay.objects.all()",
            "    model_form = forms.DeviceBayCSVForm",
            "    table = tables.DeviceBayTable",
            "",
            "",
            "class DeviceBayBulkEditView(generic.BulkEditView):",
            "    queryset = DeviceBay.objects.all()",
            "    filterset = filters.DeviceBayFilterSet",
            "    table = tables.DeviceBayTable",
            "    form = forms.DeviceBayBulkEditForm",
            "",
            "",
            "class DeviceBayBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = DeviceBay.objects.all()",
            "",
            "",
            "class DeviceBayBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DeviceBay.objects.all()",
            "    filterset = filters.DeviceBayFilterSet",
            "    table = tables.DeviceBayTable",
            "",
            "",
            "#",
            "# Inventory items",
            "#",
            "",
            "",
            "class InventoryItemListView(generic.ObjectListView):",
            "    queryset = InventoryItem.objects.all()",
            "    filterset = filters.InventoryItemFilterSet",
            "    filterset_form = forms.InventoryItemFilterForm",
            "    table = tables.InventoryItemTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class InventoryItemView(generic.ObjectView):",
            "    queryset = InventoryItem.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"breadcrumb_url\": \"dcim:device_inventory\"}",
            "",
            "",
            "class InventoryItemEditView(generic.ObjectEditView):",
            "    queryset = InventoryItem.objects.all()",
            "    model_form = forms.InventoryItemForm",
            "",
            "",
            "class InventoryItemCreateView(generic.ComponentCreateView):",
            "    queryset = InventoryItem.objects.all()",
            "    form = forms.InventoryItemCreateForm",
            "    model_form = forms.InventoryItemForm",
            "    template_name = \"dcim/device_component_add.html\"",
            "",
            "",
            "class InventoryItemDeleteView(generic.ObjectDeleteView):",
            "    queryset = InventoryItem.objects.all()",
            "",
            "",
            "class InventoryItemBulkImportView(generic.BulkImportView):",
            "    queryset = InventoryItem.objects.all()",
            "    model_form = forms.InventoryItemCSVForm",
            "    table = tables.InventoryItemTable",
            "",
            "",
            "class InventoryItemBulkEditView(generic.BulkEditView):",
            "    queryset = InventoryItem.objects.select_related(\"device\", \"manufacturer\")",
            "    filterset = filters.InventoryItemFilterSet",
            "    table = tables.InventoryItemTable",
            "    form = forms.InventoryItemBulkEditForm",
            "",
            "",
            "class InventoryItemBulkRenameView(BaseDeviceComponentsBulkRenameView):",
            "    queryset = InventoryItem.objects.all()",
            "",
            "",
            "class InventoryItemBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = InventoryItem.objects.select_related(\"device\", \"manufacturer\")",
            "    table = tables.InventoryItemTable",
            "    template_name = \"dcim/inventoryitem_bulk_delete.html\"",
            "",
            "",
            "#",
            "# Bulk Device component creation",
            "#",
            "",
            "",
            "class DeviceBulkAddConsolePortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.ConsolePortBulkCreateForm",
            "    queryset = ConsolePort.objects.all()",
            "    model_form = forms.ConsolePortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddConsoleServerPortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.ConsoleServerPortBulkCreateForm",
            "    queryset = ConsoleServerPort.objects.all()",
            "    model_form = forms.ConsoleServerPortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddPowerPortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.PowerPortBulkCreateForm",
            "    queryset = PowerPort.objects.all()",
            "    model_form = forms.PowerPortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddPowerOutletView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.PowerOutletBulkCreateForm",
            "    queryset = PowerOutlet.objects.all()",
            "    model_form = forms.PowerOutletForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddInterfaceView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.InterfaceBulkCreateForm",
            "    queryset = Interface.objects.all()",
            "    model_form = forms.InterfaceForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "# class DeviceBulkAddFrontPortView(generic.BulkComponentCreateView):",
            "#     parent_model = Device",
            "#     parent_field = 'device'",
            "#     form = forms.FrontPortBulkCreateForm",
            "#     queryset = FrontPort.objects.all()",
            "#     model_form = forms.FrontPortForm",
            "#     filterset = filters.DeviceFilterSet",
            "#     table = tables.DeviceTable",
            "#     default_return_url = 'dcim:device_list'",
            "",
            "",
            "class DeviceBulkAddRearPortView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.RearPortBulkCreateForm",
            "    queryset = RearPort.objects.all()",
            "    model_form = forms.RearPortForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddDeviceBayView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.DeviceBayBulkCreateForm",
            "    queryset = DeviceBay.objects.all()",
            "    model_form = forms.DeviceBayForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "class DeviceBulkAddInventoryItemView(generic.BulkComponentCreateView):",
            "    parent_model = Device",
            "    parent_field = \"device\"",
            "    form = forms.InventoryItemBulkCreateForm",
            "    queryset = InventoryItem.objects.all()",
            "    model_form = forms.InventoryItemForm",
            "    filterset = filters.DeviceFilterSet",
            "    table = tables.DeviceTable",
            "    default_return_url = \"dcim:device_list\"",
            "",
            "",
            "#",
            "# Cables",
            "#",
            "",
            "",
            "class CableListView(generic.ObjectListView):",
            "    queryset = Cable.objects.all()",
            "    filterset = filters.CableFilterSet",
            "    filterset_form = forms.CableFilterForm",
            "    table = tables.CableTable",
            "    action_buttons = (\"import\", \"export\")",
            "",
            "",
            "class CableView(generic.ObjectView):",
            "    queryset = Cable.objects.all()",
            "",
            "",
            "class PathTraceView(generic.ObjectView):",
            "    \"\"\"",
            "    Trace a cable path beginning from the given path endpoint (origin).",
            "    \"\"\"",
            "",
            "    additional_permissions = [\"dcim.view_cable\"]",
            "    template_name = \"dcim/cable_trace.html\"",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        model = kwargs.pop(\"model\")",
            "        self.queryset = model.objects.all()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_paths = []",
            "",
            "        # If tracing a PathEndpoint, locate the CablePath (if one exists) by its origin",
            "        if isinstance(instance, PathEndpoint):",
            "            path = instance._path",
            "",
            "        # Otherwise, find all CablePaths which traverse the specified object",
            "        else:",
            "            related_paths = CablePath.objects.filter(path__contains=instance).prefetch_related(\"origin\")",
            "            # Check for specification of a particular path (when tracing pass-through ports)",
            "",
            "            cablepath_id = request.GET.get(\"cablepath_id\")",
            "            if cablepath_id is not None:",
            "                try:",
            "                    path_id = uuid.UUID(cablepath_id)",
            "                except (AttributeError, TypeError, ValueError):",
            "                    path_id = None",
            "                try:",
            "                    path = related_paths.get(pk=path_id)",
            "                except CablePath.DoesNotExist:",
            "                    path = related_paths.first()",
            "            else:",
            "                path = related_paths.first()",
            "",
            "        return {",
            "            \"path\": path,",
            "            \"related_paths\": related_paths,",
            "            \"total_length\": path.get_total_length() if path else None,",
            "        }",
            "",
            "",
            "class CableCreateView(generic.ObjectEditView):",
            "    queryset = Cable.objects.all()",
            "    template_name = \"dcim/cable_connect.html\"",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Set the model_form class based on the type of component being connected",
            "        self.model_form = {",
            "            \"console-port\": forms.ConnectCableToConsolePortForm,",
            "            \"console-server-port\": forms.ConnectCableToConsoleServerPortForm,",
            "            \"power-port\": forms.ConnectCableToPowerPortForm,",
            "            \"power-outlet\": forms.ConnectCableToPowerOutletForm,",
            "            \"interface\": forms.ConnectCableToInterfaceForm,",
            "            \"front-port\": forms.ConnectCableToFrontPortForm,",
            "            \"rear-port\": forms.ConnectCableToRearPortForm,",
            "            \"power-feed\": forms.ConnectCableToPowerFeedForm,",
            "            \"circuit-termination\": forms.ConnectCableToCircuitTerminationForm,",
            "        }[kwargs.get(\"termination_b_type\")]",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        termination_a_type = url_kwargs.get(\"termination_a_type\")",
            "        termination_a_id = url_kwargs.get(\"termination_a_id\")",
            "        termination_b_type_name = url_kwargs.get(\"termination_b_type\")",
            "        self.termination_b_type = ContentType.objects.get(model=termination_b_type_name.replace(\"-\", \"\"))",
            "",
            "        # Initialize Cable termination attributes",
            "        obj.termination_a = termination_a_type.objects.get(pk=termination_a_id)",
            "        obj.termination_b_type = self.termination_b_type",
            "",
            "        return obj",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "",
            "        # Parse initial data manually to avoid setting field values as lists",
            "        initial_data = {k: request.GET[k] for k in request.GET}",
            "",
            "        # Set initial site and rack based on side A termination (if not already set)",
            "        termination_a_site = getattr(obj.termination_a.parent, \"site\", None)",
            "        if termination_a_site and \"termination_b_region\" not in initial_data:",
            "            initial_data[\"termination_b_region\"] = termination_a_site.region",
            "        if \"termination_b_site\" not in initial_data:",
            "            initial_data[\"termination_b_site\"] = termination_a_site",
            "        if \"termination_b_rack\" not in initial_data:",
            "            initial_data[\"termination_b_rack\"] = getattr(obj.termination_a.parent, \"rack\", None)",
            "",
            "        form = self.model_form(exclude_id=kwargs.get(\"termination_a_id\"), instance=obj, initial=initial_data)",
            "",
            "        # the following builds up a CSS query selector to match all drop-downs",
            "        # in the termination_b form except the termination_b_id. this is necessary to reset the termination_b_id",
            "        # drop-down whenever any of these drop-downs' values changes. this cannot be hardcoded because the form is",
            "        # selected dynamically and therefore the fields change depending on the value of termination_b_type (L2358)",
            "        js_select_onchange_query = \", \".join(",
            "            [",
            "                f\"select#id_{field_name}\"",
            "                for field_name, field in form.fields.items()",
            "                # include all termination_b_* fields:",
            "                if field_name.startswith(\"termination_b\")",
            "                # exclude termination_b_id:",
            "                and field_name != \"termination_b_id\"",
            "                # include only HTML select fields:",
            "                and field.widget.input_type == \"select\"",
            "            ]",
            "        )",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": Cable._meta.verbose_name,",
            "                \"termination_b_type\": self.termination_b_type.name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"js_select_onchange_query\": js_select_onchange_query,",
            "            },",
            "        )",
            "",
            "",
            "class CableEditView(generic.ObjectEditView):",
            "    queryset = Cable.objects.all()",
            "    model_form = forms.CableForm",
            "    template_name = \"dcim/cable_edit.html\"",
            "",
            "",
            "class CableDeleteView(generic.ObjectDeleteView):",
            "    queryset = Cable.objects.all()",
            "",
            "",
            "class CableBulkImportView(generic.BulkImportView):",
            "    queryset = Cable.objects.all()",
            "    model_form = forms.CableCSVForm",
            "    table = tables.CableTable",
            "",
            "",
            "class CableBulkEditView(generic.BulkEditView):",
            "    queryset = Cable.objects.prefetch_related(\"termination_a\", \"termination_b\")",
            "    filterset = filters.CableFilterSet",
            "    table = tables.CableTable",
            "    form = forms.CableBulkEditForm",
            "",
            "",
            "class CableBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Cable.objects.prefetch_related(\"termination_a\", \"termination_b\")",
            "    filterset = filters.CableFilterSet",
            "    table = tables.CableTable",
            "",
            "",
            "#",
            "# Connections",
            "#",
            "",
            "",
            "class ConnectionsListView(generic.ObjectListView):",
            "    CSVRow = namedtuple(\"CSVRow\", [\"device\", \"name\", \"dest_device\", \"dest_name\", \"reachable\"])",
            "",
            "    def queryset_to_csv_body_data(self):",
            "        \"\"\"",
            "        The headers may differ from view to view but the formatting of the CSV data is the same.",
            "        \"\"\"",
            "        csv_body_data = []",
            "        for obj in self.queryset:",
            "            # The connected endpoint may or may not be associated with a Device (e.g., CircuitTerminations are not)",
            "            # and may or may not have a name of its own (e.g., CircuitTerminations do not)",
            "            dest_device = None",
            "            dest_name = None",
            "            if obj.connected_endpoint:",
            "                if hasattr(obj.connected_endpoint, \"device\"):",
            "                    dest_device = obj.connected_endpoint.device.identifier",
            "                if hasattr(obj.connected_endpoint, \"name\"):",
            "                    dest_name = obj.connected_endpoint.name",
            "",
            "            # In the case where a connection exists between two like endpoints,",
            "            # for consistency of output we want to ensure that it's always represented as",
            "            # (\"device a\", \"interface a\", \"device b\", \"interface b\") rather than",
            "            # (\"device b\", \"interface b\", \"device a\", \"interface a\")",
            "            if obj.__class__ == obj.connected_endpoint.__class__ and (",
            "                obj.device.identifier > obj.connected_endpoint.device.identifier",
            "                or (",
            "                    obj.device.identifier == obj.connected_endpoint.device.identifier",
            "                    and obj.name > obj.connected_endpoint.name",
            "                )",
            "            ):",
            "                # Swap the two endpoints around for consistent output as described above",
            "                row = self.CSVRow(",
            "                    device=dest_device,",
            "                    name=dest_name,",
            "                    dest_device=obj.device.identifier,",
            "                    dest_name=obj.name,",
            "                    reachable=str(obj.path.is_active),",
            "                )",
            "            else:",
            "                # Existing order of endpoints is fine and correct",
            "                row = self.CSVRow(",
            "                    device=obj.device.identifier,",
            "                    name=obj.name,",
            "                    dest_device=dest_device,",
            "                    dest_name=dest_name,",
            "                    reachable=str(obj.path.is_active),",
            "                )",
            "",
            "            csv_body_data.append(csv_format(row))",
            "",
            "        return sorted(csv_body_data)",
            "",
            "",
            "class ConsoleConnectionsListView(ConnectionsListView):",
            "    queryset = ConsolePort.objects.filter(_path__isnull=False)",
            "    filterset = filters.ConsoleConnectionFilterSet",
            "    filterset_form = forms.ConsoleConnectionFilterForm",
            "    table = tables.ConsoleConnectionTable",
            "    action_buttons = (\"export\",)",
            "",
            "    def queryset_to_csv(self):",
            "        csv_data = [",
            "            # Headers",
            "            \",\".join([\"device\", \"console_port\", \"console_server\", \"port\", \"reachable\"])",
            "        ]",
            "        csv_data.extend(self.queryset_to_csv_body_data())",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"title\": \"Console Connections\",",
            "            \"list_url\": \"dcim:console_connections_list\",",
            "            \"search_form\": None,  # ConsoleConnectionFilterSet do not support q filter",
            "        }",
            "",
            "",
            "class PowerConnectionsListView(ConnectionsListView):",
            "    queryset = PowerPort.objects.filter(_path__isnull=False)",
            "    filterset = filters.PowerConnectionFilterSet",
            "    filterset_form = forms.PowerConnectionFilterForm",
            "    table = tables.PowerConnectionTable",
            "    action_buttons = (\"export\",)",
            "",
            "    def queryset_to_csv(self):",
            "        csv_data = [",
            "            # Headers",
            "            \",\".join([\"device\", \"power_port\", \"pdu\", \"outlet\", \"reachable\"])",
            "        ]",
            "        csv_data.extend(self.queryset_to_csv_body_data())",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"title\": \"Power Connections\",",
            "            \"list_url\": \"dcim:power_connections_list\",",
            "            \"search_form\": None,  # PowerConnectionFilterSet do not support q filter",
            "        }",
            "",
            "",
            "class InterfaceConnectionsListView(ConnectionsListView):",
            "    queryset = None  # This gets set initially in init (See `get_queryset()`)",
            "    filterset = filters.InterfaceConnectionFilterSet",
            "    filterset_form = forms.InterfaceConnectionFilterForm",
            "    table = tables.InterfaceConnectionTable",
            "    action_buttons = (\"export\",)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.get_queryset()  # Populate self.queryset after init.",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        This is a required so that the call to `ContentType.objects.get_for_model` does not result in a circular import.",
            "        \"\"\"",
            "        qs = Interface.objects.filter(_path__isnull=False).exclude(",
            "            # If an Interface is connected to another Interface, avoid returning both (A, B) and (B, A)",
            "            # Unfortunately we can't use something consistent to pick which pair to exclude (such as device or name)",
            "            # as _path.destination is a GenericForeignKey without a corresponding GenericRelation and so cannot be",
            "            # used for reverse querying.",
            "            # The below at least ensures uniqueness, but doesn't guarantee whether we get (A, B) or (B, A);",
            "            # we fix it up to be consistently (A, B) in queryset_to_csv_body_data().",
            "            # TODO: this is very problematic when filtering the view via FilterSet - if the filterset matches (A), then",
            "            #       the connection will appear in the table, but if it only matches (B) then the connection will not!",
            "            _path__destination_type=ContentType.objects.get_for_model(Interface),",
            "            pk__lt=F(\"_path__destination_id\"),",
            "        )",
            "        if self.queryset is None:",
            "            self.queryset = qs",
            "",
            "        return self.queryset",
            "",
            "    def queryset_to_csv(self):",
            "        csv_data = [",
            "            # Headers",
            "            \",\".join([\"device_a\", \"interface_a\", \"device_b\", \"interface_b\", \"reachable\"])",
            "        ]",
            "        csv_data.extend(self.queryset_to_csv_body_data())",
            "",
            "        return \"\\n\".join(csv_data)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"title\": \"Interface Connections\",",
            "            \"list_url\": \"dcim:interface_connections_list\",",
            "            \"search_form\": None,  # InterfaceConnectionFilterSet do not support q filter",
            "        }",
            "",
            "",
            "#",
            "# Virtual chassis",
            "#",
            "",
            "",
            "class VirtualChassisListView(generic.ObjectListView):",
            "    queryset = VirtualChassis.objects.select_related(\"master\").annotate(",
            "        member_count=count_related(Device, \"virtual_chassis\")",
            "    )",
            "    table = tables.VirtualChassisTable",
            "    filterset = filters.VirtualChassisFilterSet",
            "    filterset_form = forms.VirtualChassisFilterForm",
            "",
            "",
            "class VirtualChassisView(generic.ObjectView):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        members = Device.objects.restrict(request.user).filter(virtual_chassis=instance)",
            "",
            "        return {",
            "            \"members\": members,",
            "        }",
            "",
            "",
            "class VirtualChassisCreateView(generic.ObjectEditView):",
            "    queryset = VirtualChassis.objects.all()",
            "    model_form = forms.VirtualChassisCreateForm",
            "    template_name = \"dcim/virtualchassis_add.html\"",
            "",
            "",
            "class VirtualChassisEditView(ObjectPermissionRequiredMixin, GetReturnURLMixin, View):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"dcim.change_virtualchassis\"",
            "",
            "    def get(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "        VCMemberFormSet = modelformset_factory(",
            "            model=Device,",
            "            form=forms.DeviceVCMembershipForm,",
            "            formset=forms.BaseVCMemberFormSet,",
            "            extra=0,",
            "        )",
            "        members_queryset = virtual_chassis.members.select_related(\"rack\").order_by(\"vc_position\")",
            "",
            "        vc_form = forms.VirtualChassisForm(instance=virtual_chassis)",
            "        vc_form.fields[\"master\"].queryset = members_queryset",
            "        formset = VCMemberFormSet(queryset=members_queryset)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_edit.html\",",
            "            {",
            "                \"vc_form\": vc_form,",
            "                \"formset\": formset,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "    def post(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "        VCMemberFormSet = modelformset_factory(",
            "            model=Device,",
            "            form=forms.DeviceVCMembershipForm,",
            "            formset=forms.BaseVCMemberFormSet,",
            "            extra=0,",
            "        )",
            "        members_queryset = virtual_chassis.members.select_related(\"rack\").order_by(\"vc_position\")",
            "",
            "        vc_form = forms.VirtualChassisForm(request.POST, instance=virtual_chassis)",
            "        vc_form.fields[\"master\"].queryset = members_queryset",
            "        formset = VCMemberFormSet(request.POST, queryset=members_queryset)",
            "",
            "        if vc_form.is_valid() and formset.is_valid():",
            "            with transaction.atomic():",
            "                # Save the VirtualChassis",
            "                vc_form.save()",
            "",
            "                # Nullify the vc_position of each member first to allow reordering without raising an IntegrityError on",
            "                # duplicate positions. Then save each member instance.",
            "                members = formset.save(commit=False)",
            "                devices = Device.objects.filter(pk__in=[m.pk for m in members])",
            "                for device in devices:",
            "                    device.vc_position = None",
            "                    device.save()",
            "                for member in members:",
            "                    member.save()",
            "",
            "            return redirect(virtual_chassis.get_absolute_url())",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_edit.html\",",
            "            {",
            "                \"vc_form\": vc_form,",
            "                \"formset\": formset,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "",
            "class VirtualChassisDeleteView(generic.ObjectDeleteView):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "",
            "class VirtualChassisAddMemberView(ObjectPermissionRequiredMixin, GetReturnURLMixin, View):",
            "    queryset = VirtualChassis.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"dcim.change_virtualchassis\"",
            "",
            "    def get(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        initial_data = {k: request.GET[k] for k in request.GET}",
            "        member_select_form = forms.VCMemberSelectForm(initial=initial_data)",
            "        membership_form = forms.DeviceVCMembershipForm(initial=initial_data)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_add_member.html\",",
            "            {",
            "                \"virtual_chassis\": virtual_chassis,",
            "                \"member_select_form\": member_select_form,",
            "                \"membership_form\": membership_form,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "    def post(self, request, pk):",
            "        virtual_chassis = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        member_select_form = forms.VCMemberSelectForm(request.POST)",
            "",
            "        if member_select_form.is_valid():",
            "            device = member_select_form.cleaned_data[\"device\"]",
            "            device.virtual_chassis = virtual_chassis",
            "            data = {k: request.POST[k] for k in [\"vc_position\", \"vc_priority\"]}",
            "            membership_form = forms.DeviceVCMembershipForm(data=data, validate_vc_position=True, instance=device)",
            "",
            "            if membership_form.is_valid():",
            "                membership_form.save()",
            "                msg = format_html('Added member <a href=\"{}\">{}</a>', device.get_absolute_url(), device)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    return redirect(request.get_full_path())",
            "",
            "                return redirect(self.get_return_url(request, device))",
            "",
            "        else:",
            "            membership_form = forms.DeviceVCMembershipForm(data=request.POST)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_add_member.html\",",
            "            {",
            "                \"virtual_chassis\": virtual_chassis,",
            "                \"member_select_form\": member_select_form,",
            "                \"membership_form\": membership_form,",
            "                \"return_url\": self.get_return_url(request, virtual_chassis),",
            "            },",
            "        )",
            "",
            "",
            "class VirtualChassisRemoveMemberView(ObjectPermissionRequiredMixin, GetReturnURLMixin, View):",
            "    queryset = Device.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"dcim.change_device\"",
            "",
            "    def get(self, request, pk):",
            "        device = get_object_or_404(self.queryset, pk=pk, virtual_chassis__isnull=False)",
            "        form = ConfirmationForm(initial=request.GET)",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_remove_member.html\",",
            "            {",
            "                \"device\": device,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device),",
            "            },",
            "        )",
            "",
            "    def post(self, request, pk):",
            "        device = get_object_or_404(self.queryset, pk=pk, virtual_chassis__isnull=False)",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        # Protect master device from being removed",
            "        virtual_chassis = VirtualChassis.objects.filter(master=device).first()",
            "        if virtual_chassis is not None:",
            "            msg = format_html(\"Unable to remove master device {} from the virtual chassis.\", device)",
            "            messages.error(request, msg)",
            "            return redirect(device.get_absolute_url())",
            "",
            "        if form.is_valid():",
            "            devices = Device.objects.filter(pk=device.pk)",
            "            for device in devices:",
            "                device.virtual_chassis = None",
            "                device.vc_position = None",
            "                device.vc_priority = None",
            "                device.save()",
            "",
            "            msg = f\"Removed {device} from virtual chassis {device.virtual_chassis}\"",
            "            messages.success(request, msg)",
            "",
            "            return redirect(self.get_return_url(request, device))",
            "",
            "        return render(",
            "            request,",
            "            \"dcim/virtualchassis_remove_member.html\",",
            "            {",
            "                \"device\": device,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, device),",
            "            },",
            "        )",
            "",
            "",
            "class VirtualChassisBulkImportView(generic.BulkImportView):",
            "    queryset = VirtualChassis.objects.all()",
            "    model_form = forms.VirtualChassisCSVForm",
            "    table = tables.VirtualChassisTable",
            "",
            "",
            "class VirtualChassisBulkEditView(generic.BulkEditView):",
            "    queryset = VirtualChassis.objects.all()",
            "    filterset = filters.VirtualChassisFilterSet",
            "    table = tables.VirtualChassisTable",
            "    form = forms.VirtualChassisBulkEditForm",
            "",
            "",
            "class VirtualChassisBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = VirtualChassis.objects.all()",
            "    filterset = filters.VirtualChassisFilterSet",
            "    table = tables.VirtualChassisTable",
            "",
            "",
            "#",
            "# Power panels",
            "#",
            "",
            "",
            "class PowerPanelListView(generic.ObjectListView):",
            "    queryset = PowerPanel.objects.select_related(\"site\", \"rack_group\").annotate(",
            "        powerfeed_count=count_related(PowerFeed, \"power_panel\")",
            "    )",
            "    filterset = filters.PowerPanelFilterSet",
            "    filterset_form = forms.PowerPanelFilterForm",
            "    table = tables.PowerPanelTable",
            "",
            "",
            "class PowerPanelView(generic.ObjectView):",
            "    queryset = PowerPanel.objects.prefetch_related(\"site\", \"rack_group\")",
            "",
            "    def get_extra_context(self, request, instance):",
            "        power_feeds = PowerFeed.objects.restrict(request.user).filter(power_panel=instance).select_related(\"rack\")",
            "        powerfeed_table = tables.PowerFeedTable(data=power_feeds, orderable=False)",
            "        powerfeed_table.exclude = [\"power_panel\"]",
            "",
            "        return {",
            "            \"powerfeed_table\": powerfeed_table,",
            "        }",
            "",
            "",
            "class PowerPanelEditView(generic.ObjectEditView):",
            "    queryset = PowerPanel.objects.all()",
            "    model_form = forms.PowerPanelForm",
            "    template_name = \"dcim/powerpanel_edit.html\"",
            "",
            "",
            "class PowerPanelDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerPanel.objects.all()",
            "",
            "",
            "class PowerPanelBulkImportView(generic.BulkImportView):",
            "    queryset = PowerPanel.objects.all()",
            "    model_form = forms.PowerPanelCSVForm",
            "    table = tables.PowerPanelTable",
            "",
            "",
            "class PowerPanelBulkEditView(generic.BulkEditView):",
            "    queryset = PowerPanel.objects.select_related(\"site\", \"rack_group\")",
            "    filterset = filters.PowerPanelFilterSet",
            "    table = tables.PowerPanelTable",
            "    form = forms.PowerPanelBulkEditForm",
            "",
            "",
            "class PowerPanelBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerPanel.objects.select_related(\"site\", \"rack_group\").annotate(",
            "        powerfeed_count=count_related(PowerFeed, \"power_panel\")",
            "    )",
            "    filterset = filters.PowerPanelFilterSet",
            "    table = tables.PowerPanelTable",
            "",
            "",
            "#",
            "# Power feeds",
            "#",
            "",
            "",
            "class PowerFeedListView(generic.ObjectListView):",
            "    queryset = PowerFeed.objects.all()",
            "    filterset = filters.PowerFeedFilterSet",
            "    filterset_form = forms.PowerFeedFilterForm",
            "    table = tables.PowerFeedTable",
            "",
            "",
            "class PowerFeedView(generic.ObjectView):",
            "    queryset = PowerFeed.objects.select_related(\"power_panel\", \"rack\")",
            "",
            "",
            "class PowerFeedEditView(generic.ObjectEditView):",
            "    queryset = PowerFeed.objects.all()",
            "    model_form = forms.PowerFeedForm",
            "    template_name = \"dcim/powerfeed_edit.html\"",
            "",
            "",
            "class PowerFeedDeleteView(generic.ObjectDeleteView):",
            "    queryset = PowerFeed.objects.all()",
            "",
            "",
            "class PowerFeedBulkImportView(generic.BulkImportView):",
            "    queryset = PowerFeed.objects.all()",
            "    model_form = forms.PowerFeedCSVForm",
            "    table = tables.PowerFeedTable",
            "",
            "",
            "class PowerFeedBulkEditView(generic.BulkEditView):",
            "    queryset = PowerFeed.objects.select_related(\"power_panel\", \"rack\")",
            "    filterset = filters.PowerFeedFilterSet",
            "    table = tables.PowerFeedTable",
            "    form = forms.PowerFeedBulkEditForm",
            "",
            "",
            "class PowerFeedBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = PowerFeed.objects.select_related(\"power_panel\", \"rack\")",
            "    filterset = filters.PowerFeedFilterSet",
            "    table = tables.PowerFeedTable",
            "",
            "",
            "class DeviceRedundancyGroupUIViewSet(NautobotUIViewSet):",
            "    bulk_create_form_class = forms.DeviceRedundancyGroupCSVForm",
            "    bulk_update_form_class = forms.DeviceRedundancyGroupBulkEditForm",
            "    filterset_class = filters.DeviceRedundancyGroupFilterSet",
            "    filterset_form_class = forms.DeviceRedundancyGroupFilterForm",
            "    form_class = forms.DeviceRedundancyGroupForm",
            "    queryset = (",
            "        DeviceRedundancyGroup.objects.select_related(\"status\")",
            "        .prefetch_related(\"members\")",
            "        .annotate(member_count=count_related(Device, \"device_redundancy_group\"))",
            "    )",
            "    serializer_class = serializers.DeviceRedundancyGroupSerializer",
            "    table_class = tables.DeviceRedundancyGroupTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "",
            "        if self.action == \"retrieve\" and instance:",
            "            members = instance.members_sorted.restrict(request.user)",
            "            members_table = tables.DeviceTable(members)",
            "            members_table.columns.show(\"device_redundancy_group_priority\")",
            "            context[\"members_table\"] = members_table",
            "        return context",
            "",
            "",
            "class InterfaceRedundancyGroupUIViewSet(NautobotUIViewSet):",
            "    \"\"\"ViewSet for the InterfaceRedundancyGroup model.\"\"\"",
            "",
            "    bulk_create_form_class = forms.InterfaceRedundancyGroupCSVForm",
            "    bulk_update_form_class = forms.InterfaceRedundancyGroupBulkEditForm",
            "    filterset_class = filters.InterfaceRedundancyGroupFilterSet",
            "    filterset_form_class = forms.InterfaceRedundancyGroupFilterForm",
            "    form_class = forms.InterfaceRedundancyGroupForm",
            "    queryset = InterfaceRedundancyGroup.objects.select_related(\"status\")",
            "    queryset = queryset.prefetch_related(\"interfaces\")",
            "    queryset = queryset.annotate(",
            "        interface_count=count_related(Interface, \"interface_redundancy_groups\"),",
            "    )",
            "    serializer_class = serializers.InterfaceRedundancyGroupSerializer",
            "    table_class = tables.InterfaceRedundancyGroupTable",
            "    lookup_field = \"pk\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"Return additional panels for display.\"\"\"",
            "        context = super().get_extra_context(request, instance)",
            "        if instance and self.action == \"retrieve\":",
            "            interface_table = self._get_interface_redundancy_groups_table(request, instance)",
            "            context[\"interface_table\"] = interface_table",
            "        return context",
            "",
            "    def _get_interface_redundancy_groups_table(self, request, instance):",
            "        \"\"\"Return a table of assigned Interfaces.\"\"\"",
            "        queryset = instance.interface_redundancy_group_associations.restrict(request.user)",
            "        queryset = queryset.prefetch_related(\"interface\")",
            "        queryset = queryset.order_by(\"priority\")",
            "        column_sequence = (",
            "            \"interface__device\",",
            "            \"interface\",",
            "            \"priority\",",
            "            \"interface__status\",",
            "            \"interface__enabled\",",
            "            \"interface__ip_addresses\",",
            "            \"interface__type\",",
            "            \"interface__description\",",
            "            \"interface__label\",",
            "        )",
            "        table = tables.InterfaceRedundancyGroupAssociationTable(",
            "            data=queryset,",
            "            sequence=column_sequence,",
            "            orderable=False,",
            "        )",
            "        for column_name in column_sequence:",
            "            table.columns.show(column_name)",
            "        return table",
            "",
            "",
            "class InterfaceRedundancyGroupAssociationUIViewSet(ObjectEditViewMixin, ObjectDestroyViewMixin):",
            "    queryset = InterfaceRedundancyGroupAssociation.objects.all()",
            "    form_class = forms.InterfaceRedundancyGroupAssociationForm",
            "    template_name = \"dcim/interfaceredundancygroupassociation_create.html\"",
            "    lookup_field = \"pk\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "16": [],
            "2964": [
                "VirtualChassisAddMemberView",
                "post"
            ],
            "2965": [
                "VirtualChassisAddMemberView",
                "post"
            ],
            "3014": [
                "VirtualChassisRemoveMemberView",
                "post"
            ],
            "3015": [
                "VirtualChassisRemoveMemberView",
                "post"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/forms/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": 648,
                "PatchRowcode": "         self.fields[\"provided_contents\"] = CSVMultipleChoiceField("
            },
            "1": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 649,
                "PatchRowcode": "             choices=get_git_datasource_content_choices(),"
            },
            "2": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 650,
                "PatchRowcode": "             required=False,"
            },
            "3": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            help_text=mark_safe("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+            help_text=mark_safe(  # noqa: S308"
            },
            "5": {
                "beforePatchRowNumber": 652,
                "afterPatchRowNumber": 652,
                "PatchRowcode": "                 \"The data types this repository provides. Multiple values must be comma-separated and wrapped in \""
            },
            "6": {
                "beforePatchRowNumber": 653,
                "afterPatchRowNumber": 653,
                "PatchRowcode": "                 'double quotes (e.g. <code>\"extras.job,extras.configcontext\"</code>).'"
            },
            "7": {
                "beforePatchRowNumber": 654,
                "afterPatchRowNumber": 654,
                "PatchRowcode": "             ),"
            },
            "8": {
                "beforePatchRowNumber": 1352,
                "afterPatchRowNumber": 1352,
                "PatchRowcode": "     content_types = CSVMultipleContentTypeField("
            },
            "9": {
                "beforePatchRowNumber": 1353,
                "afterPatchRowNumber": 1353,
                "PatchRowcode": "         feature=\"statuses\","
            },
            "10": {
                "beforePatchRowNumber": 1354,
                "afterPatchRowNumber": 1354,
                "PatchRowcode": "         choices_as_strings=True,"
            },
            "11": {
                "beforePatchRowNumber": 1355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=mark_safe("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1355,
                "PatchRowcode": "+        help_text=mark_safe(  # noqa: S308"
            },
            "13": {
                "beforePatchRowNumber": 1356,
                "afterPatchRowNumber": 1356,
                "PatchRowcode": "             \"The object types to which this status applies. Multiple values \""
            },
            "14": {
                "beforePatchRowNumber": 1357,
                "afterPatchRowNumber": 1357,
                "PatchRowcode": "             \"must be comma-separated and wrapped in double quotes. (e.g. \""
            },
            "15": {
                "beforePatchRowNumber": 1358,
                "afterPatchRowNumber": 1358,
                "PatchRowcode": "             '<code>\"dcim.device,dcim.rack\"</code>)'"
            },
            "16": {
                "beforePatchRowNumber": 1364,
                "afterPatchRowNumber": 1364,
                "PatchRowcode": "         model = Status"
            },
            "17": {
                "beforePatchRowNumber": 1365,
                "afterPatchRowNumber": 1365,
                "PatchRowcode": "         fields = Status.csv_headers"
            },
            "18": {
                "beforePatchRowNumber": 1366,
                "afterPatchRowNumber": 1366,
                "PatchRowcode": "         help_texts = {"
            },
            "19": {
                "beforePatchRowNumber": 1367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1367,
                "PatchRowcode": "+            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308"
            },
            "21": {
                "beforePatchRowNumber": 1368,
                "afterPatchRowNumber": 1368,
                "PatchRowcode": "         }"
            },
            "22": {
                "beforePatchRowNumber": 1369,
                "afterPatchRowNumber": 1369,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 1370,
                "afterPatchRowNumber": 1370,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 1427,
                "afterPatchRowNumber": 1427,
                "PatchRowcode": "         model = Tag"
            },
            "25": {
                "beforePatchRowNumber": 1428,
                "afterPatchRowNumber": 1428,
                "PatchRowcode": "         fields = Tag.csv_headers"
            },
            "26": {
                "beforePatchRowNumber": 1429,
                "afterPatchRowNumber": 1429,
                "PatchRowcode": "         help_texts = {"
            },
            "27": {
                "beforePatchRowNumber": 1430,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1430,
                "PatchRowcode": "+            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308"
            },
            "29": {
                "beforePatchRowNumber": 1431,
                "afterPatchRowNumber": 1431,
                "PatchRowcode": "         }"
            },
            "30": {
                "beforePatchRowNumber": 1432,
                "afterPatchRowNumber": 1432,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 1433,
                "afterPatchRowNumber": 1433,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.db.models.fields import TextField",
            "from django.forms import ModelMultipleChoiceField, inlineformset_factory",
            "from django.urls.base import reverse",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.dcim.models import DeviceRedundancyGroup, DeviceRole, DeviceType, Location, Platform, Region, Site",
            "from nautobot.tenancy.models import Tenant, TenantGroup",
            "from nautobot.utilities.deprecation import class_deprecated_in_favor_of",
            "from nautobot.utilities.forms import (",
            "    add_blank_choice,",
            "    APISelect,",
            "    APISelectMultiple,",
            "    BootstrapMixin,",
            "    BulkEditForm,",
            "    BulkEditNullBooleanSelect,",
            "    ColorSelect,",
            "    CommentField,",
            "    CSVContentTypeField,",
            "    CSVModelChoiceField,",
            "    CSVModelForm,",
            "    CSVMultipleChoiceField,",
            "    CSVMultipleContentTypeField,",
            "    DateTimePicker,",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    JSONField,",
            "    MultipleContentTypeField,",
            "    SlugField,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    TagFilterField,",
            ")",
            "from nautobot.utilities.forms.constants import BOOLEAN_WITH_BLANK_CHOICES",
            "from nautobot.virtualization.models import Cluster, ClusterGroup",
            "from nautobot.extras.choices import (",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    ObjectChangeActionChoices,",
            "    RelationshipTypeChoices,",
            ")",
            "from nautobot.extras.constants import JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.datasources import get_datasource_content_choices",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomFieldChoice,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.registry import registry",
            "from nautobot.extras.utils import ChangeLoggedModelsQuery, FeatureQuery, TaggableClassesQuery",
            "from .base import (",
            "    NautobotBulkEditForm,",
            "    NautobotFilterForm,",
            "    NautobotModelForm,",
            ")",
            "from .mixins import (",
            "    CustomFieldModelBulkEditFormMixin,",
            "    CustomFieldModelFormMixin,",
            "    NoteModelBulkEditFormMixin,",
            "    NoteModelFormMixin,",
            "    RelationshipModelFormMixin,",
            ")",
            "",
            "",
            "__all__ = (",
            "    \"BaseDynamicGroupMembershipFormSet\",",
            "    \"ComputedFieldForm\",",
            "    \"ComputedFieldFilterForm\",",
            "    \"ConfigContextForm\",",
            "    \"ConfigContextBulkEditForm\",",
            "    \"ConfigContextFilterForm\",",
            "    \"ConfigContextSchemaForm\",",
            "    \"ConfigContextSchemaBulkEditForm\",",
            "    \"ConfigContextSchemaFilterForm\",",
            "    \"CustomFieldForm\",",
            "    \"CustomFieldModelCSVForm\",",
            "    \"CustomFieldBulkCreateForm\",  # 2.0 TODO remove this deprecated class",
            "    \"CustomFieldChoiceFormSet\",",
            "    \"CustomLinkForm\",",
            "    \"CustomLinkFilterForm\",",
            "    \"DynamicGroupForm\",",
            "    \"DynamicGroupFilterForm\",",
            "    \"DynamicGroupMembershipFormSet\",",
            "    \"ExportTemplateForm\",",
            "    \"ExportTemplateFilterForm\",",
            "    \"GitRepositoryForm\",",
            "    \"GitRepositoryCSVForm\",",
            "    \"GitRepositoryBulkEditForm\",",
            "    \"GitRepositoryFilterForm\",",
            "    \"GraphQLQueryForm\",",
            "    \"GraphQLQueryFilterForm\",",
            "    \"ImageAttachmentForm\",",
            "    \"JobForm\",",
            "    \"JobButtonForm\",",
            "    \"JobButtonBulkEditForm\",",
            "    \"JobButtonFilterForm\",",
            "    \"JobEditForm\",",
            "    \"JobFilterForm\",",
            "    \"JobHookForm\",",
            "    \"JobHookFilterForm\",",
            "    \"JobScheduleForm\",",
            "    \"JobResultFilterForm\",",
            "    \"LocalContextFilterForm\",",
            "    \"LocalContextModelForm\",",
            "    \"LocalContextModelBulkEditForm\",",
            "    \"NoteForm\",",
            "    \"ObjectChangeFilterForm\",",
            "    \"PasswordInputWithPlaceholder\",",
            "    \"RelationshipForm\",",
            "    \"RelationshipFilterForm\",",
            "    \"RelationshipAssociationFilterForm\",",
            "    \"ScheduledJobFilterForm\",",
            "    \"SecretForm\",",
            "    \"SecretCSVForm\",",
            "    \"SecretFilterForm\",",
            "    \"SecretsGroupForm\",",
            "    \"SecretsGroupFilterForm\",",
            "    \"SecretsGroupAssociationFormSet\",",
            "    \"StatusForm\",",
            "    \"StatusCSVForm\",",
            "    \"StatusFilterForm\",",
            "    \"StatusBulkEditForm\",",
            "    \"TagForm\",",
            "    \"TagCSVForm\",",
            "    \"TagFilterForm\",",
            "    \"TagBulkEditForm\",",
            "    \"WebhookForm\",",
            "    \"WebhookFilterForm\",",
            ")",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=True,",
            "        label=\"Content Type\",",
            "    )",
            "    slug = SlugField(",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    template = forms.CharField(",
            "        widget=forms.Textarea,",
            "        help_text=(",
            "            \"Jinja2 template code for field value.<br>\"",
            "            \"Use <code>obj</code> to refer to the object to which this computed field is attached.\"",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = ComputedField",
            "        fields = (",
            "            \"content_type\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"template\",",
            "            \"fallback_value\",",
            "            \"weight\",",
            "            \"advanced_ui\",",
            "        )",
            "",
            "",
            "class ComputedFieldFilterForm(BootstrapMixin, forms.Form):",
            "    model = ComputedField",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextForm(BootstrapMixin, NoteModelFormMixin, forms.ModelForm):",
            "    regions = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), required=False)",
            "    sites = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), required=False)",
            "    locations = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), required=False)",
            "    roles = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), required=False)",
            "    device_types = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), required=False)",
            "    platforms = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), required=False)",
            "    cluster_groups = DynamicModelMultipleChoiceField(queryset=ClusterGroup.objects.all(), required=False)",
            "    clusters = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False)",
            "    tenant_groups = DynamicModelMultipleChoiceField(queryset=TenantGroup.objects.all(), required=False)",
            "    tenants = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    device_redundancy_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), required=False",
            "    )",
            "    tags = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    # Conditional enablement of dynamic groups filtering",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "    data = JSONField(label=\"\")",
            "",
            "    class Meta:",
            "        model = ConfigContext",
            "        fields = (",
            "            \"name\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"schema\",",
            "            \"is_active\",",
            "            \"regions\",",
            "            \"sites\",",
            "            \"locations\",",
            "            \"roles\",",
            "            \"device_types\",",
            "            \"platforms\",",
            "            \"cluster_groups\",",
            "            \"clusters\",",
            "            \"tenant_groups\",",
            "            \"tenants\",",
            "            \"device_redundancy_groups\",",
            "            \"tags\",",
            "            \"dynamic_groups\",",
            "            \"data\",",
            "        )",
            "",
            "",
            "class ConfigContextBulkEditForm(BootstrapMixin, NoteModelBulkEditFormMixin, BulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContext.objects.all(), widget=forms.MultipleHiddenInput)",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    weight = forms.IntegerField(required=False, min_value=0)",
            "    is_active = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect())",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "            \"schema\",",
            "        ]",
            "",
            "",
            "class ConfigContextFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False)",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), to_field_name=\"slug\", required=False)",
            "    location = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    role = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), to_field_name=\"slug\", required=False)",
            "    type = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), to_field_name=\"slug\", required=False)",
            "    platform = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), to_field_name=\"slug\", required=False)",
            "    cluster_group = DynamicModelMultipleChoiceField(",
            "        queryset=ClusterGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    cluster_id = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False, label=\"Cluster\")",
            "    tenant_group = DynamicModelMultipleChoiceField(",
            "        queryset=TenantGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), to_field_name=\"slug\", required=False)",
            "    device_redundancy_group = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tag = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), to_field_name=\"slug\", required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaForm(NautobotModelForm):",
            "    data_schema = JSONField(label=\"\")",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = ConfigContextSchema",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"data_schema\",",
            "        )",
            "",
            "",
            "class ConfigContextSchemaBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContextSchema.objects.all(), widget=forms.MultipleHiddenInput)",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class ConfigContextSchemaFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "# CustomFieldChoice inline formset for use with providing dynamic rows when creating/editing choices",
            "# for `CustomField` objects in UI views. Fields/exclude must be set but since we're using all the",
            "# fields we're just setting `exclude=()` here.",
            "CustomFieldChoiceFormSet = inlineformset_factory(",
            "    parent_model=CustomField,",
            "    model=CustomFieldChoice,",
            "    exclude=(),",
            "    extra=5,",
            "    widgets={",
            "        \"value\": forms.TextInput(attrs={\"class\": \"form-control\"}),",
            "        \"weight\": forms.NumberInput(attrs={\"class\": \"form-control\"}),",
            "    },",
            ")",
            "",
            "",
            "class CustomFieldForm(BootstrapMixin, forms.ModelForm):",
            "    label = forms.CharField(required=True, max_length=50, help_text=\"Name of the field as displayed to users.\")",
            "    slug = SlugField(",
            "        max_length=50,",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    description = forms.CharField(",
            "        required=False,",
            "        help_text=\"Also used as the help text when editing models using this custom field.<br>\"",
            "        '<a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\">'",
            "        \"Markdown</a> syntax is supported.\",",
            "    )",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"custom_fields\", help_text=\"The object(s) to which this field applies.\"",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomField",
            "        fields = (",
            "            \"label\",",
            "            \"grouping\",",
            "            \"slug\",",
            "            \"type\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"required\",",
            "            \"default\",",
            "            \"filter_logic\",",
            "            \"advanced_ui\",",
            "            \"content_types\",",
            "            \"validation_minimum\",",
            "            \"validation_maximum\",",
            "            \"validation_regex\",",
            "        )",
            "",
            "",
            "class CustomFieldModelCSVForm(CSVModelForm, CustomFieldModelFormMixin):",
            "    \"\"\"Base class for CSV export of models that support custom fields.\"\"\"",
            "",
            "    def _append_customfield_fields(self):",
            "        # Append form fields",
            "        for cf in CustomField.objects.filter(content_types=self.obj_type):",
            "            field_name = f\"cf_{cf.slug}\"",
            "            self.fields[field_name] = cf.to_form_field(for_csv_import=True)",
            "",
            "            # Annotate the field in the list of CustomField form fields",
            "            self.custom_fields.append(field_name)",
            "",
            "",
            "# 2.0 TODO: remove this class",
            "@class_deprecated_in_favor_of(CustomFieldModelBulkEditFormMixin)",
            "class CustomFieldBulkCreateForm(CustomFieldModelBulkEditFormMixin):",
            "    \"\"\"No longer needed as a separate class - use CustomFieldModelBulkEditFormMixin instead.\"\"\"",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomLink",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"text\",",
            "            \"target_url\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"new_window\",",
            "        )",
            "",
            "",
            "class CustomLinkFilterForm(BootstrapMixin, forms.Form):",
            "    model = CustomLink",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupForm(NautobotModelForm):",
            "    \"\"\"DynamicGroup model form.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"dynamic_groups\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"content_type\",",
            "        ]",
            "",
            "",
            "class DynamicGroupMembershipFormSetForm(forms.ModelForm):",
            "    \"\"\"DynamicGroupMembership model form for use inline on DynamicGroupFormSet.\"\"\"",
            "",
            "    group = DynamicModelChoiceField(",
            "        queryset=DynamicGroup.objects.all(),",
            "        query_params={\"content_type\": \"$content_type\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroupMembership",
            "        fields = (\"operator\", \"group\", \"weight\")",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "# DynamicGroups to a parent DynamicGroup.",
            "BaseDynamicGroupMembershipFormSet = inlineformset_factory(",
            "    parent_model=DynamicGroup,",
            "    model=DynamicGroupMembership,",
            "    form=DynamicGroupMembershipFormSetForm,",
            "    extra=4,",
            "    fk_name=\"parent_group\",",
            "    widgets={",
            "        \"operator\": StaticSelect2,",
            "        \"weight\": forms.HiddenInput(),",
            "    },",
            ")",
            "",
            "",
            "class DynamicGroupMembershipFormSet(BaseDynamicGroupMembershipFormSet):",
            "    \"\"\"",
            "    Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "    groups to a parent DynamicGroup.",
            "    \"\"\"",
            "",
            "",
            "class DynamicGroupFilterForm(BootstrapMixin, forms.Form):",
            "    \"\"\"DynamicGroup filter form.\"\"\"",
            "",
            "    model = DynamicGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = MultipleContentTypeField(feature=\"dynamic_groups\", choices_as_strings=True, label=\"Content Type\")",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = ExportTemplate",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"description\",",
            "            \"template_code\",",
            "            \"mime_type\",",
            "            \"file_extension\",",
            "        )",
            "",
            "",
            "class ExportTemplateFilterForm(BootstrapMixin, forms.Form):",
            "    model = ExportTemplate",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Git repositories and other data sources",
            "#",
            "",
            "",
            "def get_git_datasource_content_choices():",
            "    return get_datasource_content_choices(\"extras.gitrepository\")",
            "",
            "",
            "class PasswordInputWithPlaceholder(forms.PasswordInput):",
            "    \"\"\"PasswordInput that is populated with a placeholder value if any existing value is present.\"\"\"",
            "",
            "    def __init__(self, attrs=None, placeholder=\"\", render_value=False):",
            "        if placeholder:",
            "            render_value = True",
            "        self._placeholder = placeholder",
            "        super().__init__(attrs=attrs, render_value=render_value)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        if value:",
            "            value = self._placeholder",
            "        return super().get_context(name, value, attrs)",
            "",
            "",
            "class GitRepositoryForm(BootstrapMixin, RelationshipModelFormMixin):",
            "    slug = SlugField(help_text=\"Filesystem-friendly unique shorthand\")",
            "",
            "    remote_url = forms.URLField(",
            "        required=True,",
            "        label=\"Remote URL\",",
            "        help_text=\"Only http:// and https:// URLs are presently supported\",",
            "    )",
            "",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"Username for token authentication.<br><em>Deprecated</em> - use a secrets group instead\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    provided_contents = forms.MultipleChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=get_git_datasource_content_choices,",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"username\",",
            "            \"_token\",",
            "            \"secrets_group\",",
            "            \"provided_contents\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # set dryrun after a successful clean",
            "        if \"_dryrun_create\" in self.data or \"_dryrun_update\" in self.data:",
            "            self.instance.set_dryrun()",
            "",
            "",
            "class GitRepositoryCSVForm(CSVModelForm):",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Secrets group for repository access (if any)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = GitRepository.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.fields[\"provided_contents\"] = CSVMultipleChoiceField(",
            "            choices=get_git_datasource_content_choices(),",
            "            required=False,",
            "            help_text=mark_safe(",
            "                \"The data types this repository provides. Multiple values must be comma-separated and wrapped in \"",
            "                'double quotes (e.g. <code>\"extras.job,extras.configcontext\"</code>).'",
            "            ),",
            "        )",
            "",
            "",
            "class GitRepositoryBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=GitRepository.objects.all(),",
            "        widget=forms.MultipleHiddenInput(),",
            "    )",
            "    remote_url = forms.CharField(",
            "        label=\"Remote URL\",",
            "        required=False,",
            "    )",
            "    branch = forms.CharField(",
            "        required=False,",
            "    )",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        nullable_fields = [\"secrets_group\"]",
            "",
            "",
            "class GitRepositoryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GitRepository",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    branch = forms.CharField(required=False)",
            "    provided_contents = forms.ChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=add_blank_choice(get_git_datasource_content_choices()),",
            "    )",
            "",
            "",
            "#",
            "# GraphQL saved queries",
            "#",
            "",
            "",
            "class GraphQLQueryForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField()",
            "    query = TextField()",
            "",
            "    class Meta:",
            "        model = GraphQLQuery",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"query\",",
            "        )",
            "",
            "    def get_action_url(self):",
            "        return reverse(\"extras:graphqlquery_add\")",
            "",
            "",
            "class GraphQLQueryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GraphQLQuery",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentForm(BootstrapMixin, forms.ModelForm):",
            "    class Meta:",
            "        model = ImageAttachment",
            "        fields = [",
            "            \"name\",",
            "            \"image\",",
            "        ]",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is used to render the user input fields for a Job class. Its fields are dynamically",
            "    controlled by the job definition. See `nautobot.extras.jobs.BaseJob.as_form`",
            "    \"\"\"",
            "",
            "    _commit = forms.BooleanField(",
            "        required=False,",
            "        initial=True,",
            "        label=\"Commit changes\",",
            "        help_text=\"Commit changes to the database (uncheck for a dry-run)\",",
            "    )",
            "    _profile = forms.BooleanField(",
            "        required=False,",
            "        initial=False,",
            "        label=\"Profile job execution\",",
            "        help_text=\"Profiles the job execution using cProfile and outputs a report to /tmp/\",",
            "    )",
            "    _task_queue = forms.ChoiceField(",
            "        required=False,",
            "        help_text=\"The task queue to route this job to\",",
            "        label=\"Task queue\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Move special fields to the end of the form",
            "        for field in [\"_task_queue\", \"_commit\", \"_profile\"]:",
            "            value = self.fields.pop(field)",
            "            self.fields[field] = value",
            "",
            "    @property",
            "    def requires_input(self):",
            "        \"\"\"",
            "        A boolean indicating whether the form requires user input (ignore the _commit field).",
            "        \"\"\"",
            "        return bool(len(self.fields) > 1)",
            "",
            "",
            "class JobEditForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Job",
            "        fields = [",
            "            \"slug\",",
            "            \"enabled\",",
            "            \"name_override\",",
            "            \"name\",",
            "            \"grouping_override\",",
            "            \"grouping\",",
            "            \"description_override\",",
            "            \"description\",",
            "            \"commit_default_override\",",
            "            \"commit_default\",",
            "            \"hidden_override\",",
            "            \"hidden\",",
            "            \"read_only_override\",",
            "            \"read_only\",",
            "            \"approval_required_override\",",
            "            \"approval_required\",",
            "            \"soft_time_limit_override\",",
            "            \"soft_time_limit\",",
            "            \"time_limit_override\",",
            "            \"time_limit\",",
            "            \"has_sensitive_variables_override\",",
            "            \"has_sensitive_variables\",",
            "            \"task_queues_override\",",
            "            \"task_queues\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        For all overridable fields, if they aren't marked as overridden, revert them to the underlying value if known.",
            "        \"\"\"",
            "        cleaned_data = super().clean() or self.cleaned_data",
            "        job_class = self.instance.job_class",
            "        if job_class is not None:",
            "            for field_name in JOB_OVERRIDABLE_FIELDS:",
            "                if not cleaned_data.get(f\"{field_name}_override\", False):",
            "                    cleaned_data[field_name] = getattr(job_class, field_name)",
            "        return cleaned_data",
            "",
            "",
            "class JobFilterForm(BootstrapMixin, forms.Form):",
            "    model = Job",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    installed = forms.NullBooleanField(",
            "        initial=True,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    has_sensitive_variables = forms.NullBooleanField(",
            "        required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES)",
            "    )",
            "    commit_default = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    hidden = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    read_only = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    approval_required = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    is_job_hook_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    is_job_button_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class JobHookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(), required=True, label=\"Content Type(s)\"",
            "    )",
            "",
            "    class Meta:",
            "        model = JobHook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = JobHook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            job=self.cleaned_data.get(\"job\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class JobHookFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobHook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(),",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    job = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "",
            "",
            "class JobScheduleForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is rendered alongside the JobForm but deals specifically with the fields needed to either",
            "    execute the job immediately, or schedule it for later. Each field name is prefixed with an underscore",
            "    because in the POST body, they share a namespace with the JobForm which includes fields defined by the",
            "    job author, so the underscore prefix helps to avoid name collisions.",
            "    \"\"\"",
            "",
            "    _schedule_type = forms.ChoiceField(",
            "        choices=JobExecutionType,",
            "        help_text=\"The job can either run immediately, once in the future, or on a recurring schedule.\",",
            "        label=\"Type\",",
            "    )",
            "    _schedule_name = forms.CharField(",
            "        required=False,",
            "        label=\"Schedule name\",",
            "        help_text=\"Name for the job schedule.\",",
            "    )",
            "    _schedule_start_time = forms.DateTimeField(",
            "        required=False,",
            "        label=\"Starting date and time\",",
            "        widget=DateTimePicker(),",
            "        help_text=f\"The scheduled time is relative to the Nautobot configured timezone: {settings.TIME_ZONE}.\",",
            "    )",
            "    _recurrence_custom_time = forms.CharField(",
            "        required=False,",
            "        label=\"Crontab\",",
            "        help_text=\"Custom crontab syntax (* * * * *)\",",
            "    )",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Validate all required information is present if the job needs to be scheduled",
            "        \"\"\"",
            "        cleaned_data = super().clean()",
            "",
            "        if \"_schedule_type\" in cleaned_data and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY:",
            "            if not cleaned_data.get(\"_schedule_name\"):",
            "                raise ValidationError({\"_schedule_name\": \"Please provide a name for the job schedule.\"})",
            "",
            "            if (",
            "                not cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_CUSTOM",
            "            ) or (",
            "                cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_start_time\") < ScheduledJob.earliest_possible_time()",
            "            ):",
            "                raise ValidationError(",
            "                    {",
            "                        \"_schedule_start_time\": \"Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                    }",
            "                )",
            "",
            "            if cleaned_data.get(\"_schedule_type\") == JobExecutionType.TYPE_CUSTOM:",
            "                try:",
            "                    ScheduledJob.get_crontab(cleaned_data.get(\"_recurrence_custom_time\"))",
            "                except Exception as e:",
            "                    raise ValidationError({\"_recurrence_custom_time\": e})",
            "",
            "",
            "class JobResultFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobResult",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    # 2.0 TODO(glenn) filtering by obj_type should be solved by dynamic filter form generation",
            "    name = forms.CharField(required=False)",
            "    user = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    status = forms.MultipleChoiceField(",
            "        choices=JobResultStatusChoices,",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "",
            "",
            "class ScheduledJobFilterForm(BootstrapMixin, forms.Form):",
            "    model = ScheduledJob",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/job-models/\"),",
            "    )",
            "    total_run_count = forms.IntegerField(required=False)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = JobButton",
            "        fields = (",
            "            \"content_types\",",
            "            \"name\",",
            "            \"text\",",
            "            \"job\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"confirmation\",",
            "        )",
            "",
            "",
            "class JobButtonBulkEditForm(BootstrapMixin, BulkEditForm):",
            "    \"\"\"Bulk edit form for `JobButton` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=JobButton.objects.all(), widget=forms.MultipleHiddenInput)",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "        required=False,",
            "    )",
            "    weight = forms.IntegerField(required=False)",
            "    group_name = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"group_name\"]",
            "",
            "",
            "class JobButtonFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobButton",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Types\",",
            "    )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteForm(BootstrapMixin, forms.ModelForm):",
            "    note = CommentField",
            "",
            "    class Meta:",
            "        model = Note",
            "        fields = [\"assigned_object_type\", \"assigned_object_id\", \"note\"]",
            "        widgets = {",
            "            \"assigned_object_type\": forms.HiddenInput,",
            "            \"assigned_object_id\": forms.HiddenInput,",
            "        }",
            "",
            "",
            "#",
            "# Filter form for local config context data",
            "#",
            "",
            "",
            "class LocalContextFilterForm(forms.Form):",
            "    local_context_data = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has local config context data\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    local_context_schema = DynamicModelMultipleChoiceField(",
            "        queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "",
            "#",
            "# Model form for local config context data",
            "#",
            "",
            "",
            "class LocalContextModelForm(forms.ModelForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    local_context_data = JSONField(required=False, label=\"\")",
            "",
            "",
            "class LocalContextModelBulkEditForm(BulkEditForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # append nullable fields",
            "        self.nullable_fields.append(\"local_context_schema\")",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeFilterForm(BootstrapMixin, forms.Form):",
            "    model = ObjectChange",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    time__gte = forms.DateTimeField(label=\"After\", required=False, widget=DateTimePicker())",
            "    time__lte = forms.DateTimeField(label=\"Before\", required=False, widget=DateTimePicker())",
            "    action = forms.ChoiceField(",
            "        choices=add_blank_choice(ObjectChangeActionChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    user_id = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    changed_object_type_id = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Type\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField(help_text=\"Internal name of this relationship. Please use underscores rather than dashes.\")",
            "    source_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The source object type to which this relationship applies.\",",
            "    )",
            "    source_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable source objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "    destination_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The destination object type to which this relationship applies.\",",
            "    )",
            "    destination_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable destination objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "",
            "    class Meta:",
            "        model = Relationship",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"type\",",
            "            \"required_on\",",
            "            \"advanced_ui\",",
            "            \"source_type\",",
            "            \"source_label\",",
            "            \"source_hidden\",",
            "            \"source_filter\",",
            "            \"destination_type\",",
            "            \"destination_label\",",
            "            \"destination_hidden\",",
            "            \"destination_filter\",",
            "        ]",
            "",
            "    def save(self, commit=True):",
            "        # TODO add support for owner when a CR is created in the UI",
            "        obj = super().save(commit)",
            "",
            "        return obj",
            "",
            "",
            "class RelationshipFilterForm(BootstrapMixin, forms.Form):",
            "    model = Relationship",
            "",
            "    type = forms.MultipleChoiceField(choices=RelationshipTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "class RelationshipAssociationFilterForm(BootstrapMixin, forms.Form):",
            "    model = RelationshipAssociation",
            "",
            "    relationship = DynamicModelMultipleChoiceField(",
            "        queryset=Relationship.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "    )",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "def provider_choices():",
            "    return sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()])",
            "",
            "",
            "class SecretForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `Secret` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    provider = forms.ChoiceField(choices=provider_choices, widget=StaticSelect2())",
            "",
            "    parameters = JSONField(help_text='Enter parameters in <a href=\"https://json.org/\">JSON</a> format.')",
            "",
            "    class Meta:",
            "        model = Secret",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"provider\",",
            "            \"parameters\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class SecretCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = Secret",
            "        fields = Secret.csv_headers",
            "",
            "",
            "def provider_choices_with_blank():",
            "    return add_blank_choice(sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()]))",
            "",
            "",
            "class SecretFilterForm(NautobotFilterForm):",
            "    model = Secret",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    provider = forms.MultipleChoiceField(",
            "        choices=provider_choices_with_blank, widget=StaticSelect2Multiple(), required=False",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing assignments of Secrets to SecretsGroups.",
            "SecretsGroupAssociationFormSet = inlineformset_factory(",
            "    parent_model=SecretsGroup,",
            "    model=SecretsGroupAssociation,",
            "    fields=(\"access_type\", \"secret_type\", \"secret\"),",
            "    extra=5,",
            "    widgets={",
            "        \"access_type\": StaticSelect2,",
            "        \"secret_type\": StaticSelect2,",
            "        \"secret\": APISelect(api_url=\"/api/extras/secrets/\"),",
            "    },",
            ")",
            "",
            "",
            "class SecretsGroupForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `SecretsGroup` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = SecretsGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class SecretsGroupFilterForm(NautobotFilterForm):",
            "    model = SecretsGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusForm(NautobotModelForm):",
            "    \"\"\"Generic create/update form for `Status` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Status",
            "        widgets = {\"color\": ColorSelect()}",
            "        fields = [\"name\", \"slug\", \"description\", \"content_types\", \"color\"]",
            "",
            "",
            "class StatusCSVForm(CustomFieldModelCSVForm):",
            "    \"\"\"Generic CSV bulk import form for `Status` objects.\"\"\"",
            "",
            "    content_types = CSVMultipleContentTypeField(",
            "        feature=\"statuses\",",
            "        choices_as_strings=True,",
            "        help_text=mark_safe(",
            "            \"The object types to which this status applies. Multiple values \"",
            "            \"must be comma-separated and wrapped in double quotes. (e.g. \"",
            "            '<code>\"dcim.device,dcim.rack\"</code>)'",
            "        ),",
            "        label=\"Content type(s)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Status",
            "        fields = Status.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),",
            "        }",
            "",
            "",
            "class StatusFilterForm(NautobotFilterForm):",
            "    \"\"\"Filtering/search form for `Status` objects.\"\"\"",
            "",
            "    model = Status",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"statuses\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "",
            "",
            "class StatusBulkEditForm(NautobotBulkEditForm):",
            "    \"\"\"Bulk edit/delete form for `Status` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=Status.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagForm(NautobotModelForm):",
            "    slug = SlugField()",
            "    content_types = ModelMultipleChoiceField(",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = [\"name\", \"slug\", \"color\", \"description\", \"content_types\"]",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        if self.instance.present_in_database:",
            "            # check if tag is assigned to any of the removed content_types",
            "            content_types_id = [content_type.id for content_type in self.cleaned_data[\"content_types\"]]",
            "            errors = self.instance.validate_content_types_removal(content_types_id)",
            "",
            "            if errors:",
            "                raise ValidationError(errors)",
            "",
            "        return data",
            "",
            "",
            "class TagCSVForm(CustomFieldModelCSVForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = Tag.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),",
            "        }",
            "",
            "",
            "class TagFilterForm(NautobotFilterForm):",
            "    model = Tag",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "",
            "class TagBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Tag.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    description = forms.CharField(max_length=200, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(feature=\"webhooks\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Webhook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "            \"payload_url\",",
            "            \"http_method\",",
            "            \"http_content_type\",",
            "            \"additional_headers\",",
            "            \"body_template\",",
            "            \"secret\",",
            "            \"ssl_verification\",",
            "            \"ca_file_path\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = Webhook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            payload_url=self.cleaned_data.get(\"payload_url\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class WebhookFilterForm(BootstrapMixin, forms.Form):",
            "    model = Webhook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"webhooks\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))"
        ],
        "afterPatchFile": [
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.db.models.fields import TextField",
            "from django.forms import ModelMultipleChoiceField, inlineformset_factory",
            "from django.urls.base import reverse",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.dcim.models import DeviceRedundancyGroup, DeviceRole, DeviceType, Location, Platform, Region, Site",
            "from nautobot.tenancy.models import Tenant, TenantGroup",
            "from nautobot.utilities.deprecation import class_deprecated_in_favor_of",
            "from nautobot.utilities.forms import (",
            "    add_blank_choice,",
            "    APISelect,",
            "    APISelectMultiple,",
            "    BootstrapMixin,",
            "    BulkEditForm,",
            "    BulkEditNullBooleanSelect,",
            "    ColorSelect,",
            "    CommentField,",
            "    CSVContentTypeField,",
            "    CSVModelChoiceField,",
            "    CSVModelForm,",
            "    CSVMultipleChoiceField,",
            "    CSVMultipleContentTypeField,",
            "    DateTimePicker,",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    JSONField,",
            "    MultipleContentTypeField,",
            "    SlugField,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    TagFilterField,",
            ")",
            "from nautobot.utilities.forms.constants import BOOLEAN_WITH_BLANK_CHOICES",
            "from nautobot.virtualization.models import Cluster, ClusterGroup",
            "from nautobot.extras.choices import (",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    ObjectChangeActionChoices,",
            "    RelationshipTypeChoices,",
            ")",
            "from nautobot.extras.constants import JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.datasources import get_datasource_content_choices",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomFieldChoice,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Webhook,",
            ")",
            "from nautobot.extras.registry import registry",
            "from nautobot.extras.utils import ChangeLoggedModelsQuery, FeatureQuery, TaggableClassesQuery",
            "from .base import (",
            "    NautobotBulkEditForm,",
            "    NautobotFilterForm,",
            "    NautobotModelForm,",
            ")",
            "from .mixins import (",
            "    CustomFieldModelBulkEditFormMixin,",
            "    CustomFieldModelFormMixin,",
            "    NoteModelBulkEditFormMixin,",
            "    NoteModelFormMixin,",
            "    RelationshipModelFormMixin,",
            ")",
            "",
            "",
            "__all__ = (",
            "    \"BaseDynamicGroupMembershipFormSet\",",
            "    \"ComputedFieldForm\",",
            "    \"ComputedFieldFilterForm\",",
            "    \"ConfigContextForm\",",
            "    \"ConfigContextBulkEditForm\",",
            "    \"ConfigContextFilterForm\",",
            "    \"ConfigContextSchemaForm\",",
            "    \"ConfigContextSchemaBulkEditForm\",",
            "    \"ConfigContextSchemaFilterForm\",",
            "    \"CustomFieldForm\",",
            "    \"CustomFieldModelCSVForm\",",
            "    \"CustomFieldBulkCreateForm\",  # 2.0 TODO remove this deprecated class",
            "    \"CustomFieldChoiceFormSet\",",
            "    \"CustomLinkForm\",",
            "    \"CustomLinkFilterForm\",",
            "    \"DynamicGroupForm\",",
            "    \"DynamicGroupFilterForm\",",
            "    \"DynamicGroupMembershipFormSet\",",
            "    \"ExportTemplateForm\",",
            "    \"ExportTemplateFilterForm\",",
            "    \"GitRepositoryForm\",",
            "    \"GitRepositoryCSVForm\",",
            "    \"GitRepositoryBulkEditForm\",",
            "    \"GitRepositoryFilterForm\",",
            "    \"GraphQLQueryForm\",",
            "    \"GraphQLQueryFilterForm\",",
            "    \"ImageAttachmentForm\",",
            "    \"JobForm\",",
            "    \"JobButtonForm\",",
            "    \"JobButtonBulkEditForm\",",
            "    \"JobButtonFilterForm\",",
            "    \"JobEditForm\",",
            "    \"JobFilterForm\",",
            "    \"JobHookForm\",",
            "    \"JobHookFilterForm\",",
            "    \"JobScheduleForm\",",
            "    \"JobResultFilterForm\",",
            "    \"LocalContextFilterForm\",",
            "    \"LocalContextModelForm\",",
            "    \"LocalContextModelBulkEditForm\",",
            "    \"NoteForm\",",
            "    \"ObjectChangeFilterForm\",",
            "    \"PasswordInputWithPlaceholder\",",
            "    \"RelationshipForm\",",
            "    \"RelationshipFilterForm\",",
            "    \"RelationshipAssociationFilterForm\",",
            "    \"ScheduledJobFilterForm\",",
            "    \"SecretForm\",",
            "    \"SecretCSVForm\",",
            "    \"SecretFilterForm\",",
            "    \"SecretsGroupForm\",",
            "    \"SecretsGroupFilterForm\",",
            "    \"SecretsGroupAssociationFormSet\",",
            "    \"StatusForm\",",
            "    \"StatusCSVForm\",",
            "    \"StatusFilterForm\",",
            "    \"StatusBulkEditForm\",",
            "    \"TagForm\",",
            "    \"TagCSVForm\",",
            "    \"TagFilterForm\",",
            "    \"TagBulkEditForm\",",
            "    \"WebhookForm\",",
            "    \"WebhookFilterForm\",",
            ")",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=True,",
            "        label=\"Content Type\",",
            "    )",
            "    slug = SlugField(",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    template = forms.CharField(",
            "        widget=forms.Textarea,",
            "        help_text=(",
            "            \"Jinja2 template code for field value.<br>\"",
            "            \"Use <code>obj</code> to refer to the object to which this computed field is attached.\"",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = ComputedField",
            "        fields = (",
            "            \"content_type\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"template\",",
            "            \"fallback_value\",",
            "            \"weight\",",
            "            \"advanced_ui\",",
            "        )",
            "",
            "",
            "class ComputedFieldFilterForm(BootstrapMixin, forms.Form):",
            "    model = ComputedField",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_fields\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextForm(BootstrapMixin, NoteModelFormMixin, forms.ModelForm):",
            "    regions = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), required=False)",
            "    sites = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), required=False)",
            "    locations = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), required=False)",
            "    roles = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), required=False)",
            "    device_types = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), required=False)",
            "    platforms = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), required=False)",
            "    cluster_groups = DynamicModelMultipleChoiceField(queryset=ClusterGroup.objects.all(), required=False)",
            "    clusters = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False)",
            "    tenant_groups = DynamicModelMultipleChoiceField(queryset=TenantGroup.objects.all(), required=False)",
            "    tenants = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), required=False)",
            "    device_redundancy_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), required=False",
            "    )",
            "    tags = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    # Conditional enablement of dynamic groups filtering",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "    data = JSONField(label=\"\")",
            "",
            "    class Meta:",
            "        model = ConfigContext",
            "        fields = (",
            "            \"name\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"schema\",",
            "            \"is_active\",",
            "            \"regions\",",
            "            \"sites\",",
            "            \"locations\",",
            "            \"roles\",",
            "            \"device_types\",",
            "            \"platforms\",",
            "            \"cluster_groups\",",
            "            \"clusters\",",
            "            \"tenant_groups\",",
            "            \"tenants\",",
            "            \"device_redundancy_groups\",",
            "            \"tags\",",
            "            \"dynamic_groups\",",
            "            \"data\",",
            "        )",
            "",
            "",
            "class ConfigContextBulkEditForm(BootstrapMixin, NoteModelBulkEditFormMixin, BulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContext.objects.all(), widget=forms.MultipleHiddenInput)",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    weight = forms.IntegerField(required=False, min_value=0)",
            "    is_active = forms.NullBooleanField(required=False, widget=BulkEditNullBooleanSelect())",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "            \"schema\",",
            "        ]",
            "",
            "",
            "class ConfigContextFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False)",
            "    region = DynamicModelMultipleChoiceField(queryset=Region.objects.all(), to_field_name=\"slug\", required=False)",
            "    site = DynamicModelMultipleChoiceField(queryset=Site.objects.all(), to_field_name=\"slug\", required=False)",
            "    location = DynamicModelMultipleChoiceField(queryset=Location.objects.all(), to_field_name=\"slug\", required=False)",
            "    role = DynamicModelMultipleChoiceField(queryset=DeviceRole.objects.all(), to_field_name=\"slug\", required=False)",
            "    type = DynamicModelMultipleChoiceField(queryset=DeviceType.objects.all(), to_field_name=\"slug\", required=False)",
            "    platform = DynamicModelMultipleChoiceField(queryset=Platform.objects.all(), to_field_name=\"slug\", required=False)",
            "    cluster_group = DynamicModelMultipleChoiceField(",
            "        queryset=ClusterGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    cluster_id = DynamicModelMultipleChoiceField(queryset=Cluster.objects.all(), required=False, label=\"Cluster\")",
            "    tenant_group = DynamicModelMultipleChoiceField(",
            "        queryset=TenantGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tenant = DynamicModelMultipleChoiceField(queryset=Tenant.objects.all(), to_field_name=\"slug\", required=False)",
            "    device_redundancy_group = DynamicModelMultipleChoiceField(",
            "        queryset=DeviceRedundancyGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "    tag = DynamicModelMultipleChoiceField(queryset=Tag.objects.all(), to_field_name=\"slug\", required=False)",
            "    dynamic_groups = DynamicModelMultipleChoiceField(",
            "        queryset=DynamicGroup.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        if not settings.CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED:",
            "            self.fields.pop(\"dynamic_groups\")",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaForm(NautobotModelForm):",
            "    data_schema = JSONField(label=\"\")",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = ConfigContextSchema",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"data_schema\",",
            "        )",
            "",
            "",
            "class ConfigContextSchemaBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=ConfigContextSchema.objects.all(), widget=forms.MultipleHiddenInput)",
            "    description = forms.CharField(required=False, max_length=100)",
            "",
            "    class Meta:",
            "        nullable_fields = [",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class ConfigContextSchemaFilterForm(BootstrapMixin, forms.Form):",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "# CustomFieldChoice inline formset for use with providing dynamic rows when creating/editing choices",
            "# for `CustomField` objects in UI views. Fields/exclude must be set but since we're using all the",
            "# fields we're just setting `exclude=()` here.",
            "CustomFieldChoiceFormSet = inlineformset_factory(",
            "    parent_model=CustomField,",
            "    model=CustomFieldChoice,",
            "    exclude=(),",
            "    extra=5,",
            "    widgets={",
            "        \"value\": forms.TextInput(attrs={\"class\": \"form-control\"}),",
            "        \"weight\": forms.NumberInput(attrs={\"class\": \"form-control\"}),",
            "    },",
            ")",
            "",
            "",
            "class CustomFieldForm(BootstrapMixin, forms.ModelForm):",
            "    label = forms.CharField(required=True, max_length=50, help_text=\"Name of the field as displayed to users.\")",
            "    slug = SlugField(",
            "        max_length=50,",
            "        slug_source=\"label\",",
            "        help_text=\"Internal name of this field. Please use underscores rather than dashes.\",",
            "    )",
            "    description = forms.CharField(",
            "        required=False,",
            "        help_text=\"Also used as the help text when editing models using this custom field.<br>\"",
            "        '<a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\">'",
            "        \"Markdown</a> syntax is supported.\",",
            "    )",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"custom_fields\", help_text=\"The object(s) to which this field applies.\"",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomField",
            "        fields = (",
            "            \"label\",",
            "            \"grouping\",",
            "            \"slug\",",
            "            \"type\",",
            "            \"weight\",",
            "            \"description\",",
            "            \"required\",",
            "            \"default\",",
            "            \"filter_logic\",",
            "            \"advanced_ui\",",
            "            \"content_types\",",
            "            \"validation_minimum\",",
            "            \"validation_maximum\",",
            "            \"validation_regex\",",
            "        )",
            "",
            "",
            "class CustomFieldModelCSVForm(CSVModelForm, CustomFieldModelFormMixin):",
            "    \"\"\"Base class for CSV export of models that support custom fields.\"\"\"",
            "",
            "    def _append_customfield_fields(self):",
            "        # Append form fields",
            "        for cf in CustomField.objects.filter(content_types=self.obj_type):",
            "            field_name = f\"cf_{cf.slug}\"",
            "            self.fields[field_name] = cf.to_form_field(for_csv_import=True)",
            "",
            "            # Annotate the field in the list of CustomField form fields",
            "            self.custom_fields.append(field_name)",
            "",
            "",
            "# 2.0 TODO: remove this class",
            "@class_deprecated_in_favor_of(CustomFieldModelBulkEditFormMixin)",
            "class CustomFieldBulkCreateForm(CustomFieldModelBulkEditFormMixin):",
            "    \"\"\"No longer needed as a separate class - use CustomFieldModelBulkEditFormMixin instead.\"\"\"",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = CustomLink",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"text\",",
            "            \"target_url\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"new_window\",",
            "        )",
            "",
            "",
            "class CustomLinkFilterForm(BootstrapMixin, forms.Form):",
            "    model = CustomLink",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"custom_links\").get_query()).order_by(\"app_label\", \"model\"),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupForm(NautobotModelForm):",
            "    \"\"\"DynamicGroup model form.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"dynamic_groups\").get_query()).order_by(\"app_label\", \"model\"),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"content_type\",",
            "        ]",
            "",
            "",
            "class DynamicGroupMembershipFormSetForm(forms.ModelForm):",
            "    \"\"\"DynamicGroupMembership model form for use inline on DynamicGroupFormSet.\"\"\"",
            "",
            "    group = DynamicModelChoiceField(",
            "        queryset=DynamicGroup.objects.all(),",
            "        query_params={\"content_type\": \"$content_type\"},",
            "    )",
            "",
            "    class Meta:",
            "        model = DynamicGroupMembership",
            "        fields = (\"operator\", \"group\", \"weight\")",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "# DynamicGroups to a parent DynamicGroup.",
            "BaseDynamicGroupMembershipFormSet = inlineformset_factory(",
            "    parent_model=DynamicGroup,",
            "    model=DynamicGroupMembership,",
            "    form=DynamicGroupMembershipFormSetForm,",
            "    extra=4,",
            "    fk_name=\"parent_group\",",
            "    widgets={",
            "        \"operator\": StaticSelect2,",
            "        \"weight\": forms.HiddenInput(),",
            "    },",
            ")",
            "",
            "",
            "class DynamicGroupMembershipFormSet(BaseDynamicGroupMembershipFormSet):",
            "    \"\"\"",
            "    Inline formset for use with providing dynamic rows when creating/editing memberships of child",
            "    groups to a parent DynamicGroup.",
            "    \"\"\"",
            "",
            "",
            "class DynamicGroupFilterForm(BootstrapMixin, forms.Form):",
            "    \"\"\"DynamicGroup filter form.\"\"\"",
            "",
            "    model = DynamicGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = MultipleContentTypeField(feature=\"dynamic_groups\", choices_as_strings=True, label=\"Content Type\")",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateForm(BootstrapMixin, forms.ModelForm):",
            "    content_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        label=\"Content Type\",",
            "    )",
            "",
            "    class Meta:",
            "        model = ExportTemplate",
            "        fields = (",
            "            \"content_type\",",
            "            \"name\",",
            "            \"description\",",
            "            \"template_code\",",
            "            \"mime_type\",",
            "            \"file_extension\",",
            "        )",
            "",
            "",
            "class ExportTemplateFilterForm(BootstrapMixin, forms.Form):",
            "    model = ExportTemplate",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_type = CSVContentTypeField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"export_templates\").get_query()).order_by(",
            "            \"app_label\", \"model\"",
            "        ),",
            "        required=False,",
            "        label=\"Content Type\",",
            "    )",
            "",
            "",
            "#",
            "# Git repositories and other data sources",
            "#",
            "",
            "",
            "def get_git_datasource_content_choices():",
            "    return get_datasource_content_choices(\"extras.gitrepository\")",
            "",
            "",
            "class PasswordInputWithPlaceholder(forms.PasswordInput):",
            "    \"\"\"PasswordInput that is populated with a placeholder value if any existing value is present.\"\"\"",
            "",
            "    def __init__(self, attrs=None, placeholder=\"\", render_value=False):",
            "        if placeholder:",
            "            render_value = True",
            "        self._placeholder = placeholder",
            "        super().__init__(attrs=attrs, render_value=render_value)",
            "",
            "    def get_context(self, name, value, attrs):",
            "        if value:",
            "            value = self._placeholder",
            "        return super().get_context(name, value, attrs)",
            "",
            "",
            "class GitRepositoryForm(BootstrapMixin, RelationshipModelFormMixin):",
            "    slug = SlugField(help_text=\"Filesystem-friendly unique shorthand\")",
            "",
            "    remote_url = forms.URLField(",
            "        required=True,",
            "        label=\"Remote URL\",",
            "        help_text=\"Only http:// and https:// URLs are presently supported\",",
            "    )",
            "",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"Username for token authentication.<br><em>Deprecated</em> - use a secrets group instead\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    provided_contents = forms.MultipleChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=get_git_datasource_content_choices,",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"username\",",
            "            \"_token\",",
            "            \"secrets_group\",",
            "            \"provided_contents\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # set dryrun after a successful clean",
            "        if \"_dryrun_create\" in self.data or \"_dryrun_update\" in self.data:",
            "            self.instance.set_dryrun()",
            "",
            "",
            "class GitRepositoryCSVForm(CSVModelForm):",
            "    secrets_group = CSVModelChoiceField(",
            "        queryset=SecretsGroup.objects.all(),",
            "        to_field_name=\"name\",",
            "        required=False,",
            "        help_text=\"Secrets group for repository access (if any)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        fields = GitRepository.csv_headers",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.fields[\"provided_contents\"] = CSVMultipleChoiceField(",
            "            choices=get_git_datasource_content_choices(),",
            "            required=False,",
            "            help_text=mark_safe(  # noqa: S308",
            "                \"The data types this repository provides. Multiple values must be comma-separated and wrapped in \"",
            "                'double quotes (e.g. <code>\"extras.job,extras.configcontext\"</code>).'",
            "            ),",
            "        )",
            "",
            "",
            "class GitRepositoryBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(",
            "        queryset=GitRepository.objects.all(),",
            "        widget=forms.MultipleHiddenInput(),",
            "    )",
            "    remote_url = forms.CharField(",
            "        label=\"Remote URL\",",
            "        required=False,",
            "    )",
            "    branch = forms.CharField(",
            "        required=False,",
            "    )",
            "    _token = forms.CharField(",
            "        required=False,",
            "        label=\"Token\",",
            "        widget=PasswordInputWithPlaceholder(placeholder=GitRepository.TOKEN_PLACEHOLDER),",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "    username = forms.CharField(",
            "        required=False,",
            "        label=\"Username\",",
            "        help_text=\"<em>Deprecated</em> - use a secrets group instead.\",",
            "    )",
            "",
            "    secrets_group = DynamicModelChoiceField(required=False, queryset=SecretsGroup.objects.all())",
            "",
            "    class Meta:",
            "        model = GitRepository",
            "        nullable_fields = [\"secrets_group\"]",
            "",
            "",
            "class GitRepositoryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GitRepository",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    branch = forms.CharField(required=False)",
            "    provided_contents = forms.ChoiceField(",
            "        required=False,",
            "        label=\"Provides\",",
            "        choices=add_blank_choice(get_git_datasource_content_choices()),",
            "    )",
            "",
            "",
            "#",
            "# GraphQL saved queries",
            "#",
            "",
            "",
            "class GraphQLQueryForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField()",
            "    query = TextField()",
            "",
            "    class Meta:",
            "        model = GraphQLQuery",
            "        fields = (",
            "            \"name\",",
            "            \"slug\",",
            "            \"query\",",
            "        )",
            "",
            "    def get_action_url(self):",
            "        return reverse(\"extras:graphqlquery_add\")",
            "",
            "",
            "class GraphQLQueryFilterForm(BootstrapMixin, forms.Form):",
            "    model = GraphQLQuery",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentForm(BootstrapMixin, forms.ModelForm):",
            "    class Meta:",
            "        model = ImageAttachment",
            "        fields = [",
            "            \"name\",",
            "            \"image\",",
            "        ]",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is used to render the user input fields for a Job class. Its fields are dynamically",
            "    controlled by the job definition. See `nautobot.extras.jobs.BaseJob.as_form`",
            "    \"\"\"",
            "",
            "    _commit = forms.BooleanField(",
            "        required=False,",
            "        initial=True,",
            "        label=\"Commit changes\",",
            "        help_text=\"Commit changes to the database (uncheck for a dry-run)\",",
            "    )",
            "    _profile = forms.BooleanField(",
            "        required=False,",
            "        initial=False,",
            "        label=\"Profile job execution\",",
            "        help_text=\"Profiles the job execution using cProfile and outputs a report to /tmp/\",",
            "    )",
            "    _task_queue = forms.ChoiceField(",
            "        required=False,",
            "        help_text=\"The task queue to route this job to\",",
            "        label=\"Task queue\",",
            "    )",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Move special fields to the end of the form",
            "        for field in [\"_task_queue\", \"_commit\", \"_profile\"]:",
            "            value = self.fields.pop(field)",
            "            self.fields[field] = value",
            "",
            "    @property",
            "    def requires_input(self):",
            "        \"\"\"",
            "        A boolean indicating whether the form requires user input (ignore the _commit field).",
            "        \"\"\"",
            "        return bool(len(self.fields) > 1)",
            "",
            "",
            "class JobEditForm(NautobotModelForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Job",
            "        fields = [",
            "            \"slug\",",
            "            \"enabled\",",
            "            \"name_override\",",
            "            \"name\",",
            "            \"grouping_override\",",
            "            \"grouping\",",
            "            \"description_override\",",
            "            \"description\",",
            "            \"commit_default_override\",",
            "            \"commit_default\",",
            "            \"hidden_override\",",
            "            \"hidden\",",
            "            \"read_only_override\",",
            "            \"read_only\",",
            "            \"approval_required_override\",",
            "            \"approval_required\",",
            "            \"soft_time_limit_override\",",
            "            \"soft_time_limit\",",
            "            \"time_limit_override\",",
            "            \"time_limit\",",
            "            \"has_sensitive_variables_override\",",
            "            \"has_sensitive_variables\",",
            "            \"task_queues_override\",",
            "            \"task_queues\",",
            "            \"tags\",",
            "        ]",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        For all overridable fields, if they aren't marked as overridden, revert them to the underlying value if known.",
            "        \"\"\"",
            "        cleaned_data = super().clean() or self.cleaned_data",
            "        job_class = self.instance.job_class",
            "        if job_class is not None:",
            "            for field_name in JOB_OVERRIDABLE_FIELDS:",
            "                if not cleaned_data.get(f\"{field_name}_override\", False):",
            "                    cleaned_data[field_name] = getattr(job_class, field_name)",
            "        return cleaned_data",
            "",
            "",
            "class JobFilterForm(BootstrapMixin, forms.Form):",
            "    model = Job",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    installed = forms.NullBooleanField(",
            "        initial=True,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    has_sensitive_variables = forms.NullBooleanField(",
            "        required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES)",
            "    )",
            "    commit_default = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    hidden = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    read_only = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    approval_required = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    is_job_hook_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    is_job_button_receiver = forms.NullBooleanField(",
            "        initial=False,",
            "        required=False,",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "class JobHookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(), required=True, label=\"Content Type(s)\"",
            "    )",
            "",
            "    class Meta:",
            "        model = JobHook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = JobHook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            job=self.cleaned_data.get(\"job\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class JobHookFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobHook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        queryset=ChangeLoggedModelsQuery().as_queryset(),",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "    )",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    job = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "",
            "",
            "class JobScheduleForm(BootstrapMixin, forms.Form):",
            "    \"\"\"",
            "    This form is rendered alongside the JobForm but deals specifically with the fields needed to either",
            "    execute the job immediately, or schedule it for later. Each field name is prefixed with an underscore",
            "    because in the POST body, they share a namespace with the JobForm which includes fields defined by the",
            "    job author, so the underscore prefix helps to avoid name collisions.",
            "    \"\"\"",
            "",
            "    _schedule_type = forms.ChoiceField(",
            "        choices=JobExecutionType,",
            "        help_text=\"The job can either run immediately, once in the future, or on a recurring schedule.\",",
            "        label=\"Type\",",
            "    )",
            "    _schedule_name = forms.CharField(",
            "        required=False,",
            "        label=\"Schedule name\",",
            "        help_text=\"Name for the job schedule.\",",
            "    )",
            "    _schedule_start_time = forms.DateTimeField(",
            "        required=False,",
            "        label=\"Starting date and time\",",
            "        widget=DateTimePicker(),",
            "        help_text=f\"The scheduled time is relative to the Nautobot configured timezone: {settings.TIME_ZONE}.\",",
            "    )",
            "    _recurrence_custom_time = forms.CharField(",
            "        required=False,",
            "        label=\"Crontab\",",
            "        help_text=\"Custom crontab syntax (* * * * *)\",",
            "    )",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Validate all required information is present if the job needs to be scheduled",
            "        \"\"\"",
            "        cleaned_data = super().clean()",
            "",
            "        if \"_schedule_type\" in cleaned_data and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY:",
            "            if not cleaned_data.get(\"_schedule_name\"):",
            "                raise ValidationError({\"_schedule_name\": \"Please provide a name for the job schedule.\"})",
            "",
            "            if (",
            "                not cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_type\") != JobExecutionType.TYPE_CUSTOM",
            "            ) or (",
            "                cleaned_data.get(\"_schedule_start_time\")",
            "                and cleaned_data.get(\"_schedule_start_time\") < ScheduledJob.earliest_possible_time()",
            "            ):",
            "                raise ValidationError(",
            "                    {",
            "                        \"_schedule_start_time\": \"Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                    }",
            "                )",
            "",
            "            if cleaned_data.get(\"_schedule_type\") == JobExecutionType.TYPE_CUSTOM:",
            "                try:",
            "                    ScheduledJob.get_crontab(cleaned_data.get(\"_recurrence_custom_time\"))",
            "                except Exception as e:",
            "                    raise ValidationError({\"_recurrence_custom_time\": e})",
            "",
            "",
            "class JobResultFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobResult",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/jobs/\", api_version=\"1.3\"),",
            "    )",
            "    # 2.0 TODO(glenn) filtering by obj_type should be solved by dynamic filter form generation",
            "    name = forms.CharField(required=False)",
            "    user = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    status = forms.MultipleChoiceField(",
            "        choices=JobResultStatusChoices,",
            "        required=False,",
            "        widget=StaticSelect2Multiple(),",
            "    )",
            "",
            "",
            "class ScheduledJobFilterForm(BootstrapMixin, forms.Form):",
            "    model = ScheduledJob",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    name = forms.CharField(required=False)",
            "    job_model = DynamicModelMultipleChoiceField(",
            "        label=\"Job\",",
            "        queryset=Job.objects.all(),",
            "        required=False,",
            "        to_field_name=\"slug\",",
            "        widget=APISelectMultiple(api_url=\"/api/extras/job-models/\"),",
            "    )",
            "    total_run_count = forms.IntegerField(required=False)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "    class Meta:",
            "        model = JobButton",
            "        fields = (",
            "            \"content_types\",",
            "            \"name\",",
            "            \"text\",",
            "            \"job\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"confirmation\",",
            "        )",
            "",
            "",
            "class JobButtonBulkEditForm(BootstrapMixin, BulkEditForm):",
            "    \"\"\"Bulk edit form for `JobButton` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=JobButton.objects.all(), widget=forms.MultipleHiddenInput)",
            "    content_types = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        label=\"Object Types\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "        required=False,",
            "    )",
            "    weight = forms.IntegerField(required=False)",
            "    group_name = forms.CharField(required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"group_name\"]",
            "",
            "",
            "class JobButtonFilterForm(BootstrapMixin, forms.Form):",
            "    model = JobButton",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = CSVContentTypeField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Types\",",
            "    )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteForm(BootstrapMixin, forms.ModelForm):",
            "    note = CommentField",
            "",
            "    class Meta:",
            "        model = Note",
            "        fields = [\"assigned_object_type\", \"assigned_object_id\", \"note\"]",
            "        widgets = {",
            "            \"assigned_object_type\": forms.HiddenInput,",
            "            \"assigned_object_id\": forms.HiddenInput,",
            "        }",
            "",
            "",
            "#",
            "# Filter form for local config context data",
            "#",
            "",
            "",
            "class LocalContextFilterForm(forms.Form):",
            "    local_context_data = forms.NullBooleanField(",
            "        required=False,",
            "        label=\"Has local config context data\",",
            "        widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES),",
            "    )",
            "    local_context_schema = DynamicModelMultipleChoiceField(",
            "        queryset=ConfigContextSchema.objects.all(), to_field_name=\"slug\", required=False",
            "    )",
            "",
            "",
            "#",
            "# Model form for local config context data",
            "#",
            "",
            "",
            "class LocalContextModelForm(forms.ModelForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "    local_context_data = JSONField(required=False, label=\"\")",
            "",
            "",
            "class LocalContextModelBulkEditForm(BulkEditForm):",
            "    local_context_schema = DynamicModelChoiceField(queryset=ConfigContextSchema.objects.all(), required=False)",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # append nullable fields",
            "        self.nullable_fields.append(\"local_context_schema\")",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeFilterForm(BootstrapMixin, forms.Form):",
            "    model = ObjectChange",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    time__gte = forms.DateTimeField(label=\"After\", required=False, widget=DateTimePicker())",
            "    time__lte = forms.DateTimeField(label=\"Before\", required=False, widget=DateTimePicker())",
            "    action = forms.ChoiceField(",
            "        choices=add_blank_choice(ObjectChangeActionChoices),",
            "        required=False,",
            "        widget=StaticSelect2(),",
            "    )",
            "    user_id = DynamicModelMultipleChoiceField(",
            "        queryset=get_user_model().objects.all(),",
            "        required=False,",
            "        label=\"User\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/users/users/\",",
            "        ),",
            "    )",
            "    changed_object_type_id = DynamicModelMultipleChoiceField(",
            "        queryset=ContentType.objects.all(),",
            "        required=False,",
            "        label=\"Object Type\",",
            "        widget=APISelectMultiple(",
            "            api_url=\"/api/extras/content-types/\",",
            "        ),",
            "    )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipForm(BootstrapMixin, forms.ModelForm):",
            "    slug = SlugField(help_text=\"Internal name of this relationship. Please use underscores rather than dashes.\")",
            "    source_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The source object type to which this relationship applies.\",",
            "    )",
            "    source_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable source objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "    destination_type = forms.ModelChoiceField(",
            "        queryset=ContentType.objects.filter(FeatureQuery(\"relationships\").get_query()).order_by(\"app_label\", \"model\"),",
            "        help_text=\"The destination object type to which this relationship applies.\",",
            "    )",
            "    destination_filter = JSONField(",
            "        required=False,",
            "        help_text=\"Filterset filter matching the applicable destination objects of the selected type.<br>\"",
            "        'Enter in <a href=\"https://json.org/\">JSON</a> format.',",
            "    )",
            "",
            "    class Meta:",
            "        model = Relationship",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"type\",",
            "            \"required_on\",",
            "            \"advanced_ui\",",
            "            \"source_type\",",
            "            \"source_label\",",
            "            \"source_hidden\",",
            "            \"source_filter\",",
            "            \"destination_type\",",
            "            \"destination_label\",",
            "            \"destination_hidden\",",
            "            \"destination_filter\",",
            "        ]",
            "",
            "    def save(self, commit=True):",
            "        # TODO add support for owner when a CR is created in the UI",
            "        obj = super().save(commit)",
            "",
            "        return obj",
            "",
            "",
            "class RelationshipFilterForm(BootstrapMixin, forms.Form):",
            "    model = Relationship",
            "",
            "    type = forms.MultipleChoiceField(choices=RelationshipTypeChoices, required=False, widget=StaticSelect2Multiple())",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "class RelationshipAssociationFilterForm(BootstrapMixin, forms.Form):",
            "    model = RelationshipAssociation",
            "",
            "    relationship = DynamicModelMultipleChoiceField(",
            "        queryset=Relationship.objects.all(),",
            "        to_field_name=\"slug\",",
            "        required=False,",
            "    )",
            "",
            "    source_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Source Type\"",
            "    )",
            "",
            "    destination_type = MultipleContentTypeField(",
            "        feature=\"relationships\", choices_as_strings=True, required=False, label=\"Destination Type\"",
            "    )",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "def provider_choices():",
            "    return sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()])",
            "",
            "",
            "class SecretForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `Secret` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    provider = forms.ChoiceField(choices=provider_choices, widget=StaticSelect2())",
            "",
            "    parameters = JSONField(help_text='Enter parameters in <a href=\"https://json.org/\">JSON</a> format.')",
            "",
            "    class Meta:",
            "        model = Secret",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "            \"provider\",",
            "            \"parameters\",",
            "            \"tags\",",
            "        ]",
            "",
            "",
            "class SecretCSVForm(CustomFieldModelCSVForm):",
            "    class Meta:",
            "        model = Secret",
            "        fields = Secret.csv_headers",
            "",
            "",
            "def provider_choices_with_blank():",
            "    return add_blank_choice(sorted([(slug, provider.name) for slug, provider in registry[\"secrets_providers\"].items()]))",
            "",
            "",
            "class SecretFilterForm(NautobotFilterForm):",
            "    model = Secret",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    provider = forms.MultipleChoiceField(",
            "        choices=provider_choices_with_blank, widget=StaticSelect2Multiple(), required=False",
            "    )",
            "    tag = TagFilterField(model)",
            "",
            "",
            "# Inline formset for use with providing dynamic rows when creating/editing assignments of Secrets to SecretsGroups.",
            "SecretsGroupAssociationFormSet = inlineformset_factory(",
            "    parent_model=SecretsGroup,",
            "    model=SecretsGroupAssociation,",
            "    fields=(\"access_type\", \"secret_type\", \"secret\"),",
            "    extra=5,",
            "    widgets={",
            "        \"access_type\": StaticSelect2,",
            "        \"secret_type\": StaticSelect2,",
            "        \"secret\": APISelect(api_url=\"/api/extras/secrets/\"),",
            "    },",
            ")",
            "",
            "",
            "class SecretsGroupForm(NautobotModelForm):",
            "    \"\"\"Create/update form for `SecretsGroup` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = SecretsGroup",
            "        fields = [",
            "            \"name\",",
            "            \"slug\",",
            "            \"description\",",
            "        ]",
            "",
            "",
            "class SecretsGroupFilterForm(NautobotFilterForm):",
            "    model = SecretsGroup",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusForm(NautobotModelForm):",
            "    \"\"\"Generic create/update form for `Status` objects.\"\"\"",
            "",
            "    slug = SlugField()",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Status",
            "        widgets = {\"color\": ColorSelect()}",
            "        fields = [\"name\", \"slug\", \"description\", \"content_types\", \"color\"]",
            "",
            "",
            "class StatusCSVForm(CustomFieldModelCSVForm):",
            "    \"\"\"Generic CSV bulk import form for `Status` objects.\"\"\"",
            "",
            "    content_types = CSVMultipleContentTypeField(",
            "        feature=\"statuses\",",
            "        choices_as_strings=True,",
            "        help_text=mark_safe(  # noqa: S308",
            "            \"The object types to which this status applies. Multiple values \"",
            "            \"must be comma-separated and wrapped in double quotes. (e.g. \"",
            "            '<code>\"dcim.device,dcim.rack\"</code>)'",
            "        ),",
            "        label=\"Content type(s)\",",
            "    )",
            "",
            "    class Meta:",
            "        model = Status",
            "        fields = Status.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "class StatusFilterForm(NautobotFilterForm):",
            "    \"\"\"Filtering/search form for `Status` objects.\"\"\"",
            "",
            "    model = Status",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"statuses\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "",
            "",
            "class StatusBulkEditForm(NautobotBulkEditForm):",
            "    \"\"\"Bulk edit/delete form for `Status` objects.\"\"\"",
            "",
            "    pk = forms.ModelMultipleChoiceField(queryset=Status.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    content_types = MultipleContentTypeField(feature=\"statuses\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        nullable_fields = []",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagForm(NautobotModelForm):",
            "    slug = SlugField()",
            "    content_types = ModelMultipleChoiceField(",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = [\"name\", \"slug\", \"color\", \"description\", \"content_types\"]",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        if self.instance.present_in_database:",
            "            # check if tag is assigned to any of the removed content_types",
            "            content_types_id = [content_type.id for content_type in self.cleaned_data[\"content_types\"]]",
            "            errors = self.instance.validate_content_types_removal(content_types_id)",
            "",
            "            if errors:",
            "                raise ValidationError(errors)",
            "",
            "        return data",
            "",
            "",
            "class TagCSVForm(CustomFieldModelCSVForm):",
            "    slug = SlugField()",
            "",
            "    class Meta:",
            "        model = Tag",
            "        fields = Tag.csv_headers",
            "        help_texts = {",
            "            \"color\": mark_safe(\"RGB color in hexadecimal (e.g. <code>00ff00</code>)\"),  # noqa: S308",
            "        }",
            "",
            "",
            "class TagFilterForm(NautobotFilterForm):",
            "    model = Tag",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        choices_as_strings=True,",
            "        required=False,",
            "        label=\"Content Type(s)\",",
            "        queryset=TaggableClassesQuery().as_queryset(),",
            "    )",
            "",
            "",
            "class TagBulkEditForm(NautobotBulkEditForm):",
            "    pk = forms.ModelMultipleChoiceField(queryset=Tag.objects.all(), widget=forms.MultipleHiddenInput)",
            "    color = forms.CharField(max_length=6, required=False, widget=ColorSelect())",
            "    description = forms.CharField(max_length=200, required=False)",
            "",
            "    class Meta:",
            "        nullable_fields = [\"description\"]",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookForm(BootstrapMixin, forms.ModelForm):",
            "    content_types = MultipleContentTypeField(feature=\"webhooks\", required=False, label=\"Content Type(s)\")",
            "",
            "    class Meta:",
            "        model = Webhook",
            "        fields = (",
            "            \"name\",",
            "            \"content_types\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "            \"payload_url\",",
            "            \"http_method\",",
            "            \"http_content_type\",",
            "            \"additional_headers\",",
            "            \"body_template\",",
            "            \"secret\",",
            "            \"ssl_verification\",",
            "            \"ca_file_path\",",
            "        )",
            "",
            "    def clean(self):",
            "        data = super().clean()",
            "",
            "        conflicts = Webhook.check_for_conflicts(",
            "            instance=self.instance,",
            "            content_types=self.cleaned_data.get(\"content_types\"),",
            "            payload_url=self.cleaned_data.get(\"payload_url\"),",
            "            type_create=self.cleaned_data.get(\"type_create\"),",
            "            type_update=self.cleaned_data.get(\"type_update\"),",
            "            type_delete=self.cleaned_data.get(\"type_delete\"),",
            "        )",
            "",
            "        if conflicts:",
            "            raise ValidationError(conflicts)",
            "",
            "        return data",
            "",
            "",
            "class WebhookFilterForm(BootstrapMixin, forms.Form):",
            "    model = Webhook",
            "    q = forms.CharField(required=False, label=\"Search\")",
            "    content_types = MultipleContentTypeField(",
            "        feature=\"webhooks\", choices_as_strings=True, required=False, label=\"Content Type(s)\"",
            "    )",
            "    type_create = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_update = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    type_delete = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))",
            "    enabled = forms.NullBooleanField(required=False, widget=StaticSelect2(choices=BOOLEAN_WITH_BLANK_CHOICES))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "651": [
                "GitRepositoryCSVForm",
                "__init__"
            ],
            "1355": [
                "StatusCSVForm"
            ],
            "1367": [
                "StatusCSVForm",
                "Meta"
            ],
            "1430": [
                "TagCSVForm",
                "Meta"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/models/customfields.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from django.db import models"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from django.forms.widgets import TextInput"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from django.urls import reverse"
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from nautobot.extras.choices import CustomFieldFilterLogicChoices, CustomFieldTypeChoices"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from nautobot.extras.models import ChangeLoggedModel"
            },
            "8": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "                 field.validators = ["
            },
            "9": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "                     RegexValidator("
            },
            "10": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "                         regex=self.validation_regex,"
            },
            "11": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        message=mark_safe(f\"Values must match this regex: <code>{self.validation_regex}</code>\"),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+                        message=format_html(\"Values must match this regex: <code>{}</code>\", self.validation_regex),"
            },
            "13": {
                "beforePatchRowNumber": 550,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "                     )"
            },
            "14": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "                 ]"
            },
            "15": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 552,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import logging",
            "import re",
            "from collections import OrderedDict",
            "from datetime import datetime, date",
            "",
            "from django import forms",
            "from django.db import transaction",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.validators import RegexValidator, ValidationError",
            "from django.db import models",
            "from django.forms.widgets import TextInput",
            "from django.urls import reverse",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.extras.choices import CustomFieldFilterLogicChoices, CustomFieldTypeChoices",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.extras.tasks import delete_custom_field_data, update_custom_field_choice_data",
            "from nautobot.extras.utils import FeatureQuery, extras_features",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models import BaseModel",
            "from nautobot.utilities.forms import (",
            "    CommentField,",
            "    CSVChoiceField,",
            "    CSVMultipleChoiceField,",
            "    DatePicker,",
            "    JSONField,",
            "    LaxURLField,",
            "    NullableDateField,",
            "    SmallTextarea,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    add_blank_choice,",
            ")",
            "from nautobot.utilities.querysets import RestrictedQuerySet",
            "from nautobot.utilities.templatetags.helpers import render_markdown",
            "from nautobot.utilities.utils import render_jinja2, slugify_dashes_to_underscores",
            "from nautobot.utilities.validators import validate_regex",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ComputedFieldManager(models.Manager.from_queryset(RestrictedQuerySet)):",
            "    use_in_migrations = True",
            "",
            "    def get_for_model(self, model):",
            "        \"\"\"",
            "        Return all ComputedFields assigned to the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return self.get_queryset().filter(content_type=content_type)",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class ComputedField(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    Read-only rendered fields driven by a Jinja2 template that are applied to objects within a ContentType.",
            "    \"\"\"",
            "",
            "    content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"custom_fields\"),",
            "    )",
            "    slug = AutoSlugField(",
            "        populate_from=\"label\",",
            "        help_text=\"Internal field name. Please use underscores rather than dashes in this slug.\",",
            "        slugify_function=slugify_dashes_to_underscores,",
            "    )",
            "    label = models.CharField(max_length=100, help_text=\"Name of the field as displayed to users\")",
            "    description = models.CharField(max_length=200, blank=True)",
            "    template = models.TextField(max_length=500, help_text=\"Jinja2 template code for field value\")",
            "    fallback_value = models.CharField(",
            "        max_length=500,",
            "        blank=True,",
            "        help_text=\"Fallback value (if any) to be output for the field in the case of a template rendering error.\",",
            "    )",
            "    weight = models.PositiveSmallIntegerField(default=100)",
            "    advanced_ui = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Move to Advanced tab\",",
            "        help_text=\"Hide this field from the object's primary information tab. \"",
            "        'It will appear in the \"Advanced\" tab instead.',",
            "    )",
            "",
            "    objects = ComputedFieldManager()",
            "",
            "    clone_fields = [\"content_type\", \"description\", \"template\", \"fallback_value\", \"weight\"]",
            "",
            "    class Meta:",
            "        ordering = [\"weight\", \"slug\"]",
            "        unique_together = (\"content_type\", \"label\")",
            "",
            "    def __str__(self):",
            "        return self.label",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:computedfield\", args=[self.slug])",
            "",
            "    def render(self, context):",
            "        try:",
            "            rendered = render_jinja2(self.template, context)",
            "            # If there is an undefined variable within a template, it returns nothing",
            "            # Doesn't raise an exception either most likely due to using Undefined rather",
            "            # than StrictUndefined, but return fallback_value if None is returned",
            "            if rendered is None:",
            "                logger.warning(\"Failed to render computed field %s\", self.slug)",
            "                return self.fallback_value",
            "            return rendered",
            "        except Exception as exc:",
            "            logger.warning(\"Failed to render computed field %s: %s\", self.slug, exc)",
            "            return self.fallback_value",
            "",
            "",
            "class CustomFieldModel(models.Model):",
            "    \"\"\"",
            "    Abstract class for any model which may have custom fields associated with it.",
            "    \"\"\"",
            "",
            "    _custom_field_data = models.JSONField(encoder=DjangoJSONEncoder, blank=True, default=dict)",
            "",
            "    class Meta:",
            "        abstract = True",
            "",
            "    @property",
            "    def custom_field_data(self):",
            "        \"\"\"",
            "        Legacy interface to raw custom field data",
            "",
            "        TODO(John): remove this entirely when the cf property is enhanced",
            "        \"\"\"",
            "        return self._custom_field_data",
            "",
            "    @property",
            "    def cf(self):",
            "        \"\"\"",
            "        Convenience wrapper for custom field data.",
            "        \"\"\"",
            "        return self._custom_field_data",
            "",
            "    def get_custom_fields_basic(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_fields() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictionary of custom fields for a single object in the form {<field>: value}",
            "        which have advanced_ui set to False",
            "        \"\"\"",
            "        return self.get_custom_fields(advanced_ui=False)",
            "",
            "    def get_custom_fields_advanced(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_fields() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictionary of custom fields for a single object in the form {<field>: value}",
            "        which have advanced_ui set to True",
            "        \"\"\"",
            "        return self.get_custom_fields(advanced_ui=True)",
            "",
            "    def get_custom_fields(self, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictionary of custom fields for a single object in the form {<field>: value}.",
            "        \"\"\"",
            "        fields = CustomField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            fields = fields.filter(advanced_ui=advanced_ui)",
            "        # 2.0 TODO: #824 field.slug rather than field.name",
            "        return OrderedDict([(field, self.cf.get(field.name)) for field in fields])",
            "",
            "    def get_custom_field_groupings_basic(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_field_groupings() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictonary of custom fields grouped by the same grouping in the form",
            "        {",
            "            <grouping_1>: [(cf1, <value for cf1>), (cf2, <value for cf2>), ...],",
            "            ...",
            "            <grouping_5>: [(cf8, <value for cf8>), (cf9, <value for cf9>), ...],",
            "            ...",
            "        }",
            "        which have advanced_ui set to False",
            "        \"\"\"",
            "        return self.get_custom_field_groupings(advanced_ui=False)",
            "",
            "    def get_custom_field_groupings_advanced(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_field_groupings() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictonary of custom fields grouped by the same grouping in the form",
            "        {",
            "            <grouping_1>: [(cf1, <value for cf1>), (cf2, <value for cf2>), ...],",
            "            ...",
            "            <grouping_5>: [(cf8, <value for cf8>), (cf9, <value for cf9>), ...],",
            "            ...",
            "        }",
            "        which have advanced_ui set to True",
            "        \"\"\"",
            "        return self.get_custom_field_groupings(advanced_ui=True)",
            "",
            "    def get_custom_field_groupings(self, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictonary of custom fields grouped by the same grouping in the form",
            "        {",
            "            <grouping_1>: [(cf1, <value for cf1>), (cf2, <value for cf2>), ...],",
            "            ...",
            "            <grouping_5>: [(cf8, <value for cf8>), (cf9, <value for cf9>), ...],",
            "            ...",
            "        }",
            "        \"\"\"",
            "        record = {}",
            "        fields = CustomField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            fields = fields.filter(advanced_ui=advanced_ui)",
            "",
            "        for field in fields:",
            "            data = (field, self.cf.get(field.name))",
            "            record.setdefault(field.grouping, []).append(data)",
            "        record = dict(sorted(record.items()))",
            "        return record",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # 2.0 TODO: #824 replace cf.name with cf.slug",
            "        custom_fields = {cf.name: cf for cf in CustomField.objects.get_for_model(self)}",
            "",
            "        # Validate all field values",
            "        for field_name, value in self._custom_field_data.items():",
            "            if field_name not in custom_fields:",
            "                # log a warning instead of raising a ValidationError so as not to break the UI",
            "                logger.warning(f\"Unknown field name '{field_name}' in custom field data for {self} ({self.pk}).\")",
            "                continue",
            "            try:",
            "                custom_fields[field_name].validate(value)",
            "            except ValidationError as e:",
            "                raise ValidationError(f\"Invalid value for custom field '{field_name}': {e.message}\")",
            "",
            "        # Check for missing values, erroring on required ones and populating non-required ones automatically",
            "        for cf in custom_fields.values():",
            "            # 2.0 TODO: #824 replace cf.name with cf.slug",
            "            if cf.name not in self._custom_field_data:",
            "                if cf.default is not None:",
            "                    self._custom_field_data[cf.name] = cf.default",
            "                elif cf.required:",
            "                    raise ValidationError(f\"Missing required custom field '{cf.name}'.\")",
            "",
            "    # Computed Field Methods",
            "    def has_computed_fields(self, advanced_ui=None):",
            "        \"\"\"",
            "        Return a boolean indicating whether or not this content type has computed fields associated with it.",
            "        This can also check whether the advanced_ui attribute is True or False for UI display purposes.",
            "        \"\"\"",
            "        computed_fields = ComputedField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            computed_fields = computed_fields.filter(advanced_ui=advanced_ui)",
            "        return computed_fields.exists()",
            "",
            "    def has_computed_fields_basic(self):",
            "        return self.has_computed_fields(advanced_ui=False)",
            "",
            "    def has_computed_fields_advanced(self):",
            "        return self.has_computed_fields(advanced_ui=True)",
            "",
            "    def get_computed_field(self, slug, render=True):",
            "        \"\"\"",
            "        Get a computed field for this model, lookup via slug.",
            "        Returns the template of this field if render is False, otherwise returns the rendered value.",
            "        \"\"\"",
            "        try:",
            "            computed_field = ComputedField.objects.get_for_model(self).get(slug=slug)",
            "        except ComputedField.DoesNotExist:",
            "            logger.warning(\"Computed Field with slug %s does not exist for model %s\", slug, self._meta.verbose_name)",
            "            return None",
            "        if render:",
            "            return computed_field.render(context={\"obj\": self})",
            "        return computed_field.template",
            "",
            "    def get_computed_fields(self, label_as_key=False, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictionary of all computed fields and their rendered values for this model.",
            "        Keys are the `slug` value of each field. If label_as_key is True, `label` values of each field are used as keys.",
            "        \"\"\"",
            "        computed_fields_dict = {}",
            "        computed_fields = ComputedField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            computed_fields = computed_fields.filter(advanced_ui=advanced_ui)",
            "        if not computed_fields:",
            "            return {}",
            "        for cf in computed_fields:",
            "            computed_fields_dict[cf.label if label_as_key else cf.slug] = cf.render(context={\"obj\": self})",
            "        return computed_fields_dict",
            "",
            "",
            "class CustomFieldManager(models.Manager.from_queryset(RestrictedQuerySet)):",
            "    use_in_migrations = True",
            "",
            "    def get_for_model(self, model):",
            "        \"\"\"",
            "        Return all CustomFields assigned to the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return self.get_queryset().filter(content_types=content_type)",
            "",
            "",
            "@extras_features(\"webhooks\")",
            "class CustomField(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"custom_fields\",",
            "        verbose_name=\"Object(s)\",",
            "        limit_choices_to=FeatureQuery(\"custom_fields\"),",
            "        help_text=\"The object(s) to which this field applies.\",",
            "    )",
            "    grouping = models.CharField(",
            "        max_length=255,",
            "        blank=True,",
            "        help_text=\"Human-readable grouping that this custom field belongs to.\",",
            "    )",
            "    type = models.CharField(",
            "        max_length=50,",
            "        choices=CustomFieldTypeChoices,",
            "        default=CustomFieldTypeChoices.TYPE_TEXT,",
            "        help_text=\"The type of value(s) allowed for this field.\",",
            "    )",
            "    # 2.0 TODO: #824 remove `name` field as redundant, make `label` mandatory, populate `slug` from `label` field.",
            "    name = models.CharField(max_length=50, unique=True, help_text=\"Human-readable unique name of this field.\")",
            "    label = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        help_text=\"Name of the field as displayed to users (if not provided, the field's name will be used.)\",",
            "    )",
            "    slug = AutoSlugField(",
            "        blank=False,",
            "        max_length=50,",
            "        populate_from=\"label\",",
            "        help_text=\"Internal field name. Please use underscores rather than dashes in this slug.\",",
            "        slugify_function=slugify_dashes_to_underscores,",
            "    )",
            "    description = models.CharField(max_length=200, blank=True, help_text=\"A helpful description for this field.\")",
            "    required = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If true, this field is required when creating new objects or editing an existing object.\",",
            "    )",
            "    # todoindex:",
            "    filter_logic = models.CharField(",
            "        max_length=50,",
            "        choices=CustomFieldFilterLogicChoices,",
            "        default=CustomFieldFilterLogicChoices.FILTER_LOOSE,",
            "        help_text=\"Loose matches any instance of a given string; Exact matches the entire field.\",",
            "    )",
            "    default = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        help_text=(",
            "            \"Default value for the field (must be a JSON value). Encapsulate strings with double quotes (e.g. \"",
            "            '\"Foo\").'",
            "        ),",
            "    )",
            "    weight = models.PositiveSmallIntegerField(",
            "        default=100, help_text=\"Fields with higher weights appear lower in a form.\"",
            "    )",
            "    validation_minimum = models.BigIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Minimum value\",",
            "        help_text=\"Minimum allowed value (for numeric fields).\",",
            "    )",
            "    validation_maximum = models.BigIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Maximum value\",",
            "        help_text=\"Maximum allowed value (for numeric fields).\",",
            "    )",
            "    validation_regex = models.CharField(",
            "        blank=True,",
            "        validators=[validate_regex],",
            "        max_length=500,",
            "        verbose_name=\"Validation regex\",",
            "        help_text=\"Regular expression to enforce on text field values. Use ^ and $ to force matching of entire string. \"",
            "        \"For example, <code>^[A-Z]{3}$</code> will limit values to exactly three uppercase letters. Regular \"",
            "        \"expression on select and multi-select will be applied at <code>Custom Field Choices</code> definition.\",",
            "    )",
            "    advanced_ui = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Move to Advanced tab\",",
            "        help_text=\"Hide this field from the object's primary information tab. \"",
            "        'It will appear in the \"Advanced\" tab instead.',",
            "    )",
            "",
            "    objects = CustomFieldManager()",
            "",
            "    clone_fields = [",
            "        \"content_types\",",
            "        \"grouping\",",
            "        \"type\",",
            "        \"description\",",
            "        \"required\",",
            "        \"filter_logic\",",
            "        \"default\",",
            "        \"weight\",",
            "        \"validation_minimum\",",
            "        \"validation_maximum\",",
            "        \"validation_regex\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = [\"weight\", \"name\"]",
            "",
            "    def __str__(self):",
            "        return self.label or self.name.replace(\"_\", \" \").capitalize()",
            "",
            "    def _fixup_empty_fields(self):",
            "        \"\"\"Handle the case when a new instance is created and some fields are left blank.\"\"\"",
            "        if self.present_in_database:",
            "            return",
            "",
            "        # 2.0 TODO: this is to handle the UI case where `name` is no longer a directly configured form.",
            "        # Once `name` is no longer a model field, we can remove this.",
            "        if self.slug and not self.name:",
            "            self.name = self.slug",
            "",
            "        # 2.0 TODO: this is to fixup existing ORM usage when caller specifies a name but not a label;",
            "        # in 2.0 we should make `label` a mandatory field when getting rid of `name`.",
            "        if self.name and not self.label:",
            "            self.label = self.name",
            "",
            "        # This is to fix up existing ORM usage when caller doesn't specify a slug since it wasn't a field before.",
            "        if not self.slug:",
            "            self.slug = slugify_dashes_to_underscores(self.label or self.name)",
            "",
            "    def clean_fields(self, exclude=None):",
            "        # Ensure now-mandatory fields are correctly populated, as otherwise cleaning will fail.",
            "        self._fixup_empty_fields()",
            "        super().clean_fields(exclude=exclude)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        if self.present_in_database:",
            "            # Check immutable fields",
            "            database_object = self.__class__.objects.get(pk=self.pk)",
            "",
            "            # 2.0 TODO: #824 once self.name is no longer used as a dict key, can remove this constraint",
            "            if self.name != database_object.name:",
            "                raise ValidationError({\"name\": \"Name cannot be changed once created\"})",
            "",
            "            if self.slug != database_object.slug:",
            "                raise ValidationError({\"slug\": \"Slug cannot be changed once created\"})",
            "",
            "            if self.type != database_object.type:",
            "                raise ValidationError({\"type\": \"Type cannot be changed once created\"})",
            "",
            "        # Validate the field's default value (if any)",
            "        if self.default is not None:",
            "            try:",
            "                self.validate(self.default)",
            "            except ValidationError as err:",
            "                raise ValidationError({\"default\": f'Invalid default value \"{self.default}\": {err.message}'})",
            "",
            "        # Minimum/maximum values can be set only for numeric fields",
            "        if self.validation_minimum is not None and self.type != CustomFieldTypeChoices.TYPE_INTEGER:",
            "            raise ValidationError({\"validation_minimum\": \"A minimum value may be set only for numeric fields\"})",
            "        if self.validation_maximum is not None and self.type != CustomFieldTypeChoices.TYPE_INTEGER:",
            "            raise ValidationError({\"validation_maximum\": \"A maximum value may be set only for numeric fields\"})",
            "",
            "        # Regex validation can be set only for text, url, select and multi-select fields",
            "        if self.validation_regex and self.type not in CustomFieldTypeChoices.REGEX_TYPES:",
            "            raise ValidationError(",
            "                {\"validation_regex\": \"Regular expression validation is supported only for text, URL and select fields\"}",
            "            )",
            "",
            "        # Choices can be set only on selection fields",
            "        if self.choices.exists() and self.type not in (",
            "            CustomFieldTypeChoices.TYPE_SELECT,",
            "            CustomFieldTypeChoices.TYPE_MULTISELECT,",
            "        ):",
            "            raise ValidationError(\"Choices may be set only for custom selection fields.\")",
            "",
            "        # A selection field's default (if any) must be present in its available choices",
            "        if (",
            "            self.type == CustomFieldTypeChoices.TYPE_SELECT",
            "            and self.default",
            "            and self.default not in self.choices.values_list(\"value\", flat=True)",
            "        ):",
            "            raise ValidationError(",
            "                {\"default\": f\"The specified default value ({self.default}) is not listed as an available choice.\"}",
            "            )",
            "",
            "    def save(self, *args, **kwargs):",
            "        # Prior to Nautobot 1.4, `slug` was a non-existent field, but now it's mandatory.",
            "        # Protect against get_or_create() or other ORM usage where callers aren't calling clean() before saving.",
            "        # Normally we'd just say \"Don't do that!\" but we know there are some cases of this in the wild.",
            "        self._fixup_empty_fields()",
            "        super().save(*args, **kwargs)",
            "",
            "    def to_form_field(",
            "        self, set_initial=True, enforce_required=True, for_csv_import=False, simple_json_filter=False, label=None",
            "    ):",
            "        \"\"\"",
            "        Return a form field suitable for setting a CustomField's value for an object.",
            "        set_initial: Set initial date for the field. This should be False when generating a field for bulk editing.",
            "        enforce_required: Honor the value of CustomField.required. Set to False for filtering/bulk editing.",
            "        for_csv_import: Return a form field suitable for bulk import of objects in CSV format.",
            "        simple_json_filter: Return a TextInput widget for JSON filtering instead of the default TextArea widget.",
            "        label: Set the input label manually (if required) otherwise it will default to field's __str__() implementation.",
            "        \"\"\"",
            "        initial = self.default if set_initial else None",
            "        required = self.required if enforce_required else False",
            "",
            "        # Integer",
            "        if self.type == CustomFieldTypeChoices.TYPE_INTEGER:",
            "            field = forms.IntegerField(",
            "                required=required,",
            "                initial=initial,",
            "                min_value=self.validation_minimum,",
            "                max_value=self.validation_maximum,",
            "            )",
            "",
            "        # Boolean",
            "        elif self.type == CustomFieldTypeChoices.TYPE_BOOLEAN:",
            "            choices = (",
            "                (None, \"---------\"),",
            "                (True, \"True\"),",
            "                (False, \"False\"),",
            "            )",
            "            field = forms.NullBooleanField(",
            "                required=required,",
            "                initial=initial,",
            "                widget=StaticSelect2(choices=choices),",
            "            )",
            "",
            "        # Date",
            "        elif self.type == CustomFieldTypeChoices.TYPE_DATE:",
            "            field = NullableDateField(",
            "                required=required,",
            "                initial=initial,",
            "                widget=DatePicker(),",
            "            )",
            "",
            "        # Text and URL",
            "        elif self.type in (CustomFieldTypeChoices.TYPE_URL, CustomFieldTypeChoices.TYPE_TEXT):",
            "            if self.type == CustomFieldTypeChoices.TYPE_URL:",
            "                field = LaxURLField(required=required, initial=initial)",
            "            elif self.type == CustomFieldTypeChoices.TYPE_TEXT:",
            "                field = forms.CharField(max_length=255, required=required, initial=initial)",
            "",
            "            if self.validation_regex:",
            "                field.validators = [",
            "                    RegexValidator(",
            "                        regex=self.validation_regex,",
            "                        message=mark_safe(f\"Values must match this regex: <code>{self.validation_regex}</code>\"),",
            "                    )",
            "                ]",
            "",
            "        # Markdown",
            "        elif self.type == CustomFieldTypeChoices.TYPE_MARKDOWN:",
            "            field = CommentField(widget=SmallTextarea, label=None)",
            "",
            "        # JSON",
            "        elif self.type == CustomFieldTypeChoices.TYPE_JSON:",
            "            if simple_json_filter:",
            "                field = JSONField(encoder=DjangoJSONEncoder, required=required, initial=None, widget=TextInput)",
            "            else:",
            "                field = JSONField(encoder=DjangoJSONEncoder, required=required, initial=initial)",
            "",
            "        # Select or Multi-select",
            "        else:",
            "            choices = [(cfc.value, cfc.value) for cfc in self.choices.all()]",
            "            default_choice = self.choices.filter(value=self.default).first()",
            "",
            "            if not required or default_choice is None:",
            "                choices = add_blank_choice(choices)",
            "",
            "            # Set the initial value to the first available choice (if any)",
            "            if set_initial and default_choice:",
            "                initial = default_choice.value",
            "",
            "            if self.type == CustomFieldTypeChoices.TYPE_SELECT:",
            "                field_class = CSVChoiceField if for_csv_import else forms.ChoiceField",
            "                field = field_class(",
            "                    choices=choices,",
            "                    required=required,",
            "                    initial=initial,",
            "                    widget=StaticSelect2(),",
            "                )",
            "            else:",
            "                field_class = CSVMultipleChoiceField if for_csv_import else forms.MultipleChoiceField",
            "                field = field_class(choices=choices, required=required, initial=initial, widget=StaticSelect2Multiple())",
            "",
            "        field.model = self",
            "        if label is not None:",
            "            field.label = label",
            "        else:",
            "            field.label = str(self)",
            "",
            "        if self.description:",
            "            # Avoid script injection and similar attacks! Output HTML but only accept Markdown as input",
            "            field.help_text = render_markdown(self.description)",
            "",
            "        return field",
            "",
            "    def validate(self, value):",
            "        \"\"\"",
            "        Validate a value according to the field's type validation rules.",
            "        \"\"\"",
            "        if value not in [None, \"\", []]:",
            "            # Validate text field",
            "            if self.type in (CustomFieldTypeChoices.TYPE_TEXT, CustomFieldTypeChoices.TYPE_URL):",
            "                if not isinstance(value, str):",
            "                    raise ValidationError(\"Value must be a string\")",
            "",
            "                if self.validation_regex and not re.search(self.validation_regex, value):",
            "                    raise ValidationError(f\"Value must match regex '{self.validation_regex}'\")",
            "",
            "            # Validate integer",
            "            if self.type == CustomFieldTypeChoices.TYPE_INTEGER:",
            "                try:",
            "                    int(value)",
            "                except ValueError:",
            "                    raise ValidationError(\"Value must be an integer.\")",
            "                if self.validation_minimum is not None and value < self.validation_minimum:",
            "                    raise ValidationError(f\"Value must be at least {self.validation_minimum}\")",
            "                if self.validation_maximum is not None and value > self.validation_maximum:",
            "                    raise ValidationError(f\"Value must not exceed {self.validation_maximum}\")",
            "",
            "            # Validate boolean",
            "            if self.type == CustomFieldTypeChoices.TYPE_BOOLEAN and value not in [",
            "                True,",
            "                False,",
            "                1,",
            "                0,",
            "            ]:",
            "                raise ValidationError(\"Value must be true or false.\")",
            "",
            "            # Validate date",
            "            if self.type == CustomFieldTypeChoices.TYPE_DATE:",
            "                if not isinstance(value, date):",
            "                    try:",
            "                        datetime.strptime(value, \"%Y-%m-%d\")",
            "                    except ValueError:",
            "                        raise ValidationError(\"Date values must be in the format YYYY-MM-DD.\")",
            "",
            "            # Validate selected choice",
            "            if self.type == CustomFieldTypeChoices.TYPE_SELECT:",
            "                if value not in self.choices.values_list(\"value\", flat=True):",
            "                    raise ValidationError(",
            "                        f\"Invalid choice ({value}). Available choices are: {', '.join(self.choices.values_list('value', flat=True))}\"",
            "                    )",
            "",
            "            if self.type == CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "                if not set(value).issubset(self.choices.values_list(\"value\", flat=True)):",
            "                    raise ValidationError(",
            "                        f\"Invalid choice(s) ({value}). Available choices are: {', '.join(self.choices.values_list('value', flat=True))}\"",
            "                    )",
            "",
            "        elif self.required:",
            "            raise ValidationError(\"Required field cannot be empty.\")",
            "",
            "    def delete(self, *args, **kwargs):",
            "        \"\"\"",
            "        Handle the cleanup of old custom field data when a CustomField is deleted.",
            "        \"\"\"",
            "        content_types = set(self.content_types.values_list(\"pk\", flat=True))",
            "",
            "        super().delete(*args, **kwargs)",
            "",
            "        # 2.0 TODO: #824 use self.slug as key instead of self.name",
            "        delete_custom_field_data.delay(self.name, content_types)",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:customfield\", args=[self.slug])",
            "",
            "",
            "@extras_features(",
            "    \"graphql\",",
            "    \"webhooks\",",
            ")",
            "class CustomFieldChoice(BaseModel, ChangeLoggedModel):",
            "    \"\"\"",
            "    The custom field choice is used to store the possible set of values for a selection type custom field",
            "    \"\"\"",
            "",
            "    field = models.ForeignKey(",
            "        to=\"extras.CustomField\",",
            "        on_delete=models.CASCADE,",
            "        related_name=\"choices\",",
            "        limit_choices_to=models.Q(",
            "            type__in=[CustomFieldTypeChoices.TYPE_SELECT, CustomFieldTypeChoices.TYPE_MULTISELECT]",
            "        ),",
            "    )",
            "    value = models.CharField(max_length=100)",
            "    weight = models.PositiveSmallIntegerField(default=100, help_text=\"Higher weights appear later in the list\")",
            "",
            "    class Meta:",
            "        ordering = [\"field\", \"weight\", \"value\"]",
            "        unique_together = [\"field\", \"value\"]",
            "",
            "    def __str__(self):",
            "        return self.value",
            "",
            "    def get_absolute_url(self):",
            "        # 2.0 TODO: replace slug with pk",
            "        return reverse(\"extras:customfield\", args=[self.field.slug])",
            "",
            "    def clean(self):",
            "        if self.field.type not in (CustomFieldTypeChoices.TYPE_SELECT, CustomFieldTypeChoices.TYPE_MULTISELECT):",
            "            raise ValidationError(\"Custom field choices can only be assigned to selection fields.\")",
            "",
            "        if not re.search(self.field.validation_regex, self.value):",
            "            raise ValidationError(f\"Value must match regex {self.field.validation_regex} got {self.value}.\")",
            "",
            "    def save(self, *args, **kwargs):",
            "        \"\"\"",
            "        When a custom field choice is saved, perform logic that will update data across all custom field data.",
            "        \"\"\"",
            "        if self.present_in_database:",
            "            database_object = self.__class__.objects.get(pk=self.pk)",
            "        else:",
            "            database_object = self",
            "",
            "        super().save(*args, **kwargs)",
            "",
            "        if self.value != database_object.value:",
            "            transaction.on_commit(",
            "                lambda: update_custom_field_choice_data.delay(self.field.pk, database_object.value, self.value)",
            "            )",
            "",
            "    def delete(self, *args, **kwargs):",
            "        \"\"\"",
            "        When a custom field choice is deleted, remove references to in custom field data",
            "        \"\"\"",
            "        if self.field.default:",
            "            # Cannot delete the choice if it is the default value.",
            "            if self.field.type == CustomFieldTypeChoices.TYPE_SELECT and self.field.default == self.value:",
            "                raise models.ProtectedError(",
            "                    msg=\"Cannot delete this choice because it is the default value for the field.\",",
            "                    protected_objects=[self],  # TODO: should this be self.field instead?",
            "                )",
            "            elif self.value in self.field.default:",
            "                raise models.ProtectedError(",
            "                    msg=\"Cannot delete this choice because it is one of the default values for the field.\",",
            "                    protected_objects=[self],  # TODO: should this be self.field instead?",
            "                )",
            "",
            "        if self.field.type == CustomFieldTypeChoices.TYPE_SELECT:",
            "            # Check if this value is in active use in a select field",
            "            for ct in self.field.content_types.all():",
            "                model = ct.model_class()",
            "                # 2.0 TODO: #824 self.field.slug instead of self.field.name",
            "                if model.objects.filter(**{f\"_custom_field_data__{self.field.name}\": self.value}).exists():",
            "                    raise models.ProtectedError(",
            "                        msg=\"Cannot delete this choice because it is in active use.\",",
            "                        protected_objects=[self],  # TODO should this be model.objects.filter(...) instead?",
            "                    )",
            "",
            "        else:",
            "            # Check if this value is in active use in a multi-select field",
            "            for ct in self.field.content_types.all():",
            "                model = ct.model_class()",
            "                # 2.0 TODO: #824 self.field.slug instead of self.field.name",
            "                if model.objects.filter(**{f\"_custom_field_data__{self.field.name}__contains\": self.value}).exists():",
            "                    raise models.ProtectedError(",
            "                        msg=\"Cannot delete this choice because it is in active use.\",",
            "                        protected_objects=[self],  # TODO should this be model.objects.filter(...) instead?",
            "                    )",
            "",
            "        super().delete(*args, **kwargs)",
            "",
            "    def to_objectchange(self, action, related_object=None, **kwargs):",
            "        # Annotate the parent field",
            "        try:",
            "            field = self.field",
            "        except ObjectDoesNotExist:",
            "            # The parent field has already been deleted",
            "            field = None",
            "",
            "        return super().to_objectchange(action, related_object=field, **kwargs)"
        ],
        "afterPatchFile": [
            "import logging",
            "import re",
            "from collections import OrderedDict",
            "from datetime import datetime, date",
            "",
            "from django import forms",
            "from django.db import transaction",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.validators import RegexValidator, ValidationError",
            "from django.db import models",
            "from django.forms.widgets import TextInput",
            "from django.urls import reverse",
            "from django.utils.html import format_html",
            "",
            "from nautobot.extras.choices import CustomFieldFilterLogicChoices, CustomFieldTypeChoices",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.extras.tasks import delete_custom_field_data, update_custom_field_choice_data",
            "from nautobot.extras.utils import FeatureQuery, extras_features",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models import BaseModel",
            "from nautobot.utilities.forms import (",
            "    CommentField,",
            "    CSVChoiceField,",
            "    CSVMultipleChoiceField,",
            "    DatePicker,",
            "    JSONField,",
            "    LaxURLField,",
            "    NullableDateField,",
            "    SmallTextarea,",
            "    StaticSelect2,",
            "    StaticSelect2Multiple,",
            "    add_blank_choice,",
            ")",
            "from nautobot.utilities.querysets import RestrictedQuerySet",
            "from nautobot.utilities.templatetags.helpers import render_markdown",
            "from nautobot.utilities.utils import render_jinja2, slugify_dashes_to_underscores",
            "from nautobot.utilities.validators import validate_regex",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ComputedFieldManager(models.Manager.from_queryset(RestrictedQuerySet)):",
            "    use_in_migrations = True",
            "",
            "    def get_for_model(self, model):",
            "        \"\"\"",
            "        Return all ComputedFields assigned to the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return self.get_queryset().filter(content_type=content_type)",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class ComputedField(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    Read-only rendered fields driven by a Jinja2 template that are applied to objects within a ContentType.",
            "    \"\"\"",
            "",
            "    content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"custom_fields\"),",
            "    )",
            "    slug = AutoSlugField(",
            "        populate_from=\"label\",",
            "        help_text=\"Internal field name. Please use underscores rather than dashes in this slug.\",",
            "        slugify_function=slugify_dashes_to_underscores,",
            "    )",
            "    label = models.CharField(max_length=100, help_text=\"Name of the field as displayed to users\")",
            "    description = models.CharField(max_length=200, blank=True)",
            "    template = models.TextField(max_length=500, help_text=\"Jinja2 template code for field value\")",
            "    fallback_value = models.CharField(",
            "        max_length=500,",
            "        blank=True,",
            "        help_text=\"Fallback value (if any) to be output for the field in the case of a template rendering error.\",",
            "    )",
            "    weight = models.PositiveSmallIntegerField(default=100)",
            "    advanced_ui = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Move to Advanced tab\",",
            "        help_text=\"Hide this field from the object's primary information tab. \"",
            "        'It will appear in the \"Advanced\" tab instead.',",
            "    )",
            "",
            "    objects = ComputedFieldManager()",
            "",
            "    clone_fields = [\"content_type\", \"description\", \"template\", \"fallback_value\", \"weight\"]",
            "",
            "    class Meta:",
            "        ordering = [\"weight\", \"slug\"]",
            "        unique_together = (\"content_type\", \"label\")",
            "",
            "    def __str__(self):",
            "        return self.label",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:computedfield\", args=[self.slug])",
            "",
            "    def render(self, context):",
            "        try:",
            "            rendered = render_jinja2(self.template, context)",
            "            # If there is an undefined variable within a template, it returns nothing",
            "            # Doesn't raise an exception either most likely due to using Undefined rather",
            "            # than StrictUndefined, but return fallback_value if None is returned",
            "            if rendered is None:",
            "                logger.warning(\"Failed to render computed field %s\", self.slug)",
            "                return self.fallback_value",
            "            return rendered",
            "        except Exception as exc:",
            "            logger.warning(\"Failed to render computed field %s: %s\", self.slug, exc)",
            "            return self.fallback_value",
            "",
            "",
            "class CustomFieldModel(models.Model):",
            "    \"\"\"",
            "    Abstract class for any model which may have custom fields associated with it.",
            "    \"\"\"",
            "",
            "    _custom_field_data = models.JSONField(encoder=DjangoJSONEncoder, blank=True, default=dict)",
            "",
            "    class Meta:",
            "        abstract = True",
            "",
            "    @property",
            "    def custom_field_data(self):",
            "        \"\"\"",
            "        Legacy interface to raw custom field data",
            "",
            "        TODO(John): remove this entirely when the cf property is enhanced",
            "        \"\"\"",
            "        return self._custom_field_data",
            "",
            "    @property",
            "    def cf(self):",
            "        \"\"\"",
            "        Convenience wrapper for custom field data.",
            "        \"\"\"",
            "        return self._custom_field_data",
            "",
            "    def get_custom_fields_basic(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_fields() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictionary of custom fields for a single object in the form {<field>: value}",
            "        which have advanced_ui set to False",
            "        \"\"\"",
            "        return self.get_custom_fields(advanced_ui=False)",
            "",
            "    def get_custom_fields_advanced(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_fields() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictionary of custom fields for a single object in the form {<field>: value}",
            "        which have advanced_ui set to True",
            "        \"\"\"",
            "        return self.get_custom_fields(advanced_ui=True)",
            "",
            "    def get_custom_fields(self, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictionary of custom fields for a single object in the form {<field>: value}.",
            "        \"\"\"",
            "        fields = CustomField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            fields = fields.filter(advanced_ui=advanced_ui)",
            "        # 2.0 TODO: #824 field.slug rather than field.name",
            "        return OrderedDict([(field, self.cf.get(field.name)) for field in fields])",
            "",
            "    def get_custom_field_groupings_basic(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_field_groupings() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictonary of custom fields grouped by the same grouping in the form",
            "        {",
            "            <grouping_1>: [(cf1, <value for cf1>), (cf2, <value for cf2>), ...],",
            "            ...",
            "            <grouping_5>: [(cf8, <value for cf8>), (cf9, <value for cf9>), ...],",
            "            ...",
            "        }",
            "        which have advanced_ui set to False",
            "        \"\"\"",
            "        return self.get_custom_field_groupings(advanced_ui=False)",
            "",
            "    def get_custom_field_groupings_advanced(self):",
            "        \"\"\"",
            "        This method exists to help call get_custom_field_groupings() in templates where a function argument (advanced_ui) cannot be specified.",
            "        Return a dictonary of custom fields grouped by the same grouping in the form",
            "        {",
            "            <grouping_1>: [(cf1, <value for cf1>), (cf2, <value for cf2>), ...],",
            "            ...",
            "            <grouping_5>: [(cf8, <value for cf8>), (cf9, <value for cf9>), ...],",
            "            ...",
            "        }",
            "        which have advanced_ui set to True",
            "        \"\"\"",
            "        return self.get_custom_field_groupings(advanced_ui=True)",
            "",
            "    def get_custom_field_groupings(self, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictonary of custom fields grouped by the same grouping in the form",
            "        {",
            "            <grouping_1>: [(cf1, <value for cf1>), (cf2, <value for cf2>), ...],",
            "            ...",
            "            <grouping_5>: [(cf8, <value for cf8>), (cf9, <value for cf9>), ...],",
            "            ...",
            "        }",
            "        \"\"\"",
            "        record = {}",
            "        fields = CustomField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            fields = fields.filter(advanced_ui=advanced_ui)",
            "",
            "        for field in fields:",
            "            data = (field, self.cf.get(field.name))",
            "            record.setdefault(field.grouping, []).append(data)",
            "        record = dict(sorted(record.items()))",
            "        return record",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # 2.0 TODO: #824 replace cf.name with cf.slug",
            "        custom_fields = {cf.name: cf for cf in CustomField.objects.get_for_model(self)}",
            "",
            "        # Validate all field values",
            "        for field_name, value in self._custom_field_data.items():",
            "            if field_name not in custom_fields:",
            "                # log a warning instead of raising a ValidationError so as not to break the UI",
            "                logger.warning(f\"Unknown field name '{field_name}' in custom field data for {self} ({self.pk}).\")",
            "                continue",
            "            try:",
            "                custom_fields[field_name].validate(value)",
            "            except ValidationError as e:",
            "                raise ValidationError(f\"Invalid value for custom field '{field_name}': {e.message}\")",
            "",
            "        # Check for missing values, erroring on required ones and populating non-required ones automatically",
            "        for cf in custom_fields.values():",
            "            # 2.0 TODO: #824 replace cf.name with cf.slug",
            "            if cf.name not in self._custom_field_data:",
            "                if cf.default is not None:",
            "                    self._custom_field_data[cf.name] = cf.default",
            "                elif cf.required:",
            "                    raise ValidationError(f\"Missing required custom field '{cf.name}'.\")",
            "",
            "    # Computed Field Methods",
            "    def has_computed_fields(self, advanced_ui=None):",
            "        \"\"\"",
            "        Return a boolean indicating whether or not this content type has computed fields associated with it.",
            "        This can also check whether the advanced_ui attribute is True or False for UI display purposes.",
            "        \"\"\"",
            "        computed_fields = ComputedField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            computed_fields = computed_fields.filter(advanced_ui=advanced_ui)",
            "        return computed_fields.exists()",
            "",
            "    def has_computed_fields_basic(self):",
            "        return self.has_computed_fields(advanced_ui=False)",
            "",
            "    def has_computed_fields_advanced(self):",
            "        return self.has_computed_fields(advanced_ui=True)",
            "",
            "    def get_computed_field(self, slug, render=True):",
            "        \"\"\"",
            "        Get a computed field for this model, lookup via slug.",
            "        Returns the template of this field if render is False, otherwise returns the rendered value.",
            "        \"\"\"",
            "        try:",
            "            computed_field = ComputedField.objects.get_for_model(self).get(slug=slug)",
            "        except ComputedField.DoesNotExist:",
            "            logger.warning(\"Computed Field with slug %s does not exist for model %s\", slug, self._meta.verbose_name)",
            "            return None",
            "        if render:",
            "            return computed_field.render(context={\"obj\": self})",
            "        return computed_field.template",
            "",
            "    def get_computed_fields(self, label_as_key=False, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictionary of all computed fields and their rendered values for this model.",
            "        Keys are the `slug` value of each field. If label_as_key is True, `label` values of each field are used as keys.",
            "        \"\"\"",
            "        computed_fields_dict = {}",
            "        computed_fields = ComputedField.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            computed_fields = computed_fields.filter(advanced_ui=advanced_ui)",
            "        if not computed_fields:",
            "            return {}",
            "        for cf in computed_fields:",
            "            computed_fields_dict[cf.label if label_as_key else cf.slug] = cf.render(context={\"obj\": self})",
            "        return computed_fields_dict",
            "",
            "",
            "class CustomFieldManager(models.Manager.from_queryset(RestrictedQuerySet)):",
            "    use_in_migrations = True",
            "",
            "    def get_for_model(self, model):",
            "        \"\"\"",
            "        Return all CustomFields assigned to the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return self.get_queryset().filter(content_types=content_type)",
            "",
            "",
            "@extras_features(\"webhooks\")",
            "class CustomField(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"custom_fields\",",
            "        verbose_name=\"Object(s)\",",
            "        limit_choices_to=FeatureQuery(\"custom_fields\"),",
            "        help_text=\"The object(s) to which this field applies.\",",
            "    )",
            "    grouping = models.CharField(",
            "        max_length=255,",
            "        blank=True,",
            "        help_text=\"Human-readable grouping that this custom field belongs to.\",",
            "    )",
            "    type = models.CharField(",
            "        max_length=50,",
            "        choices=CustomFieldTypeChoices,",
            "        default=CustomFieldTypeChoices.TYPE_TEXT,",
            "        help_text=\"The type of value(s) allowed for this field.\",",
            "    )",
            "    # 2.0 TODO: #824 remove `name` field as redundant, make `label` mandatory, populate `slug` from `label` field.",
            "    name = models.CharField(max_length=50, unique=True, help_text=\"Human-readable unique name of this field.\")",
            "    label = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        help_text=\"Name of the field as displayed to users (if not provided, the field's name will be used.)\",",
            "    )",
            "    slug = AutoSlugField(",
            "        blank=False,",
            "        max_length=50,",
            "        populate_from=\"label\",",
            "        help_text=\"Internal field name. Please use underscores rather than dashes in this slug.\",",
            "        slugify_function=slugify_dashes_to_underscores,",
            "    )",
            "    description = models.CharField(max_length=200, blank=True, help_text=\"A helpful description for this field.\")",
            "    required = models.BooleanField(",
            "        default=False,",
            "        help_text=\"If true, this field is required when creating new objects or editing an existing object.\",",
            "    )",
            "    # todoindex:",
            "    filter_logic = models.CharField(",
            "        max_length=50,",
            "        choices=CustomFieldFilterLogicChoices,",
            "        default=CustomFieldFilterLogicChoices.FILTER_LOOSE,",
            "        help_text=\"Loose matches any instance of a given string; Exact matches the entire field.\",",
            "    )",
            "    default = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        help_text=(",
            "            \"Default value for the field (must be a JSON value). Encapsulate strings with double quotes (e.g. \"",
            "            '\"Foo\").'",
            "        ),",
            "    )",
            "    weight = models.PositiveSmallIntegerField(",
            "        default=100, help_text=\"Fields with higher weights appear lower in a form.\"",
            "    )",
            "    validation_minimum = models.BigIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Minimum value\",",
            "        help_text=\"Minimum allowed value (for numeric fields).\",",
            "    )",
            "    validation_maximum = models.BigIntegerField(",
            "        blank=True,",
            "        null=True,",
            "        verbose_name=\"Maximum value\",",
            "        help_text=\"Maximum allowed value (for numeric fields).\",",
            "    )",
            "    validation_regex = models.CharField(",
            "        blank=True,",
            "        validators=[validate_regex],",
            "        max_length=500,",
            "        verbose_name=\"Validation regex\",",
            "        help_text=\"Regular expression to enforce on text field values. Use ^ and $ to force matching of entire string. \"",
            "        \"For example, <code>^[A-Z]{3}$</code> will limit values to exactly three uppercase letters. Regular \"",
            "        \"expression on select and multi-select will be applied at <code>Custom Field Choices</code> definition.\",",
            "    )",
            "    advanced_ui = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Move to Advanced tab\",",
            "        help_text=\"Hide this field from the object's primary information tab. \"",
            "        'It will appear in the \"Advanced\" tab instead.',",
            "    )",
            "",
            "    objects = CustomFieldManager()",
            "",
            "    clone_fields = [",
            "        \"content_types\",",
            "        \"grouping\",",
            "        \"type\",",
            "        \"description\",",
            "        \"required\",",
            "        \"filter_logic\",",
            "        \"default\",",
            "        \"weight\",",
            "        \"validation_minimum\",",
            "        \"validation_maximum\",",
            "        \"validation_regex\",",
            "    ]",
            "",
            "    class Meta:",
            "        ordering = [\"weight\", \"name\"]",
            "",
            "    def __str__(self):",
            "        return self.label or self.name.replace(\"_\", \" \").capitalize()",
            "",
            "    def _fixup_empty_fields(self):",
            "        \"\"\"Handle the case when a new instance is created and some fields are left blank.\"\"\"",
            "        if self.present_in_database:",
            "            return",
            "",
            "        # 2.0 TODO: this is to handle the UI case where `name` is no longer a directly configured form.",
            "        # Once `name` is no longer a model field, we can remove this.",
            "        if self.slug and not self.name:",
            "            self.name = self.slug",
            "",
            "        # 2.0 TODO: this is to fixup existing ORM usage when caller specifies a name but not a label;",
            "        # in 2.0 we should make `label` a mandatory field when getting rid of `name`.",
            "        if self.name and not self.label:",
            "            self.label = self.name",
            "",
            "        # This is to fix up existing ORM usage when caller doesn't specify a slug since it wasn't a field before.",
            "        if not self.slug:",
            "            self.slug = slugify_dashes_to_underscores(self.label or self.name)",
            "",
            "    def clean_fields(self, exclude=None):",
            "        # Ensure now-mandatory fields are correctly populated, as otherwise cleaning will fail.",
            "        self._fixup_empty_fields()",
            "        super().clean_fields(exclude=exclude)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        if self.present_in_database:",
            "            # Check immutable fields",
            "            database_object = self.__class__.objects.get(pk=self.pk)",
            "",
            "            # 2.0 TODO: #824 once self.name is no longer used as a dict key, can remove this constraint",
            "            if self.name != database_object.name:",
            "                raise ValidationError({\"name\": \"Name cannot be changed once created\"})",
            "",
            "            if self.slug != database_object.slug:",
            "                raise ValidationError({\"slug\": \"Slug cannot be changed once created\"})",
            "",
            "            if self.type != database_object.type:",
            "                raise ValidationError({\"type\": \"Type cannot be changed once created\"})",
            "",
            "        # Validate the field's default value (if any)",
            "        if self.default is not None:",
            "            try:",
            "                self.validate(self.default)",
            "            except ValidationError as err:",
            "                raise ValidationError({\"default\": f'Invalid default value \"{self.default}\": {err.message}'})",
            "",
            "        # Minimum/maximum values can be set only for numeric fields",
            "        if self.validation_minimum is not None and self.type != CustomFieldTypeChoices.TYPE_INTEGER:",
            "            raise ValidationError({\"validation_minimum\": \"A minimum value may be set only for numeric fields\"})",
            "        if self.validation_maximum is not None and self.type != CustomFieldTypeChoices.TYPE_INTEGER:",
            "            raise ValidationError({\"validation_maximum\": \"A maximum value may be set only for numeric fields\"})",
            "",
            "        # Regex validation can be set only for text, url, select and multi-select fields",
            "        if self.validation_regex and self.type not in CustomFieldTypeChoices.REGEX_TYPES:",
            "            raise ValidationError(",
            "                {\"validation_regex\": \"Regular expression validation is supported only for text, URL and select fields\"}",
            "            )",
            "",
            "        # Choices can be set only on selection fields",
            "        if self.choices.exists() and self.type not in (",
            "            CustomFieldTypeChoices.TYPE_SELECT,",
            "            CustomFieldTypeChoices.TYPE_MULTISELECT,",
            "        ):",
            "            raise ValidationError(\"Choices may be set only for custom selection fields.\")",
            "",
            "        # A selection field's default (if any) must be present in its available choices",
            "        if (",
            "            self.type == CustomFieldTypeChoices.TYPE_SELECT",
            "            and self.default",
            "            and self.default not in self.choices.values_list(\"value\", flat=True)",
            "        ):",
            "            raise ValidationError(",
            "                {\"default\": f\"The specified default value ({self.default}) is not listed as an available choice.\"}",
            "            )",
            "",
            "    def save(self, *args, **kwargs):",
            "        # Prior to Nautobot 1.4, `slug` was a non-existent field, but now it's mandatory.",
            "        # Protect against get_or_create() or other ORM usage where callers aren't calling clean() before saving.",
            "        # Normally we'd just say \"Don't do that!\" but we know there are some cases of this in the wild.",
            "        self._fixup_empty_fields()",
            "        super().save(*args, **kwargs)",
            "",
            "    def to_form_field(",
            "        self, set_initial=True, enforce_required=True, for_csv_import=False, simple_json_filter=False, label=None",
            "    ):",
            "        \"\"\"",
            "        Return a form field suitable for setting a CustomField's value for an object.",
            "        set_initial: Set initial date for the field. This should be False when generating a field for bulk editing.",
            "        enforce_required: Honor the value of CustomField.required. Set to False for filtering/bulk editing.",
            "        for_csv_import: Return a form field suitable for bulk import of objects in CSV format.",
            "        simple_json_filter: Return a TextInput widget for JSON filtering instead of the default TextArea widget.",
            "        label: Set the input label manually (if required) otherwise it will default to field's __str__() implementation.",
            "        \"\"\"",
            "        initial = self.default if set_initial else None",
            "        required = self.required if enforce_required else False",
            "",
            "        # Integer",
            "        if self.type == CustomFieldTypeChoices.TYPE_INTEGER:",
            "            field = forms.IntegerField(",
            "                required=required,",
            "                initial=initial,",
            "                min_value=self.validation_minimum,",
            "                max_value=self.validation_maximum,",
            "            )",
            "",
            "        # Boolean",
            "        elif self.type == CustomFieldTypeChoices.TYPE_BOOLEAN:",
            "            choices = (",
            "                (None, \"---------\"),",
            "                (True, \"True\"),",
            "                (False, \"False\"),",
            "            )",
            "            field = forms.NullBooleanField(",
            "                required=required,",
            "                initial=initial,",
            "                widget=StaticSelect2(choices=choices),",
            "            )",
            "",
            "        # Date",
            "        elif self.type == CustomFieldTypeChoices.TYPE_DATE:",
            "            field = NullableDateField(",
            "                required=required,",
            "                initial=initial,",
            "                widget=DatePicker(),",
            "            )",
            "",
            "        # Text and URL",
            "        elif self.type in (CustomFieldTypeChoices.TYPE_URL, CustomFieldTypeChoices.TYPE_TEXT):",
            "            if self.type == CustomFieldTypeChoices.TYPE_URL:",
            "                field = LaxURLField(required=required, initial=initial)",
            "            elif self.type == CustomFieldTypeChoices.TYPE_TEXT:",
            "                field = forms.CharField(max_length=255, required=required, initial=initial)",
            "",
            "            if self.validation_regex:",
            "                field.validators = [",
            "                    RegexValidator(",
            "                        regex=self.validation_regex,",
            "                        message=format_html(\"Values must match this regex: <code>{}</code>\", self.validation_regex),",
            "                    )",
            "                ]",
            "",
            "        # Markdown",
            "        elif self.type == CustomFieldTypeChoices.TYPE_MARKDOWN:",
            "            field = CommentField(widget=SmallTextarea, label=None)",
            "",
            "        # JSON",
            "        elif self.type == CustomFieldTypeChoices.TYPE_JSON:",
            "            if simple_json_filter:",
            "                field = JSONField(encoder=DjangoJSONEncoder, required=required, initial=None, widget=TextInput)",
            "            else:",
            "                field = JSONField(encoder=DjangoJSONEncoder, required=required, initial=initial)",
            "",
            "        # Select or Multi-select",
            "        else:",
            "            choices = [(cfc.value, cfc.value) for cfc in self.choices.all()]",
            "            default_choice = self.choices.filter(value=self.default).first()",
            "",
            "            if not required or default_choice is None:",
            "                choices = add_blank_choice(choices)",
            "",
            "            # Set the initial value to the first available choice (if any)",
            "            if set_initial and default_choice:",
            "                initial = default_choice.value",
            "",
            "            if self.type == CustomFieldTypeChoices.TYPE_SELECT:",
            "                field_class = CSVChoiceField if for_csv_import else forms.ChoiceField",
            "                field = field_class(",
            "                    choices=choices,",
            "                    required=required,",
            "                    initial=initial,",
            "                    widget=StaticSelect2(),",
            "                )",
            "            else:",
            "                field_class = CSVMultipleChoiceField if for_csv_import else forms.MultipleChoiceField",
            "                field = field_class(choices=choices, required=required, initial=initial, widget=StaticSelect2Multiple())",
            "",
            "        field.model = self",
            "        if label is not None:",
            "            field.label = label",
            "        else:",
            "            field.label = str(self)",
            "",
            "        if self.description:",
            "            # Avoid script injection and similar attacks! Output HTML but only accept Markdown as input",
            "            field.help_text = render_markdown(self.description)",
            "",
            "        return field",
            "",
            "    def validate(self, value):",
            "        \"\"\"",
            "        Validate a value according to the field's type validation rules.",
            "        \"\"\"",
            "        if value not in [None, \"\", []]:",
            "            # Validate text field",
            "            if self.type in (CustomFieldTypeChoices.TYPE_TEXT, CustomFieldTypeChoices.TYPE_URL):",
            "                if not isinstance(value, str):",
            "                    raise ValidationError(\"Value must be a string\")",
            "",
            "                if self.validation_regex and not re.search(self.validation_regex, value):",
            "                    raise ValidationError(f\"Value must match regex '{self.validation_regex}'\")",
            "",
            "            # Validate integer",
            "            if self.type == CustomFieldTypeChoices.TYPE_INTEGER:",
            "                try:",
            "                    int(value)",
            "                except ValueError:",
            "                    raise ValidationError(\"Value must be an integer.\")",
            "                if self.validation_minimum is not None and value < self.validation_minimum:",
            "                    raise ValidationError(f\"Value must be at least {self.validation_minimum}\")",
            "                if self.validation_maximum is not None and value > self.validation_maximum:",
            "                    raise ValidationError(f\"Value must not exceed {self.validation_maximum}\")",
            "",
            "            # Validate boolean",
            "            if self.type == CustomFieldTypeChoices.TYPE_BOOLEAN and value not in [",
            "                True,",
            "                False,",
            "                1,",
            "                0,",
            "            ]:",
            "                raise ValidationError(\"Value must be true or false.\")",
            "",
            "            # Validate date",
            "            if self.type == CustomFieldTypeChoices.TYPE_DATE:",
            "                if not isinstance(value, date):",
            "                    try:",
            "                        datetime.strptime(value, \"%Y-%m-%d\")",
            "                    except ValueError:",
            "                        raise ValidationError(\"Date values must be in the format YYYY-MM-DD.\")",
            "",
            "            # Validate selected choice",
            "            if self.type == CustomFieldTypeChoices.TYPE_SELECT:",
            "                if value not in self.choices.values_list(\"value\", flat=True):",
            "                    raise ValidationError(",
            "                        f\"Invalid choice ({value}). Available choices are: {', '.join(self.choices.values_list('value', flat=True))}\"",
            "                    )",
            "",
            "            if self.type == CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "                if not set(value).issubset(self.choices.values_list(\"value\", flat=True)):",
            "                    raise ValidationError(",
            "                        f\"Invalid choice(s) ({value}). Available choices are: {', '.join(self.choices.values_list('value', flat=True))}\"",
            "                    )",
            "",
            "        elif self.required:",
            "            raise ValidationError(\"Required field cannot be empty.\")",
            "",
            "    def delete(self, *args, **kwargs):",
            "        \"\"\"",
            "        Handle the cleanup of old custom field data when a CustomField is deleted.",
            "        \"\"\"",
            "        content_types = set(self.content_types.values_list(\"pk\", flat=True))",
            "",
            "        super().delete(*args, **kwargs)",
            "",
            "        # 2.0 TODO: #824 use self.slug as key instead of self.name",
            "        delete_custom_field_data.delay(self.name, content_types)",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:customfield\", args=[self.slug])",
            "",
            "",
            "@extras_features(",
            "    \"graphql\",",
            "    \"webhooks\",",
            ")",
            "class CustomFieldChoice(BaseModel, ChangeLoggedModel):",
            "    \"\"\"",
            "    The custom field choice is used to store the possible set of values for a selection type custom field",
            "    \"\"\"",
            "",
            "    field = models.ForeignKey(",
            "        to=\"extras.CustomField\",",
            "        on_delete=models.CASCADE,",
            "        related_name=\"choices\",",
            "        limit_choices_to=models.Q(",
            "            type__in=[CustomFieldTypeChoices.TYPE_SELECT, CustomFieldTypeChoices.TYPE_MULTISELECT]",
            "        ),",
            "    )",
            "    value = models.CharField(max_length=100)",
            "    weight = models.PositiveSmallIntegerField(default=100, help_text=\"Higher weights appear later in the list\")",
            "",
            "    class Meta:",
            "        ordering = [\"field\", \"weight\", \"value\"]",
            "        unique_together = [\"field\", \"value\"]",
            "",
            "    def __str__(self):",
            "        return self.value",
            "",
            "    def get_absolute_url(self):",
            "        # 2.0 TODO: replace slug with pk",
            "        return reverse(\"extras:customfield\", args=[self.field.slug])",
            "",
            "    def clean(self):",
            "        if self.field.type not in (CustomFieldTypeChoices.TYPE_SELECT, CustomFieldTypeChoices.TYPE_MULTISELECT):",
            "            raise ValidationError(\"Custom field choices can only be assigned to selection fields.\")",
            "",
            "        if not re.search(self.field.validation_regex, self.value):",
            "            raise ValidationError(f\"Value must match regex {self.field.validation_regex} got {self.value}.\")",
            "",
            "    def save(self, *args, **kwargs):",
            "        \"\"\"",
            "        When a custom field choice is saved, perform logic that will update data across all custom field data.",
            "        \"\"\"",
            "        if self.present_in_database:",
            "            database_object = self.__class__.objects.get(pk=self.pk)",
            "        else:",
            "            database_object = self",
            "",
            "        super().save(*args, **kwargs)",
            "",
            "        if self.value != database_object.value:",
            "            transaction.on_commit(",
            "                lambda: update_custom_field_choice_data.delay(self.field.pk, database_object.value, self.value)",
            "            )",
            "",
            "    def delete(self, *args, **kwargs):",
            "        \"\"\"",
            "        When a custom field choice is deleted, remove references to in custom field data",
            "        \"\"\"",
            "        if self.field.default:",
            "            # Cannot delete the choice if it is the default value.",
            "            if self.field.type == CustomFieldTypeChoices.TYPE_SELECT and self.field.default == self.value:",
            "                raise models.ProtectedError(",
            "                    msg=\"Cannot delete this choice because it is the default value for the field.\",",
            "                    protected_objects=[self],  # TODO: should this be self.field instead?",
            "                )",
            "            elif self.value in self.field.default:",
            "                raise models.ProtectedError(",
            "                    msg=\"Cannot delete this choice because it is one of the default values for the field.\",",
            "                    protected_objects=[self],  # TODO: should this be self.field instead?",
            "                )",
            "",
            "        if self.field.type == CustomFieldTypeChoices.TYPE_SELECT:",
            "            # Check if this value is in active use in a select field",
            "            for ct in self.field.content_types.all():",
            "                model = ct.model_class()",
            "                # 2.0 TODO: #824 self.field.slug instead of self.field.name",
            "                if model.objects.filter(**{f\"_custom_field_data__{self.field.name}\": self.value}).exists():",
            "                    raise models.ProtectedError(",
            "                        msg=\"Cannot delete this choice because it is in active use.\",",
            "                        protected_objects=[self],  # TODO should this be model.objects.filter(...) instead?",
            "                    )",
            "",
            "        else:",
            "            # Check if this value is in active use in a multi-select field",
            "            for ct in self.field.content_types.all():",
            "                model = ct.model_class()",
            "                # 2.0 TODO: #824 self.field.slug instead of self.field.name",
            "                if model.objects.filter(**{f\"_custom_field_data__{self.field.name}__contains\": self.value}).exists():",
            "                    raise models.ProtectedError(",
            "                        msg=\"Cannot delete this choice because it is in active use.\",",
            "                        protected_objects=[self],  # TODO should this be model.objects.filter(...) instead?",
            "                    )",
            "",
            "        super().delete(*args, **kwargs)",
            "",
            "    def to_objectchange(self, action, related_object=None, **kwargs):",
            "        # Annotate the parent field",
            "        try:",
            "            field = self.field",
            "        except ObjectDoesNotExist:",
            "            # The parent field has already been deleted",
            "            field = None",
            "",
            "        return super().to_objectchange(action, related_object=field, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "549": [
                "CustomField",
                "to_form_field"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/models/models.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "     name = models.CharField(max_length=100, unique=True)"
            },
            "1": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "     text = models.CharField("
            },
            "2": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "         max_length=500,"
            },
            "3": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=\"Jinja2 template code for link text. Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>. Links which render as empty text will not be displayed.\","
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+        help_text=\"Jinja2 template code for link text. \""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+        \"Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>. \""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        \"Links which render as empty text will not be displayed.\","
            },
            "7": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "     )"
            },
            "8": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "     target_url = models.CharField("
            },
            "9": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         max_length=500,"
            },
            "10": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         verbose_name=\"URL\","
            },
            "11": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=\"Jinja2 template code for link URL. Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>.\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+        help_text=\"Jinja2 template code for link URL. \""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+        \"Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>.\","
            },
            "14": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "     )"
            },
            "15": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     weight = models.PositiveSmallIntegerField(default=100)"
            },
            "16": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     group_name = models.CharField("
            }
        },
        "frontPatchFile": [
            "from datetime import datetime",
            "import json",
            "from collections import OrderedDict",
            "",
            "from db_file_storage.model_utils import delete_file, delete_file_if_needed",
            "from db_file_storage.storage import DatabaseFileStorage",
            "from django.conf import settings",
            "from django.contrib.contenttypes.fields import GenericForeignKey",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.exceptions import ValidationError",
            "from django.db import models",
            "from django.http import HttpResponse",
            "from django.utils.text import slugify",
            "from django.urls import reverse",
            "from graphene_django.settings import graphene_settings",
            "from graphql import get_default_backend",
            "from graphql.error import GraphQLSyntaxError",
            "from graphql.language.ast import OperationDefinition",
            "from jsonschema.exceptions import SchemaError, ValidationError as JSONSchemaValidationError",
            "from jsonschema.validators import Draft7Validator",
            "from rest_framework.utils.encoders import JSONEncoder",
            "",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models import BaseModel",
            "from nautobot.core.models.generics import OrganizationalModel",
            "from nautobot.extras.choices import (",
            "    ButtonClassChoices,",
            "    WebhookHttpMethodChoices,",
            ")",
            "from nautobot.extras.constants import HTTP_CONTENT_TYPE_JSON",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.extras.models.relationships import RelationshipModel",
            "from nautobot.extras.querysets import ConfigContextQuerySet, NotesQuerySet",
            "from nautobot.extras.utils import extras_features, FeatureQuery, image_upload",
            "from nautobot.utilities.utils import deepmerge, render_jinja2",
            "",
            "# Avoid breaking backward compatibility on anything that might expect these to still be defined here:",
            "from .jobs import JOB_LOGS, Job, JobLogEntry, JobResult, ScheduledJob, ScheduledJobs  # noqa: F401",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextSchemaValidationMixin:",
            "    \"\"\"",
            "    Mixin that provides validation of config context data against a json schema.",
            "    \"\"\"",
            "",
            "    def _validate_with_schema(self, data_field, schema_field):",
            "        schema = getattr(self, schema_field)",
            "        data = getattr(self, data_field)",
            "",
            "        # If schema is None, then no schema has been specified on the instance and thus no validation should occur.",
            "        if schema:",
            "            try:",
            "                Draft7Validator(schema.data_schema, format_checker=Draft7Validator.FORMAT_CHECKER).validate(data)",
            "            except JSONSchemaValidationError as e:",
            "                raise ValidationError({data_field: [f\"Validation using the JSON Schema {schema} failed.\", e.message]})",
            "",
            "",
            "def limit_dynamic_group_choices():",
            "    return models.Q(content_type__app_label=\"virtualization\", content_type__model=\"virtualmachine\") | models.Q(",
            "        content_type__app_label=\"dcim\", content_type__model=\"device\"",
            "    )",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class ConfigContext(BaseModel, ChangeLoggedModel, ConfigContextSchemaValidationMixin, NotesMixin):",
            "    \"\"\"",
            "    A ConfigContext represents a set of arbitrary data available to any Device or VirtualMachine matching its assigned",
            "    qualifiers (region, site, etc.). For example, the data stored in a ConfigContext assigned to site A and tenant B",
            "    will be available to a Device in site A assigned to tenant B. Data is stored in JSON format.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, db_index=True)",
            "",
            "    # A ConfigContext *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"config_context_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    owner = GenericForeignKey(",
            "        ct_field=\"owner_content_type\",",
            "        fk_field=\"owner_object_id\",",
            "    )",
            "",
            "    weight = models.PositiveSmallIntegerField(default=1000)",
            "    description = models.CharField(max_length=200, blank=True)",
            "    is_active = models.BooleanField(",
            "        default=True,",
            "    )",
            "    schema = models.ForeignKey(",
            "        to=\"extras.ConfigContextSchema\",",
            "        on_delete=models.SET_NULL,",
            "        null=True,",
            "        blank=True,",
            "        help_text=\"Optional schema to validate the structure of the data\",",
            "    )",
            "    regions = models.ManyToManyField(to=\"dcim.Region\", related_name=\"+\", blank=True)",
            "    sites = models.ManyToManyField(to=\"dcim.Site\", related_name=\"+\", blank=True)",
            "    locations = models.ManyToManyField(to=\"dcim.Location\", related_name=\"+\", blank=True)",
            "    roles = models.ManyToManyField(to=\"dcim.DeviceRole\", related_name=\"+\", blank=True)",
            "    device_types = models.ManyToManyField(to=\"dcim.DeviceType\", related_name=\"+\", blank=True)",
            "    device_redundancy_groups = models.ManyToManyField(to=\"dcim.DeviceRedundancyGroup\", related_name=\"+\", blank=True)",
            "    platforms = models.ManyToManyField(to=\"dcim.Platform\", related_name=\"+\", blank=True)",
            "    cluster_groups = models.ManyToManyField(to=\"virtualization.ClusterGroup\", related_name=\"+\", blank=True)",
            "    clusters = models.ManyToManyField(to=\"virtualization.Cluster\", related_name=\"+\", blank=True)",
            "    tenant_groups = models.ManyToManyField(to=\"tenancy.TenantGroup\", related_name=\"+\", blank=True)",
            "    tenants = models.ManyToManyField(to=\"tenancy.Tenant\", related_name=\"+\", blank=True)",
            "    tags = models.ManyToManyField(to=\"extras.Tag\", related_name=\"+\", blank=True)",
            "",
            "    # Due to feature flag CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED this field will remain empty unless set to True.",
            "    dynamic_groups = models.ManyToManyField(",
            "        to=\"extras.DynamicGroup\", related_name=\"+\", blank=True, limit_choices_to=limit_dynamic_group_choices",
            "    )",
            "    data = models.JSONField(encoder=DjangoJSONEncoder)",
            "",
            "    objects = ConfigContextQuerySet.as_manager()",
            "",
            "    class Meta:",
            "        ordering = [\"weight\", \"name\"]",
            "        unique_together = [[\"name\", \"owner_content_type\", \"owner_object_id\"]]",
            "",
            "    def __str__(self):",
            "        if self.owner:",
            "            return f\"[{self.owner}] {self.name}\"",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:configcontext\", kwargs={\"pk\": self.pk})",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Verify that JSON data is provided as an object",
            "        if not isinstance(self.data, dict):",
            "            raise ValidationError({\"data\": 'JSON data must be in object form. Example: {\"foo\": 123}'})",
            "",
            "        # Validate data against schema",
            "        self._validate_with_schema(\"data\", \"schema\")",
            "",
            "        # Check for a duplicated `name`. This is necessary because Django does not consider two NULL fields to be equal,",
            "        # and thus if the `owner` is NULL, a duplicate `name` will not otherwise automatically raise an exception.",
            "        if (",
            "            ConfigContext.objects.exclude(pk=self.pk)",
            "            .filter(name=self.name, owner_content_type=self.owner_content_type, owner_object_id=self.owner_object_id)",
            "            .exists()",
            "        ):",
            "            raise ValidationError({\"name\": \"A ConfigContext with this name already exists.\"})",
            "",
            "",
            "class ConfigContextModel(models.Model, ConfigContextSchemaValidationMixin):",
            "    \"\"\"",
            "    A model which includes local configuration context data. This local data will override any inherited data from",
            "    ConfigContexts.",
            "    \"\"\"",
            "",
            "    local_context_data = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    local_context_schema = models.ForeignKey(",
            "        to=\"extras.ConfigContextSchema\",",
            "        on_delete=models.SET_NULL,",
            "        null=True,",
            "        blank=True,",
            "        help_text=\"Optional schema to validate the structure of the data\",",
            "    )",
            "    # The local context data *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    local_context_data_owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"config_context_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    local_context_data_owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    local_context_data_owner = GenericForeignKey(",
            "        ct_field=\"local_context_data_owner_content_type\",",
            "        fk_field=\"local_context_data_owner_object_id\",",
            "    )",
            "",
            "    class Meta:",
            "        abstract = True",
            "        indexes = [",
            "            models.Index(fields=(\"local_context_data_owner_content_type\", \"local_context_data_owner_object_id\")),",
            "        ]",
            "",
            "    def get_config_context(self):",
            "        \"\"\"",
            "        Return the rendered configuration context for a device or VM.",
            "        \"\"\"",
            "",
            "        if not hasattr(self, \"config_context_data\"):",
            "            # Annotation not available, so fall back to manually querying for the config context",
            "            config_context_data = ConfigContext.objects.get_for_object(self).values_list(\"data\", flat=True)",
            "        else:",
            "            config_context_data = self.config_context_data or []",
            "            # Annotation has keys \"weight\" and \"name\" (used for ordering) and \"data\" (the actual config context data)",
            "            config_context_data = [",
            "                c[\"data\"] for c in sorted(config_context_data, key=lambda k: (k[\"weight\"], k[\"name\"]))",
            "            ]",
            "",
            "        # Compile all config data, overwriting lower-weight values with higher-weight values where a collision occurs",
            "        data = OrderedDict()",
            "        for context in config_context_data:",
            "            data = deepmerge(data, context)",
            "",
            "        # If the object has local config context data defined, merge it last",
            "        if self.local_context_data:",
            "            data = deepmerge(data, self.local_context_data)",
            "",
            "        return data",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Verify that JSON data is provided as an object",
            "        if self.local_context_data and not isinstance(self.local_context_data, dict):",
            "            raise ValidationError({\"local_context_data\": 'JSON data must be in object form. Example: {\"foo\": 123}'})",
            "",
            "        if self.local_context_schema and not self.local_context_data:",
            "            raise ValidationError({\"local_context_schema\": \"Local context data must exist for a schema to be applied.\"})",
            "",
            "        # Validate data against schema",
            "        self._validate_with_schema(\"local_context_data\", \"local_context_schema\")",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_validators\",",
            "    \"graphql\",",
            "    \"relationships\",",
            ")",
            "class ConfigContextSchema(OrganizationalModel):",
            "    \"\"\"",
            "    This model stores jsonschema documents where are used to optionally validate config context data payloads.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=200)",
            "    description = models.CharField(max_length=200, blank=True)",
            "    slug = AutoSlugField(populate_from=\"name\", max_length=200, unique=None, db_index=True)",
            "    data_schema = models.JSONField(",
            "        help_text=\"A JSON Schema document which is used to validate a config context object.\"",
            "    )",
            "    # A ConfigContextSchema *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"config_context_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    owner = GenericForeignKey(",
            "        ct_field=\"owner_content_type\",",
            "        fk_field=\"owner_object_id\",",
            "    )",
            "",
            "    class Meta:",
            "        constraints = [",
            "            models.UniqueConstraint(fields=[\"name\", \"owner_content_type\", \"owner_object_id\"], name=\"unique_name_owner\"),",
            "        ]",
            "",
            "    def __str__(self):",
            "        if self.owner:",
            "            return f\"[{self.owner}] {self.name}\"",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:configcontextschema\", args=[self.slug])",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Validate the schema",
            "        \"\"\"",
            "        super().clean()",
            "",
            "        try:",
            "            Draft7Validator.check_schema(self.data_schema)",
            "        except SchemaError as e:",
            "            raise ValidationError({\"data_schema\": e.message})",
            "",
            "        if (",
            "            not isinstance(self.data_schema, dict)",
            "            or \"properties\" not in self.data_schema",
            "            or self.data_schema.get(\"type\") != \"object\"",
            "        ):",
            "            raise ValidationError(",
            "                {",
            "                    \"data_schema\": \"Nautobot only supports context data in the form of an object and thus the \"",
            "                    \"JSON schema must be of type object and specify a set of properties.\"",
            "                }",
            "            )",
            "",
            "",
            "#",
            "# Custom links",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class CustomLink(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    A custom link to an external representation of a Nautobot object. The link text and URL fields accept Jinja2 template",
            "    code to be rendered with an object as context.",
            "    \"\"\"",
            "",
            "    content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"custom_links\"),",
            "    )",
            "    name = models.CharField(max_length=100, unique=True)",
            "    text = models.CharField(",
            "        max_length=500,",
            "        help_text=\"Jinja2 template code for link text. Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>. Links which render as empty text will not be displayed.\",",
            "    )",
            "    target_url = models.CharField(",
            "        max_length=500,",
            "        verbose_name=\"URL\",",
            "        help_text=\"Jinja2 template code for link URL. Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>.\",",
            "    )",
            "    weight = models.PositiveSmallIntegerField(default=100)",
            "    group_name = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        help_text=\"Links with the same group will appear as a dropdown menu\",",
            "    )",
            "    button_class = models.CharField(",
            "        max_length=30,",
            "        choices=ButtonClassChoices,",
            "        default=ButtonClassChoices.CLASS_DEFAULT,",
            "        help_text=\"The class of the first link in a group will be used for the dropdown button\",",
            "    )",
            "    new_window = models.BooleanField(help_text=\"Force link to open in a new window\")",
            "",
            "    class Meta:",
            "        ordering = [\"group_name\", \"weight\", \"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:customlink\", kwargs={\"pk\": self.pk})",
            "",
            "",
            "#",
            "# Export templates",
            "#",
            "",
            "",
            "@extras_features(",
            "    \"graphql\",",
            "    \"relationships\",",
            ")",
            "class ExportTemplate(BaseModel, ChangeLoggedModel, RelationshipModel, NotesMixin):",
            "    # An ExportTemplate *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        related_name=\"export_template_owners\",",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"export_template_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    owner = GenericForeignKey(",
            "        ct_field=\"owner_content_type\",",
            "        fk_field=\"owner_object_id\",",
            "    )",
            "    content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"export_templates\"),",
            "    )",
            "    name = models.CharField(max_length=100)",
            "    description = models.CharField(max_length=200, blank=True)",
            "    template_code = models.TextField(",
            "        help_text=\"The list of objects being exported is passed as a context variable named <code>queryset</code>.\"",
            "    )",
            "    mime_type = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"MIME type\",",
            "        help_text=\"Defaults to <code>text/plain</code>\",",
            "    )",
            "    file_extension = models.CharField(",
            "        max_length=15,",
            "        blank=True,",
            "        help_text=\"Extension to append to the rendered filename\",",
            "    )",
            "",
            "    class Meta:",
            "        ordering = [\"content_type\", \"name\"]",
            "        unique_together = [[\"content_type\", \"name\", \"owner_content_type\", \"owner_object_id\"]]",
            "",
            "    def __str__(self):",
            "        if self.owner:",
            "            return f\"[{self.owner}] {self.content_type}: {self.name}\"",
            "        return f\"{self.content_type}: {self.name}\"",
            "",
            "    def render(self, queryset):",
            "        \"\"\"",
            "        Render the contents of the template.",
            "        \"\"\"",
            "        context = {\"queryset\": queryset}",
            "        output = render_jinja2(self.template_code, context)",
            "",
            "        # Replace CRLF-style line terminators",
            "        output = output.replace(\"\\r\\n\", \"\\n\")",
            "",
            "        return output",
            "",
            "    def render_to_response(self, queryset):",
            "        \"\"\"",
            "        Render the template to an HTTP response, delivered as a named file attachment",
            "        \"\"\"",
            "        output = self.render(queryset)",
            "        mime_type = \"text/plain\" if not self.mime_type else self.mime_type",
            "",
            "        # Build the response",
            "        response = HttpResponse(output, content_type=mime_type)",
            "        extension = f\".{self.file_extension}\" if self.file_extension else \"\"",
            "        filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{queryset.model._meta.verbose_name_plural}{extension}\"",
            "        response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "",
            "        return response",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:exporttemplate\", kwargs={\"pk\": self.pk})",
            "",
            "    def clean(self):",
            "        super().clean()",
            "        if self.file_extension.startswith(\".\"):",
            "            self.file_extension = self.file_extension[1:]",
            "",
            "        # Don't allow two ExportTemplates with the same name, content_type, and owner.",
            "        # This is necessary because Django doesn't consider NULL=NULL, and so if owner is NULL the unique_together",
            "        # condition will never be matched even if name and content_type are the same.",
            "        if (",
            "            ExportTemplate.objects.exclude(pk=self.pk)",
            "            .filter(",
            "                name=self.name,",
            "                content_type=self.content_type,",
            "                owner_content_type=self.owner_content_type,",
            "                owner_object_id=self.owner_object_id,",
            "            )",
            "            .exists()",
            "        ):",
            "            raise ValidationError({\"name\": \"An ExportTemplate with this name and content type already exists.\"})",
            "",
            "",
            "#",
            "# File attachments",
            "#",
            "",
            "",
            "class FileAttachment(BaseModel):",
            "    \"\"\"An object for storing the contents and metadata of a file in the database.",
            "",
            "    This object is used by `FileProxy` objects to retrieve file contents and is",
            "    not intended to be used standalone.",
            "    \"\"\"",
            "",
            "    bytes = models.BinaryField()",
            "    filename = models.CharField(max_length=255)",
            "    mimetype = models.CharField(max_length=255)",
            "",
            "    def __str__(self):",
            "        return self.filename",
            "",
            "    class Meta:",
            "        ordering = [\"filename\"]",
            "",
            "",
            "def database_storage():",
            "    \"\"\"Returns storage backend used by `FileProxy.file` to store files in the database.\"\"\"",
            "    return DatabaseFileStorage()",
            "",
            "",
            "class FileProxy(BaseModel):",
            "    \"\"\"An object to store a file in the database.",
            "",
            "    The `file` field can be used like a file handle. The file contents are stored and retrieved from",
            "    `FileAttachment` objects.",
            "",
            "    The associated `FileAttachment` is removed when `delete()` is called. For this reason, one",
            "    should never use bulk delete operations on `FileProxy` objects, unless `FileAttachment` objects",
            "    are also bulk-deleted, because a model's `delete()` method is not called during bulk operations.",
            "    In most cases, it is better to iterate over a queryset of `FileProxy` objects and call",
            "    `delete()` on each one individually.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=255)",
            "    file = models.FileField(",
            "        upload_to=\"extras.FileAttachment/bytes/filename/mimetype\",",
            "        storage=database_storage,  # Use only this backend",
            "    )",
            "    uploaded_at = models.DateTimeField(auto_now_add=True)",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    class Meta:",
            "        get_latest_by = \"uploaded_at\"",
            "        ordering = [\"name\"]",
            "        verbose_name_plural = \"file proxies\"",
            "",
            "    def save(self, *args, **kwargs):",
            "        delete_file_if_needed(self, \"file\")",
            "        super().save(*args, **kwargs)",
            "",
            "    def delete(self, *args, **kwargs):",
            "        super().delete(*args, **kwargs)",
            "        delete_file(self, \"file\")",
            "",
            "",
            "#",
            "# Saved GraphQL queries",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class GraphQLQuery(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    query = models.TextField()",
            "    variables = models.JSONField(encoder=DjangoJSONEncoder, default=dict, blank=True)",
            "",
            "    class Meta:",
            "        ordering = (\"slug\",)",
            "        verbose_name = \"GraphQL query\"",
            "        verbose_name_plural = \"GraphQL queries\"",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:graphqlquery\", kwargs={\"slug\": self.slug})",
            "",
            "    def save(self, *args, **kwargs):",
            "        variables = {}",
            "        schema = graphene_settings.SCHEMA",
            "        backend = get_default_backend()",
            "        # Load query into GraphQL backend",
            "        document = backend.document_from_string(schema, self.query)",
            "",
            "        # Inspect the parsed document tree (document.document_ast) to retrieve the query (operation) definition(s)",
            "        # that define one or more variables. For each operation and variable definition, store the variable's",
            "        # default value (if any) into our own \"variables\" dict.",
            "        definitions = [",
            "            d",
            "            for d in document.document_ast.definitions",
            "            if isinstance(d, OperationDefinition) and d.variable_definitions",
            "        ]",
            "        for definition in definitions:",
            "            for variable_definition in definition.variable_definitions:",
            "                default = variable_definition.default_value.value if variable_definition.default_value else \"\"",
            "                variables[variable_definition.variable.name.value] = default",
            "",
            "        self.variables = variables",
            "        return super().save(*args, **kwargs)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "        schema = graphene_settings.SCHEMA",
            "        backend = get_default_backend()",
            "        try:",
            "            backend.document_from_string(schema, self.query)",
            "        except GraphQLSyntaxError as error:",
            "            raise ValidationError({\"query\": error})",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "",
            "#",
            "# Health Check",
            "#",
            "",
            "",
            "class HealthCheckTestModel(BaseModel):",
            "    title = models.CharField(max_length=128)",
            "",
            "",
            "#",
            "# Image Attachments",
            "#",
            "",
            "",
            "class ImageAttachment(BaseModel):",
            "    \"\"\"",
            "    An uploaded image which is associated with an object.",
            "    \"\"\"",
            "",
            "    content_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)",
            "    object_id = models.UUIDField(db_index=True)",
            "    parent = GenericForeignKey(ct_field=\"content_type\", fk_field=\"object_id\")",
            "    image = models.ImageField(upload_to=image_upload, height_field=\"image_height\", width_field=\"image_width\")",
            "    image_height = models.PositiveSmallIntegerField()",
            "    image_width = models.PositiveSmallIntegerField()",
            "    name = models.CharField(max_length=50, blank=True, db_index=True)",
            "    created = models.DateTimeField(auto_now_add=True)",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)  # name may be non-unique",
            "",
            "    def __str__(self):",
            "        if self.name:",
            "            return self.name",
            "        filename = self.image.name.rsplit(\"/\", 1)[-1]",
            "        return filename.split(\"_\", 2)[2]",
            "",
            "    def delete(self, *args, **kwargs):",
            "        _name = self.image.name",
            "",
            "        super().delete(*args, **kwargs)",
            "",
            "        # Delete file from disk",
            "        self.image.delete(save=False)",
            "",
            "        # Deleting the file erases its name. We restore the image's filename here in case we still need to reference it",
            "        # before the request finishes. (For example, to display a message indicating the ImageAttachment was deleted.)",
            "        self.image.name = _name",
            "",
            "    @property",
            "    def size(self):",
            "        \"\"\"",
            "        Wrapper around `image.size` to suppress an OSError in case the file is inaccessible. Also opportunistically",
            "        catch other exceptions that we know other storage back-ends to throw.",
            "        \"\"\"",
            "        expected_exceptions = [OSError]",
            "",
            "        try:",
            "            from botocore.exceptions import ClientError",
            "",
            "            expected_exceptions.append(ClientError)",
            "        except ImportError:",
            "            pass",
            "",
            "        try:",
            "            return self.image.size",
            "        except tuple(expected_exceptions):",
            "            return None",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "@extras_features(\"graphql\", \"webhooks\")",
            "class Note(BaseModel, ChangeLoggedModel):",
            "    \"\"\"",
            "    Notes allow anyone with proper permissions to add a note to an object.",
            "    \"\"\"",
            "",
            "    assigned_object_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)",
            "    assigned_object_id = models.UUIDField(db_index=True)",
            "    assigned_object = GenericForeignKey(ct_field=\"assigned_object_type\", fk_field=\"assigned_object_id\")",
            "    user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL,",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"note\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    user_name = models.CharField(max_length=150, editable=False)",
            "",
            "    slug = AutoSlugField(populate_from=\"assigned_object\")",
            "    note = models.TextField()",
            "    objects = NotesQuerySet.as_manager()",
            "",
            "    class Meta:",
            "        ordering = [\"created\"]",
            "",
            "    def slugify_function(self, content):",
            "        return slugify(f\"{str(content)[:50]}-{datetime.now().isoformat()}\")",
            "",
            "    def __str__(self):",
            "        return str(self.slug)",
            "",
            "    def save(self, *args, **kwargs):",
            "        # Record the user's name as static strings",
            "        self.user_name = self.user.username if self.user else \"Undefined\"",
            "        return super().save(*args, **kwargs)",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class Webhook(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    A Webhook defines a request that will be sent to a remote application when an object is created, updated, and/or",
            "    delete in Nautobot. The request will contain a representation of the object, which the remote application can act on.",
            "    Each Webhook can be limited to firing only on certain actions or certain object types.",
            "    \"\"\"",
            "",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"webhooks\",",
            "        verbose_name=\"Object types\",",
            "        limit_choices_to=FeatureQuery(\"webhooks\"),",
            "        help_text=\"The object(s) to which this Webhook applies.\",",
            "    )",
            "    name = models.CharField(max_length=150, unique=True)",
            "    type_create = models.BooleanField(default=False, help_text=\"Call this webhook when a matching object is created.\")",
            "    type_update = models.BooleanField(default=False, help_text=\"Call this webhook when a matching object is updated.\")",
            "    type_delete = models.BooleanField(default=False, help_text=\"Call this webhook when a matching object is deleted.\")",
            "    payload_url = models.CharField(",
            "        max_length=500,",
            "        verbose_name=\"URL\",",
            "        help_text=\"A POST will be sent to this URL when the webhook is called.\",",
            "    )",
            "    enabled = models.BooleanField(default=True)",
            "    http_method = models.CharField(",
            "        max_length=30,",
            "        choices=WebhookHttpMethodChoices,",
            "        default=WebhookHttpMethodChoices.METHOD_POST,",
            "        verbose_name=\"HTTP method\",",
            "    )",
            "    http_content_type = models.CharField(",
            "        max_length=100,",
            "        default=HTTP_CONTENT_TYPE_JSON,",
            "        verbose_name=\"HTTP content type\",",
            "        help_text=\"The complete list of official content types is available \"",
            "        '<a href=\"https://www.iana.org/assignments/media-types/media-types.xhtml\">here</a>.',",
            "    )",
            "    additional_headers = models.TextField(",
            "        blank=True,",
            "        help_text=\"User-supplied HTTP headers to be sent with the request in addition to the HTTP content type. \"",
            "        \"Headers should be defined in the format <code>Name: Value</code>. Jinja2 template processing is \"",
            "        \"support with the same context as the request body (below).\",",
            "    )",
            "    body_template = models.TextField(",
            "        blank=True,",
            "        help_text=\"Jinja2 template for a custom request body. If blank, a JSON object representing the change will be \"",
            "        \"included. Available context data includes: <code>event</code>, <code>model</code>, \"",
            "        \"<code>timestamp</code>, <code>username</code>, <code>request_id</code>, and <code>data</code>.\",",
            "    )",
            "    secret = models.CharField(",
            "        max_length=255,",
            "        blank=True,",
            "        help_text=\"When provided, the request will include a 'X-Hook-Signature' \"",
            "        \"header containing a HMAC hex digest of the payload body using \"",
            "        \"the secret as the key. The secret is not transmitted in \"",
            "        \"the request.\",",
            "    )",
            "    ssl_verification = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"SSL verification\",",
            "        help_text=\"Enable SSL certificate verification. Disable with caution!\",",
            "    )",
            "    ca_file_path = models.CharField(",
            "        max_length=4096,",
            "        null=True,",
            "        blank=True,",
            "        verbose_name=\"CA File Path\",",
            "        help_text=\"The specific CA certificate file to use for SSL verification. \"",
            "        \"Leave blank to use the system defaults.\",",
            "    )",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # At least one action type must be selected",
            "        if not self.type_create and not self.type_delete and not self.type_update:",
            "            raise ValidationError(\"You must select at least one type: create, update, and/or delete.\")",
            "",
            "        # CA file path requires SSL verification enabled",
            "        if not self.ssl_verification and self.ca_file_path:",
            "            raise ValidationError(",
            "                {\"ca_file_path\": \"Do not specify a CA certificate file if SSL verification is disabled.\"}",
            "            )",
            "",
            "    def render_headers(self, context):",
            "        \"\"\"",
            "        Render additional_headers and return a dict of Header: Value pairs.",
            "        \"\"\"",
            "        if not self.additional_headers:",
            "            return {}",
            "        ret = {}",
            "        data = render_jinja2(self.additional_headers, context)",
            "        for line in data.splitlines():",
            "            header, value = line.split(\":\")",
            "            ret[header.strip()] = value.strip()",
            "        return ret",
            "",
            "    def render_body(self, context):",
            "        \"\"\"",
            "        Render the body template, if defined. Otherwise, dump the context as a JSON object.",
            "        \"\"\"",
            "        if self.body_template:",
            "            return render_jinja2(self.body_template, context)",
            "        else:",
            "            return json.dumps(context, cls=JSONEncoder, ensure_ascii=False)",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:webhook\", kwargs={\"pk\": self.pk})",
            "",
            "    @classmethod",
            "    def check_for_conflicts(",
            "        cls, instance=None, content_types=None, payload_url=None, type_create=None, type_update=None, type_delete=None",
            "    ):",
            "        \"\"\"",
            "        Helper method for enforcing uniqueness.",
            "",
            "        Don't allow two webhooks with the same content_type, same payload_url, and any action(s) in common.",
            "        Called by WebhookForm.clean() and WebhookSerializer.validate()",
            "        \"\"\"",
            "",
            "        conflicts = {}",
            "        webhook_error_msg = \"A webhook already exists for {action} on {content_type} to URL {url}\"",
            "",
            "        if instance is not None and instance.present_in_database:",
            "            # This is a PATCH and might not include all relevant data e.g content_types, payload_url or actions",
            "            # Therefore we get data not available from instance",
            "            content_types = instance.content_types.all() if content_types is None else content_types",
            "            payload_url = instance.payload_url if payload_url is None else payload_url",
            "            type_create = instance.type_create if type_create is None else type_create",
            "            type_update = instance.type_update if type_update is None else type_update",
            "            type_delete = instance.type_delete if type_delete is None else type_delete",
            "",
            "        if content_types is not None:",
            "            for content_type in content_types:",
            "                webhooks = cls.objects.filter(content_types__in=[content_type], payload_url=payload_url)",
            "                if instance and instance.present_in_database:",
            "                    webhooks = webhooks.exclude(pk=instance.pk)",
            "",
            "                existing_type_create = webhooks.filter(type_create=type_create).exists() if type_create else False",
            "                existing_type_update = webhooks.filter(type_update=type_update).exists() if type_update else False",
            "                existing_type_delete = webhooks.filter(type_delete=type_delete).exists() if type_delete else False",
            "",
            "                if existing_type_create:",
            "                    conflicts.setdefault(\"type_create\", []).append(",
            "                        webhook_error_msg.format(content_type=content_type, action=\"create\", url=payload_url),",
            "                    )",
            "",
            "                if existing_type_update:",
            "                    conflicts.setdefault(\"type_update\", []).append(",
            "                        webhook_error_msg.format(content_type=content_type, action=\"update\", url=payload_url),",
            "                    )",
            "",
            "                if existing_type_delete:",
            "                    conflicts.setdefault(\"type_delete\", []).append(",
            "                        webhook_error_msg.format(content_type=content_type, action=\"delete\", url=payload_url),",
            "                    )",
            "",
            "        return conflicts"
        ],
        "afterPatchFile": [
            "from datetime import datetime",
            "import json",
            "from collections import OrderedDict",
            "",
            "from db_file_storage.model_utils import delete_file, delete_file_if_needed",
            "from db_file_storage.storage import DatabaseFileStorage",
            "from django.conf import settings",
            "from django.contrib.contenttypes.fields import GenericForeignKey",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.core.exceptions import ValidationError",
            "from django.db import models",
            "from django.http import HttpResponse",
            "from django.utils.text import slugify",
            "from django.urls import reverse",
            "from graphene_django.settings import graphene_settings",
            "from graphql import get_default_backend",
            "from graphql.error import GraphQLSyntaxError",
            "from graphql.language.ast import OperationDefinition",
            "from jsonschema.exceptions import SchemaError, ValidationError as JSONSchemaValidationError",
            "from jsonschema.validators import Draft7Validator",
            "from rest_framework.utils.encoders import JSONEncoder",
            "",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models import BaseModel",
            "from nautobot.core.models.generics import OrganizationalModel",
            "from nautobot.extras.choices import (",
            "    ButtonClassChoices,",
            "    WebhookHttpMethodChoices,",
            ")",
            "from nautobot.extras.constants import HTTP_CONTENT_TYPE_JSON",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.extras.models.relationships import RelationshipModel",
            "from nautobot.extras.querysets import ConfigContextQuerySet, NotesQuerySet",
            "from nautobot.extras.utils import extras_features, FeatureQuery, image_upload",
            "from nautobot.utilities.utils import deepmerge, render_jinja2",
            "",
            "# Avoid breaking backward compatibility on anything that might expect these to still be defined here:",
            "from .jobs import JOB_LOGS, Job, JobLogEntry, JobResult, ScheduledJob, ScheduledJobs  # noqa: F401",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextSchemaValidationMixin:",
            "    \"\"\"",
            "    Mixin that provides validation of config context data against a json schema.",
            "    \"\"\"",
            "",
            "    def _validate_with_schema(self, data_field, schema_field):",
            "        schema = getattr(self, schema_field)",
            "        data = getattr(self, data_field)",
            "",
            "        # If schema is None, then no schema has been specified on the instance and thus no validation should occur.",
            "        if schema:",
            "            try:",
            "                Draft7Validator(schema.data_schema, format_checker=Draft7Validator.FORMAT_CHECKER).validate(data)",
            "            except JSONSchemaValidationError as e:",
            "                raise ValidationError({data_field: [f\"Validation using the JSON Schema {schema} failed.\", e.message]})",
            "",
            "",
            "def limit_dynamic_group_choices():",
            "    return models.Q(content_type__app_label=\"virtualization\", content_type__model=\"virtualmachine\") | models.Q(",
            "        content_type__app_label=\"dcim\", content_type__model=\"device\"",
            "    )",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class ConfigContext(BaseModel, ChangeLoggedModel, ConfigContextSchemaValidationMixin, NotesMixin):",
            "    \"\"\"",
            "    A ConfigContext represents a set of arbitrary data available to any Device or VirtualMachine matching its assigned",
            "    qualifiers (region, site, etc.). For example, the data stored in a ConfigContext assigned to site A and tenant B",
            "    will be available to a Device in site A assigned to tenant B. Data is stored in JSON format.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=100, db_index=True)",
            "",
            "    # A ConfigContext *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"config_context_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    owner = GenericForeignKey(",
            "        ct_field=\"owner_content_type\",",
            "        fk_field=\"owner_object_id\",",
            "    )",
            "",
            "    weight = models.PositiveSmallIntegerField(default=1000)",
            "    description = models.CharField(max_length=200, blank=True)",
            "    is_active = models.BooleanField(",
            "        default=True,",
            "    )",
            "    schema = models.ForeignKey(",
            "        to=\"extras.ConfigContextSchema\",",
            "        on_delete=models.SET_NULL,",
            "        null=True,",
            "        blank=True,",
            "        help_text=\"Optional schema to validate the structure of the data\",",
            "    )",
            "    regions = models.ManyToManyField(to=\"dcim.Region\", related_name=\"+\", blank=True)",
            "    sites = models.ManyToManyField(to=\"dcim.Site\", related_name=\"+\", blank=True)",
            "    locations = models.ManyToManyField(to=\"dcim.Location\", related_name=\"+\", blank=True)",
            "    roles = models.ManyToManyField(to=\"dcim.DeviceRole\", related_name=\"+\", blank=True)",
            "    device_types = models.ManyToManyField(to=\"dcim.DeviceType\", related_name=\"+\", blank=True)",
            "    device_redundancy_groups = models.ManyToManyField(to=\"dcim.DeviceRedundancyGroup\", related_name=\"+\", blank=True)",
            "    platforms = models.ManyToManyField(to=\"dcim.Platform\", related_name=\"+\", blank=True)",
            "    cluster_groups = models.ManyToManyField(to=\"virtualization.ClusterGroup\", related_name=\"+\", blank=True)",
            "    clusters = models.ManyToManyField(to=\"virtualization.Cluster\", related_name=\"+\", blank=True)",
            "    tenant_groups = models.ManyToManyField(to=\"tenancy.TenantGroup\", related_name=\"+\", blank=True)",
            "    tenants = models.ManyToManyField(to=\"tenancy.Tenant\", related_name=\"+\", blank=True)",
            "    tags = models.ManyToManyField(to=\"extras.Tag\", related_name=\"+\", blank=True)",
            "",
            "    # Due to feature flag CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED this field will remain empty unless set to True.",
            "    dynamic_groups = models.ManyToManyField(",
            "        to=\"extras.DynamicGroup\", related_name=\"+\", blank=True, limit_choices_to=limit_dynamic_group_choices",
            "    )",
            "    data = models.JSONField(encoder=DjangoJSONEncoder)",
            "",
            "    objects = ConfigContextQuerySet.as_manager()",
            "",
            "    class Meta:",
            "        ordering = [\"weight\", \"name\"]",
            "        unique_together = [[\"name\", \"owner_content_type\", \"owner_object_id\"]]",
            "",
            "    def __str__(self):",
            "        if self.owner:",
            "            return f\"[{self.owner}] {self.name}\"",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:configcontext\", kwargs={\"pk\": self.pk})",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Verify that JSON data is provided as an object",
            "        if not isinstance(self.data, dict):",
            "            raise ValidationError({\"data\": 'JSON data must be in object form. Example: {\"foo\": 123}'})",
            "",
            "        # Validate data against schema",
            "        self._validate_with_schema(\"data\", \"schema\")",
            "",
            "        # Check for a duplicated `name`. This is necessary because Django does not consider two NULL fields to be equal,",
            "        # and thus if the `owner` is NULL, a duplicate `name` will not otherwise automatically raise an exception.",
            "        if (",
            "            ConfigContext.objects.exclude(pk=self.pk)",
            "            .filter(name=self.name, owner_content_type=self.owner_content_type, owner_object_id=self.owner_object_id)",
            "            .exists()",
            "        ):",
            "            raise ValidationError({\"name\": \"A ConfigContext with this name already exists.\"})",
            "",
            "",
            "class ConfigContextModel(models.Model, ConfigContextSchemaValidationMixin):",
            "    \"\"\"",
            "    A model which includes local configuration context data. This local data will override any inherited data from",
            "    ConfigContexts.",
            "    \"\"\"",
            "",
            "    local_context_data = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    local_context_schema = models.ForeignKey(",
            "        to=\"extras.ConfigContextSchema\",",
            "        on_delete=models.SET_NULL,",
            "        null=True,",
            "        blank=True,",
            "        help_text=\"Optional schema to validate the structure of the data\",",
            "    )",
            "    # The local context data *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    local_context_data_owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"config_context_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    local_context_data_owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    local_context_data_owner = GenericForeignKey(",
            "        ct_field=\"local_context_data_owner_content_type\",",
            "        fk_field=\"local_context_data_owner_object_id\",",
            "    )",
            "",
            "    class Meta:",
            "        abstract = True",
            "        indexes = [",
            "            models.Index(fields=(\"local_context_data_owner_content_type\", \"local_context_data_owner_object_id\")),",
            "        ]",
            "",
            "    def get_config_context(self):",
            "        \"\"\"",
            "        Return the rendered configuration context for a device or VM.",
            "        \"\"\"",
            "",
            "        if not hasattr(self, \"config_context_data\"):",
            "            # Annotation not available, so fall back to manually querying for the config context",
            "            config_context_data = ConfigContext.objects.get_for_object(self).values_list(\"data\", flat=True)",
            "        else:",
            "            config_context_data = self.config_context_data or []",
            "            # Annotation has keys \"weight\" and \"name\" (used for ordering) and \"data\" (the actual config context data)",
            "            config_context_data = [",
            "                c[\"data\"] for c in sorted(config_context_data, key=lambda k: (k[\"weight\"], k[\"name\"]))",
            "            ]",
            "",
            "        # Compile all config data, overwriting lower-weight values with higher-weight values where a collision occurs",
            "        data = OrderedDict()",
            "        for context in config_context_data:",
            "            data = deepmerge(data, context)",
            "",
            "        # If the object has local config context data defined, merge it last",
            "        if self.local_context_data:",
            "            data = deepmerge(data, self.local_context_data)",
            "",
            "        return data",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # Verify that JSON data is provided as an object",
            "        if self.local_context_data and not isinstance(self.local_context_data, dict):",
            "            raise ValidationError({\"local_context_data\": 'JSON data must be in object form. Example: {\"foo\": 123}'})",
            "",
            "        if self.local_context_schema and not self.local_context_data:",
            "            raise ValidationError({\"local_context_schema\": \"Local context data must exist for a schema to be applied.\"})",
            "",
            "        # Validate data against schema",
            "        self._validate_with_schema(\"local_context_data\", \"local_context_schema\")",
            "",
            "",
            "@extras_features(",
            "    \"custom_fields\",",
            "    \"custom_validators\",",
            "    \"graphql\",",
            "    \"relationships\",",
            ")",
            "class ConfigContextSchema(OrganizationalModel):",
            "    \"\"\"",
            "    This model stores jsonschema documents where are used to optionally validate config context data payloads.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=200)",
            "    description = models.CharField(max_length=200, blank=True)",
            "    slug = AutoSlugField(populate_from=\"name\", max_length=200, unique=None, db_index=True)",
            "    data_schema = models.JSONField(",
            "        help_text=\"A JSON Schema document which is used to validate a config context object.\"",
            "    )",
            "    # A ConfigContextSchema *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"config_context_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    owner = GenericForeignKey(",
            "        ct_field=\"owner_content_type\",",
            "        fk_field=\"owner_object_id\",",
            "    )",
            "",
            "    class Meta:",
            "        constraints = [",
            "            models.UniqueConstraint(fields=[\"name\", \"owner_content_type\", \"owner_object_id\"], name=\"unique_name_owner\"),",
            "        ]",
            "",
            "    def __str__(self):",
            "        if self.owner:",
            "            return f\"[{self.owner}] {self.name}\"",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:configcontextschema\", args=[self.slug])",
            "",
            "    def clean(self):",
            "        \"\"\"",
            "        Validate the schema",
            "        \"\"\"",
            "        super().clean()",
            "",
            "        try:",
            "            Draft7Validator.check_schema(self.data_schema)",
            "        except SchemaError as e:",
            "            raise ValidationError({\"data_schema\": e.message})",
            "",
            "        if (",
            "            not isinstance(self.data_schema, dict)",
            "            or \"properties\" not in self.data_schema",
            "            or self.data_schema.get(\"type\") != \"object\"",
            "        ):",
            "            raise ValidationError(",
            "                {",
            "                    \"data_schema\": \"Nautobot only supports context data in the form of an object and thus the \"",
            "                    \"JSON schema must be of type object and specify a set of properties.\"",
            "                }",
            "            )",
            "",
            "",
            "#",
            "# Custom links",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class CustomLink(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    A custom link to an external representation of a Nautobot object. The link text and URL fields accept Jinja2 template",
            "    code to be rendered with an object as context.",
            "    \"\"\"",
            "",
            "    content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"custom_links\"),",
            "    )",
            "    name = models.CharField(max_length=100, unique=True)",
            "    text = models.CharField(",
            "        max_length=500,",
            "        help_text=\"Jinja2 template code for link text. \"",
            "        \"Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>. \"",
            "        \"Links which render as empty text will not be displayed.\",",
            "    )",
            "    target_url = models.CharField(",
            "        max_length=500,",
            "        verbose_name=\"URL\",",
            "        help_text=\"Jinja2 template code for link URL. \"",
            "        \"Reference the object as <code>{{ obj }}</code> such as <code>{{ obj.platform.slug }}</code>.\",",
            "    )",
            "    weight = models.PositiveSmallIntegerField(default=100)",
            "    group_name = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        help_text=\"Links with the same group will appear as a dropdown menu\",",
            "    )",
            "    button_class = models.CharField(",
            "        max_length=30,",
            "        choices=ButtonClassChoices,",
            "        default=ButtonClassChoices.CLASS_DEFAULT,",
            "        help_text=\"The class of the first link in a group will be used for the dropdown button\",",
            "    )",
            "    new_window = models.BooleanField(help_text=\"Force link to open in a new window\")",
            "",
            "    class Meta:",
            "        ordering = [\"group_name\", \"weight\", \"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:customlink\", kwargs={\"pk\": self.pk})",
            "",
            "",
            "#",
            "# Export templates",
            "#",
            "",
            "",
            "@extras_features(",
            "    \"graphql\",",
            "    \"relationships\",",
            ")",
            "class ExportTemplate(BaseModel, ChangeLoggedModel, RelationshipModel, NotesMixin):",
            "    # An ExportTemplate *may* be owned by another model, such as a GitRepository, or it may be un-owned",
            "    owner_content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        related_name=\"export_template_owners\",",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"export_template_owners\"),",
            "        default=None,",
            "        null=True,",
            "        blank=True,",
            "    )",
            "    owner_object_id = models.UUIDField(default=None, null=True, blank=True)",
            "    owner = GenericForeignKey(",
            "        ct_field=\"owner_content_type\",",
            "        fk_field=\"owner_object_id\",",
            "    )",
            "    content_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        limit_choices_to=FeatureQuery(\"export_templates\"),",
            "    )",
            "    name = models.CharField(max_length=100)",
            "    description = models.CharField(max_length=200, blank=True)",
            "    template_code = models.TextField(",
            "        help_text=\"The list of objects being exported is passed as a context variable named <code>queryset</code>.\"",
            "    )",
            "    mime_type = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"MIME type\",",
            "        help_text=\"Defaults to <code>text/plain</code>\",",
            "    )",
            "    file_extension = models.CharField(",
            "        max_length=15,",
            "        blank=True,",
            "        help_text=\"Extension to append to the rendered filename\",",
            "    )",
            "",
            "    class Meta:",
            "        ordering = [\"content_type\", \"name\"]",
            "        unique_together = [[\"content_type\", \"name\", \"owner_content_type\", \"owner_object_id\"]]",
            "",
            "    def __str__(self):",
            "        if self.owner:",
            "            return f\"[{self.owner}] {self.content_type}: {self.name}\"",
            "        return f\"{self.content_type}: {self.name}\"",
            "",
            "    def render(self, queryset):",
            "        \"\"\"",
            "        Render the contents of the template.",
            "        \"\"\"",
            "        context = {\"queryset\": queryset}",
            "        output = render_jinja2(self.template_code, context)",
            "",
            "        # Replace CRLF-style line terminators",
            "        output = output.replace(\"\\r\\n\", \"\\n\")",
            "",
            "        return output",
            "",
            "    def render_to_response(self, queryset):",
            "        \"\"\"",
            "        Render the template to an HTTP response, delivered as a named file attachment",
            "        \"\"\"",
            "        output = self.render(queryset)",
            "        mime_type = \"text/plain\" if not self.mime_type else self.mime_type",
            "",
            "        # Build the response",
            "        response = HttpResponse(output, content_type=mime_type)",
            "        extension = f\".{self.file_extension}\" if self.file_extension else \"\"",
            "        filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{queryset.model._meta.verbose_name_plural}{extension}\"",
            "        response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "",
            "        return response",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:exporttemplate\", kwargs={\"pk\": self.pk})",
            "",
            "    def clean(self):",
            "        super().clean()",
            "        if self.file_extension.startswith(\".\"):",
            "            self.file_extension = self.file_extension[1:]",
            "",
            "        # Don't allow two ExportTemplates with the same name, content_type, and owner.",
            "        # This is necessary because Django doesn't consider NULL=NULL, and so if owner is NULL the unique_together",
            "        # condition will never be matched even if name and content_type are the same.",
            "        if (",
            "            ExportTemplate.objects.exclude(pk=self.pk)",
            "            .filter(",
            "                name=self.name,",
            "                content_type=self.content_type,",
            "                owner_content_type=self.owner_content_type,",
            "                owner_object_id=self.owner_object_id,",
            "            )",
            "            .exists()",
            "        ):",
            "            raise ValidationError({\"name\": \"An ExportTemplate with this name and content type already exists.\"})",
            "",
            "",
            "#",
            "# File attachments",
            "#",
            "",
            "",
            "class FileAttachment(BaseModel):",
            "    \"\"\"An object for storing the contents and metadata of a file in the database.",
            "",
            "    This object is used by `FileProxy` objects to retrieve file contents and is",
            "    not intended to be used standalone.",
            "    \"\"\"",
            "",
            "    bytes = models.BinaryField()",
            "    filename = models.CharField(max_length=255)",
            "    mimetype = models.CharField(max_length=255)",
            "",
            "    def __str__(self):",
            "        return self.filename",
            "",
            "    class Meta:",
            "        ordering = [\"filename\"]",
            "",
            "",
            "def database_storage():",
            "    \"\"\"Returns storage backend used by `FileProxy.file` to store files in the database.\"\"\"",
            "    return DatabaseFileStorage()",
            "",
            "",
            "class FileProxy(BaseModel):",
            "    \"\"\"An object to store a file in the database.",
            "",
            "    The `file` field can be used like a file handle. The file contents are stored and retrieved from",
            "    `FileAttachment` objects.",
            "",
            "    The associated `FileAttachment` is removed when `delete()` is called. For this reason, one",
            "    should never use bulk delete operations on `FileProxy` objects, unless `FileAttachment` objects",
            "    are also bulk-deleted, because a model's `delete()` method is not called during bulk operations.",
            "    In most cases, it is better to iterate over a queryset of `FileProxy` objects and call",
            "    `delete()` on each one individually.",
            "    \"\"\"",
            "",
            "    name = models.CharField(max_length=255)",
            "    file = models.FileField(",
            "        upload_to=\"extras.FileAttachment/bytes/filename/mimetype\",",
            "        storage=database_storage,  # Use only this backend",
            "    )",
            "    uploaded_at = models.DateTimeField(auto_now_add=True)",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    class Meta:",
            "        get_latest_by = \"uploaded_at\"",
            "        ordering = [\"name\"]",
            "        verbose_name_plural = \"file proxies\"",
            "",
            "    def save(self, *args, **kwargs):",
            "        delete_file_if_needed(self, \"file\")",
            "        super().save(*args, **kwargs)",
            "",
            "    def delete(self, *args, **kwargs):",
            "        super().delete(*args, **kwargs)",
            "        delete_file(self, \"file\")",
            "",
            "",
            "#",
            "# Saved GraphQL queries",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class GraphQLQuery(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    name = models.CharField(max_length=100, unique=True)",
            "    slug = AutoSlugField(populate_from=\"name\")",
            "    query = models.TextField()",
            "    variables = models.JSONField(encoder=DjangoJSONEncoder, default=dict, blank=True)",
            "",
            "    class Meta:",
            "        ordering = (\"slug\",)",
            "        verbose_name = \"GraphQL query\"",
            "        verbose_name_plural = \"GraphQL queries\"",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:graphqlquery\", kwargs={\"slug\": self.slug})",
            "",
            "    def save(self, *args, **kwargs):",
            "        variables = {}",
            "        schema = graphene_settings.SCHEMA",
            "        backend = get_default_backend()",
            "        # Load query into GraphQL backend",
            "        document = backend.document_from_string(schema, self.query)",
            "",
            "        # Inspect the parsed document tree (document.document_ast) to retrieve the query (operation) definition(s)",
            "        # that define one or more variables. For each operation and variable definition, store the variable's",
            "        # default value (if any) into our own \"variables\" dict.",
            "        definitions = [",
            "            d",
            "            for d in document.document_ast.definitions",
            "            if isinstance(d, OperationDefinition) and d.variable_definitions",
            "        ]",
            "        for definition in definitions:",
            "            for variable_definition in definition.variable_definitions:",
            "                default = variable_definition.default_value.value if variable_definition.default_value else \"\"",
            "                variables[variable_definition.variable.name.value] = default",
            "",
            "        self.variables = variables",
            "        return super().save(*args, **kwargs)",
            "",
            "    def clean(self):",
            "        super().clean()",
            "        schema = graphene_settings.SCHEMA",
            "        backend = get_default_backend()",
            "        try:",
            "            backend.document_from_string(schema, self.query)",
            "        except GraphQLSyntaxError as error:",
            "            raise ValidationError({\"query\": error})",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "",
            "#",
            "# Health Check",
            "#",
            "",
            "",
            "class HealthCheckTestModel(BaseModel):",
            "    title = models.CharField(max_length=128)",
            "",
            "",
            "#",
            "# Image Attachments",
            "#",
            "",
            "",
            "class ImageAttachment(BaseModel):",
            "    \"\"\"",
            "    An uploaded image which is associated with an object.",
            "    \"\"\"",
            "",
            "    content_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)",
            "    object_id = models.UUIDField(db_index=True)",
            "    parent = GenericForeignKey(ct_field=\"content_type\", fk_field=\"object_id\")",
            "    image = models.ImageField(upload_to=image_upload, height_field=\"image_height\", width_field=\"image_width\")",
            "    image_height = models.PositiveSmallIntegerField()",
            "    image_width = models.PositiveSmallIntegerField()",
            "    name = models.CharField(max_length=50, blank=True, db_index=True)",
            "    created = models.DateTimeField(auto_now_add=True)",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)  # name may be non-unique",
            "",
            "    def __str__(self):",
            "        if self.name:",
            "            return self.name",
            "        filename = self.image.name.rsplit(\"/\", 1)[-1]",
            "        return filename.split(\"_\", 2)[2]",
            "",
            "    def delete(self, *args, **kwargs):",
            "        _name = self.image.name",
            "",
            "        super().delete(*args, **kwargs)",
            "",
            "        # Delete file from disk",
            "        self.image.delete(save=False)",
            "",
            "        # Deleting the file erases its name. We restore the image's filename here in case we still need to reference it",
            "        # before the request finishes. (For example, to display a message indicating the ImageAttachment was deleted.)",
            "        self.image.name = _name",
            "",
            "    @property",
            "    def size(self):",
            "        \"\"\"",
            "        Wrapper around `image.size` to suppress an OSError in case the file is inaccessible. Also opportunistically",
            "        catch other exceptions that we know other storage back-ends to throw.",
            "        \"\"\"",
            "        expected_exceptions = [OSError]",
            "",
            "        try:",
            "            from botocore.exceptions import ClientError",
            "",
            "            expected_exceptions.append(ClientError)",
            "        except ImportError:",
            "            pass",
            "",
            "        try:",
            "            return self.image.size",
            "        except tuple(expected_exceptions):",
            "            return None",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "@extras_features(\"graphql\", \"webhooks\")",
            "class Note(BaseModel, ChangeLoggedModel):",
            "    \"\"\"",
            "    Notes allow anyone with proper permissions to add a note to an object.",
            "    \"\"\"",
            "",
            "    assigned_object_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)",
            "    assigned_object_id = models.UUIDField(db_index=True)",
            "    assigned_object = GenericForeignKey(ct_field=\"assigned_object_type\", fk_field=\"assigned_object_id\")",
            "    user = models.ForeignKey(",
            "        to=settings.AUTH_USER_MODEL,",
            "        on_delete=models.SET_NULL,",
            "        related_name=\"note\",",
            "        blank=True,",
            "        null=True,",
            "    )",
            "    user_name = models.CharField(max_length=150, editable=False)",
            "",
            "    slug = AutoSlugField(populate_from=\"assigned_object\")",
            "    note = models.TextField()",
            "    objects = NotesQuerySet.as_manager()",
            "",
            "    class Meta:",
            "        ordering = [\"created\"]",
            "",
            "    def slugify_function(self, content):",
            "        return slugify(f\"{str(content)[:50]}-{datetime.now().isoformat()}\")",
            "",
            "    def __str__(self):",
            "        return str(self.slug)",
            "",
            "    def save(self, *args, **kwargs):",
            "        # Record the user's name as static strings",
            "        self.user_name = self.user.username if self.user else \"Undefined\"",
            "        return super().save(*args, **kwargs)",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "@extras_features(\"graphql\")",
            "class Webhook(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    \"\"\"",
            "    A Webhook defines a request that will be sent to a remote application when an object is created, updated, and/or",
            "    delete in Nautobot. The request will contain a representation of the object, which the remote application can act on.",
            "    Each Webhook can be limited to firing only on certain actions or certain object types.",
            "    \"\"\"",
            "",
            "    content_types = models.ManyToManyField(",
            "        to=ContentType,",
            "        related_name=\"webhooks\",",
            "        verbose_name=\"Object types\",",
            "        limit_choices_to=FeatureQuery(\"webhooks\"),",
            "        help_text=\"The object(s) to which this Webhook applies.\",",
            "    )",
            "    name = models.CharField(max_length=150, unique=True)",
            "    type_create = models.BooleanField(default=False, help_text=\"Call this webhook when a matching object is created.\")",
            "    type_update = models.BooleanField(default=False, help_text=\"Call this webhook when a matching object is updated.\")",
            "    type_delete = models.BooleanField(default=False, help_text=\"Call this webhook when a matching object is deleted.\")",
            "    payload_url = models.CharField(",
            "        max_length=500,",
            "        verbose_name=\"URL\",",
            "        help_text=\"A POST will be sent to this URL when the webhook is called.\",",
            "    )",
            "    enabled = models.BooleanField(default=True)",
            "    http_method = models.CharField(",
            "        max_length=30,",
            "        choices=WebhookHttpMethodChoices,",
            "        default=WebhookHttpMethodChoices.METHOD_POST,",
            "        verbose_name=\"HTTP method\",",
            "    )",
            "    http_content_type = models.CharField(",
            "        max_length=100,",
            "        default=HTTP_CONTENT_TYPE_JSON,",
            "        verbose_name=\"HTTP content type\",",
            "        help_text=\"The complete list of official content types is available \"",
            "        '<a href=\"https://www.iana.org/assignments/media-types/media-types.xhtml\">here</a>.',",
            "    )",
            "    additional_headers = models.TextField(",
            "        blank=True,",
            "        help_text=\"User-supplied HTTP headers to be sent with the request in addition to the HTTP content type. \"",
            "        \"Headers should be defined in the format <code>Name: Value</code>. Jinja2 template processing is \"",
            "        \"support with the same context as the request body (below).\",",
            "    )",
            "    body_template = models.TextField(",
            "        blank=True,",
            "        help_text=\"Jinja2 template for a custom request body. If blank, a JSON object representing the change will be \"",
            "        \"included. Available context data includes: <code>event</code>, <code>model</code>, \"",
            "        \"<code>timestamp</code>, <code>username</code>, <code>request_id</code>, and <code>data</code>.\",",
            "    )",
            "    secret = models.CharField(",
            "        max_length=255,",
            "        blank=True,",
            "        help_text=\"When provided, the request will include a 'X-Hook-Signature' \"",
            "        \"header containing a HMAC hex digest of the payload body using \"",
            "        \"the secret as the key. The secret is not transmitted in \"",
            "        \"the request.\",",
            "    )",
            "    ssl_verification = models.BooleanField(",
            "        default=True,",
            "        verbose_name=\"SSL verification\",",
            "        help_text=\"Enable SSL certificate verification. Disable with caution!\",",
            "    )",
            "    ca_file_path = models.CharField(",
            "        max_length=4096,",
            "        null=True,",
            "        blank=True,",
            "        verbose_name=\"CA File Path\",",
            "        help_text=\"The specific CA certificate file to use for SSL verification. \"",
            "        \"Leave blank to use the system defaults.\",",
            "    )",
            "",
            "    class Meta:",
            "        ordering = (\"name\",)",
            "",
            "    def __str__(self):",
            "        return self.name",
            "",
            "    def clean(self):",
            "        super().clean()",
            "",
            "        # At least one action type must be selected",
            "        if not self.type_create and not self.type_delete and not self.type_update:",
            "            raise ValidationError(\"You must select at least one type: create, update, and/or delete.\")",
            "",
            "        # CA file path requires SSL verification enabled",
            "        if not self.ssl_verification and self.ca_file_path:",
            "            raise ValidationError(",
            "                {\"ca_file_path\": \"Do not specify a CA certificate file if SSL verification is disabled.\"}",
            "            )",
            "",
            "    def render_headers(self, context):",
            "        \"\"\"",
            "        Render additional_headers and return a dict of Header: Value pairs.",
            "        \"\"\"",
            "        if not self.additional_headers:",
            "            return {}",
            "        ret = {}",
            "        data = render_jinja2(self.additional_headers, context)",
            "        for line in data.splitlines():",
            "            header, value = line.split(\":\")",
            "            ret[header.strip()] = value.strip()",
            "        return ret",
            "",
            "    def render_body(self, context):",
            "        \"\"\"",
            "        Render the body template, if defined. Otherwise, dump the context as a JSON object.",
            "        \"\"\"",
            "        if self.body_template:",
            "            return render_jinja2(self.body_template, context)",
            "        else:",
            "            return json.dumps(context, cls=JSONEncoder, ensure_ascii=False)",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:webhook\", kwargs={\"pk\": self.pk})",
            "",
            "    @classmethod",
            "    def check_for_conflicts(",
            "        cls, instance=None, content_types=None, payload_url=None, type_create=None, type_update=None, type_delete=None",
            "    ):",
            "        \"\"\"",
            "        Helper method for enforcing uniqueness.",
            "",
            "        Don't allow two webhooks with the same content_type, same payload_url, and any action(s) in common.",
            "        Called by WebhookForm.clean() and WebhookSerializer.validate()",
            "        \"\"\"",
            "",
            "        conflicts = {}",
            "        webhook_error_msg = \"A webhook already exists for {action} on {content_type} to URL {url}\"",
            "",
            "        if instance is not None and instance.present_in_database:",
            "            # This is a PATCH and might not include all relevant data e.g content_types, payload_url or actions",
            "            # Therefore we get data not available from instance",
            "            content_types = instance.content_types.all() if content_types is None else content_types",
            "            payload_url = instance.payload_url if payload_url is None else payload_url",
            "            type_create = instance.type_create if type_create is None else type_create",
            "            type_update = instance.type_update if type_update is None else type_update",
            "            type_delete = instance.type_delete if type_delete is None else type_delete",
            "",
            "        if content_types is not None:",
            "            for content_type in content_types:",
            "                webhooks = cls.objects.filter(content_types__in=[content_type], payload_url=payload_url)",
            "                if instance and instance.present_in_database:",
            "                    webhooks = webhooks.exclude(pk=instance.pk)",
            "",
            "                existing_type_create = webhooks.filter(type_create=type_create).exists() if type_create else False",
            "                existing_type_update = webhooks.filter(type_update=type_update).exists() if type_update else False",
            "                existing_type_delete = webhooks.filter(type_delete=type_delete).exists() if type_delete else False",
            "",
            "                if existing_type_create:",
            "                    conflicts.setdefault(\"type_create\", []).append(",
            "                        webhook_error_msg.format(content_type=content_type, action=\"create\", url=payload_url),",
            "                    )",
            "",
            "                if existing_type_update:",
            "                    conflicts.setdefault(\"type_update\", []).append(",
            "                        webhook_error_msg.format(content_type=content_type, action=\"update\", url=payload_url),",
            "                    )",
            "",
            "                if existing_type_delete:",
            "                    conflicts.setdefault(\"type_delete\", []).append(",
            "                        webhook_error_msg.format(content_type=content_type, action=\"delete\", url=payload_url),",
            "                    )",
            "",
            "        return conflicts"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "329": [
                "CustomLink"
            ],
            "334": [
                "CustomLink"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/models/relationships.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.db.models import Q"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from django.urls import reverse"
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from django.urls.exceptions import NoReverseMatch"
            },
            "3": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from nautobot.core.fields import AutoSlugField"
            },
            "7": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from nautobot.core.models import BaseModel"
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     widgets,"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " )"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from nautobot.utilities.querysets import RestrictedQuerySet"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from nautobot.utilities.templatetags.helpers import bettertitle"
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "15": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "                 if output_for == \"ui\":"
            },
            "16": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "                     try:"
            },
            "17": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "                         add_url = reverse(get_route_for_model(required_model_class, \"add\"))"
            },
            "18": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        hint = ("
            },
            "19": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            f\"<a target='_blank' href='{add_url}'>Click here</a> to create \""
            },
            "20": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            f\"a {required_model_meta.verbose_name}.\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+                        hint = format_html("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+                            '<a target=\"_blank\" href=\"{}\">Click here</a> to create a {}.',"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+                            add_url,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+                            required_model_meta.verbose_name,"
            },
            "25": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "                         )"
            },
            "26": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "                     except NoReverseMatch:"
            },
            "27": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "                         pass"
            },
            "28": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "                     except NoReverseMatch:"
            },
            "29": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "                         pass"
            },
            "30": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 293,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                error_message = mark_safe("
            },
            "32": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\"{name_plural[0].upper()}{name_plural[1:]} require \""
            },
            "33": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\"{num_required_verbose} {required_model_meta.verbose_name}, but no \""
            },
            "34": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\"{required_model_meta.verbose_name_plural} exist yet. {hint}\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+                error_message = format_html("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+                    \"{} require {} {}, but no {} exist yet. \","
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+                    bettertitle(name_plural),"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+                    num_required_verbose,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+                    required_model_meta.verbose_name,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+                    required_model_meta.verbose_name_plural,"
            },
            "41": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "                 )"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+                error_message += hint"
            },
            "43": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "                 field_errors[field_key].append(error_message)"
            },
            "44": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 303,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "             if initial_data is not None:"
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from django import forms",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation",
            "from django.core.exceptions import ValidationError",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.db import models",
            "from django.db.models import Q",
            "from django.urls import reverse",
            "from django.urls.exceptions import NoReverseMatch",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models import BaseModel",
            "from nautobot.extras.choices import RelationshipTypeChoices, RelationshipRequiredSideChoices, RelationshipSideChoices",
            "from nautobot.extras.utils import FeatureQuery, extras_features",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.utilities.utils import get_filterset_for_model, get_route_for_model, slugify_dashes_to_underscores",
            "from nautobot.utilities.forms import (",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    widgets,",
            ")",
            "from nautobot.utilities.querysets import RestrictedQuerySet",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "VALID_SIDES = [item[0] for item in RelationshipSideChoices.CHOICES]",
            "",
            "",
            "class RelationshipModel(models.Model):",
            "    \"\"\"",
            "    Abstract class for any model which may have custom relationships associated with it.",
            "    \"\"\"",
            "",
            "    class Meta:",
            "        abstract = True",
            "",
            "    # Define GenericRelations so that deleting a RelationshipModel instance",
            "    # cascades to deleting any RelationshipAssociations that were using this instance,",
            "    # and also for convenience in looking up the RelationshipModels associated to any given RelationshipAssociation",
            "    source_for_associations = GenericRelation(",
            "        \"extras.RelationshipAssociation\",",
            "        content_type_field=\"source_type\",",
            "        object_id_field=\"source_id\",",
            "        related_query_name=\"source_%(app_label)s_%(class)s\",  # e.g. 'source_dcim_site', 'source_ipam_vlan'",
            "    )",
            "    destination_for_associations = GenericRelation(",
            "        \"extras.RelationshipAssociation\",",
            "        content_type_field=\"destination_type\",",
            "        object_id_field=\"destination_id\",",
            "        related_query_name=\"destination_%(app_label)s_%(class)s\",  # e.g. 'destination_dcim_rack'",
            "    )",
            "",
            "    @property",
            "    def associations(self):",
            "        return list(self.source_for_associations.all()) + list(self.destination_for_associations.all())",
            "",
            "    def get_relationships(self, include_hidden=False, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictionary of RelationshipAssociation querysets for all custom relationships",
            "",
            "        Returns:",
            "            response {",
            "                \"source\": {",
            "                    <Relationship instance #1>: <RelationshipAssociation queryset #1>,",
            "                    <Relationship instance #2>: <RelationshipAssociation queryset #2>,",
            "                },",
            "                \"destination\": {",
            "                    <Relationship instance #3>: <RelationshipAssociation queryset #3>,",
            "                    <Relationship instance #4>: <RelationshipAssociation queryset #4>,",
            "                },",
            "                \"peer\": {",
            "                    <Relationship instance #5>: <RelationshipAssociation queryset #5>,",
            "                    <Relationship instance #6>: <RelationshipAssociation queryset #6>,",
            "                },",
            "            }",
            "        \"\"\"",
            "        src_relationships, dst_relationships = Relationship.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            src_relationships = src_relationships.filter(advanced_ui=advanced_ui)",
            "            dst_relationships = dst_relationships.filter(advanced_ui=advanced_ui)",
            "        content_type = ContentType.objects.get_for_model(self)",
            "",
            "        sides = {",
            "            RelationshipSideChoices.SIDE_SOURCE: src_relationships,",
            "            RelationshipSideChoices.SIDE_DESTINATION: dst_relationships,",
            "        }",
            "",
            "        resp = {",
            "            RelationshipSideChoices.SIDE_SOURCE: {},",
            "            RelationshipSideChoices.SIDE_DESTINATION: {},",
            "            RelationshipSideChoices.SIDE_PEER: {},",
            "        }",
            "        for side, relationships in sides.items():",
            "            for relationship in relationships:",
            "                if getattr(relationship, f\"{side}_hidden\") and not include_hidden:",
            "                    continue",
            "",
            "                # Determine if the relationship is applicable to this object based on the filter",
            "                # To resolve the filter we are using the FilterSet for the given model",
            "                # If there is no match when we query the primary key of the device along with the filter",
            "                # Then the relationship is not applicable to this object",
            "                if getattr(relationship, f\"{side}_filter\"):",
            "                    filterset = get_filterset_for_model(self._meta.model)",
            "                    if filterset:",
            "                        filter_params = getattr(relationship, f\"{side}_filter\")",
            "                        if not filterset(filter_params, self._meta.model.objects.filter(id=self.id)).qs.exists():",
            "                            continue",
            "",
            "                # Construct the queryset to query all RelationshipAssociation for this object and this relationship",
            "                query_params = {\"relationship\": relationship}",
            "                if not relationship.symmetric:",
            "                    # Query for RelationshipAssociations that this object is on the expected side of",
            "                    query_params[f\"{side}_id\"] = self.pk",
            "                    query_params[f\"{side}_type\"] = content_type",
            "",
            "                    resp[side][relationship] = RelationshipAssociation.objects.filter(**query_params)",
            "                else:",
            "                    # Query for RelationshipAssociations involving this object, regardless of side",
            "                    resp[RelationshipSideChoices.SIDE_PEER][relationship] = RelationshipAssociation.objects.filter(",
            "                        (",
            "                            Q(source_id=self.pk, source_type=content_type)",
            "                            | Q(destination_id=self.pk, destination_type=content_type)",
            "                        ),",
            "                        **query_params,",
            "                    )",
            "",
            "        return resp",
            "",
            "    def get_relationships_data(self, **kwargs):",
            "        \"\"\"",
            "        Return a dictionary of relationships with the label and the value or the queryset for each.",
            "",
            "        Used for rendering relationships in the UI; see nautobot/core/templates/inc/relationships_table_rows.html",
            "",
            "        Returns:",
            "            response {",
            "                \"source\": {",
            "                    <Relationship instance #1>: {   # one-to-one relationship that self is the source of",
            "                        \"label\": \"...\",",
            "                        \"peer_type\": <ContentType>,",
            "                        \"has_many\": False,",
            "                        \"value\": <model instance>,     # single destination for this relationship",
            "                        \"url\": \"...\",",
            "                    },",
            "                    <Relationship instance #2>: {   # one-to-many or many-to-many relationship that self is a source for",
            "                        \"label\": \"...\",",
            "                        \"peer_type\": <ContentType>,",
            "                        \"has_many\": True,",
            "                        \"value\": None,",
            "                        \"queryset\": <RelationshipAssociation queryset #2>   # set of destinations for the relationship",
            "                    },",
            "                },",
            "                \"destination\": {",
            "                    (same format as \"source\" dict - relationships that self is the destination of)",
            "                },",
            "                \"peer\": {",
            "                    (same format as \"source\" dict - symmetric relationships that self is involved in)",
            "                },",
            "            }",
            "        \"\"\"",
            "",
            "        relationships_by_side = self.get_relationships(**kwargs)",
            "",
            "        resp = {",
            "            RelationshipSideChoices.SIDE_SOURCE: {},",
            "            RelationshipSideChoices.SIDE_DESTINATION: {},",
            "            RelationshipSideChoices.SIDE_PEER: {},",
            "        }",
            "        for side, relationships in relationships_by_side.items():",
            "            for relationship, queryset in relationships.items():",
            "                peer_side = RelationshipSideChoices.OPPOSITE[side]",
            "",
            "                resp[side][relationship] = {",
            "                    \"label\": relationship.get_label(side),",
            "                    \"value\": None,",
            "                }",
            "                if not relationship.symmetric:",
            "                    resp[side][relationship][\"peer_type\"] = getattr(relationship, f\"{peer_side}_type\")",
            "                else:",
            "                    # Symmetric relationship - source_type == destination_type, so it doesn't matter which we choose",
            "                    resp[side][relationship][\"peer_type\"] = getattr(relationship, \"source_type\")",
            "",
            "                resp[side][relationship][\"has_many\"] = relationship.has_many(peer_side)",
            "",
            "                if resp[side][relationship][\"has_many\"]:",
            "                    resp[side][relationship][\"queryset\"] = queryset",
            "                else:",
            "                    resp[side][relationship][\"url\"] = None",
            "                    association = queryset.first()",
            "                    if not association:",
            "                        continue",
            "",
            "                    peer = association.get_peer(self)",
            "",
            "                    resp[side][relationship][\"value\"] = peer",
            "                    if hasattr(peer, \"get_absolute_url\"):",
            "                        resp[side][relationship][\"url\"] = peer.get_absolute_url()",
            "                    else:",
            "                        logger.warning(\"Peer object %s has no get_absolute_url() method\", peer)",
            "",
            "        return resp",
            "",
            "    def get_relationships_data_basic_fields(self):",
            "        \"\"\"",
            "        Same docstring as get_relationships_data() above except this only returns relationships",
            "        where advanced_ui==False for displaying in the main object detail tab on the object's page",
            "        \"\"\"",
            "        return self.get_relationships_data(advanced_ui=False)",
            "",
            "    def get_relationships_data_advanced_fields(self):",
            "        \"\"\"",
            "        Same docstring as get_relationships_data() above except this only returns relationships",
            "        where advanced_ui==True for displaying in the 'Advanced' tab on the object's page",
            "        \"\"\"",
            "        return self.get_relationships_data(advanced_ui=True)",
            "",
            "    @classmethod",
            "    def required_related_objects_errors(",
            "        cls, output_for=\"ui\", initial_data=None, relationships_key_specified=False, instance=None",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            output_for: either \"ui\" or \"api\" depending on usage",
            "            initial_data: submitted form/serializer data to validate against",
            "            relationships_key_specified: if the \"relationships\" key was provided or not",
            "            instance: an optional model instance to validate against",
            "        Returns:",
            "            List of field error dicts if any are found",
            "        \"\"\"",
            "",
            "        required_relationships = Relationship.objects.get_required_for_model(cls)",
            "        relationships_field_errors = {}",
            "        for relation in required_relationships:",
            "            opposite_side = RelationshipSideChoices.OPPOSITE[relation.required_on]",
            "",
            "            if relation.skip_required(cls, opposite_side):",
            "                continue",
            "",
            "            if relation.has_many(opposite_side):",
            "                num_required_verbose = \"at least one\"",
            "            else:",
            "                num_required_verbose = \"a\"",
            "",
            "            if output_for == \"api\":",
            "                # If this is a model instance and the relationships json data key is missing, check to see if",
            "                # required relationship associations already exist, and continue (ignore validation) if so",
            "                if (",
            "                    getattr(instance, \"present_in_database\", False) is True",
            "                    and initial_data.get(relation, {}).get(opposite_side, {}) == {}",
            "                    and not relationships_key_specified",
            "                ):",
            "                    filter_kwargs = {\"relationship\": relation, f\"{relation.required_on}_id\": instance.pk}",
            "                    if RelationshipAssociation.objects.filter(**filter_kwargs).exists():",
            "                        continue",
            "",
            "            required_model_class = getattr(relation, f\"{opposite_side}_type\").model_class()",
            "            required_model_meta = required_model_class._meta",
            "            cr_field_name = f\"cr_{relation.slug}__{opposite_side}\"",
            "            name_plural = cls._meta.verbose_name_plural",
            "            field_key = relation.slug if output_for == \"api\" else cr_field_name",
            "            field_errors = {field_key: []}",
            "",
            "            if not required_model_class.objects.exists():",
            "                hint = (",
            "                    f\"You need to create {num_required_verbose} {required_model_meta.verbose_name} \"",
            "                    f\"before instantiating a {cls._meta.verbose_name}.\"",
            "                )",
            "",
            "                if output_for == \"ui\":",
            "                    try:",
            "                        add_url = reverse(get_route_for_model(required_model_class, \"add\"))",
            "                        hint = (",
            "                            f\"<a target='_blank' href='{add_url}'>Click here</a> to create \"",
            "                            f\"a {required_model_meta.verbose_name}.\"",
            "                        )",
            "                    except NoReverseMatch:",
            "                        pass",
            "",
            "                elif output_for == \"api\":",
            "                    try:",
            "                        api_post_url = reverse(get_route_for_model(required_model_class, \"list\", api=True))",
            "                        hint = f\"Create a {required_model_meta.verbose_name} by posting to {api_post_url}\"",
            "                    except NoReverseMatch:",
            "                        pass",
            "",
            "                error_message = mark_safe(",
            "                    f\"{name_plural[0].upper()}{name_plural[1:]} require \"",
            "                    f\"{num_required_verbose} {required_model_meta.verbose_name}, but no \"",
            "                    f\"{required_model_meta.verbose_name_plural} exist yet. {hint}\"",
            "                )",
            "                field_errors[field_key].append(error_message)",
            "",
            "            if initial_data is not None:",
            "                supplied_data = []",
            "",
            "                if output_for == \"ui\":",
            "                    supplied_data = initial_data.get(field_key, [])",
            "",
            "                elif output_for == \"api\":",
            "                    supplied_data = initial_data.get(relation, {}).get(opposite_side, {})",
            "",
            "                if not supplied_data:",
            "                    if output_for == \"ui\":",
            "                        field_errors[field_key].append(",
            "                            f\"You need to select {num_required_verbose} {required_model_meta.verbose_name}.\"",
            "                        )",
            "                    elif output_for == \"api\":",
            "                        field_errors[field_key].append(",
            "                            f'You need to specify [\"relationships\"][\"{relation.slug}\"][\"{opposite_side}\"][\"objects\"].'",
            "                        )",
            "",
            "            if len(field_errors[field_key]) > 0:",
            "                relationships_field_errors[field_key] = field_errors[field_key]",
            "",
            "        return relationships_field_errors",
            "",
            "",
            "class RelationshipManager(models.Manager.from_queryset(RestrictedQuerySet)):",
            "    use_in_migrations = True",
            "",
            "    def get_for_model(self, model):",
            "        \"\"\"",
            "        Return all Relationships assigned to the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return (",
            "            self.get_queryset().filter(source_type=content_type),",
            "            self.get_queryset().filter(destination_type=content_type),",
            "        )",
            "",
            "    def get_required_for_model(self, model):",
            "        \"\"\"",
            "        Return a queryset with all required Relationships on the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return self.get_queryset().filter(",
            "            Q(source_type=content_type, required_on=RelationshipRequiredSideChoices.SOURCE_SIDE_REQUIRED)",
            "            | Q(destination_type=content_type, required_on=RelationshipRequiredSideChoices.DESTINATION_SIDE_REQUIRED)",
            "        )",
            "",
            "",
            "class Relationship(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    name = models.CharField(max_length=100, unique=True, help_text=\"Name of the relationship as displayed to users\")",
            "    slug = AutoSlugField(",
            "        populate_from=\"name\",",
            "        slugify_function=slugify_dashes_to_underscores,",
            "        help_text=\"Internal relationship name. Please use underscores rather than dashes in this slug.\",",
            "    )",
            "    description = models.CharField(max_length=200, blank=True)",
            "    type = models.CharField(",
            "        max_length=50,",
            "        choices=RelationshipTypeChoices,",
            "        default=RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "        help_text=\"Cardinality of this relationship\",",
            "    )",
            "    required_on = models.CharField(",
            "        max_length=12,",
            "        choices=RelationshipRequiredSideChoices,",
            "        default=RelationshipRequiredSideChoices.NEITHER_SIDE_REQUIRED,",
            "        help_text=\"Objects on the specified side MUST implement this relationship. \"",
            "        \"Not permitted for symmetric relationships.\",",
            "        blank=True,",
            "    )",
            "",
            "    #",
            "    # Source",
            "    #",
            "    source_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        related_name=\"source_relationships\",",
            "        verbose_name=\"Source Object\",",
            "        limit_choices_to=FeatureQuery(\"relationships\"),",
            "        help_text=\"The source object type to which this relationship applies.\",",
            "    )",
            "    source_label = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"Source Label\",",
            "        help_text=\"Label for related destination objects, as displayed on the source object.\",",
            "    )",
            "    source_hidden = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Hide for source object\",",
            "        help_text=\"Hide this relationship on the source object.\",",
            "    )",
            "    source_filter = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"Filterset filter matching the applicable source objects of the selected type\",",
            "    )",
            "",
            "    #",
            "    # Destination",
            "    #",
            "    destination_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        related_name=\"destination_relationships\",",
            "        verbose_name=\"Destination Object\",",
            "        limit_choices_to=FeatureQuery(\"relationships\"),",
            "        help_text=\"The destination object type to which this relationship applies.\",",
            "    )",
            "    destination_label = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"Destination Label\",",
            "        help_text=\"Label for related source objects, as displayed on the destination object.\",",
            "    )",
            "    destination_hidden = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Hide for destination object\",",
            "        help_text=\"Hide this relationship on the destination object.\",",
            "    )",
            "    destination_filter = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"Filterset filter matching the applicable destination objects of the selected type\",",
            "    )",
            "    advanced_ui = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Move to Advanced tab\",",
            "        help_text=\"Hide this field from the object's primary information tab. \"",
            "        'It will appear in the \"Advanced\" tab instead.',",
            "    )",
            "",
            "    objects = RelationshipManager()",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name.replace(\"_\", \" \")",
            "",
            "    @property",
            "    def symmetric(self):",
            "        return self.type in (",
            "            RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC,",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "        )",
            "",
            "    @property",
            "    def peer_type(self):",
            "        \"\"\"Virtual attribute for symmetric relationships only.\"\"\"",
            "        if self.symmetric:",
            "            return self.source_type",
            "        return None",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:relationship\", args=[self.slug])",
            "",
            "    def get_label(self, side):",
            "        \"\"\"Return the label for a given side, source or destination.",
            "",
            "        If the label is not returned, return the verbose_name_plural of the other object",
            "        \"\"\"",
            "",
            "        if side not in VALID_SIDES:",
            "            raise ValueError(f\"side value can only be: {','.join(VALID_SIDES)}\")",
            "",
            "        # Peer \"side\" implies symmetric relationship, where source and dest are equivalent",
            "        if side == RelationshipSideChoices.SIDE_PEER:",
            "            side = RelationshipSideChoices.SIDE_SOURCE",
            "",
            "        if getattr(self, f\"{side}_label\"):",
            "            return getattr(self, f\"{side}_label\")",
            "",
            "        if side == RelationshipSideChoices.SIDE_SOURCE:",
            "            destination_model = self.destination_type.model_class()",
            "            if not destination_model:  # perhaps a plugin was uninstalled?",
            "                return str(self)",
            "            if self.type in (",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "                RelationshipTypeChoices.TYPE_ONE_TO_MANY,",
            "            ):",
            "                return destination_model._meta.verbose_name_plural",
            "            else:",
            "                return destination_model._meta.verbose_name",
            "",
            "        elif side == RelationshipSideChoices.SIDE_DESTINATION:",
            "            source_model = self.source_type.model_class()",
            "            if not source_model:  # perhaps a plugin was uninstalled?",
            "                return str(self)",
            "            if self.type in (",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "            ):",
            "                return source_model._meta.verbose_name_plural",
            "            else:",
            "                return source_model._meta.verbose_name",
            "",
            "        return None",
            "",
            "    def has_many(self, side):",
            "        \"\"\"Return True if the given side of the relationship can support multiple objects.\"\"\"",
            "",
            "        if side not in VALID_SIDES:",
            "            raise ValueError(f\"side value can only be: {','.join(VALID_SIDES)}\")",
            "",
            "        if self.type in (",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "        ):",
            "            return True",
            "",
            "        if self.type in (RelationshipTypeChoices.TYPE_ONE_TO_ONE, RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC):",
            "            return False",
            "",
            "        # ONE_TO_MANY",
            "        return side == RelationshipSideChoices.SIDE_DESTINATION",
            "",
            "    def to_form_field(self, side):",
            "        \"\"\"",
            "        Return a form field suitable for setting a Relationship's value for an object.",
            "        \"\"\"",
            "",
            "        if side not in VALID_SIDES:",
            "            raise ValueError(f\"side value can only be: {','.join(VALID_SIDES)}\")",
            "",
            "        peer_side = RelationshipSideChoices.OPPOSITE[side]",
            "",
            "        if peer_side != RelationshipSideChoices.SIDE_PEER:",
            "            object_type = getattr(self, f\"{peer_side}_type\")",
            "            filters = getattr(self, f\"{peer_side}_filter\") or {}",
            "        else:",
            "            # Symmetric relationship - source and dest fields are presumed identical, so just use source",
            "            object_type = getattr(self, \"source_type\")",
            "            filters = getattr(self, \"source_filter\") or {}",
            "",
            "        model_class = object_type.model_class()",
            "        if model_class:",
            "            queryset = model_class.objects.all()",
            "        else:  # maybe a relationship to a model that no longer exists, such as a removed plugin?",
            "            queryset = None",
            "",
            "        field_class = None",
            "        if queryset is not None:",
            "            if self.has_many(peer_side):",
            "                field_class = DynamicModelMultipleChoiceField",
            "            else:",
            "                field_class = DynamicModelChoiceField",
            "",
            "            field = field_class(queryset=queryset, query_params=filters)",
            "        else:",
            "            field = forms.MultipleChoiceField(widget=widgets.StaticSelect2Multiple)",
            "",
            "        field.model = self",
            "        field.required = False",
            "        field.label = self.get_label(side)",
            "        if self.description:",
            "            field.help_text = self.description",
            "",
            "        return field",
            "",
            "    def clean(self):",
            "        # Check if source and destination filters are valid",
            "        for side in [\"source\", \"destination\"]:",
            "            if not getattr(self, f\"{side}_filter\"):",
            "                continue",
            "",
            "            filter_ = getattr(self, f\"{side}_filter\")",
            "            side_model = getattr(self, f\"{side}_type\").model_class()",
            "            if not side_model:  # can happen if for example a plugin providing the model was uninstalled",
            "                raise ValidationError({f\"{side}_type\": \"Unable to locate model class\"})",
            "            model_name = side_model._meta.label",
            "            if not isinstance(filter_, dict):",
            "                raise ValidationError({f\"{side}_filter\": f\"Filter for {model_name} must be a dictionary\"})",
            "",
            "            filterset_class = get_filterset_for_model(side_model)",
            "            if not filterset_class:",
            "                raise ValidationError(",
            "                    {",
            "                        f\"{side}_filter\": f\"Filters are not supported for {model_name} object (Unable to find a FilterSet)\"",
            "                    }",
            "                )",
            "            filterset = filterset_class(filter_, side_model.objects.all())",
            "",
            "            error_messages = []",
            "            if filterset.errors:",
            "                for key in filterset.errors:",
            "                    # When settings.STRICT_FILTERING is True, any extraneous filter parameters will result in",
            "                    # filterset.errors[key] = [\"Unknown filter field\"]",
            "                    # This is redundant with our custom (more specific) error message added below from filterset_params",
            "                    # So discard such a message if present.",
            "                    errors_list = [error for error in filterset.errors[key] if \"Unknown filter field\" not in str(error)]",
            "                    if errors_list:",
            "                        error_messages.append(f\"'{key}': \" + \", \".join(errors_list))",
            "",
            "            filterset_params = set(filterset.filters.keys())",
            "            for key in filter_.keys():",
            "                if key not in filterset_params:",
            "                    error_messages.append(f\"'{key}' is not a valid filter parameter for {model_name} object\")",
            "",
            "            if error_messages:",
            "                raise ValidationError({f\"{side}_filter\": error_messages})",
            "",
            "        if self.symmetric:",
            "            # For a symmetric relation, source and destination attributes must be equivalent if specified",
            "            error_messages = {}",
            "            if self.source_type != self.destination_type:",
            "                error_messages[\"destination_type\"] = \"Must match source_type for a symmetric relationship\"",
            "            if self.source_label != self.destination_label:",
            "                if not self.source_label:",
            "                    self.source_label = self.destination_label",
            "                elif not self.destination_label:",
            "                    self.destination_label = self.source_label",
            "                else:",
            "                    error_messages[\"destination_label\"] = \"Must match source_label for a symmetric relationship\"",
            "            if self.source_hidden != self.destination_hidden:",
            "                error_messages[\"destination_hidden\"] = \"Must match source_hidden for a symmetric relationship\"",
            "            if self.source_filter != self.destination_filter:",
            "                if not self.source_filter:",
            "                    self.source_filter = self.destination_filter",
            "                elif not self.destination_filter:",
            "                    self.destination_filter = self.source_filter",
            "                else:",
            "                    error_messages[\"destination_filter\"] = \"Must match source_filter for a symmetric relationship\"",
            "",
            "            # Marking a relationship as required is unsupported for symmetric relationships",
            "            if self.required_on != \"\":",
            "                error_messages[\"required_on\"] = \"Symmetric relationships cannot be marked as required.\"",
            "",
            "            if error_messages:",
            "                raise ValidationError(error_messages)",
            "",
            "        # If the model already exist, ensure that it's not possible to modify the source or destination type",
            "        if self.present_in_database:",
            "            nbr_existing_cras = RelationshipAssociation.objects.filter(relationship=self).count()",
            "",
            "            if nbr_existing_cras and self.__class__.objects.get(pk=self.pk).type != self.type:",
            "                raise ValidationError(",
            "                    \"Not supported to change the type of the relationship when some associations\"",
            "                    \" are present in the database, delete all associations first before modifying the type.\"",
            "                )",
            "",
            "            if nbr_existing_cras and self.__class__.objects.get(pk=self.pk).source_type != self.source_type:",
            "                raise ValidationError(",
            "                    \"Not supported to change the type of the source object when some associations\"",
            "                    \" are present in the database, delete all associations first before modifying the source type.\"",
            "                )",
            "",
            "            elif nbr_existing_cras and self.__class__.objects.get(pk=self.pk).destination_type != self.destination_type:",
            "                raise ValidationError(",
            "                    \"Not supported to change the type of the destination object when some associations\"",
            "                    \" are present in the database, delete all associations first before modifying the destination type.\"",
            "                )",
            "",
            "    def skip_required(self, referenced_instance_or_class, side):",
            "        \"\"\"",
            "        This takes an instance or class and a side and checks if it should",
            "        be skipped or not when validating required relationships.",
            "        It will skip when any of the following conditions are True:",
            "         - a relationship is marked as symmetric",
            "         - if a required model class is None (if it doesn't exist yet -- unimplemented/uninstalled plugins for instance)",
            "",
            "        Args:",
            "            referenced_instance_or_class: model instance or class",
            "            side: side of the relationship being checked",
            "",
            "        Returns: Bool",
            "        \"\"\"",
            "",
            "        # Not enforcing required symmetric relationships",
            "        if self.symmetric:",
            "            return True",
            "",
            "        required_model_class = getattr(self, f\"{RelationshipSideChoices.OPPOSITE[side]}_type\").model_class()",
            "        # Handle the case where required_model_class is None (e.g., relationship to a plugin",
            "        # model for a plugin that's not installed at present):",
            "        if required_model_class is None:",
            "            logger.info(\"Relationship enforcement skipped as required model class doesn't exist yet.\")",
            "            return True",
            "",
            "        return False",
            "",
            "",
            "@extras_features(\"custom_validators\")",
            "class RelationshipAssociation(BaseModel):",
            "    relationship = models.ForeignKey(to=\"extras.Relationship\", on_delete=models.CASCADE, related_name=\"associations\")",
            "",
            "    source_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE, related_name=\"+\")",
            "    source_id = models.UUIDField(db_index=True)",
            "    source = GenericForeignKey(ct_field=\"source_type\", fk_field=\"source_id\")",
            "",
            "    destination_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE, related_name=\"+\")",
            "    destination_id = models.UUIDField(db_index=True)",
            "    destination = GenericForeignKey(ct_field=\"destination_type\", fk_field=\"destination_id\")",
            "",
            "    class Meta:",
            "        unique_together = (",
            "            \"relationship\",",
            "            \"source_type\",",
            "            \"source_id\",",
            "            \"destination_type\",",
            "            \"destination_id\",",
            "        )",
            "",
            "    def __str__(self):",
            "        arrow = \"<->\" if self.relationship.symmetric else \"->\"",
            "        return f\"{self.get_source() or 'unknown'} {arrow} {self.get_destination() or 'unknown'} - {self.relationship}\"",
            "",
            "    def _get_genericforeignkey(self, name):",
            "        \"\"\"",
            "        Backend for get_source and get_destination methods.",
            "",
            "        In the case where we have a RelationshipAssociation to a plugin-provided model, but the plugin is",
            "        not presently installed/enabled, dereferencing the peer GenericForeignKey will throw an AttributeError:",
            "            AttributeError: 'NoneType' object has no attribute '_base_manager'",
            "        because ContentType.model_class() returned None unexpectedly.",
            "",
            "        This method handles that exception and returns None in such a case.",
            "        \"\"\"",
            "        if name not in [\"source\", \"destination\"]:",
            "            raise RuntimeError(f\"Called for unexpected attribute {name}\")",
            "        try:",
            "            return getattr(self, name)",
            "        except AttributeError:",
            "            logger.error(",
            "                \"Unable to locate RelationshipAssociation %s (of type %s). Perhaps a plugin is missing?\",",
            "                name,",
            "                getattr(self, f\"{name}_type\"),",
            "            )",
            "",
            "        return None",
            "",
            "    def get_source(self):",
            "        \"\"\"Accessor for self.source - returns None if the object cannot be located.\"\"\"",
            "        return self._get_genericforeignkey(\"source\")",
            "",
            "    def get_destination(self):",
            "        \"\"\"Accessor for self.destination - returns None if the object cannot be located.\"\"\"",
            "        return self._get_genericforeignkey(\"destination\")",
            "",
            "    def get_peer(self, obj):",
            "        \"\"\"",
            "        Get the object on the opposite side of this RelationshipAssociation from the provided `obj`.",
            "",
            "        If obj is not involved in this RelationshipAssociation, or if the peer object is not locatable, returns None.",
            "        \"\"\"",
            "        if obj == self.get_source():",
            "            return self.get_destination()",
            "        elif obj == self.get_destination():",
            "            return self.get_source()",
            "",
            "        return None",
            "",
            "    def clean(self):",
            "        if self.source_type != self.relationship.source_type:",
            "            raise ValidationError(",
            "                {\"source_type\": f\"source_type has a different value than defined in {self.relationship}\"}",
            "            )",
            "",
            "        if self.destination_type != self.relationship.destination_type:",
            "            raise ValidationError(",
            "                {\"destination_type\": f\"destination_type has a different value than defined in {self.relationship}\"}",
            "            )",
            "",
            "        if self.source_type == self.destination_type and self.source_id == self.destination_id:",
            "            raise ValidationError({\"destination_id\": \"An object cannot form a RelationshipAssociation with itself\"})",
            "",
            "        if self.relationship.symmetric:",
            "            # Check for a \"duplicate\" record that exists with source and destination swapped",
            "            if RelationshipAssociation.objects.filter(",
            "                relationship=self.relationship,",
            "                destination_id=self.source_id,",
            "                source_id=self.destination_id,",
            "            ).exists():",
            "                raise ValidationError(",
            "                    {",
            "                        \"__all__\": (",
            "                            f\"A {self.relationship} association already exists between \"",
            "                            f\"{self.get_source() or self.source_id} and \"",
            "                            f\"{self.get_destination() or self.destination_id}\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "        # Check if a similar relationship association already exists in violation of relationship type cardinality",
            "        if self.relationship.type not in (",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "        ):",
            "            # Either one-to-many or one-to-one, in either case don't allow multiple sources to the same destination",
            "            if (",
            "                RelationshipAssociation.objects.filter(",
            "                    relationship=self.relationship,",
            "                    destination_type=self.destination_type,",
            "                    destination_id=self.destination_id,",
            "                )",
            "                .exclude(pk=self.pk)",
            "                .exists()",
            "            ):",
            "                raise ValidationError(",
            "                    {",
            "                        \"destination\": (",
            "                            f\"Unable to create more than one {self.relationship} association to \"",
            "                            f\"{self.get_destination() or self.destination_id} (destination)\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "            if self.relationship.type in (",
            "                RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "                RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC,",
            "            ):",
            "                # Don't allow multiple destinations from the same source",
            "                if (",
            "                    RelationshipAssociation.objects.filter(",
            "                        relationship=self.relationship,",
            "                        source_type=self.source_type,",
            "                        source_id=self.source_id,",
            "                    )",
            "                    .exclude(pk=self.pk)",
            "                    .exists()",
            "                ):",
            "                    raise ValidationError(",
            "                        {",
            "                            \"source\": (",
            "                                f\"Unable to create more than one {self.relationship} association from \"",
            "                                f\"{self.get_source() or self.source_id} (source)\"",
            "                            )",
            "                        }",
            "                    )",
            "",
            "            if self.relationship.type == RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC:",
            "                # Handle the case where the source and destination fields (which are interchangeable for a symmetric",
            "                # relationship) are swapped around - sneaky!",
            "                if RelationshipAssociation.objects.filter(",
            "                    relationship=self.relationship,",
            "                    destination_id=self.source_id,",
            "                ).exists():",
            "                    raise ValidationError(",
            "                        {",
            "                            \"source\": (",
            "                                f\"Unable to create more than one {self.relationship} association involving \"",
            "                                f\"{self.get_source() or self.source_id} (peer)\"",
            "                            )",
            "                        }",
            "                    )",
            "                if RelationshipAssociation.objects.filter(",
            "                    relationship=self.relationship,",
            "                    source_id=self.destination_id,",
            "                ).exists():",
            "                    raise ValidationError(",
            "                        {",
            "                            \"destination\": (",
            "                                f\"Unable to create more than one {self.relationship} association involving \"",
            "                                f\"{self.get_destination() or self.destination_id} (peer)\"",
            "                            )",
            "                        }",
            "                    )",
            "",
            "        if self.relationship.destination_filter or self.relationship.source_filter:",
            "            self._validate_relationship_filter_restriction()",
            "",
            "    def _validate_relationship_filter_restriction(self):",
            "        \"\"\"Validate relationship association do not violate filter restrictions\"\"\"",
            "        sides = []",
            "",
            "        if self.relationship.destination_filter:",
            "            sides.append(\"destination\")",
            "",
            "        if self.relationship.source_filter:",
            "            sides.append(\"source\")",
            "",
            "        for side_name in sides:",
            "            side = getattr(self, side_name)  # destination / source",
            "            side_filter = getattr(self.relationship, f\"{side_name}_filter\")",
            "",
            "            filterset_class = get_filterset_for_model(side.__class__)",
            "            filterset = filterset_class(side_filter, side.__class__.objects.all())",
            "            queryset = filterset.qs.filter(id=side.id)",
            "",
            "            if queryset.exists() is False:",
            "                raise ValidationError(",
            "                    {side_name: (f\"{side} violates {self.relationship} {side_name}_filter restriction\")}",
            "                )"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from django import forms",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation",
            "from django.core.exceptions import ValidationError",
            "from django.core.serializers.json import DjangoJSONEncoder",
            "from django.db import models",
            "from django.db.models import Q",
            "from django.urls import reverse",
            "from django.urls.exceptions import NoReverseMatch",
            "from django.utils.html import format_html",
            "",
            "from nautobot.core.fields import AutoSlugField",
            "from nautobot.core.models import BaseModel",
            "from nautobot.extras.choices import RelationshipTypeChoices, RelationshipRequiredSideChoices, RelationshipSideChoices",
            "from nautobot.extras.utils import FeatureQuery, extras_features",
            "from nautobot.extras.models import ChangeLoggedModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.utilities.utils import get_filterset_for_model, get_route_for_model, slugify_dashes_to_underscores",
            "from nautobot.utilities.forms import (",
            "    DynamicModelChoiceField,",
            "    DynamicModelMultipleChoiceField,",
            "    widgets,",
            ")",
            "from nautobot.utilities.querysets import RestrictedQuerySet",
            "from nautobot.utilities.templatetags.helpers import bettertitle",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "VALID_SIDES = [item[0] for item in RelationshipSideChoices.CHOICES]",
            "",
            "",
            "class RelationshipModel(models.Model):",
            "    \"\"\"",
            "    Abstract class for any model which may have custom relationships associated with it.",
            "    \"\"\"",
            "",
            "    class Meta:",
            "        abstract = True",
            "",
            "    # Define GenericRelations so that deleting a RelationshipModel instance",
            "    # cascades to deleting any RelationshipAssociations that were using this instance,",
            "    # and also for convenience in looking up the RelationshipModels associated to any given RelationshipAssociation",
            "    source_for_associations = GenericRelation(",
            "        \"extras.RelationshipAssociation\",",
            "        content_type_field=\"source_type\",",
            "        object_id_field=\"source_id\",",
            "        related_query_name=\"source_%(app_label)s_%(class)s\",  # e.g. 'source_dcim_site', 'source_ipam_vlan'",
            "    )",
            "    destination_for_associations = GenericRelation(",
            "        \"extras.RelationshipAssociation\",",
            "        content_type_field=\"destination_type\",",
            "        object_id_field=\"destination_id\",",
            "        related_query_name=\"destination_%(app_label)s_%(class)s\",  # e.g. 'destination_dcim_rack'",
            "    )",
            "",
            "    @property",
            "    def associations(self):",
            "        return list(self.source_for_associations.all()) + list(self.destination_for_associations.all())",
            "",
            "    def get_relationships(self, include_hidden=False, advanced_ui=None):",
            "        \"\"\"",
            "        Return a dictionary of RelationshipAssociation querysets for all custom relationships",
            "",
            "        Returns:",
            "            response {",
            "                \"source\": {",
            "                    <Relationship instance #1>: <RelationshipAssociation queryset #1>,",
            "                    <Relationship instance #2>: <RelationshipAssociation queryset #2>,",
            "                },",
            "                \"destination\": {",
            "                    <Relationship instance #3>: <RelationshipAssociation queryset #3>,",
            "                    <Relationship instance #4>: <RelationshipAssociation queryset #4>,",
            "                },",
            "                \"peer\": {",
            "                    <Relationship instance #5>: <RelationshipAssociation queryset #5>,",
            "                    <Relationship instance #6>: <RelationshipAssociation queryset #6>,",
            "                },",
            "            }",
            "        \"\"\"",
            "        src_relationships, dst_relationships = Relationship.objects.get_for_model(self)",
            "        if advanced_ui is not None:",
            "            src_relationships = src_relationships.filter(advanced_ui=advanced_ui)",
            "            dst_relationships = dst_relationships.filter(advanced_ui=advanced_ui)",
            "        content_type = ContentType.objects.get_for_model(self)",
            "",
            "        sides = {",
            "            RelationshipSideChoices.SIDE_SOURCE: src_relationships,",
            "            RelationshipSideChoices.SIDE_DESTINATION: dst_relationships,",
            "        }",
            "",
            "        resp = {",
            "            RelationshipSideChoices.SIDE_SOURCE: {},",
            "            RelationshipSideChoices.SIDE_DESTINATION: {},",
            "            RelationshipSideChoices.SIDE_PEER: {},",
            "        }",
            "        for side, relationships in sides.items():",
            "            for relationship in relationships:",
            "                if getattr(relationship, f\"{side}_hidden\") and not include_hidden:",
            "                    continue",
            "",
            "                # Determine if the relationship is applicable to this object based on the filter",
            "                # To resolve the filter we are using the FilterSet for the given model",
            "                # If there is no match when we query the primary key of the device along with the filter",
            "                # Then the relationship is not applicable to this object",
            "                if getattr(relationship, f\"{side}_filter\"):",
            "                    filterset = get_filterset_for_model(self._meta.model)",
            "                    if filterset:",
            "                        filter_params = getattr(relationship, f\"{side}_filter\")",
            "                        if not filterset(filter_params, self._meta.model.objects.filter(id=self.id)).qs.exists():",
            "                            continue",
            "",
            "                # Construct the queryset to query all RelationshipAssociation for this object and this relationship",
            "                query_params = {\"relationship\": relationship}",
            "                if not relationship.symmetric:",
            "                    # Query for RelationshipAssociations that this object is on the expected side of",
            "                    query_params[f\"{side}_id\"] = self.pk",
            "                    query_params[f\"{side}_type\"] = content_type",
            "",
            "                    resp[side][relationship] = RelationshipAssociation.objects.filter(**query_params)",
            "                else:",
            "                    # Query for RelationshipAssociations involving this object, regardless of side",
            "                    resp[RelationshipSideChoices.SIDE_PEER][relationship] = RelationshipAssociation.objects.filter(",
            "                        (",
            "                            Q(source_id=self.pk, source_type=content_type)",
            "                            | Q(destination_id=self.pk, destination_type=content_type)",
            "                        ),",
            "                        **query_params,",
            "                    )",
            "",
            "        return resp",
            "",
            "    def get_relationships_data(self, **kwargs):",
            "        \"\"\"",
            "        Return a dictionary of relationships with the label and the value or the queryset for each.",
            "",
            "        Used for rendering relationships in the UI; see nautobot/core/templates/inc/relationships_table_rows.html",
            "",
            "        Returns:",
            "            response {",
            "                \"source\": {",
            "                    <Relationship instance #1>: {   # one-to-one relationship that self is the source of",
            "                        \"label\": \"...\",",
            "                        \"peer_type\": <ContentType>,",
            "                        \"has_many\": False,",
            "                        \"value\": <model instance>,     # single destination for this relationship",
            "                        \"url\": \"...\",",
            "                    },",
            "                    <Relationship instance #2>: {   # one-to-many or many-to-many relationship that self is a source for",
            "                        \"label\": \"...\",",
            "                        \"peer_type\": <ContentType>,",
            "                        \"has_many\": True,",
            "                        \"value\": None,",
            "                        \"queryset\": <RelationshipAssociation queryset #2>   # set of destinations for the relationship",
            "                    },",
            "                },",
            "                \"destination\": {",
            "                    (same format as \"source\" dict - relationships that self is the destination of)",
            "                },",
            "                \"peer\": {",
            "                    (same format as \"source\" dict - symmetric relationships that self is involved in)",
            "                },",
            "            }",
            "        \"\"\"",
            "",
            "        relationships_by_side = self.get_relationships(**kwargs)",
            "",
            "        resp = {",
            "            RelationshipSideChoices.SIDE_SOURCE: {},",
            "            RelationshipSideChoices.SIDE_DESTINATION: {},",
            "            RelationshipSideChoices.SIDE_PEER: {},",
            "        }",
            "        for side, relationships in relationships_by_side.items():",
            "            for relationship, queryset in relationships.items():",
            "                peer_side = RelationshipSideChoices.OPPOSITE[side]",
            "",
            "                resp[side][relationship] = {",
            "                    \"label\": relationship.get_label(side),",
            "                    \"value\": None,",
            "                }",
            "                if not relationship.symmetric:",
            "                    resp[side][relationship][\"peer_type\"] = getattr(relationship, f\"{peer_side}_type\")",
            "                else:",
            "                    # Symmetric relationship - source_type == destination_type, so it doesn't matter which we choose",
            "                    resp[side][relationship][\"peer_type\"] = getattr(relationship, \"source_type\")",
            "",
            "                resp[side][relationship][\"has_many\"] = relationship.has_many(peer_side)",
            "",
            "                if resp[side][relationship][\"has_many\"]:",
            "                    resp[side][relationship][\"queryset\"] = queryset",
            "                else:",
            "                    resp[side][relationship][\"url\"] = None",
            "                    association = queryset.first()",
            "                    if not association:",
            "                        continue",
            "",
            "                    peer = association.get_peer(self)",
            "",
            "                    resp[side][relationship][\"value\"] = peer",
            "                    if hasattr(peer, \"get_absolute_url\"):",
            "                        resp[side][relationship][\"url\"] = peer.get_absolute_url()",
            "                    else:",
            "                        logger.warning(\"Peer object %s has no get_absolute_url() method\", peer)",
            "",
            "        return resp",
            "",
            "    def get_relationships_data_basic_fields(self):",
            "        \"\"\"",
            "        Same docstring as get_relationships_data() above except this only returns relationships",
            "        where advanced_ui==False for displaying in the main object detail tab on the object's page",
            "        \"\"\"",
            "        return self.get_relationships_data(advanced_ui=False)",
            "",
            "    def get_relationships_data_advanced_fields(self):",
            "        \"\"\"",
            "        Same docstring as get_relationships_data() above except this only returns relationships",
            "        where advanced_ui==True for displaying in the 'Advanced' tab on the object's page",
            "        \"\"\"",
            "        return self.get_relationships_data(advanced_ui=True)",
            "",
            "    @classmethod",
            "    def required_related_objects_errors(",
            "        cls, output_for=\"ui\", initial_data=None, relationships_key_specified=False, instance=None",
            "    ):",
            "        \"\"\"",
            "        Args:",
            "            output_for: either \"ui\" or \"api\" depending on usage",
            "            initial_data: submitted form/serializer data to validate against",
            "            relationships_key_specified: if the \"relationships\" key was provided or not",
            "            instance: an optional model instance to validate against",
            "        Returns:",
            "            List of field error dicts if any are found",
            "        \"\"\"",
            "",
            "        required_relationships = Relationship.objects.get_required_for_model(cls)",
            "        relationships_field_errors = {}",
            "        for relation in required_relationships:",
            "            opposite_side = RelationshipSideChoices.OPPOSITE[relation.required_on]",
            "",
            "            if relation.skip_required(cls, opposite_side):",
            "                continue",
            "",
            "            if relation.has_many(opposite_side):",
            "                num_required_verbose = \"at least one\"",
            "            else:",
            "                num_required_verbose = \"a\"",
            "",
            "            if output_for == \"api\":",
            "                # If this is a model instance and the relationships json data key is missing, check to see if",
            "                # required relationship associations already exist, and continue (ignore validation) if so",
            "                if (",
            "                    getattr(instance, \"present_in_database\", False) is True",
            "                    and initial_data.get(relation, {}).get(opposite_side, {}) == {}",
            "                    and not relationships_key_specified",
            "                ):",
            "                    filter_kwargs = {\"relationship\": relation, f\"{relation.required_on}_id\": instance.pk}",
            "                    if RelationshipAssociation.objects.filter(**filter_kwargs).exists():",
            "                        continue",
            "",
            "            required_model_class = getattr(relation, f\"{opposite_side}_type\").model_class()",
            "            required_model_meta = required_model_class._meta",
            "            cr_field_name = f\"cr_{relation.slug}__{opposite_side}\"",
            "            name_plural = cls._meta.verbose_name_plural",
            "            field_key = relation.slug if output_for == \"api\" else cr_field_name",
            "            field_errors = {field_key: []}",
            "",
            "            if not required_model_class.objects.exists():",
            "                hint = (",
            "                    f\"You need to create {num_required_verbose} {required_model_meta.verbose_name} \"",
            "                    f\"before instantiating a {cls._meta.verbose_name}.\"",
            "                )",
            "",
            "                if output_for == \"ui\":",
            "                    try:",
            "                        add_url = reverse(get_route_for_model(required_model_class, \"add\"))",
            "                        hint = format_html(",
            "                            '<a target=\"_blank\" href=\"{}\">Click here</a> to create a {}.',",
            "                            add_url,",
            "                            required_model_meta.verbose_name,",
            "                        )",
            "                    except NoReverseMatch:",
            "                        pass",
            "",
            "                elif output_for == \"api\":",
            "                    try:",
            "                        api_post_url = reverse(get_route_for_model(required_model_class, \"list\", api=True))",
            "                        hint = f\"Create a {required_model_meta.verbose_name} by posting to {api_post_url}\"",
            "                    except NoReverseMatch:",
            "                        pass",
            "",
            "                error_message = format_html(",
            "                    \"{} require {} {}, but no {} exist yet. \",",
            "                    bettertitle(name_plural),",
            "                    num_required_verbose,",
            "                    required_model_meta.verbose_name,",
            "                    required_model_meta.verbose_name_plural,",
            "                )",
            "                error_message += hint",
            "                field_errors[field_key].append(error_message)",
            "",
            "            if initial_data is not None:",
            "                supplied_data = []",
            "",
            "                if output_for == \"ui\":",
            "                    supplied_data = initial_data.get(field_key, [])",
            "",
            "                elif output_for == \"api\":",
            "                    supplied_data = initial_data.get(relation, {}).get(opposite_side, {})",
            "",
            "                if not supplied_data:",
            "                    if output_for == \"ui\":",
            "                        field_errors[field_key].append(",
            "                            f\"You need to select {num_required_verbose} {required_model_meta.verbose_name}.\"",
            "                        )",
            "                    elif output_for == \"api\":",
            "                        field_errors[field_key].append(",
            "                            f'You need to specify [\"relationships\"][\"{relation.slug}\"][\"{opposite_side}\"][\"objects\"].'",
            "                        )",
            "",
            "            if len(field_errors[field_key]) > 0:",
            "                relationships_field_errors[field_key] = field_errors[field_key]",
            "",
            "        return relationships_field_errors",
            "",
            "",
            "class RelationshipManager(models.Manager.from_queryset(RestrictedQuerySet)):",
            "    use_in_migrations = True",
            "",
            "    def get_for_model(self, model):",
            "        \"\"\"",
            "        Return all Relationships assigned to the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return (",
            "            self.get_queryset().filter(source_type=content_type),",
            "            self.get_queryset().filter(destination_type=content_type),",
            "        )",
            "",
            "    def get_required_for_model(self, model):",
            "        \"\"\"",
            "        Return a queryset with all required Relationships on the given model.",
            "        \"\"\"",
            "        content_type = ContentType.objects.get_for_model(model._meta.concrete_model)",
            "        return self.get_queryset().filter(",
            "            Q(source_type=content_type, required_on=RelationshipRequiredSideChoices.SOURCE_SIDE_REQUIRED)",
            "            | Q(destination_type=content_type, required_on=RelationshipRequiredSideChoices.DESTINATION_SIDE_REQUIRED)",
            "        )",
            "",
            "",
            "class Relationship(BaseModel, ChangeLoggedModel, NotesMixin):",
            "    name = models.CharField(max_length=100, unique=True, help_text=\"Name of the relationship as displayed to users\")",
            "    slug = AutoSlugField(",
            "        populate_from=\"name\",",
            "        slugify_function=slugify_dashes_to_underscores,",
            "        help_text=\"Internal relationship name. Please use underscores rather than dashes in this slug.\",",
            "    )",
            "    description = models.CharField(max_length=200, blank=True)",
            "    type = models.CharField(",
            "        max_length=50,",
            "        choices=RelationshipTypeChoices,",
            "        default=RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "        help_text=\"Cardinality of this relationship\",",
            "    )",
            "    required_on = models.CharField(",
            "        max_length=12,",
            "        choices=RelationshipRequiredSideChoices,",
            "        default=RelationshipRequiredSideChoices.NEITHER_SIDE_REQUIRED,",
            "        help_text=\"Objects on the specified side MUST implement this relationship. \"",
            "        \"Not permitted for symmetric relationships.\",",
            "        blank=True,",
            "    )",
            "",
            "    #",
            "    # Source",
            "    #",
            "    source_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        related_name=\"source_relationships\",",
            "        verbose_name=\"Source Object\",",
            "        limit_choices_to=FeatureQuery(\"relationships\"),",
            "        help_text=\"The source object type to which this relationship applies.\",",
            "    )",
            "    source_label = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"Source Label\",",
            "        help_text=\"Label for related destination objects, as displayed on the source object.\",",
            "    )",
            "    source_hidden = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Hide for source object\",",
            "        help_text=\"Hide this relationship on the source object.\",",
            "    )",
            "    source_filter = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"Filterset filter matching the applicable source objects of the selected type\",",
            "    )",
            "",
            "    #",
            "    # Destination",
            "    #",
            "    destination_type = models.ForeignKey(",
            "        to=ContentType,",
            "        on_delete=models.CASCADE,",
            "        related_name=\"destination_relationships\",",
            "        verbose_name=\"Destination Object\",",
            "        limit_choices_to=FeatureQuery(\"relationships\"),",
            "        help_text=\"The destination object type to which this relationship applies.\",",
            "    )",
            "    destination_label = models.CharField(",
            "        max_length=50,",
            "        blank=True,",
            "        verbose_name=\"Destination Label\",",
            "        help_text=\"Label for related source objects, as displayed on the destination object.\",",
            "    )",
            "    destination_hidden = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Hide for destination object\",",
            "        help_text=\"Hide this relationship on the destination object.\",",
            "    )",
            "    destination_filter = models.JSONField(",
            "        encoder=DjangoJSONEncoder,",
            "        blank=True,",
            "        null=True,",
            "        help_text=\"Filterset filter matching the applicable destination objects of the selected type\",",
            "    )",
            "    advanced_ui = models.BooleanField(",
            "        default=False,",
            "        verbose_name=\"Move to Advanced tab\",",
            "        help_text=\"Hide this field from the object's primary information tab. \"",
            "        'It will appear in the \"Advanced\" tab instead.',",
            "    )",
            "",
            "    objects = RelationshipManager()",
            "",
            "    class Meta:",
            "        ordering = [\"name\"]",
            "",
            "    def __str__(self):",
            "        return self.name.replace(\"_\", \" \")",
            "",
            "    @property",
            "    def symmetric(self):",
            "        return self.type in (",
            "            RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC,",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "        )",
            "",
            "    @property",
            "    def peer_type(self):",
            "        \"\"\"Virtual attribute for symmetric relationships only.\"\"\"",
            "        if self.symmetric:",
            "            return self.source_type",
            "        return None",
            "",
            "    def get_absolute_url(self):",
            "        return reverse(\"extras:relationship\", args=[self.slug])",
            "",
            "    def get_label(self, side):",
            "        \"\"\"Return the label for a given side, source or destination.",
            "",
            "        If the label is not returned, return the verbose_name_plural of the other object",
            "        \"\"\"",
            "",
            "        if side not in VALID_SIDES:",
            "            raise ValueError(f\"side value can only be: {','.join(VALID_SIDES)}\")",
            "",
            "        # Peer \"side\" implies symmetric relationship, where source and dest are equivalent",
            "        if side == RelationshipSideChoices.SIDE_PEER:",
            "            side = RelationshipSideChoices.SIDE_SOURCE",
            "",
            "        if getattr(self, f\"{side}_label\"):",
            "            return getattr(self, f\"{side}_label\")",
            "",
            "        if side == RelationshipSideChoices.SIDE_SOURCE:",
            "            destination_model = self.destination_type.model_class()",
            "            if not destination_model:  # perhaps a plugin was uninstalled?",
            "                return str(self)",
            "            if self.type in (",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "                RelationshipTypeChoices.TYPE_ONE_TO_MANY,",
            "            ):",
            "                return destination_model._meta.verbose_name_plural",
            "            else:",
            "                return destination_model._meta.verbose_name",
            "",
            "        elif side == RelationshipSideChoices.SIDE_DESTINATION:",
            "            source_model = self.source_type.model_class()",
            "            if not source_model:  # perhaps a plugin was uninstalled?",
            "                return str(self)",
            "            if self.type in (",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "                RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "            ):",
            "                return source_model._meta.verbose_name_plural",
            "            else:",
            "                return source_model._meta.verbose_name",
            "",
            "        return None",
            "",
            "    def has_many(self, side):",
            "        \"\"\"Return True if the given side of the relationship can support multiple objects.\"\"\"",
            "",
            "        if side not in VALID_SIDES:",
            "            raise ValueError(f\"side value can only be: {','.join(VALID_SIDES)}\")",
            "",
            "        if self.type in (",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "        ):",
            "            return True",
            "",
            "        if self.type in (RelationshipTypeChoices.TYPE_ONE_TO_ONE, RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC):",
            "            return False",
            "",
            "        # ONE_TO_MANY",
            "        return side == RelationshipSideChoices.SIDE_DESTINATION",
            "",
            "    def to_form_field(self, side):",
            "        \"\"\"",
            "        Return a form field suitable for setting a Relationship's value for an object.",
            "        \"\"\"",
            "",
            "        if side not in VALID_SIDES:",
            "            raise ValueError(f\"side value can only be: {','.join(VALID_SIDES)}\")",
            "",
            "        peer_side = RelationshipSideChoices.OPPOSITE[side]",
            "",
            "        if peer_side != RelationshipSideChoices.SIDE_PEER:",
            "            object_type = getattr(self, f\"{peer_side}_type\")",
            "            filters = getattr(self, f\"{peer_side}_filter\") or {}",
            "        else:",
            "            # Symmetric relationship - source and dest fields are presumed identical, so just use source",
            "            object_type = getattr(self, \"source_type\")",
            "            filters = getattr(self, \"source_filter\") or {}",
            "",
            "        model_class = object_type.model_class()",
            "        if model_class:",
            "            queryset = model_class.objects.all()",
            "        else:  # maybe a relationship to a model that no longer exists, such as a removed plugin?",
            "            queryset = None",
            "",
            "        field_class = None",
            "        if queryset is not None:",
            "            if self.has_many(peer_side):",
            "                field_class = DynamicModelMultipleChoiceField",
            "            else:",
            "                field_class = DynamicModelChoiceField",
            "",
            "            field = field_class(queryset=queryset, query_params=filters)",
            "        else:",
            "            field = forms.MultipleChoiceField(widget=widgets.StaticSelect2Multiple)",
            "",
            "        field.model = self",
            "        field.required = False",
            "        field.label = self.get_label(side)",
            "        if self.description:",
            "            field.help_text = self.description",
            "",
            "        return field",
            "",
            "    def clean(self):",
            "        # Check if source and destination filters are valid",
            "        for side in [\"source\", \"destination\"]:",
            "            if not getattr(self, f\"{side}_filter\"):",
            "                continue",
            "",
            "            filter_ = getattr(self, f\"{side}_filter\")",
            "            side_model = getattr(self, f\"{side}_type\").model_class()",
            "            if not side_model:  # can happen if for example a plugin providing the model was uninstalled",
            "                raise ValidationError({f\"{side}_type\": \"Unable to locate model class\"})",
            "            model_name = side_model._meta.label",
            "            if not isinstance(filter_, dict):",
            "                raise ValidationError({f\"{side}_filter\": f\"Filter for {model_name} must be a dictionary\"})",
            "",
            "            filterset_class = get_filterset_for_model(side_model)",
            "            if not filterset_class:",
            "                raise ValidationError(",
            "                    {",
            "                        f\"{side}_filter\": f\"Filters are not supported for {model_name} object (Unable to find a FilterSet)\"",
            "                    }",
            "                )",
            "            filterset = filterset_class(filter_, side_model.objects.all())",
            "",
            "            error_messages = []",
            "            if filterset.errors:",
            "                for key in filterset.errors:",
            "                    # When settings.STRICT_FILTERING is True, any extraneous filter parameters will result in",
            "                    # filterset.errors[key] = [\"Unknown filter field\"]",
            "                    # This is redundant with our custom (more specific) error message added below from filterset_params",
            "                    # So discard such a message if present.",
            "                    errors_list = [error for error in filterset.errors[key] if \"Unknown filter field\" not in str(error)]",
            "                    if errors_list:",
            "                        error_messages.append(f\"'{key}': \" + \", \".join(errors_list))",
            "",
            "            filterset_params = set(filterset.filters.keys())",
            "            for key in filter_.keys():",
            "                if key not in filterset_params:",
            "                    error_messages.append(f\"'{key}' is not a valid filter parameter for {model_name} object\")",
            "",
            "            if error_messages:",
            "                raise ValidationError({f\"{side}_filter\": error_messages})",
            "",
            "        if self.symmetric:",
            "            # For a symmetric relation, source and destination attributes must be equivalent if specified",
            "            error_messages = {}",
            "            if self.source_type != self.destination_type:",
            "                error_messages[\"destination_type\"] = \"Must match source_type for a symmetric relationship\"",
            "            if self.source_label != self.destination_label:",
            "                if not self.source_label:",
            "                    self.source_label = self.destination_label",
            "                elif not self.destination_label:",
            "                    self.destination_label = self.source_label",
            "                else:",
            "                    error_messages[\"destination_label\"] = \"Must match source_label for a symmetric relationship\"",
            "            if self.source_hidden != self.destination_hidden:",
            "                error_messages[\"destination_hidden\"] = \"Must match source_hidden for a symmetric relationship\"",
            "            if self.source_filter != self.destination_filter:",
            "                if not self.source_filter:",
            "                    self.source_filter = self.destination_filter",
            "                elif not self.destination_filter:",
            "                    self.destination_filter = self.source_filter",
            "                else:",
            "                    error_messages[\"destination_filter\"] = \"Must match source_filter for a symmetric relationship\"",
            "",
            "            # Marking a relationship as required is unsupported for symmetric relationships",
            "            if self.required_on != \"\":",
            "                error_messages[\"required_on\"] = \"Symmetric relationships cannot be marked as required.\"",
            "",
            "            if error_messages:",
            "                raise ValidationError(error_messages)",
            "",
            "        # If the model already exist, ensure that it's not possible to modify the source or destination type",
            "        if self.present_in_database:",
            "            nbr_existing_cras = RelationshipAssociation.objects.filter(relationship=self).count()",
            "",
            "            if nbr_existing_cras and self.__class__.objects.get(pk=self.pk).type != self.type:",
            "                raise ValidationError(",
            "                    \"Not supported to change the type of the relationship when some associations\"",
            "                    \" are present in the database, delete all associations first before modifying the type.\"",
            "                )",
            "",
            "            if nbr_existing_cras and self.__class__.objects.get(pk=self.pk).source_type != self.source_type:",
            "                raise ValidationError(",
            "                    \"Not supported to change the type of the source object when some associations\"",
            "                    \" are present in the database, delete all associations first before modifying the source type.\"",
            "                )",
            "",
            "            elif nbr_existing_cras and self.__class__.objects.get(pk=self.pk).destination_type != self.destination_type:",
            "                raise ValidationError(",
            "                    \"Not supported to change the type of the destination object when some associations\"",
            "                    \" are present in the database, delete all associations first before modifying the destination type.\"",
            "                )",
            "",
            "    def skip_required(self, referenced_instance_or_class, side):",
            "        \"\"\"",
            "        This takes an instance or class and a side and checks if it should",
            "        be skipped or not when validating required relationships.",
            "        It will skip when any of the following conditions are True:",
            "         - a relationship is marked as symmetric",
            "         - if a required model class is None (if it doesn't exist yet -- unimplemented/uninstalled plugins for instance)",
            "",
            "        Args:",
            "            referenced_instance_or_class: model instance or class",
            "            side: side of the relationship being checked",
            "",
            "        Returns: Bool",
            "        \"\"\"",
            "",
            "        # Not enforcing required symmetric relationships",
            "        if self.symmetric:",
            "            return True",
            "",
            "        required_model_class = getattr(self, f\"{RelationshipSideChoices.OPPOSITE[side]}_type\").model_class()",
            "        # Handle the case where required_model_class is None (e.g., relationship to a plugin",
            "        # model for a plugin that's not installed at present):",
            "        if required_model_class is None:",
            "            logger.info(\"Relationship enforcement skipped as required model class doesn't exist yet.\")",
            "            return True",
            "",
            "        return False",
            "",
            "",
            "@extras_features(\"custom_validators\")",
            "class RelationshipAssociation(BaseModel):",
            "    relationship = models.ForeignKey(to=\"extras.Relationship\", on_delete=models.CASCADE, related_name=\"associations\")",
            "",
            "    source_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE, related_name=\"+\")",
            "    source_id = models.UUIDField(db_index=True)",
            "    source = GenericForeignKey(ct_field=\"source_type\", fk_field=\"source_id\")",
            "",
            "    destination_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE, related_name=\"+\")",
            "    destination_id = models.UUIDField(db_index=True)",
            "    destination = GenericForeignKey(ct_field=\"destination_type\", fk_field=\"destination_id\")",
            "",
            "    class Meta:",
            "        unique_together = (",
            "            \"relationship\",",
            "            \"source_type\",",
            "            \"source_id\",",
            "            \"destination_type\",",
            "            \"destination_id\",",
            "        )",
            "",
            "    def __str__(self):",
            "        arrow = \"<->\" if self.relationship.symmetric else \"->\"",
            "        return f\"{self.get_source() or 'unknown'} {arrow} {self.get_destination() or 'unknown'} - {self.relationship}\"",
            "",
            "    def _get_genericforeignkey(self, name):",
            "        \"\"\"",
            "        Backend for get_source and get_destination methods.",
            "",
            "        In the case where we have a RelationshipAssociation to a plugin-provided model, but the plugin is",
            "        not presently installed/enabled, dereferencing the peer GenericForeignKey will throw an AttributeError:",
            "            AttributeError: 'NoneType' object has no attribute '_base_manager'",
            "        because ContentType.model_class() returned None unexpectedly.",
            "",
            "        This method handles that exception and returns None in such a case.",
            "        \"\"\"",
            "        if name not in [\"source\", \"destination\"]:",
            "            raise RuntimeError(f\"Called for unexpected attribute {name}\")",
            "        try:",
            "            return getattr(self, name)",
            "        except AttributeError:",
            "            logger.error(",
            "                \"Unable to locate RelationshipAssociation %s (of type %s). Perhaps a plugin is missing?\",",
            "                name,",
            "                getattr(self, f\"{name}_type\"),",
            "            )",
            "",
            "        return None",
            "",
            "    def get_source(self):",
            "        \"\"\"Accessor for self.source - returns None if the object cannot be located.\"\"\"",
            "        return self._get_genericforeignkey(\"source\")",
            "",
            "    def get_destination(self):",
            "        \"\"\"Accessor for self.destination - returns None if the object cannot be located.\"\"\"",
            "        return self._get_genericforeignkey(\"destination\")",
            "",
            "    def get_peer(self, obj):",
            "        \"\"\"",
            "        Get the object on the opposite side of this RelationshipAssociation from the provided `obj`.",
            "",
            "        If obj is not involved in this RelationshipAssociation, or if the peer object is not locatable, returns None.",
            "        \"\"\"",
            "        if obj == self.get_source():",
            "            return self.get_destination()",
            "        elif obj == self.get_destination():",
            "            return self.get_source()",
            "",
            "        return None",
            "",
            "    def clean(self):",
            "        if self.source_type != self.relationship.source_type:",
            "            raise ValidationError(",
            "                {\"source_type\": f\"source_type has a different value than defined in {self.relationship}\"}",
            "            )",
            "",
            "        if self.destination_type != self.relationship.destination_type:",
            "            raise ValidationError(",
            "                {\"destination_type\": f\"destination_type has a different value than defined in {self.relationship}\"}",
            "            )",
            "",
            "        if self.source_type == self.destination_type and self.source_id == self.destination_id:",
            "            raise ValidationError({\"destination_id\": \"An object cannot form a RelationshipAssociation with itself\"})",
            "",
            "        if self.relationship.symmetric:",
            "            # Check for a \"duplicate\" record that exists with source and destination swapped",
            "            if RelationshipAssociation.objects.filter(",
            "                relationship=self.relationship,",
            "                destination_id=self.source_id,",
            "                source_id=self.destination_id,",
            "            ).exists():",
            "                raise ValidationError(",
            "                    {",
            "                        \"__all__\": (",
            "                            f\"A {self.relationship} association already exists between \"",
            "                            f\"{self.get_source() or self.source_id} and \"",
            "                            f\"{self.get_destination() or self.destination_id}\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "        # Check if a similar relationship association already exists in violation of relationship type cardinality",
            "        if self.relationship.type not in (",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY,",
            "            RelationshipTypeChoices.TYPE_MANY_TO_MANY_SYMMETRIC,",
            "        ):",
            "            # Either one-to-many or one-to-one, in either case don't allow multiple sources to the same destination",
            "            if (",
            "                RelationshipAssociation.objects.filter(",
            "                    relationship=self.relationship,",
            "                    destination_type=self.destination_type,",
            "                    destination_id=self.destination_id,",
            "                )",
            "                .exclude(pk=self.pk)",
            "                .exists()",
            "            ):",
            "                raise ValidationError(",
            "                    {",
            "                        \"destination\": (",
            "                            f\"Unable to create more than one {self.relationship} association to \"",
            "                            f\"{self.get_destination() or self.destination_id} (destination)\"",
            "                        )",
            "                    }",
            "                )",
            "",
            "            if self.relationship.type in (",
            "                RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "                RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC,",
            "            ):",
            "                # Don't allow multiple destinations from the same source",
            "                if (",
            "                    RelationshipAssociation.objects.filter(",
            "                        relationship=self.relationship,",
            "                        source_type=self.source_type,",
            "                        source_id=self.source_id,",
            "                    )",
            "                    .exclude(pk=self.pk)",
            "                    .exists()",
            "                ):",
            "                    raise ValidationError(",
            "                        {",
            "                            \"source\": (",
            "                                f\"Unable to create more than one {self.relationship} association from \"",
            "                                f\"{self.get_source() or self.source_id} (source)\"",
            "                            )",
            "                        }",
            "                    )",
            "",
            "            if self.relationship.type == RelationshipTypeChoices.TYPE_ONE_TO_ONE_SYMMETRIC:",
            "                # Handle the case where the source and destination fields (which are interchangeable for a symmetric",
            "                # relationship) are swapped around - sneaky!",
            "                if RelationshipAssociation.objects.filter(",
            "                    relationship=self.relationship,",
            "                    destination_id=self.source_id,",
            "                ).exists():",
            "                    raise ValidationError(",
            "                        {",
            "                            \"source\": (",
            "                                f\"Unable to create more than one {self.relationship} association involving \"",
            "                                f\"{self.get_source() or self.source_id} (peer)\"",
            "                            )",
            "                        }",
            "                    )",
            "                if RelationshipAssociation.objects.filter(",
            "                    relationship=self.relationship,",
            "                    source_id=self.destination_id,",
            "                ).exists():",
            "                    raise ValidationError(",
            "                        {",
            "                            \"destination\": (",
            "                                f\"Unable to create more than one {self.relationship} association involving \"",
            "                                f\"{self.get_destination() or self.destination_id} (peer)\"",
            "                            )",
            "                        }",
            "                    )",
            "",
            "        if self.relationship.destination_filter or self.relationship.source_filter:",
            "            self._validate_relationship_filter_restriction()",
            "",
            "    def _validate_relationship_filter_restriction(self):",
            "        \"\"\"Validate relationship association do not violate filter restrictions\"\"\"",
            "        sides = []",
            "",
            "        if self.relationship.destination_filter:",
            "            sides.append(\"destination\")",
            "",
            "        if self.relationship.source_filter:",
            "            sides.append(\"source\")",
            "",
            "        for side_name in sides:",
            "            side = getattr(self, side_name)  # destination / source",
            "            side_filter = getattr(self.relationship, f\"{side_name}_filter\")",
            "",
            "            filterset_class = get_filterset_for_model(side.__class__)",
            "            filterset = filterset_class(side_filter, side.__class__.objects.all())",
            "            queryset = filterset.qs.filter(id=side.id)",
            "",
            "            if queryset.exists() is False:",
            "                raise ValidationError(",
            "                    {side_name: (f\"{side} violates {self.relationship} {side_name}_filter restriction\")}",
            "                )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "12": [],
            "278": [
                "RelationshipModel",
                "required_related_objects_errors"
            ],
            "279": [
                "RelationshipModel",
                "required_related_objects_errors"
            ],
            "280": [
                "RelationshipModel",
                "required_related_objects_errors"
            ],
            "292": [
                "RelationshipModel",
                "required_related_objects_errors"
            ],
            "293": [
                "RelationshipModel",
                "required_related_objects_errors"
            ],
            "294": [
                "RelationshipModel",
                "required_related_objects_errors"
            ],
            "295": [
                "RelationshipModel",
                "required_related_objects_errors"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/tables.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import django_tables2 as tables"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from django.conf import settings"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.utils.html import format_html"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django_tables2.utils import Accessor"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from jsonschema.exceptions import ValidationError as JSONSchemaValidationError"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     def render_description(self, record):"
            },
            "9": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         if record.description:"
            },
            "10": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return mark_safe(render_markdown(record.description))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+            return render_markdown(record.description)"
            },
            "12": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         return self.default"
            },
            "13": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 260,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import django_tables2 as tables",
            "from django.conf import settings",
            "from django.utils.html import format_html",
            "from django.utils.safestring import mark_safe",
            "from django_tables2.utils import Accessor",
            "from jsonschema.exceptions import ValidationError as JSONSchemaValidationError",
            "",
            "from nautobot.utilities.tables import (",
            "    BaseTable,",
            "    BooleanColumn,",
            "    ButtonsColumn,",
            "    ChoiceFieldColumn,",
            "    ColorColumn,",
            "    ColoredLabelColumn,",
            "    ContentTypesColumn,",
            "    TagColumn,",
            "    ToggleColumn,",
            ")",
            "from nautobot.utilities.templatetags.helpers import render_boolean, render_markdown",
            "from .choices import LogLevelChoices",
            "from .models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    Job as JobModel,",
            "    JobButton,",
            "    JobHook,",
            "    JobResult,",
            "    JobLogEntry,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Webhook,",
            ")",
            "from .registry import registry",
            "",
            "",
            "TAGGED_ITEM = \"\"\"",
            "{% if value.get_absolute_url %}",
            "    <a href=\"{{ value.get_absolute_url }}\">{{ value }}</a>",
            "{% else %}",
            "    {{ value }}",
            "{% endif %}",
            "\"\"\"",
            "",
            "GITREPOSITORY_PROVIDES = \"\"\"",
            "<span class=\"text-nowrap\">",
            "{% for entry in datasource_contents %}",
            "<span style=\"display: inline-block\" title=\"{{ entry.name|title }}\"",
            "class=\"label label-{% if entry.content_identifier in record.provided_contents %}success{% else %}default{% endif %}\">",
            "<i class=\"mdi {{ entry.icon }}\"></i></span>",
            "{% endfor %}",
            "</span>",
            "\"\"\"",
            "",
            "GITREPOSITORY_BUTTONS = \"\"\"",
            "<button data-url=\"{% url 'extras:gitrepository_sync' slug=record.slug %}\" type=\"submit\" class=\"btn btn-primary btn-xs sync-repository\" title=\"Sync\" {% if not perms.extras.change_gitrepository %}disabled=\"disabled\"{% endif %}><i class=\"mdi mdi-source-branch-sync\" aria-hidden=\"true\"></i></button>",
            "\"\"\"",
            "",
            "JOB_BUTTONS = \"\"\"",
            "<a href=\"{% url 'extras:job_run' slug=record.slug %}\" class=\"btn btn-primary btn-xs\" title=\"Run/Schedule\" {% if not perms.extras.run_job or not record.runnable %}disabled=\"disabled\"{% endif %}><i class=\"mdi mdi-play\" aria-hidden=\"true\"></i></a>",
            "\"\"\"",
            "",
            "OBJECTCHANGE_OBJECT = \"\"\"",
            "{% if record.changed_object and record.changed_object.get_absolute_url %}",
            "    <a href=\"{{ record.changed_object.get_absolute_url }}\">{{ record.object_repr }}</a>",
            "{% else %}",
            "    {{ record.object_repr }}",
            "{% endif %}",
            "\"\"\"",
            "",
            "OBJECTCHANGE_REQUEST_ID = \"\"\"",
            "<a href=\"{% url 'extras:objectchange_list' %}?request_id={{ value }}\">{{ value }}</a>",
            "\"\"\"",
            "",
            "# TODO: Webhook content_types in table order_by",
            "WEBHOOK_CONTENT_TYPES = \"\"\"",
            "{{ value.all|join:\", \"|truncatewords:15 }}",
            "\"\"\"",
            "",
            "SCHEDULED_JOB_APPROVAL_QUEUE_BUTTONS = \"\"\"",
            "<button type=\"button\"",
            "        onClick=\"handleDetailPostAction('{% url 'extras:scheduledjob_approval_request_view' pk=record.pk %}', '_dry_run')\"",
            "        title=\"Dry Run\"",
            "        class=\"btn btn-primary btn-xs\"{% if not perms.extras.run_job %} disabled=\"disabled\"{% endif %}>",
            "    <i class=\"mdi mdi-play\"></i>",
            "</button>",
            "<button type=\"button\"",
            "        onClick=\"handleDetailPostAction('{% url 'extras:scheduledjob_approval_request_view' pk=record.pk %}', '_approve')\"",
            "        title=\"Approve\"",
            "        class=\"btn btn-success btn-xs\"{% if not perms.extras.run_job %} disabled=\"disabled\"{% endif %}>",
            "    <i class=\"mdi mdi-check\"></i>",
            "</button>",
            "<button type=\"button\"",
            "        onClick=\"handleDetailPostAction('{% url 'extras:scheduledjob_approval_request_view' pk=record.pk %}', '_deny')\"",
            "        title=\"Deny\"",
            "        class=\"btn btn-danger btn-xs\"{% if not perms.extras.run_job %} disabled=\"disabled\"{% endif %}>",
            "    <i class=\"mdi mdi-close\"></i>",
            "</button>",
            "\"\"\"",
            "",
            "",
            "class ComputedFieldTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    label = tables.Column(linkify=True)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ComputedField",
            "        fields = (",
            "            \"pk\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"content_type\",",
            "            \"description\",",
            "            \"weight\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"content_type\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "class ConfigContextTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    owner = tables.LinkColumn()",
            "    is_active = BooleanColumn(verbose_name=\"Active\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ConfigContext",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"owner\",",
            "            \"weight\",",
            "            \"is_active\",",
            "            \"description\",",
            "            \"regions\",",
            "            \"sites\",",
            "            \"roles\",",
            "            \"platforms\",",
            "            \"cluster_groups\",",
            "            \"clusters\",",
            "            \"tenant_groups\",",
            "            \"tenants\",",
            "            \"dynamic_groups\",",
            "        )",
            "        default_columns = (\"pk\", \"name\", \"weight\", \"is_active\", \"description\")",
            "",
            "",
            "class ConfigContextSchemaTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    owner = tables.LinkColumn()",
            "    actions = ButtonsColumn(ConfigContextSchema, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ConfigContextSchema",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"owner\",",
            "            \"description\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (\"pk\", \"name\", \"description\", \"actions\")",
            "",
            "",
            "class ConfigContextSchemaValidationStateColumn(tables.Column):",
            "    \"\"\"",
            "    Custom column that validates an instance's context data against a config context schema",
            "    \"\"\"",
            "",
            "    def __init__(self, validator, data_field, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.validator = validator",
            "        self.data_field = data_field",
            "",
            "    def render(self, record):",
            "        data = getattr(record, self.data_field)",
            "        try:",
            "            self.validator.validate(data)",
            "        except JSONSchemaValidationError as e:",
            "            # Return a red x (like a boolean column) and the validation error message",
            "            return render_boolean(False) + format_html('<span class=\"text-danger\">{}</span>', e.message)",
            "",
            "        # Return a green check (like a boolean column)",
            "        return render_boolean(True)",
            "",
            "",
            "class CustomFieldTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    label = tables.Column(linkify=True)",
            "    # 2.0 TODO: #824 Remove name column",
            "    name = tables.TemplateColumn(",
            "        template_code=\"\"\"",
            "{{ value }}",
            "{% if value != record.slug %}",
            "<span class=\"text-warning mdi mdi-alert\" title=\"Name does not match slug '{{ record.slug }}'\"></span>",
            "{% endif %}",
            "\"\"\"",
            "    )",
            "    slug = tables.TemplateColumn(",
            "        template_code=\"\"\"",
            "{{ value }}",
            "{% if value != record.name %}",
            "<span class=\"text-warning mdi mdi-alert\" title=\"Name '{{ record.name }}' does not match slug\"></span>",
            "{% endif %}",
            "\"\"\"",
            "    )",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "    required = BooleanColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = CustomField",
            "        fields = (",
            "            \"pk\",",
            "            \"label\",",
            "            # 2.0 TODO: #824 Remove name column",
            "            \"name\",",
            "            \"slug\",",
            "            \"content_types\",",
            "            \"type\",",
            "            \"description\",",
            "            \"required\",",
            "            \"default\",",
            "            \"weight\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"content_types\",",
            "            \"type\",",
            "            \"required\",",
            "            \"weight\",",
            "        )",
            "",
            "    def render_description(self, record):",
            "        if record.description:",
            "            return mark_safe(render_markdown(record.description))",
            "        return self.default",
            "",
            "",
            "class CustomLinkTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    new_window = BooleanColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = CustomLink",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_type\",",
            "            \"text\",",
            "            \"target_url\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"new_window\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_type\",",
            "            \"group_name\",",
            "            \"weight\",",
            "        )",
            "",
            "",
            "class DynamicGroupTable(BaseTable):",
            "    \"\"\"Base table for displaying dynamic groups in list view.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    members = tables.Column(accessor=\"count\", verbose_name=\"Group Members\", orderable=False)",
            "    actions = ButtonsColumn(DynamicGroup, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):  # pylint: disable=too-few-public-methods",
            "        model = DynamicGroup",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "            \"content_type\",",
            "            \"members\",",
            "            \"actions\",",
            "        )",
            "",
            "    def render_members(self, value, record):",
            "        \"\"\"Provide a filtered URL to the group members (if any).\"\"\"",
            "        # Only linkify if there are members.",
            "        if not value:",
            "            return value",
            "        return format_html('<a href=\"{}\">{}</a>', record.get_group_members_url(), value)",
            "",
            "",
            "class DynamicGroupMembershipTable(DynamicGroupTable):",
            "    \"\"\"Hybrid table for displaying info for both group and membership.\"\"\"",
            "",
            "    description = tables.Column(accessor=\"group.description\")",
            "    actions = ButtonsColumn(DynamicGroup, pk_field=\"slug\", buttons=(\"edit\",))",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = DynamicGroupMembership",
            "        fields = (",
            "            \"pk\",",
            "            \"operator\",",
            "            \"name\",",
            "            \"weight\",",
            "            \"members\",",
            "            \"description\",",
            "            \"actions\",",
            "        )",
            "        exclude = (\"content_type\",)",
            "",
            "",
            "DESCENDANTS_LINK = \"\"\"",
            "{% load helpers %}",
            "{% for node, depth in descendants_tree.items %}",
            "    {% if record.pk == node %}",
            "        {% for i in depth|as_range %}",
            "            {% if not forloop.first %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "            {% endif %}",
            "        {% endfor %}",
            "    {% endif %}",
            "{% endfor %}",
            "<a href=\"{{ record.get_absolute_url }}\">{{ record.name }}</a>",
            "\"\"\"",
            "",
            "",
            "OPERATOR_LINK = \"\"\"",
            "{% load helpers %}",
            "{% for node, depth in descendants_tree.items %}",
            "    {% if record.pk == node %}",
            "        {% for i in depth|as_range %}",
            "            {% if not forloop.first %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "            {% endif %}",
            "        {% endfor %}",
            "    {% endif %}",
            "{% endfor %}",
            "{{ record.get_operator_display }}",
            "\"\"\"",
            "",
            "",
            "class NestedDynamicGroupDescendantsTable(DynamicGroupMembershipTable):",
            "    \"\"\"",
            "    Subclass of DynamicGroupMembershipTable used in detail views to show parenting hierarchy with dots.",
            "    \"\"\"",
            "",
            "    operator = tables.TemplateColumn(template_code=OPERATOR_LINK)",
            "    name = tables.TemplateColumn(template_code=DESCENDANTS_LINK)",
            "",
            "    class Meta(DynamicGroupMembershipTable.Meta):",
            "        pass",
            "",
            "",
            "ANCESTORS_LINK = \"\"\"",
            "{% load helpers %}",
            "{% for node in ancestors_tree %}",
            "    {% if node.name == record.name %}",
            "        {% for i in node.depth|as_range %}",
            "            {% if not forloop.first %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "            {% endif %}",
            "        {% endfor %}",
            "    {% endif %}",
            "{% endfor %}",
            "<a href=\"{{ record.get_absolute_url }}\">{{ record.name }}</a>",
            "\"\"\"",
            "",
            "",
            "class NestedDynamicGroupAncestorsTable(DynamicGroupTable):",
            "    \"\"\"",
            "    Subclass of DynamicGroupTable used in detail views to show parenting hierarchy with dots.",
            "    \"\"\"",
            "",
            "    name = tables.TemplateColumn(template_code=ANCESTORS_LINK)",
            "    actions = ButtonsColumn(DynamicGroup, pk_field=\"slug\", buttons=(\"edit\",))",
            "",
            "    class Meta(DynamicGroupTable.Meta):",
            "        fields = [\"name\", \"members\", \"description\", \"actions\"]",
            "        exclude = [\"content_type\"]",
            "",
            "",
            "class ExportTemplateTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    owner = tables.LinkColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ExportTemplate",
            "        fields = (",
            "            \"pk\",",
            "            \"owner\",",
            "            \"content_type\",",
            "            \"name\",",
            "            \"description\",",
            "            \"mime_type\",",
            "            \"file_extension\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_type\",",
            "            \"file_extension\",",
            "        )",
            "",
            "",
            "class GitRepositoryTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    remote_url = tables.Column(verbose_name=\"Remote URL\")",
            "    secrets_group = tables.Column(linkify=True)",
            "    last_sync_time = tables.DateTimeColumn(",
            "        empty_values=(), format=settings.SHORT_DATETIME_FORMAT, verbose_name=\"Sync Time\"",
            "    )",
            "",
            "    last_sync_user = tables.Column(empty_values=(), verbose_name=\"Sync By\")",
            "",
            "    class JobResultColumn(tables.TemplateColumn):",
            "        def render(self, record, table, value, bound_column, **kwargs):",
            "            if record.name in table.context.get(\"job_results\", {}):",
            "                table.context.update({\"result\": table.context[\"job_results\"][record.name]})",
            "            else:",
            "                table.context.update({\"result\": None})",
            "            return super().render(record, table, value, bound_column, **kwargs)",
            "",
            "    last_sync_status = JobResultColumn(template_name=\"extras/inc/job_label.html\", verbose_name=\"Sync Status\")",
            "    provides = tables.TemplateColumn(GITREPOSITORY_PROVIDES)",
            "    actions = ButtonsColumn(GitRepository, pk_field=\"slug\", prepend_template=GITREPOSITORY_BUTTONS)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = GitRepository",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"secrets_group\",",
            "            \"provides\",",
            "            \"last_sync_time\",",
            "            \"last_sync_user\",",
            "            \"last_sync_status\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"provides\",",
            "            \"last_sync_status\",",
            "            \"actions\",",
            "        )",
            "",
            "    def render_last_sync_time(self, record):",
            "        if record.name in self.context[\"job_results\"]:",
            "            return self.context[\"job_results\"][record.name].completed",
            "        return self.default",
            "",
            "    def render_last_sync_user(self, record):",
            "        if record.name in self.context[\"job_results\"]:",
            "            user = self.context[\"job_results\"][record.name].user",
            "            return user",
            "        return self.default",
            "",
            "",
            "class GitRepositoryBulkTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    remote_url = tables.Column(verbose_name=\"Remote URL\")",
            "    secrets_group = tables.Column(linkify=True)",
            "    provides = tables.TemplateColumn(GITREPOSITORY_PROVIDES)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = GitRepository",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"secrets_group\",",
            "            \"provides\",",
            "        )",
            "",
            "",
            "class GraphQLQueryTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = GraphQLQuery",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"slug\",",
            "        )",
            "",
            "",
            "def log_object_link(value, record):",
            "    return record.absolute_url",
            "",
            "",
            "def log_entry_color_css(record):",
            "    if record.log_level.lower() == \"failure\":",
            "        return \"danger\"",
            "    return record.log_level.lower()",
            "",
            "",
            "class JobTable(BaseTable):",
            "    # TODO(Glenn): pk = ToggleColumn()",
            "    source = tables.Column()",
            "    # grouping is used to, well, group the Jobs, so it isn't a column of its own.",
            "    name = tables.Column(linkify=True)",
            "    installed = BooleanColumn()",
            "    enabled = BooleanColumn()",
            "    has_sensitive_variables = BooleanColumn()",
            "    description = tables.Column(accessor=\"description_first_line\")",
            "    commit_default = BooleanColumn()",
            "    hidden = BooleanColumn()",
            "    read_only = BooleanColumn()",
            "    approval_required = BooleanColumn()",
            "    is_job_hook_receiver = BooleanColumn()",
            "    is_job_button_receiver = BooleanColumn()",
            "    soft_time_limit = tables.Column()",
            "    time_limit = tables.Column()",
            "    actions = ButtonsColumn(JobModel, pk_field=\"slug\", prepend_template=JOB_BUTTONS)",
            "    last_run = tables.TemplateColumn(",
            "        accessor=\"latest_result\",",
            "        template_code=\"\"\"",
            "            {% if value %}",
            "                {{ value.created }} by {{ value.user }}",
            "            {% else %}",
            "                <span class=\"text-muted\">Never</span>",
            "            {% endif %}",
            "        \"\"\",",
            "        linkify=lambda value: value.get_absolute_url() if value else None,",
            "    )",
            "    last_status = tables.TemplateColumn(",
            "        template_code=\"{% include 'extras/inc/job_label.html' with result=record.latest_result %}\",",
            "    )",
            "    tags = TagColumn(url_name=\"extras:job_list\")",
            "",
            "    def render_description(self, value):",
            "        return render_markdown(value)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobModel",
            "        orderable = False",
            "        fields = (",
            "            \"source\",",
            "            \"name\",",
            "            \"installed\",",
            "            \"enabled\",",
            "            \"has_sensitive_variables\",",
            "            \"description\",",
            "            \"commit_default\",",
            "            \"hidden\",",
            "            \"read_only\",",
            "            \"is_job_hook_receiver\",",
            "            \"is_job_button_receiver\",",
            "            \"approval_required\",",
            "            \"soft_time_limit\",",
            "            \"time_limit\",",
            "            \"last_run\",",
            "            \"last_status\",",
            "            \"tags\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (",
            "            \"name\",",
            "            \"enabled\",",
            "            \"description\",",
            "            \"last_run\",",
            "            \"last_status\",",
            "            \"actions\",",
            "        )",
            "",
            "",
            "class JobHookTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    content_types = tables.TemplateColumn(WEBHOOK_CONTENT_TYPES)",
            "    job = tables.Column(linkify=True)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobHook",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "        )",
            "",
            "",
            "class JobLogEntryTable(BaseTable):",
            "    created = tables.DateTimeColumn(verbose_name=\"Time\", format=\"Y-m-d H:i:s.u\")",
            "    grouping = tables.Column()",
            "    log_level = tables.Column(",
            "        verbose_name=\"Level\",",
            "        attrs={\"td\": {\"class\": \"text-nowrap report-stats\"}},",
            "    )",
            "    log_object = tables.Column(verbose_name=\"Object\", linkify=log_object_link)",
            "    message = tables.Column(",
            "        attrs={\"td\": {\"class\": \"rendered-markdown\"}},",
            "    )",
            "",
            "    def render_log_level(self, value):",
            "        log_level = value.lower()",
            "        # The css is label-danger for failure items.",
            "        if log_level == \"failure\":",
            "            log_level = \"danger\"",
            "",
            "        return format_html('<label class=\"label label-{}\">{}</label>', log_level, value)",
            "",
            "    def render_message(self, value):",
            "        return render_markdown(value)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobLogEntry",
            "        fields = (\"created\", \"grouping\", \"log_level\", \"log_object\", \"message\")",
            "        default_columns = (\"created\", \"grouping\", \"log_level\", \"log_object\", \"message\")",
            "        row_attrs = {",
            "            \"class\": log_entry_color_css,",
            "        }",
            "        attrs = {",
            "            \"class\": \"table table-hover table-headings\",",
            "            \"id\": \"logs\",",
            "        }",
            "",
            "",
            "class JobResultTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    linked_record = tables.Column(verbose_name=\"Job / Git Repository\", linkify=True)",
            "    name = tables.Column()",
            "    created = tables.DateTimeColumn(linkify=True, format=settings.SHORT_DATETIME_FORMAT)",
            "    status = tables.TemplateColumn(",
            "        template_code=\"{% include 'extras/inc/job_label.html' with result=record %}\",",
            "    )",
            "    summary = tables.Column(",
            "        empty_values=(),",
            "        verbose_name=\"Results\",",
            "        orderable=False,",
            "        attrs={\"td\": {\"class\": \"text-nowrap report-stats\"}},",
            "    )",
            "    actions = tables.TemplateColumn(",
            "        template_code=\"\"\"",
            "            {% load helpers %}",
            "            {% if perms.extras.run_job %}",
            "                {% if record.job_model and record.job_kwargs %}",
            "                    <a href=\"{% url 'extras:job_run' slug=record.job_model.slug %}?kwargs_from_job_result={{ record.pk }}\"",
            "                       class=\"btn btn-xs btn-success\" title=\"Re-run job with same arguments.\">",
            "                        <i class=\"mdi mdi-repeat\"></i>",
            "                    </a>",
            "                {% elif record.job_model is not None %}",
            "                    <a href=\"{% url 'extras:job_run' slug=record.job_model.slug %}\" class=\"btn btn-primary btn-xs\"",
            "                       title=\"Run job\">",
            "                        <i class=\"mdi mdi-play\"></i>",
            "                    </a>",
            "                {% else %}",
            "                    <a href=\"#\" class=\"btn btn-xs btn-default disabled\" title=\"Job is not available, cannot be re-run\">",
            "                        <i class=\"mdi mdi-repeat-off\"></i>",
            "                    </a>",
            "                {% endif %}",
            "            {% endif %}",
            "            <a href=\"{% url 'extras:jobresult_delete' pk=record.pk %}\" class=\"btn btn-xs btn-danger\"",
            "               title=\"Delete this job result.\">",
            "                <i class=\"mdi mdi-trash-can-outline\"></i>",
            "            </a>",
            "        \"\"\"",
            "    )",
            "",
            "    def order_linked_record(self, queryset, is_descending):",
            "        return (",
            "            queryset.order_by(",
            "                (\"-\" if is_descending else \"\") + \"job_model__name\",",
            "                (\"-\" if is_descending else \"\") + \"name\",",
            "            ),",
            "            True,",
            "        )",
            "",
            "    def render_summary(self, record):",
            "        \"\"\"",
            "        Define custom rendering for the summary column.",
            "        \"\"\"",
            "        log_objects = record.logs.all()",
            "        success = log_objects.filter(log_level=LogLevelChoices.LOG_SUCCESS).count()",
            "        info = log_objects.filter(log_level=LogLevelChoices.LOG_INFO).count()",
            "        warning = log_objects.filter(log_level=LogLevelChoices.LOG_WARNING).count()",
            "        failure = log_objects.filter(log_level=LogLevelChoices.LOG_FAILURE).count()",
            "        return format_html(",
            "            \"\"\"<label class=\"label label-success\">{}</label>",
            "            <label class=\"label label-info\">{}</label>",
            "            <label class=\"label label-warning\">{}</label>",
            "            <label class=\"label label-danger\">{}</label>\"\"\",",
            "            success,",
            "            info,",
            "            warning,",
            "            failure,",
            "        )",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobResult",
            "        fields = (",
            "            \"pk\",",
            "            \"created\",",
            "            \"name\",",
            "            \"linked_record\",",
            "            \"duration\",",
            "            \"completed\",",
            "            \"user\",",
            "            \"status\",",
            "            \"summary\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (\"pk\", \"created\", \"name\", \"linked_record\", \"user\", \"status\", \"summary\", \"actions\")",
            "",
            "",
            "class JobButtonTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    job = tables.Column(linkify=True)",
            "    confirmation = BooleanColumn()",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobButton",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"text\",",
            "            \"job\",",
            "            \"group_name\",",
            "            \"weight\",",
            "            \"button_class\",",
            "            \"confirmation\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"group_name\",",
            "            \"weight\",",
            "            \"job\",",
            "            \"confirmation\",",
            "        )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteTable(BaseTable):",
            "    actions = ButtonsColumn(Note, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Note",
            "        fields = (\"created\", \"note\", \"user_name\")",
            "",
            "    def render_note(self, value):",
            "        return render_markdown(value)",
            "",
            "",
            "#",
            "# ScheduledJobs",
            "#",
            "",
            "",
            "class ScheduledJobTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    job_model = tables.Column(verbose_name=\"Job\", linkify=True)",
            "    interval = tables.Column(verbose_name=\"Execution Type\")",
            "    start_time = tables.Column(verbose_name=\"First Run\")",
            "    last_run_at = tables.Column(verbose_name=\"Most Recent Run\")",
            "    total_run_count = tables.Column(verbose_name=\"Total Run Count\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ScheduledJob",
            "        fields = (\"pk\", \"name\", \"job_model\", \"interval\", \"start_time\", \"last_run_at\")",
            "",
            "",
            "class ScheduledJobApprovalQueueTable(BaseTable):",
            "    name = tables.LinkColumn(viewname=\"extras:scheduledjob_approval_request_view\", args=[tables.A(\"pk\")])",
            "    job_model = tables.Column(verbose_name=\"Job\", linkify=True)",
            "    interval = tables.Column(verbose_name=\"Execution Type\")",
            "    start_time = tables.Column(verbose_name=\"Requested\")",
            "    user = tables.Column(verbose_name=\"Requestor\")",
            "    actions = tables.TemplateColumn(SCHEDULED_JOB_APPROVAL_QUEUE_BUTTONS)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ScheduledJob",
            "        fields = (\"name\", \"job_model\", \"interval\", \"user\", \"start_time\", \"actions\")",
            "",
            "",
            "class ObjectChangeTable(BaseTable):",
            "    time = tables.DateTimeColumn(linkify=True, format=settings.SHORT_DATETIME_FORMAT)",
            "    action = ChoiceFieldColumn()",
            "    changed_object_type = tables.Column(verbose_name=\"Type\")",
            "    object_repr = tables.TemplateColumn(template_code=OBJECTCHANGE_OBJECT, verbose_name=\"Object\")",
            "    request_id = tables.TemplateColumn(template_code=OBJECTCHANGE_REQUEST_ID, verbose_name=\"Request ID\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ObjectChange",
            "        fields = (",
            "            \"time\",",
            "            \"user_name\",",
            "            \"action\",",
            "            \"changed_object_type\",",
            "            \"object_repr\",",
            "            \"request_id\",",
            "        )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    actions = ButtonsColumn(Relationship, pk_field=\"slug\", buttons=(\"edit\", \"delete\"))",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Relationship",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "            \"type\",",
            "            \"source_type\",",
            "            \"destination_type\",",
            "            \"actions\",",
            "            \"required_on\",",
            "        )",
            "",
            "",
            "class RelationshipAssociationTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    actions = ButtonsColumn(RelationshipAssociation, buttons=(\"delete\",))",
            "    relationship = tables.Column(linkify=True)",
            "",
            "    source_type = tables.Column()",
            "    source = tables.Column(linkify=True, orderable=False, accessor=\"get_source\", default=\"unknown\")",
            "",
            "    destination_type = tables.Column()",
            "    destination = tables.Column(linkify=True, orderable=False, accessor=\"get_destination\", default=\"unknown\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = RelationshipAssociation",
            "        fields = (\"pk\", \"relationship\", \"source_type\", \"source\", \"destination_type\", \"destination\", \"actions\")",
            "        default_columns = (\"pk\", \"relationship\", \"source\", \"destination\", \"actions\")",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretTable(BaseTable):",
            "    \"\"\"Table for list view of `Secret` objects.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    tags = TagColumn(url_name=\"extras:secret_list\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Secret",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"provider\",",
            "            \"description\",",
            "            \"tags\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"provider\",",
            "            \"description\",",
            "            \"tags\",",
            "        )",
            "",
            "    def render_provider(self, value):",
            "        return registry[\"secrets_providers\"][value].name if value in registry[\"secrets_providers\"] else value",
            "",
            "",
            "class SecretsGroupTable(BaseTable):",
            "    \"\"\"Table for list view of `SecretsGroup` objects.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = SecretsGroup",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "#",
            "# Custom statuses",
            "#",
            "",
            "",
            "class StatusTable(BaseTable):",
            "    \"\"\"Table for list view of `Status` objects.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn(viewname=\"extras:status\", args=[Accessor(\"slug\")])",
            "    color = ColorColumn()",
            "    actions = ButtonsColumn(Status, pk_field=\"slug\")",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Status",
            "        fields = [\"pk\", \"name\", \"slug\", \"color\", \"content_types\", \"description\"]",
            "",
            "",
            "class StatusTableMixin(BaseTable):",
            "    \"\"\"Mixin to add a `status` field to a table.\"\"\"",
            "",
            "    status = ColoredLabelColumn()",
            "",
            "",
            "class TagTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn(viewname=\"extras:tag\", args=[Accessor(\"slug\")])",
            "    color = ColorColumn()",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "    actions = ButtonsColumn(Tag, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Tag",
            "        fields = (\"pk\", \"name\", \"items\", \"slug\", \"color\", \"content_types\", \"description\", \"actions\")",
            "",
            "",
            "class TaggedItemTable(BaseTable):",
            "    content_object = tables.TemplateColumn(template_code=TAGGED_ITEM, orderable=False, verbose_name=\"Object\")",
            "    content_type = tables.Column(verbose_name=\"Type\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = TaggedItem",
            "        fields = (\"content_object\", \"content_type\")",
            "",
            "",
            "class WebhookTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    content_types = tables.TemplateColumn(WEBHOOK_CONTENT_TYPES)",
            "    enabled = BooleanColumn()",
            "    type_create = BooleanColumn()",
            "    type_update = BooleanColumn()",
            "    type_delete = BooleanColumn()",
            "    ssl_verification = BooleanColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Webhook",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"payload_url\",",
            "            \"http_content_type\",",
            "            \"http_method\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "            \"ssl_verification\",",
            "            \"ca_file_path\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"payload_url\",",
            "            \"http_content_type\",",
            "            \"enabled\",",
            "        )"
        ],
        "afterPatchFile": [
            "import django_tables2 as tables",
            "from django.conf import settings",
            "from django.utils.html import format_html",
            "from django_tables2.utils import Accessor",
            "from jsonschema.exceptions import ValidationError as JSONSchemaValidationError",
            "",
            "from nautobot.utilities.tables import (",
            "    BaseTable,",
            "    BooleanColumn,",
            "    ButtonsColumn,",
            "    ChoiceFieldColumn,",
            "    ColorColumn,",
            "    ColoredLabelColumn,",
            "    ContentTypesColumn,",
            "    TagColumn,",
            "    ToggleColumn,",
            ")",
            "from nautobot.utilities.templatetags.helpers import render_boolean, render_markdown",
            "from .choices import LogLevelChoices",
            "from .models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    Job as JobModel,",
            "    JobButton,",
            "    JobHook,",
            "    JobResult,",
            "    JobLogEntry,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Webhook,",
            ")",
            "from .registry import registry",
            "",
            "",
            "TAGGED_ITEM = \"\"\"",
            "{% if value.get_absolute_url %}",
            "    <a href=\"{{ value.get_absolute_url }}\">{{ value }}</a>",
            "{% else %}",
            "    {{ value }}",
            "{% endif %}",
            "\"\"\"",
            "",
            "GITREPOSITORY_PROVIDES = \"\"\"",
            "<span class=\"text-nowrap\">",
            "{% for entry in datasource_contents %}",
            "<span style=\"display: inline-block\" title=\"{{ entry.name|title }}\"",
            "class=\"label label-{% if entry.content_identifier in record.provided_contents %}success{% else %}default{% endif %}\">",
            "<i class=\"mdi {{ entry.icon }}\"></i></span>",
            "{% endfor %}",
            "</span>",
            "\"\"\"",
            "",
            "GITREPOSITORY_BUTTONS = \"\"\"",
            "<button data-url=\"{% url 'extras:gitrepository_sync' slug=record.slug %}\" type=\"submit\" class=\"btn btn-primary btn-xs sync-repository\" title=\"Sync\" {% if not perms.extras.change_gitrepository %}disabled=\"disabled\"{% endif %}><i class=\"mdi mdi-source-branch-sync\" aria-hidden=\"true\"></i></button>",
            "\"\"\"",
            "",
            "JOB_BUTTONS = \"\"\"",
            "<a href=\"{% url 'extras:job_run' slug=record.slug %}\" class=\"btn btn-primary btn-xs\" title=\"Run/Schedule\" {% if not perms.extras.run_job or not record.runnable %}disabled=\"disabled\"{% endif %}><i class=\"mdi mdi-play\" aria-hidden=\"true\"></i></a>",
            "\"\"\"",
            "",
            "OBJECTCHANGE_OBJECT = \"\"\"",
            "{% if record.changed_object and record.changed_object.get_absolute_url %}",
            "    <a href=\"{{ record.changed_object.get_absolute_url }}\">{{ record.object_repr }}</a>",
            "{% else %}",
            "    {{ record.object_repr }}",
            "{% endif %}",
            "\"\"\"",
            "",
            "OBJECTCHANGE_REQUEST_ID = \"\"\"",
            "<a href=\"{% url 'extras:objectchange_list' %}?request_id={{ value }}\">{{ value }}</a>",
            "\"\"\"",
            "",
            "# TODO: Webhook content_types in table order_by",
            "WEBHOOK_CONTENT_TYPES = \"\"\"",
            "{{ value.all|join:\", \"|truncatewords:15 }}",
            "\"\"\"",
            "",
            "SCHEDULED_JOB_APPROVAL_QUEUE_BUTTONS = \"\"\"",
            "<button type=\"button\"",
            "        onClick=\"handleDetailPostAction('{% url 'extras:scheduledjob_approval_request_view' pk=record.pk %}', '_dry_run')\"",
            "        title=\"Dry Run\"",
            "        class=\"btn btn-primary btn-xs\"{% if not perms.extras.run_job %} disabled=\"disabled\"{% endif %}>",
            "    <i class=\"mdi mdi-play\"></i>",
            "</button>",
            "<button type=\"button\"",
            "        onClick=\"handleDetailPostAction('{% url 'extras:scheduledjob_approval_request_view' pk=record.pk %}', '_approve')\"",
            "        title=\"Approve\"",
            "        class=\"btn btn-success btn-xs\"{% if not perms.extras.run_job %} disabled=\"disabled\"{% endif %}>",
            "    <i class=\"mdi mdi-check\"></i>",
            "</button>",
            "<button type=\"button\"",
            "        onClick=\"handleDetailPostAction('{% url 'extras:scheduledjob_approval_request_view' pk=record.pk %}', '_deny')\"",
            "        title=\"Deny\"",
            "        class=\"btn btn-danger btn-xs\"{% if not perms.extras.run_job %} disabled=\"disabled\"{% endif %}>",
            "    <i class=\"mdi mdi-close\"></i>",
            "</button>",
            "\"\"\"",
            "",
            "",
            "class ComputedFieldTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    label = tables.Column(linkify=True)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ComputedField",
            "        fields = (",
            "            \"pk\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"content_type\",",
            "            \"description\",",
            "            \"weight\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"content_type\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "class ConfigContextTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    owner = tables.LinkColumn()",
            "    is_active = BooleanColumn(verbose_name=\"Active\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ConfigContext",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"owner\",",
            "            \"weight\",",
            "            \"is_active\",",
            "            \"description\",",
            "            \"regions\",",
            "            \"sites\",",
            "            \"roles\",",
            "            \"platforms\",",
            "            \"cluster_groups\",",
            "            \"clusters\",",
            "            \"tenant_groups\",",
            "            \"tenants\",",
            "            \"dynamic_groups\",",
            "        )",
            "        default_columns = (\"pk\", \"name\", \"weight\", \"is_active\", \"description\")",
            "",
            "",
            "class ConfigContextSchemaTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    owner = tables.LinkColumn()",
            "    actions = ButtonsColumn(ConfigContextSchema, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ConfigContextSchema",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"owner\",",
            "            \"description\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (\"pk\", \"name\", \"description\", \"actions\")",
            "",
            "",
            "class ConfigContextSchemaValidationStateColumn(tables.Column):",
            "    \"\"\"",
            "    Custom column that validates an instance's context data against a config context schema",
            "    \"\"\"",
            "",
            "    def __init__(self, validator, data_field, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.validator = validator",
            "        self.data_field = data_field",
            "",
            "    def render(self, record):",
            "        data = getattr(record, self.data_field)",
            "        try:",
            "            self.validator.validate(data)",
            "        except JSONSchemaValidationError as e:",
            "            # Return a red x (like a boolean column) and the validation error message",
            "            return render_boolean(False) + format_html('<span class=\"text-danger\">{}</span>', e.message)",
            "",
            "        # Return a green check (like a boolean column)",
            "        return render_boolean(True)",
            "",
            "",
            "class CustomFieldTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    label = tables.Column(linkify=True)",
            "    # 2.0 TODO: #824 Remove name column",
            "    name = tables.TemplateColumn(",
            "        template_code=\"\"\"",
            "{{ value }}",
            "{% if value != record.slug %}",
            "<span class=\"text-warning mdi mdi-alert\" title=\"Name does not match slug '{{ record.slug }}'\"></span>",
            "{% endif %}",
            "\"\"\"",
            "    )",
            "    slug = tables.TemplateColumn(",
            "        template_code=\"\"\"",
            "{{ value }}",
            "{% if value != record.name %}",
            "<span class=\"text-warning mdi mdi-alert\" title=\"Name '{{ record.name }}' does not match slug\"></span>",
            "{% endif %}",
            "\"\"\"",
            "    )",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "    required = BooleanColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = CustomField",
            "        fields = (",
            "            \"pk\",",
            "            \"label\",",
            "            # 2.0 TODO: #824 Remove name column",
            "            \"name\",",
            "            \"slug\",",
            "            \"content_types\",",
            "            \"type\",",
            "            \"description\",",
            "            \"required\",",
            "            \"default\",",
            "            \"weight\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"label\",",
            "            \"slug\",",
            "            \"content_types\",",
            "            \"type\",",
            "            \"required\",",
            "            \"weight\",",
            "        )",
            "",
            "    def render_description(self, record):",
            "        if record.description:",
            "            return render_markdown(record.description)",
            "        return self.default",
            "",
            "",
            "class CustomLinkTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    new_window = BooleanColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = CustomLink",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_type\",",
            "            \"text\",",
            "            \"target_url\",",
            "            \"weight\",",
            "            \"group_name\",",
            "            \"button_class\",",
            "            \"new_window\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_type\",",
            "            \"group_name\",",
            "            \"weight\",",
            "        )",
            "",
            "",
            "class DynamicGroupTable(BaseTable):",
            "    \"\"\"Base table for displaying dynamic groups in list view.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    members = tables.Column(accessor=\"count\", verbose_name=\"Group Members\", orderable=False)",
            "    actions = ButtonsColumn(DynamicGroup, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):  # pylint: disable=too-few-public-methods",
            "        model = DynamicGroup",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "            \"content_type\",",
            "            \"members\",",
            "            \"actions\",",
            "        )",
            "",
            "    def render_members(self, value, record):",
            "        \"\"\"Provide a filtered URL to the group members (if any).\"\"\"",
            "        # Only linkify if there are members.",
            "        if not value:",
            "            return value",
            "        return format_html('<a href=\"{}\">{}</a>', record.get_group_members_url(), value)",
            "",
            "",
            "class DynamicGroupMembershipTable(DynamicGroupTable):",
            "    \"\"\"Hybrid table for displaying info for both group and membership.\"\"\"",
            "",
            "    description = tables.Column(accessor=\"group.description\")",
            "    actions = ButtonsColumn(DynamicGroup, pk_field=\"slug\", buttons=(\"edit\",))",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = DynamicGroupMembership",
            "        fields = (",
            "            \"pk\",",
            "            \"operator\",",
            "            \"name\",",
            "            \"weight\",",
            "            \"members\",",
            "            \"description\",",
            "            \"actions\",",
            "        )",
            "        exclude = (\"content_type\",)",
            "",
            "",
            "DESCENDANTS_LINK = \"\"\"",
            "{% load helpers %}",
            "{% for node, depth in descendants_tree.items %}",
            "    {% if record.pk == node %}",
            "        {% for i in depth|as_range %}",
            "            {% if not forloop.first %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "            {% endif %}",
            "        {% endfor %}",
            "    {% endif %}",
            "{% endfor %}",
            "<a href=\"{{ record.get_absolute_url }}\">{{ record.name }}</a>",
            "\"\"\"",
            "",
            "",
            "OPERATOR_LINK = \"\"\"",
            "{% load helpers %}",
            "{% for node, depth in descendants_tree.items %}",
            "    {% if record.pk == node %}",
            "        {% for i in depth|as_range %}",
            "            {% if not forloop.first %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "            {% endif %}",
            "        {% endfor %}",
            "    {% endif %}",
            "{% endfor %}",
            "{{ record.get_operator_display }}",
            "\"\"\"",
            "",
            "",
            "class NestedDynamicGroupDescendantsTable(DynamicGroupMembershipTable):",
            "    \"\"\"",
            "    Subclass of DynamicGroupMembershipTable used in detail views to show parenting hierarchy with dots.",
            "    \"\"\"",
            "",
            "    operator = tables.TemplateColumn(template_code=OPERATOR_LINK)",
            "    name = tables.TemplateColumn(template_code=DESCENDANTS_LINK)",
            "",
            "    class Meta(DynamicGroupMembershipTable.Meta):",
            "        pass",
            "",
            "",
            "ANCESTORS_LINK = \"\"\"",
            "{% load helpers %}",
            "{% for node in ancestors_tree %}",
            "    {% if node.name == record.name %}",
            "        {% for i in node.depth|as_range %}",
            "            {% if not forloop.first %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "            {% endif %}",
            "        {% endfor %}",
            "    {% endif %}",
            "{% endfor %}",
            "<a href=\"{{ record.get_absolute_url }}\">{{ record.name }}</a>",
            "\"\"\"",
            "",
            "",
            "class NestedDynamicGroupAncestorsTable(DynamicGroupTable):",
            "    \"\"\"",
            "    Subclass of DynamicGroupTable used in detail views to show parenting hierarchy with dots.",
            "    \"\"\"",
            "",
            "    name = tables.TemplateColumn(template_code=ANCESTORS_LINK)",
            "    actions = ButtonsColumn(DynamicGroup, pk_field=\"slug\", buttons=(\"edit\",))",
            "",
            "    class Meta(DynamicGroupTable.Meta):",
            "        fields = [\"name\", \"members\", \"description\", \"actions\"]",
            "        exclude = [\"content_type\"]",
            "",
            "",
            "class ExportTemplateTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    owner = tables.LinkColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ExportTemplate",
            "        fields = (",
            "            \"pk\",",
            "            \"owner\",",
            "            \"content_type\",",
            "            \"name\",",
            "            \"description\",",
            "            \"mime_type\",",
            "            \"file_extension\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_type\",",
            "            \"file_extension\",",
            "        )",
            "",
            "",
            "class GitRepositoryTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    remote_url = tables.Column(verbose_name=\"Remote URL\")",
            "    secrets_group = tables.Column(linkify=True)",
            "    last_sync_time = tables.DateTimeColumn(",
            "        empty_values=(), format=settings.SHORT_DATETIME_FORMAT, verbose_name=\"Sync Time\"",
            "    )",
            "",
            "    last_sync_user = tables.Column(empty_values=(), verbose_name=\"Sync By\")",
            "",
            "    class JobResultColumn(tables.TemplateColumn):",
            "        def render(self, record, table, value, bound_column, **kwargs):",
            "            if record.name in table.context.get(\"job_results\", {}):",
            "                table.context.update({\"result\": table.context[\"job_results\"][record.name]})",
            "            else:",
            "                table.context.update({\"result\": None})",
            "            return super().render(record, table, value, bound_column, **kwargs)",
            "",
            "    last_sync_status = JobResultColumn(template_name=\"extras/inc/job_label.html\", verbose_name=\"Sync Status\")",
            "    provides = tables.TemplateColumn(GITREPOSITORY_PROVIDES)",
            "    actions = ButtonsColumn(GitRepository, pk_field=\"slug\", prepend_template=GITREPOSITORY_BUTTONS)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = GitRepository",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"slug\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"secrets_group\",",
            "            \"provides\",",
            "            \"last_sync_time\",",
            "            \"last_sync_user\",",
            "            \"last_sync_status\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"provides\",",
            "            \"last_sync_status\",",
            "            \"actions\",",
            "        )",
            "",
            "    def render_last_sync_time(self, record):",
            "        if record.name in self.context[\"job_results\"]:",
            "            return self.context[\"job_results\"][record.name].completed",
            "        return self.default",
            "",
            "    def render_last_sync_user(self, record):",
            "        if record.name in self.context[\"job_results\"]:",
            "            user = self.context[\"job_results\"][record.name].user",
            "            return user",
            "        return self.default",
            "",
            "",
            "class GitRepositoryBulkTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    remote_url = tables.Column(verbose_name=\"Remote URL\")",
            "    secrets_group = tables.Column(linkify=True)",
            "    provides = tables.TemplateColumn(GITREPOSITORY_PROVIDES)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = GitRepository",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"remote_url\",",
            "            \"branch\",",
            "            \"secrets_group\",",
            "            \"provides\",",
            "        )",
            "",
            "",
            "class GraphQLQueryTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = GraphQLQuery",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"slug\",",
            "        )",
            "",
            "",
            "def log_object_link(value, record):",
            "    return record.absolute_url",
            "",
            "",
            "def log_entry_color_css(record):",
            "    if record.log_level.lower() == \"failure\":",
            "        return \"danger\"",
            "    return record.log_level.lower()",
            "",
            "",
            "class JobTable(BaseTable):",
            "    # TODO(Glenn): pk = ToggleColumn()",
            "    source = tables.Column()",
            "    # grouping is used to, well, group the Jobs, so it isn't a column of its own.",
            "    name = tables.Column(linkify=True)",
            "    installed = BooleanColumn()",
            "    enabled = BooleanColumn()",
            "    has_sensitive_variables = BooleanColumn()",
            "    description = tables.Column(accessor=\"description_first_line\")",
            "    commit_default = BooleanColumn()",
            "    hidden = BooleanColumn()",
            "    read_only = BooleanColumn()",
            "    approval_required = BooleanColumn()",
            "    is_job_hook_receiver = BooleanColumn()",
            "    is_job_button_receiver = BooleanColumn()",
            "    soft_time_limit = tables.Column()",
            "    time_limit = tables.Column()",
            "    actions = ButtonsColumn(JobModel, pk_field=\"slug\", prepend_template=JOB_BUTTONS)",
            "    last_run = tables.TemplateColumn(",
            "        accessor=\"latest_result\",",
            "        template_code=\"\"\"",
            "            {% if value %}",
            "                {{ value.created }} by {{ value.user }}",
            "            {% else %}",
            "                <span class=\"text-muted\">Never</span>",
            "            {% endif %}",
            "        \"\"\",",
            "        linkify=lambda value: value.get_absolute_url() if value else None,",
            "    )",
            "    last_status = tables.TemplateColumn(",
            "        template_code=\"{% include 'extras/inc/job_label.html' with result=record.latest_result %}\",",
            "    )",
            "    tags = TagColumn(url_name=\"extras:job_list\")",
            "",
            "    def render_description(self, value):",
            "        return render_markdown(value)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobModel",
            "        orderable = False",
            "        fields = (",
            "            \"source\",",
            "            \"name\",",
            "            \"installed\",",
            "            \"enabled\",",
            "            \"has_sensitive_variables\",",
            "            \"description\",",
            "            \"commit_default\",",
            "            \"hidden\",",
            "            \"read_only\",",
            "            \"is_job_hook_receiver\",",
            "            \"is_job_button_receiver\",",
            "            \"approval_required\",",
            "            \"soft_time_limit\",",
            "            \"time_limit\",",
            "            \"last_run\",",
            "            \"last_status\",",
            "            \"tags\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (",
            "            \"name\",",
            "            \"enabled\",",
            "            \"description\",",
            "            \"last_run\",",
            "            \"last_status\",",
            "            \"actions\",",
            "        )",
            "",
            "",
            "class JobHookTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    content_types = tables.TemplateColumn(WEBHOOK_CONTENT_TYPES)",
            "    job = tables.Column(linkify=True)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobHook",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"job\",",
            "            \"enabled\",",
            "        )",
            "",
            "",
            "class JobLogEntryTable(BaseTable):",
            "    created = tables.DateTimeColumn(verbose_name=\"Time\", format=\"Y-m-d H:i:s.u\")",
            "    grouping = tables.Column()",
            "    log_level = tables.Column(",
            "        verbose_name=\"Level\",",
            "        attrs={\"td\": {\"class\": \"text-nowrap report-stats\"}},",
            "    )",
            "    log_object = tables.Column(verbose_name=\"Object\", linkify=log_object_link)",
            "    message = tables.Column(",
            "        attrs={\"td\": {\"class\": \"rendered-markdown\"}},",
            "    )",
            "",
            "    def render_log_level(self, value):",
            "        log_level = value.lower()",
            "        # The css is label-danger for failure items.",
            "        if log_level == \"failure\":",
            "            log_level = \"danger\"",
            "",
            "        return format_html('<label class=\"label label-{}\">{}</label>', log_level, value)",
            "",
            "    def render_message(self, value):",
            "        return render_markdown(value)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobLogEntry",
            "        fields = (\"created\", \"grouping\", \"log_level\", \"log_object\", \"message\")",
            "        default_columns = (\"created\", \"grouping\", \"log_level\", \"log_object\", \"message\")",
            "        row_attrs = {",
            "            \"class\": log_entry_color_css,",
            "        }",
            "        attrs = {",
            "            \"class\": \"table table-hover table-headings\",",
            "            \"id\": \"logs\",",
            "        }",
            "",
            "",
            "class JobResultTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    linked_record = tables.Column(verbose_name=\"Job / Git Repository\", linkify=True)",
            "    name = tables.Column()",
            "    created = tables.DateTimeColumn(linkify=True, format=settings.SHORT_DATETIME_FORMAT)",
            "    status = tables.TemplateColumn(",
            "        template_code=\"{% include 'extras/inc/job_label.html' with result=record %}\",",
            "    )",
            "    summary = tables.Column(",
            "        empty_values=(),",
            "        verbose_name=\"Results\",",
            "        orderable=False,",
            "        attrs={\"td\": {\"class\": \"text-nowrap report-stats\"}},",
            "    )",
            "    actions = tables.TemplateColumn(",
            "        template_code=\"\"\"",
            "            {% load helpers %}",
            "            {% if perms.extras.run_job %}",
            "                {% if record.job_model and record.job_kwargs %}",
            "                    <a href=\"{% url 'extras:job_run' slug=record.job_model.slug %}?kwargs_from_job_result={{ record.pk }}\"",
            "                       class=\"btn btn-xs btn-success\" title=\"Re-run job with same arguments.\">",
            "                        <i class=\"mdi mdi-repeat\"></i>",
            "                    </a>",
            "                {% elif record.job_model is not None %}",
            "                    <a href=\"{% url 'extras:job_run' slug=record.job_model.slug %}\" class=\"btn btn-primary btn-xs\"",
            "                       title=\"Run job\">",
            "                        <i class=\"mdi mdi-play\"></i>",
            "                    </a>",
            "                {% else %}",
            "                    <a href=\"#\" class=\"btn btn-xs btn-default disabled\" title=\"Job is not available, cannot be re-run\">",
            "                        <i class=\"mdi mdi-repeat-off\"></i>",
            "                    </a>",
            "                {% endif %}",
            "            {% endif %}",
            "            <a href=\"{% url 'extras:jobresult_delete' pk=record.pk %}\" class=\"btn btn-xs btn-danger\"",
            "               title=\"Delete this job result.\">",
            "                <i class=\"mdi mdi-trash-can-outline\"></i>",
            "            </a>",
            "        \"\"\"",
            "    )",
            "",
            "    def order_linked_record(self, queryset, is_descending):",
            "        return (",
            "            queryset.order_by(",
            "                (\"-\" if is_descending else \"\") + \"job_model__name\",",
            "                (\"-\" if is_descending else \"\") + \"name\",",
            "            ),",
            "            True,",
            "        )",
            "",
            "    def render_summary(self, record):",
            "        \"\"\"",
            "        Define custom rendering for the summary column.",
            "        \"\"\"",
            "        log_objects = record.logs.all()",
            "        success = log_objects.filter(log_level=LogLevelChoices.LOG_SUCCESS).count()",
            "        info = log_objects.filter(log_level=LogLevelChoices.LOG_INFO).count()",
            "        warning = log_objects.filter(log_level=LogLevelChoices.LOG_WARNING).count()",
            "        failure = log_objects.filter(log_level=LogLevelChoices.LOG_FAILURE).count()",
            "        return format_html(",
            "            \"\"\"<label class=\"label label-success\">{}</label>",
            "            <label class=\"label label-info\">{}</label>",
            "            <label class=\"label label-warning\">{}</label>",
            "            <label class=\"label label-danger\">{}</label>\"\"\",",
            "            success,",
            "            info,",
            "            warning,",
            "            failure,",
            "        )",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobResult",
            "        fields = (",
            "            \"pk\",",
            "            \"created\",",
            "            \"name\",",
            "            \"linked_record\",",
            "            \"duration\",",
            "            \"completed\",",
            "            \"user\",",
            "            \"status\",",
            "            \"summary\",",
            "            \"actions\",",
            "        )",
            "        default_columns = (\"pk\", \"created\", \"name\", \"linked_record\", \"user\", \"status\", \"summary\", \"actions\")",
            "",
            "",
            "class JobButtonTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    job = tables.Column(linkify=True)",
            "    confirmation = BooleanColumn()",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = JobButton",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"text\",",
            "            \"job\",",
            "            \"group_name\",",
            "            \"weight\",",
            "            \"button_class\",",
            "            \"confirmation\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"group_name\",",
            "            \"weight\",",
            "            \"job\",",
            "            \"confirmation\",",
            "        )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteTable(BaseTable):",
            "    actions = ButtonsColumn(Note, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Note",
            "        fields = (\"created\", \"note\", \"user_name\")",
            "",
            "    def render_note(self, value):",
            "        return render_markdown(value)",
            "",
            "",
            "#",
            "# ScheduledJobs",
            "#",
            "",
            "",
            "class ScheduledJobTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    job_model = tables.Column(verbose_name=\"Job\", linkify=True)",
            "    interval = tables.Column(verbose_name=\"Execution Type\")",
            "    start_time = tables.Column(verbose_name=\"First Run\")",
            "    last_run_at = tables.Column(verbose_name=\"Most Recent Run\")",
            "    total_run_count = tables.Column(verbose_name=\"Total Run Count\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ScheduledJob",
            "        fields = (\"pk\", \"name\", \"job_model\", \"interval\", \"start_time\", \"last_run_at\")",
            "",
            "",
            "class ScheduledJobApprovalQueueTable(BaseTable):",
            "    name = tables.LinkColumn(viewname=\"extras:scheduledjob_approval_request_view\", args=[tables.A(\"pk\")])",
            "    job_model = tables.Column(verbose_name=\"Job\", linkify=True)",
            "    interval = tables.Column(verbose_name=\"Execution Type\")",
            "    start_time = tables.Column(verbose_name=\"Requested\")",
            "    user = tables.Column(verbose_name=\"Requestor\")",
            "    actions = tables.TemplateColumn(SCHEDULED_JOB_APPROVAL_QUEUE_BUTTONS)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ScheduledJob",
            "        fields = (\"name\", \"job_model\", \"interval\", \"user\", \"start_time\", \"actions\")",
            "",
            "",
            "class ObjectChangeTable(BaseTable):",
            "    time = tables.DateTimeColumn(linkify=True, format=settings.SHORT_DATETIME_FORMAT)",
            "    action = ChoiceFieldColumn()",
            "    changed_object_type = tables.Column(verbose_name=\"Type\")",
            "    object_repr = tables.TemplateColumn(template_code=OBJECTCHANGE_OBJECT, verbose_name=\"Object\")",
            "    request_id = tables.TemplateColumn(template_code=OBJECTCHANGE_REQUEST_ID, verbose_name=\"Request ID\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = ObjectChange",
            "        fields = (",
            "            \"time\",",
            "            \"user_name\",",
            "            \"action\",",
            "            \"changed_object_type\",",
            "            \"object_repr\",",
            "            \"request_id\",",
            "        )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    actions = ButtonsColumn(Relationship, pk_field=\"slug\", buttons=(\"edit\", \"delete\"))",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Relationship",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "            \"type\",",
            "            \"source_type\",",
            "            \"destination_type\",",
            "            \"actions\",",
            "            \"required_on\",",
            "        )",
            "",
            "",
            "class RelationshipAssociationTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    actions = ButtonsColumn(RelationshipAssociation, buttons=(\"delete\",))",
            "    relationship = tables.Column(linkify=True)",
            "",
            "    source_type = tables.Column()",
            "    source = tables.Column(linkify=True, orderable=False, accessor=\"get_source\", default=\"unknown\")",
            "",
            "    destination_type = tables.Column()",
            "    destination = tables.Column(linkify=True, orderable=False, accessor=\"get_destination\", default=\"unknown\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = RelationshipAssociation",
            "        fields = (\"pk\", \"relationship\", \"source_type\", \"source\", \"destination_type\", \"destination\", \"actions\")",
            "        default_columns = (\"pk\", \"relationship\", \"source\", \"destination\", \"actions\")",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretTable(BaseTable):",
            "    \"\"\"Table for list view of `Secret` objects.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "    tags = TagColumn(url_name=\"extras:secret_list\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Secret",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"provider\",",
            "            \"description\",",
            "            \"tags\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"provider\",",
            "            \"description\",",
            "            \"tags\",",
            "        )",
            "",
            "    def render_provider(self, value):",
            "        return registry[\"secrets_providers\"][value].name if value in registry[\"secrets_providers\"] else value",
            "",
            "",
            "class SecretsGroupTable(BaseTable):",
            "    \"\"\"Table for list view of `SecretsGroup` objects.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = SecretsGroup",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"description\",",
            "        )",
            "",
            "",
            "#",
            "# Custom statuses",
            "#",
            "",
            "",
            "class StatusTable(BaseTable):",
            "    \"\"\"Table for list view of `Status` objects.\"\"\"",
            "",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn(viewname=\"extras:status\", args=[Accessor(\"slug\")])",
            "    color = ColorColumn()",
            "    actions = ButtonsColumn(Status, pk_field=\"slug\")",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Status",
            "        fields = [\"pk\", \"name\", \"slug\", \"color\", \"content_types\", \"description\"]",
            "",
            "",
            "class StatusTableMixin(BaseTable):",
            "    \"\"\"Mixin to add a `status` field to a table.\"\"\"",
            "",
            "    status = ColoredLabelColumn()",
            "",
            "",
            "class TagTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.LinkColumn(viewname=\"extras:tag\", args=[Accessor(\"slug\")])",
            "    color = ColorColumn()",
            "    content_types = ContentTypesColumn(truncate_words=15)",
            "    actions = ButtonsColumn(Tag, pk_field=\"slug\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Tag",
            "        fields = (\"pk\", \"name\", \"items\", \"slug\", \"color\", \"content_types\", \"description\", \"actions\")",
            "",
            "",
            "class TaggedItemTable(BaseTable):",
            "    content_object = tables.TemplateColumn(template_code=TAGGED_ITEM, orderable=False, verbose_name=\"Object\")",
            "    content_type = tables.Column(verbose_name=\"Type\")",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = TaggedItem",
            "        fields = (\"content_object\", \"content_type\")",
            "",
            "",
            "class WebhookTable(BaseTable):",
            "    pk = ToggleColumn()",
            "    name = tables.Column(linkify=True)",
            "    content_types = tables.TemplateColumn(WEBHOOK_CONTENT_TYPES)",
            "    enabled = BooleanColumn()",
            "    type_create = BooleanColumn()",
            "    type_update = BooleanColumn()",
            "    type_delete = BooleanColumn()",
            "    ssl_verification = BooleanColumn()",
            "",
            "    class Meta(BaseTable.Meta):",
            "        model = Webhook",
            "        fields = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"payload_url\",",
            "            \"http_content_type\",",
            "            \"http_method\",",
            "            \"enabled\",",
            "            \"type_create\",",
            "            \"type_update\",",
            "            \"type_delete\",",
            "            \"ssl_verification\",",
            "            \"ca_file_path\",",
            "        )",
            "        default_columns = (",
            "            \"pk\",",
            "            \"name\",",
            "            \"content_types\",",
            "            \"payload_url\",",
            "            \"http_content_type\",",
            "            \"enabled\",",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": [],
            "258": [
                "CustomFieldTable",
                "render_description"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/templatetags/computed_fields.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from django import template"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from django.contrib.contenttypes.models import ContentType"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from django.utils.html import format_html_join"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from nautobot.extras.models import ComputedField"
            },
            "7": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     if not computed_fields:"
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         return \"\""
            },
            "10": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    template_code = \"\""
            },
            "12": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "13": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for label, value in fields.items():"
            },
            "14": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        escaped_label = escape(label)"
            },
            "15": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        template_code += f\"\"\""
            },
            "16": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            <tr>"
            },
            "17": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                <td><span title=\"{escaped_label}\">{escaped_label}</span></td>"
            },
            "18": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                <td>{escape(value)}</td>"
            },
            "19": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            <tr>"
            },
            "20": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"\"\""
            },
            "21": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return mark_safe(template_code)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    return format_html_join("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        \"\\n\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        '<tr><td><span title=\"{}\">{}</span></td><td>{}</td></tr>',"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        ((label, label, value) for label, value in fields.items()),"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    )"
            }
        },
        "frontPatchFile": [
            "from django import template",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.utils.html import escape",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot.extras.models import ComputedField",
            "",
            "register = template.Library()",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def has_computed_fields(context, obj):",
            "    \"\"\"",
            "    Return a boolean value indicating if an object's content type has associated computed fields.",
            "    \"\"\"",
            "    content_type = ContentType.objects.get_for_model(obj)",
            "    return ComputedField.objects.filter(content_type=content_type).exists()",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def computed_fields(context, obj, advanced_ui=None):",
            "    \"\"\"",
            "    Render all applicable links for the given object.",
            "    This can also check whether the advanced_ui attribute is True or False for UI display purposes.",
            "    \"\"\"",
            "    fields = obj.get_computed_fields(label_as_key=True, advanced_ui=advanced_ui)",
            "    if not computed_fields:",
            "        return \"\"",
            "",
            "    template_code = \"\"",
            "",
            "    for label, value in fields.items():",
            "        escaped_label = escape(label)",
            "        template_code += f\"\"\"",
            "            <tr>",
            "                <td><span title=\"{escaped_label}\">{escaped_label}</span></td>",
            "                <td>{escape(value)}</td>",
            "            <tr>",
            "            \"\"\"",
            "    return mark_safe(template_code)"
        ],
        "afterPatchFile": [
            "from django import template",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.utils.html import format_html_join",
            "",
            "from nautobot.extras.models import ComputedField",
            "",
            "register = template.Library()",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def has_computed_fields(context, obj):",
            "    \"\"\"",
            "    Return a boolean value indicating if an object's content type has associated computed fields.",
            "    \"\"\"",
            "    content_type = ContentType.objects.get_for_model(obj)",
            "    return ComputedField.objects.filter(content_type=content_type).exists()",
            "",
            "",
            "@register.simple_tag(takes_context=True)",
            "def computed_fields(context, obj, advanced_ui=None):",
            "    \"\"\"",
            "    Render all applicable links for the given object.",
            "    This can also check whether the advanced_ui attribute is True or False for UI display purposes.",
            "    \"\"\"",
            "    fields = obj.get_computed_fields(label_as_key=True, advanced_ui=advanced_ui)",
            "    if not computed_fields:",
            "        return \"\"",
            "",
            "    return format_html_join(",
            "        \"\\n\",",
            "        '<tr><td><span title=\"{}\">{}</span></td><td>{}</td></tr>',",
            "        ((label, label, value) for label, value in fields.items()),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "3": [],
            "4": [],
            "30": [
                "computed_fields"
            ],
            "31": [
                "computed_fields"
            ],
            "32": [
                "computed_fields"
            ],
            "33": [
                "computed_fields"
            ],
            "34": [
                "computed_fields"
            ],
            "35": [
                "computed_fields"
            ],
            "36": [
                "computed_fields"
            ],
            "37": [
                "computed_fields"
            ],
            "38": [
                "computed_fields"
            ],
            "39": [
                "computed_fields"
            ],
            "40": [
                "computed_fields"
            ]
        },
        "addLocation": []
    }
}