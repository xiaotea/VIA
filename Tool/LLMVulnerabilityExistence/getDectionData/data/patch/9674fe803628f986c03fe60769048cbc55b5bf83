{
    "starlite/app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         \"get_logger\","
            },
            "1": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         \"logger\","
            },
            "2": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         \"logging_config\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        \"multipart_form_part_limit\","
            },
            "4": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         \"on_shutdown\","
            },
            "5": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         \"on_startup\","
            },
            "6": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         \"openapi_config\","
            },
            "7": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         initial_state: Optional[\"InitialStateType\"] = None,"
            },
            "8": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         logging_config: Union[\"BaseLoggingConfig\", \"EmptyType\", None] = Empty,"
            },
            "9": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         middleware: Optional[List[\"Middleware\"]] = None,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        multipart_form_part_limit: int = 1000,"
            },
            "11": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,"
            },
            "12": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,"
            },
            "13": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         on_startup: Optional[List[\"LifeSpanHandler\"]] = None,"
            },
            "14": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "             initial_state: An object from which to initialize the app state."
            },
            "15": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "             logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`."
            },
            "16": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "             middleware: A list of :class:`Middleware <starlite.types.Middleware>`."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                This limit is intended to protect from DoS attacks."
            },
            "19": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive"
            },
            "20": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "                 an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with"
            },
            "21": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "                 the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more"
            },
            "22": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "             initial_state=initial_state or {},"
            },
            "23": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "             logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,  # type: ignore[arg-type]"
            },
            "24": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "             middleware=middleware or [],"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+            multipart_form_part_limit=multipart_form_part_limit,"
            },
            "26": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "             on_shutdown=on_shutdown or [],"
            },
            "27": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "             on_startup=on_startup or [],"
            },
            "28": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "             openapi_config=openapi_config,"
            },
            "29": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "         self.static_files_config = config.static_files_config"
            },
            "30": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "         self.template_engine = config.template_config.engine_instance if config.template_config else None"
            },
            "31": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "         self.websocket_class = config.websocket_class or WebSocket"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+        self.multipart_form_part_limit = config.multipart_form_part_limit"
            },
            "33": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 352,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "         super().__init__("
            },
            "35": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "             after_request=config.after_request,"
            }
        },
        "frontPatchFile": [
            "from datetime import date, datetime, time, timedelta",
            "from functools import partial",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, Dict, List, Optional, Type, Union, cast",
            "",
            "from pydantic_openapi_schema import construct_open_api_with_schema_class",
            "from typing_extensions import TypedDict",
            "",
            "from starlite.asgi import ASGIRouter",
            "from starlite.asgi.utils import get_route_handlers, wrap_in_exception_handler",
            "from starlite.config import AllowedHostsConfig, AppConfig, CacheConfig, OpenAPIConfig",
            "from starlite.config.logging import LoggingConfig, get_logger_placeholder",
            "from starlite.connection import Request, WebSocket",
            "from starlite.datastructures.state import State",
            "from starlite.exceptions import (",
            "    ImproperlyConfiguredException,",
            "    NoRouteMatchFoundException,",
            ")",
            "from starlite.handlers.http import HTTPRouteHandler",
            "from starlite.middleware.cors import CORSMiddleware",
            "from starlite.openapi.path_item import create_path_item",
            "from starlite.router import Router",
            "from starlite.routes import ASGIRoute, HTTPRoute, WebSocketRoute",
            "from starlite.signature import create_signature_model",
            "from starlite.types import Empty",
            "from starlite.types.internal_types import PathParameterDefinition",
            "from starlite.utils import (",
            "    as_async_callable_list,",
            "    async_partial,",
            "    is_async_callable,",
            "    join_paths,",
            "    unique,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from pydantic_openapi_schema.v3_1_0 import SecurityRequirement",
            "    from pydantic_openapi_schema.v3_1_0.open_api import OpenAPI",
            "",
            "    from starlite.config import (",
            "        BaseLoggingConfig,",
            "        CompressionConfig,",
            "        CORSConfig,",
            "        CSRFConfig,",
            "        StaticFilesConfig,",
            "        TemplateConfig,",
            "    )",
            "    from starlite.datastructures import CacheControlHeader, ETag, Provide",
            "    from starlite.handlers.base import BaseRouteHandler",
            "    from starlite.plugins.base import PluginProtocol",
            "    from starlite.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        ASGIApp,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        EmptyType,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        LifeSpanHandler,",
            "        LifeSpanHookHandler,",
            "        LifeSpanReceive,",
            "        LifeSpanScope,",
            "        LifeSpanSend,",
            "        Logger,",
            "        Message,",
            "        Middleware,",
            "        OnAppInitHandler,",
            "        ParametersMap,",
            "        Receive,",
            "        ResponseCookies,",
            "        ResponseHeadersMap,",
            "        ResponseType,",
            "        RouteHandlerType,",
            "        Scope,",
            "        Send,",
            "        SingleOrList,",
            "        TypeEncodersMap,",
            "    )",
            "    from starlite.types.callable_types import AnyCallable, GetLogger",
            "    from starlite.types.composite_types import InitialStateType",
            "",
            "DEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title=\"Starlite API\", version=\"1.0.0\")",
            "\"\"\"The default OpenAPI config used if not configuration is explicitly passed to the :class:`Starlite",
            "<starlite.app.Starlite>` instance constructor.",
            "\"\"\"",
            "DEFAULT_CACHE_CONFIG = CacheConfig()",
            "\"\"\"The default cache config used if not configuration is explicitly passed to the :class:`Starlite",
            "<starlite.app.Starlite>` instance constructor.",
            "\"\"\"",
            "",
            "",
            "class HandlerIndex(TypedDict):",
            "    \"\"\"Map route handler names to a mapping of paths + route handler.",
            "",
            "    It's returned from the 'get_handler_index_by_name' utility method.",
            "    \"\"\"",
            "",
            "    paths: List[str]",
            "    \"\"\"Full route paths to the route handler.\"\"\"",
            "    handler: \"RouteHandlerType\"",
            "    \"\"\"Route handler instance.\"\"\"",
            "    identifier: str",
            "    \"\"\"Unique identifier of the handler.",
            "",
            "    Either equal to the 'name' attribute or the ``__str__`` value of the handler.",
            "    \"\"\"",
            "",
            "",
            "class Starlite(Router):",
            "    \"\"\"The Starlite application.",
            "",
            "    ``Starlite`` is the root level of the app - it has the base path of \"/\" and all root level",
            "    Controllers, Routers and Route Handlers should be registered on it.",
            "",
            "    Inherits from the :class:`Router <starlite.router.Router>` class",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"after_exception\",",
            "        \"after_shutdown\",",
            "        \"after_startup\",",
            "        \"allowed_hosts\",",
            "        \"asgi_handler\",",
            "        \"asgi_router\",",
            "        \"before_send\",",
            "        \"before_shutdown\",",
            "        \"before_startup\",",
            "        \"cache\",",
            "        \"compression_config\",",
            "        \"cors_config\",",
            "        \"csrf_config\",",
            "        \"debug\",",
            "        \"get_logger\",",
            "        \"logger\",",
            "        \"logging_config\",",
            "        \"on_shutdown\",",
            "        \"on_startup\",",
            "        \"openapi_config\",",
            "        \"openapi_schema\",",
            "        \"plugins\",",
            "        \"request_class\",",
            "        \"route_map\",",
            "        \"state\",",
            "        \"static_files_config\",",
            "        \"template_engine\",",
            "        \"websocket_class\",",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        route_handlers: List[\"ControllerRouterHandler\"],",
            "        *,",
            "        after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,",
            "        after_request: Optional[\"AfterRequestHookHandler\"] = None,",
            "        after_response: Optional[\"AfterResponseHookHandler\"] = None,",
            "        after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,",
            "        before_request: Optional[\"BeforeRequestHookHandler\"] = None,",
            "        before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,",
            "        before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        cache_config: CacheConfig = DEFAULT_CACHE_CONFIG,",
            "        cache_control: Optional[\"CacheControlHeader\"] = None,",
            "        compression_config: Optional[\"CompressionConfig\"] = None,",
            "        cors_config: Optional[\"CORSConfig\"] = None,",
            "        csrf_config: Optional[\"CSRFConfig\"] = None,",
            "        debug: bool = False,",
            "        dependencies: Optional[Dict[str, \"Provide\"]] = None,",
            "        etag: Optional[\"ETag\"] = None,",
            "        exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,",
            "        guards: Optional[List[\"Guard\"]] = None,",
            "        initial_state: Optional[\"InitialStateType\"] = None,",
            "        logging_config: Union[\"BaseLoggingConfig\", \"EmptyType\", None] = Empty,",
            "        middleware: Optional[List[\"Middleware\"]] = None,",
            "        on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,",
            "        on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,",
            "        on_startup: Optional[List[\"LifeSpanHandler\"]] = None,",
            "        openapi_config: Optional[OpenAPIConfig] = DEFAULT_OPENAPI_CONFIG,",
            "        opt: Optional[Dict[str, Any]] = None,",
            "        parameters: Optional[\"ParametersMap\"] = None,",
            "        plugins: Optional[List[\"PluginProtocol\"]] = None,",
            "        request_class: Optional[Type[\"Request\"]] = None,",
            "        response_class: Optional[\"ResponseType\"] = None,",
            "        response_cookies: Optional[\"ResponseCookies\"] = None,",
            "        response_headers: Optional[\"ResponseHeadersMap\"] = None,",
            "        security: Optional[List[\"SecurityRequirement\"]] = None,",
            "        static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,",
            "        tags: Optional[List[str]] = None,",
            "        template_config: Optional[\"TemplateConfig\"] = None,",
            "        type_encoders: Optional[\"TypeEncodersMap\"] = None,",
            "        websocket_class: Optional[Type[\"WebSocket\"]] = None,",
            "    ) -> None:",
            "        \"\"\"Initialize a ``Starlite`` application.",
            "",
            "        Args:",
            "            after_exception: An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>`",
            "                or list thereof.This hook is called after an exception occurs. In difference to exception handlers,",
            "                it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "            after_request: A sync or async function executed after the route handler function returned and the response",
            "                object has been resolved. Receives the response object.",
            "            after_response: A sync or async function called after the response has been awaited. It receives the",
            "                :class:`Request <starlite.connection.Request>` object and should not return any values.",
            "            after_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown'",
            "                list have been called.",
            "            after_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup'",
            "                list have been called.",
            "            allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.",
            "            before_request: A sync or async function called immediately before calling the route handler.",
            "                Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is",
            "                used for the response, bypassing the route handler.",
            "            before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or",
            "                list thereof. This hook is called when the ASGI send function is called.",
            "            before_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown'",
            "                list have been called.",
            "            before_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup'",
            "                list have been called.",
            "            cache_config: Configures caching behavior of the application.",
            "            cache_control: A ``cache-control`` header of type",
            "                :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route handlers of this app.",
            "                Can be overridden by route handlers.",
            "            compression_config: Configures compression behaviour of the application, this enabled a builtin or user",
            "                defined Compression middleware.",
            "            cors_config: If set this enables the builtin CORS middleware.",
            "            csrf_config: If set this enables the builtin CSRF middleware.",
            "            debug: If ``True``, app errors rendered as HTML with a stack trace.",
            "            dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.",
            "            etag: An ``etag`` header of type :class:`ETag <datastructures.ETag>` to add to route handlers of this app.",
            "                Can be overridden by route handlers.",
            "            exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.",
            "            guards: A list of :class:`Guard <starlite.types.Guard>` callables.",
            "            initial_state: An object from which to initialize the app state.",
            "            logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.",
            "            middleware: A list of :class:`Middleware <starlite.types.Middleware>`.",
            "            on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive",
            "                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with",
            "                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more",
            "                than one handler is registered they are called in the order they are provided.",
            "            on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "                application shutdown.",
            "            on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "                application startup.",
            "            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`",
            "            opt: A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or wherever you",
            "                have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.",
            "            parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all",
            "                application paths.",
            "            plugins: List of plugins.",
            "            request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for",
            "                http connections.",
            "            response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.",
            "            response_cookies: A list of [Cookie](starlite.datastructures.Cookie] instances.",
            "            response_headers: A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>`",
            "                instances.",
            "            route_handlers: A required list of route handlers, which can include instances of",
            "                :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or",
            "                any function decorated by the route handler decorators.",
            "            security: A list of dictionaries that will be added to the schema of all route handlers in the application.",
            "                See :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.",
            "            static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`",
            "            tags: A list of string tags that will be appended to the schema of all route handlers under the application.",
            "            template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`",
            "            type_encoders: A mapping of types to callables that transform them into types supported for serialization.",
            "            websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for",
            "                websocket connections.",
            "        \"\"\"",
            "        self.openapi_schema: Optional[\"OpenAPI\"] = None",
            "        self.get_logger: \"GetLogger\" = get_logger_placeholder",
            "        self.logger: Optional[\"Logger\"] = None",
            "        self.routes: List[Union[\"HTTPRoute\", \"ASGIRoute\", \"WebSocketRoute\"]] = []",
            "        self.asgi_router = ASGIRouter(app=self)",
            "",
            "        config = AppConfig(",
            "            after_exception=after_exception or [],",
            "            after_request=after_request,",
            "            after_response=after_response,",
            "            after_shutdown=after_shutdown or [],",
            "            after_startup=after_startup or [],",
            "            allowed_hosts=allowed_hosts or [],",
            "            before_request=before_request,",
            "            before_send=before_send or [],",
            "            before_shutdown=before_shutdown or [],",
            "            before_startup=before_startup or [],",
            "            cache_config=cache_config,",
            "            cache_control=cache_control,",
            "            compression_config=compression_config,",
            "            cors_config=cors_config,",
            "            csrf_config=csrf_config,",
            "            debug=debug,",
            "            dependencies=dependencies or {},",
            "            etag=etag,",
            "            exception_handlers=exception_handlers or {},",
            "            guards=guards or [],",
            "            initial_state=initial_state or {},",
            "            logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,  # type: ignore[arg-type]",
            "            middleware=middleware or [],",
            "            on_shutdown=on_shutdown or [],",
            "            on_startup=on_startup or [],",
            "            openapi_config=openapi_config,",
            "            opt=opt or {},",
            "            parameters=parameters or {},",
            "            plugins=plugins or [],",
            "            request_class=request_class,",
            "            response_class=response_class,",
            "            response_cookies=response_cookies or [],",
            "            response_headers=response_headers or {},",
            "            route_handlers=route_handlers,",
            "            security=security or [],",
            "            static_files_config=static_files_config or [],",
            "            tags=tags or [],",
            "            template_config=template_config,",
            "            type_encoders=type_encoders,",
            "            websocket_class=websocket_class,",
            "        )",
            "        for handler in on_app_init or []:",
            "            config = handler(config)",
            "",
            "        self.allowed_hosts = cast(\"Optional[AllowedHostsConfig]\", config.allowed_hosts)",
            "        self.after_exception = as_async_callable_list(config.after_exception)",
            "        self.after_shutdown = as_async_callable_list(config.after_shutdown)",
            "        self.after_startup = as_async_callable_list(config.after_startup)",
            "        self.before_send = as_async_callable_list(config.before_send)",
            "        self.before_shutdown = as_async_callable_list(config.before_shutdown)",
            "        self.before_startup = as_async_callable_list(config.before_startup)",
            "        self.cache = config.cache_config.to_cache()",
            "        self.compression_config = config.compression_config",
            "        self.cors_config = config.cors_config",
            "        self.csrf_config = config.csrf_config",
            "        self.debug = config.debug",
            "        self.logging_config = config.logging_config",
            "        self.on_shutdown = config.on_shutdown",
            "        self.on_startup = config.on_startup",
            "        self.openapi_config = config.openapi_config",
            "        self.plugins = config.plugins",
            "        self.request_class = config.request_class or Request",
            "        self.state = State(config.initial_state, deep_copy=True)",
            "        self.static_files_config = config.static_files_config",
            "        self.template_engine = config.template_config.engine_instance if config.template_config else None",
            "        self.websocket_class = config.websocket_class or WebSocket",
            "",
            "        super().__init__(",
            "            after_request=config.after_request,",
            "            after_response=config.after_response,",
            "            before_request=config.before_request,",
            "            cache_control=config.cache_control,",
            "            dependencies=config.dependencies,",
            "            etag=config.etag,",
            "            exception_handlers=config.exception_handlers,",
            "            guards=config.guards,",
            "            middleware=config.middleware,",
            "            opt=config.opt,",
            "            parameters=config.parameters,",
            "            path=\"\",",
            "            response_class=config.response_class,",
            "            response_cookies=config.response_cookies,",
            "            response_headers=config.response_headers,",
            "            # route handlers are registered below",
            "            route_handlers=[],",
            "            security=config.security,",
            "            tags=config.tags,",
            "            type_encoders=config.type_encoders,",
            "        )",
            "        for plugin in self.plugins:",
            "            plugin.on_app_init(app=self)",
            "",
            "        for route_handler in config.route_handlers:",
            "            self.register(route_handler)",
            "",
            "        if self.debug and isinstance(self.logging_config, LoggingConfig):",
            "            self.logging_config.loggers[\"starlite\"][\"level\"] = \"DEBUG\"",
            "",
            "        if self.logging_config:",
            "            self.get_logger = self.logging_config.configure()",
            "            self.logger = self.get_logger(\"starlite\")",
            "",
            "        if self.openapi_config:",
            "            self.openapi_schema = self.openapi_config.to_openapi_schema()",
            "            self.update_openapi_schema()",
            "            self.register(self.openapi_config.openapi_controller)",
            "",
            "        for static_config in (",
            "            self.static_files_config if isinstance(self.static_files_config, list) else [self.static_files_config]",
            "        ):",
            "            self.register(static_config.to_static_files_app())",
            "",
            "        self.asgi_handler = self._create_asgi_handler()",
            "",
            "    async def __call__(",
            "        self,",
            "        scope: Union[\"Scope\", \"LifeSpanScope\"],",
            "        receive: Union[\"Receive\", \"LifeSpanReceive\"],",
            "        send: Union[\"Send\", \"LifeSpanSend\"],",
            "    ) -> None:",
            "        \"\"\"Application entry point.",
            "",
            "        Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        scope[\"app\"] = self",
            "        if scope[\"type\"] == \"lifespan\":",
            "            await self.asgi_router.lifespan(receive=receive, send=send)  # type: ignore[arg-type]",
            "            return",
            "        scope[\"state\"] = {}",
            "        await self.asgi_handler(scope, receive, self._wrap_send(send=send, scope=scope))  # type: ignore[arg-type]",
            "",
            "    def register(self, value: \"ControllerRouterHandler\", add_to_openapi_schema: bool = False) -> None:  # type: ignore[override]",
            "        \"\"\"Register a route handler on the app.",
            "",
            "        This method can be used to dynamically add endpoints to an application.",
            "",
            "        Args:",
            "            value: an instance of :class:`Router <starlite.router.Router>`, a subclass of",
            "                :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.",
            "            add_to_openapi_schema: Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route",
            "                handlers.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        routes = super().register(value=value)",
            "",
            "        should_add_to_openapi_schema = False",
            "",
            "        for route in routes:",
            "            route_handlers = get_route_handlers(route)",
            "",
            "            for route_handler in route_handlers:",
            "                self._create_handler_signature_model(route_handler=route_handler)",
            "                self._set_runtime_callables(route_handler=route_handler)",
            "                route_handler.resolve_guards()",
            "                route_handler.resolve_middleware()",
            "                route_handler.resolve_opts()",
            "",
            "                if isinstance(route_handler, HTTPRouteHandler):",
            "                    route_handler.resolve_before_request()",
            "                    route_handler.resolve_after_response()",
            "                    route_handler.resolve_response_handler()",
            "                    should_add_to_openapi_schema = add_to_openapi_schema",
            "",
            "            if isinstance(route, HTTPRoute):",
            "                route.create_handler_map()",
            "",
            "            elif isinstance(route, WebSocketRoute):",
            "                route.handler_parameter_model = route.create_handler_kwargs_model(route.route_handler)",
            "",
            "        self.asgi_router.construct_routing_trie()",
            "",
            "        if should_add_to_openapi_schema:",
            "            self.update_openapi_schema()",
            "",
            "    def get_handler_index_by_name(self, name: str) -> Optional[HandlerIndex]:",
            "        \"\"\"Receives a route handler name and returns an optional dictionary containing the route handler instance and",
            "        list of paths sorted lexically.",
            "",
            "        Examples:",
            "            .. code-block: python",
            "",
            "                from starlite import Starlite, get",
            "",
            "",
            "                @get(\"/\", name=\"my-handler\")",
            "                def handler() -> None:",
            "                    pass",
            "",
            "",
            "                app = Starlite(route_handlers=[handler])",
            "",
            "                handler_index = app.get_handler_index_by_name(\"my-handler\")",
            "",
            "                # { \"paths\": [\"/\"], \"handler\" ... }",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "",
            "        Returns:",
            "            A :class:`HandlerIndex <starlite.app.HandlerIndex>` instance or None.",
            "        \"\"\"",
            "        handler = self.asgi_router.route_handler_index.get(name)",
            "        if not handler:",
            "            return None",
            "",
            "        identifier = handler.name or str(handler)",
            "        routes = self.asgi_router.route_mapping[identifier]",
            "        paths = sorted(unique([route.path for route in routes]))",
            "",
            "        return HandlerIndex(handler=handler, paths=paths, identifier=identifier)",
            "",
            "    def route_reverse(self, name: str, **path_parameters: Any) -> str:",
            "        \"\"\"Receives a route handler name, path parameter values and returns url path to the handler with filled path",
            "        parameters.",
            "",
            "        Examples:",
            "            .. code-block: python",
            "",
            "                from starlite import Starlite, get",
            "",
            "",
            "                @get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")",
            "                def get_membership_details(group_id: int, user_id: int) -> None:",
            "                    pass",
            "",
            "",
            "                app = Starlite(route_handlers=[get_membership_details])",
            "",
            "                path = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)",
            "",
            "                # /group/10/user/100",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "            **path_parameters: Actual values for path parameters in the route.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If route with 'name' does not exist, path parameters are missing in",
            "                ``**path_parameters or have wrong type``.",
            "",
            "        Returns:",
            "            A fully formatted url path.",
            "        \"\"\"",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Route {name} can not be found\")",
            "",
            "        allow_str_instead = {datetime, date, time, timedelta, float, Path}",
            "        output: List[str] = []",
            "",
            "        routes = sorted(",
            "            self.asgi_router.route_mapping[handler_index[\"identifier\"]],",
            "            key=lambda r: len(r.path_parameters),",
            "            reverse=True,",
            "        )",
            "        passed_parameters = set(path_parameters.keys())",
            "",
            "        selected_route = routes[-1]",
            "        for route in routes:",
            "            if passed_parameters.issuperset({param.name for param in route.path_parameters}):",
            "                selected_route = route",
            "                break",
            "",
            "        for component in selected_route.path_components:",
            "            if isinstance(component, PathParameterDefinition):",
            "                val = path_parameters.get(component.name)",
            "                if not (",
            "                    isinstance(val, component.type) or (component.type in allow_str_instead and isinstance(val, str))",
            "                ):",
            "                    raise NoRouteMatchFoundException(",
            "                        f\"Received type for path parameter {component.name} doesn't match declared type {component.type}\"",
            "                    )",
            "                output.append(str(val))",
            "            else:",
            "                output.append(component)",
            "",
            "        return join_paths(output)",
            "",
            "    def url_for_static_asset(self, name: str, file_path: str) -> str:",
            "        \"\"\"Receives a static files handler name, an asset file path and returns resolved url path to the asset.",
            "",
            "        Examples:",
            "            .. code-block: python",
            "",
            "                from starlite import Starlite, StaticFilesConfig",
            "",
            "                app = Starlite(",
            "                    static_files_config=StaticFilesConfig(directories=[\"css\"], path=\"/static/css\")",
            "                )",
            "",
            "                path = app.url_for_static_asset(\"css\", \"main.css\")",
            "",
            "                # /static/css/main.css",
            "",
            "        Args:",
            "            name: A static handler unique name.",
            "            file_path: a string containing path to an asset.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If static files handler with 'name' does not exist.",
            "",
            "        Returns:",
            "            A url path to the asset.",
            "        \"\"\"",
            "        from starlite.static_files.base import StaticFiles",
            "",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Static handler {name} can not be found\")",
            "",
            "        handler_fn = cast(\"AnyCallable\", handler_index[\"handler\"].fn.value)",
            "        if not isinstance(handler_fn, StaticFiles):",
            "            raise NoRouteMatchFoundException(f\"Handler with name {name} is not a static files handler\")",
            "",
            "        return join_paths([handler_index[\"paths\"][0], file_path])  # type: ignore[unreachable]",
            "",
            "    @property",
            "    def route_handler_method_view(self) -> Dict[str, List[str]]:",
            "        \"\"\"Map route handlers to paths.",
            "",
            "        Returns:",
            "            A dictionary of router handlers and lists of paths as strings",
            "        \"\"\"",
            "        route_map: Dict[str, List[str]] = {}",
            "        for handler, routes in self.asgi_router.route_mapping.items():",
            "            route_map[handler] = [route.path for route in routes]",
            "",
            "        return route_map",
            "",
            "    def _create_asgi_handler(self) -> \"ASGIApp\":",
            "        \"\"\"Create an ASGIApp that wraps the ASGI router inside an exception handler.",
            "",
            "        If CORS or TrustedHost configs are provided to the constructor, they will wrap the router as well.",
            "        \"\"\"",
            "        asgi_handler: \"ASGIApp\" = self.asgi_router",
            "        if self.cors_config:",
            "            asgi_handler = CORSMiddleware(app=asgi_handler, config=self.cors_config)",
            "",
            "        return wrap_in_exception_handler(",
            "            debug=self.debug, app=asgi_handler, exception_handlers=self.exception_handlers or {}",
            "        )",
            "",
            "    @staticmethod",
            "    def _set_runtime_callables(route_handler: \"BaseRouteHandler\") -> None:",
            "        \"\"\"Optimize the route_handler.fn and any provider.dependency callables for runtime by doing the following:",
            "",
            "        1. ensure that the ``self`` argument is preserved by binding it using partial.",
            "        2. ensure sync functions are wrapped in AsyncCallable for sync_to_thread handlers.",
            "",
            "        Args:",
            "            route_handler: A route handler to process.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        from starlite.controller import Controller",
            "",
            "        if isinstance(route_handler.owner, Controller) and not hasattr(route_handler.fn.value, \"func\"):",
            "            route_handler.fn.value = partial(route_handler.fn.value, route_handler.owner)",
            "",
            "        if isinstance(route_handler, HTTPRouteHandler):",
            "            route_handler.has_sync_callable = False",
            "            if not is_async_callable(route_handler.fn.value):",
            "                if route_handler.sync_to_thread:",
            "                    route_handler.fn.value = async_partial(route_handler.fn.value)",
            "                else:",
            "                    route_handler.has_sync_callable = True",
            "",
            "        for provider in route_handler.resolve_dependencies().values():",
            "            if not is_async_callable(provider.dependency.value):",
            "                provider.has_sync_callable = False",
            "                if provider.sync_to_thread:",
            "                    provider.dependency.value = async_partial(provider.dependency.value)",
            "                else:",
            "                    provider.has_sync_callable = True",
            "",
            "    def _create_handler_signature_model(self, route_handler: \"BaseRouteHandler\") -> None:",
            "        \"\"\"Create function signature models for all route handler functions and provider dependencies.\"\"\"",
            "        if not route_handler.signature_model:",
            "            route_handler.signature_model = create_signature_model(",
            "                fn=cast(\"AnyCallable\", route_handler.fn.value),",
            "                plugins=self.plugins,",
            "                dependency_name_set=route_handler.dependency_name_set,",
            "            )",
            "",
            "        for provider in route_handler.resolve_dependencies().values():",
            "            if not getattr(provider, \"signature_model\", None):",
            "                provider.signature_model = create_signature_model(",
            "                    fn=provider.dependency.value,",
            "                    plugins=self.plugins,",
            "                    dependency_name_set=route_handler.dependency_name_set,",
            "                )",
            "",
            "    def _wrap_send(self, send: \"Send\", scope: \"Scope\") -> \"Send\":",
            "        \"\"\"Wrap the ASGI send and handles any 'before send' hooks.",
            "",
            "        Args:",
            "            send: The ASGI send function.",
            "",
            "        Returns:",
            "            An ASGI send function.",
            "        \"\"\"",
            "        if self.before_send:",
            "",
            "            async def wrapped_send(message: \"Message\") -> None:",
            "                for hook in self.before_send:",
            "                    if hook.num_expected_args > 2:",
            "                        await hook(message, self.state, scope)",
            "                    else:",
            "                        await hook(message, self.state)",
            "                await send(message)",
            "",
            "            return wrapped_send",
            "        return send",
            "",
            "    def update_openapi_schema(self) -> None:",
            "        \"\"\"Update the OpenAPI schema to reflect the route handlers registered on the app.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if not self.openapi_config or not self.openapi_schema or self.openapi_schema.paths is None:",
            "            raise ImproperlyConfiguredException(\"Cannot generate OpenAPI schema without initializing an OpenAPIConfig\")",
            "",
            "        for route in self.routes:",
            "            if (",
            "                isinstance(route, HTTPRoute)",
            "                and any(route_handler.include_in_schema for route_handler, _ in route.route_handler_map.values())",
            "                and (route.path_format or \"/\") not in self.openapi_schema.paths",
            "            ):",
            "                self.openapi_schema.paths[route.path_format or \"/\"] = create_path_item(",
            "                    route=route,",
            "                    create_examples=self.openapi_config.create_examples,",
            "                    plugins=self.plugins,",
            "                    use_handler_docstrings=self.openapi_config.use_handler_docstrings,",
            "                )",
            "        self.openapi_schema = construct_open_api_with_schema_class(",
            "            open_api_schema=self.openapi_schema, by_alias=self.openapi_config.by_alias",
            "        )"
        ],
        "afterPatchFile": [
            "from datetime import date, datetime, time, timedelta",
            "from functools import partial",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, Dict, List, Optional, Type, Union, cast",
            "",
            "from pydantic_openapi_schema import construct_open_api_with_schema_class",
            "from typing_extensions import TypedDict",
            "",
            "from starlite.asgi import ASGIRouter",
            "from starlite.asgi.utils import get_route_handlers, wrap_in_exception_handler",
            "from starlite.config import AllowedHostsConfig, AppConfig, CacheConfig, OpenAPIConfig",
            "from starlite.config.logging import LoggingConfig, get_logger_placeholder",
            "from starlite.connection import Request, WebSocket",
            "from starlite.datastructures.state import State",
            "from starlite.exceptions import (",
            "    ImproperlyConfiguredException,",
            "    NoRouteMatchFoundException,",
            ")",
            "from starlite.handlers.http import HTTPRouteHandler",
            "from starlite.middleware.cors import CORSMiddleware",
            "from starlite.openapi.path_item import create_path_item",
            "from starlite.router import Router",
            "from starlite.routes import ASGIRoute, HTTPRoute, WebSocketRoute",
            "from starlite.signature import create_signature_model",
            "from starlite.types import Empty",
            "from starlite.types.internal_types import PathParameterDefinition",
            "from starlite.utils import (",
            "    as_async_callable_list,",
            "    async_partial,",
            "    is_async_callable,",
            "    join_paths,",
            "    unique,",
            ")",
            "",
            "if TYPE_CHECKING:",
            "    from pydantic_openapi_schema.v3_1_0 import SecurityRequirement",
            "    from pydantic_openapi_schema.v3_1_0.open_api import OpenAPI",
            "",
            "    from starlite.config import (",
            "        BaseLoggingConfig,",
            "        CompressionConfig,",
            "        CORSConfig,",
            "        CSRFConfig,",
            "        StaticFilesConfig,",
            "        TemplateConfig,",
            "    )",
            "    from starlite.datastructures import CacheControlHeader, ETag, Provide",
            "    from starlite.handlers.base import BaseRouteHandler",
            "    from starlite.plugins.base import PluginProtocol",
            "    from starlite.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        ASGIApp,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        EmptyType,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        LifeSpanHandler,",
            "        LifeSpanHookHandler,",
            "        LifeSpanReceive,",
            "        LifeSpanScope,",
            "        LifeSpanSend,",
            "        Logger,",
            "        Message,",
            "        Middleware,",
            "        OnAppInitHandler,",
            "        ParametersMap,",
            "        Receive,",
            "        ResponseCookies,",
            "        ResponseHeadersMap,",
            "        ResponseType,",
            "        RouteHandlerType,",
            "        Scope,",
            "        Send,",
            "        SingleOrList,",
            "        TypeEncodersMap,",
            "    )",
            "    from starlite.types.callable_types import AnyCallable, GetLogger",
            "    from starlite.types.composite_types import InitialStateType",
            "",
            "DEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title=\"Starlite API\", version=\"1.0.0\")",
            "\"\"\"The default OpenAPI config used if not configuration is explicitly passed to the :class:`Starlite",
            "<starlite.app.Starlite>` instance constructor.",
            "\"\"\"",
            "DEFAULT_CACHE_CONFIG = CacheConfig()",
            "\"\"\"The default cache config used if not configuration is explicitly passed to the :class:`Starlite",
            "<starlite.app.Starlite>` instance constructor.",
            "\"\"\"",
            "",
            "",
            "class HandlerIndex(TypedDict):",
            "    \"\"\"Map route handler names to a mapping of paths + route handler.",
            "",
            "    It's returned from the 'get_handler_index_by_name' utility method.",
            "    \"\"\"",
            "",
            "    paths: List[str]",
            "    \"\"\"Full route paths to the route handler.\"\"\"",
            "    handler: \"RouteHandlerType\"",
            "    \"\"\"Route handler instance.\"\"\"",
            "    identifier: str",
            "    \"\"\"Unique identifier of the handler.",
            "",
            "    Either equal to the 'name' attribute or the ``__str__`` value of the handler.",
            "    \"\"\"",
            "",
            "",
            "class Starlite(Router):",
            "    \"\"\"The Starlite application.",
            "",
            "    ``Starlite`` is the root level of the app - it has the base path of \"/\" and all root level",
            "    Controllers, Routers and Route Handlers should be registered on it.",
            "",
            "    Inherits from the :class:`Router <starlite.router.Router>` class",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"after_exception\",",
            "        \"after_shutdown\",",
            "        \"after_startup\",",
            "        \"allowed_hosts\",",
            "        \"asgi_handler\",",
            "        \"asgi_router\",",
            "        \"before_send\",",
            "        \"before_shutdown\",",
            "        \"before_startup\",",
            "        \"cache\",",
            "        \"compression_config\",",
            "        \"cors_config\",",
            "        \"csrf_config\",",
            "        \"debug\",",
            "        \"get_logger\",",
            "        \"logger\",",
            "        \"logging_config\",",
            "        \"multipart_form_part_limit\",",
            "        \"on_shutdown\",",
            "        \"on_startup\",",
            "        \"openapi_config\",",
            "        \"openapi_schema\",",
            "        \"plugins\",",
            "        \"request_class\",",
            "        \"route_map\",",
            "        \"state\",",
            "        \"static_files_config\",",
            "        \"template_engine\",",
            "        \"websocket_class\",",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        route_handlers: List[\"ControllerRouterHandler\"],",
            "        *,",
            "        after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,",
            "        after_request: Optional[\"AfterRequestHookHandler\"] = None,",
            "        after_response: Optional[\"AfterResponseHookHandler\"] = None,",
            "        after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,",
            "        before_request: Optional[\"BeforeRequestHookHandler\"] = None,",
            "        before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,",
            "        before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "        cache_config: CacheConfig = DEFAULT_CACHE_CONFIG,",
            "        cache_control: Optional[\"CacheControlHeader\"] = None,",
            "        compression_config: Optional[\"CompressionConfig\"] = None,",
            "        cors_config: Optional[\"CORSConfig\"] = None,",
            "        csrf_config: Optional[\"CSRFConfig\"] = None,",
            "        debug: bool = False,",
            "        dependencies: Optional[Dict[str, \"Provide\"]] = None,",
            "        etag: Optional[\"ETag\"] = None,",
            "        exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,",
            "        guards: Optional[List[\"Guard\"]] = None,",
            "        initial_state: Optional[\"InitialStateType\"] = None,",
            "        logging_config: Union[\"BaseLoggingConfig\", \"EmptyType\", None] = Empty,",
            "        middleware: Optional[List[\"Middleware\"]] = None,",
            "        multipart_form_part_limit: int = 1000,",
            "        on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,",
            "        on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,",
            "        on_startup: Optional[List[\"LifeSpanHandler\"]] = None,",
            "        openapi_config: Optional[OpenAPIConfig] = DEFAULT_OPENAPI_CONFIG,",
            "        opt: Optional[Dict[str, Any]] = None,",
            "        parameters: Optional[\"ParametersMap\"] = None,",
            "        plugins: Optional[List[\"PluginProtocol\"]] = None,",
            "        request_class: Optional[Type[\"Request\"]] = None,",
            "        response_class: Optional[\"ResponseType\"] = None,",
            "        response_cookies: Optional[\"ResponseCookies\"] = None,",
            "        response_headers: Optional[\"ResponseHeadersMap\"] = None,",
            "        security: Optional[List[\"SecurityRequirement\"]] = None,",
            "        static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,",
            "        tags: Optional[List[str]] = None,",
            "        template_config: Optional[\"TemplateConfig\"] = None,",
            "        type_encoders: Optional[\"TypeEncodersMap\"] = None,",
            "        websocket_class: Optional[Type[\"WebSocket\"]] = None,",
            "    ) -> None:",
            "        \"\"\"Initialize a ``Starlite`` application.",
            "",
            "        Args:",
            "            after_exception: An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>`",
            "                or list thereof.This hook is called after an exception occurs. In difference to exception handlers,",
            "                it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "            after_request: A sync or async function executed after the route handler function returned and the response",
            "                object has been resolved. Receives the response object.",
            "            after_response: A sync or async function called after the response has been awaited. It receives the",
            "                :class:`Request <starlite.connection.Request>` object and should not return any values.",
            "            after_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown'",
            "                list have been called.",
            "            after_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup'",
            "                list have been called.",
            "            allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.",
            "            before_request: A sync or async function called immediately before calling the route handler.",
            "                Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is",
            "                used for the response, bypassing the route handler.",
            "            before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or",
            "                list thereof. This hook is called when the ASGI send function is called.",
            "            before_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown'",
            "                list have been called.",
            "            before_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or",
            "                list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup'",
            "                list have been called.",
            "            cache_config: Configures caching behavior of the application.",
            "            cache_control: A ``cache-control`` header of type",
            "                :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route handlers of this app.",
            "                Can be overridden by route handlers.",
            "            compression_config: Configures compression behaviour of the application, this enabled a builtin or user",
            "                defined Compression middleware.",
            "            cors_config: If set this enables the builtin CORS middleware.",
            "            csrf_config: If set this enables the builtin CSRF middleware.",
            "            debug: If ``True``, app errors rendered as HTML with a stack trace.",
            "            dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.",
            "            etag: An ``etag`` header of type :class:`ETag <datastructures.ETag>` to add to route handlers of this app.",
            "                Can be overridden by route handlers.",
            "            exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.",
            "            guards: A list of :class:`Guard <starlite.types.Guard>` callables.",
            "            initial_state: An object from which to initialize the app state.",
            "            logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.",
            "            middleware: A list of :class:`Middleware <starlite.types.Middleware>`.",
            "            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.",
            "                This limit is intended to protect from DoS attacks.",
            "            on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive",
            "                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with",
            "                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more",
            "                than one handler is registered they are called in the order they are provided.",
            "            on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "                application shutdown.",
            "            on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "                application startup.",
            "            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`",
            "            opt: A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or wherever you",
            "                have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.",
            "            parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all",
            "                application paths.",
            "            plugins: List of plugins.",
            "            request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for",
            "                http connections.",
            "            response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.",
            "            response_cookies: A list of [Cookie](starlite.datastructures.Cookie] instances.",
            "            response_headers: A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>`",
            "                instances.",
            "            route_handlers: A required list of route handlers, which can include instances of",
            "                :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or",
            "                any function decorated by the route handler decorators.",
            "            security: A list of dictionaries that will be added to the schema of all route handlers in the application.",
            "                See :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.",
            "            static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`",
            "            tags: A list of string tags that will be appended to the schema of all route handlers under the application.",
            "            template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`",
            "            type_encoders: A mapping of types to callables that transform them into types supported for serialization.",
            "            websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for",
            "                websocket connections.",
            "        \"\"\"",
            "        self.openapi_schema: Optional[\"OpenAPI\"] = None",
            "        self.get_logger: \"GetLogger\" = get_logger_placeholder",
            "        self.logger: Optional[\"Logger\"] = None",
            "        self.routes: List[Union[\"HTTPRoute\", \"ASGIRoute\", \"WebSocketRoute\"]] = []",
            "        self.asgi_router = ASGIRouter(app=self)",
            "",
            "        config = AppConfig(",
            "            after_exception=after_exception or [],",
            "            after_request=after_request,",
            "            after_response=after_response,",
            "            after_shutdown=after_shutdown or [],",
            "            after_startup=after_startup or [],",
            "            allowed_hosts=allowed_hosts or [],",
            "            before_request=before_request,",
            "            before_send=before_send or [],",
            "            before_shutdown=before_shutdown or [],",
            "            before_startup=before_startup or [],",
            "            cache_config=cache_config,",
            "            cache_control=cache_control,",
            "            compression_config=compression_config,",
            "            cors_config=cors_config,",
            "            csrf_config=csrf_config,",
            "            debug=debug,",
            "            dependencies=dependencies or {},",
            "            etag=etag,",
            "            exception_handlers=exception_handlers or {},",
            "            guards=guards or [],",
            "            initial_state=initial_state or {},",
            "            logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,  # type: ignore[arg-type]",
            "            middleware=middleware or [],",
            "            multipart_form_part_limit=multipart_form_part_limit,",
            "            on_shutdown=on_shutdown or [],",
            "            on_startup=on_startup or [],",
            "            openapi_config=openapi_config,",
            "            opt=opt or {},",
            "            parameters=parameters or {},",
            "            plugins=plugins or [],",
            "            request_class=request_class,",
            "            response_class=response_class,",
            "            response_cookies=response_cookies or [],",
            "            response_headers=response_headers or {},",
            "            route_handlers=route_handlers,",
            "            security=security or [],",
            "            static_files_config=static_files_config or [],",
            "            tags=tags or [],",
            "            template_config=template_config,",
            "            type_encoders=type_encoders,",
            "            websocket_class=websocket_class,",
            "        )",
            "        for handler in on_app_init or []:",
            "            config = handler(config)",
            "",
            "        self.allowed_hosts = cast(\"Optional[AllowedHostsConfig]\", config.allowed_hosts)",
            "        self.after_exception = as_async_callable_list(config.after_exception)",
            "        self.after_shutdown = as_async_callable_list(config.after_shutdown)",
            "        self.after_startup = as_async_callable_list(config.after_startup)",
            "        self.before_send = as_async_callable_list(config.before_send)",
            "        self.before_shutdown = as_async_callable_list(config.before_shutdown)",
            "        self.before_startup = as_async_callable_list(config.before_startup)",
            "        self.cache = config.cache_config.to_cache()",
            "        self.compression_config = config.compression_config",
            "        self.cors_config = config.cors_config",
            "        self.csrf_config = config.csrf_config",
            "        self.debug = config.debug",
            "        self.logging_config = config.logging_config",
            "        self.on_shutdown = config.on_shutdown",
            "        self.on_startup = config.on_startup",
            "        self.openapi_config = config.openapi_config",
            "        self.plugins = config.plugins",
            "        self.request_class = config.request_class or Request",
            "        self.state = State(config.initial_state, deep_copy=True)",
            "        self.static_files_config = config.static_files_config",
            "        self.template_engine = config.template_config.engine_instance if config.template_config else None",
            "        self.websocket_class = config.websocket_class or WebSocket",
            "        self.multipart_form_part_limit = config.multipart_form_part_limit",
            "",
            "        super().__init__(",
            "            after_request=config.after_request,",
            "            after_response=config.after_response,",
            "            before_request=config.before_request,",
            "            cache_control=config.cache_control,",
            "            dependencies=config.dependencies,",
            "            etag=config.etag,",
            "            exception_handlers=config.exception_handlers,",
            "            guards=config.guards,",
            "            middleware=config.middleware,",
            "            opt=config.opt,",
            "            parameters=config.parameters,",
            "            path=\"\",",
            "            response_class=config.response_class,",
            "            response_cookies=config.response_cookies,",
            "            response_headers=config.response_headers,",
            "            # route handlers are registered below",
            "            route_handlers=[],",
            "            security=config.security,",
            "            tags=config.tags,",
            "            type_encoders=config.type_encoders,",
            "        )",
            "        for plugin in self.plugins:",
            "            plugin.on_app_init(app=self)",
            "",
            "        for route_handler in config.route_handlers:",
            "            self.register(route_handler)",
            "",
            "        if self.debug and isinstance(self.logging_config, LoggingConfig):",
            "            self.logging_config.loggers[\"starlite\"][\"level\"] = \"DEBUG\"",
            "",
            "        if self.logging_config:",
            "            self.get_logger = self.logging_config.configure()",
            "            self.logger = self.get_logger(\"starlite\")",
            "",
            "        if self.openapi_config:",
            "            self.openapi_schema = self.openapi_config.to_openapi_schema()",
            "            self.update_openapi_schema()",
            "            self.register(self.openapi_config.openapi_controller)",
            "",
            "        for static_config in (",
            "            self.static_files_config if isinstance(self.static_files_config, list) else [self.static_files_config]",
            "        ):",
            "            self.register(static_config.to_static_files_app())",
            "",
            "        self.asgi_handler = self._create_asgi_handler()",
            "",
            "    async def __call__(",
            "        self,",
            "        scope: Union[\"Scope\", \"LifeSpanScope\"],",
            "        receive: Union[\"Receive\", \"LifeSpanReceive\"],",
            "        send: Union[\"Send\", \"LifeSpanSend\"],",
            "    ) -> None:",
            "        \"\"\"Application entry point.",
            "",
            "        Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        scope[\"app\"] = self",
            "        if scope[\"type\"] == \"lifespan\":",
            "            await self.asgi_router.lifespan(receive=receive, send=send)  # type: ignore[arg-type]",
            "            return",
            "        scope[\"state\"] = {}",
            "        await self.asgi_handler(scope, receive, self._wrap_send(send=send, scope=scope))  # type: ignore[arg-type]",
            "",
            "    def register(self, value: \"ControllerRouterHandler\", add_to_openapi_schema: bool = False) -> None:  # type: ignore[override]",
            "        \"\"\"Register a route handler on the app.",
            "",
            "        This method can be used to dynamically add endpoints to an application.",
            "",
            "        Args:",
            "            value: an instance of :class:`Router <starlite.router.Router>`, a subclass of",
            "                :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.",
            "            add_to_openapi_schema: Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route",
            "                handlers.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        routes = super().register(value=value)",
            "",
            "        should_add_to_openapi_schema = False",
            "",
            "        for route in routes:",
            "            route_handlers = get_route_handlers(route)",
            "",
            "            for route_handler in route_handlers:",
            "                self._create_handler_signature_model(route_handler=route_handler)",
            "                self._set_runtime_callables(route_handler=route_handler)",
            "                route_handler.resolve_guards()",
            "                route_handler.resolve_middleware()",
            "                route_handler.resolve_opts()",
            "",
            "                if isinstance(route_handler, HTTPRouteHandler):",
            "                    route_handler.resolve_before_request()",
            "                    route_handler.resolve_after_response()",
            "                    route_handler.resolve_response_handler()",
            "                    should_add_to_openapi_schema = add_to_openapi_schema",
            "",
            "            if isinstance(route, HTTPRoute):",
            "                route.create_handler_map()",
            "",
            "            elif isinstance(route, WebSocketRoute):",
            "                route.handler_parameter_model = route.create_handler_kwargs_model(route.route_handler)",
            "",
            "        self.asgi_router.construct_routing_trie()",
            "",
            "        if should_add_to_openapi_schema:",
            "            self.update_openapi_schema()",
            "",
            "    def get_handler_index_by_name(self, name: str) -> Optional[HandlerIndex]:",
            "        \"\"\"Receives a route handler name and returns an optional dictionary containing the route handler instance and",
            "        list of paths sorted lexically.",
            "",
            "        Examples:",
            "            .. code-block: python",
            "",
            "                from starlite import Starlite, get",
            "",
            "",
            "                @get(\"/\", name=\"my-handler\")",
            "                def handler() -> None:",
            "                    pass",
            "",
            "",
            "                app = Starlite(route_handlers=[handler])",
            "",
            "                handler_index = app.get_handler_index_by_name(\"my-handler\")",
            "",
            "                # { \"paths\": [\"/\"], \"handler\" ... }",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "",
            "        Returns:",
            "            A :class:`HandlerIndex <starlite.app.HandlerIndex>` instance or None.",
            "        \"\"\"",
            "        handler = self.asgi_router.route_handler_index.get(name)",
            "        if not handler:",
            "            return None",
            "",
            "        identifier = handler.name or str(handler)",
            "        routes = self.asgi_router.route_mapping[identifier]",
            "        paths = sorted(unique([route.path for route in routes]))",
            "",
            "        return HandlerIndex(handler=handler, paths=paths, identifier=identifier)",
            "",
            "    def route_reverse(self, name: str, **path_parameters: Any) -> str:",
            "        \"\"\"Receives a route handler name, path parameter values and returns url path to the handler with filled path",
            "        parameters.",
            "",
            "        Examples:",
            "            .. code-block: python",
            "",
            "                from starlite import Starlite, get",
            "",
            "",
            "                @get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")",
            "                def get_membership_details(group_id: int, user_id: int) -> None:",
            "                    pass",
            "",
            "",
            "                app = Starlite(route_handlers=[get_membership_details])",
            "",
            "                path = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)",
            "",
            "                # /group/10/user/100",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "            **path_parameters: Actual values for path parameters in the route.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If route with 'name' does not exist, path parameters are missing in",
            "                ``**path_parameters or have wrong type``.",
            "",
            "        Returns:",
            "            A fully formatted url path.",
            "        \"\"\"",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Route {name} can not be found\")",
            "",
            "        allow_str_instead = {datetime, date, time, timedelta, float, Path}",
            "        output: List[str] = []",
            "",
            "        routes = sorted(",
            "            self.asgi_router.route_mapping[handler_index[\"identifier\"]],",
            "            key=lambda r: len(r.path_parameters),",
            "            reverse=True,",
            "        )",
            "        passed_parameters = set(path_parameters.keys())",
            "",
            "        selected_route = routes[-1]",
            "        for route in routes:",
            "            if passed_parameters.issuperset({param.name for param in route.path_parameters}):",
            "                selected_route = route",
            "                break",
            "",
            "        for component in selected_route.path_components:",
            "            if isinstance(component, PathParameterDefinition):",
            "                val = path_parameters.get(component.name)",
            "                if not (",
            "                    isinstance(val, component.type) or (component.type in allow_str_instead and isinstance(val, str))",
            "                ):",
            "                    raise NoRouteMatchFoundException(",
            "                        f\"Received type for path parameter {component.name} doesn't match declared type {component.type}\"",
            "                    )",
            "                output.append(str(val))",
            "            else:",
            "                output.append(component)",
            "",
            "        return join_paths(output)",
            "",
            "    def url_for_static_asset(self, name: str, file_path: str) -> str:",
            "        \"\"\"Receives a static files handler name, an asset file path and returns resolved url path to the asset.",
            "",
            "        Examples:",
            "            .. code-block: python",
            "",
            "                from starlite import Starlite, StaticFilesConfig",
            "",
            "                app = Starlite(",
            "                    static_files_config=StaticFilesConfig(directories=[\"css\"], path=\"/static/css\")",
            "                )",
            "",
            "                path = app.url_for_static_asset(\"css\", \"main.css\")",
            "",
            "                # /static/css/main.css",
            "",
            "        Args:",
            "            name: A static handler unique name.",
            "            file_path: a string containing path to an asset.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If static files handler with 'name' does not exist.",
            "",
            "        Returns:",
            "            A url path to the asset.",
            "        \"\"\"",
            "        from starlite.static_files.base import StaticFiles",
            "",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Static handler {name} can not be found\")",
            "",
            "        handler_fn = cast(\"AnyCallable\", handler_index[\"handler\"].fn.value)",
            "        if not isinstance(handler_fn, StaticFiles):",
            "            raise NoRouteMatchFoundException(f\"Handler with name {name} is not a static files handler\")",
            "",
            "        return join_paths([handler_index[\"paths\"][0], file_path])  # type: ignore[unreachable]",
            "",
            "    @property",
            "    def route_handler_method_view(self) -> Dict[str, List[str]]:",
            "        \"\"\"Map route handlers to paths.",
            "",
            "        Returns:",
            "            A dictionary of router handlers and lists of paths as strings",
            "        \"\"\"",
            "        route_map: Dict[str, List[str]] = {}",
            "        for handler, routes in self.asgi_router.route_mapping.items():",
            "            route_map[handler] = [route.path for route in routes]",
            "",
            "        return route_map",
            "",
            "    def _create_asgi_handler(self) -> \"ASGIApp\":",
            "        \"\"\"Create an ASGIApp that wraps the ASGI router inside an exception handler.",
            "",
            "        If CORS or TrustedHost configs are provided to the constructor, they will wrap the router as well.",
            "        \"\"\"",
            "        asgi_handler: \"ASGIApp\" = self.asgi_router",
            "        if self.cors_config:",
            "            asgi_handler = CORSMiddleware(app=asgi_handler, config=self.cors_config)",
            "",
            "        return wrap_in_exception_handler(",
            "            debug=self.debug, app=asgi_handler, exception_handlers=self.exception_handlers or {}",
            "        )",
            "",
            "    @staticmethod",
            "    def _set_runtime_callables(route_handler: \"BaseRouteHandler\") -> None:",
            "        \"\"\"Optimize the route_handler.fn and any provider.dependency callables for runtime by doing the following:",
            "",
            "        1. ensure that the ``self`` argument is preserved by binding it using partial.",
            "        2. ensure sync functions are wrapped in AsyncCallable for sync_to_thread handlers.",
            "",
            "        Args:",
            "            route_handler: A route handler to process.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        from starlite.controller import Controller",
            "",
            "        if isinstance(route_handler.owner, Controller) and not hasattr(route_handler.fn.value, \"func\"):",
            "            route_handler.fn.value = partial(route_handler.fn.value, route_handler.owner)",
            "",
            "        if isinstance(route_handler, HTTPRouteHandler):",
            "            route_handler.has_sync_callable = False",
            "            if not is_async_callable(route_handler.fn.value):",
            "                if route_handler.sync_to_thread:",
            "                    route_handler.fn.value = async_partial(route_handler.fn.value)",
            "                else:",
            "                    route_handler.has_sync_callable = True",
            "",
            "        for provider in route_handler.resolve_dependencies().values():",
            "            if not is_async_callable(provider.dependency.value):",
            "                provider.has_sync_callable = False",
            "                if provider.sync_to_thread:",
            "                    provider.dependency.value = async_partial(provider.dependency.value)",
            "                else:",
            "                    provider.has_sync_callable = True",
            "",
            "    def _create_handler_signature_model(self, route_handler: \"BaseRouteHandler\") -> None:",
            "        \"\"\"Create function signature models for all route handler functions and provider dependencies.\"\"\"",
            "        if not route_handler.signature_model:",
            "            route_handler.signature_model = create_signature_model(",
            "                fn=cast(\"AnyCallable\", route_handler.fn.value),",
            "                plugins=self.plugins,",
            "                dependency_name_set=route_handler.dependency_name_set,",
            "            )",
            "",
            "        for provider in route_handler.resolve_dependencies().values():",
            "            if not getattr(provider, \"signature_model\", None):",
            "                provider.signature_model = create_signature_model(",
            "                    fn=provider.dependency.value,",
            "                    plugins=self.plugins,",
            "                    dependency_name_set=route_handler.dependency_name_set,",
            "                )",
            "",
            "    def _wrap_send(self, send: \"Send\", scope: \"Scope\") -> \"Send\":",
            "        \"\"\"Wrap the ASGI send and handles any 'before send' hooks.",
            "",
            "        Args:",
            "            send: The ASGI send function.",
            "",
            "        Returns:",
            "            An ASGI send function.",
            "        \"\"\"",
            "        if self.before_send:",
            "",
            "            async def wrapped_send(message: \"Message\") -> None:",
            "                for hook in self.before_send:",
            "                    if hook.num_expected_args > 2:",
            "                        await hook(message, self.state, scope)",
            "                    else:",
            "                        await hook(message, self.state)",
            "                await send(message)",
            "",
            "            return wrapped_send",
            "        return send",
            "",
            "    def update_openapi_schema(self) -> None:",
            "        \"\"\"Update the OpenAPI schema to reflect the route handlers registered on the app.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if not self.openapi_config or not self.openapi_schema or self.openapi_schema.paths is None:",
            "            raise ImproperlyConfiguredException(\"Cannot generate OpenAPI schema without initializing an OpenAPIConfig\")",
            "",
            "        for route in self.routes:",
            "            if (",
            "                isinstance(route, HTTPRoute)",
            "                and any(route_handler.include_in_schema for route_handler, _ in route.route_handler_map.values())",
            "                and (route.path_format or \"/\") not in self.openapi_schema.paths",
            "            ):",
            "                self.openapi_schema.paths[route.path_format or \"/\"] = create_path_item(",
            "                    route=route,",
            "                    create_examples=self.openapi_config.create_examples,",
            "                    plugins=self.plugins,",
            "                    use_handler_docstrings=self.openapi_config.use_handler_docstrings,",
            "                )",
            "        self.openapi_schema = construct_open_api_with_schema_class(",
            "            open_api_schema=self.openapi_schema, by_alias=self.openapi_config.by_alias",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "starlite.app.Starlite.self",
            "starlite.app.Starlite",
            "label_studio.core.settings.base"
        ]
    },
    "starlite/config/app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "     \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "     websocket_class: Optional[Type[WebSocket]]"
            },
            "2": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     \"\"\"An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for websocket connections.\"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    multipart_form_part_limit: int"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "     @validator(\"allowed_hosts\", always=True)"
            },
            "7": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     def validate_allowed_hosts(  # pylint: disable=no-self-argument"
            }
        },
        "frontPatchFile": [
            "from typing import Any, Dict, List, Optional, Type, Union",
            "",
            "from pydantic import BaseConfig, BaseModel, validator",
            "from pydantic_openapi_schema.v3_1_0 import SecurityRequirement",
            "",
            "from starlite.connection import Request, WebSocket",
            "from starlite.datastructures import CacheControlHeader, ETag, Provide",
            "from starlite.plugins.base import PluginProtocol",
            "from starlite.types import (",
            "    AfterExceptionHookHandler,",
            "    AfterRequestHookHandler,",
            "    AfterResponseHookHandler,",
            "    BeforeMessageSendHookHandler,",
            "    BeforeRequestHookHandler,",
            "    ControllerRouterHandler,",
            "    ExceptionHandlersMap,",
            "    Guard,",
            "    LifeSpanHandler,",
            "    LifeSpanHookHandler,",
            "    Middleware,",
            "    ParametersMap,",
            "    ResponseCookies,",
            "    ResponseHeadersMap,",
            "    ResponseType,",
            "    SingleOrList,",
            "    TypeEncodersMap,",
            ")",
            "from starlite.types.composite_types import InitialStateType",
            "",
            "from . import AllowedHostsConfig",
            "from .cache import CacheConfig",
            "from .compression import CompressionConfig",
            "from .cors import CORSConfig",
            "from .csrf import CSRFConfig",
            "from .logging import BaseLoggingConfig",
            "from .openapi import OpenAPIConfig",
            "from .static_files import StaticFilesConfig",
            "from .template import TemplateConfig",
            "",
            "",
            "class AppConfig(BaseModel):",
            "    \"\"\"The parameters provided to the ``Starlite`` app are used to instantiate an instance, and then the instance is",
            "    passed to any callbacks registered to ``on_app_init`` in the order they are provided.",
            "",
            "    The final attribute values are used to instantiate the application object.",
            "    \"\"\"",
            "",
            "    class Config(BaseConfig):",
            "        arbitrary_types_allowed = True",
            "",
            "    after_exception: SingleOrList[AfterExceptionHookHandler]",
            "    \"\"\"An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>` or list thereof.",
            "",
            "    This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a",
            "    response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "    \"\"\"",
            "    after_request: Optional[AfterRequestHookHandler]",
            "    \"\"\"A sync or async function executed after the route handler function returned and the response object has been",
            "    resolved.",
            "",
            "    Receives the response object which may be any subclass of :class:`Response <starlite.response.Response>`.",
            "    \"\"\"",
            "    after_response: Optional[AfterResponseHookHandler]",
            "    \"\"\"A sync or async function called after the response has been awaited. It receives the.",
            "",
            "    :class:`Request <starlite.connection.Request>` object and should not return any values.",
            "    \"\"\"",
            "    after_shutdown: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.",
            "    \"\"\"",
            "    after_startup: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.",
            "    \"\"\"",
            "    allowed_hosts: Optional[Union[List[str], AllowedHostsConfig]]",
            "    \"\"\"If set enables the builtin allowed hosts middleware.\"\"\"",
            "    before_request: Optional[BeforeRequestHookHandler]",
            "    \"\"\"A sync or async function called immediately before calling the route handler. Receives the.",
            "",
            "    :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is used for the response, bypassing",
            "    the route handler.",
            "    \"\"\"",
            "    before_send: SingleOrList[BeforeMessageSendHookHandler]",
            "    \"\"\"An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or list thereof.",
            "",
            "    This hook is called when the ASGI send function is called.",
            "    \"\"\"",
            "    before_shutdown: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.",
            "    \"\"\"",
            "    before_startup: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.",
            "    \"\"\"",
            "    cache_config: CacheConfig",
            "    \"\"\"Configures caching behavior of the application.\"\"\"",
            "    cache_control: Optional[CacheControlHeader]",
            "    \"\"\"A ``cache-control`` header of type :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route",
            "    handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    compression_config: Optional[CompressionConfig]",
            "    \"\"\"Configures compression behaviour of the application, this enabled a builtin or user defined Compression",
            "    middleware.",
            "    \"\"\"",
            "    cors_config: Optional[CORSConfig]",
            "    \"\"\"If set this enables the builtin CORS middleware.\"\"\"",
            "    csrf_config: Optional[CSRFConfig]",
            "    \"\"\"If set this enables the builtin CSRF middleware.\"\"\"",
            "    debug: bool",
            "    \"\"\"If ``True``, app errors rendered as HTML with a stack trace.\"\"\"",
            "    dependencies: Dict[str, Provide]",
            "    \"\"\"A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\"\"\"",
            "    etag: Optional[ETag]",
            "    \"\"\"An ``etag`` header of type :class:`ETag <starlite.datastructures.ETag>` to add to route handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    exception_handlers: ExceptionHandlersMap",
            "    \"\"\"A dictionary that maps handler functions to status codes and/or exception types.\"\"\"",
            "    guards: List[Guard]",
            "    \"\"\"A list of :class:`Guard <starlite.types.Guard>` callables.\"\"\"",
            "    initial_state: InitialStateType",
            "    \"\"\"An object from which to initialize the app state.\"\"\"",
            "    logging_config: Optional[BaseLoggingConfig]",
            "    \"\"\"An instance of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>` subclass.\"\"\"",
            "    middleware: List[Middleware]",
            "    \"\"\"A list of :class:`Middleware <starlite.types.Middleware>`.\"\"\"",
            "    on_shutdown: List[LifeSpanHandler]",
            "    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application shutdown.\"\"\"",
            "    on_startup: List[LifeSpanHandler]",
            "    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application startup.\"\"\"",
            "    openapi_config: Optional[OpenAPIConfig]",
            "    \"\"\"Defaults to :data:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`\"\"\"",
            "    opt: Dict[str, Any]",
            "    \"\"\"A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or",
            "    wherever you have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.",
            "",
            "    Can be overridden by routers and router handlers.",
            "    \"\"\"",
            "    parameters: ParametersMap",
            "    \"\"\"A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all application paths.\"\"\"",
            "    plugins: List[PluginProtocol]",
            "    \"\"\"List of :class:`PluginProtocol <starlite.plugins.base.PluginProtocol>`.\"\"\"",
            "    request_class: Optional[Type[Request]]",
            "    \"\"\"An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for http connections.\"\"\"",
            "    response_class: Optional[ResponseType]",
            "    \"\"\"A custom subclass of [starlite.response.Response] to be used as the app's default response.\"\"\"",
            "    response_cookies: ResponseCookies",
            "    \"\"\"A list of [Cookie](starlite.datastructures.Cookie] instances.\"\"\"",
            "    response_headers: ResponseHeadersMap",
            "    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>` instances.\"\"\"",
            "    route_handlers: List[ControllerRouterHandler]",
            "    \"\"\"A required list of route handlers, which can include instances of :class:`Router <starlite.router.Router>`, subclasses",
            "    of.",
            "",
            "    :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.",
            "    \"\"\"",
            "    security: List[SecurityRequirement]",
            "    \"\"\"A list of dictionaries that will be added to the schema of all route handlers in the application. See.",
            "",
            "    :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.",
            "    \"\"\"",
            "    static_files_config: SingleOrList[StaticFilesConfig]",
            "    \"\"\"An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`.\"\"\"",
            "    tags: List[str]",
            "    \"\"\"A list of string tags that will be appended to the schema of all route handlers under the application.\"\"\"",
            "    template_config: Optional[TemplateConfig]",
            "    \"\"\"An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`.\"\"\"",
            "    type_encoders: Optional[TypeEncodersMap] = None",
            "    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"",
            "    websocket_class: Optional[Type[WebSocket]]",
            "    \"\"\"An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for websocket connections.\"\"\"",
            "",
            "    @validator(\"allowed_hosts\", always=True)",
            "    def validate_allowed_hosts(  # pylint: disable=no-self-argument",
            "        cls, value: Optional[Union[List[str], AllowedHostsConfig]]",
            "    ) -> Optional[AllowedHostsConfig]:",
            "        \"\"\"Normalize the allowed hosts to be a config or None.",
            "",
            "        Args:",
            "            value: Optional a list of hosts or allowed hosts config",
            "",
            "        Returns:",
            "            Optional config.",
            "        \"\"\"",
            "        if value:",
            "            if isinstance(value, list):",
            "                return AllowedHostsConfig(allowed_hosts=value)",
            "            return value",
            "        return None"
        ],
        "afterPatchFile": [
            "from typing import Any, Dict, List, Optional, Type, Union",
            "",
            "from pydantic import BaseConfig, BaseModel, validator",
            "from pydantic_openapi_schema.v3_1_0 import SecurityRequirement",
            "",
            "from starlite.connection import Request, WebSocket",
            "from starlite.datastructures import CacheControlHeader, ETag, Provide",
            "from starlite.plugins.base import PluginProtocol",
            "from starlite.types import (",
            "    AfterExceptionHookHandler,",
            "    AfterRequestHookHandler,",
            "    AfterResponseHookHandler,",
            "    BeforeMessageSendHookHandler,",
            "    BeforeRequestHookHandler,",
            "    ControllerRouterHandler,",
            "    ExceptionHandlersMap,",
            "    Guard,",
            "    LifeSpanHandler,",
            "    LifeSpanHookHandler,",
            "    Middleware,",
            "    ParametersMap,",
            "    ResponseCookies,",
            "    ResponseHeadersMap,",
            "    ResponseType,",
            "    SingleOrList,",
            "    TypeEncodersMap,",
            ")",
            "from starlite.types.composite_types import InitialStateType",
            "",
            "from . import AllowedHostsConfig",
            "from .cache import CacheConfig",
            "from .compression import CompressionConfig",
            "from .cors import CORSConfig",
            "from .csrf import CSRFConfig",
            "from .logging import BaseLoggingConfig",
            "from .openapi import OpenAPIConfig",
            "from .static_files import StaticFilesConfig",
            "from .template import TemplateConfig",
            "",
            "",
            "class AppConfig(BaseModel):",
            "    \"\"\"The parameters provided to the ``Starlite`` app are used to instantiate an instance, and then the instance is",
            "    passed to any callbacks registered to ``on_app_init`` in the order they are provided.",
            "",
            "    The final attribute values are used to instantiate the application object.",
            "    \"\"\"",
            "",
            "    class Config(BaseConfig):",
            "        arbitrary_types_allowed = True",
            "",
            "    after_exception: SingleOrList[AfterExceptionHookHandler]",
            "    \"\"\"An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>` or list thereof.",
            "",
            "    This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a",
            "    response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "    \"\"\"",
            "    after_request: Optional[AfterRequestHookHandler]",
            "    \"\"\"A sync or async function executed after the route handler function returned and the response object has been",
            "    resolved.",
            "",
            "    Receives the response object which may be any subclass of :class:`Response <starlite.response.Response>`.",
            "    \"\"\"",
            "    after_response: Optional[AfterResponseHookHandler]",
            "    \"\"\"A sync or async function called after the response has been awaited. It receives the.",
            "",
            "    :class:`Request <starlite.connection.Request>` object and should not return any values.",
            "    \"\"\"",
            "    after_shutdown: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.",
            "    \"\"\"",
            "    after_startup: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.",
            "    \"\"\"",
            "    allowed_hosts: Optional[Union[List[str], AllowedHostsConfig]]",
            "    \"\"\"If set enables the builtin allowed hosts middleware.\"\"\"",
            "    before_request: Optional[BeforeRequestHookHandler]",
            "    \"\"\"A sync or async function called immediately before calling the route handler. Receives the.",
            "",
            "    :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is used for the response, bypassing",
            "    the route handler.",
            "    \"\"\"",
            "    before_send: SingleOrList[BeforeMessageSendHookHandler]",
            "    \"\"\"An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or list thereof.",
            "",
            "    This hook is called when the ASGI send function is called.",
            "    \"\"\"",
            "    before_shutdown: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.",
            "    \"\"\"",
            "    before_startup: SingleOrList[LifeSpanHookHandler]",
            "    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.",
            "",
            "    This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.",
            "    \"\"\"",
            "    cache_config: CacheConfig",
            "    \"\"\"Configures caching behavior of the application.\"\"\"",
            "    cache_control: Optional[CacheControlHeader]",
            "    \"\"\"A ``cache-control`` header of type :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route",
            "    handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    compression_config: Optional[CompressionConfig]",
            "    \"\"\"Configures compression behaviour of the application, this enabled a builtin or user defined Compression",
            "    middleware.",
            "    \"\"\"",
            "    cors_config: Optional[CORSConfig]",
            "    \"\"\"If set this enables the builtin CORS middleware.\"\"\"",
            "    csrf_config: Optional[CSRFConfig]",
            "    \"\"\"If set this enables the builtin CSRF middleware.\"\"\"",
            "    debug: bool",
            "    \"\"\"If ``True``, app errors rendered as HTML with a stack trace.\"\"\"",
            "    dependencies: Dict[str, Provide]",
            "    \"\"\"A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\"\"\"",
            "    etag: Optional[ETag]",
            "    \"\"\"An ``etag`` header of type :class:`ETag <starlite.datastructures.ETag>` to add to route handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    exception_handlers: ExceptionHandlersMap",
            "    \"\"\"A dictionary that maps handler functions to status codes and/or exception types.\"\"\"",
            "    guards: List[Guard]",
            "    \"\"\"A list of :class:`Guard <starlite.types.Guard>` callables.\"\"\"",
            "    initial_state: InitialStateType",
            "    \"\"\"An object from which to initialize the app state.\"\"\"",
            "    logging_config: Optional[BaseLoggingConfig]",
            "    \"\"\"An instance of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>` subclass.\"\"\"",
            "    middleware: List[Middleware]",
            "    \"\"\"A list of :class:`Middleware <starlite.types.Middleware>`.\"\"\"",
            "    on_shutdown: List[LifeSpanHandler]",
            "    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application shutdown.\"\"\"",
            "    on_startup: List[LifeSpanHandler]",
            "    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application startup.\"\"\"",
            "    openapi_config: Optional[OpenAPIConfig]",
            "    \"\"\"Defaults to :data:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`\"\"\"",
            "    opt: Dict[str, Any]",
            "    \"\"\"A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or",
            "    wherever you have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.",
            "",
            "    Can be overridden by routers and router handlers.",
            "    \"\"\"",
            "    parameters: ParametersMap",
            "    \"\"\"A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all application paths.\"\"\"",
            "    plugins: List[PluginProtocol]",
            "    \"\"\"List of :class:`PluginProtocol <starlite.plugins.base.PluginProtocol>`.\"\"\"",
            "    request_class: Optional[Type[Request]]",
            "    \"\"\"An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for http connections.\"\"\"",
            "    response_class: Optional[ResponseType]",
            "    \"\"\"A custom subclass of [starlite.response.Response] to be used as the app's default response.\"\"\"",
            "    response_cookies: ResponseCookies",
            "    \"\"\"A list of [Cookie](starlite.datastructures.Cookie] instances.\"\"\"",
            "    response_headers: ResponseHeadersMap",
            "    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>` instances.\"\"\"",
            "    route_handlers: List[ControllerRouterHandler]",
            "    \"\"\"A required list of route handlers, which can include instances of :class:`Router <starlite.router.Router>`, subclasses",
            "    of.",
            "",
            "    :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.",
            "    \"\"\"",
            "    security: List[SecurityRequirement]",
            "    \"\"\"A list of dictionaries that will be added to the schema of all route handlers in the application. See.",
            "",
            "    :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.",
            "    \"\"\"",
            "    static_files_config: SingleOrList[StaticFilesConfig]",
            "    \"\"\"An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`.\"\"\"",
            "    tags: List[str]",
            "    \"\"\"A list of string tags that will be appended to the schema of all route handlers under the application.\"\"\"",
            "    template_config: Optional[TemplateConfig]",
            "    \"\"\"An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`.\"\"\"",
            "    type_encoders: Optional[TypeEncodersMap] = None",
            "    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"",
            "    websocket_class: Optional[Type[WebSocket]]",
            "    \"\"\"An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for websocket connections.\"\"\"",
            "    multipart_form_part_limit: int",
            "    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\"",
            "",
            "    @validator(\"allowed_hosts\", always=True)",
            "    def validate_allowed_hosts(  # pylint: disable=no-self-argument",
            "        cls, value: Optional[Union[List[str], AllowedHostsConfig]]",
            "    ) -> Optional[AllowedHostsConfig]:",
            "        \"\"\"Normalize the allowed hosts to be a config or None.",
            "",
            "        Args:",
            "            value: Optional a list of hosts or allowed hosts config",
            "",
            "        Returns:",
            "            Optional config.",
            "        \"\"\"",
            "        if value:",
            "            if isinstance(value, list):",
            "                return AllowedHostsConfig(allowed_hosts=value)",
            "            return value",
            "        return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "starlite.config.app.AppConfig.self"
        ]
    },
    "starlite/connection/request.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             content_type, options = self.content_type"
            },
            "1": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             if content_type == RequestEncodingType.MULTI_PART:"
            },
            "2": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "                 self._form = self.scope[\"_form\"] = form_values = parse_multipart_form(  # type: ignore[typeddict-item]"
            },
            "3": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    body=await self.body(), boundary=options.get(\"boundary\", \"\").encode()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                    body=await self.body(),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                    boundary=options.get(\"boundary\", \"\").encode(),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                    multipart_form_part_limit=self.app.multipart_form_part_limit,"
            },
            "7": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "                 )"
            },
            "8": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "                 return FormMultiDict(form_values)"
            },
            "9": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             if content_type == RequestEncodingType.URL_ENCODED:"
            }
        },
        "frontPatchFile": [
            "from typing import TYPE_CHECKING, Any, AsyncGenerator, Dict, Generic, Tuple, cast",
            "",
            "from starlite.connection.base import (",
            "    ASGIConnection,",
            "    Auth,",
            "    User,",
            "    empty_receive,",
            "    empty_send,",
            ")",
            "from starlite.datastructures.multi_dicts import FormMultiDict",
            "from starlite.enums import RequestEncodingType",
            "from starlite.exceptions import InternalServerException",
            "from starlite.multipart import parse_content_header, parse_multipart_form",
            "from starlite.parsers import parse_url_encoded_form_data",
            "from starlite.types import Empty",
            "from starlite.utils.serialization import decode_json, decode_msgpack",
            "",
            "if TYPE_CHECKING:",
            "    from starlite.handlers.http import HTTPRouteHandler  # noqa: F401",
            "    from starlite.types.asgi_types import HTTPScope, Method, Receive, Scope, Send",
            "",
            "",
            "SERVER_PUSH_HEADERS = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "class Request(Generic[User, Auth], ASGIConnection[\"HTTPRouteHandler\", User, Auth]):",
            "    \"\"\"The Starlite Request class.\"\"\"",
            "",
            "    __slots__ = (\"_json\", \"_form\", \"_body\", \"_msgpack\", \"_content_type\", \"is_connected\")",
            "",
            "    scope: \"HTTPScope\"",
            "    \"\"\"The ASGI scope attached to the connection.\"\"\"",
            "    receive: \"Receive\"",
            "    \"\"\"The ASGI receive function.\"\"\"",
            "    send: \"Send\"",
            "    \"\"\"The ASGI send function.\"\"\"",
            "",
            "    def __init__(self, scope: \"Scope\", receive: \"Receive\" = empty_receive, send: \"Send\" = empty_send) -> None:",
            "        \"\"\"Initialize ``Request``.",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "        \"\"\"",
            "        super().__init__(scope, receive, send)",
            "        self.is_connected: bool = True",
            "        self._body: Any = scope.get(\"_body\", Empty)",
            "        self._form: Any = scope.get(\"_form\", Empty)",
            "        self._json: Any = scope.get(\"_json\", Empty)",
            "        self._msgpack: Any = scope.get(\"_msgpack\", Empty)",
            "        self._content_type: Any = scope.get(\"_content_type\", Empty)",
            "",
            "    @property",
            "    def method(self) -> \"Method\":",
            "        \"\"\"Return the request method.",
            "",
            "        Returns:",
            "            The request :class:`Method <starlite.types.Method>`",
            "        \"\"\"",
            "        return self.scope[\"method\"]",
            "",
            "    @property",
            "    def content_type(self) -> Tuple[str, Dict[str, str]]:",
            "        \"\"\"Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.",
            "",
            "        Returns:",
            "            A tuple with the parsed value and a dictionary containing any options send in it.",
            "        \"\"\"",
            "        if self._content_type is Empty:",
            "            self._content_type = self.scope[\"_content_type\"] = parse_content_header(self.headers.get(\"Content-Type\", \"\"))  # type: ignore[typeddict-item]",
            "        return cast(\"Tuple[str, Dict[str, str]]\", self._content_type)",
            "",
            "    async def json(self) -> Any:",
            "        \"\"\"Retrieve the json request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._json is Empty:",
            "            body = await self.body()",
            "            self._json = self.scope[\"_json\"] = decode_json(body or b\"null\")  # type: ignore[typeddict-item]",
            "        return self._json",
            "",
            "    async def msgpack(self) -> Any:",
            "        \"\"\"Retrieve the MessagePack request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._msgpack is Empty:",
            "            body = await self.body()",
            "            self._msgpack = self.scope[\"_msgpack\"] = decode_msgpack(body or b\"\\xc0\")  # type: ignore[typeddict-item]",
            "        return self._msgpack",
            "",
            "    async def stream(self) -> AsyncGenerator[bytes, None]:",
            "        \"\"\"Return an async generator that streams chunks of bytes.",
            "",
            "        Returns:",
            "            An async generator.",
            "",
            "        Raises:",
            "            RuntimeError: if the stream is already consumed",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            if self.is_connected:",
            "                while event := await self.receive():",
            "                    if event[\"type\"] == \"http.request\":",
            "                        if event[\"body\"]:",
            "                            yield event[\"body\"]",
            "                        if not event.get(\"more_body\", False):",
            "                            break",
            "                    if event[\"type\"] == \"http.disconnect\":",
            "                        raise InternalServerException(\"client disconnected prematurely\")",
            "",
            "                self.is_connected = False",
            "                yield b\"\"",
            "            else:",
            "                raise InternalServerException(\"stream consumed\")",
            "        else:",
            "            yield self._body",
            "            yield b\"\"",
            "            return",
            "",
            "    async def body(self) -> bytes:",
            "        \"\"\"Return the body of the request.",
            "",
            "        Returns:",
            "            A byte-string representing the body of the request.",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            self._body = self.scope[\"_body\"] = b\"\".join([c async for c in self.stream()])  # type: ignore[typeddict-item]",
            "        return cast(\"bytes\", self._body)",
            "",
            "    async def form(self) -> FormMultiDict:",
            "        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an",
            "        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the",
            "        request, otherwise, an empty instance.",
            "",
            "        Returns:",
            "            A FormMultiDict instance",
            "        \"\"\"",
            "        if self._form is Empty:",
            "            content_type, options = self.content_type",
            "            if content_type == RequestEncodingType.MULTI_PART:",
            "                self._form = self.scope[\"_form\"] = form_values = parse_multipart_form(  # type: ignore[typeddict-item]",
            "                    body=await self.body(), boundary=options.get(\"boundary\", \"\").encode()",
            "                )",
            "                return FormMultiDict(form_values)",
            "            if content_type == RequestEncodingType.URL_ENCODED:",
            "                self._form = self.scope[\"_form\"] = form_values = parse_url_encoded_form_data(  # type: ignore[typeddict-item]",
            "                    await self.body(),",
            "                )",
            "                return FormMultiDict(form_values)",
            "            return FormMultiDict()",
            "        return FormMultiDict(self._form)",
            "",
            "    async def send_push_promise(self, path: str) -> None:",
            "        \"\"\"Send a push promise.",
            "",
            "        This method requires the `http.response.push` extension to be sent from the ASGI server.",
            "",
            "        Args:",
            "            path: Path to send the promise to.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        extensions: Dict[str, Dict[Any, Any]] = self.scope.get(\"extensions\") or {}",
            "        if \"http.response.push\" in extensions:",
            "            raw_headers = []",
            "            for name in SERVER_PUSH_HEADERS:",
            "                for value in self.headers.getall(name, []):",
            "                    raw_headers.append((name.encode(\"latin-1\"), value.encode(\"latin-1\")))",
            "            await self.send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})"
        ],
        "afterPatchFile": [
            "from typing import TYPE_CHECKING, Any, AsyncGenerator, Dict, Generic, Tuple, cast",
            "",
            "from starlite.connection.base import (",
            "    ASGIConnection,",
            "    Auth,",
            "    User,",
            "    empty_receive,",
            "    empty_send,",
            ")",
            "from starlite.datastructures.multi_dicts import FormMultiDict",
            "from starlite.enums import RequestEncodingType",
            "from starlite.exceptions import InternalServerException",
            "from starlite.multipart import parse_content_header, parse_multipart_form",
            "from starlite.parsers import parse_url_encoded_form_data",
            "from starlite.types import Empty",
            "from starlite.utils.serialization import decode_json, decode_msgpack",
            "",
            "if TYPE_CHECKING:",
            "    from starlite.handlers.http import HTTPRouteHandler  # noqa: F401",
            "    from starlite.types.asgi_types import HTTPScope, Method, Receive, Scope, Send",
            "",
            "",
            "SERVER_PUSH_HEADERS = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "class Request(Generic[User, Auth], ASGIConnection[\"HTTPRouteHandler\", User, Auth]):",
            "    \"\"\"The Starlite Request class.\"\"\"",
            "",
            "    __slots__ = (\"_json\", \"_form\", \"_body\", \"_msgpack\", \"_content_type\", \"is_connected\")",
            "",
            "    scope: \"HTTPScope\"",
            "    \"\"\"The ASGI scope attached to the connection.\"\"\"",
            "    receive: \"Receive\"",
            "    \"\"\"The ASGI receive function.\"\"\"",
            "    send: \"Send\"",
            "    \"\"\"The ASGI send function.\"\"\"",
            "",
            "    def __init__(self, scope: \"Scope\", receive: \"Receive\" = empty_receive, send: \"Send\" = empty_send) -> None:",
            "        \"\"\"Initialize ``Request``.",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "        \"\"\"",
            "        super().__init__(scope, receive, send)",
            "        self.is_connected: bool = True",
            "        self._body: Any = scope.get(\"_body\", Empty)",
            "        self._form: Any = scope.get(\"_form\", Empty)",
            "        self._json: Any = scope.get(\"_json\", Empty)",
            "        self._msgpack: Any = scope.get(\"_msgpack\", Empty)",
            "        self._content_type: Any = scope.get(\"_content_type\", Empty)",
            "",
            "    @property",
            "    def method(self) -> \"Method\":",
            "        \"\"\"Return the request method.",
            "",
            "        Returns:",
            "            The request :class:`Method <starlite.types.Method>`",
            "        \"\"\"",
            "        return self.scope[\"method\"]",
            "",
            "    @property",
            "    def content_type(self) -> Tuple[str, Dict[str, str]]:",
            "        \"\"\"Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.",
            "",
            "        Returns:",
            "            A tuple with the parsed value and a dictionary containing any options send in it.",
            "        \"\"\"",
            "        if self._content_type is Empty:",
            "            self._content_type = self.scope[\"_content_type\"] = parse_content_header(self.headers.get(\"Content-Type\", \"\"))  # type: ignore[typeddict-item]",
            "        return cast(\"Tuple[str, Dict[str, str]]\", self._content_type)",
            "",
            "    async def json(self) -> Any:",
            "        \"\"\"Retrieve the json request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._json is Empty:",
            "            body = await self.body()",
            "            self._json = self.scope[\"_json\"] = decode_json(body or b\"null\")  # type: ignore[typeddict-item]",
            "        return self._json",
            "",
            "    async def msgpack(self) -> Any:",
            "        \"\"\"Retrieve the MessagePack request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._msgpack is Empty:",
            "            body = await self.body()",
            "            self._msgpack = self.scope[\"_msgpack\"] = decode_msgpack(body or b\"\\xc0\")  # type: ignore[typeddict-item]",
            "        return self._msgpack",
            "",
            "    async def stream(self) -> AsyncGenerator[bytes, None]:",
            "        \"\"\"Return an async generator that streams chunks of bytes.",
            "",
            "        Returns:",
            "            An async generator.",
            "",
            "        Raises:",
            "            RuntimeError: if the stream is already consumed",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            if self.is_connected:",
            "                while event := await self.receive():",
            "                    if event[\"type\"] == \"http.request\":",
            "                        if event[\"body\"]:",
            "                            yield event[\"body\"]",
            "                        if not event.get(\"more_body\", False):",
            "                            break",
            "                    if event[\"type\"] == \"http.disconnect\":",
            "                        raise InternalServerException(\"client disconnected prematurely\")",
            "",
            "                self.is_connected = False",
            "                yield b\"\"",
            "            else:",
            "                raise InternalServerException(\"stream consumed\")",
            "        else:",
            "            yield self._body",
            "            yield b\"\"",
            "            return",
            "",
            "    async def body(self) -> bytes:",
            "        \"\"\"Return the body of the request.",
            "",
            "        Returns:",
            "            A byte-string representing the body of the request.",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            self._body = self.scope[\"_body\"] = b\"\".join([c async for c in self.stream()])  # type: ignore[typeddict-item]",
            "        return cast(\"bytes\", self._body)",
            "",
            "    async def form(self) -> FormMultiDict:",
            "        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an",
            "        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the",
            "        request, otherwise, an empty instance.",
            "",
            "        Returns:",
            "            A FormMultiDict instance",
            "        \"\"\"",
            "        if self._form is Empty:",
            "            content_type, options = self.content_type",
            "            if content_type == RequestEncodingType.MULTI_PART:",
            "                self._form = self.scope[\"_form\"] = form_values = parse_multipart_form(  # type: ignore[typeddict-item]",
            "                    body=await self.body(),",
            "                    boundary=options.get(\"boundary\", \"\").encode(),",
            "                    multipart_form_part_limit=self.app.multipart_form_part_limit,",
            "                )",
            "                return FormMultiDict(form_values)",
            "            if content_type == RequestEncodingType.URL_ENCODED:",
            "                self._form = self.scope[\"_form\"] = form_values = parse_url_encoded_form_data(  # type: ignore[typeddict-item]",
            "                    await self.body(),",
            "                )",
            "                return FormMultiDict(form_values)",
            "            return FormMultiDict()",
            "        return FormMultiDict(self._form)",
            "",
            "    async def send_push_promise(self, path: str) -> None:",
            "        \"\"\"Send a push promise.",
            "",
            "        This method requires the `http.response.push` extension to be sent from the ASGI server.",
            "",
            "        Args:",
            "            path: Path to send the promise to.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        extensions: Dict[str, Dict[Any, Any]] = self.scope.get(\"extensions\") or {}",
            "        if \"http.response.push\" in extensions:",
            "            raw_headers = []",
            "            for name in SERVER_PUSH_HEADERS:",
            "                for value in self.headers.getall(name, []):",
            "                    raw_headers.append((name.encode(\"latin-1\"), value.encode(\"latin-1\")))",
            "            await self.send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "153": [
                "Request"
            ]
        },
        "addLocation": []
    },
    "starlite/kwargs/extractors.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from starlite.enums import ParamType, RequestEncodingType"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from starlite.exceptions import ValidationException"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from starlite.multipart import parse_multipart_form"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from starlite.params import BodyKwarg"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from starlite.parsers import ("
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     parse_headers,"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     parse_query_string,"
            },
            "7": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     Returns:"
            },
            "8": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         An extractor function."
            },
            "9": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "     \"\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+    body_kwarg_multipart_form_part_limit: Optional[int] = None"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+    if signature_field.kwarg_model and isinstance(signature_field.kwarg_model, BodyKwarg):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        body_kwarg_multipart_form_part_limit = signature_field.kwarg_model.multipart_form_part_limit"
            },
            "13": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 296,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "     async def extract_multipart("
            },
            "15": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "         connection: \"Request[Any, Any]\","
            },
            "16": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "     ) -> Any:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+        multipart_form_part_limit = ("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+            body_kwarg_multipart_form_part_limit"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+            if body_kwarg_multipart_form_part_limit is not None"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+            else connection.app.multipart_form_part_limit"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        )"
            },
            "22": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "         connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]"
            },
            "23": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "             connection.scope[\"_form\"]  # type: ignore[typeddict-item]"
            },
            "24": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "             if \"_form\" in connection.scope"
            },
            "25": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "             else parse_multipart_form("
            },
            "26": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                body=await connection.body(), boundary=connection.content_type[-1].get(\"boundary\", \"\").encode()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+                body=await connection.body(),"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+                boundary=connection.content_type[-1].get(\"boundary\", \"\").encode(),"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+                multipart_form_part_limit=multipart_form_part_limit,"
            },
            "30": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             )"
            },
            "31": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "         )"
            },
            "32": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 314,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from collections import defaultdict",
            "from functools import lru_cache",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Coroutine,",
            "    DefaultDict,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlite.datastructures.upload_file import UploadFile",
            "from starlite.enums import ParamType, RequestEncodingType",
            "from starlite.exceptions import ValidationException",
            "from starlite.multipart import parse_multipart_form",
            "from starlite.parsers import (",
            "    parse_headers,",
            "    parse_query_string,",
            "    parse_url_encoded_form_data,",
            ")",
            "from starlite.types import Empty",
            "",
            "if TYPE_CHECKING:",
            "    from starlite.connection import ASGIConnection, Request",
            "    from starlite.kwargs import KwargsModel",
            "    from starlite.kwargs.parameter_definition import ParameterDefinition",
            "    from starlite.signature.models import SignatureField",
            "",
            "",
            "def create_connection_value_extractor(",
            "    kwargs_model: \"KwargsModel\",",
            "    connection_key: str,",
            "    expected_params: Set[\"ParameterDefinition\"],",
            "    parser: Optional[Callable[[\"ASGIConnection\", \"KwargsModel\"], Dict[str, Any]]] = None,",
            ") -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:",
            "    \"\"\"Create a kwargs extractor function.",
            "",
            "    Args:",
            "        kwargs_model: The KwargsModel instance.",
            "        connection_key: The attribute key to use.",
            "        expected_params: The set of expected params.",
            "        parser: An optional parser function.",
            "",
            "    Returns:",
            "        An extractor function.",
            "    \"\"\"",
            "",
            "    alias_and_key_tuple = tuple(",
            "        (p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias, p.field_name)",
            "        for p in expected_params",
            "    )",
            "    alias_defaults = {",
            "        p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias: p.default_value",
            "        for p in expected_params",
            "        if not (p.is_required or p.default_value is Ellipsis)",
            "    }",
            "",
            "    def extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "        data = parser(connection, kwargs_model) if parser else getattr(connection, connection_key, {})",
            "",
            "        try:",
            "            connection_mapping: Dict[str, Any] = {",
            "                key: data[alias] if alias in data else alias_defaults[alias] for alias, key in alias_and_key_tuple",
            "            }",
            "            values.update(connection_mapping)",
            "        except KeyError as e:",
            "            raise ValidationException(f\"Missing required parameter {e.args[0]} for url {connection.url}\") from e",
            "",
            "    return extractor",
            "",
            "",
            "@lru_cache(1024)",
            "def create_query_default_dict(",
            "    parsed_query: Tuple[Tuple[str, str], ...], sequence_query_parameter_names: Tuple[str, ...]",
            ") -> DefaultDict[str, Union[List[str], str]]:",
            "    \"\"\"Transform a list of tuples into a default dict. Ensures non-list values are not wrapped in a list.",
            "",
            "    Args:",
            "        parsed_query: The parsed query list of tuples.",
            "        sequence_query_parameter_names: A set of query parameters that should be wrapped in list.",
            "",
            "    Returns:",
            "        A default dict",
            "    \"\"\"",
            "    output: DefaultDict[str, Union[List[str], str]] = defaultdict(list)",
            "",
            "    for k, v in parsed_query:",
            "        if k in sequence_query_parameter_names:",
            "            output[k].append(v)  # type: ignore",
            "        else:",
            "            output[k] = v",
            "",
            "    return output",
            "",
            "",
            "def parse_connection_query_params(connection: \"ASGIConnection\", kwargs_model: \"KwargsModel\") -> Dict[str, Any]:",
            "    \"\"\"Parse query params and cache the result in scope.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        kwargs_model: The KwargsModel instance.",
            "",
            "    Returns:",
            "        A dictionary of parsed values.",
            "    \"\"\"",
            "    parsed_query = connection.scope[\"_parsed_query\"] = (  # type: ignore",
            "        connection._parsed_query",
            "        if connection._parsed_query is not Empty",
            "        else parse_query_string(connection.scope.get(\"query_string\", b\"\"))",
            "    )",
            "    return create_query_default_dict(",
            "        parsed_query=parsed_query, sequence_query_parameter_names=kwargs_model.sequence_query_parameter_names",
            "    )",
            "",
            "",
            "def parse_connection_headers(connection: \"ASGIConnection\", _: \"KwargsModel\") -> Dict[str, Any]:",
            "    \"\"\"Parse header parameters and cache the result in scope.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        _: The KwargsModel instance.",
            "",
            "    Returns:",
            "        A dictionary of parsed values",
            "    \"\"\"",
            "    parsed_headers = connection.scope[\"_headers\"] = (  # type: ignore",
            "        connection._headers if connection._headers is not Empty else parse_headers(tuple(connection.scope[\"headers\"]))",
            "    )",
            "    return cast(\"Dict[str, Any]\", parsed_headers)",
            "",
            "",
            "def state_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the app state from the connection and insert it to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"state\"] = connection.app.state._state",
            "",
            "",
            "def headers_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the headers from the connection and insert them to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"headers\"] = connection.headers",
            "",
            "",
            "def cookies_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the cookies from the connection and insert them to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"cookies\"] = connection.cookies",
            "",
            "",
            "def query_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the query params from the connection and insert them to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"query\"] = connection.query_params",
            "",
            "",
            "def scope_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the scope from the connection and insert it into the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"scope\"] = connection.scope",
            "",
            "",
            "def request_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Set the connection instance as the 'request' value in the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"request\"] = connection",
            "",
            "",
            "def socket_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Set the connection instance as the 'socket' value in the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"socket\"] = connection",
            "",
            "",
            "def body_extractor(",
            "    values: Dict[str, Any],",
            "    connection: \"Request[Any, Any]\",",
            ") -> None:",
            "    \"\"\"Extract the body from the request instance.",
            "",
            "    Notes:",
            "        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        The Body value.",
            "    \"\"\"",
            "    values[\"body\"] = connection.body()",
            "",
            "",
            "async def json_extractor(",
            "    connection: \"Request[Any, Any]\",",
            ") -> Any:",
            "    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.",
            "",
            "    Notes:",
            "        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "",
            "    Returns:",
            "        The JSON value.",
            "    \"\"\"",
            "    return await connection.json()",
            "",
            "",
            "async def msgpack_extractor(connection: \"Request[Any, Any]\") -> Any:",
            "    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.",
            "",
            "    Notes:",
            "        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "",
            "    Returns:",
            "        The MessagePack value.",
            "    \"\"\"",
            "    return await connection.msgpack()",
            "",
            "",
            "def create_multipart_extractor(",
            "    signature_field: \"SignatureField\", is_data_optional: bool",
            ") -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:",
            "    \"\"\"Create a multipart form-data extractor.",
            "",
            "    Args:",
            "        signature_field: A SignatureField instance.",
            "        is_data_optional: Boolean dictating whether the field is optional.",
            "",
            "    Returns:",
            "        An extractor function.",
            "    \"\"\"",
            "",
            "    async def extract_multipart(",
            "        connection: \"Request[Any, Any]\",",
            "    ) -> Any:",
            "        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]",
            "            connection.scope[\"_form\"]  # type: ignore[typeddict-item]",
            "            if \"_form\" in connection.scope",
            "            else parse_multipart_form(",
            "                body=await connection.body(), boundary=connection.content_type[-1].get(\"boundary\", \"\").encode()",
            "            )",
            "        )",
            "",
            "        if signature_field.is_non_string_sequence:",
            "            return list(form_values.values())",
            "        if signature_field.is_simple_type and signature_field.field_type is UploadFile and form_values:",
            "            return [v for v in form_values.values() if isinstance(v, UploadFile)][0]",
            "",
            "        return form_values if form_values or not is_data_optional else None",
            "",
            "    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_multipart)",
            "",
            "",
            "def create_url_encoded_data_extractor(",
            "    is_data_optional: bool,",
            ") -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:",
            "    \"\"\"Create extractor for url encoded form-data.",
            "",
            "    Args:",
            "        is_data_optional: Boolean dictating whether the field is optional.",
            "",
            "    Returns:",
            "        An extractor function.",
            "    \"\"\"",
            "",
            "    async def extract_url_encoded_extractor(",
            "        connection: \"Request[Any, Any]\",",
            "    ) -> Any:",
            "        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]",
            "            connection.scope[\"_form\"]  # type: ignore[typeddict-item]",
            "            if \"_form\" in connection.scope",
            "            else parse_url_encoded_form_data(await connection.body())",
            "        )",
            "        return form_values if form_values or not is_data_optional else None",
            "",
            "    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_url_encoded_extractor)",
            "",
            "",
            "def create_data_extractor(kwargs_model: \"KwargsModel\") -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:",
            "    \"\"\"Create an extractor for a request's body.",
            "",
            "    Args:",
            "        kwargs_model: The KwargsModel instance.",
            "",
            "    Returns:",
            "        An extractor for the request's body.",
            "    \"\"\"",
            "",
            "    if kwargs_model.expected_form_data:",
            "        media_type, signature_field = kwargs_model.expected_form_data",
            "",
            "        if media_type == RequestEncodingType.MULTI_PART:",
            "            data_extractor = create_multipart_extractor(",
            "                signature_field=signature_field,",
            "                is_data_optional=kwargs_model.is_data_optional,",
            "            )",
            "        else:",
            "            data_extractor = create_url_encoded_data_extractor(is_data_optional=kwargs_model.is_data_optional)",
            "    elif kwargs_model.expected_msgpack_data:",
            "        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", msgpack_extractor)",
            "    else:",
            "        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", json_extractor)",
            "",
            "    def extractor(",
            "        values: Dict[str, Any],",
            "        connection: \"ASGIConnection[Any, Any, Any]\",",
            "    ) -> None:",
            "        values[\"data\"] = data_extractor(connection)",
            "",
            "    return extractor"
        ],
        "afterPatchFile": [
            "from collections import defaultdict",
            "from functools import lru_cache",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Callable,",
            "    Coroutine,",
            "    DefaultDict,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Set,",
            "    Tuple,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlite.datastructures.upload_file import UploadFile",
            "from starlite.enums import ParamType, RequestEncodingType",
            "from starlite.exceptions import ValidationException",
            "from starlite.multipart import parse_multipart_form",
            "from starlite.params import BodyKwarg",
            "from starlite.parsers import (",
            "    parse_headers,",
            "    parse_query_string,",
            "    parse_url_encoded_form_data,",
            ")",
            "from starlite.types import Empty",
            "",
            "if TYPE_CHECKING:",
            "    from starlite.connection import ASGIConnection, Request",
            "    from starlite.kwargs import KwargsModel",
            "    from starlite.kwargs.parameter_definition import ParameterDefinition",
            "    from starlite.signature.models import SignatureField",
            "",
            "",
            "def create_connection_value_extractor(",
            "    kwargs_model: \"KwargsModel\",",
            "    connection_key: str,",
            "    expected_params: Set[\"ParameterDefinition\"],",
            "    parser: Optional[Callable[[\"ASGIConnection\", \"KwargsModel\"], Dict[str, Any]]] = None,",
            ") -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:",
            "    \"\"\"Create a kwargs extractor function.",
            "",
            "    Args:",
            "        kwargs_model: The KwargsModel instance.",
            "        connection_key: The attribute key to use.",
            "        expected_params: The set of expected params.",
            "        parser: An optional parser function.",
            "",
            "    Returns:",
            "        An extractor function.",
            "    \"\"\"",
            "",
            "    alias_and_key_tuple = tuple(",
            "        (p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias, p.field_name)",
            "        for p in expected_params",
            "    )",
            "    alias_defaults = {",
            "        p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias: p.default_value",
            "        for p in expected_params",
            "        if not (p.is_required or p.default_value is Ellipsis)",
            "    }",
            "",
            "    def extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "        data = parser(connection, kwargs_model) if parser else getattr(connection, connection_key, {})",
            "",
            "        try:",
            "            connection_mapping: Dict[str, Any] = {",
            "                key: data[alias] if alias in data else alias_defaults[alias] for alias, key in alias_and_key_tuple",
            "            }",
            "            values.update(connection_mapping)",
            "        except KeyError as e:",
            "            raise ValidationException(f\"Missing required parameter {e.args[0]} for url {connection.url}\") from e",
            "",
            "    return extractor",
            "",
            "",
            "@lru_cache(1024)",
            "def create_query_default_dict(",
            "    parsed_query: Tuple[Tuple[str, str], ...], sequence_query_parameter_names: Tuple[str, ...]",
            ") -> DefaultDict[str, Union[List[str], str]]:",
            "    \"\"\"Transform a list of tuples into a default dict. Ensures non-list values are not wrapped in a list.",
            "",
            "    Args:",
            "        parsed_query: The parsed query list of tuples.",
            "        sequence_query_parameter_names: A set of query parameters that should be wrapped in list.",
            "",
            "    Returns:",
            "        A default dict",
            "    \"\"\"",
            "    output: DefaultDict[str, Union[List[str], str]] = defaultdict(list)",
            "",
            "    for k, v in parsed_query:",
            "        if k in sequence_query_parameter_names:",
            "            output[k].append(v)  # type: ignore",
            "        else:",
            "            output[k] = v",
            "",
            "    return output",
            "",
            "",
            "def parse_connection_query_params(connection: \"ASGIConnection\", kwargs_model: \"KwargsModel\") -> Dict[str, Any]:",
            "    \"\"\"Parse query params and cache the result in scope.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        kwargs_model: The KwargsModel instance.",
            "",
            "    Returns:",
            "        A dictionary of parsed values.",
            "    \"\"\"",
            "    parsed_query = connection.scope[\"_parsed_query\"] = (  # type: ignore",
            "        connection._parsed_query",
            "        if connection._parsed_query is not Empty",
            "        else parse_query_string(connection.scope.get(\"query_string\", b\"\"))",
            "    )",
            "    return create_query_default_dict(",
            "        parsed_query=parsed_query, sequence_query_parameter_names=kwargs_model.sequence_query_parameter_names",
            "    )",
            "",
            "",
            "def parse_connection_headers(connection: \"ASGIConnection\", _: \"KwargsModel\") -> Dict[str, Any]:",
            "    \"\"\"Parse header parameters and cache the result in scope.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        _: The KwargsModel instance.",
            "",
            "    Returns:",
            "        A dictionary of parsed values",
            "    \"\"\"",
            "    parsed_headers = connection.scope[\"_headers\"] = (  # type: ignore",
            "        connection._headers if connection._headers is not Empty else parse_headers(tuple(connection.scope[\"headers\"]))",
            "    )",
            "    return cast(\"Dict[str, Any]\", parsed_headers)",
            "",
            "",
            "def state_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the app state from the connection and insert it to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"state\"] = connection.app.state._state",
            "",
            "",
            "def headers_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the headers from the connection and insert them to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"headers\"] = connection.headers",
            "",
            "",
            "def cookies_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the cookies from the connection and insert them to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"cookies\"] = connection.cookies",
            "",
            "",
            "def query_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the query params from the connection and insert them to the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"query\"] = connection.query_params",
            "",
            "",
            "def scope_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Extract the scope from the connection and insert it into the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"scope\"] = connection.scope",
            "",
            "",
            "def request_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Set the connection instance as the 'request' value in the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"request\"] = connection",
            "",
            "",
            "def socket_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:",
            "    \"\"\"Set the connection instance as the 'socket' value in the kwargs injected to the handler.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        None",
            "    \"\"\"",
            "    values[\"socket\"] = connection",
            "",
            "",
            "def body_extractor(",
            "    values: Dict[str, Any],",
            "    connection: \"Request[Any, Any]\",",
            ") -> None:",
            "    \"\"\"Extract the body from the request instance.",
            "",
            "    Notes:",
            "        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "        values: The kwargs that are extracted from the connection and will be injected into the handler.",
            "",
            "    Returns:",
            "        The Body value.",
            "    \"\"\"",
            "    values[\"body\"] = connection.body()",
            "",
            "",
            "async def json_extractor(",
            "    connection: \"Request[Any, Any]\",",
            ") -> Any:",
            "    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.",
            "",
            "    Notes:",
            "        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "",
            "    Returns:",
            "        The JSON value.",
            "    \"\"\"",
            "    return await connection.json()",
            "",
            "",
            "async def msgpack_extractor(connection: \"Request[Any, Any]\") -> Any:",
            "    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.",
            "",
            "    Notes:",
            "        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.",
            "",
            "    Args:",
            "        connection: The ASGI connection instance.",
            "",
            "    Returns:",
            "        The MessagePack value.",
            "    \"\"\"",
            "    return await connection.msgpack()",
            "",
            "",
            "def create_multipart_extractor(",
            "    signature_field: \"SignatureField\", is_data_optional: bool",
            ") -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:",
            "    \"\"\"Create a multipart form-data extractor.",
            "",
            "    Args:",
            "        signature_field: A SignatureField instance.",
            "        is_data_optional: Boolean dictating whether the field is optional.",
            "",
            "    Returns:",
            "        An extractor function.",
            "    \"\"\"",
            "    body_kwarg_multipart_form_part_limit: Optional[int] = None",
            "    if signature_field.kwarg_model and isinstance(signature_field.kwarg_model, BodyKwarg):",
            "        body_kwarg_multipart_form_part_limit = signature_field.kwarg_model.multipart_form_part_limit",
            "",
            "    async def extract_multipart(",
            "        connection: \"Request[Any, Any]\",",
            "    ) -> Any:",
            "        multipart_form_part_limit = (",
            "            body_kwarg_multipart_form_part_limit",
            "            if body_kwarg_multipart_form_part_limit is not None",
            "            else connection.app.multipart_form_part_limit",
            "        )",
            "        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]",
            "            connection.scope[\"_form\"]  # type: ignore[typeddict-item]",
            "            if \"_form\" in connection.scope",
            "            else parse_multipart_form(",
            "                body=await connection.body(),",
            "                boundary=connection.content_type[-1].get(\"boundary\", \"\").encode(),",
            "                multipart_form_part_limit=multipart_form_part_limit,",
            "            )",
            "        )",
            "",
            "        if signature_field.is_non_string_sequence:",
            "            return list(form_values.values())",
            "        if signature_field.is_simple_type and signature_field.field_type is UploadFile and form_values:",
            "            return [v for v in form_values.values() if isinstance(v, UploadFile)][0]",
            "",
            "        return form_values if form_values or not is_data_optional else None",
            "",
            "    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_multipart)",
            "",
            "",
            "def create_url_encoded_data_extractor(",
            "    is_data_optional: bool,",
            ") -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:",
            "    \"\"\"Create extractor for url encoded form-data.",
            "",
            "    Args:",
            "        is_data_optional: Boolean dictating whether the field is optional.",
            "",
            "    Returns:",
            "        An extractor function.",
            "    \"\"\"",
            "",
            "    async def extract_url_encoded_extractor(",
            "        connection: \"Request[Any, Any]\",",
            "    ) -> Any:",
            "        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]",
            "            connection.scope[\"_form\"]  # type: ignore[typeddict-item]",
            "            if \"_form\" in connection.scope",
            "            else parse_url_encoded_form_data(await connection.body())",
            "        )",
            "        return form_values if form_values or not is_data_optional else None",
            "",
            "    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_url_encoded_extractor)",
            "",
            "",
            "def create_data_extractor(kwargs_model: \"KwargsModel\") -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:",
            "    \"\"\"Create an extractor for a request's body.",
            "",
            "    Args:",
            "        kwargs_model: The KwargsModel instance.",
            "",
            "    Returns:",
            "        An extractor for the request's body.",
            "    \"\"\"",
            "",
            "    if kwargs_model.expected_form_data:",
            "        media_type, signature_field = kwargs_model.expected_form_data",
            "",
            "        if media_type == RequestEncodingType.MULTI_PART:",
            "            data_extractor = create_multipart_extractor(",
            "                signature_field=signature_field,",
            "                is_data_optional=kwargs_model.is_data_optional,",
            "            )",
            "        else:",
            "            data_extractor = create_url_encoded_data_extractor(is_data_optional=kwargs_model.is_data_optional)",
            "    elif kwargs_model.expected_msgpack_data:",
            "        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", msgpack_extractor)",
            "    else:",
            "        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", json_extractor)",
            "",
            "    def extractor(",
            "        values: Dict[str, Any],",
            "        connection: \"ASGIConnection[Any, Any, Any]\",",
            "    ) -> None:",
            "        values[\"data\"] = data_extractor(connection)",
            "",
            "    return extractor"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "300": [
                "create_multipart_extractor"
            ]
        },
        "addLocation": [
            "label_studio.core.settings.base",
            "starlite.kwargs.extractors.create_data_extractor"
        ]
    },
    "starlite/multipart.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from urllib.parse import unquote"
            },
            "1": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from starlite.datastructures.upload_file import UploadFile"
            },
            "3": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from starlite.exceptions import SerializationException"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+from starlite.exceptions import SerializationException, ValidationException"
            },
            "5": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from starlite.utils.serialization import decode_json"
            },
            "6": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+_token = r\"([\\w!#$%&'*+\\-.^_`|~]+)\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+_quoted = r'\"([^\"]*)\"'"
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " _param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)"
            },
            "11": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " _firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')"
            },
            "12": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     return value.strip().lower(), options"
            },
            "14": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def parse_multipart_form(body: bytes, boundary: bytes) -> Dict[str, Any]:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+def parse_body(body: bytes, boundary: bytes, multipart_form_part_limit: int) -> List[bytes]:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    \"\"\"Split the body using the boundary"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        and validate the number of form parts is within the allowed limit."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    :param body: The form body."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    :param boundary: The boundary used to separate form components."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    :param multipart_form_part_limit: The limit of allowed form components"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    :return:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        A list of form components."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    \"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    if not (body and boundary):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        return []"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    form_parts = body.split(boundary, multipart_form_part_limit + 3)[1:-1]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    if len(form_parts) > multipart_form_part_limit:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        raise ValidationException("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            f\"number of multipart components exceeds the allowed limit of {multipart_form_part_limit}, \""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            f\"this potentially indicates a DoS attack\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        )"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    return form_parts"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+def parse_multipart_form(body: bytes, boundary: bytes, multipart_form_part_limit: int = 1000) -> Dict[str, Any]:"
            },
            "42": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     \"\"\"Parse multipart form data."
            },
            "43": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     Args:"
            },
            "45": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         body: Body of the request."
            },
            "46": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         boundary: Boundary of the multipart message."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        multipart_form_part_limit: Limit of the number of parts allowed."
            },
            "48": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     Returns:"
            },
            "50": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         A dictionary of parsed results."
            },
            "51": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     \"\"\""
            },
            "52": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     fields: DefaultDict[str, List[Any]] = defaultdict(list)"
            },
            "54": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if body and boundary:"
            },
            "56": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        form_parts = body.split(boundary)"
            },
            "57": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for form_part in form_parts[1:-1]:"
            },
            "58": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file_name = None"
            },
            "59": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content_type = \"text/plain\""
            },
            "60": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            content_charset = \"utf-8\""
            },
            "61": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            field_name = None"
            },
            "62": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            line_index = 2"
            },
            "63": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            line_end_index = 0"
            },
            "64": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            headers: List[Tuple[str, str]] = []"
            },
            "65": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "66": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            while line_end_index != -1:"
            },
            "67": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                line_end_index = form_part.find(b\"\\r\\n\", line_index)"
            },
            "68": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                form_line = form_part[line_index:line_end_index].decode(\"utf-8\")"
            },
            "69": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "70": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if not form_line:"
            },
            "71": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    break"
            },
            "72": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "73": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                line_index = line_end_index + 2"
            },
            "74": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                colon_index = form_line.index(\":\")"
            },
            "75": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                current_idx = colon_index + 2"
            },
            "76": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                form_header_field = form_line[0:colon_index].lower()"
            },
            "77": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                form_header_value, form_parameters = parse_content_header(form_line[current_idx:])"
            },
            "78": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "79": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if form_header_field == \"content-disposition\":"
            },
            "80": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    field_name = form_parameters.get(\"name\")"
            },
            "81": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    file_name = form_parameters.get(\"filename\")"
            },
            "82": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "83": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):"
            },
            "84": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        encoding, _, value = decode_rfc2231(filename_with_asterisk)"
            },
            "85": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        file_name = unquote(value, encoding=encoding or content_charset)"
            },
            "86": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "87": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                elif form_header_field == \"content-type\":"
            },
            "88": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    content_type = form_header_value"
            },
            "89": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    content_charset = form_parameters.get(\"charset\", \"utf-8\")"
            },
            "90": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                headers.append((form_header_field, form_header_value))"
            },
            "91": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "92": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if field_name:"
            },
            "93": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")"
            },
            "94": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if file_name:"
            },
            "95": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    form_file = UploadFile("
            },
            "96": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)"
            },
            "97": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "98": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    fields[field_name].append(form_file)"
            },
            "99": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "100": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    try:"
            },
            "101": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        fields[field_name].append(decode_json(post_data))"
            },
            "102": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    except SerializationException:"
            },
            "103": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        fields[field_name].append(post_data.decode(content_charset))"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+    for form_part in parse_body(body=body, boundary=boundary, multipart_form_part_limit=multipart_form_part_limit):"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        file_name = None"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        content_type = \"text/plain\""
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        content_charset = \"utf-8\""
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        field_name = None"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        line_index = 2"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+        line_end_index = 0"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        headers: List[Tuple[str, str]] = []"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        while line_end_index != -1:"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            line_end_index = form_part.find(b\"\\r\\n\", line_index)"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+            if not form_line:"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                break"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+"
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            line_index = line_end_index + 2"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            colon_index = form_line.index(\":\")"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            current_idx = colon_index + 2"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            form_header_field = form_line[0:colon_index].lower()"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            form_header_value, form_parameters = parse_content_header(form_line[current_idx:])"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            if form_header_field == \"content-disposition\":"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+                field_name = form_parameters.get(\"name\")"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+                file_name = form_parameters.get(\"filename\")"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+                if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+                    encoding, _, value = decode_rfc2231(filename_with_asterisk)"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+                    file_name = unquote(value, encoding=encoding or content_charset)"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+            elif form_header_field == \"content-type\":"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+                content_type = form_header_value"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+                content_charset = form_parameters.get(\"charset\", \"utf-8\")"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            headers.append((form_header_field, form_header_value))"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        if field_name:"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            if file_name:"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                form_file = UploadFile("
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+                    content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+                )"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+                fields[field_name].append(form_file)"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            else:"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                try:"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+                    fields[field_name].append(decode_json(post_data))"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+                except SerializationException:"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                    fields[field_name].append(post_data.decode(content_charset))"
            },
            "151": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "152": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     return {k: v if len(v) > 1 else v[0] for k, v in fields.items()}"
            }
        },
        "frontPatchFile": [
            "\"\"\"The contents of this file were adapted from sanic.",
            "",
            "MIT License",
            "",
            "Copyright (c) 2016-present Sanic Community",
            "",
            "Permission is hereby granted, free of charge, to any person obtaining a copy",
            "of this software and associated documentation files (the \"Software\"), to deal",
            "in the Software without restriction, including without limitation the rights",
            "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
            "copies of the Software, and to permit persons to whom the Software is",
            "furnished to do so, subject to the following conditions:",
            "",
            "The above copyright notice and this permission notice shall be included in all",
            "copies or substantial portions of the Software.",
            "",
            "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
            "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
            "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
            "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
            "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
            "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
            "SOFTWARE.",
            "\"\"\"",
            "",
            "import re",
            "from collections import defaultdict",
            "from email.utils import decode_rfc2231",
            "from typing import Any, DefaultDict, Dict, List, Tuple",
            "from urllib.parse import unquote",
            "",
            "from starlite.datastructures.upload_file import UploadFile",
            "from starlite.exceptions import SerializationException",
            "from starlite.utils.serialization import decode_json",
            "",
            "_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'",
            "_param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)",
            "_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')",
            "",
            "",
            "def parse_content_header(value: str) -> Tuple[str, Dict[str, str]]:",
            "    \"\"\"Parse content-type and content-disposition header values.",
            "",
            "    Args:",
            "        value: A header string value to parse.",
            "",
            "    Returns:",
            "        A tuple containing the normalized header string and a dictionary of parameters.",
            "    \"\"\"",
            "    value = _firefox_quote_escape.sub(\"%22\", value)",
            "    pos = value.find(\";\")",
            "    if pos == -1:",
            "        options: Dict[str, str] = {}",
            "    else:",
            "        options = {",
            "            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"') for m in _param.finditer(value[pos:])",
            "        }",
            "        value = value[:pos]",
            "    return value.strip().lower(), options",
            "",
            "",
            "def parse_multipart_form(body: bytes, boundary: bytes) -> Dict[str, Any]:",
            "    \"\"\"Parse multipart form data.",
            "",
            "    Args:",
            "        body: Body of the request.",
            "        boundary: Boundary of the multipart message.",
            "",
            "    Returns:",
            "        A dictionary of parsed results.",
            "    \"\"\"",
            "",
            "    fields: DefaultDict[str, List[Any]] = defaultdict(list)",
            "",
            "    if body and boundary:",
            "        form_parts = body.split(boundary)",
            "        for form_part in form_parts[1:-1]:",
            "            file_name = None",
            "            content_type = \"text/plain\"",
            "            content_charset = \"utf-8\"",
            "            field_name = None",
            "            line_index = 2",
            "            line_end_index = 0",
            "            headers: List[Tuple[str, str]] = []",
            "",
            "            while line_end_index != -1:",
            "                line_end_index = form_part.find(b\"\\r\\n\", line_index)",
            "                form_line = form_part[line_index:line_end_index].decode(\"utf-8\")",
            "",
            "                if not form_line:",
            "                    break",
            "",
            "                line_index = line_end_index + 2",
            "                colon_index = form_line.index(\":\")",
            "                current_idx = colon_index + 2",
            "                form_header_field = form_line[0:colon_index].lower()",
            "                form_header_value, form_parameters = parse_content_header(form_line[current_idx:])",
            "",
            "                if form_header_field == \"content-disposition\":",
            "                    field_name = form_parameters.get(\"name\")",
            "                    file_name = form_parameters.get(\"filename\")",
            "",
            "                    if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):",
            "                        encoding, _, value = decode_rfc2231(filename_with_asterisk)",
            "                        file_name = unquote(value, encoding=encoding or content_charset)",
            "",
            "                elif form_header_field == \"content-type\":",
            "                    content_type = form_header_value",
            "                    content_charset = form_parameters.get(\"charset\", \"utf-8\")",
            "                headers.append((form_header_field, form_header_value))",
            "",
            "            if field_name:",
            "                post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")",
            "                if file_name:",
            "                    form_file = UploadFile(",
            "                        content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)",
            "                    )",
            "                    fields[field_name].append(form_file)",
            "                else:",
            "                    try:",
            "                        fields[field_name].append(decode_json(post_data))",
            "                    except SerializationException:",
            "                        fields[field_name].append(post_data.decode(content_charset))",
            "",
            "    return {k: v if len(v) > 1 else v[0] for k, v in fields.items()}"
        ],
        "afterPatchFile": [
            "\"\"\"The contents of this file were adapted from sanic.",
            "",
            "MIT License",
            "",
            "Copyright (c) 2016-present Sanic Community",
            "",
            "Permission is hereby granted, free of charge, to any person obtaining a copy",
            "of this software and associated documentation files (the \"Software\"), to deal",
            "in the Software without restriction, including without limitation the rights",
            "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
            "copies of the Software, and to permit persons to whom the Software is",
            "furnished to do so, subject to the following conditions:",
            "",
            "The above copyright notice and this permission notice shall be included in all",
            "copies or substantial portions of the Software.",
            "",
            "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
            "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
            "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
            "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
            "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
            "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
            "SOFTWARE.",
            "\"\"\"",
            "",
            "import re",
            "from collections import defaultdict",
            "from email.utils import decode_rfc2231",
            "from typing import Any, DefaultDict, Dict, List, Tuple",
            "from urllib.parse import unquote",
            "",
            "from starlite.datastructures.upload_file import UploadFile",
            "from starlite.exceptions import SerializationException, ValidationException",
            "from starlite.utils.serialization import decode_json",
            "",
            "_token = r\"([\\w!#$%&'*+\\-.^_`|~]+)\"",
            "_quoted = r'\"([^\"]*)\"'",
            "_param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)",
            "_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')",
            "",
            "",
            "def parse_content_header(value: str) -> Tuple[str, Dict[str, str]]:",
            "    \"\"\"Parse content-type and content-disposition header values.",
            "",
            "    Args:",
            "        value: A header string value to parse.",
            "",
            "    Returns:",
            "        A tuple containing the normalized header string and a dictionary of parameters.",
            "    \"\"\"",
            "    value = _firefox_quote_escape.sub(\"%22\", value)",
            "    pos = value.find(\";\")",
            "    if pos == -1:",
            "        options: Dict[str, str] = {}",
            "    else:",
            "        options = {",
            "            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"') for m in _param.finditer(value[pos:])",
            "        }",
            "        value = value[:pos]",
            "    return value.strip().lower(), options",
            "",
            "",
            "def parse_body(body: bytes, boundary: bytes, multipart_form_part_limit: int) -> List[bytes]:",
            "    \"\"\"Split the body using the boundary",
            "        and validate the number of form parts is within the allowed limit.",
            "",
            "    :param body: The form body.",
            "    :param boundary: The boundary used to separate form components.",
            "    :param multipart_form_part_limit: The limit of allowed form components",
            "    :return:",
            "        A list of form components.",
            "    \"\"\"",
            "    if not (body and boundary):",
            "        return []",
            "",
            "    form_parts = body.split(boundary, multipart_form_part_limit + 3)[1:-1]",
            "",
            "    if len(form_parts) > multipart_form_part_limit:",
            "        raise ValidationException(",
            "            f\"number of multipart components exceeds the allowed limit of {multipart_form_part_limit}, \"",
            "            f\"this potentially indicates a DoS attack\"",
            "        )",
            "",
            "    return form_parts",
            "",
            "",
            "def parse_multipart_form(body: bytes, boundary: bytes, multipart_form_part_limit: int = 1000) -> Dict[str, Any]:",
            "    \"\"\"Parse multipart form data.",
            "",
            "    Args:",
            "        body: Body of the request.",
            "        boundary: Boundary of the multipart message.",
            "        multipart_form_part_limit: Limit of the number of parts allowed.",
            "",
            "    Returns:",
            "        A dictionary of parsed results.",
            "    \"\"\"",
            "",
            "    fields: DefaultDict[str, List[Any]] = defaultdict(list)",
            "",
            "    for form_part in parse_body(body=body, boundary=boundary, multipart_form_part_limit=multipart_form_part_limit):",
            "        file_name = None",
            "        content_type = \"text/plain\"",
            "        content_charset = \"utf-8\"",
            "        field_name = None",
            "        line_index = 2",
            "        line_end_index = 0",
            "        headers: List[Tuple[str, str]] = []",
            "",
            "        while line_end_index != -1:",
            "            line_end_index = form_part.find(b\"\\r\\n\", line_index)",
            "            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")",
            "",
            "            if not form_line:",
            "                break",
            "",
            "            line_index = line_end_index + 2",
            "            colon_index = form_line.index(\":\")",
            "            current_idx = colon_index + 2",
            "            form_header_field = form_line[0:colon_index].lower()",
            "            form_header_value, form_parameters = parse_content_header(form_line[current_idx:])",
            "",
            "            if form_header_field == \"content-disposition\":",
            "                field_name = form_parameters.get(\"name\")",
            "                file_name = form_parameters.get(\"filename\")",
            "",
            "                if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):",
            "                    encoding, _, value = decode_rfc2231(filename_with_asterisk)",
            "                    file_name = unquote(value, encoding=encoding or content_charset)",
            "",
            "            elif form_header_field == \"content-type\":",
            "                content_type = form_header_value",
            "                content_charset = form_parameters.get(\"charset\", \"utf-8\")",
            "            headers.append((form_header_field, form_header_value))",
            "",
            "        if field_name:",
            "            post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")",
            "            if file_name:",
            "                form_file = UploadFile(",
            "                    content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)",
            "                )",
            "                fields[field_name].append(form_file)",
            "            else:",
            "                try:",
            "                    fields[field_name].append(decode_json(post_data))",
            "                except SerializationException:",
            "                    fields[field_name].append(post_data.decode(content_charset))",
            "",
            "    return {k: v if len(v) > 1 else v[0] for k, v in fields.items()}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [],
            "36": [],
            "62": [
                "parse_multipart_form"
            ],
            "75": [
                "parse_multipart_form"
            ],
            "76": [
                "parse_multipart_form"
            ],
            "77": [
                "parse_multipart_form"
            ],
            "78": [
                "parse_multipart_form"
            ],
            "79": [
                "parse_multipart_form"
            ],
            "80": [
                "parse_multipart_form"
            ],
            "81": [
                "parse_multipart_form"
            ],
            "82": [
                "parse_multipart_form"
            ],
            "83": [
                "parse_multipart_form"
            ],
            "84": [
                "parse_multipart_form"
            ],
            "85": [
                "parse_multipart_form"
            ],
            "86": [
                "parse_multipart_form"
            ],
            "87": [
                "parse_multipart_form"
            ],
            "88": [
                "parse_multipart_form"
            ],
            "89": [
                "parse_multipart_form"
            ],
            "90": [
                "parse_multipart_form"
            ],
            "91": [
                "parse_multipart_form"
            ],
            "92": [
                "parse_multipart_form"
            ],
            "93": [
                "parse_multipart_form"
            ],
            "94": [
                "parse_multipart_form"
            ],
            "95": [
                "parse_multipart_form"
            ],
            "96": [
                "parse_multipart_form"
            ],
            "97": [
                "parse_multipart_form"
            ],
            "98": [
                "parse_multipart_form"
            ],
            "99": [
                "parse_multipart_form"
            ],
            "100": [
                "parse_multipart_form"
            ],
            "101": [
                "parse_multipart_form"
            ],
            "102": [
                "parse_multipart_form"
            ],
            "103": [
                "parse_multipart_form"
            ],
            "104": [
                "parse_multipart_form"
            ],
            "105": [
                "parse_multipart_form"
            ],
            "106": [
                "parse_multipart_form"
            ],
            "107": [
                "parse_multipart_form"
            ],
            "108": [
                "parse_multipart_form"
            ],
            "109": [
                "parse_multipart_form"
            ],
            "110": [
                "parse_multipart_form"
            ],
            "111": [
                "parse_multipart_form"
            ],
            "112": [
                "parse_multipart_form"
            ],
            "113": [
                "parse_multipart_form"
            ],
            "114": [
                "parse_multipart_form"
            ],
            "115": [
                "parse_multipart_form"
            ],
            "116": [
                "parse_multipart_form"
            ],
            "117": [
                "parse_multipart_form"
            ],
            "118": [
                "parse_multipart_form"
            ],
            "119": [
                "parse_multipart_form"
            ],
            "120": [
                "parse_multipart_form"
            ],
            "121": [
                "parse_multipart_form"
            ],
            "122": [
                "parse_multipart_form"
            ],
            "123": [
                "parse_multipart_form"
            ]
        },
        "addLocation": []
    },
    "starlite/params.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "     Equivalent to pattern in the OpenAPI specification."
            },
            "2": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "     \"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+    multipart_form_part_limit: Optional[int] = field(default=None)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "     def __hash__(self) -> int:  # pragma: no cover"
            },
            "7": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         \"\"\"Hash the dataclass in a safe way."
            },
            "8": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "     max_items: Optional[int] = None,"
            },
            "9": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "     min_length: Optional[int] = None,"
            },
            "10": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "     max_length: Optional[int] = None,"
            },
            "11": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    regex: Optional[str] = None"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+    regex: Optional[str] = None,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+    multipart_form_part_limit: Optional[int] = None"
            },
            "14": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 322,
                "PatchRowcode": " ) -> Any:"
            },
            "15": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "     \"\"\"Create an extended request body kwarg definition."
            },
            "16": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 324,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "             maxLength in the OpenAPI specification."
            },
            "18": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "         regex: A string representing a regex against which the given string will be matched."
            },
            "19": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "             Equivalent to pattern in the OpenAPI specification."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+            This limit is intended to protect from DoS attacks."
            },
            "22": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "     \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "     return BodyKwarg("
            },
            "24": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "         media_type=media_type,"
            },
            "25": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "         min_length=min_length,"
            },
            "26": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "         max_length=max_length,"
            },
            "27": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "         regex=regex,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+        multipart_form_part_limit=multipart_form_part_limit,"
            },
            "29": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "     )"
            },
            "30": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 384,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 385,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from dataclasses import asdict, dataclass, field",
            "from typing import TYPE_CHECKING, Any, Hashable, List, Optional, Union",
            "",
            "from starlite.enums import RequestEncodingType",
            "from starlite.types import Empty",
            "",
            "if TYPE_CHECKING:",
            "    from pydantic_openapi_schema.v3_1_0.example import Example",
            "    from pydantic_openapi_schema.v3_1_0.external_documentation import (",
            "        ExternalDocumentation,",
            "    )",
            "",
            "",
            "@dataclass(frozen=True)",
            "class ParameterKwarg:",
            "    \"\"\"Data container representing a parameter.\"\"\"",
            "",
            "    value_type: Any = field(default=Empty)",
            "    \"\"\"The field value - `Empty` by default.\"\"\"",
            "    header: Optional[str] = field(default=None)",
            "    \"\"\"The header parameter key - required for header parameters.\"\"\"",
            "    cookie: Optional[str] = field(default=None)",
            "    \"\"\"The cookie parameter key - required for cookie parameters.\"\"\"",
            "    query: Optional[str] = field(default=None)",
            "    \"\"\"The query parameter key for this parameter.\"\"\"",
            "    examples: Optional[List[\"Example\"]] = field(default=None)",
            "    \"\"\"A list of Example models.\"\"\"",
            "    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)",
            "    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"",
            "    content_encoding: Optional[str] = field(default=None)",
            "    \"\"\"The content encoding of the value.",
            "",
            "    Applicable on to string values. See OpenAPI 3.1 for details.",
            "    \"\"\"",
            "    required: Optional[bool] = field(default=None)",
            "    \"\"\"A boolean flag dictating whether this parameter is required.",
            "",
            "    If set to False, None values will be allowed. Defaults to True.",
            "    \"\"\"",
            "    default: Any = field(default=Empty)",
            "    \"\"\"A default value.",
            "",
            "    If const is true, this value is required.",
            "    \"\"\"",
            "    title: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"",
            "    description: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"",
            "    const: Optional[bool] = field(default=None)",
            "    \"\"\"A boolean flag dictating whether this parameter is a constant.",
            "",
            "    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to",
            "    be populated with the default value.",
            "    \"\"\"",
            "    gt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater than a given float or int.",
            "",
            "    Equivalent to exclusiveMinimum in the OpenAPI specification.",
            "    \"\"\"",
            "    ge: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater or equal to a given float or int.",
            "",
            "    Equivalent to minimum in the OpenAPI specification.",
            "    \"\"\"",
            "    lt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less than a given float or int.",
            "",
            "    Equivalent to exclusiveMaximum in the OpenAPI specification.",
            "    \"\"\"",
            "    le: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less or equal to a given float or int.",
            "",
            "    Equivalent to maximum in the OpenAPI specification.",
            "    \"\"\"",
            "    multiple_of: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to a multiple of a given float or int.",
            "",
            "    Equivalent to multipleOf in the OpenAPI specification.",
            "    \"\"\"",
            "    min_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a minimum number of items.",
            "",
            "    Equivalent to minItems in the OpenAPI specification.",
            "    \"\"\"",
            "    max_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a maximum number of items.",
            "",
            "    Equivalent to maxItems in the OpenAPI specification.",
            "    \"\"\"",
            "    min_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a minimum length.",
            "",
            "    Equivalent to minLength in the OpenAPI specification.",
            "    \"\"\"",
            "    max_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a maximum length.",
            "",
            "    Equivalent to maxLength in the OpenAPI specification.",
            "    \"\"\"",
            "    regex: Optional[str] = field(default=None)",
            "    \"\"\"A string representing a regex against which the given string will be matched.",
            "",
            "    Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "",
            "    def __hash__(self) -> int:  # pragma: no cover",
            "        \"\"\"Hash the dataclass in a safe way.",
            "",
            "        Returns:",
            "            A hash",
            "        \"\"\"",
            "        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))",
            "",
            "",
            "def Parameter(",
            "    value_type: Any = Empty,",
            "    *,",
            "    header: Optional[str] = None,",
            "    cookie: Optional[str] = None,",
            "    query: Optional[str] = None,",
            "    examples: Optional[List[\"Example\"]] = None,",
            "    external_docs: Optional[\"ExternalDocumentation\"] = None,",
            "    content_encoding: Optional[str] = None,",
            "    required: Optional[bool] = None,",
            "    default: Any = Empty,",
            "    title: Optional[str] = None,",
            "    description: Optional[str] = None,",
            "    const: Optional[bool] = None,",
            "    gt: Optional[float] = None,",
            "    ge: Optional[float] = None,",
            "    lt: Optional[float] = None,",
            "    le: Optional[float] = None,",
            "    multiple_of: Optional[float] = None,",
            "    min_items: Optional[int] = None,",
            "    max_items: Optional[int] = None,",
            "    min_length: Optional[int] = None,",
            "    max_length: Optional[int] = None,",
            "    regex: Optional[str] = None",
            ") -> Any:",
            "    \"\"\"Create an extended parameter kwarg definition.",
            "",
            "    Args:",
            "        value_type: `Empty` by default.",
            "        header: The header parameter key - required for header parameters.",
            "        cookie: The cookie parameter key - required for cookie parameters.",
            "        query: The query parameter key for this parameter.",
            "        examples: A list of Example models.",
            "        external_docs: A url pointing at external documentation for the given",
            "            parameter.",
            "        content_encoding: The content encoding of the value. Applicable on to string values. See",
            "            OpenAPI 3.1 for details.",
            "        required: A boolean flag dictating whether this parameter is required. If set to False, None",
            "            values will be allowed. Defaults to True.",
            "        default: A default value. If const is true, this value is required.",
            "        title: String value used in the title section of the OpenAPI schema for the given",
            "            parameter.",
            "        description: String value used in the description section of the OpenAPI schema for the",
            "            given parameter.",
            "        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed",
            "            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with",
            "            the default value.",
            "        gt: Constrict value to be greater than a given float or int. Equivalent to",
            "            exclusiveMinimum in the OpenAPI specification.",
            "        ge: Constrict value to be greater or equal to a given float or int. Equivalent to",
            "            minimum in the OpenAPI specification.",
            "        lt: Constrict value to be less than a given float or int. Equivalent to",
            "            exclusiveMaximum in the OpenAPI specification.",
            "        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum",
            "            in the OpenAPI specification.",
            "        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to",
            "            multipleOf in the OpenAPI specification.",
            "        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to",
            "            minItems in the OpenAPI specification.",
            "        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to",
            "            maxItems in the OpenAPI specification.",
            "        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to",
            "            minLength in the OpenAPI specification.",
            "        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to",
            "            maxLength in the OpenAPI specification.",
            "        regex: A string representing a regex against which the given string will be matched.",
            "            Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "    return ParameterKwarg(",
            "        value_type=value_type,",
            "        header=header,",
            "        cookie=cookie,",
            "        query=query,",
            "        examples=examples,",
            "        external_docs=external_docs,",
            "        content_encoding=content_encoding,",
            "        required=required,",
            "        default=default,",
            "        title=title,",
            "        description=description,",
            "        const=const,",
            "        gt=gt,",
            "        ge=ge,",
            "        lt=lt,",
            "        le=le,",
            "        multiple_of=multiple_of,",
            "        min_items=min_items,",
            "        max_items=max_items,",
            "        min_length=min_length,",
            "        max_length=max_length,",
            "        regex=regex,",
            "    )",
            "",
            "",
            "@dataclass(frozen=True)",
            "class BodyKwarg:",
            "    \"\"\"Data container representing a request body.\"\"\"",
            "",
            "    media_type: Union[str, \"RequestEncodingType\"] = field(default=RequestEncodingType.JSON)",
            "    \"\"\"Media-Type of the body.\"\"\"",
            "    examples: Optional[List[\"Example\"]] = field(default=None)",
            "    \"\"\"A list of Example models.\"\"\"",
            "    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)",
            "    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"",
            "    content_encoding: Optional[str] = field(default=None)",
            "    \"\"\"The content encoding of the value.",
            "",
            "    Applicable on to string values. See OpenAPI 3.1 for details.",
            "    \"\"\"",
            "    default: Any = field(default=Empty)",
            "    \"\"\"A default value.",
            "",
            "    If const is true, this value is required.",
            "    \"\"\"",
            "    title: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"",
            "    description: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"",
            "    const: Optional[bool] = field(default=None)",
            "    \"\"\"A boolean flag dictating whether this parameter is a constant.",
            "",
            "    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to",
            "    be populated with the default value.",
            "    \"\"\"",
            "    gt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater than a given float or int.",
            "",
            "    Equivalent to exclusiveMinimum in the OpenAPI specification.",
            "    \"\"\"",
            "    ge: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater or equal to a given float or int.",
            "",
            "    Equivalent to minimum in the OpenAPI specification.",
            "    \"\"\"",
            "    lt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less than a given float or int.",
            "",
            "    Equivalent to exclusiveMaximum in the OpenAPI specification.",
            "    \"\"\"",
            "    le: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less or equal to a given float or int.",
            "",
            "    Equivalent to maximum in the OpenAPI specification.",
            "    \"\"\"",
            "    multiple_of: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to a multiple of a given float or int.",
            "",
            "    Equivalent to multipleOf in the OpenAPI specification.",
            "    \"\"\"",
            "    min_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a minimum number of items.",
            "",
            "    Equivalent to minItems in the OpenAPI specification.",
            "    \"\"\"",
            "    max_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a maximum number of items.",
            "",
            "    Equivalent to maxItems in the OpenAPI specification.",
            "    \"\"\"",
            "    min_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a minimum length.",
            "",
            "    Equivalent to minLength in the OpenAPI specification.",
            "    \"\"\"",
            "    max_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a maximum length.",
            "",
            "    Equivalent to maxLength in the OpenAPI specification.",
            "    \"\"\"",
            "    regex: Optional[str] = field(default=None)",
            "    \"\"\"A string representing a regex against which the given string will be matched.",
            "",
            "    Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "",
            "    def __hash__(self) -> int:  # pragma: no cover",
            "        \"\"\"Hash the dataclass in a safe way.",
            "",
            "        Returns:",
            "            A hash",
            "        \"\"\"",
            "        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))",
            "",
            "",
            "def Body(",
            "    *,",
            "    media_type: Union[str, \"RequestEncodingType\"] = RequestEncodingType.JSON,",
            "    examples: Optional[List[\"Example\"]] = None,",
            "    external_docs: Optional[\"ExternalDocumentation\"] = None,",
            "    content_encoding: Optional[str] = None,",
            "    default: Any = Empty,",
            "    title: Optional[str] = None,",
            "    description: Optional[str] = None,",
            "    const: Optional[bool] = None,",
            "    gt: Optional[float] = None,",
            "    ge: Optional[float] = None,",
            "    lt: Optional[float] = None,",
            "    le: Optional[float] = None,",
            "    multiple_of: Optional[float] = None,",
            "    min_items: Optional[int] = None,",
            "    max_items: Optional[int] = None,",
            "    min_length: Optional[int] = None,",
            "    max_length: Optional[int] = None,",
            "    regex: Optional[str] = None",
            ") -> Any:",
            "    \"\"\"Create an extended request body kwarg definition.",
            "",
            "    Args:",
            "        media_type: Defaults to RequestEncodingType.JSON.",
            "        examples: A list of Example models.",
            "        external_docs: A url pointing at external documentation for the given",
            "            parameter.",
            "        content_encoding: The content encoding of the value. Applicable on to string values. See",
            "            OpenAPI 3.1 for details.",
            "        default: A default value. If const is true, this value is required.",
            "        title: String value used in the title section of the OpenAPI schema for the given",
            "            parameter.",
            "        description: String value used in the description section of the OpenAPI schema for the",
            "            given parameter.",
            "        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed",
            "            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with",
            "            the default value.",
            "        gt: Constrict value to be greater than a given float or int. Equivalent to",
            "            exclusiveMinimum in the OpenAPI specification.",
            "        ge: Constrict value to be greater or equal to a given float or int. Equivalent to",
            "            minimum in the OpenAPI specification.",
            "        lt: Constrict value to be less than a given float or int. Equivalent to",
            "            exclusiveMaximum in the OpenAPI specification.",
            "        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum",
            "            in the OpenAPI specification.",
            "        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to",
            "            multipleOf in the OpenAPI specification.",
            "        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to",
            "            minItems in the OpenAPI specification.",
            "        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to",
            "            maxItems in the OpenAPI specification.",
            "        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to",
            "            minLength in the OpenAPI specification.",
            "        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to",
            "            maxLength in the OpenAPI specification.",
            "        regex: A string representing a regex against which the given string will be matched.",
            "            Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "    return BodyKwarg(",
            "        media_type=media_type,",
            "        examples=examples,",
            "        external_docs=external_docs,",
            "        content_encoding=content_encoding,",
            "        default=default,",
            "        title=title,",
            "        description=description,",
            "        const=const,",
            "        gt=gt,",
            "        ge=ge,",
            "        lt=lt,",
            "        le=le,",
            "        multiple_of=multiple_of,",
            "        min_items=min_items,",
            "        max_items=max_items,",
            "        min_length=min_length,",
            "        max_length=max_length,",
            "        regex=regex,",
            "    )",
            "",
            "",
            "@dataclass(frozen=True)",
            "class DependencyKwarg:",
            "    \"\"\"Data container representing a dependency.\"\"\"",
            "",
            "    default: Any = field(default=Empty)",
            "    \"\"\"A default value.\"\"\"",
            "    skip_validation: bool = field(default=False)",
            "    \"\"\"Flag dictating whether to skip validation.\"\"\"",
            "",
            "    def __hash__(self) -> int:",
            "        \"\"\"Hash the dataclass in a safe way.",
            "",
            "        Returns:",
            "            A hash",
            "        \"\"\"",
            "        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))",
            "",
            "",
            "def Dependency(*, default: Any = Empty, skip_validation: bool = False) -> Any:",
            "    \"\"\"Create a dependency kwarg definition.",
            "",
            "    Args:",
            "        default: A default value to use in case a dependency is not provided.",
            "        skip_validation: If `True` provided dependency values are not validated by signature model.",
            "    \"\"\"",
            "    return DependencyKwarg(default=default, skip_validation=skip_validation)"
        ],
        "afterPatchFile": [
            "from dataclasses import asdict, dataclass, field",
            "from typing import TYPE_CHECKING, Any, Hashable, List, Optional, Union",
            "",
            "from starlite.enums import RequestEncodingType",
            "from starlite.types import Empty",
            "",
            "if TYPE_CHECKING:",
            "    from pydantic_openapi_schema.v3_1_0.example import Example",
            "    from pydantic_openapi_schema.v3_1_0.external_documentation import (",
            "        ExternalDocumentation,",
            "    )",
            "",
            "",
            "@dataclass(frozen=True)",
            "class ParameterKwarg:",
            "    \"\"\"Data container representing a parameter.\"\"\"",
            "",
            "    value_type: Any = field(default=Empty)",
            "    \"\"\"The field value - `Empty` by default.\"\"\"",
            "    header: Optional[str] = field(default=None)",
            "    \"\"\"The header parameter key - required for header parameters.\"\"\"",
            "    cookie: Optional[str] = field(default=None)",
            "    \"\"\"The cookie parameter key - required for cookie parameters.\"\"\"",
            "    query: Optional[str] = field(default=None)",
            "    \"\"\"The query parameter key for this parameter.\"\"\"",
            "    examples: Optional[List[\"Example\"]] = field(default=None)",
            "    \"\"\"A list of Example models.\"\"\"",
            "    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)",
            "    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"",
            "    content_encoding: Optional[str] = field(default=None)",
            "    \"\"\"The content encoding of the value.",
            "",
            "    Applicable on to string values. See OpenAPI 3.1 for details.",
            "    \"\"\"",
            "    required: Optional[bool] = field(default=None)",
            "    \"\"\"A boolean flag dictating whether this parameter is required.",
            "",
            "    If set to False, None values will be allowed. Defaults to True.",
            "    \"\"\"",
            "    default: Any = field(default=Empty)",
            "    \"\"\"A default value.",
            "",
            "    If const is true, this value is required.",
            "    \"\"\"",
            "    title: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"",
            "    description: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"",
            "    const: Optional[bool] = field(default=None)",
            "    \"\"\"A boolean flag dictating whether this parameter is a constant.",
            "",
            "    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to",
            "    be populated with the default value.",
            "    \"\"\"",
            "    gt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater than a given float or int.",
            "",
            "    Equivalent to exclusiveMinimum in the OpenAPI specification.",
            "    \"\"\"",
            "    ge: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater or equal to a given float or int.",
            "",
            "    Equivalent to minimum in the OpenAPI specification.",
            "    \"\"\"",
            "    lt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less than a given float or int.",
            "",
            "    Equivalent to exclusiveMaximum in the OpenAPI specification.",
            "    \"\"\"",
            "    le: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less or equal to a given float or int.",
            "",
            "    Equivalent to maximum in the OpenAPI specification.",
            "    \"\"\"",
            "    multiple_of: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to a multiple of a given float or int.",
            "",
            "    Equivalent to multipleOf in the OpenAPI specification.",
            "    \"\"\"",
            "    min_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a minimum number of items.",
            "",
            "    Equivalent to minItems in the OpenAPI specification.",
            "    \"\"\"",
            "    max_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a maximum number of items.",
            "",
            "    Equivalent to maxItems in the OpenAPI specification.",
            "    \"\"\"",
            "    min_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a minimum length.",
            "",
            "    Equivalent to minLength in the OpenAPI specification.",
            "    \"\"\"",
            "    max_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a maximum length.",
            "",
            "    Equivalent to maxLength in the OpenAPI specification.",
            "    \"\"\"",
            "    regex: Optional[str] = field(default=None)",
            "    \"\"\"A string representing a regex against which the given string will be matched.",
            "",
            "    Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "",
            "    def __hash__(self) -> int:  # pragma: no cover",
            "        \"\"\"Hash the dataclass in a safe way.",
            "",
            "        Returns:",
            "            A hash",
            "        \"\"\"",
            "        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))",
            "",
            "",
            "def Parameter(",
            "    value_type: Any = Empty,",
            "    *,",
            "    header: Optional[str] = None,",
            "    cookie: Optional[str] = None,",
            "    query: Optional[str] = None,",
            "    examples: Optional[List[\"Example\"]] = None,",
            "    external_docs: Optional[\"ExternalDocumentation\"] = None,",
            "    content_encoding: Optional[str] = None,",
            "    required: Optional[bool] = None,",
            "    default: Any = Empty,",
            "    title: Optional[str] = None,",
            "    description: Optional[str] = None,",
            "    const: Optional[bool] = None,",
            "    gt: Optional[float] = None,",
            "    ge: Optional[float] = None,",
            "    lt: Optional[float] = None,",
            "    le: Optional[float] = None,",
            "    multiple_of: Optional[float] = None,",
            "    min_items: Optional[int] = None,",
            "    max_items: Optional[int] = None,",
            "    min_length: Optional[int] = None,",
            "    max_length: Optional[int] = None,",
            "    regex: Optional[str] = None",
            ") -> Any:",
            "    \"\"\"Create an extended parameter kwarg definition.",
            "",
            "    Args:",
            "        value_type: `Empty` by default.",
            "        header: The header parameter key - required for header parameters.",
            "        cookie: The cookie parameter key - required for cookie parameters.",
            "        query: The query parameter key for this parameter.",
            "        examples: A list of Example models.",
            "        external_docs: A url pointing at external documentation for the given",
            "            parameter.",
            "        content_encoding: The content encoding of the value. Applicable on to string values. See",
            "            OpenAPI 3.1 for details.",
            "        required: A boolean flag dictating whether this parameter is required. If set to False, None",
            "            values will be allowed. Defaults to True.",
            "        default: A default value. If const is true, this value is required.",
            "        title: String value used in the title section of the OpenAPI schema for the given",
            "            parameter.",
            "        description: String value used in the description section of the OpenAPI schema for the",
            "            given parameter.",
            "        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed",
            "            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with",
            "            the default value.",
            "        gt: Constrict value to be greater than a given float or int. Equivalent to",
            "            exclusiveMinimum in the OpenAPI specification.",
            "        ge: Constrict value to be greater or equal to a given float or int. Equivalent to",
            "            minimum in the OpenAPI specification.",
            "        lt: Constrict value to be less than a given float or int. Equivalent to",
            "            exclusiveMaximum in the OpenAPI specification.",
            "        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum",
            "            in the OpenAPI specification.",
            "        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to",
            "            multipleOf in the OpenAPI specification.",
            "        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to",
            "            minItems in the OpenAPI specification.",
            "        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to",
            "            maxItems in the OpenAPI specification.",
            "        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to",
            "            minLength in the OpenAPI specification.",
            "        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to",
            "            maxLength in the OpenAPI specification.",
            "        regex: A string representing a regex against which the given string will be matched.",
            "            Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "    return ParameterKwarg(",
            "        value_type=value_type,",
            "        header=header,",
            "        cookie=cookie,",
            "        query=query,",
            "        examples=examples,",
            "        external_docs=external_docs,",
            "        content_encoding=content_encoding,",
            "        required=required,",
            "        default=default,",
            "        title=title,",
            "        description=description,",
            "        const=const,",
            "        gt=gt,",
            "        ge=ge,",
            "        lt=lt,",
            "        le=le,",
            "        multiple_of=multiple_of,",
            "        min_items=min_items,",
            "        max_items=max_items,",
            "        min_length=min_length,",
            "        max_length=max_length,",
            "        regex=regex,",
            "    )",
            "",
            "",
            "@dataclass(frozen=True)",
            "class BodyKwarg:",
            "    \"\"\"Data container representing a request body.\"\"\"",
            "",
            "    media_type: Union[str, \"RequestEncodingType\"] = field(default=RequestEncodingType.JSON)",
            "    \"\"\"Media-Type of the body.\"\"\"",
            "    examples: Optional[List[\"Example\"]] = field(default=None)",
            "    \"\"\"A list of Example models.\"\"\"",
            "    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)",
            "    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"",
            "    content_encoding: Optional[str] = field(default=None)",
            "    \"\"\"The content encoding of the value.",
            "",
            "    Applicable on to string values. See OpenAPI 3.1 for details.",
            "    \"\"\"",
            "    default: Any = field(default=Empty)",
            "    \"\"\"A default value.",
            "",
            "    If const is true, this value is required.",
            "    \"\"\"",
            "    title: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"",
            "    description: Optional[str] = field(default=None)",
            "    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"",
            "    const: Optional[bool] = field(default=None)",
            "    \"\"\"A boolean flag dictating whether this parameter is a constant.",
            "",
            "    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to",
            "    be populated with the default value.",
            "    \"\"\"",
            "    gt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater than a given float or int.",
            "",
            "    Equivalent to exclusiveMinimum in the OpenAPI specification.",
            "    \"\"\"",
            "    ge: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be greater or equal to a given float or int.",
            "",
            "    Equivalent to minimum in the OpenAPI specification.",
            "    \"\"\"",
            "    lt: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less than a given float or int.",
            "",
            "    Equivalent to exclusiveMaximum in the OpenAPI specification.",
            "    \"\"\"",
            "    le: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to be less or equal to a given float or int.",
            "",
            "    Equivalent to maximum in the OpenAPI specification.",
            "    \"\"\"",
            "    multiple_of: Optional[float] = field(default=None)",
            "    \"\"\"Constrict value to a multiple of a given float or int.",
            "",
            "    Equivalent to multipleOf in the OpenAPI specification.",
            "    \"\"\"",
            "    min_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a minimum number of items.",
            "",
            "    Equivalent to minItems in the OpenAPI specification.",
            "    \"\"\"",
            "    max_items: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a set or a list to have a maximum number of items.",
            "",
            "    Equivalent to maxItems in the OpenAPI specification.",
            "    \"\"\"",
            "    min_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a minimum length.",
            "",
            "    Equivalent to minLength in the OpenAPI specification.",
            "    \"\"\"",
            "    max_length: Optional[int] = field(default=None)",
            "    \"\"\"Constrict a string or bytes value to have a maximum length.",
            "",
            "    Equivalent to maxLength in the OpenAPI specification.",
            "    \"\"\"",
            "    regex: Optional[str] = field(default=None)",
            "    \"\"\"A string representing a regex against which the given string will be matched.",
            "",
            "    Equivalent to pattern in the OpenAPI specification.",
            "    \"\"\"",
            "    multipart_form_part_limit: Optional[int] = field(default=None)",
            "    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\"",
            "",
            "    def __hash__(self) -> int:  # pragma: no cover",
            "        \"\"\"Hash the dataclass in a safe way.",
            "",
            "        Returns:",
            "            A hash",
            "        \"\"\"",
            "        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))",
            "",
            "",
            "def Body(",
            "    *,",
            "    media_type: Union[str, \"RequestEncodingType\"] = RequestEncodingType.JSON,",
            "    examples: Optional[List[\"Example\"]] = None,",
            "    external_docs: Optional[\"ExternalDocumentation\"] = None,",
            "    content_encoding: Optional[str] = None,",
            "    default: Any = Empty,",
            "    title: Optional[str] = None,",
            "    description: Optional[str] = None,",
            "    const: Optional[bool] = None,",
            "    gt: Optional[float] = None,",
            "    ge: Optional[float] = None,",
            "    lt: Optional[float] = None,",
            "    le: Optional[float] = None,",
            "    multiple_of: Optional[float] = None,",
            "    min_items: Optional[int] = None,",
            "    max_items: Optional[int] = None,",
            "    min_length: Optional[int] = None,",
            "    max_length: Optional[int] = None,",
            "    regex: Optional[str] = None,",
            "    multipart_form_part_limit: Optional[int] = None",
            ") -> Any:",
            "    \"\"\"Create an extended request body kwarg definition.",
            "",
            "    Args:",
            "        media_type: Defaults to RequestEncodingType.JSON.",
            "        examples: A list of Example models.",
            "        external_docs: A url pointing at external documentation for the given",
            "            parameter.",
            "        content_encoding: The content encoding of the value. Applicable on to string values. See",
            "            OpenAPI 3.1 for details.",
            "        default: A default value. If const is true, this value is required.",
            "        title: String value used in the title section of the OpenAPI schema for the given",
            "            parameter.",
            "        description: String value used in the description section of the OpenAPI schema for the",
            "            given parameter.",
            "        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed",
            "            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with",
            "            the default value.",
            "        gt: Constrict value to be greater than a given float or int. Equivalent to",
            "            exclusiveMinimum in the OpenAPI specification.",
            "        ge: Constrict value to be greater or equal to a given float or int. Equivalent to",
            "            minimum in the OpenAPI specification.",
            "        lt: Constrict value to be less than a given float or int. Equivalent to",
            "            exclusiveMaximum in the OpenAPI specification.",
            "        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum",
            "            in the OpenAPI specification.",
            "        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to",
            "            multipleOf in the OpenAPI specification.",
            "        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to",
            "            minItems in the OpenAPI specification.",
            "        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to",
            "            maxItems in the OpenAPI specification.",
            "        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to",
            "            minLength in the OpenAPI specification.",
            "        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to",
            "            maxLength in the OpenAPI specification.",
            "        regex: A string representing a regex against which the given string will be matched.",
            "            Equivalent to pattern in the OpenAPI specification.",
            "        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.",
            "            This limit is intended to protect from DoS attacks.",
            "    \"\"\"",
            "    return BodyKwarg(",
            "        media_type=media_type,",
            "        examples=examples,",
            "        external_docs=external_docs,",
            "        content_encoding=content_encoding,",
            "        default=default,",
            "        title=title,",
            "        description=description,",
            "        const=const,",
            "        gt=gt,",
            "        ge=ge,",
            "        lt=lt,",
            "        le=le,",
            "        multiple_of=multiple_of,",
            "        min_items=min_items,",
            "        max_items=max_items,",
            "        min_length=min_length,",
            "        max_length=max_length,",
            "        regex=regex,",
            "        multipart_form_part_limit=multipart_form_part_limit,",
            "    )",
            "",
            "",
            "@dataclass(frozen=True)",
            "class DependencyKwarg:",
            "    \"\"\"Data container representing a dependency.\"\"\"",
            "",
            "    default: Any = field(default=Empty)",
            "    \"\"\"A default value.\"\"\"",
            "    skip_validation: bool = field(default=False)",
            "    \"\"\"Flag dictating whether to skip validation.\"\"\"",
            "",
            "    def __hash__(self) -> int:",
            "        \"\"\"Hash the dataclass in a safe way.",
            "",
            "        Returns:",
            "            A hash",
            "        \"\"\"",
            "        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))",
            "",
            "",
            "def Dependency(*, default: Any = Empty, skip_validation: bool = False) -> Any:",
            "    \"\"\"Create a dependency kwarg definition.",
            "",
            "    Args:",
            "        default: A default value to use in case a dependency is not provided.",
            "        skip_validation: If `True` provided dependency values are not validated by signature model.",
            "    \"\"\"",
            "    return DependencyKwarg(default=default, skip_validation=skip_validation)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "318": [
                "Body"
            ]
        },
        "addLocation": [
            "starlite.params.Body",
            "starlite.params.BodyKwarg.self"
        ]
    },
    "starlite/testing/create_test_client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     initial_state: Optional[Union[\"ImmutableState\", Dict[str, Any], Iterable[Tuple[str, Any]]]] = None,"
            },
            "1": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     logging_config: Optional[\"BaseLoggingConfig\"] = None,"
            },
            "2": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     middleware: Optional[List[\"Middleware\"]] = None,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    multipart_form_part_limit: int = 1000,"
            },
            "4": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,"
            },
            "5": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,"
            },
            "6": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     on_startup: Optional[List[\"LifeSpanHandler\"]] = None,"
            },
            "7": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         initial_state: An object from which to initialize the app state."
            },
            "8": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`."
            },
            "9": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         middleware: A list of :class:`Middleware <starlite.types.Middleware>`."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            This limit is intended to protect from DoS attacks."
            },
            "12": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         on_app_init:  A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive"
            },
            "13": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "                 an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with"
            },
            "14": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "                 the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more"
            },
            "15": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "             initial_state=initial_state,"
            },
            "16": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "             logging_config=logging_config,"
            },
            "17": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "             middleware=middleware,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            multipart_form_part_limit=multipart_form_part_limit,"
            },
            "19": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "             on_app_init=on_app_init,"
            },
            "20": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             on_shutdown=on_shutdown,"
            },
            "21": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "             on_startup=on_startup,"
            }
        },
        "frontPatchFile": [
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Literal,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlite.app import DEFAULT_CACHE_CONFIG, Starlite",
            "from starlite.testing.client.sync_client import TestClient",
            "",
            "if TYPE_CHECKING:",
            "    from starlite import (",
            "        BaseLoggingConfig,",
            "        CacheConfig,",
            "        CompressionConfig,",
            "        CORSConfig,",
            "        CSRFConfig,",
            "        OpenAPIConfig,",
            "        PluginProtocol,",
            "        Request,",
            "        StaticFilesConfig,",
            "        TemplateConfig,",
            "        WebSocket,",
            "    )",
            "    from starlite.config import AllowedHostsConfig",
            "    from starlite.datastructures.state import ImmutableState",
            "    from starlite.middleware.session.base import BaseBackendConfig",
            "    from starlite.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        Dependencies,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        LifeSpanHandler,",
            "        LifeSpanHookHandler,",
            "        Middleware,",
            "        OnAppInitHandler,",
            "        ParametersMap,",
            "        ResponseType,",
            "        SingleOrList,",
            "    )",
            "",
            "",
            "def create_test_client(",
            "    route_handlers: Union[\"ControllerRouterHandler\", List[\"ControllerRouterHandler\"]],",
            "    *,",
            "    after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,",
            "    after_request: Optional[\"AfterRequestHookHandler\"] = None,",
            "    after_response: Optional[\"AfterResponseHookHandler\"] = None,",
            "    after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,",
            "    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",",
            "    backend_options: Optional[Dict[str, Any]] = None,",
            "    base_url: str = \"http://testserver.local\",",
            "    before_request: Optional[\"BeforeRequestHookHandler\"] = None,",
            "    before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,",
            "    before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    cache_config: \"CacheConfig\" = DEFAULT_CACHE_CONFIG,",
            "    compression_config: Optional[\"CompressionConfig\"] = None,",
            "    cors_config: Optional[\"CORSConfig\"] = None,",
            "    csrf_config: Optional[\"CSRFConfig\"] = None,",
            "    dependencies: Optional[\"Dependencies\"] = None,",
            "    exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,",
            "    guards: Optional[List[\"Guard\"]] = None,",
            "    initial_state: Optional[Union[\"ImmutableState\", Dict[str, Any], Iterable[Tuple[str, Any]]]] = None,",
            "    logging_config: Optional[\"BaseLoggingConfig\"] = None,",
            "    middleware: Optional[List[\"Middleware\"]] = None,",
            "    on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,",
            "    on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,",
            "    on_startup: Optional[List[\"LifeSpanHandler\"]] = None,",
            "    openapi_config: Optional[\"OpenAPIConfig\"] = None,",
            "    parameters: Optional[\"ParametersMap\"] = None,",
            "    plugins: Optional[List[\"PluginProtocol\"]] = None,",
            "    raise_server_exceptions: bool = True,",
            "    request_class: Optional[Type[\"Request\"]] = None,",
            "    response_class: Optional[\"ResponseType\"] = None,",
            "    root_path: str = \"\",",
            "    session_config: Optional[\"BaseBackendConfig\"] = None,",
            "    static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,",
            "    template_config: Optional[\"TemplateConfig\"] = None,",
            "    websocket_class: Optional[Type[\"WebSocket\"]] = None,",
            ") -> TestClient[\"Starlite\"]:",
            "    \"\"\"Create a Starlite app instance and initializes it.",
            "",
            "    :class:`TestClient <starlite.testing.TestClient>` with it.",
            "",
            "    Notes:",
            "        - This function should be called as a context manager to ensure async startup and shutdown are",
            "            handled correctly.",
            "",
            "    Examples:",
            "        .. code-block: python",
            "",
            "            from starlite import get, create_test_client",
            "",
            "",
            "            @get(\"/some-path\")",
            "            def my_handler() -> dict[str, str]:",
            "                return {\"hello\": \"world\"}",
            "",
            "",
            "            def test_my_handler() -> None:",
            "                with create_test_client(my_handler) as client:",
            "                    response == client.get(\"/some-path\")",
            "                    assert response.json() == {\"hello\": \"world\"}",
            "",
            "",
            "    Args:",
            "        route_handlers: A single handler or a list of route handlers, which can include instances of",
            "            :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or",
            "            any function decorated by the route handler decorators.",
            "        after_exception: An application level :class:`exception event handler <starlite.types.AfterExceptionHookHandler>`.",
            "            This hook is called after an exception occurs. In difference to exception handlers, it is not meant to",
            "            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "        after_request: A sync or async function executed after the route handler function returned and the response",
            "            object has been resolved. Receives the response object which may be any subclass of",
            "            :class:`Response <starlite.response.Response>`.",
            "        after_response: A sync or async function called after the response has been awaited. It receives the",
            "            :class:`Request <starlite.connection.Request>` object and should not return any values.",
            "        after_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.",
            "            This hook is called during the ASGI shutdown, after all callables in the ``on_shutdown``",
            "            list have been called.",
            "        after_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.",
            "            This hook is called during the ASGI startup, after all callables in the ``on_startup``",
            "            list have been called.",
            "        allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.",
            "        backend: The async backend to use, options are \"asyncio\" or \"trio\".",
            "        backend_options: ``anyio`` options.",
            "        base_url: URL scheme and domain for test request paths, e.g. 'http://testserver'.",
            "        before_request: A sync or async function called immediately before calling the route handler.",
            "            Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is",
            "            used for the response, bypassing the route handler.",
            "        before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or",
            "            list thereof. This hook is called when the ASGI send function is called.",
            "        before_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is",
            "            called during the ASGI shutdown, before any callables in the ``on_shutdown`` list have been called.",
            "        before_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is",
            "            called during the ASGI startup, before any callables in the ``on_startup`` list have been called.",
            "        cache_config: Configures caching behavior of the application.",
            "        compression_config: Configures compression behaviour of the application, this enabled a builtin or user",
            "            defined Compression middleware.",
            "        cors_config: If set this enables the builtin CORS middleware.",
            "        csrf_config: If set this enables the builtin CSRF middleware.",
            "        dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.",
            "        exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.",
            "        guards: A list of :class:`Guard <starlite.types.Guard>` callables.",
            "        initial_state: An object from which to initialize the app state.",
            "        logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.",
            "        middleware: A list of :class:`Middleware <starlite.types.Middleware>`.",
            "        on_app_init:  A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive",
            "                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with",
            "                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more",
            "                than one handler is registered they are called in the order they are provided.",
            "        on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "            application shutdown.",
            "        on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "            application startup.",
            "        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`",
            "        parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all",
            "            application paths.",
            "        plugins: List of plugins.",
            "        request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for",
            "            http connections.",
            "        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of",
            "            wrapping them in an HTTP response.",
            "        response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.",
            "        root_path: Path prefix for requests.",
            "        static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`",
            "        session_config: Configuration for Session Middleware class to create raw session cookies for request to the",
            "            route handlers.",
            "        template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`",
            "        websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for",
            "            websocket connections.",
            "",
            "    Returns:",
            "        An instance of :class:`TestClient <starlite.testing.TestClient>` with a created app instance.",
            "    \"\"\"",
            "    return TestClient[Starlite](",
            "        app=Starlite(",
            "            after_exception=after_exception,",
            "            after_request=after_request,",
            "            after_response=after_response,",
            "            after_shutdown=after_shutdown,",
            "            after_startup=after_startup,",
            "            allowed_hosts=allowed_hosts,",
            "            before_request=before_request,",
            "            before_send=before_send,",
            "            before_shutdown=before_shutdown,",
            "            before_startup=before_startup,",
            "            cache_config=cache_config,",
            "            compression_config=compression_config,",
            "            cors_config=cors_config,",
            "            csrf_config=csrf_config,",
            "            dependencies=dependencies,",
            "            exception_handlers=exception_handlers,",
            "            guards=guards,",
            "            initial_state=initial_state,",
            "            logging_config=logging_config,",
            "            middleware=middleware,",
            "            on_app_init=on_app_init,",
            "            on_shutdown=on_shutdown,",
            "            on_startup=on_startup,",
            "            openapi_config=openapi_config,",
            "            parameters=parameters,",
            "            plugins=plugins,",
            "            request_class=request_class,",
            "            response_class=response_class,",
            "            route_handlers=cast(\"Any\", route_handlers if isinstance(route_handlers, list) else [route_handlers]),",
            "            static_files_config=static_files_config,",
            "            template_config=template_config,",
            "            websocket_class=websocket_class,",
            "        ),",
            "        backend=backend,",
            "        backend_options=backend_options,",
            "        base_url=base_url,",
            "        raise_server_exceptions=raise_server_exceptions,",
            "        root_path=root_path,",
            "        session_config=session_config,",
            "    )"
        ],
        "afterPatchFile": [
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Literal,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "from starlite.app import DEFAULT_CACHE_CONFIG, Starlite",
            "from starlite.testing.client.sync_client import TestClient",
            "",
            "if TYPE_CHECKING:",
            "    from starlite import (",
            "        BaseLoggingConfig,",
            "        CacheConfig,",
            "        CompressionConfig,",
            "        CORSConfig,",
            "        CSRFConfig,",
            "        OpenAPIConfig,",
            "        PluginProtocol,",
            "        Request,",
            "        StaticFilesConfig,",
            "        TemplateConfig,",
            "        WebSocket,",
            "    )",
            "    from starlite.config import AllowedHostsConfig",
            "    from starlite.datastructures.state import ImmutableState",
            "    from starlite.middleware.session.base import BaseBackendConfig",
            "    from starlite.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        Dependencies,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        LifeSpanHandler,",
            "        LifeSpanHookHandler,",
            "        Middleware,",
            "        OnAppInitHandler,",
            "        ParametersMap,",
            "        ResponseType,",
            "        SingleOrList,",
            "    )",
            "",
            "",
            "def create_test_client(",
            "    route_handlers: Union[\"ControllerRouterHandler\", List[\"ControllerRouterHandler\"]],",
            "    *,",
            "    after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,",
            "    after_request: Optional[\"AfterRequestHookHandler\"] = None,",
            "    after_response: Optional[\"AfterResponseHookHandler\"] = None,",
            "    after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,",
            "    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",",
            "    backend_options: Optional[Dict[str, Any]] = None,",
            "    base_url: str = \"http://testserver.local\",",
            "    before_request: Optional[\"BeforeRequestHookHandler\"] = None,",
            "    before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,",
            "    before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,",
            "    cache_config: \"CacheConfig\" = DEFAULT_CACHE_CONFIG,",
            "    compression_config: Optional[\"CompressionConfig\"] = None,",
            "    cors_config: Optional[\"CORSConfig\"] = None,",
            "    csrf_config: Optional[\"CSRFConfig\"] = None,",
            "    dependencies: Optional[\"Dependencies\"] = None,",
            "    exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,",
            "    guards: Optional[List[\"Guard\"]] = None,",
            "    initial_state: Optional[Union[\"ImmutableState\", Dict[str, Any], Iterable[Tuple[str, Any]]]] = None,",
            "    logging_config: Optional[\"BaseLoggingConfig\"] = None,",
            "    middleware: Optional[List[\"Middleware\"]] = None,",
            "    multipart_form_part_limit: int = 1000,",
            "    on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,",
            "    on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,",
            "    on_startup: Optional[List[\"LifeSpanHandler\"]] = None,",
            "    openapi_config: Optional[\"OpenAPIConfig\"] = None,",
            "    parameters: Optional[\"ParametersMap\"] = None,",
            "    plugins: Optional[List[\"PluginProtocol\"]] = None,",
            "    raise_server_exceptions: bool = True,",
            "    request_class: Optional[Type[\"Request\"]] = None,",
            "    response_class: Optional[\"ResponseType\"] = None,",
            "    root_path: str = \"\",",
            "    session_config: Optional[\"BaseBackendConfig\"] = None,",
            "    static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,",
            "    template_config: Optional[\"TemplateConfig\"] = None,",
            "    websocket_class: Optional[Type[\"WebSocket\"]] = None,",
            ") -> TestClient[\"Starlite\"]:",
            "    \"\"\"Create a Starlite app instance and initializes it.",
            "",
            "    :class:`TestClient <starlite.testing.TestClient>` with it.",
            "",
            "    Notes:",
            "        - This function should be called as a context manager to ensure async startup and shutdown are",
            "            handled correctly.",
            "",
            "    Examples:",
            "        .. code-block: python",
            "",
            "            from starlite import get, create_test_client",
            "",
            "",
            "            @get(\"/some-path\")",
            "            def my_handler() -> dict[str, str]:",
            "                return {\"hello\": \"world\"}",
            "",
            "",
            "            def test_my_handler() -> None:",
            "                with create_test_client(my_handler) as client:",
            "                    response == client.get(\"/some-path\")",
            "                    assert response.json() == {\"hello\": \"world\"}",
            "",
            "",
            "    Args:",
            "        route_handlers: A single handler or a list of route handlers, which can include instances of",
            "            :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or",
            "            any function decorated by the route handler decorators.",
            "        after_exception: An application level :class:`exception event handler <starlite.types.AfterExceptionHookHandler>`.",
            "            This hook is called after an exception occurs. In difference to exception handlers, it is not meant to",
            "            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "        after_request: A sync or async function executed after the route handler function returned and the response",
            "            object has been resolved. Receives the response object which may be any subclass of",
            "            :class:`Response <starlite.response.Response>`.",
            "        after_response: A sync or async function called after the response has been awaited. It receives the",
            "            :class:`Request <starlite.connection.Request>` object and should not return any values.",
            "        after_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.",
            "            This hook is called during the ASGI shutdown, after all callables in the ``on_shutdown``",
            "            list have been called.",
            "        after_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.",
            "            This hook is called during the ASGI startup, after all callables in the ``on_startup``",
            "            list have been called.",
            "        allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.",
            "        backend: The async backend to use, options are \"asyncio\" or \"trio\".",
            "        backend_options: ``anyio`` options.",
            "        base_url: URL scheme and domain for test request paths, e.g. 'http://testserver'.",
            "        before_request: A sync or async function called immediately before calling the route handler.",
            "            Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is",
            "            used for the response, bypassing the route handler.",
            "        before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or",
            "            list thereof. This hook is called when the ASGI send function is called.",
            "        before_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is",
            "            called during the ASGI shutdown, before any callables in the ``on_shutdown`` list have been called.",
            "        before_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is",
            "            called during the ASGI startup, before any callables in the ``on_startup`` list have been called.",
            "        cache_config: Configures caching behavior of the application.",
            "        compression_config: Configures compression behaviour of the application, this enabled a builtin or user",
            "            defined Compression middleware.",
            "        cors_config: If set this enables the builtin CORS middleware.",
            "        csrf_config: If set this enables the builtin CSRF middleware.",
            "        dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.",
            "        exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.",
            "        guards: A list of :class:`Guard <starlite.types.Guard>` callables.",
            "        initial_state: An object from which to initialize the app state.",
            "        logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.",
            "        middleware: A list of :class:`Middleware <starlite.types.Middleware>`.",
            "        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.",
            "            This limit is intended to protect from DoS attacks.",
            "        on_app_init:  A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive",
            "                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with",
            "                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more",
            "                than one handler is registered they are called in the order they are provided.",
            "        on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "            application shutdown.",
            "        on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during",
            "            application startup.",
            "        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`",
            "        parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all",
            "            application paths.",
            "        plugins: List of plugins.",
            "        request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for",
            "            http connections.",
            "        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of",
            "            wrapping them in an HTTP response.",
            "        response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.",
            "        root_path: Path prefix for requests.",
            "        static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`",
            "        session_config: Configuration for Session Middleware class to create raw session cookies for request to the",
            "            route handlers.",
            "        template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`",
            "        websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for",
            "            websocket connections.",
            "",
            "    Returns:",
            "        An instance of :class:`TestClient <starlite.testing.TestClient>` with a created app instance.",
            "    \"\"\"",
            "    return TestClient[Starlite](",
            "        app=Starlite(",
            "            after_exception=after_exception,",
            "            after_request=after_request,",
            "            after_response=after_response,",
            "            after_shutdown=after_shutdown,",
            "            after_startup=after_startup,",
            "            allowed_hosts=allowed_hosts,",
            "            before_request=before_request,",
            "            before_send=before_send,",
            "            before_shutdown=before_shutdown,",
            "            before_startup=before_startup,",
            "            cache_config=cache_config,",
            "            compression_config=compression_config,",
            "            cors_config=cors_config,",
            "            csrf_config=csrf_config,",
            "            dependencies=dependencies,",
            "            exception_handlers=exception_handlers,",
            "            guards=guards,",
            "            initial_state=initial_state,",
            "            logging_config=logging_config,",
            "            middleware=middleware,",
            "            multipart_form_part_limit=multipart_form_part_limit,",
            "            on_app_init=on_app_init,",
            "            on_shutdown=on_shutdown,",
            "            on_startup=on_startup,",
            "            openapi_config=openapi_config,",
            "            parameters=parameters,",
            "            plugins=plugins,",
            "            request_class=request_class,",
            "            response_class=response_class,",
            "            route_handlers=cast(\"Any\", route_handlers if isinstance(route_handlers, list) else [route_handlers]),",
            "            static_files_config=static_files_config,",
            "            template_config=template_config,",
            "            websocket_class=websocket_class,",
            "        ),",
            "        backend=backend,",
            "        backend_options=backend_options,",
            "        base_url=base_url,",
            "        raise_server_exceptions=raise_server_exceptions,",
            "        root_path=root_path,",
            "        session_config=session_config,",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "label_studio.core.settings.base"
        ]
    }
}