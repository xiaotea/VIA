{
    "two_factor/views/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import warnings"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from base64 import b32encode"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from binascii import unhexlify"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import time"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import django_otp"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import qrcode"
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from django.contrib.auth.forms import AuthenticationForm"
            },
            "8": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from django.contrib.auth.views import SuccessURLAllowedHostsMixin"
            },
            "9": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from django.contrib.sites.shortcuts import get_current_site"
            },
            "10": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.forms import Form"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from django.forms import Form, ValidationError"
            },
            "12": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django.http import Http404, HttpResponse, HttpResponseRedirect"
            },
            "13": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django.shortcuts import redirect, resolve_url"
            },
            "14": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.urls import reverse"
            },
            "15": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from django.utils.decorators import method_decorator"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from django.utils.functional import cached_property"
            },
            "17": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from django.utils.http import is_safe_url"
            },
            "18": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from django.utils.module_loading import import_string"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from django.utils.translation import gettext as _"
            },
            "20": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from django.views.decorators.cache import never_cache"
            },
            "21": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from django.views.decorators.csrf import csrf_protect"
            },
            "22": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from django.views.decorators.debug import sensitive_post_parameters"
            },
            "23": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         'backup': False,"
            },
            "24": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     }"
            },
            "25": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     redirect_authenticated_user = False"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    storage_name = 'two_factor.views.utils.LoginStorage'"
            },
            "27": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     def has_token_step(self):"
            },
            "29": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         return default_device(self.get_user())"
            },
            "30": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         return default_device(self.get_user()) and \\"
            },
            "31": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             'token' not in self.storage.validated_step_data"
            },
            "32": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+    @cached_property"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+    def expired(self):"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        login_timeout = getattr(settings, 'TWO_FACTOR_LOGIN_TIMEOUT', 600)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        if login_timeout == 0:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            return False"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        expiration_time = self.storage.data.get(\"authentication_time\", 0) + login_timeout"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        return int(time.time()) > expiration_time"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     condition_dict = {"
            },
            "42": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         'token': has_token_step,"
            },
            "43": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         'backup': has_backup_step,"
            },
            "44": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         super().__init__(**kwargs)"
            },
            "45": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         self.user_cache = None"
            },
            "46": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         self.device_cache = None"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        self.show_timeout_error = False"
            },
            "48": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "     def post(self, *args, **kwargs):"
            },
            "50": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "         \"\"\""
            },
            "51": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         The user can select a particular device to challenge, being the backup"
            },
            "52": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         devices added to the account."
            },
            "53": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         \"\"\""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        if wizard_goto_step == 'auth':"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+            self.storage.reset()"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        if self.expired and self.steps.current != 'auth':"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            logger.info(\"User's authentication flow has timed out. The user \""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                        \"has been redirected to the initial auth form.\")"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            self.storage.reset()"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            self.show_timeout_error = True"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+            return self.render_goto_step('auth')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         # Generating a challenge doesn't require to validate the form."
            },
            "67": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         if 'challenge_device' in self.request.POST:"
            },
            "68": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             return self.render_goto_step('token')"
            },
            "69": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             }"
            },
            "70": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         return {}"
            },
            "71": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+    def get_done_form_list(self):"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        \"\"\""
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        Return the forms that should be processed during the final step"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        \"\"\""
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        # Intentionally do not process the auth form on the final step. We"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        # haven't stored this data, and it isn't required to login the user"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        form_list = self.get_form_list()"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        form_list.pop('auth')"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        return form_list"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+    def process_step(self, form):"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        \"\"\""
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        Process an individual step in the flow"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        \"\"\""
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        # To prevent saving any private auth data to the session store, we"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        # validate the authentication form, determine the resulting user, then"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        # only store the minimum needed to login that user (the user's primary"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        # key and the backend used)"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        if self.steps.current == 'auth':"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+            user = form.is_valid() and form.user_cache"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            self.storage.reset()"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            self.storage.authenticated_user = user"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            self.storage.data[\"authentication_time\"] = int(time.time())"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+            # By returning None when the user clicks the \"back\" button to the"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            # auth step the form will be blank with validation warnings"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+            return None"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        return super().process_step(form)"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+    def process_step_files(self, form):"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+        \"\"\""
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        Process the files submitted from a specific test"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        \"\"\""
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        if self.steps.current == 'auth':"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            return {}"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        return super().process_step_files(form)"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+    def get_form(self, *args, **kwargs):"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        \"\"\""
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        Returns the form for the step"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        \"\"\""
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        form = super().get_form(*args, **kwargs)"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        if self.show_timeout_error:"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            form.cleaned_data = getattr(form, 'cleaned_data', {})"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            form.add_error(None, ValidationError(_('Your session has timed out. Please login again.')))"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        return form"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+"
            },
            "120": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "     def get_device(self, step=None):"
            },
            "121": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         \"\"\""
            },
            "122": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         Returns the OTP device selected by the user, or his default device."
            },
            "123": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         if not a valid user; see also issue #65."
            },
            "124": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         \"\"\""
            },
            "125": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         if not self.user_cache:"
            },
            "126": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            form_obj = self.get_form(step='auth',"
            },
            "127": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                     data=self.storage.get_step_data('auth'))"
            },
            "128": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.user_cache = form_obj.is_valid() and form_obj.user_cache"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+            self.user_cache = self.storage.authenticated_user"
            },
            "130": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         return self.user_cache"
            },
            "131": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 265,
                "PatchRowcode": " "
            },
            "132": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "     def get_context_data(self, form, **kwargs):"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import warnings",
            "from base64 import b32encode",
            "from binascii import unhexlify",
            "",
            "import django_otp",
            "import qrcode",
            "import qrcode.image.svg",
            "from django.conf import settings",
            "from django.contrib.auth import REDIRECT_FIELD_NAME, login",
            "from django.contrib.auth.decorators import login_required",
            "from django.contrib.auth.forms import AuthenticationForm",
            "from django.contrib.auth.views import SuccessURLAllowedHostsMixin",
            "from django.contrib.sites.shortcuts import get_current_site",
            "from django.forms import Form",
            "from django.http import Http404, HttpResponse, HttpResponseRedirect",
            "from django.shortcuts import redirect, resolve_url",
            "from django.urls import reverse",
            "from django.utils.decorators import method_decorator",
            "from django.utils.http import is_safe_url",
            "from django.utils.module_loading import import_string",
            "from django.views.decorators.cache import never_cache",
            "from django.views.decorators.csrf import csrf_protect",
            "from django.views.decorators.debug import sensitive_post_parameters",
            "from django.views.generic import DeleteView, FormView, TemplateView",
            "from django.views.generic.base import View",
            "from django_otp.decorators import otp_required",
            "from django_otp.plugins.otp_static.models import StaticDevice, StaticToken",
            "",
            "from two_factor import signals",
            "from two_factor.models import get_available_methods, random_hex_str",
            "from two_factor.utils import totp_digits",
            "",
            "from ..forms import (",
            "    AuthenticationTokenForm, BackupTokenForm, DeviceValidationForm, MethodForm,",
            "    PhoneNumberForm, PhoneNumberMethodForm, TOTPDeviceForm, YubiKeyDeviceForm,",
            ")",
            "from ..models import PhoneDevice, get_available_phone_methods",
            "from ..utils import backup_phones, default_device, get_otpauth_url",
            "from .utils import IdempotentSessionWizardView, class_view_decorator",
            "",
            "try:",
            "    from otp_yubikey.models import ValidationService, RemoteYubikeyDevice",
            "except ImportError:",
            "    ValidationService = RemoteYubikeyDevice = None",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@class_view_decorator(sensitive_post_parameters())",
            "@class_view_decorator(never_cache)",
            "class LoginView(SuccessURLAllowedHostsMixin, IdempotentSessionWizardView):",
            "    \"\"\"",
            "    View for handling the login process, including OTP verification.",
            "",
            "    The login process is composed like a wizard. The first step asks for the",
            "    user's credentials. If the credentials are correct, the wizard proceeds to",
            "    the OTP verification step. If the user has a default OTP device configured,",
            "    that device is asked to generate a token (send sms / call phone) and the",
            "    user is asked to provide the generated token. The backup devices are also",
            "    listed, allowing the user to select a backup device for verification.",
            "    \"\"\"",
            "    template_name = 'two_factor/core/login.html'",
            "    form_list = (",
            "        ('auth', AuthenticationForm),",
            "        ('token', AuthenticationTokenForm),",
            "        ('backup', BackupTokenForm),",
            "    )",
            "    idempotent_dict = {",
            "        'token': False,",
            "        'backup': False,",
            "    }",
            "    redirect_authenticated_user = False",
            "",
            "    def has_token_step(self):",
            "        return default_device(self.get_user())",
            "",
            "    def has_backup_step(self):",
            "        return default_device(self.get_user()) and \\",
            "            'token' not in self.storage.validated_step_data",
            "",
            "    condition_dict = {",
            "        'token': has_token_step,",
            "        'backup': has_backup_step,",
            "    }",
            "    redirect_field_name = REDIRECT_FIELD_NAME",
            "",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "        self.user_cache = None",
            "        self.device_cache = None",
            "",
            "    def post(self, *args, **kwargs):",
            "        \"\"\"",
            "        The user can select a particular device to challenge, being the backup",
            "        devices added to the account.",
            "        \"\"\"",
            "        # Generating a challenge doesn't require to validate the form.",
            "        if 'challenge_device' in self.request.POST:",
            "            return self.render_goto_step('token')",
            "",
            "        return super().post(*args, **kwargs)",
            "",
            "    def done(self, form_list, **kwargs):",
            "        \"\"\"",
            "        Login the user and redirect to the desired page.",
            "        \"\"\"",
            "        login(self.request, self.get_user())",
            "",
            "        redirect_to = self.get_success_url()",
            "",
            "        device = getattr(self.get_user(), 'otp_device', None)",
            "        if device:",
            "            signals.user_verified.send(sender=__name__, request=self.request,",
            "                                       user=self.get_user(), device=device)",
            "        return redirect(redirect_to)",
            "",
            "    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)",
            "    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L63",
            "    def get_success_url(self):",
            "        url = self.get_redirect_url()",
            "        return url or resolve_url(settings.LOGIN_REDIRECT_URL)",
            "",
            "    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)",
            "    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L67",
            "    def get_redirect_url(self):",
            "        \"\"\"Return the user-originating redirect URL if it's safe.\"\"\"",
            "        redirect_to = self.request.POST.get(",
            "            self.redirect_field_name,",
            "            self.request.GET.get(self.redirect_field_name, '')",
            "        )",
            "        url_is_safe = is_safe_url(",
            "            url=redirect_to,",
            "            allowed_hosts=self.get_success_url_allowed_hosts(),",
            "            require_https=self.request.is_secure(),",
            "        )",
            "        return redirect_to if url_is_safe else ''",
            "",
            "    def get_form_kwargs(self, step=None):",
            "        \"\"\"",
            "        AuthenticationTokenForm requires the user kwarg.",
            "        \"\"\"",
            "        if step == 'auth':",
            "            return {",
            "                'request': self.request",
            "            }",
            "        if step in ('token', 'backup'):",
            "            return {",
            "                'user': self.get_user(),",
            "                'initial_device': self.get_device(step),",
            "            }",
            "        return {}",
            "",
            "    def get_device(self, step=None):",
            "        \"\"\"",
            "        Returns the OTP device selected by the user, or his default device.",
            "        \"\"\"",
            "        if not self.device_cache:",
            "            challenge_device_id = self.request.POST.get('challenge_device', None)",
            "            if challenge_device_id:",
            "                for device in backup_phones(self.get_user()):",
            "                    if device.persistent_id == challenge_device_id:",
            "                        self.device_cache = device",
            "                        break",
            "            if step == 'backup':",
            "                try:",
            "                    self.device_cache = self.get_user().staticdevice_set.get(name='backup')",
            "                except StaticDevice.DoesNotExist:",
            "                    pass",
            "            if not self.device_cache:",
            "                self.device_cache = default_device(self.get_user())",
            "        return self.device_cache",
            "",
            "    def render(self, form=None, **kwargs):",
            "        \"\"\"",
            "        If the user selected a device, ask the device to generate a challenge;",
            "        either making a phone call or sending a text message.",
            "        \"\"\"",
            "        if self.steps.current == 'token':",
            "            self.get_device().generate_challenge()",
            "        return super().render(form, **kwargs)",
            "",
            "    def get_user(self):",
            "        \"\"\"",
            "        Returns the user authenticated by the AuthenticationForm. Returns False",
            "        if not a valid user; see also issue #65.",
            "        \"\"\"",
            "        if not self.user_cache:",
            "            form_obj = self.get_form(step='auth',",
            "                                     data=self.storage.get_step_data('auth'))",
            "            self.user_cache = form_obj.is_valid() and form_obj.user_cache",
            "        return self.user_cache",
            "",
            "    def get_context_data(self, form, **kwargs):",
            "        \"\"\"",
            "        Adds user's default and backup OTP devices to the context.",
            "        \"\"\"",
            "        context = super().get_context_data(form, **kwargs)",
            "        if self.steps.current == 'token':",
            "            context['device'] = self.get_device()",
            "            context['other_devices'] = [",
            "                phone for phone in backup_phones(self.get_user())",
            "                if phone != self.get_device()]",
            "            try:",
            "                context['backup_tokens'] = self.get_user().staticdevice_set\\",
            "                    .get(name='backup').token_set.count()",
            "            except StaticDevice.DoesNotExist:",
            "                context['backup_tokens'] = 0",
            "",
            "        if getattr(settings, 'LOGOUT_REDIRECT_URL', None):",
            "            context['cancel_url'] = resolve_url(settings.LOGOUT_REDIRECT_URL)",
            "        elif getattr(settings, 'LOGOUT_URL', None):",
            "            warnings.warn(",
            "                \"LOGOUT_URL has been replaced by LOGOUT_REDIRECT_URL, please \"",
            "                \"review the URL and update your settings.\",",
            "                DeprecationWarning)",
            "            context['cancel_url'] = resolve_url(settings.LOGOUT_URL)",
            "        return context",
            "",
            "    # Copied from django.conrib.auth.views.LoginView  (Branch: stable/1.11.x)",
            "    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L49",
            "    @method_decorator(sensitive_post_parameters())",
            "    @method_decorator(csrf_protect)",
            "    @method_decorator(never_cache)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if self.redirect_authenticated_user and self.request.user.is_authenticated:",
            "            redirect_to = self.get_success_url()",
            "            if redirect_to == self.request.path:",
            "                raise ValueError(",
            "                    \"Redirection loop for authenticated user detected. Check that \"",
            "                    \"your LOGIN_REDIRECT_URL doesn't point to a login page.\"",
            "                )",
            "            return HttpResponseRedirect(redirect_to)",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(login_required)",
            "class SetupView(IdempotentSessionWizardView):",
            "    \"\"\"",
            "    View for handling OTP setup using a wizard.",
            "",
            "    The first step of the wizard shows an introduction text, explaining how OTP",
            "    works and why it should be enabled. The user has to select the verification",
            "    method (generator / call / sms) in the second step. Depending on the method",
            "    selected, the third step configures the device. For the generator method, a",
            "    QR code is shown which can be scanned using a mobile phone app and the user",
            "    is asked to provide a generated token. For call and sms methods, the user",
            "    provides the phone number which is then validated in the final step.",
            "    \"\"\"",
            "    success_url = 'two_factor:setup_complete'",
            "    qrcode_url = 'two_factor:qr'",
            "    template_name = 'two_factor/core/setup.html'",
            "    session_key_name = 'django_two_factor-qr_secret_key'",
            "    initial_dict = {}",
            "    form_list = (",
            "        ('welcome', Form),",
            "        ('method', MethodForm),",
            "        ('generator', TOTPDeviceForm),",
            "        ('sms', PhoneNumberForm),",
            "        ('call', PhoneNumberForm),",
            "        ('validation', DeviceValidationForm),",
            "        ('yubikey', YubiKeyDeviceForm),",
            "    )",
            "    condition_dict = {",
            "        'generator': lambda self: self.get_method() == 'generator',",
            "        'call': lambda self: self.get_method() == 'call',",
            "        'sms': lambda self: self.get_method() == 'sms',",
            "        'validation': lambda self: self.get_method() in ('sms', 'call'),",
            "        'yubikey': lambda self: self.get_method() == 'yubikey',",
            "    }",
            "    idempotent_dict = {",
            "        'yubikey': False,",
            "    }",
            "",
            "    def get_method(self):",
            "        method_data = self.storage.validated_step_data.get('method', {})",
            "        return method_data.get('method', None)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Start the setup wizard. Redirect if already enabled.",
            "        \"\"\"",
            "        if default_device(self.request.user):",
            "            return redirect(self.success_url)",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def get_form_list(self):",
            "        \"\"\"",
            "        Check if there is only one method, then skip the MethodForm from form_list",
            "        \"\"\"",
            "        form_list = super().get_form_list()",
            "        available_methods = get_available_methods()",
            "        if len(available_methods) == 1:",
            "            form_list.pop('method', None)",
            "            method_key, _ = available_methods[0]",
            "            self.storage.validated_step_data['method'] = {'method': method_key}",
            "        return form_list",
            "",
            "    def render_next_step(self, form, **kwargs):",
            "        \"\"\"",
            "        In the validation step, ask the device to generate a challenge.",
            "        \"\"\"",
            "        next_step = self.steps.next",
            "        if next_step == 'validation':",
            "            try:",
            "                self.get_device().generate_challenge()",
            "                kwargs[\"challenge_succeeded\"] = True",
            "            except Exception:",
            "                logger.exception(\"Could not generate challenge\")",
            "                kwargs[\"challenge_succeeded\"] = False",
            "        return super().render_next_step(form, **kwargs)",
            "",
            "    def done(self, form_list, **kwargs):",
            "        \"\"\"",
            "        Finish the wizard. Save all forms and redirect.",
            "        \"\"\"",
            "        # Remove secret key used for QR code generation",
            "        try:",
            "            del self.request.session[self.session_key_name]",
            "        except KeyError:",
            "            pass",
            "",
            "        # TOTPDeviceForm",
            "        if self.get_method() == 'generator':",
            "            form = [form for form in form_list if isinstance(form, TOTPDeviceForm)][0]",
            "            device = form.save()",
            "",
            "        # PhoneNumberForm / YubiKeyDeviceForm",
            "        elif self.get_method() in ('call', 'sms', 'yubikey'):",
            "            device = self.get_device()",
            "            device.save()",
            "",
            "        else:",
            "            raise NotImplementedError(\"Unknown method '%s'\" % self.get_method())",
            "",
            "        django_otp.login(self.request, device)",
            "        return redirect(self.success_url)",
            "",
            "    def get_form_kwargs(self, step=None):",
            "        kwargs = {}",
            "        if step == 'generator':",
            "            kwargs.update({",
            "                'key': self.get_key(step),",
            "                'user': self.request.user,",
            "            })",
            "        if step in ('validation', 'yubikey'):",
            "            kwargs.update({",
            "                'device': self.get_device()",
            "            })",
            "        metadata = self.get_form_metadata(step)",
            "        if metadata:",
            "            kwargs.update({",
            "                'metadata': metadata,",
            "            })",
            "        return kwargs",
            "",
            "    def get_device(self, **kwargs):",
            "        \"\"\"",
            "        Uses the data from the setup step and generated key to recreate device.",
            "",
            "        Only used for call / sms -- generator uses other procedure.",
            "        \"\"\"",
            "        method = self.get_method()",
            "        kwargs = kwargs or {}",
            "        kwargs['name'] = 'default'",
            "        kwargs['user'] = self.request.user",
            "",
            "        if method in ('call', 'sms'):",
            "            kwargs['method'] = method",
            "            kwargs['number'] = self.storage.validated_step_data\\",
            "                .get(method, {}).get('number')",
            "            return PhoneDevice(key=self.get_key(method), **kwargs)",
            "",
            "        if method == 'yubikey':",
            "            kwargs['public_id'] = self.storage.validated_step_data\\",
            "                .get('yubikey', {}).get('token', '')[:-32]",
            "            try:",
            "                kwargs['service'] = ValidationService.objects.get(name='default')",
            "            except ValidationService.DoesNotExist:",
            "                raise KeyError(\"No ValidationService found with name 'default'\")",
            "            except ValidationService.MultipleObjectsReturned:",
            "                raise KeyError(\"Multiple ValidationService found with name 'default'\")",
            "            return RemoteYubikeyDevice(**kwargs)",
            "",
            "    def get_key(self, step):",
            "        self.storage.extra_data.setdefault('keys', {})",
            "        if step in self.storage.extra_data['keys']:",
            "            return self.storage.extra_data['keys'].get(step)",
            "        key = random_hex_str(20)",
            "        self.storage.extra_data['keys'][step] = key",
            "        return key",
            "",
            "    def get_context_data(self, form, **kwargs):",
            "        context = super().get_context_data(form, **kwargs)",
            "        if self.steps.current == 'generator':",
            "            key = self.get_key('generator')",
            "            rawkey = unhexlify(key.encode('ascii'))",
            "            b32key = b32encode(rawkey).decode('utf-8')",
            "            self.request.session[self.session_key_name] = b32key",
            "            context.update({",
            "                'QR_URL': reverse(self.qrcode_url)",
            "            })",
            "        elif self.steps.current == 'validation':",
            "            context['device'] = self.get_device()",
            "        context['cancel_url'] = resolve_url(settings.LOGIN_REDIRECT_URL)",
            "        return context",
            "",
            "    def process_step(self, form):",
            "        if hasattr(form, 'metadata'):",
            "            self.storage.extra_data.setdefault('forms', {})",
            "            self.storage.extra_data['forms'][self.steps.current] = form.metadata",
            "        return super().process_step(form)",
            "",
            "    def get_form_metadata(self, step):",
            "        self.storage.extra_data.setdefault('forms', {})",
            "        return self.storage.extra_data['forms'].get(step, None)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class BackupTokensView(FormView):",
            "    \"\"\"",
            "    View for listing and generating backup tokens.",
            "",
            "    A user can generate a number of static backup tokens. When the user loses",
            "    its phone, these backup tokens can be used for verification. These backup",
            "    tokens should be stored in a safe location; either in a safe or underneath",
            "    a pillow ;-).",
            "    \"\"\"",
            "    form_class = Form",
            "    success_url = 'two_factor:backup_tokens'",
            "    template_name = 'two_factor/core/backup_tokens.html'",
            "    number_of_tokens = 10",
            "",
            "    def get_device(self):",
            "        return self.request.user.staticdevice_set.get_or_create(name='backup')[0]",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = super().get_context_data(**kwargs)",
            "        context['device'] = self.get_device()",
            "        return context",
            "",
            "    def form_valid(self, form):",
            "        \"\"\"",
            "        Delete existing backup codes and generate new ones.",
            "        \"\"\"",
            "        device = self.get_device()",
            "        device.token_set.all().delete()",
            "        for n in range(self.number_of_tokens):",
            "            device.token_set.create(token=StaticToken.random_token())",
            "",
            "        return redirect(self.success_url)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class PhoneSetupView(IdempotentSessionWizardView):",
            "    \"\"\"",
            "    View for configuring a phone number for receiving tokens.",
            "",
            "    A user can have multiple backup :class:`~two_factor.models.PhoneDevice`",
            "    for receiving OTP tokens. If the primary phone number is not available, as",
            "    the battery might have drained or the phone is lost, these backup phone",
            "    numbers can be used for verification.",
            "    \"\"\"",
            "    template_name = 'two_factor/core/phone_register.html'",
            "    success_url = settings.LOGIN_REDIRECT_URL",
            "    form_list = (",
            "        ('setup', PhoneNumberMethodForm),",
            "        ('validation', DeviceValidationForm),",
            "    )",
            "    key_name = 'key'",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Start the setup wizard. Redirect if no phone methods available.",
            "        \"\"\"",
            "        if not get_available_phone_methods():",
            "            return redirect(self.success_url)",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def done(self, form_list, **kwargs):",
            "        \"\"\"",
            "        Store the device and redirect to profile page.",
            "        \"\"\"",
            "        self.get_device(user=self.request.user, name='backup').save()",
            "        return redirect(self.success_url)",
            "",
            "    def render_next_step(self, form, **kwargs):",
            "        \"\"\"",
            "        In the validation step, ask the device to generate a challenge.",
            "        \"\"\"",
            "        next_step = self.steps.next",
            "        if next_step == 'validation':",
            "            self.get_device().generate_challenge()",
            "        return super().render_next_step(form, **kwargs)",
            "",
            "    def get_form_kwargs(self, step=None):",
            "        \"\"\"",
            "        Provide the device to the DeviceValidationForm.",
            "        \"\"\"",
            "        if step == 'validation':",
            "            return {'device': self.get_device()}",
            "        return {}",
            "",
            "    def get_device(self, **kwargs):",
            "        \"\"\"",
            "        Uses the data from the setup step and generated key to recreate device.",
            "        \"\"\"",
            "        kwargs = kwargs or {}",
            "        kwargs.update(self.storage.validated_step_data.get('setup', {}))",
            "        return PhoneDevice(key=self.get_key(), **kwargs)",
            "",
            "    def get_key(self):",
            "        \"\"\"",
            "        The key is preserved between steps and stored as ascii in the session.",
            "        \"\"\"",
            "        if self.key_name not in self.storage.extra_data:",
            "            key = random_hex_str(20)",
            "            self.storage.extra_data[self.key_name] = key",
            "        return self.storage.extra_data[self.key_name]",
            "",
            "    def get_context_data(self, form, **kwargs):",
            "        kwargs.setdefault('cancel_url', resolve_url(self.success_url))",
            "        return super().get_context_data(form, **kwargs)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class PhoneDeleteView(DeleteView):",
            "    \"\"\"",
            "    View for removing a phone number used for verification.",
            "    \"\"\"",
            "    success_url = settings.LOGIN_REDIRECT_URL",
            "",
            "    def get_queryset(self):",
            "        return self.request.user.phonedevice_set.filter(name='backup')",
            "",
            "    def get_success_url(self):",
            "        return resolve_url(self.success_url)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class SetupCompleteView(TemplateView):",
            "    \"\"\"",
            "    View congratulation the user when OTP setup has completed.",
            "    \"\"\"",
            "    template_name = 'two_factor/core/setup_complete.html'",
            "",
            "    def get_context_data(self):",
            "        return {",
            "            'phone_methods': get_available_phone_methods(),",
            "        }",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(login_required)",
            "class QRGeneratorView(View):",
            "    \"\"\"",
            "    View returns an SVG image with the OTP token information",
            "    \"\"\"",
            "    http_method_names = ['get']",
            "    default_qr_factory = 'qrcode.image.svg.SvgPathImage'",
            "    session_key_name = 'django_two_factor-qr_secret_key'",
            "",
            "    # The qrcode library only supports PNG and SVG for now",
            "    image_content_types = {",
            "        'PNG': 'image/png',",
            "        'SVG': 'image/svg+xml; charset=utf-8',",
            "    }",
            "",
            "    def get_issuer(self):",
            "        return get_current_site(self.request).name",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        # Get the data from the session",
            "        try:",
            "            key = self.request.session[self.session_key_name]",
            "        except KeyError:",
            "            raise Http404()",
            "",
            "        # Get data for qrcode",
            "        image_factory_string = getattr(settings, 'TWO_FACTOR_QR_FACTORY', self.default_qr_factory)",
            "        image_factory = import_string(image_factory_string)",
            "        content_type = self.image_content_types[image_factory.kind]",
            "        try:",
            "            username = self.request.user.get_username()",
            "        except AttributeError:",
            "            username = self.request.user.username",
            "",
            "        otpauth_url = get_otpauth_url(accountname=username,",
            "                                      issuer=self.get_issuer(),",
            "                                      secret=key,",
            "                                      digits=totp_digits())",
            "",
            "        # Make and return QR code",
            "        img = qrcode.make(otpauth_url, image_factory=image_factory)",
            "        resp = HttpResponse(content_type=content_type)",
            "        img.save(resp)",
            "        return resp"
        ],
        "afterPatchFile": [
            "import logging",
            "import warnings",
            "from base64 import b32encode",
            "from binascii import unhexlify",
            "import time",
            "",
            "import django_otp",
            "import qrcode",
            "import qrcode.image.svg",
            "from django.conf import settings",
            "from django.contrib.auth import REDIRECT_FIELD_NAME, login",
            "from django.contrib.auth.decorators import login_required",
            "from django.contrib.auth.forms import AuthenticationForm",
            "from django.contrib.auth.views import SuccessURLAllowedHostsMixin",
            "from django.contrib.sites.shortcuts import get_current_site",
            "from django.forms import Form, ValidationError",
            "from django.http import Http404, HttpResponse, HttpResponseRedirect",
            "from django.shortcuts import redirect, resolve_url",
            "from django.urls import reverse",
            "from django.utils.decorators import method_decorator",
            "from django.utils.functional import cached_property",
            "from django.utils.http import is_safe_url",
            "from django.utils.module_loading import import_string",
            "from django.utils.translation import gettext as _",
            "from django.views.decorators.cache import never_cache",
            "from django.views.decorators.csrf import csrf_protect",
            "from django.views.decorators.debug import sensitive_post_parameters",
            "from django.views.generic import DeleteView, FormView, TemplateView",
            "from django.views.generic.base import View",
            "from django_otp.decorators import otp_required",
            "from django_otp.plugins.otp_static.models import StaticDevice, StaticToken",
            "",
            "from two_factor import signals",
            "from two_factor.models import get_available_methods, random_hex_str",
            "from two_factor.utils import totp_digits",
            "",
            "from ..forms import (",
            "    AuthenticationTokenForm, BackupTokenForm, DeviceValidationForm, MethodForm,",
            "    PhoneNumberForm, PhoneNumberMethodForm, TOTPDeviceForm, YubiKeyDeviceForm,",
            ")",
            "from ..models import PhoneDevice, get_available_phone_methods",
            "from ..utils import backup_phones, default_device, get_otpauth_url",
            "from .utils import IdempotentSessionWizardView, class_view_decorator",
            "",
            "try:",
            "    from otp_yubikey.models import ValidationService, RemoteYubikeyDevice",
            "except ImportError:",
            "    ValidationService = RemoteYubikeyDevice = None",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@class_view_decorator(sensitive_post_parameters())",
            "@class_view_decorator(never_cache)",
            "class LoginView(SuccessURLAllowedHostsMixin, IdempotentSessionWizardView):",
            "    \"\"\"",
            "    View for handling the login process, including OTP verification.",
            "",
            "    The login process is composed like a wizard. The first step asks for the",
            "    user's credentials. If the credentials are correct, the wizard proceeds to",
            "    the OTP verification step. If the user has a default OTP device configured,",
            "    that device is asked to generate a token (send sms / call phone) and the",
            "    user is asked to provide the generated token. The backup devices are also",
            "    listed, allowing the user to select a backup device for verification.",
            "    \"\"\"",
            "    template_name = 'two_factor/core/login.html'",
            "    form_list = (",
            "        ('auth', AuthenticationForm),",
            "        ('token', AuthenticationTokenForm),",
            "        ('backup', BackupTokenForm),",
            "    )",
            "    idempotent_dict = {",
            "        'token': False,",
            "        'backup': False,",
            "    }",
            "    redirect_authenticated_user = False",
            "    storage_name = 'two_factor.views.utils.LoginStorage'",
            "",
            "    def has_token_step(self):",
            "        return default_device(self.get_user())",
            "",
            "    def has_backup_step(self):",
            "        return default_device(self.get_user()) and \\",
            "            'token' not in self.storage.validated_step_data",
            "",
            "    @cached_property",
            "    def expired(self):",
            "        login_timeout = getattr(settings, 'TWO_FACTOR_LOGIN_TIMEOUT', 600)",
            "        if login_timeout == 0:",
            "            return False",
            "        expiration_time = self.storage.data.get(\"authentication_time\", 0) + login_timeout",
            "        return int(time.time()) > expiration_time",
            "",
            "    condition_dict = {",
            "        'token': has_token_step,",
            "        'backup': has_backup_step,",
            "    }",
            "    redirect_field_name = REDIRECT_FIELD_NAME",
            "",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "        self.user_cache = None",
            "        self.device_cache = None",
            "        self.show_timeout_error = False",
            "",
            "    def post(self, *args, **kwargs):",
            "        \"\"\"",
            "        The user can select a particular device to challenge, being the backup",
            "        devices added to the account.",
            "        \"\"\"",
            "        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)",
            "",
            "        if wizard_goto_step == 'auth':",
            "            self.storage.reset()",
            "",
            "        if self.expired and self.steps.current != 'auth':",
            "            logger.info(\"User's authentication flow has timed out. The user \"",
            "                        \"has been redirected to the initial auth form.\")",
            "            self.storage.reset()",
            "            self.show_timeout_error = True",
            "            return self.render_goto_step('auth')",
            "",
            "        # Generating a challenge doesn't require to validate the form.",
            "        if 'challenge_device' in self.request.POST:",
            "            return self.render_goto_step('token')",
            "",
            "        return super().post(*args, **kwargs)",
            "",
            "    def done(self, form_list, **kwargs):",
            "        \"\"\"",
            "        Login the user and redirect to the desired page.",
            "        \"\"\"",
            "        login(self.request, self.get_user())",
            "",
            "        redirect_to = self.get_success_url()",
            "",
            "        device = getattr(self.get_user(), 'otp_device', None)",
            "        if device:",
            "            signals.user_verified.send(sender=__name__, request=self.request,",
            "                                       user=self.get_user(), device=device)",
            "        return redirect(redirect_to)",
            "",
            "    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)",
            "    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L63",
            "    def get_success_url(self):",
            "        url = self.get_redirect_url()",
            "        return url or resolve_url(settings.LOGIN_REDIRECT_URL)",
            "",
            "    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)",
            "    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L67",
            "    def get_redirect_url(self):",
            "        \"\"\"Return the user-originating redirect URL if it's safe.\"\"\"",
            "        redirect_to = self.request.POST.get(",
            "            self.redirect_field_name,",
            "            self.request.GET.get(self.redirect_field_name, '')",
            "        )",
            "        url_is_safe = is_safe_url(",
            "            url=redirect_to,",
            "            allowed_hosts=self.get_success_url_allowed_hosts(),",
            "            require_https=self.request.is_secure(),",
            "        )",
            "        return redirect_to if url_is_safe else ''",
            "",
            "    def get_form_kwargs(self, step=None):",
            "        \"\"\"",
            "        AuthenticationTokenForm requires the user kwarg.",
            "        \"\"\"",
            "        if step == 'auth':",
            "            return {",
            "                'request': self.request",
            "            }",
            "        if step in ('token', 'backup'):",
            "            return {",
            "                'user': self.get_user(),",
            "                'initial_device': self.get_device(step),",
            "            }",
            "        return {}",
            "",
            "    def get_done_form_list(self):",
            "        \"\"\"",
            "        Return the forms that should be processed during the final step",
            "        \"\"\"",
            "        # Intentionally do not process the auth form on the final step. We",
            "        # haven't stored this data, and it isn't required to login the user",
            "        form_list = self.get_form_list()",
            "        form_list.pop('auth')",
            "        return form_list",
            "",
            "    def process_step(self, form):",
            "        \"\"\"",
            "        Process an individual step in the flow",
            "        \"\"\"",
            "        # To prevent saving any private auth data to the session store, we",
            "        # validate the authentication form, determine the resulting user, then",
            "        # only store the minimum needed to login that user (the user's primary",
            "        # key and the backend used)",
            "        if self.steps.current == 'auth':",
            "            user = form.is_valid() and form.user_cache",
            "            self.storage.reset()",
            "            self.storage.authenticated_user = user",
            "            self.storage.data[\"authentication_time\"] = int(time.time())",
            "",
            "            # By returning None when the user clicks the \"back\" button to the",
            "            # auth step the form will be blank with validation warnings",
            "            return None",
            "",
            "        return super().process_step(form)",
            "",
            "    def process_step_files(self, form):",
            "        \"\"\"",
            "        Process the files submitted from a specific test",
            "        \"\"\"",
            "        if self.steps.current == 'auth':",
            "            return {}",
            "        return super().process_step_files(form)",
            "",
            "    def get_form(self, *args, **kwargs):",
            "        \"\"\"",
            "        Returns the form for the step",
            "        \"\"\"",
            "        form = super().get_form(*args, **kwargs)",
            "        if self.show_timeout_error:",
            "            form.cleaned_data = getattr(form, 'cleaned_data', {})",
            "            form.add_error(None, ValidationError(_('Your session has timed out. Please login again.')))",
            "        return form",
            "",
            "    def get_device(self, step=None):",
            "        \"\"\"",
            "        Returns the OTP device selected by the user, or his default device.",
            "        \"\"\"",
            "        if not self.device_cache:",
            "            challenge_device_id = self.request.POST.get('challenge_device', None)",
            "            if challenge_device_id:",
            "                for device in backup_phones(self.get_user()):",
            "                    if device.persistent_id == challenge_device_id:",
            "                        self.device_cache = device",
            "                        break",
            "            if step == 'backup':",
            "                try:",
            "                    self.device_cache = self.get_user().staticdevice_set.get(name='backup')",
            "                except StaticDevice.DoesNotExist:",
            "                    pass",
            "            if not self.device_cache:",
            "                self.device_cache = default_device(self.get_user())",
            "        return self.device_cache",
            "",
            "    def render(self, form=None, **kwargs):",
            "        \"\"\"",
            "        If the user selected a device, ask the device to generate a challenge;",
            "        either making a phone call or sending a text message.",
            "        \"\"\"",
            "        if self.steps.current == 'token':",
            "            self.get_device().generate_challenge()",
            "        return super().render(form, **kwargs)",
            "",
            "    def get_user(self):",
            "        \"\"\"",
            "        Returns the user authenticated by the AuthenticationForm. Returns False",
            "        if not a valid user; see also issue #65.",
            "        \"\"\"",
            "        if not self.user_cache:",
            "            self.user_cache = self.storage.authenticated_user",
            "        return self.user_cache",
            "",
            "    def get_context_data(self, form, **kwargs):",
            "        \"\"\"",
            "        Adds user's default and backup OTP devices to the context.",
            "        \"\"\"",
            "        context = super().get_context_data(form, **kwargs)",
            "        if self.steps.current == 'token':",
            "            context['device'] = self.get_device()",
            "            context['other_devices'] = [",
            "                phone for phone in backup_phones(self.get_user())",
            "                if phone != self.get_device()]",
            "            try:",
            "                context['backup_tokens'] = self.get_user().staticdevice_set\\",
            "                    .get(name='backup').token_set.count()",
            "            except StaticDevice.DoesNotExist:",
            "                context['backup_tokens'] = 0",
            "",
            "        if getattr(settings, 'LOGOUT_REDIRECT_URL', None):",
            "            context['cancel_url'] = resolve_url(settings.LOGOUT_REDIRECT_URL)",
            "        elif getattr(settings, 'LOGOUT_URL', None):",
            "            warnings.warn(",
            "                \"LOGOUT_URL has been replaced by LOGOUT_REDIRECT_URL, please \"",
            "                \"review the URL and update your settings.\",",
            "                DeprecationWarning)",
            "            context['cancel_url'] = resolve_url(settings.LOGOUT_URL)",
            "        return context",
            "",
            "    # Copied from django.conrib.auth.views.LoginView  (Branch: stable/1.11.x)",
            "    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L49",
            "    @method_decorator(sensitive_post_parameters())",
            "    @method_decorator(csrf_protect)",
            "    @method_decorator(never_cache)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if self.redirect_authenticated_user and self.request.user.is_authenticated:",
            "            redirect_to = self.get_success_url()",
            "            if redirect_to == self.request.path:",
            "                raise ValueError(",
            "                    \"Redirection loop for authenticated user detected. Check that \"",
            "                    \"your LOGIN_REDIRECT_URL doesn't point to a login page.\"",
            "                )",
            "            return HttpResponseRedirect(redirect_to)",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(login_required)",
            "class SetupView(IdempotentSessionWizardView):",
            "    \"\"\"",
            "    View for handling OTP setup using a wizard.",
            "",
            "    The first step of the wizard shows an introduction text, explaining how OTP",
            "    works and why it should be enabled. The user has to select the verification",
            "    method (generator / call / sms) in the second step. Depending on the method",
            "    selected, the third step configures the device. For the generator method, a",
            "    QR code is shown which can be scanned using a mobile phone app and the user",
            "    is asked to provide a generated token. For call and sms methods, the user",
            "    provides the phone number which is then validated in the final step.",
            "    \"\"\"",
            "    success_url = 'two_factor:setup_complete'",
            "    qrcode_url = 'two_factor:qr'",
            "    template_name = 'two_factor/core/setup.html'",
            "    session_key_name = 'django_two_factor-qr_secret_key'",
            "    initial_dict = {}",
            "    form_list = (",
            "        ('welcome', Form),",
            "        ('method', MethodForm),",
            "        ('generator', TOTPDeviceForm),",
            "        ('sms', PhoneNumberForm),",
            "        ('call', PhoneNumberForm),",
            "        ('validation', DeviceValidationForm),",
            "        ('yubikey', YubiKeyDeviceForm),",
            "    )",
            "    condition_dict = {",
            "        'generator': lambda self: self.get_method() == 'generator',",
            "        'call': lambda self: self.get_method() == 'call',",
            "        'sms': lambda self: self.get_method() == 'sms',",
            "        'validation': lambda self: self.get_method() in ('sms', 'call'),",
            "        'yubikey': lambda self: self.get_method() == 'yubikey',",
            "    }",
            "    idempotent_dict = {",
            "        'yubikey': False,",
            "    }",
            "",
            "    def get_method(self):",
            "        method_data = self.storage.validated_step_data.get('method', {})",
            "        return method_data.get('method', None)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Start the setup wizard. Redirect if already enabled.",
            "        \"\"\"",
            "        if default_device(self.request.user):",
            "            return redirect(self.success_url)",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def get_form_list(self):",
            "        \"\"\"",
            "        Check if there is only one method, then skip the MethodForm from form_list",
            "        \"\"\"",
            "        form_list = super().get_form_list()",
            "        available_methods = get_available_methods()",
            "        if len(available_methods) == 1:",
            "            form_list.pop('method', None)",
            "            method_key, _ = available_methods[0]",
            "            self.storage.validated_step_data['method'] = {'method': method_key}",
            "        return form_list",
            "",
            "    def render_next_step(self, form, **kwargs):",
            "        \"\"\"",
            "        In the validation step, ask the device to generate a challenge.",
            "        \"\"\"",
            "        next_step = self.steps.next",
            "        if next_step == 'validation':",
            "            try:",
            "                self.get_device().generate_challenge()",
            "                kwargs[\"challenge_succeeded\"] = True",
            "            except Exception:",
            "                logger.exception(\"Could not generate challenge\")",
            "                kwargs[\"challenge_succeeded\"] = False",
            "        return super().render_next_step(form, **kwargs)",
            "",
            "    def done(self, form_list, **kwargs):",
            "        \"\"\"",
            "        Finish the wizard. Save all forms and redirect.",
            "        \"\"\"",
            "        # Remove secret key used for QR code generation",
            "        try:",
            "            del self.request.session[self.session_key_name]",
            "        except KeyError:",
            "            pass",
            "",
            "        # TOTPDeviceForm",
            "        if self.get_method() == 'generator':",
            "            form = [form for form in form_list if isinstance(form, TOTPDeviceForm)][0]",
            "            device = form.save()",
            "",
            "        # PhoneNumberForm / YubiKeyDeviceForm",
            "        elif self.get_method() in ('call', 'sms', 'yubikey'):",
            "            device = self.get_device()",
            "            device.save()",
            "",
            "        else:",
            "            raise NotImplementedError(\"Unknown method '%s'\" % self.get_method())",
            "",
            "        django_otp.login(self.request, device)",
            "        return redirect(self.success_url)",
            "",
            "    def get_form_kwargs(self, step=None):",
            "        kwargs = {}",
            "        if step == 'generator':",
            "            kwargs.update({",
            "                'key': self.get_key(step),",
            "                'user': self.request.user,",
            "            })",
            "        if step in ('validation', 'yubikey'):",
            "            kwargs.update({",
            "                'device': self.get_device()",
            "            })",
            "        metadata = self.get_form_metadata(step)",
            "        if metadata:",
            "            kwargs.update({",
            "                'metadata': metadata,",
            "            })",
            "        return kwargs",
            "",
            "    def get_device(self, **kwargs):",
            "        \"\"\"",
            "        Uses the data from the setup step and generated key to recreate device.",
            "",
            "        Only used for call / sms -- generator uses other procedure.",
            "        \"\"\"",
            "        method = self.get_method()",
            "        kwargs = kwargs or {}",
            "        kwargs['name'] = 'default'",
            "        kwargs['user'] = self.request.user",
            "",
            "        if method in ('call', 'sms'):",
            "            kwargs['method'] = method",
            "            kwargs['number'] = self.storage.validated_step_data\\",
            "                .get(method, {}).get('number')",
            "            return PhoneDevice(key=self.get_key(method), **kwargs)",
            "",
            "        if method == 'yubikey':",
            "            kwargs['public_id'] = self.storage.validated_step_data\\",
            "                .get('yubikey', {}).get('token', '')[:-32]",
            "            try:",
            "                kwargs['service'] = ValidationService.objects.get(name='default')",
            "            except ValidationService.DoesNotExist:",
            "                raise KeyError(\"No ValidationService found with name 'default'\")",
            "            except ValidationService.MultipleObjectsReturned:",
            "                raise KeyError(\"Multiple ValidationService found with name 'default'\")",
            "            return RemoteYubikeyDevice(**kwargs)",
            "",
            "    def get_key(self, step):",
            "        self.storage.extra_data.setdefault('keys', {})",
            "        if step in self.storage.extra_data['keys']:",
            "            return self.storage.extra_data['keys'].get(step)",
            "        key = random_hex_str(20)",
            "        self.storage.extra_data['keys'][step] = key",
            "        return key",
            "",
            "    def get_context_data(self, form, **kwargs):",
            "        context = super().get_context_data(form, **kwargs)",
            "        if self.steps.current == 'generator':",
            "            key = self.get_key('generator')",
            "            rawkey = unhexlify(key.encode('ascii'))",
            "            b32key = b32encode(rawkey).decode('utf-8')",
            "            self.request.session[self.session_key_name] = b32key",
            "            context.update({",
            "                'QR_URL': reverse(self.qrcode_url)",
            "            })",
            "        elif self.steps.current == 'validation':",
            "            context['device'] = self.get_device()",
            "        context['cancel_url'] = resolve_url(settings.LOGIN_REDIRECT_URL)",
            "        return context",
            "",
            "    def process_step(self, form):",
            "        if hasattr(form, 'metadata'):",
            "            self.storage.extra_data.setdefault('forms', {})",
            "            self.storage.extra_data['forms'][self.steps.current] = form.metadata",
            "        return super().process_step(form)",
            "",
            "    def get_form_metadata(self, step):",
            "        self.storage.extra_data.setdefault('forms', {})",
            "        return self.storage.extra_data['forms'].get(step, None)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class BackupTokensView(FormView):",
            "    \"\"\"",
            "    View for listing and generating backup tokens.",
            "",
            "    A user can generate a number of static backup tokens. When the user loses",
            "    its phone, these backup tokens can be used for verification. These backup",
            "    tokens should be stored in a safe location; either in a safe or underneath",
            "    a pillow ;-).",
            "    \"\"\"",
            "    form_class = Form",
            "    success_url = 'two_factor:backup_tokens'",
            "    template_name = 'two_factor/core/backup_tokens.html'",
            "    number_of_tokens = 10",
            "",
            "    def get_device(self):",
            "        return self.request.user.staticdevice_set.get_or_create(name='backup')[0]",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = super().get_context_data(**kwargs)",
            "        context['device'] = self.get_device()",
            "        return context",
            "",
            "    def form_valid(self, form):",
            "        \"\"\"",
            "        Delete existing backup codes and generate new ones.",
            "        \"\"\"",
            "        device = self.get_device()",
            "        device.token_set.all().delete()",
            "        for n in range(self.number_of_tokens):",
            "            device.token_set.create(token=StaticToken.random_token())",
            "",
            "        return redirect(self.success_url)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class PhoneSetupView(IdempotentSessionWizardView):",
            "    \"\"\"",
            "    View for configuring a phone number for receiving tokens.",
            "",
            "    A user can have multiple backup :class:`~two_factor.models.PhoneDevice`",
            "    for receiving OTP tokens. If the primary phone number is not available, as",
            "    the battery might have drained or the phone is lost, these backup phone",
            "    numbers can be used for verification.",
            "    \"\"\"",
            "    template_name = 'two_factor/core/phone_register.html'",
            "    success_url = settings.LOGIN_REDIRECT_URL",
            "    form_list = (",
            "        ('setup', PhoneNumberMethodForm),",
            "        ('validation', DeviceValidationForm),",
            "    )",
            "    key_name = 'key'",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Start the setup wizard. Redirect if no phone methods available.",
            "        \"\"\"",
            "        if not get_available_phone_methods():",
            "            return redirect(self.success_url)",
            "        return super().get(request, *args, **kwargs)",
            "",
            "    def done(self, form_list, **kwargs):",
            "        \"\"\"",
            "        Store the device and redirect to profile page.",
            "        \"\"\"",
            "        self.get_device(user=self.request.user, name='backup').save()",
            "        return redirect(self.success_url)",
            "",
            "    def render_next_step(self, form, **kwargs):",
            "        \"\"\"",
            "        In the validation step, ask the device to generate a challenge.",
            "        \"\"\"",
            "        next_step = self.steps.next",
            "        if next_step == 'validation':",
            "            self.get_device().generate_challenge()",
            "        return super().render_next_step(form, **kwargs)",
            "",
            "    def get_form_kwargs(self, step=None):",
            "        \"\"\"",
            "        Provide the device to the DeviceValidationForm.",
            "        \"\"\"",
            "        if step == 'validation':",
            "            return {'device': self.get_device()}",
            "        return {}",
            "",
            "    def get_device(self, **kwargs):",
            "        \"\"\"",
            "        Uses the data from the setup step and generated key to recreate device.",
            "        \"\"\"",
            "        kwargs = kwargs or {}",
            "        kwargs.update(self.storage.validated_step_data.get('setup', {}))",
            "        return PhoneDevice(key=self.get_key(), **kwargs)",
            "",
            "    def get_key(self):",
            "        \"\"\"",
            "        The key is preserved between steps and stored as ascii in the session.",
            "        \"\"\"",
            "        if self.key_name not in self.storage.extra_data:",
            "            key = random_hex_str(20)",
            "            self.storage.extra_data[self.key_name] = key",
            "        return self.storage.extra_data[self.key_name]",
            "",
            "    def get_context_data(self, form, **kwargs):",
            "        kwargs.setdefault('cancel_url', resolve_url(self.success_url))",
            "        return super().get_context_data(form, **kwargs)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class PhoneDeleteView(DeleteView):",
            "    \"\"\"",
            "    View for removing a phone number used for verification.",
            "    \"\"\"",
            "    success_url = settings.LOGIN_REDIRECT_URL",
            "",
            "    def get_queryset(self):",
            "        return self.request.user.phonedevice_set.filter(name='backup')",
            "",
            "    def get_success_url(self):",
            "        return resolve_url(self.success_url)",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(otp_required)",
            "class SetupCompleteView(TemplateView):",
            "    \"\"\"",
            "    View congratulation the user when OTP setup has completed.",
            "    \"\"\"",
            "    template_name = 'two_factor/core/setup_complete.html'",
            "",
            "    def get_context_data(self):",
            "        return {",
            "            'phone_methods': get_available_phone_methods(),",
            "        }",
            "",
            "",
            "@class_view_decorator(never_cache)",
            "@class_view_decorator(login_required)",
            "class QRGeneratorView(View):",
            "    \"\"\"",
            "    View returns an SVG image with the OTP token information",
            "    \"\"\"",
            "    http_method_names = ['get']",
            "    default_qr_factory = 'qrcode.image.svg.SvgPathImage'",
            "    session_key_name = 'django_two_factor-qr_secret_key'",
            "",
            "    # The qrcode library only supports PNG and SVG for now",
            "    image_content_types = {",
            "        'PNG': 'image/png',",
            "        'SVG': 'image/svg+xml; charset=utf-8',",
            "    }",
            "",
            "    def get_issuer(self):",
            "        return get_current_site(self.request).name",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        # Get the data from the session",
            "        try:",
            "            key = self.request.session[self.session_key_name]",
            "        except KeyError:",
            "            raise Http404()",
            "",
            "        # Get data for qrcode",
            "        image_factory_string = getattr(settings, 'TWO_FACTOR_QR_FACTORY', self.default_qr_factory)",
            "        image_factory = import_string(image_factory_string)",
            "        content_type = self.image_content_types[image_factory.kind]",
            "        try:",
            "            username = self.request.user.get_username()",
            "        except AttributeError:",
            "            username = self.request.user.username",
            "",
            "        otpauth_url = get_otpauth_url(accountname=username,",
            "                                      issuer=self.get_issuer(),",
            "                                      secret=key,",
            "                                      digits=totp_digits())",
            "",
            "        # Make and return QR code",
            "        img = qrcode.make(otpauth_url, image_factory=image_factory)",
            "        resp = HttpResponse(content_type=content_type)",
            "        img.save(resp)",
            "        return resp"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "190": [
                "LoginView",
                "get_user"
            ],
            "191": [
                "LoginView",
                "get_user"
            ],
            "192": [
                "LoginView",
                "get_user"
            ]
        },
        "addLocation": []
    },
    "two_factor/views/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+from django.contrib.auth import load_backend"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.core.exceptions import SuspiciousOperation"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from django.utils.decorators import method_decorator"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.utils.translation import gettext as _"
            },
            "6": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "                                    _set_validated_step_data)"
            },
            "7": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+class LoginStorage(ExtraSessionStorage):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    \"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    SessionStorage that includes the property 'authenticated_user' for storing"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    backend authenticated users while logging in."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    \"\"\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    def _get_authenticated_user(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        # Ensure that both user_pk and user_backend exist in the session"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        if not all([self.data.get(\"user_pk\"), self.data.get(\"user_backend\")]):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            return False"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        # Acquire the user the same way django.contrib.auth.get_user does"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        backend = load_backend(self.data[\"user_backend\"])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        user = backend.get_user(self.data[\"user_pk\"])"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        if not user:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            return False"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        # Set user.backend to the dotted path version of the backend for login()"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        user.backend = self.data[\"user_backend\"]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        return user"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    def _set_authenticated_user(self, user):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        # Acquire the PK the same way django's auth middleware does"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        self.data[\"user_pk\"] = user._meta.pk.value_to_string(user)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        self.data[\"user_backend\"] = user.backend"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    authenticated_user = property(_get_authenticated_user,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                                  _set_authenticated_user)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " class IdempotentSessionWizardView(SessionWizardView):"
            },
            "37": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     WizardView that allows certain steps to be marked non-idempotent, in which"
            },
            "39": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         return super().process_step(form)"
            },
            "41": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    def get_done_form_list(self):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        return self.get_form_list()"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     def render_done(self, form, **kwargs):"
            },
            "46": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "         \"\"\""
            },
            "47": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         This method gets called when all forms passed. The method should also"
            },
            "48": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         \"\"\""
            },
            "49": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         final_form_list = []"
            },
            "50": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "         # walk through the form list and try to validate the data again."
            },
            "51": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for form_key in self.get_form_list():"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        for form_key in self.get_done_form_list():"
            },
            "53": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "             form_obj = self.get_form(step=form_key,"
            },
            "54": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "                                      data=self.storage.get_step_data(form_key),"
            },
            "55": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "                                      files=self.storage.get_step_files("
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils.decorators import method_decorator",
            "from django.utils.translation import gettext as _",
            "from formtools.wizard.forms import ManagementForm",
            "from formtools.wizard.storage.session import SessionStorage",
            "from formtools.wizard.views import SessionWizardView",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ExtraSessionStorage(SessionStorage):",
            "    \"\"\"",
            "    SessionStorage that includes the property `validated_step_data` for storing",
            "    cleaned form data per step.",
            "    \"\"\"",
            "    validated_step_data_key = 'validated_step_data'",
            "",
            "    def init_data(self):",
            "        super().init_data()",
            "        self.data[self.validated_step_data_key] = {}",
            "",
            "    def reset(self):",
            "        if self.prefix in self.request.session:",
            "            super().reset()",
            "        else:",
            "            self.init_data()",
            "",
            "    def _get_validated_step_data(self):",
            "        return self.data[self.validated_step_data_key]",
            "",
            "    def _set_validated_step_data(self, validated_step_data):",
            "        self.data[self.validated_step_data_key] = validated_step_data",
            "",
            "    validated_step_data = property(_get_validated_step_data,",
            "                                   _set_validated_step_data)",
            "",
            "",
            "class IdempotentSessionWizardView(SessionWizardView):",
            "    \"\"\"",
            "    WizardView that allows certain steps to be marked non-idempotent, in which",
            "    case the form is only validated once and the cleaned values stored.",
            "    \"\"\"",
            "    storage_name = 'two_factor.views.utils.ExtraSessionStorage'",
            "    idempotent_dict = {}",
            "",
            "    def is_step_visible(self, step):",
            "        \"\"\"",
            "        Returns whether the given `step` should be included in the wizard; it",
            "        is included if either the form is idempotent or not filled in before.",
            "        \"\"\"",
            "        return self.idempotent_dict.get(step, True) or \\",
            "            step not in self.storage.validated_step_data",
            "",
            "    def get_prev_step(self, step=None):",
            "        \"\"\"",
            "        Returns the previous step before the given `step`. If there are no",
            "        steps available, None will be returned. If the `step` argument is",
            "        None, the current step will be determined automatically.",
            "        \"\"\"",
            "        if step is None:",
            "            step = self.steps.current",
            "        form_list = self.get_form_list()",
            "        keys = list(form_list.keys())",
            "        key = keys.index(step) - 1",
            "        if key >= 0:",
            "            for prev_step in keys[key::-1]:",
            "                if self.is_step_visible(prev_step):",
            "                    return prev_step",
            "        return None",
            "",
            "    def get_next_step(self, step=None):",
            "        \"\"\"",
            "        Returns the next step after the given `step`. If no more steps are",
            "        available, None will be returned. If the `step` argument is None, the",
            "        current step will be determined automatically.",
            "        \"\"\"",
            "        if step is None:",
            "            step = self.steps.current",
            "        form_list = self.get_form_list()",
            "        keys = list(form_list.keys())",
            "        key = keys.index(step) + 1",
            "        for next_step in keys[key:]:",
            "            if self.is_step_visible(next_step):",
            "                return next_step",
            "        return None",
            "",
            "    def post(self, *args, **kwargs):",
            "        \"\"\"",
            "        Check if the current step is still available. It might not be if",
            "        conditions have changed.",
            "        \"\"\"",
            "        if self.steps.current not in self.steps.all:",
            "            logger.warning(\"Current step '%s' is no longer valid, returning \"",
            "                           \"to last valid step in the wizard.\",",
            "                           self.steps.current)",
            "            return self.render_goto_step(self.steps.all[-1])",
            "",
            "        # -- Duplicated code from upstream",
            "        # Look for a wizard_goto_step element in the posted data which",
            "        # contains a valid step name. If one was found, render the requested",
            "        # form. (This makes stepping back a lot easier).",
            "        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)",
            "        if wizard_goto_step and wizard_goto_step in self.get_form_list():",
            "            return self.render_goto_step(wizard_goto_step)",
            "",
            "        # Check if form was refreshed",
            "        management_form = ManagementForm(self.request.POST, prefix=self.prefix)",
            "        if not management_form.is_valid():",
            "            raise SuspiciousOperation(_('ManagementForm data is missing or has been tampered with'))",
            "",
            "        form_current_step = management_form.cleaned_data['current_step']",
            "        if (form_current_step != self.steps.current",
            "                and self.storage.current_step is not None):",
            "            # form refreshed, change current step",
            "            self.storage.current_step = form_current_step",
            "        # -- End duplicated code from upstream",
            "",
            "        # This is different from the first check, as this checks",
            "        # if the new step is available. See issue #65.",
            "        if self.steps.current not in self.steps.all:",
            "            logger.warning(\"Requested step '%s' is no longer valid, returning \"",
            "                           \"to last valid step in the wizard.\",",
            "                           self.steps.current)",
            "            return self.render_goto_step(self.steps.all[-1])",
            "",
            "        return super().post(*args, **kwargs)",
            "",
            "    def process_step(self, form):",
            "        \"\"\"",
            "        Stores the validated data for `form` and cleans out validated forms",
            "        for next steps, as those might be affected by the current step. Note",
            "        that this behaviour is relied upon by the `LoginView` to prevent users",
            "        from bypassing the `TokenForm` by going steps back and changing",
            "        credentials.",
            "        \"\"\"",
            "        step = self.steps.current",
            "",
            "        # If the form is not-idempotent (cannot be validated multiple times),",
            "        # the cleaned data should be stored; marking the form as validated.",
            "        self.storage.validated_step_data[step] = form.cleaned_data",
            "",
            "        # It is assumed that earlier steps affect later steps; so even though",
            "        # those forms might not be idempotent, we'll remove the validated data",
            "        # to force re-entry.",
            "        # form_list = self.get_form_list(idempotent=False)",
            "        form_list = self.get_form_list()",
            "        keys = list(form_list.keys())",
            "        key = keys.index(step) + 1",
            "        for next_step in keys[key:]:",
            "            self.storage.validated_step_data.pop(next_step, None)",
            "",
            "        return super().process_step(form)",
            "",
            "    def render_done(self, form, **kwargs):",
            "        \"\"\"",
            "        This method gets called when all forms passed. The method should also",
            "        re-validate all steps to prevent manipulation. If any form don't",
            "        validate, `render_revalidation_failure` should get called.",
            "        If everything is fine call `done`.",
            "        \"\"\"",
            "        final_form_list = []",
            "        # walk through the form list and try to validate the data again.",
            "        for form_key in self.get_form_list():",
            "            form_obj = self.get_form(step=form_key,",
            "                                     data=self.storage.get_step_data(form_key),",
            "                                     files=self.storage.get_step_files(",
            "                                         form_key))",
            "            if not (form_key in self.idempotent_dict or form_obj.is_valid()):",
            "                return self.render_revalidation_failure(form_key, form_obj,",
            "                                                        **kwargs)",
            "            final_form_list.append(form_obj)",
            "",
            "        # render the done view and reset the wizard before returning the",
            "        # response. This is needed to prevent from rendering done with the",
            "        # same data twice.",
            "        done_response = self.done(final_form_list, **kwargs)",
            "        self.storage.reset()",
            "        return done_response",
            "",
            "",
            "def class_view_decorator(function_decorator):",
            "    \"\"\"",
            "    Converts a function based decorator into a class based decorator usable",
            "    on class based Views.",
            "",
            "    Can't subclass the `View` as it breaks inheritance (super in particular),",
            "    so we monkey-patch instead.",
            "",
            "    From: http://stackoverflow.com/a/8429311/58107",
            "    \"\"\"",
            "    def simple_decorator(View):",
            "        View.dispatch = method_decorator(function_decorator)(View.dispatch)",
            "        return View",
            "    return simple_decorator"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from django.contrib.auth import load_backend",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils.decorators import method_decorator",
            "from django.utils.translation import gettext as _",
            "from formtools.wizard.forms import ManagementForm",
            "from formtools.wizard.storage.session import SessionStorage",
            "from formtools.wizard.views import SessionWizardView",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class ExtraSessionStorage(SessionStorage):",
            "    \"\"\"",
            "    SessionStorage that includes the property `validated_step_data` for storing",
            "    cleaned form data per step.",
            "    \"\"\"",
            "    validated_step_data_key = 'validated_step_data'",
            "",
            "    def init_data(self):",
            "        super().init_data()",
            "        self.data[self.validated_step_data_key] = {}",
            "",
            "    def reset(self):",
            "        if self.prefix in self.request.session:",
            "            super().reset()",
            "        else:",
            "            self.init_data()",
            "",
            "    def _get_validated_step_data(self):",
            "        return self.data[self.validated_step_data_key]",
            "",
            "    def _set_validated_step_data(self, validated_step_data):",
            "        self.data[self.validated_step_data_key] = validated_step_data",
            "",
            "    validated_step_data = property(_get_validated_step_data,",
            "                                   _set_validated_step_data)",
            "",
            "",
            "class LoginStorage(ExtraSessionStorage):",
            "    \"\"\"",
            "    SessionStorage that includes the property 'authenticated_user' for storing",
            "    backend authenticated users while logging in.",
            "    \"\"\"",
            "    def _get_authenticated_user(self):",
            "        # Ensure that both user_pk and user_backend exist in the session",
            "        if not all([self.data.get(\"user_pk\"), self.data.get(\"user_backend\")]):",
            "            return False",
            "        # Acquire the user the same way django.contrib.auth.get_user does",
            "        backend = load_backend(self.data[\"user_backend\"])",
            "        user = backend.get_user(self.data[\"user_pk\"])",
            "        if not user:",
            "            return False",
            "        # Set user.backend to the dotted path version of the backend for login()",
            "        user.backend = self.data[\"user_backend\"]",
            "        return user",
            "",
            "    def _set_authenticated_user(self, user):",
            "        # Acquire the PK the same way django's auth middleware does",
            "        self.data[\"user_pk\"] = user._meta.pk.value_to_string(user)",
            "        self.data[\"user_backend\"] = user.backend",
            "",
            "    authenticated_user = property(_get_authenticated_user,",
            "                                  _set_authenticated_user)",
            "",
            "",
            "class IdempotentSessionWizardView(SessionWizardView):",
            "    \"\"\"",
            "    WizardView that allows certain steps to be marked non-idempotent, in which",
            "    case the form is only validated once and the cleaned values stored.",
            "    \"\"\"",
            "    storage_name = 'two_factor.views.utils.ExtraSessionStorage'",
            "    idempotent_dict = {}",
            "",
            "    def is_step_visible(self, step):",
            "        \"\"\"",
            "        Returns whether the given `step` should be included in the wizard; it",
            "        is included if either the form is idempotent or not filled in before.",
            "        \"\"\"",
            "        return self.idempotent_dict.get(step, True) or \\",
            "            step not in self.storage.validated_step_data",
            "",
            "    def get_prev_step(self, step=None):",
            "        \"\"\"",
            "        Returns the previous step before the given `step`. If there are no",
            "        steps available, None will be returned. If the `step` argument is",
            "        None, the current step will be determined automatically.",
            "        \"\"\"",
            "        if step is None:",
            "            step = self.steps.current",
            "        form_list = self.get_form_list()",
            "        keys = list(form_list.keys())",
            "        key = keys.index(step) - 1",
            "        if key >= 0:",
            "            for prev_step in keys[key::-1]:",
            "                if self.is_step_visible(prev_step):",
            "                    return prev_step",
            "        return None",
            "",
            "    def get_next_step(self, step=None):",
            "        \"\"\"",
            "        Returns the next step after the given `step`. If no more steps are",
            "        available, None will be returned. If the `step` argument is None, the",
            "        current step will be determined automatically.",
            "        \"\"\"",
            "        if step is None:",
            "            step = self.steps.current",
            "        form_list = self.get_form_list()",
            "        keys = list(form_list.keys())",
            "        key = keys.index(step) + 1",
            "        for next_step in keys[key:]:",
            "            if self.is_step_visible(next_step):",
            "                return next_step",
            "        return None",
            "",
            "    def post(self, *args, **kwargs):",
            "        \"\"\"",
            "        Check if the current step is still available. It might not be if",
            "        conditions have changed.",
            "        \"\"\"",
            "        if self.steps.current not in self.steps.all:",
            "            logger.warning(\"Current step '%s' is no longer valid, returning \"",
            "                           \"to last valid step in the wizard.\",",
            "                           self.steps.current)",
            "            return self.render_goto_step(self.steps.all[-1])",
            "",
            "        # -- Duplicated code from upstream",
            "        # Look for a wizard_goto_step element in the posted data which",
            "        # contains a valid step name. If one was found, render the requested",
            "        # form. (This makes stepping back a lot easier).",
            "        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)",
            "        if wizard_goto_step and wizard_goto_step in self.get_form_list():",
            "            return self.render_goto_step(wizard_goto_step)",
            "",
            "        # Check if form was refreshed",
            "        management_form = ManagementForm(self.request.POST, prefix=self.prefix)",
            "        if not management_form.is_valid():",
            "            raise SuspiciousOperation(_('ManagementForm data is missing or has been tampered with'))",
            "",
            "        form_current_step = management_form.cleaned_data['current_step']",
            "        if (form_current_step != self.steps.current",
            "                and self.storage.current_step is not None):",
            "            # form refreshed, change current step",
            "            self.storage.current_step = form_current_step",
            "        # -- End duplicated code from upstream",
            "",
            "        # This is different from the first check, as this checks",
            "        # if the new step is available. See issue #65.",
            "        if self.steps.current not in self.steps.all:",
            "            logger.warning(\"Requested step '%s' is no longer valid, returning \"",
            "                           \"to last valid step in the wizard.\",",
            "                           self.steps.current)",
            "            return self.render_goto_step(self.steps.all[-1])",
            "",
            "        return super().post(*args, **kwargs)",
            "",
            "    def process_step(self, form):",
            "        \"\"\"",
            "        Stores the validated data for `form` and cleans out validated forms",
            "        for next steps, as those might be affected by the current step. Note",
            "        that this behaviour is relied upon by the `LoginView` to prevent users",
            "        from bypassing the `TokenForm` by going steps back and changing",
            "        credentials.",
            "        \"\"\"",
            "        step = self.steps.current",
            "",
            "        # If the form is not-idempotent (cannot be validated multiple times),",
            "        # the cleaned data should be stored; marking the form as validated.",
            "        self.storage.validated_step_data[step] = form.cleaned_data",
            "",
            "        # It is assumed that earlier steps affect later steps; so even though",
            "        # those forms might not be idempotent, we'll remove the validated data",
            "        # to force re-entry.",
            "        # form_list = self.get_form_list(idempotent=False)",
            "        form_list = self.get_form_list()",
            "        keys = list(form_list.keys())",
            "        key = keys.index(step) + 1",
            "        for next_step in keys[key:]:",
            "            self.storage.validated_step_data.pop(next_step, None)",
            "",
            "        return super().process_step(form)",
            "",
            "    def get_done_form_list(self):",
            "        return self.get_form_list()",
            "",
            "    def render_done(self, form, **kwargs):",
            "        \"\"\"",
            "        This method gets called when all forms passed. The method should also",
            "        re-validate all steps to prevent manipulation. If any form don't",
            "        validate, `render_revalidation_failure` should get called.",
            "        If everything is fine call `done`.",
            "        \"\"\"",
            "        final_form_list = []",
            "        # walk through the form list and try to validate the data again.",
            "        for form_key in self.get_done_form_list():",
            "            form_obj = self.get_form(step=form_key,",
            "                                     data=self.storage.get_step_data(form_key),",
            "                                     files=self.storage.get_step_files(",
            "                                         form_key))",
            "            if not (form_key in self.idempotent_dict or form_obj.is_valid()):",
            "                return self.render_revalidation_failure(form_key, form_obj,",
            "                                                        **kwargs)",
            "            final_form_list.append(form_obj)",
            "",
            "        # render the done view and reset the wizard before returning the",
            "        # response. This is needed to prevent from rendering done with the",
            "        # same data twice.",
            "        done_response = self.done(final_form_list, **kwargs)",
            "        self.storage.reset()",
            "        return done_response",
            "",
            "",
            "def class_view_decorator(function_decorator):",
            "    \"\"\"",
            "    Converts a function based decorator into a class based decorator usable",
            "    on class based Views.",
            "",
            "    Can't subclass the `View` as it breaks inheritance (super in particular),",
            "    so we monkey-patch instead.",
            "",
            "    From: http://stackoverflow.com/a/8429311/58107",
            "    \"\"\"",
            "    def simple_decorator(View):",
            "        View.dispatch = method_decorator(function_decorator)(View.dispatch)",
            "        return View",
            "    return simple_decorator"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "165": [
                "IdempotentSessionWizardView",
                "render_done"
            ]
        },
        "addLocation": [
            "two_factor.views.utils.IdempotentSessionWizardView.render_done",
            "two_factor.views.utils.IdempotentSessionWizardView.idempotent_dict",
            "src.octoprint.server.api",
            "two_factor.views.utils.IdempotentSessionWizardView.self"
        ]
    }
}