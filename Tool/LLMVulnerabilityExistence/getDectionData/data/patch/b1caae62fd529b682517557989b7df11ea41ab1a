{
    "libs/langchain/langchain/chains/api/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " \"\"\"Chain that makes API calls and summarizes the responses to answer a question.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from __future__ import annotations"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any, Dict, List, Optional"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from typing import Any, Dict, List, Optional, Sequence, Tuple"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from urllib.parse import urlparse"
            },
            "6": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from langchain.callbacks.manager import ("
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     AsyncCallbackManagerForChainRun,"
            },
            "9": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from langchain.utilities.requests import TextRequestsWrapper"
            },
            "10": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+def _extract_scheme_and_domain(url: str) -> Tuple[str, str]:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    \"\"\"Extract the scheme + domain from a given URL."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    Args:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        url (str): The input URL."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    Returns:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        return a 2-tuple of scheme and domain"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    parsed_uri = urlparse(url)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    return parsed_uri.scheme, parsed_uri.netloc"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+def _check_in_allowed_domain(url: str, limit_to_domains: Sequence[str]) -> bool:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    \"\"\"Check if a URL is in the allowed domains."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    Args:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        url (str): The input URL."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        limit_to_domains (Sequence[str]): The allowed domains."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    Returns:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        bool: True if the URL is in the allowed domains, False otherwise."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    \"\"\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    scheme, domain = _extract_scheme_and_domain(url)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    for allowed_domain in limit_to_domains:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        allowed_scheme, allowed_domain = _extract_scheme_and_domain(allowed_domain)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        if scheme == allowed_scheme and domain == allowed_domain:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            return True"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    return False"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " class APIChain(Chain):"
            },
            "45": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     \"\"\"Chain that makes API calls and summarizes the responses to answer a question."
            },
            "46": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     api_docs: str"
            },
            "48": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     question_key: str = \"question\"  #: :meta private:"
            },
            "49": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     output_key: str = \"output\"  #: :meta private:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    limit_to_domains: Optional[Sequence[str]]"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    \"\"\"Use to limit the domains that can be accessed by the API chain."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    "
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    * For example, to limit to just the domain `https://www.example.com`, set"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        `limit_to_domains=[\"https://www.example.com\"]`."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        "
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    * The default value is an empty tuple, which means that no domains are"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+      allowed by default. By design this will raise an error on instantiation."
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    * Use a None if you want to allow all domains by default -- this is not"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+      recommended for security reasons, as it would allow malicious users to"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+      make requests to arbitrary URLS including internal APIs accessible from"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+      the server."
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+    \"\"\""
            },
            "63": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     @property"
            },
            "65": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     def input_keys(self) -> List[str]:"
            },
            "66": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             )"
            },
            "67": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         return values"
            },
            "68": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    @root_validator(pre=True)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+    def validate_limit_to_domains(cls, values: Dict) -> Dict:"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        \"\"\"Check that allowed domains are valid.\"\"\""
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        if \"limit_to_domains\" not in values:"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            raise ValueError("
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                \"You must specify a list of domains to limit access using \""
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+                \"`limit_to_domains`\""
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+            )"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        if not values[\"limit_to_domains\"] and values[\"limit_to_domains\"] is not None:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+            raise ValueError("
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+                \"Please provide a list of domains to limit access using \""
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+                \"`limit_to_domains`.\""
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+            )"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        return values"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     @root_validator(pre=True)"
            },
            "85": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     def validate_api_answer_prompt(cls, values: Dict) -> Dict:"
            },
            "86": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         \"\"\"Check that api answer prompt expects the right variables.\"\"\""
            },
            "87": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         )"
            },
            "88": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         _run_manager.on_text(api_url, color=\"green\", end=\"\\n\", verbose=self.verbose)"
            },
            "89": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         api_url = api_url.strip()"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        if self.limit_to_domains and not _check_in_allowed_domain("
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            api_url, self.limit_to_domains"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        ):"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            raise ValueError("
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+                f\"{api_url} is not in the allowed domains: {self.limit_to_domains}\""
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            )"
            },
            "96": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         api_response = self.requests_wrapper.get(api_url)"
            },
            "97": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         _run_manager.on_text("
            },
            "98": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "             api_response, color=\"yellow\", end=\"\\n\", verbose=self.verbose"
            },
            "99": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             api_url, color=\"green\", end=\"\\n\", verbose=self.verbose"
            },
            "100": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         )"
            },
            "101": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "         api_url = api_url.strip()"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        if self.limit_to_domains and not _check_in_allowed_domain("
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            api_url, self.limit_to_domains"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        ):"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            raise ValueError("
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                f\"{api_url} is not in the allowed domains: {self.limit_to_domains}\""
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            )"
            },
            "108": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         api_response = await self.requests_wrapper.aget(api_url)"
            },
            "109": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "         await _run_manager.on_text("
            },
            "110": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "             api_response, color=\"yellow\", end=\"\\n\", verbose=self.verbose"
            },
            "111": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "         headers: Optional[dict] = None,"
            },
            "112": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "         api_url_prompt: BasePromptTemplate = API_URL_PROMPT,"
            },
            "113": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "         api_response_prompt: BasePromptTemplate = API_RESPONSE_PROMPT,"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        limit_to_domains: Optional[Sequence[str]] = tuple(),"
            },
            "115": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         **kwargs: Any,"
            },
            "116": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "     ) -> APIChain:"
            },
            "117": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         \"\"\"Load chain from just an LLM and the api docs.\"\"\""
            },
            "118": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "             api_answer_chain=get_answer_chain,"
            },
            "119": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             requests_wrapper=requests_wrapper,"
            },
            "120": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "             api_docs=api_docs,"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+            limit_to_domains=limit_to_domains,"
            },
            "122": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             **kwargs,"
            },
            "123": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         )"
            },
            "124": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"Chain that makes API calls and summarizes the responses to answer a question.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.callbacks.manager import (",
            "    AsyncCallbackManagerForChainRun,",
            "    CallbackManagerForChainRun,",
            ")",
            "from langchain.chains.api.prompt import API_RESPONSE_PROMPT, API_URL_PROMPT",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.pydantic_v1 import Field, root_validator",
            "from langchain.schema import BasePromptTemplate",
            "from langchain.schema.language_model import BaseLanguageModel",
            "from langchain.utilities.requests import TextRequestsWrapper",
            "",
            "",
            "class APIChain(Chain):",
            "    \"\"\"Chain that makes API calls and summarizes the responses to answer a question.",
            "",
            "    *Security Note*: This API chain uses the requests toolkit",
            "        to make GET, POST, PATCH, PUT, and DELETE requests to an API.",
            "",
            "        Exercise care in who is allowed to use this chain. If exposing",
            "        to end users, consider that users will be able to make arbitrary",
            "        requests on behalf of the server hosting the code. For example,",
            "        users could ask the server to make a request to a private API",
            "        that is only accessible from the server.",
            "",
            "        Control access to who can submit issue requests using this toolkit and",
            "        what network access it has.",
            "",
            "        See https://python.langchain.com/docs/security for more information.",
            "    \"\"\"",
            "",
            "    api_request_chain: LLMChain",
            "    api_answer_chain: LLMChain",
            "    requests_wrapper: TextRequestsWrapper = Field(exclude=True)",
            "    api_docs: str",
            "    question_key: str = \"question\"  #: :meta private:",
            "    output_key: str = \"output\"  #: :meta private:",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Expect input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.question_key]",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Expect output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.output_key]",
            "",
            "    @root_validator(pre=True)",
            "    def validate_api_request_prompt(cls, values: Dict) -> Dict:",
            "        \"\"\"Check that api request prompt expects the right variables.\"\"\"",
            "        input_vars = values[\"api_request_chain\"].prompt.input_variables",
            "        expected_vars = {\"question\", \"api_docs\"}",
            "        if set(input_vars) != expected_vars:",
            "            raise ValueError(",
            "                f\"Input variables should be {expected_vars}, got {input_vars}\"",
            "            )",
            "        return values",
            "",
            "    @root_validator(pre=True)",
            "    def validate_api_answer_prompt(cls, values: Dict) -> Dict:",
            "        \"\"\"Check that api answer prompt expects the right variables.\"\"\"",
            "        input_vars = values[\"api_answer_chain\"].prompt.input_variables",
            "        expected_vars = {\"question\", \"api_docs\", \"api_url\", \"api_response\"}",
            "        if set(input_vars) != expected_vars:",
            "            raise ValueError(",
            "                f\"Input variables should be {expected_vars}, got {input_vars}\"",
            "            )",
            "        return values",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        question = inputs[self.question_key]",
            "        api_url = self.api_request_chain.predict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        _run_manager.on_text(api_url, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        api_url = api_url.strip()",
            "        api_response = self.requests_wrapper.get(api_url)",
            "        _run_manager.on_text(",
            "            api_response, color=\"yellow\", end=\"\\n\", verbose=self.verbose",
            "        )",
            "        answer = self.api_answer_chain.predict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            api_url=api_url,",
            "            api_response=api_response,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return {self.output_key: answer}",
            "",
            "    async def _acall(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[AsyncCallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or AsyncCallbackManagerForChainRun.get_noop_manager()",
            "        question = inputs[self.question_key]",
            "        api_url = await self.api_request_chain.apredict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        await _run_manager.on_text(",
            "            api_url, color=\"green\", end=\"\\n\", verbose=self.verbose",
            "        )",
            "        api_url = api_url.strip()",
            "        api_response = await self.requests_wrapper.aget(api_url)",
            "        await _run_manager.on_text(",
            "            api_response, color=\"yellow\", end=\"\\n\", verbose=self.verbose",
            "        )",
            "        answer = await self.api_answer_chain.apredict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            api_url=api_url,",
            "            api_response=api_response,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return {self.output_key: answer}",
            "",
            "    @classmethod",
            "    def from_llm_and_api_docs(",
            "        cls,",
            "        llm: BaseLanguageModel,",
            "        api_docs: str,",
            "        headers: Optional[dict] = None,",
            "        api_url_prompt: BasePromptTemplate = API_URL_PROMPT,",
            "        api_response_prompt: BasePromptTemplate = API_RESPONSE_PROMPT,",
            "        **kwargs: Any,",
            "    ) -> APIChain:",
            "        \"\"\"Load chain from just an LLM and the api docs.\"\"\"",
            "        get_request_chain = LLMChain(llm=llm, prompt=api_url_prompt)",
            "        requests_wrapper = TextRequestsWrapper(headers=headers)",
            "        get_answer_chain = LLMChain(llm=llm, prompt=api_response_prompt)",
            "        return cls(",
            "            api_request_chain=get_request_chain,",
            "            api_answer_chain=get_answer_chain,",
            "            requests_wrapper=requests_wrapper,",
            "            api_docs=api_docs,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"api_chain\""
        ],
        "afterPatchFile": [
            "\"\"\"Chain that makes API calls and summarizes the responses to answer a question.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any, Dict, List, Optional, Sequence, Tuple",
            "from urllib.parse import urlparse",
            "",
            "from langchain.callbacks.manager import (",
            "    AsyncCallbackManagerForChainRun,",
            "    CallbackManagerForChainRun,",
            ")",
            "from langchain.chains.api.prompt import API_RESPONSE_PROMPT, API_URL_PROMPT",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.pydantic_v1 import Field, root_validator",
            "from langchain.schema import BasePromptTemplate",
            "from langchain.schema.language_model import BaseLanguageModel",
            "from langchain.utilities.requests import TextRequestsWrapper",
            "",
            "",
            "def _extract_scheme_and_domain(url: str) -> Tuple[str, str]:",
            "    \"\"\"Extract the scheme + domain from a given URL.",
            "",
            "    Args:",
            "        url (str): The input URL.",
            "",
            "    Returns:",
            "        return a 2-tuple of scheme and domain",
            "    \"\"\"",
            "    parsed_uri = urlparse(url)",
            "    return parsed_uri.scheme, parsed_uri.netloc",
            "",
            "",
            "def _check_in_allowed_domain(url: str, limit_to_domains: Sequence[str]) -> bool:",
            "    \"\"\"Check if a URL is in the allowed domains.",
            "",
            "    Args:",
            "        url (str): The input URL.",
            "        limit_to_domains (Sequence[str]): The allowed domains.",
            "",
            "    Returns:",
            "        bool: True if the URL is in the allowed domains, False otherwise.",
            "    \"\"\"",
            "    scheme, domain = _extract_scheme_and_domain(url)",
            "",
            "    for allowed_domain in limit_to_domains:",
            "        allowed_scheme, allowed_domain = _extract_scheme_and_domain(allowed_domain)",
            "        if scheme == allowed_scheme and domain == allowed_domain:",
            "            return True",
            "    return False",
            "",
            "",
            "class APIChain(Chain):",
            "    \"\"\"Chain that makes API calls and summarizes the responses to answer a question.",
            "",
            "    *Security Note*: This API chain uses the requests toolkit",
            "        to make GET, POST, PATCH, PUT, and DELETE requests to an API.",
            "",
            "        Exercise care in who is allowed to use this chain. If exposing",
            "        to end users, consider that users will be able to make arbitrary",
            "        requests on behalf of the server hosting the code. For example,",
            "        users could ask the server to make a request to a private API",
            "        that is only accessible from the server.",
            "",
            "        Control access to who can submit issue requests using this toolkit and",
            "        what network access it has.",
            "",
            "        See https://python.langchain.com/docs/security for more information.",
            "    \"\"\"",
            "",
            "    api_request_chain: LLMChain",
            "    api_answer_chain: LLMChain",
            "    requests_wrapper: TextRequestsWrapper = Field(exclude=True)",
            "    api_docs: str",
            "    question_key: str = \"question\"  #: :meta private:",
            "    output_key: str = \"output\"  #: :meta private:",
            "    limit_to_domains: Optional[Sequence[str]]",
            "    \"\"\"Use to limit the domains that can be accessed by the API chain.",
            "    ",
            "    * For example, to limit to just the domain `https://www.example.com`, set",
            "        `limit_to_domains=[\"https://www.example.com\"]`.",
            "        ",
            "    * The default value is an empty tuple, which means that no domains are",
            "      allowed by default. By design this will raise an error on instantiation.",
            "    * Use a None if you want to allow all domains by default -- this is not",
            "      recommended for security reasons, as it would allow malicious users to",
            "      make requests to arbitrary URLS including internal APIs accessible from",
            "      the server.",
            "    \"\"\"",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Expect input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.question_key]",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Expect output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return [self.output_key]",
            "",
            "    @root_validator(pre=True)",
            "    def validate_api_request_prompt(cls, values: Dict) -> Dict:",
            "        \"\"\"Check that api request prompt expects the right variables.\"\"\"",
            "        input_vars = values[\"api_request_chain\"].prompt.input_variables",
            "        expected_vars = {\"question\", \"api_docs\"}",
            "        if set(input_vars) != expected_vars:",
            "            raise ValueError(",
            "                f\"Input variables should be {expected_vars}, got {input_vars}\"",
            "            )",
            "        return values",
            "",
            "    @root_validator(pre=True)",
            "    def validate_limit_to_domains(cls, values: Dict) -> Dict:",
            "        \"\"\"Check that allowed domains are valid.\"\"\"",
            "        if \"limit_to_domains\" not in values:",
            "            raise ValueError(",
            "                \"You must specify a list of domains to limit access using \"",
            "                \"`limit_to_domains`\"",
            "            )",
            "        if not values[\"limit_to_domains\"] and values[\"limit_to_domains\"] is not None:",
            "            raise ValueError(",
            "                \"Please provide a list of domains to limit access using \"",
            "                \"`limit_to_domains`.\"",
            "            )",
            "        return values",
            "",
            "    @root_validator(pre=True)",
            "    def validate_api_answer_prompt(cls, values: Dict) -> Dict:",
            "        \"\"\"Check that api answer prompt expects the right variables.\"\"\"",
            "        input_vars = values[\"api_answer_chain\"].prompt.input_variables",
            "        expected_vars = {\"question\", \"api_docs\", \"api_url\", \"api_response\"}",
            "        if set(input_vars) != expected_vars:",
            "            raise ValueError(",
            "                f\"Input variables should be {expected_vars}, got {input_vars}\"",
            "            )",
            "        return values",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        question = inputs[self.question_key]",
            "        api_url = self.api_request_chain.predict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        _run_manager.on_text(api_url, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        api_url = api_url.strip()",
            "        if self.limit_to_domains and not _check_in_allowed_domain(",
            "            api_url, self.limit_to_domains",
            "        ):",
            "            raise ValueError(",
            "                f\"{api_url} is not in the allowed domains: {self.limit_to_domains}\"",
            "            )",
            "        api_response = self.requests_wrapper.get(api_url)",
            "        _run_manager.on_text(",
            "            api_response, color=\"yellow\", end=\"\\n\", verbose=self.verbose",
            "        )",
            "        answer = self.api_answer_chain.predict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            api_url=api_url,",
            "            api_response=api_response,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return {self.output_key: answer}",
            "",
            "    async def _acall(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[AsyncCallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or AsyncCallbackManagerForChainRun.get_noop_manager()",
            "        question = inputs[self.question_key]",
            "        api_url = await self.api_request_chain.apredict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        await _run_manager.on_text(",
            "            api_url, color=\"green\", end=\"\\n\", verbose=self.verbose",
            "        )",
            "        api_url = api_url.strip()",
            "        if self.limit_to_domains and not _check_in_allowed_domain(",
            "            api_url, self.limit_to_domains",
            "        ):",
            "            raise ValueError(",
            "                f\"{api_url} is not in the allowed domains: {self.limit_to_domains}\"",
            "            )",
            "        api_response = await self.requests_wrapper.aget(api_url)",
            "        await _run_manager.on_text(",
            "            api_response, color=\"yellow\", end=\"\\n\", verbose=self.verbose",
            "        )",
            "        answer = await self.api_answer_chain.apredict(",
            "            question=question,",
            "            api_docs=self.api_docs,",
            "            api_url=api_url,",
            "            api_response=api_response,",
            "            callbacks=_run_manager.get_child(),",
            "        )",
            "        return {self.output_key: answer}",
            "",
            "    @classmethod",
            "    def from_llm_and_api_docs(",
            "        cls,",
            "        llm: BaseLanguageModel,",
            "        api_docs: str,",
            "        headers: Optional[dict] = None,",
            "        api_url_prompt: BasePromptTemplate = API_URL_PROMPT,",
            "        api_response_prompt: BasePromptTemplate = API_RESPONSE_PROMPT,",
            "        limit_to_domains: Optional[Sequence[str]] = tuple(),",
            "        **kwargs: Any,",
            "    ) -> APIChain:",
            "        \"\"\"Load chain from just an LLM and the api docs.\"\"\"",
            "        get_request_chain = LLMChain(llm=llm, prompt=api_url_prompt)",
            "        requests_wrapper = TextRequestsWrapper(headers=headers)",
            "        get_answer_chain = LLMChain(llm=llm, prompt=api_response_prompt)",
            "        return cls(",
            "            api_request_chain=get_request_chain,",
            "            api_answer_chain=get_answer_chain,",
            "            requests_wrapper=requests_wrapper,",
            "            api_docs=api_docs,",
            "            limit_to_domains=limit_to_domains,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"api_chain\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": []
        },
        "addLocation": []
    }
}