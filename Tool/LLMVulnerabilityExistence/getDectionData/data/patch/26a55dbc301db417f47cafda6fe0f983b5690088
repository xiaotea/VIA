{
    "src/OFS/Image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " \"\"\"Image object"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import os"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import struct"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from email.generator import _make_boundary"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from io import BytesIO"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from io import TextIOBase"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from mimetypes import guess_extension"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from tempfile import TemporaryFile"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from warnings import warn"
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from six import PY2"
            },
            "13": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from six import binary_type"
            },
            "14": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from six import text_type"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from six.moves.urllib.parse import quote"
            },
            "16": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " import ZPublisher.HTTPRequest"
            },
            "18": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from AccessControl.class_init import InitializeClass"
            },
            "19": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     from cgi import escape"
            },
            "20": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+def _get_list_from_env(name, default=None):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    \"\"\"Get list from environment variable."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    Supports splitting on comma or white space."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    Use the default as fallback only when the variable is not set."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    So if the env variable is set to an empty string, this will ignore the"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    default and return an empty list."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    \"\"\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    value = os.environ.get(name)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    if value is None:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        return default or []"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    value = value.strip()"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    if \",\" in value:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        return value.split(\",\")"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    return value.split()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+# We have one list for allowed, and one for disallowed inline mimetypes."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+# This is for security purposes."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+# By default we use the allowlist.  We give integrators the option to choose"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+# the denylist via an environment variable."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+ALLOWED_INLINE_MIMETYPES = _get_list_from_env("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    \"ALLOWED_INLINE_MIMETYPES\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+    default=["
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        \"image/gif\","
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        # The mimetypes registry lists several for jpeg 2000:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        \"image/jp2\","
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        \"image/jpeg\","
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+        \"image/jpeg2000-image\","
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        \"image/jpeg2000\","
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        \"image/jpx\","
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        \"image/png\","
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        \"image/webp\","
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        \"image/x-icon\","
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        \"image/x-jpeg2000-image\","
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        \"text/plain\","
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        # By popular request we allow PDF:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        \"application/pdf\","
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    ]"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+DISALLOWED_INLINE_MIMETYPES = _get_list_from_env("
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+    \"DISALLOWED_INLINE_MIMETYPES\","
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    default=["
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        \"application/javascript\","
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        \"application/x-javascript\","
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        \"text/javascript\","
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        \"text/html\","
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        \"image/svg+xml\","
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        \"image/svg+xml-compressed\","
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+    ]"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+try:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+    USE_DENYLIST = os.environ.get(\"OFS_IMAGE_USE_DENYLIST\")"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    USE_DENYLIST = bool(int(USE_DENYLIST))"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+except (ValueError, TypeError, AttributeError):"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+    USE_DENYLIST = False"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+"
            },
            "80": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " manage_addFileForm = DTMLFile("
            },
            "81": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     'dtml/imageAdd',"
            },
            "82": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     globals(),"
            },
            "83": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     Cacheable"
            },
            "84": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " ):"
            },
            "85": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "     \"\"\"A File object is a content object for arbitrary files.\"\"\""
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    # You can control which mimetypes may be shown inline"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+    # and which must always be downloaded, for security reasons."
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+    # Make the configuration available on the class."
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+    # Then subclasses can override this."
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+    use_denylist = USE_DENYLIST"
            },
            "93": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "94": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "     meta_type = 'File'"
            },
            "95": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "     zmi_icon = 'far fa-file-archive'"
            },
            "96": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 486,
                "PatchRowcode": "                         b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')"
            },
            "97": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": 487,
                "PatchRowcode": "                     return True"
            },
            "98": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 488,
                "PatchRowcode": " "
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+    def _should_force_download(self):"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+        # If this returns True, the caller should set a"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        # Content-Disposition header with filename."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+        mimetype = self.content_type"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+        if not mimetype:"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+            return False"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+        if self.use_denylist:"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 496,
                "PatchRowcode": "+            # We explicitly deny a few mimetypes, and allow the rest."
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 497,
                "PatchRowcode": "+            return mimetype in self.disallowed_inline_mimetypes"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+        # Use the allowlist."
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+        # We only explicitly allow a few mimetypes, and deny the rest."
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+        return mimetype not in self.allowed_inline_mimetypes"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+"
            },
            "112": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "     @security.protected(View)"
            },
            "113": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "     def index_html(self, REQUEST, RESPONSE):"
            },
            "114": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "         \"\"\""
            },
            "115": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 537,
                "PatchRowcode": "         RESPONSE.setHeader('Content-Length', self.size)"
            },
            "116": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 538,
                "PatchRowcode": "         RESPONSE.setHeader('Accept-Ranges', 'bytes')"
            },
            "117": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 539,
                "PatchRowcode": " "
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 540,
                "PatchRowcode": "+        if self._should_force_download():"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 541,
                "PatchRowcode": "+            # We need a filename, even a dummy one if needed."
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 542,
                "PatchRowcode": "+            filename = self.getId()"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 543,
                "PatchRowcode": "+            if \".\" not in filename:"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 544,
                "PatchRowcode": "+                # This either returns None or \".some_extension\""
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 545,
                "PatchRowcode": "+                ext = guess_extension(self.content_type, strict=False)"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 546,
                "PatchRowcode": "+                if not ext:"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 547,
                "PatchRowcode": "+                    # image/svg+xml -> svg"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+                    ext = \".\" + self.content_type.split(\"/\")[-1].split(\"+\")[0]"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+                filename += ext"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 550,
                "PatchRowcode": "+            if not isinstance(filename, bytes):"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 551,
                "PatchRowcode": "+                filename = filename.encode(\"utf8\")"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 552,
                "PatchRowcode": "+            filename = quote(filename)"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 553,
                "PatchRowcode": "+            RESPONSE.setHeader("
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 554,
                "PatchRowcode": "+                \"Content-Disposition\","
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 555,
                "PatchRowcode": "+                \"attachment; filename*=UTF-8''{}\".format(filename),"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 556,
                "PatchRowcode": "+            )"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 557,
                "PatchRowcode": "+"
            },
            "136": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 558,
                "PatchRowcode": "         if self.ZCacheable_isCachingEnabled():"
            },
            "137": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 559,
                "PatchRowcode": "             result = self.ZCacheable_get(default=None)"
            },
            "138": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": 560,
                "PatchRowcode": "             if result is not None:"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Image object",
            "\"\"\"",
            "",
            "import struct",
            "from email.generator import _make_boundary",
            "from io import BytesIO",
            "from io import TextIOBase",
            "from tempfile import TemporaryFile",
            "from warnings import warn",
            "",
            "from six import PY2",
            "from six import binary_type",
            "from six import text_type",
            "",
            "import ZPublisher.HTTPRequest",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.Permissions import change_images_and_files  # NOQA",
            "from AccessControl.Permissions import ftp_access",
            "from AccessControl.Permissions import view as View",
            "from AccessControl.Permissions import view_management_screens",
            "from AccessControl.Permissions import webdav_access",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from Acquisition import Implicit",
            "from App.special_dtml import DTMLFile",
            "from DateTime.DateTime import DateTime",
            "from OFS import bbb",
            "from OFS.Cache import Cacheable",
            "from OFS.interfaces import IWriteLock",
            "from OFS.PropertyManager import PropertyManager",
            "from OFS.role import RoleManager",
            "from OFS.SimpleItem import Item_w__name__",
            "from OFS.SimpleItem import PathReprProvider",
            "from Persistence import Persistent",
            "from zExceptions import Redirect",
            "from zExceptions import ResourceLockedError",
            "from zope.contenttype import guess_content_type",
            "from zope.datetime import rfc1123_date",
            "from zope.event import notify",
            "from zope.interface import implementer",
            "from zope.lifecycleevent import ObjectCreatedEvent",
            "from zope.lifecycleevent import ObjectModifiedEvent",
            "from ZPublisher import HTTPRangeSupport",
            "from ZPublisher.HTTPRequest import FileUpload",
            "",
            "",
            "try:",
            "    from html import escape",
            "except ImportError:  # PY2",
            "    from cgi import escape",
            "",
            "",
            "manage_addFileForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='File',",
            "    kind='file',",
            ")",
            "",
            "",
            "def manage_addFile(",
            "    self,",
            "    id,",
            "    file=b'',",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"Add a new File object.",
            "",
            "    Creates a new File object 'id' with the contents of 'file'\"\"\"",
            "",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the file without data:",
            "    self._setObject(id, File(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        REQUEST.RESPONSE.redirect(self.absolute_url() + '/manage_main')",
            "",
            "",
            "@implementer(IWriteLock, HTTPRangeSupport.HTTPRangeInterface)",
            "class File(",
            "    PathReprProvider,",
            "    Persistent,",
            "    Implicit,",
            "    PropertyManager,",
            "    RoleManager,",
            "    Item_w__name__,",
            "    Cacheable",
            "):",
            "    \"\"\"A File object is a content object for arbitrary files.\"\"\"",
            "",
            "    meta_type = 'File'",
            "    zmi_icon = 'far fa-file-archive'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    precondition = ''",
            "    size = None",
            "",
            "    manage_editForm = DTMLFile('dtml/fileEdit', globals(),",
            "                               Kind='File', kind='file')",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    manage_options = (({'label': 'Edit', 'action': 'manage_main'},",
            "                       {'label': 'View', 'action': ''})",
            "                      + PropertyManager.manage_options",
            "                      + RoleManager.manage_options",
            "                      + Item_w__name__.manage_options",
            "                      + Cacheable.manage_options)",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string'},",
            "    )",
            "",
            "    def __init__(self, id, title, file, content_type='', precondition=''):",
            "        self.__name__ = id",
            "        self.title = title",
            "        self.precondition = precondition",
            "",
            "        data, size = self._read_data(file)",
            "        content_type = self._get_content_type(file, data, id, content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "    def _if_modified_since_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP If-Modified-Since header handling: return True if",
            "        # we can handle this request by returning a 304 response",
            "        header = REQUEST.get_header('If-Modified-Since', None)",
            "        if header is not None:",
            "            header = header.split(';')[0]",
            "            # Some proxies seem to send invalid date strings for this",
            "            # header. If the date string is not valid, we ignore it",
            "            # rather than raise an error to be generally consistent",
            "            # with common servers such as Apache (which can usually",
            "            # understand the screwy date string as a lucky side effect",
            "            # of the way they parse it).",
            "            # This happens to be what RFC2616 tells us to do in the face of an",
            "            # invalid date.",
            "            try:",
            "                mod_since = int(DateTime(header).timeTime())",
            "            except Exception:",
            "                mod_since = None",
            "            if mod_since is not None:",
            "                if self._p_mtime:",
            "                    last_mod = int(self._p_mtime)",
            "                else:",
            "                    last_mod = 0",
            "                if last_mod > 0 and last_mod <= mod_since:",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setStatus(304)",
            "                    return True",
            "",
            "    def _range_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP Range header handling: return True if we've served a range",
            "        # chunk out of our data.",
            "        range = REQUEST.get_header('Range', None)",
            "        request_range = REQUEST.get_header('Request-Range', None)",
            "        if request_range is not None:",
            "            # Netscape 2 through 4 and MSIE 3 implement a draft version",
            "            # Later on, we need to serve a different mime-type as well.",
            "            range = request_range",
            "        if_range = REQUEST.get_header('If-Range', None)",
            "        if range is not None:",
            "            ranges = HTTPRangeSupport.parseRange(range)",
            "",
            "            if if_range is not None:",
            "                # Only send ranges if the data isn't modified, otherwise send",
            "                # the whole object. Support both ETags and Last-Modified dates!",
            "                if len(if_range) > 1 and if_range[:2] == 'ts':",
            "                    # ETag:",
            "                    if if_range != self.http__etag():",
            "                        # Modified, so send a normal response. We delete",
            "                        # the ranges, which causes us to skip to the 200",
            "                        # response.",
            "                        ranges = None",
            "                else:",
            "                    # Date",
            "                    date = if_range.split(';')[0]",
            "                    try:",
            "                        mod_since = int(DateTime(date).timeTime())",
            "                    except Exception:",
            "                        mod_since = None",
            "                    if mod_since is not None:",
            "                        if self._p_mtime:",
            "                            last_mod = int(self._p_mtime)",
            "                        else:",
            "                            last_mod = 0",
            "                        if last_mod > mod_since:",
            "                            # Modified, so send a normal response. We delete",
            "                            # the ranges, which causes us to skip to the 200",
            "                            # response.",
            "                            ranges = None",
            "",
            "            if ranges:",
            "                # Search for satisfiable ranges.",
            "                satisfiable = 0",
            "                for start, end in ranges:",
            "                    if start < self.size:",
            "                        satisfiable = 1",
            "                        break",
            "",
            "                if not satisfiable:",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range', 'bytes */%d' % self.size",
            "                    )",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', self.size)",
            "                    RESPONSE.setStatus(416)",
            "                    return True",
            "",
            "                ranges = HTTPRangeSupport.expandRanges(ranges, self.size)",
            "",
            "                if len(ranges) == 1:",
            "                    # Easy case, set extra header and return partial set.",
            "                    start, end = ranges[0]",
            "                    size = end - start",
            "",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range',",
            "                        'bytes %d-%d/%d' % (start, end - 1, self.size)",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    if isinstance(data, binary_type):",
            "                        RESPONSE.write(data[start:end])",
            "                        return True",
            "",
            "                    # Linked Pdata objects. Urgh.",
            "                    pos = 0",
            "                    while data is not None:",
            "                        length = len(data.data)",
            "                        pos = pos + length",
            "                        if pos > start:",
            "                            # We are within the range",
            "                            lstart = length - (pos - start)",
            "",
            "                            if lstart < 0:",
            "                                lstart = 0",
            "",
            "                            # find the endpoint",
            "                            if end <= pos:",
            "                                lend = length - (pos - end)",
            "",
            "                                # Send and end transmission",
            "                                RESPONSE.write(data[lstart:lend])",
            "                                break",
            "",
            "                            # Not yet at the end, transmit what we have.",
            "                            RESPONSE.write(data[lstart:])",
            "",
            "                        data = data.next",
            "",
            "                    return True",
            "",
            "                else:",
            "                    boundary = _make_boundary()",
            "",
            "                    # Calculate the content length",
            "                    size = (8 + len(boundary)  # End marker length",
            "                            + len(ranges) * (  # Constant lenght per set",
            "                                49 + len(boundary)",
            "                                + len(self.content_type)",
            "                                + len('%d' % self.size)))",
            "                    for start, end in ranges:",
            "                        # Variable length per set",
            "                        size = (size + len('%d%d' % (start, end - 1))",
            "                                + end - start)",
            "",
            "                    # Some clients implement an earlier draft of the spec, they",
            "                    # will only accept x-byteranges.",
            "                    draftprefix = (request_range is not None) and 'x-' or ''",
            "",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader(",
            "                        'Content-Type',",
            "                        'multipart/%sbyteranges; boundary=%s' % (",
            "                            draftprefix,",
            "                            boundary,",
            "                        )",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    # The Pdata map allows us to jump into the Pdata chain",
            "                    # arbitrarily during out-of-order range searching.",
            "                    pdata_map = {}",
            "                    pdata_map[0] = data",
            "",
            "                    for start, end in ranges:",
            "                        RESPONSE.write(",
            "                            b'\\r\\n--'",
            "                            + boundary.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Type: '",
            "                            + self.content_type.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Range: bytes '",
            "                            + str(start).encode('ascii')",
            "                            + b'-'",
            "                            + str(end - 1).encode('ascii')",
            "                            + b'/'",
            "                            + str(self.size).encode('ascii')",
            "                            + b'\\r\\n\\r\\n'",
            "                        )",
            "",
            "                        if isinstance(data, binary_type):",
            "                            RESPONSE.write(data[start:end])",
            "",
            "                        else:",
            "                            # Yippee. Linked Pdata objects. The following",
            "                            # calculations allow us to fast-forward through the",
            "                            # Pdata chain without a lot of dereferencing if we",
            "                            # did the work already.",
            "                            first_size = len(pdata_map[0].data)",
            "                            if start < first_size:",
            "                                closest_pos = 0",
            "                            else:",
            "                                closest_pos = (",
            "                                    ((start - first_size) >> 16 << 16)",
            "                                    + first_size",
            "                                )",
            "                            pos = min(closest_pos, max(pdata_map.keys()))",
            "                            data = pdata_map[pos]",
            "",
            "                            while data is not None:",
            "                                length = len(data.data)",
            "                                pos = pos + length",
            "                                if pos > start:",
            "                                    # We are within the range",
            "                                    lstart = length - (pos - start)",
            "",
            "                                    if lstart < 0:",
            "                                        lstart = 0",
            "",
            "                                    # find the endpoint",
            "                                    if end <= pos:",
            "                                        lend = length - (pos - end)",
            "",
            "                                        # Send and loop to next range",
            "                                        RESPONSE.write(data[lstart:lend])",
            "                                        break",
            "",
            "                                    # Not yet at the end,",
            "                                    # transmit what we have.",
            "                                    RESPONSE.write(data[lstart:])",
            "",
            "                                data = data.next",
            "                                # Store a reference to a Pdata chain link",
            "                                # so we don't have to deref during",
            "                                # this request again.",
            "                                pdata_map[pos] = data",
            "",
            "                    # Do not keep the link references around.",
            "                    del pdata_map",
            "",
            "                    RESPONSE.write(",
            "                        b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')",
            "                    return True",
            "",
            "    @security.protected(View)",
            "    def index_html(self, REQUEST, RESPONSE):",
            "        \"\"\"",
            "        The default view of the contents of a File or Image.",
            "",
            "        Returns the contents of the file or image.  Also, sets the",
            "        Content-Type HTTP header to the objects content type.",
            "        \"\"\"",
            "",
            "        if self._if_modified_since_request_handler(REQUEST, RESPONSE):",
            "            # we were able to handle this by returning a 304",
            "            # unfortunately, because the HTTP cache manager uses the cache",
            "            # API, and because 304 responses are required to carry the Expires",
            "            # header for HTTP/1.1, we need to call ZCacheable_set here.",
            "            # This is nonsensical for caches other than the HTTP cache manager",
            "            # unfortunately.",
            "            self.ZCacheable_set(None)",
            "            return b''",
            "",
            "        if self.precondition and hasattr(self, str(self.precondition)):",
            "            # Grab whatever precondition was defined and then",
            "            # execute it.  The precondition will raise an exception",
            "            # if something violates its terms.",
            "            c = getattr(self, str(self.precondition))",
            "            if hasattr(c, 'isDocTemp') and c.isDocTemp:",
            "                c(REQUEST['PARENTS'][1], REQUEST)",
            "            else:",
            "                c()",
            "",
            "        if self._range_request_handler(REQUEST, RESPONSE):",
            "            # we served a chunk of content in response to a range request.",
            "            return b''",
            "",
            "        RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))",
            "        RESPONSE.setHeader('Content-Type', self.content_type)",
            "        RESPONSE.setHeader('Content-Length', self.size)",
            "        RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager and HTTP",
            "                # Accelerated Cache Manager but we will get",
            "                # something implementing the IStreamIterator interface",
            "                # from a \"FileCacheManager\"",
            "                return result",
            "",
            "        self.ZCacheable_set(None)",
            "",
            "        data = self.data",
            "        if isinstance(data, binary_type):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "    @security.protected(View)",
            "    def view_image_or_file(self, URL1):",
            "        \"\"\"The default view of the contents of the File or Image.\"\"\"",
            "        raise Redirect(URL1)",
            "",
            "    @security.protected(View)",
            "    def PrincipiaSearchSource(self):",
            "        \"\"\"Allow file objects to be searched.\"\"\"",
            "        if self.content_type.startswith('text/'):",
            "            return bytes(self.data)",
            "        return b''",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, text_type):",
            "            raise TypeError('Data can only be bytes or file-like. '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "        if size is None:",
            "            size = len(data)",
            "        self.size = size",
            "        self.data = data",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def _get_encoding(self):",
            "        \"\"\"Get the canonical encoding for ZMI.\"\"\"",
            "        return ZPublisher.HTTPRequest.default_encoding",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_edit(",
            "        self,",
            "        title,",
            "        content_type,",
            "        precondition='',",
            "        filedata=None,",
            "        REQUEST=None",
            "    ):",
            "        \"\"\"",
            "        Changes the title and content type attributes of the File or Image.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        self.title = str(title)",
            "        self.content_type = str(content_type)",
            "        if precondition:",
            "            self.precondition = str(precondition)",
            "        elif self.precondition:",
            "            del self.precondition",
            "        if filedata is not None:",
            "            if isinstance(filedata, text_type):",
            "                filedata = filedata.encode(self._get_encoding())",
            "            self.update_data(filedata, content_type, len(filedata))",
            "        else:",
            "            self.ZCacheable_invalidate()",
            "",
            "        notify(ObjectModifiedEvent(self))",
            "",
            "        if REQUEST:",
            "            message = \"Saved changes.\"",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=message)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_upload(self, file='', REQUEST=None):",
            "        \"\"\"",
            "        Replaces the current contents of the File or Image object with file.",
            "",
            "        The file or images contents are replaced with the contents of 'file'.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        if file:",
            "            data, size = self._read_data(file)",
            "            content_type = self._get_content_type(file, data, self.__name__,",
            "                                                  'application/octet-stream')",
            "            self.update_data(data, content_type, size)",
            "            notify(ObjectModifiedEvent(self))",
            "            msg = 'Saved changes.'",
            "        else:",
            "            msg = 'Please select a file to upload.'",
            "",
            "        if REQUEST:",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=msg)",
            "",
            "    def _get_content_type(self, file, body, id, content_type=None):",
            "        \"\"\"return content type or ``None``.",
            "",
            "        *file* usually is a ``FileUpload`` (like) instance; if this",
            "        specifies a content type, it is used. If *file*",
            "        is not ``FileUpload`` like, it is ignored and the",
            "        content type is guessed from the other parameters.",
            "",
            "        *body* is either a ``bytes`` or a ``Pdata`` instance",
            "        and assumed to be the *file* data.",
            "        \"\"\"",
            "        headers = getattr(file, 'headers', None)",
            "        if headers and 'content-type' in headers:",
            "            content_type = headers['content-type']",
            "        else:",
            "            if not isinstance(body, bytes):",
            "                body = body.data",
            "            content_type, enc = guess_content_type(",
            "                getattr(file, 'filename', id), body, content_type)",
            "        return content_type",
            "",
            "    def _read_data(self, file):",
            "        \"\"\"return the data and size of *file* as tuple *data*, *size*.",
            "",
            "        *file* can be a ``bytes``, ``Pdata``, ``FileUpload`` or",
            "        (binary) file like instance.",
            "",
            "        For large files, *data* is a ``Pdata``, otherwise a ``bytes`` instance.",
            "        \"\"\"",
            "        import transaction",
            "",
            "        n = 1 << 16",
            "",
            "        if isinstance(file, text_type):",
            "            raise ValueError(\"Must be bytes\")",
            "",
            "        if isinstance(file, bytes):",
            "            size = len(file)",
            "            if size < n:",
            "                return (file, size)",
            "            # Big string: cut it into smaller chunks",
            "            file = BytesIO(file)",
            "",
            "        if isinstance(file, FileUpload) and not file:",
            "            raise ValueError('File not specified')",
            "",
            "        if hasattr(file, '__class__') and file.__class__ is Pdata:",
            "            size = len(file)",
            "            return (file, size)",
            "",
            "        seek = file.seek",
            "        read = file.read",
            "",
            "        seek(0, 2)",
            "        size = end = file.tell()",
            "",
            "        if size <= 2 * n:",
            "            seek(0)",
            "            if size < n:",
            "                return read(size), size",
            "            return Pdata(read(size)), size",
            "",
            "        # Make sure we have an _p_jar, even if we are a new object, by",
            "        # doing a sub-transaction commit.",
            "        transaction.savepoint(optimistic=True)",
            "",
            "        if self._p_jar is None:",
            "            # Ugh",
            "            seek(0)",
            "            return Pdata(read(size)), size",
            "",
            "        # Now we're going to build a linked list from back",
            "        # to front to minimize the number of database updates",
            "        # and to allow us to get things out of memory as soon as",
            "        # possible.",
            "        _next = None",
            "        while end > 0:",
            "            pos = end - n",
            "            if pos < n:",
            "                pos = 0  # we always want at least n bytes",
            "            seek(pos)",
            "",
            "            # Create the object and assign it a next pointer",
            "            # in the same transaction, so that there is only",
            "            # a single database update for it.",
            "            data = Pdata(read(end - pos))",
            "            self._p_jar.add(data)",
            "            data.next = _next",
            "",
            "            # Save the object so that we can release its memory.",
            "            transaction.savepoint(optimistic=True)",
            "            data._p_deactivate()",
            "            # The object should be assigned an oid and be a ghost.",
            "            assert data._p_oid is not None",
            "            assert data._p_state == -1",
            "",
            "            _next = data",
            "            end = pos",
            "",
            "        return (_next, size)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def PUT(self, REQUEST, RESPONSE):",
            "        \"\"\"Handle HTTP PUT requests\"\"\"",
            "        self.dav__init(REQUEST, RESPONSE)",
            "        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)",
            "",
            "        type = REQUEST.get_header('content-type', None)",
            "        file = REQUEST['BODYFILE']",
            "",
            "        # Work around ``cgi`` bug",
            "        # ``cgi`` can turn the request body into a text file using",
            "        # the default encoding. ``File``, however, insists to work",
            "        # with bytes and binary files and forbids text.",
            "        # Convert back.",
            "        tfile = None",
            "        if isinstance(file, TextIOBase):  # ``cgi`` bug",
            "            if hasattr(file, \"buffer\"):",
            "                file = file.buffer  # underlying binary buffer",
            "            else:",
            "                from ZPublisher.HTTPRequest import default_encoding",
            "                tfile = TemporaryFile(\"wb+\")",
            "                bufsize = 1 << 16",
            "                while True:",
            "                    data = file.read(bufsize)",
            "                    if not data:",
            "                        break",
            "                    tfile.write(data.encode(default_encoding))",
            "                file.seek(0, 0)",
            "                tfile.seek(0, 0)",
            "                file = tfile",
            "",
            "        data, size = self._read_data(file)",
            "        if tfile is not None:",
            "            tfile.close()",
            "        content_type = self._get_content_type(file, data, self.__name__,",
            "                                              type or self.content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "        RESPONSE.setStatus(204)",
            "        return RESPONSE",
            "",
            "    @security.protected(View)",
            "    def get_size(self):",
            "        # Get the size of a file or image.",
            "        # Returns the size of the file or image.",
            "        size = self.size",
            "        if size is None:",
            "            size = len(self.data)",
            "        return size",
            "",
            "    # deprecated; use get_size!",
            "    getSize = get_size",
            "",
            "    @security.protected(View)",
            "    def getContentType(self):",
            "        # Get the content type of a file or image.",
            "        # Returns the content type (MIME type) of a file or image.",
            "        return self.content_type",
            "",
            "    def __bytes__(self):",
            "        return bytes(self.data)",
            "",
            "    def __str__(self):",
            "        if PY2:",
            "            return str(self.data)",
            "        else:",
            "            if isinstance(self.data, Pdata):",
            "                return bytes(self.data).decode(self._get_encoding())",
            "            else:",
            "                return self.data.decode(self._get_encoding())",
            "",
            "    def __bool__(self):",
            "        return True",
            "",
            "    __nonzero__ = __bool__",
            "",
            "    def __len__(self):",
            "        data = bytes(self.data)",
            "        return len(data)",
            "",
            "    @security.protected(webdav_access)",
            "    def manage_DAVget(self):",
            "        \"\"\"Return body for WebDAV.\"\"\"",
            "        RESPONSE = self.REQUEST.RESPONSE",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager but we will",
            "                # get something implementing the IStreamIterator interface",
            "                # from FileCacheManager.",
            "                # the content-length is required here by HTTPResponse.",
            "                RESPONSE.setHeader('Content-Length', self.size)",
            "                return result",
            "",
            "        data = self.data",
            "        if isinstance(data, binary_type):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "    if bbb.HAS_ZSERVER:",
            "",
            "        @security.protected(ftp_access)",
            "        def manage_FTPget(self):",
            "            \"\"\"Return body for ftp.\"\"\"",
            "            warn(u'manage_FTPget is deprecated and will be removed in Zope 5.',",
            "                 DeprecationWarning, stacklevel=2)",
            "            return self.manage_DAVget()",
            "",
            "",
            "InitializeClass(File)",
            "",
            "",
            "manage_addImageForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='Image',",
            "    kind='image',",
            ")",
            "",
            "",
            "def manage_addImage(",
            "    self,",
            "    id,",
            "    file,",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"",
            "    Add a new Image object.",
            "",
            "    Creates a new Image object 'id' with the contents of 'file'.",
            "    \"\"\"",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the image without data:",
            "    self._setObject(id, Image(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        try:",
            "            url = self.DestinationURL()",
            "        except Exception:",
            "            url = REQUEST['URL1']",
            "        REQUEST.RESPONSE.redirect('%s/manage_main' % url)",
            "    return id",
            "",
            "",
            "def getImageInfo(data):",
            "    data = bytes(data)",
            "    size = len(data)",
            "    height = -1",
            "    width = -1",
            "    content_type = ''",
            "",
            "    # handle GIFs",
            "    if (size >= 10) and data[:6] in (b'GIF87a', b'GIF89a'):",
            "        # Check to see if content_type is correct",
            "        content_type = 'image/gif'",
            "        w, h = struct.unpack(\"<HH\", data[6:10])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)",
            "    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'",
            "    # and finally the 4-byte width, height",
            "    elif (size >= 24",
            "          and data[:8] == b'\\211PNG\\r\\n\\032\\n'",
            "          and data[12:16] == b'IHDR'):",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[16:24])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # Maybe this is for an older PNG version.",
            "    elif (size >= 16) and (data[:8] == b'\\211PNG\\r\\n\\032\\n'):",
            "        # Check to see if we have the right content type",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[8:16])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # handle JPEGs",
            "    elif (size >= 2) and (data[:2] == b'\\377\\330'):",
            "        content_type = 'image/jpeg'",
            "        jpeg = BytesIO(data)",
            "        jpeg.read(2)",
            "        b = jpeg.read(1)",
            "        try:",
            "            while (b and ord(b) != 0xDA):",
            "                while (ord(b) != 0xFF):",
            "                    b = jpeg.read(1)",
            "                while (ord(b) == 0xFF):",
            "                    b = jpeg.read(1)",
            "                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):",
            "                    jpeg.read(3)",
            "                    h, w = struct.unpack(\">HH\", jpeg.read(4))",
            "                    break",
            "                else:",
            "                    jpeg.read(int(struct.unpack(\">H\", jpeg.read(2))[0]) - 2)",
            "                b = jpeg.read(1)",
            "            width = int(w)",
            "            height = int(h)",
            "        except Exception:",
            "            pass",
            "",
            "    return content_type, width, height",
            "",
            "",
            "class Image(File):",
            "    \"\"\"Image objects can be GIF, PNG or JPEG and have the same methods",
            "    as File objects.  Images also have a string representation that",
            "    renders an HTML 'IMG' tag.",
            "    \"\"\"",
            "",
            "    meta_type = 'Image'",
            "    zmi_icon = 'far fa-file-image'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    alt = ''",
            "    height = ''",
            "    width = ''",
            "",
            "    # FIXME: Redundant, already in base class",
            "    security.declareProtected(change_images_and_files, 'manage_edit')  # NOQA: D001,E501",
            "    security.declareProtected(change_images_and_files, 'manage_upload')  # NOQA: D001,E501",
            "    security.declareProtected(View, 'index_html')  # NOQA: D001",
            "    security.declareProtected(View, 'get_size')  # NOQA: D001",
            "    security.declareProtected(View, 'getContentType')  # NOQA: D001",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'alt', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string', 'mode': 'w'},",
            "        {'id': 'height', 'type': 'string'},",
            "        {'id': 'width', 'type': 'string'},",
            "    )",
            "",
            "    manage_options = (",
            "        ({'label': 'Edit', 'action': 'manage_main'},",
            "         {'label': 'View', 'action': 'view_image_or_file'})",
            "        + PropertyManager.manage_options",
            "        + RoleManager.manage_options",
            "        + Item_w__name__.manage_options",
            "        + Cacheable.manage_options",
            "    )",
            "",
            "    manage_editForm = DTMLFile(",
            "        'dtml/imageEdit',",
            "        globals(),",
            "        Kind='Image',",
            "        kind='image',",
            "    )",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(View, 'view_image_or_file')  # NOQA: D001",
            "    view_image_or_file = DTMLFile('dtml/imageView', globals())",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, text_type):",
            "            raise TypeError('Data can only be bytes or file-like.  '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if size is None:",
            "            size = len(data)",
            "",
            "        self.size = size",
            "        self.data = data",
            "",
            "        ct, width, height = getImageInfo(data)",
            "        if ct:",
            "            content_type = ct",
            "        if width >= 0 and height >= 0:",
            "            self.width = width",
            "            self.height = height",
            "",
            "        # Now we should have the correct content type, or still None",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def __bytes__(self):",
            "        return self.tag().encode('utf-8')",
            "",
            "    def __str__(self):",
            "        return self.tag()",
            "",
            "    @security.protected(View)",
            "    def tag(",
            "        self,",
            "        height=None,",
            "        width=None,",
            "        alt=None,",
            "        scale=0,",
            "        xscale=0,",
            "        yscale=0,",
            "        css_class=None,",
            "        title=None,",
            "        **args",
            "    ):",
            "        \"\"\"Generate an HTML IMG tag for this image, with customization.",
            "",
            "        Arguments to self.tag() can be any valid attributes of an IMG tag.",
            "        'src' will always be an absolute pathname, to prevent redundant",
            "        downloading of images. Defaults are applied intelligently for",
            "        'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',",
            "        and 'yscale' keyword arguments will be used to automatically adjust",
            "        the output height and width values of the image tag.",
            "        #",
            "        Since 'class' is a Python reserved word, it cannot be passed in",
            "        directly in keyword arguments which is a problem if you are",
            "        trying to use 'tag()' to include a CSS class. The tag() method",
            "        will accept a 'css_class' argument that will be converted to",
            "        'class' in the output tag to work around this.",
            "        \"\"\"",
            "        if height is None:",
            "            height = self.height",
            "        if width is None:",
            "            width = self.width",
            "",
            "        # Auto-scaling support",
            "        xdelta = xscale or scale",
            "        ydelta = yscale or scale",
            "",
            "        if xdelta and width:",
            "            width = str(int(round(int(width) * xdelta)))",
            "        if ydelta and height:",
            "            height = str(int(round(int(height) * ydelta)))",
            "",
            "        result = '<img src=\"%s\"' % (self.absolute_url())",
            "",
            "        if alt is None:",
            "            alt = getattr(self, 'alt', '')",
            "        result = '%s alt=\"%s\"' % (result, escape(alt, True))",
            "",
            "        if title is None:",
            "            title = getattr(self, 'title', '')",
            "        result = '%s title=\"%s\"' % (result, escape(title, True))",
            "",
            "        if height:",
            "            result = '%s height=\"%s\"' % (result, height)",
            "",
            "        if width:",
            "            result = '%s width=\"%s\"' % (result, width)",
            "",
            "        if css_class is not None:",
            "            result = '%s class=\"%s\"' % (result, css_class)",
            "",
            "        for key in list(args.keys()):",
            "            value = args.get(key)",
            "            if value:",
            "                result = '%s %s=\"%s\"' % (result, key, value)",
            "",
            "        return '%s />' % result",
            "",
            "",
            "InitializeClass(Image)",
            "",
            "",
            "def cookId(id, title, file):",
            "    if not id and hasattr(file, 'filename'):",
            "        filename = file.filename",
            "        title = title or filename",
            "        id = filename[max(filename.rfind('/'),",
            "                          filename.rfind('\\\\'),",
            "                          filename.rfind(':'),",
            "                          ) + 1:]",
            "    return id, title",
            "",
            "",
            "class Pdata(Persistent, Implicit):",
            "    # Wrapper for possibly large data",
            "",
            "    next = None",
            "",
            "    def __init__(self, data):",
            "        self.data = data",
            "",
            "    if PY2:",
            "        def __getslice__(self, i, j):",
            "            return self.data[i:j]",
            "",
            "    def __getitem__(self, key):",
            "        return self.data[key]",
            "",
            "    def __len__(self):",
            "        data = bytes(self)",
            "        return len(data)",
            "",
            "    def __bytes__(self):",
            "        _next = self.next",
            "        if _next is None:",
            "            return self.data",
            "",
            "        r = [self.data]",
            "        while _next is not None:",
            "            self = _next",
            "            r.append(self.data)",
            "            _next = self.next",
            "",
            "        return b''.join(r)",
            "",
            "    if PY2:",
            "        __str__ = __bytes__"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Image object",
            "\"\"\"",
            "",
            "import os",
            "import struct",
            "from email.generator import _make_boundary",
            "from io import BytesIO",
            "from io import TextIOBase",
            "from mimetypes import guess_extension",
            "from tempfile import TemporaryFile",
            "from warnings import warn",
            "",
            "from six import PY2",
            "from six import binary_type",
            "from six import text_type",
            "from six.moves.urllib.parse import quote",
            "",
            "import ZPublisher.HTTPRequest",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.Permissions import change_images_and_files  # NOQA",
            "from AccessControl.Permissions import ftp_access",
            "from AccessControl.Permissions import view as View",
            "from AccessControl.Permissions import view_management_screens",
            "from AccessControl.Permissions import webdav_access",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from Acquisition import Implicit",
            "from App.special_dtml import DTMLFile",
            "from DateTime.DateTime import DateTime",
            "from OFS import bbb",
            "from OFS.Cache import Cacheable",
            "from OFS.interfaces import IWriteLock",
            "from OFS.PropertyManager import PropertyManager",
            "from OFS.role import RoleManager",
            "from OFS.SimpleItem import Item_w__name__",
            "from OFS.SimpleItem import PathReprProvider",
            "from Persistence import Persistent",
            "from zExceptions import Redirect",
            "from zExceptions import ResourceLockedError",
            "from zope.contenttype import guess_content_type",
            "from zope.datetime import rfc1123_date",
            "from zope.event import notify",
            "from zope.interface import implementer",
            "from zope.lifecycleevent import ObjectCreatedEvent",
            "from zope.lifecycleevent import ObjectModifiedEvent",
            "from ZPublisher import HTTPRangeSupport",
            "from ZPublisher.HTTPRequest import FileUpload",
            "",
            "",
            "try:",
            "    from html import escape",
            "except ImportError:  # PY2",
            "    from cgi import escape",
            "",
            "",
            "def _get_list_from_env(name, default=None):",
            "    \"\"\"Get list from environment variable.",
            "",
            "    Supports splitting on comma or white space.",
            "    Use the default as fallback only when the variable is not set.",
            "    So if the env variable is set to an empty string, this will ignore the",
            "    default and return an empty list.",
            "    \"\"\"",
            "    value = os.environ.get(name)",
            "    if value is None:",
            "        return default or []",
            "    value = value.strip()",
            "    if \",\" in value:",
            "        return value.split(\",\")",
            "    return value.split()",
            "",
            "",
            "# We have one list for allowed, and one for disallowed inline mimetypes.",
            "# This is for security purposes.",
            "# By default we use the allowlist.  We give integrators the option to choose",
            "# the denylist via an environment variable.",
            "ALLOWED_INLINE_MIMETYPES = _get_list_from_env(",
            "    \"ALLOWED_INLINE_MIMETYPES\",",
            "    default=[",
            "        \"image/gif\",",
            "        # The mimetypes registry lists several for jpeg 2000:",
            "        \"image/jp2\",",
            "        \"image/jpeg\",",
            "        \"image/jpeg2000-image\",",
            "        \"image/jpeg2000\",",
            "        \"image/jpx\",",
            "        \"image/png\",",
            "        \"image/webp\",",
            "        \"image/x-icon\",",
            "        \"image/x-jpeg2000-image\",",
            "        \"text/plain\",",
            "        # By popular request we allow PDF:",
            "        \"application/pdf\",",
            "    ]",
            ")",
            "DISALLOWED_INLINE_MIMETYPES = _get_list_from_env(",
            "    \"DISALLOWED_INLINE_MIMETYPES\",",
            "    default=[",
            "        \"application/javascript\",",
            "        \"application/x-javascript\",",
            "        \"text/javascript\",",
            "        \"text/html\",",
            "        \"image/svg+xml\",",
            "        \"image/svg+xml-compressed\",",
            "    ]",
            ")",
            "try:",
            "    USE_DENYLIST = os.environ.get(\"OFS_IMAGE_USE_DENYLIST\")",
            "    USE_DENYLIST = bool(int(USE_DENYLIST))",
            "except (ValueError, TypeError, AttributeError):",
            "    USE_DENYLIST = False",
            "",
            "",
            "manage_addFileForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='File',",
            "    kind='file',",
            ")",
            "",
            "",
            "def manage_addFile(",
            "    self,",
            "    id,",
            "    file=b'',",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"Add a new File object.",
            "",
            "    Creates a new File object 'id' with the contents of 'file'\"\"\"",
            "",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the file without data:",
            "    self._setObject(id, File(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        REQUEST.RESPONSE.redirect(self.absolute_url() + '/manage_main')",
            "",
            "",
            "@implementer(IWriteLock, HTTPRangeSupport.HTTPRangeInterface)",
            "class File(",
            "    PathReprProvider,",
            "    Persistent,",
            "    Implicit,",
            "    PropertyManager,",
            "    RoleManager,",
            "    Item_w__name__,",
            "    Cacheable",
            "):",
            "    \"\"\"A File object is a content object for arbitrary files.\"\"\"",
            "    # You can control which mimetypes may be shown inline",
            "    # and which must always be downloaded, for security reasons.",
            "    # Make the configuration available on the class.",
            "    # Then subclasses can override this.",
            "    allowed_inline_mimetypes = ALLOWED_INLINE_MIMETYPES",
            "    disallowed_inline_mimetypes = DISALLOWED_INLINE_MIMETYPES",
            "    use_denylist = USE_DENYLIST",
            "",
            "    meta_type = 'File'",
            "    zmi_icon = 'far fa-file-archive'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    precondition = ''",
            "    size = None",
            "",
            "    manage_editForm = DTMLFile('dtml/fileEdit', globals(),",
            "                               Kind='File', kind='file')",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    manage_options = (({'label': 'Edit', 'action': 'manage_main'},",
            "                       {'label': 'View', 'action': ''})",
            "                      + PropertyManager.manage_options",
            "                      + RoleManager.manage_options",
            "                      + Item_w__name__.manage_options",
            "                      + Cacheable.manage_options)",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string'},",
            "    )",
            "",
            "    def __init__(self, id, title, file, content_type='', precondition=''):",
            "        self.__name__ = id",
            "        self.title = title",
            "        self.precondition = precondition",
            "",
            "        data, size = self._read_data(file)",
            "        content_type = self._get_content_type(file, data, id, content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "    def _if_modified_since_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP If-Modified-Since header handling: return True if",
            "        # we can handle this request by returning a 304 response",
            "        header = REQUEST.get_header('If-Modified-Since', None)",
            "        if header is not None:",
            "            header = header.split(';')[0]",
            "            # Some proxies seem to send invalid date strings for this",
            "            # header. If the date string is not valid, we ignore it",
            "            # rather than raise an error to be generally consistent",
            "            # with common servers such as Apache (which can usually",
            "            # understand the screwy date string as a lucky side effect",
            "            # of the way they parse it).",
            "            # This happens to be what RFC2616 tells us to do in the face of an",
            "            # invalid date.",
            "            try:",
            "                mod_since = int(DateTime(header).timeTime())",
            "            except Exception:",
            "                mod_since = None",
            "            if mod_since is not None:",
            "                if self._p_mtime:",
            "                    last_mod = int(self._p_mtime)",
            "                else:",
            "                    last_mod = 0",
            "                if last_mod > 0 and last_mod <= mod_since:",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setStatus(304)",
            "                    return True",
            "",
            "    def _range_request_handler(self, REQUEST, RESPONSE):",
            "        # HTTP Range header handling: return True if we've served a range",
            "        # chunk out of our data.",
            "        range = REQUEST.get_header('Range', None)",
            "        request_range = REQUEST.get_header('Request-Range', None)",
            "        if request_range is not None:",
            "            # Netscape 2 through 4 and MSIE 3 implement a draft version",
            "            # Later on, we need to serve a different mime-type as well.",
            "            range = request_range",
            "        if_range = REQUEST.get_header('If-Range', None)",
            "        if range is not None:",
            "            ranges = HTTPRangeSupport.parseRange(range)",
            "",
            "            if if_range is not None:",
            "                # Only send ranges if the data isn't modified, otherwise send",
            "                # the whole object. Support both ETags and Last-Modified dates!",
            "                if len(if_range) > 1 and if_range[:2] == 'ts':",
            "                    # ETag:",
            "                    if if_range != self.http__etag():",
            "                        # Modified, so send a normal response. We delete",
            "                        # the ranges, which causes us to skip to the 200",
            "                        # response.",
            "                        ranges = None",
            "                else:",
            "                    # Date",
            "                    date = if_range.split(';')[0]",
            "                    try:",
            "                        mod_since = int(DateTime(date).timeTime())",
            "                    except Exception:",
            "                        mod_since = None",
            "                    if mod_since is not None:",
            "                        if self._p_mtime:",
            "                            last_mod = int(self._p_mtime)",
            "                        else:",
            "                            last_mod = 0",
            "                        if last_mod > mod_since:",
            "                            # Modified, so send a normal response. We delete",
            "                            # the ranges, which causes us to skip to the 200",
            "                            # response.",
            "                            ranges = None",
            "",
            "            if ranges:",
            "                # Search for satisfiable ranges.",
            "                satisfiable = 0",
            "                for start, end in ranges:",
            "                    if start < self.size:",
            "                        satisfiable = 1",
            "                        break",
            "",
            "                if not satisfiable:",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range', 'bytes */%d' % self.size",
            "                    )",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', self.size)",
            "                    RESPONSE.setStatus(416)",
            "                    return True",
            "",
            "                ranges = HTTPRangeSupport.expandRanges(ranges, self.size)",
            "",
            "                if len(ranges) == 1:",
            "                    # Easy case, set extra header and return partial set.",
            "                    start, end = ranges[0]",
            "                    size = end - start",
            "",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader('Content-Type', self.content_type)",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Content-Range',",
            "                        'bytes %d-%d/%d' % (start, end - 1, self.size)",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    if isinstance(data, binary_type):",
            "                        RESPONSE.write(data[start:end])",
            "                        return True",
            "",
            "                    # Linked Pdata objects. Urgh.",
            "                    pos = 0",
            "                    while data is not None:",
            "                        length = len(data.data)",
            "                        pos = pos + length",
            "                        if pos > start:",
            "                            # We are within the range",
            "                            lstart = length - (pos - start)",
            "",
            "                            if lstart < 0:",
            "                                lstart = 0",
            "",
            "                            # find the endpoint",
            "                            if end <= pos:",
            "                                lend = length - (pos - end)",
            "",
            "                                # Send and end transmission",
            "                                RESPONSE.write(data[lstart:lend])",
            "                                break",
            "",
            "                            # Not yet at the end, transmit what we have.",
            "                            RESPONSE.write(data[lstart:])",
            "",
            "                        data = data.next",
            "",
            "                    return True",
            "",
            "                else:",
            "                    boundary = _make_boundary()",
            "",
            "                    # Calculate the content length",
            "                    size = (8 + len(boundary)  # End marker length",
            "                            + len(ranges) * (  # Constant lenght per set",
            "                                49 + len(boundary)",
            "                                + len(self.content_type)",
            "                                + len('%d' % self.size)))",
            "                    for start, end in ranges:",
            "                        # Variable length per set",
            "                        size = (size + len('%d%d' % (start, end - 1))",
            "                                + end - start)",
            "",
            "                    # Some clients implement an earlier draft of the spec, they",
            "                    # will only accept x-byteranges.",
            "                    draftprefix = (request_range is not None) and 'x-' or ''",
            "",
            "                    RESPONSE.setHeader('Content-Length', size)",
            "                    RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "                    RESPONSE.setHeader(",
            "                        'Last-Modified', rfc1123_date(self._p_mtime)",
            "                    )",
            "                    RESPONSE.setHeader(",
            "                        'Content-Type',",
            "                        'multipart/%sbyteranges; boundary=%s' % (",
            "                            draftprefix,",
            "                            boundary,",
            "                        )",
            "                    )",
            "                    RESPONSE.setStatus(206)  # Partial content",
            "",
            "                    data = self.data",
            "                    # The Pdata map allows us to jump into the Pdata chain",
            "                    # arbitrarily during out-of-order range searching.",
            "                    pdata_map = {}",
            "                    pdata_map[0] = data",
            "",
            "                    for start, end in ranges:",
            "                        RESPONSE.write(",
            "                            b'\\r\\n--'",
            "                            + boundary.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Type: '",
            "                            + self.content_type.encode('ascii')",
            "                            + b'\\r\\n'",
            "                        )",
            "                        RESPONSE.write(",
            "                            b'Content-Range: bytes '",
            "                            + str(start).encode('ascii')",
            "                            + b'-'",
            "                            + str(end - 1).encode('ascii')",
            "                            + b'/'",
            "                            + str(self.size).encode('ascii')",
            "                            + b'\\r\\n\\r\\n'",
            "                        )",
            "",
            "                        if isinstance(data, binary_type):",
            "                            RESPONSE.write(data[start:end])",
            "",
            "                        else:",
            "                            # Yippee. Linked Pdata objects. The following",
            "                            # calculations allow us to fast-forward through the",
            "                            # Pdata chain without a lot of dereferencing if we",
            "                            # did the work already.",
            "                            first_size = len(pdata_map[0].data)",
            "                            if start < first_size:",
            "                                closest_pos = 0",
            "                            else:",
            "                                closest_pos = (",
            "                                    ((start - first_size) >> 16 << 16)",
            "                                    + first_size",
            "                                )",
            "                            pos = min(closest_pos, max(pdata_map.keys()))",
            "                            data = pdata_map[pos]",
            "",
            "                            while data is not None:",
            "                                length = len(data.data)",
            "                                pos = pos + length",
            "                                if pos > start:",
            "                                    # We are within the range",
            "                                    lstart = length - (pos - start)",
            "",
            "                                    if lstart < 0:",
            "                                        lstart = 0",
            "",
            "                                    # find the endpoint",
            "                                    if end <= pos:",
            "                                        lend = length - (pos - end)",
            "",
            "                                        # Send and loop to next range",
            "                                        RESPONSE.write(data[lstart:lend])",
            "                                        break",
            "",
            "                                    # Not yet at the end,",
            "                                    # transmit what we have.",
            "                                    RESPONSE.write(data[lstart:])",
            "",
            "                                data = data.next",
            "                                # Store a reference to a Pdata chain link",
            "                                # so we don't have to deref during",
            "                                # this request again.",
            "                                pdata_map[pos] = data",
            "",
            "                    # Do not keep the link references around.",
            "                    del pdata_map",
            "",
            "                    RESPONSE.write(",
            "                        b'\\r\\n--' + boundary.encode('ascii') + b'--\\r\\n')",
            "                    return True",
            "",
            "    def _should_force_download(self):",
            "        # If this returns True, the caller should set a",
            "        # Content-Disposition header with filename.",
            "        mimetype = self.content_type",
            "        if not mimetype:",
            "            return False",
            "        if self.use_denylist:",
            "            # We explicitly deny a few mimetypes, and allow the rest.",
            "            return mimetype in self.disallowed_inline_mimetypes",
            "        # Use the allowlist.",
            "        # We only explicitly allow a few mimetypes, and deny the rest.",
            "        return mimetype not in self.allowed_inline_mimetypes",
            "",
            "    @security.protected(View)",
            "    def index_html(self, REQUEST, RESPONSE):",
            "        \"\"\"",
            "        The default view of the contents of a File or Image.",
            "",
            "        Returns the contents of the file or image.  Also, sets the",
            "        Content-Type HTTP header to the objects content type.",
            "        \"\"\"",
            "",
            "        if self._if_modified_since_request_handler(REQUEST, RESPONSE):",
            "            # we were able to handle this by returning a 304",
            "            # unfortunately, because the HTTP cache manager uses the cache",
            "            # API, and because 304 responses are required to carry the Expires",
            "            # header for HTTP/1.1, we need to call ZCacheable_set here.",
            "            # This is nonsensical for caches other than the HTTP cache manager",
            "            # unfortunately.",
            "            self.ZCacheable_set(None)",
            "            return b''",
            "",
            "        if self.precondition and hasattr(self, str(self.precondition)):",
            "            # Grab whatever precondition was defined and then",
            "            # execute it.  The precondition will raise an exception",
            "            # if something violates its terms.",
            "            c = getattr(self, str(self.precondition))",
            "            if hasattr(c, 'isDocTemp') and c.isDocTemp:",
            "                c(REQUEST['PARENTS'][1], REQUEST)",
            "            else:",
            "                c()",
            "",
            "        if self._range_request_handler(REQUEST, RESPONSE):",
            "            # we served a chunk of content in response to a range request.",
            "            return b''",
            "",
            "        RESPONSE.setHeader('Last-Modified', rfc1123_date(self._p_mtime))",
            "        RESPONSE.setHeader('Content-Type', self.content_type)",
            "        RESPONSE.setHeader('Content-Length', self.size)",
            "        RESPONSE.setHeader('Accept-Ranges', 'bytes')",
            "",
            "        if self._should_force_download():",
            "            # We need a filename, even a dummy one if needed.",
            "            filename = self.getId()",
            "            if \".\" not in filename:",
            "                # This either returns None or \".some_extension\"",
            "                ext = guess_extension(self.content_type, strict=False)",
            "                if not ext:",
            "                    # image/svg+xml -> svg",
            "                    ext = \".\" + self.content_type.split(\"/\")[-1].split(\"+\")[0]",
            "                filename += ext",
            "            if not isinstance(filename, bytes):",
            "                filename = filename.encode(\"utf8\")",
            "            filename = quote(filename)",
            "            RESPONSE.setHeader(",
            "                \"Content-Disposition\",",
            "                \"attachment; filename*=UTF-8''{}\".format(filename),",
            "            )",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager and HTTP",
            "                # Accelerated Cache Manager but we will get",
            "                # something implementing the IStreamIterator interface",
            "                # from a \"FileCacheManager\"",
            "                return result",
            "",
            "        self.ZCacheable_set(None)",
            "",
            "        data = self.data",
            "        if isinstance(data, binary_type):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "    @security.protected(View)",
            "    def view_image_or_file(self, URL1):",
            "        \"\"\"The default view of the contents of the File or Image.\"\"\"",
            "        raise Redirect(URL1)",
            "",
            "    @security.protected(View)",
            "    def PrincipiaSearchSource(self):",
            "        \"\"\"Allow file objects to be searched.\"\"\"",
            "        if self.content_type.startswith('text/'):",
            "            return bytes(self.data)",
            "        return b''",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, text_type):",
            "            raise TypeError('Data can only be bytes or file-like. '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "        if size is None:",
            "            size = len(data)",
            "        self.size = size",
            "        self.data = data",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def _get_encoding(self):",
            "        \"\"\"Get the canonical encoding for ZMI.\"\"\"",
            "        return ZPublisher.HTTPRequest.default_encoding",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_edit(",
            "        self,",
            "        title,",
            "        content_type,",
            "        precondition='',",
            "        filedata=None,",
            "        REQUEST=None",
            "    ):",
            "        \"\"\"",
            "        Changes the title and content type attributes of the File or Image.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        self.title = str(title)",
            "        self.content_type = str(content_type)",
            "        if precondition:",
            "            self.precondition = str(precondition)",
            "        elif self.precondition:",
            "            del self.precondition",
            "        if filedata is not None:",
            "            if isinstance(filedata, text_type):",
            "                filedata = filedata.encode(self._get_encoding())",
            "            self.update_data(filedata, content_type, len(filedata))",
            "        else:",
            "            self.ZCacheable_invalidate()",
            "",
            "        notify(ObjectModifiedEvent(self))",
            "",
            "        if REQUEST:",
            "            message = \"Saved changes.\"",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=message)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def manage_upload(self, file='', REQUEST=None):",
            "        \"\"\"",
            "        Replaces the current contents of the File or Image object with file.",
            "",
            "        The file or images contents are replaced with the contents of 'file'.",
            "        \"\"\"",
            "        if self.wl_isLocked():",
            "            raise ResourceLockedError(\"File is locked.\")",
            "",
            "        if file:",
            "            data, size = self._read_data(file)",
            "            content_type = self._get_content_type(file, data, self.__name__,",
            "                                                  'application/octet-stream')",
            "            self.update_data(data, content_type, size)",
            "            notify(ObjectModifiedEvent(self))",
            "            msg = 'Saved changes.'",
            "        else:",
            "            msg = 'Please select a file to upload.'",
            "",
            "        if REQUEST:",
            "            return self.manage_main(",
            "                self, REQUEST, manage_tabs_message=msg)",
            "",
            "    def _get_content_type(self, file, body, id, content_type=None):",
            "        \"\"\"return content type or ``None``.",
            "",
            "        *file* usually is a ``FileUpload`` (like) instance; if this",
            "        specifies a content type, it is used. If *file*",
            "        is not ``FileUpload`` like, it is ignored and the",
            "        content type is guessed from the other parameters.",
            "",
            "        *body* is either a ``bytes`` or a ``Pdata`` instance",
            "        and assumed to be the *file* data.",
            "        \"\"\"",
            "        headers = getattr(file, 'headers', None)",
            "        if headers and 'content-type' in headers:",
            "            content_type = headers['content-type']",
            "        else:",
            "            if not isinstance(body, bytes):",
            "                body = body.data",
            "            content_type, enc = guess_content_type(",
            "                getattr(file, 'filename', id), body, content_type)",
            "        return content_type",
            "",
            "    def _read_data(self, file):",
            "        \"\"\"return the data and size of *file* as tuple *data*, *size*.",
            "",
            "        *file* can be a ``bytes``, ``Pdata``, ``FileUpload`` or",
            "        (binary) file like instance.",
            "",
            "        For large files, *data* is a ``Pdata``, otherwise a ``bytes`` instance.",
            "        \"\"\"",
            "        import transaction",
            "",
            "        n = 1 << 16",
            "",
            "        if isinstance(file, text_type):",
            "            raise ValueError(\"Must be bytes\")",
            "",
            "        if isinstance(file, bytes):",
            "            size = len(file)",
            "            if size < n:",
            "                return (file, size)",
            "            # Big string: cut it into smaller chunks",
            "            file = BytesIO(file)",
            "",
            "        if isinstance(file, FileUpload) and not file:",
            "            raise ValueError('File not specified')",
            "",
            "        if hasattr(file, '__class__') and file.__class__ is Pdata:",
            "            size = len(file)",
            "            return (file, size)",
            "",
            "        seek = file.seek",
            "        read = file.read",
            "",
            "        seek(0, 2)",
            "        size = end = file.tell()",
            "",
            "        if size <= 2 * n:",
            "            seek(0)",
            "            if size < n:",
            "                return read(size), size",
            "            return Pdata(read(size)), size",
            "",
            "        # Make sure we have an _p_jar, even if we are a new object, by",
            "        # doing a sub-transaction commit.",
            "        transaction.savepoint(optimistic=True)",
            "",
            "        if self._p_jar is None:",
            "            # Ugh",
            "            seek(0)",
            "            return Pdata(read(size)), size",
            "",
            "        # Now we're going to build a linked list from back",
            "        # to front to minimize the number of database updates",
            "        # and to allow us to get things out of memory as soon as",
            "        # possible.",
            "        _next = None",
            "        while end > 0:",
            "            pos = end - n",
            "            if pos < n:",
            "                pos = 0  # we always want at least n bytes",
            "            seek(pos)",
            "",
            "            # Create the object and assign it a next pointer",
            "            # in the same transaction, so that there is only",
            "            # a single database update for it.",
            "            data = Pdata(read(end - pos))",
            "            self._p_jar.add(data)",
            "            data.next = _next",
            "",
            "            # Save the object so that we can release its memory.",
            "            transaction.savepoint(optimistic=True)",
            "            data._p_deactivate()",
            "            # The object should be assigned an oid and be a ghost.",
            "            assert data._p_oid is not None",
            "            assert data._p_state == -1",
            "",
            "            _next = data",
            "            end = pos",
            "",
            "        return (_next, size)",
            "",
            "    @security.protected(change_images_and_files)",
            "    def PUT(self, REQUEST, RESPONSE):",
            "        \"\"\"Handle HTTP PUT requests\"\"\"",
            "        self.dav__init(REQUEST, RESPONSE)",
            "        self.dav__simpleifhandler(REQUEST, RESPONSE, refresh=1)",
            "",
            "        type = REQUEST.get_header('content-type', None)",
            "        file = REQUEST['BODYFILE']",
            "",
            "        # Work around ``cgi`` bug",
            "        # ``cgi`` can turn the request body into a text file using",
            "        # the default encoding. ``File``, however, insists to work",
            "        # with bytes and binary files and forbids text.",
            "        # Convert back.",
            "        tfile = None",
            "        if isinstance(file, TextIOBase):  # ``cgi`` bug",
            "            if hasattr(file, \"buffer\"):",
            "                file = file.buffer  # underlying binary buffer",
            "            else:",
            "                from ZPublisher.HTTPRequest import default_encoding",
            "                tfile = TemporaryFile(\"wb+\")",
            "                bufsize = 1 << 16",
            "                while True:",
            "                    data = file.read(bufsize)",
            "                    if not data:",
            "                        break",
            "                    tfile.write(data.encode(default_encoding))",
            "                file.seek(0, 0)",
            "                tfile.seek(0, 0)",
            "                file = tfile",
            "",
            "        data, size = self._read_data(file)",
            "        if tfile is not None:",
            "            tfile.close()",
            "        content_type = self._get_content_type(file, data, self.__name__,",
            "                                              type or self.content_type)",
            "        self.update_data(data, content_type, size)",
            "",
            "        RESPONSE.setStatus(204)",
            "        return RESPONSE",
            "",
            "    @security.protected(View)",
            "    def get_size(self):",
            "        # Get the size of a file or image.",
            "        # Returns the size of the file or image.",
            "        size = self.size",
            "        if size is None:",
            "            size = len(self.data)",
            "        return size",
            "",
            "    # deprecated; use get_size!",
            "    getSize = get_size",
            "",
            "    @security.protected(View)",
            "    def getContentType(self):",
            "        # Get the content type of a file or image.",
            "        # Returns the content type (MIME type) of a file or image.",
            "        return self.content_type",
            "",
            "    def __bytes__(self):",
            "        return bytes(self.data)",
            "",
            "    def __str__(self):",
            "        if PY2:",
            "            return str(self.data)",
            "        else:",
            "            if isinstance(self.data, Pdata):",
            "                return bytes(self.data).decode(self._get_encoding())",
            "            else:",
            "                return self.data.decode(self._get_encoding())",
            "",
            "    def __bool__(self):",
            "        return True",
            "",
            "    __nonzero__ = __bool__",
            "",
            "    def __len__(self):",
            "        data = bytes(self.data)",
            "        return len(data)",
            "",
            "    @security.protected(webdav_access)",
            "    def manage_DAVget(self):",
            "        \"\"\"Return body for WebDAV.\"\"\"",
            "        RESPONSE = self.REQUEST.RESPONSE",
            "",
            "        if self.ZCacheable_isCachingEnabled():",
            "            result = self.ZCacheable_get(default=None)",
            "            if result is not None:",
            "                # We will always get None from RAMCacheManager but we will",
            "                # get something implementing the IStreamIterator interface",
            "                # from FileCacheManager.",
            "                # the content-length is required here by HTTPResponse.",
            "                RESPONSE.setHeader('Content-Length', self.size)",
            "                return result",
            "",
            "        data = self.data",
            "        if isinstance(data, binary_type):",
            "            RESPONSE.setBase(None)",
            "            return data",
            "",
            "        while data is not None:",
            "            RESPONSE.write(data.data)",
            "            data = data.next",
            "",
            "        return b''",
            "",
            "    if bbb.HAS_ZSERVER:",
            "",
            "        @security.protected(ftp_access)",
            "        def manage_FTPget(self):",
            "            \"\"\"Return body for ftp.\"\"\"",
            "            warn(u'manage_FTPget is deprecated and will be removed in Zope 5.',",
            "                 DeprecationWarning, stacklevel=2)",
            "            return self.manage_DAVget()",
            "",
            "",
            "InitializeClass(File)",
            "",
            "",
            "manage_addImageForm = DTMLFile(",
            "    'dtml/imageAdd',",
            "    globals(),",
            "    Kind='Image',",
            "    kind='image',",
            ")",
            "",
            "",
            "def manage_addImage(",
            "    self,",
            "    id,",
            "    file,",
            "    title='',",
            "    precondition='',",
            "    content_type='',",
            "    REQUEST=None",
            "):",
            "    \"\"\"",
            "    Add a new Image object.",
            "",
            "    Creates a new Image object 'id' with the contents of 'file'.",
            "    \"\"\"",
            "    id = str(id)",
            "    title = str(title)",
            "    content_type = str(content_type)",
            "    precondition = str(precondition)",
            "",
            "    id, title = cookId(id, title, file)",
            "",
            "    self = self.this()",
            "",
            "    # First, we create the image without data:",
            "    self._setObject(id, Image(id, title, b'', content_type, precondition))",
            "",
            "    newFile = self._getOb(id)",
            "",
            "    # Now we \"upload\" the data.  By doing this in two steps, we",
            "    # can use a database trick to make the upload more efficient.",
            "    if file:",
            "        newFile.manage_upload(file)",
            "    if content_type:",
            "        newFile.content_type = content_type",
            "",
            "    notify(ObjectCreatedEvent(newFile))",
            "",
            "    if REQUEST is not None:",
            "        try:",
            "            url = self.DestinationURL()",
            "        except Exception:",
            "            url = REQUEST['URL1']",
            "        REQUEST.RESPONSE.redirect('%s/manage_main' % url)",
            "    return id",
            "",
            "",
            "def getImageInfo(data):",
            "    data = bytes(data)",
            "    size = len(data)",
            "    height = -1",
            "    width = -1",
            "    content_type = ''",
            "",
            "    # handle GIFs",
            "    if (size >= 10) and data[:6] in (b'GIF87a', b'GIF89a'):",
            "        # Check to see if content_type is correct",
            "        content_type = 'image/gif'",
            "        w, h = struct.unpack(\"<HH\", data[6:10])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # See PNG v1.2 spec (http://www.cdrom.com/pub/png/spec/)",
            "    # Bytes 0-7 are below, 4-byte chunk length, then 'IHDR'",
            "    # and finally the 4-byte width, height",
            "    elif (size >= 24",
            "          and data[:8] == b'\\211PNG\\r\\n\\032\\n'",
            "          and data[12:16] == b'IHDR'):",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[16:24])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # Maybe this is for an older PNG version.",
            "    elif (size >= 16) and (data[:8] == b'\\211PNG\\r\\n\\032\\n'):",
            "        # Check to see if we have the right content type",
            "        content_type = 'image/png'",
            "        w, h = struct.unpack(\">LL\", data[8:16])",
            "        width = int(w)",
            "        height = int(h)",
            "",
            "    # handle JPEGs",
            "    elif (size >= 2) and (data[:2] == b'\\377\\330'):",
            "        content_type = 'image/jpeg'",
            "        jpeg = BytesIO(data)",
            "        jpeg.read(2)",
            "        b = jpeg.read(1)",
            "        try:",
            "            while (b and ord(b) != 0xDA):",
            "                while (ord(b) != 0xFF):",
            "                    b = jpeg.read(1)",
            "                while (ord(b) == 0xFF):",
            "                    b = jpeg.read(1)",
            "                if (ord(b) >= 0xC0 and ord(b) <= 0xC3):",
            "                    jpeg.read(3)",
            "                    h, w = struct.unpack(\">HH\", jpeg.read(4))",
            "                    break",
            "                else:",
            "                    jpeg.read(int(struct.unpack(\">H\", jpeg.read(2))[0]) - 2)",
            "                b = jpeg.read(1)",
            "            width = int(w)",
            "            height = int(h)",
            "        except Exception:",
            "            pass",
            "",
            "    return content_type, width, height",
            "",
            "",
            "class Image(File):",
            "    \"\"\"Image objects can be GIF, PNG or JPEG and have the same methods",
            "    as File objects.  Images also have a string representation that",
            "    renders an HTML 'IMG' tag.",
            "    \"\"\"",
            "",
            "    meta_type = 'Image'",
            "    zmi_icon = 'far fa-file-image'",
            "",
            "    security = ClassSecurityInfo()",
            "    security.declareObjectProtected(View)",
            "",
            "    alt = ''",
            "    height = ''",
            "    width = ''",
            "",
            "    # FIXME: Redundant, already in base class",
            "    security.declareProtected(change_images_and_files, 'manage_edit')  # NOQA: D001,E501",
            "    security.declareProtected(change_images_and_files, 'manage_upload')  # NOQA: D001,E501",
            "    security.declareProtected(View, 'index_html')  # NOQA: D001",
            "    security.declareProtected(View, 'get_size')  # NOQA: D001",
            "    security.declareProtected(View, 'getContentType')  # NOQA: D001",
            "",
            "    _properties = (",
            "        {'id': 'title', 'type': 'string'},",
            "        {'id': 'alt', 'type': 'string'},",
            "        {'id': 'content_type', 'type': 'string', 'mode': 'w'},",
            "        {'id': 'height', 'type': 'string'},",
            "        {'id': 'width', 'type': 'string'},",
            "    )",
            "",
            "    manage_options = (",
            "        ({'label': 'Edit', 'action': 'manage_main'},",
            "         {'label': 'View', 'action': 'view_image_or_file'})",
            "        + PropertyManager.manage_options",
            "        + RoleManager.manage_options",
            "        + Item_w__name__.manage_options",
            "        + Cacheable.manage_options",
            "    )",
            "",
            "    manage_editForm = DTMLFile(",
            "        'dtml/imageEdit',",
            "        globals(),",
            "        Kind='Image',",
            "        kind='image',",
            "    )",
            "    manage_editForm._setName('manage_editForm')",
            "",
            "    security.declareProtected(View, 'view_image_or_file')  # NOQA: D001",
            "    view_image_or_file = DTMLFile('dtml/imageView', globals())",
            "",
            "    security.declareProtected(view_management_screens, 'manage')  # NOQA: D001",
            "    security.declareProtected(view_management_screens, 'manage_main')  # NOQA: D001,E501",
            "    manage = manage_main = manage_editForm",
            "    manage_uploadForm = manage_editForm",
            "",
            "    @security.private",
            "    def update_data(self, data, content_type=None, size=None):",
            "        if isinstance(data, text_type):",
            "            raise TypeError('Data can only be bytes or file-like.  '",
            "                            'Unicode objects are expressly forbidden.')",
            "",
            "        if size is None:",
            "            size = len(data)",
            "",
            "        self.size = size",
            "        self.data = data",
            "",
            "        ct, width, height = getImageInfo(data)",
            "        if ct:",
            "            content_type = ct",
            "        if width >= 0 and height >= 0:",
            "            self.width = width",
            "            self.height = height",
            "",
            "        # Now we should have the correct content type, or still None",
            "        if content_type is not None:",
            "            self.content_type = content_type",
            "",
            "        self.ZCacheable_invalidate()",
            "        self.ZCacheable_set(None)",
            "        self.http__refreshEtag()",
            "",
            "    def __bytes__(self):",
            "        return self.tag().encode('utf-8')",
            "",
            "    def __str__(self):",
            "        return self.tag()",
            "",
            "    @security.protected(View)",
            "    def tag(",
            "        self,",
            "        height=None,",
            "        width=None,",
            "        alt=None,",
            "        scale=0,",
            "        xscale=0,",
            "        yscale=0,",
            "        css_class=None,",
            "        title=None,",
            "        **args",
            "    ):",
            "        \"\"\"Generate an HTML IMG tag for this image, with customization.",
            "",
            "        Arguments to self.tag() can be any valid attributes of an IMG tag.",
            "        'src' will always be an absolute pathname, to prevent redundant",
            "        downloading of images. Defaults are applied intelligently for",
            "        'height', 'width', and 'alt'. If specified, the 'scale', 'xscale',",
            "        and 'yscale' keyword arguments will be used to automatically adjust",
            "        the output height and width values of the image tag.",
            "        #",
            "        Since 'class' is a Python reserved word, it cannot be passed in",
            "        directly in keyword arguments which is a problem if you are",
            "        trying to use 'tag()' to include a CSS class. The tag() method",
            "        will accept a 'css_class' argument that will be converted to",
            "        'class' in the output tag to work around this.",
            "        \"\"\"",
            "        if height is None:",
            "            height = self.height",
            "        if width is None:",
            "            width = self.width",
            "",
            "        # Auto-scaling support",
            "        xdelta = xscale or scale",
            "        ydelta = yscale or scale",
            "",
            "        if xdelta and width:",
            "            width = str(int(round(int(width) * xdelta)))",
            "        if ydelta and height:",
            "            height = str(int(round(int(height) * ydelta)))",
            "",
            "        result = '<img src=\"%s\"' % (self.absolute_url())",
            "",
            "        if alt is None:",
            "            alt = getattr(self, 'alt', '')",
            "        result = '%s alt=\"%s\"' % (result, escape(alt, True))",
            "",
            "        if title is None:",
            "            title = getattr(self, 'title', '')",
            "        result = '%s title=\"%s\"' % (result, escape(title, True))",
            "",
            "        if height:",
            "            result = '%s height=\"%s\"' % (result, height)",
            "",
            "        if width:",
            "            result = '%s width=\"%s\"' % (result, width)",
            "",
            "        if css_class is not None:",
            "            result = '%s class=\"%s\"' % (result, css_class)",
            "",
            "        for key in list(args.keys()):",
            "            value = args.get(key)",
            "            if value:",
            "                result = '%s %s=\"%s\"' % (result, key, value)",
            "",
            "        return '%s />' % result",
            "",
            "",
            "InitializeClass(Image)",
            "",
            "",
            "def cookId(id, title, file):",
            "    if not id and hasattr(file, 'filename'):",
            "        filename = file.filename",
            "        title = title or filename",
            "        id = filename[max(filename.rfind('/'),",
            "                          filename.rfind('\\\\'),",
            "                          filename.rfind(':'),",
            "                          ) + 1:]",
            "    return id, title",
            "",
            "",
            "class Pdata(Persistent, Implicit):",
            "    # Wrapper for possibly large data",
            "",
            "    next = None",
            "",
            "    def __init__(self, data):",
            "        self.data = data",
            "",
            "    if PY2:",
            "        def __getslice__(self, i, j):",
            "            return self.data[i:j]",
            "",
            "    def __getitem__(self, key):",
            "        return self.data[key]",
            "",
            "    def __len__(self):",
            "        data = bytes(self)",
            "        return len(data)",
            "",
            "    def __bytes__(self):",
            "        _next = self.next",
            "        if _next is None:",
            "            return self.data",
            "",
            "        r = [self.data]",
            "        while _next is not None:",
            "            self = _next",
            "            r.append(self.data)",
            "            _next = self.next",
            "",
            "        return b''.join(r)",
            "",
            "    if PY2:",
            "        __str__ = __bytes__"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/OFS/tests/testFileAndImage.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "         response = request.RESPONSE"
            },
            "1": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "         result = self.file.index_html(request, response)"
            },
            "2": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "         self.assertEqual(result, self.data)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+        self.assertIsNone(response.getHeader(\"Content-Disposition\"))"
            },
            "4": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 372,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "     def test_interfaces(self):"
            },
            "6": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "         from OFS.Image import Image"
            },
            "7": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "                          ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')"
            },
            "8": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 384,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 385,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+class SVGTests(ImageTests):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+    content_type = 'image/svg+xml'"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+    def testViewImageOrFile(self):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+        result = self.file.index_html(request, response)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+        self.assertEqual("
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 395,
                "PatchRowcode": "+            response.getHeader(\"Content-Disposition\"),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+            \"attachment; filename*=UTF-8''file.svg\","
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+        )"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+    def testViewImageOrFileNonAscii(self):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+        try:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+            factory = getattr(self.app, self.factory)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+            factory('h\u00e4llo',"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+                    file=self.data, content_type=self.content_type)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+            transaction.commit()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+        except Exception:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+            transaction.abort()"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+            self.connection.close()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+            raise"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+        transaction.begin()"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        image = getattr(self.app, 'h\u00e4llo')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+        result = image.index_html(request, response)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+        self.assertEqual("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+            response.getHeader(\"Content-Disposition\"),"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+    def testViewImageOrFile_with_denylist(self):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+        self.file.use_denylist = True"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+        result = self.file.index_html(request, response)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+        self.assertEqual("
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+            response.getHeader(\"Content-Disposition\"),"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+            \"attachment; filename*=UTF-8''file.svg\","
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+        )"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 430,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 431,
                "PatchRowcode": "+    def testViewImageOrFile_with_empty_denylist(self):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 432,
                "PatchRowcode": "+        request = self.app.REQUEST"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 433,
                "PatchRowcode": "+        response = request.RESPONSE"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 434,
                "PatchRowcode": "+        self.file.use_denylist = True"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 435,
                "PatchRowcode": "+        self.file.disallowed_inline_mimetypes = []"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 436,
                "PatchRowcode": "+        result = self.file.index_html(request, response)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+        self.assertEqual(result, self.data)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+        self.assertIsNone(response.getHeader(\"Content-Disposition\"))"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 441,
                "PatchRowcode": " class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):"
            },
            "66": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 442,
                "PatchRowcode": "     \"\"\"Browser testing ..Image.File\"\"\""
            },
            "67": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 443,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import os",
            "import sys",
            "import time",
            "import unittest",
            "from io import BytesIO",
            "",
            "import six",
            "from six import PY3",
            "",
            "import OFS.Image",
            "import Testing.testbrowser",
            "import Testing.ZopeTestCase",
            "import transaction",
            "import Zope2",
            "from Acquisition import aq_base",
            "from OFS.Application import Application",
            "from OFS.Cache import ZCM_MANAGERS",
            "from OFS.Image import Pdata",
            "from OFS.SimpleItem import SimpleItem",
            "from Testing.makerequest import makerequest",
            "from zExceptions import Redirect",
            "from zope.component import adapter",
            "from zope.datetime import rfc1123_date",
            "from zope.lifecycleevent.interfaces import IObjectCreatedEvent",
            "from zope.lifecycleevent.interfaces import IObjectModifiedEvent",
            "from ZPublisher.HTTPRequest import HTTPRequest",
            "from ZPublisher.HTTPResponse import HTTPResponse",
            "",
            "",
            "here = os.path.dirname(os.path.abspath(__file__))",
            "filedata = os.path.join(here, 'test.gif')",
            "",
            "Zope2.startup_wsgi()",
            "",
            "",
            "def makeConnection():",
            "    import ZODB",
            "    from ZODB.DemoStorage import DemoStorage",
            "",
            "    s = DemoStorage()",
            "    return ZODB.DB(s).open()",
            "",
            "",
            "def aputrequest(file, content_type):",
            "    resp = HTTPResponse(stdout=sys.stdout)",
            "    environ = {}",
            "    environ['SERVER_NAME'] = 'foo'",
            "    environ['SERVER_PORT'] = '80'",
            "    environ['REQUEST_METHOD'] = 'PUT'",
            "    environ['CONTENT_TYPE'] = content_type",
            "    req = HTTPRequest(stdin=file, environ=environ, response=resp)",
            "    return req",
            "",
            "",
            "class DummyCache(object):",
            "",
            "    def __init__(self):",
            "        self.clear()",
            "",
            "    def ZCache_set(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.set = (ob, data)",
            "",
            "    def ZCache_get(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.get = ob",
            "        if self.si:",
            "            return self.si",
            "",
            "    def ZCache_invalidate(self, ob):",
            "        self.invalidated = ob",
            "",
            "    def clear(self):",
            "        self.set = None",
            "        self.get = None",
            "        self.invalidated = None",
            "        self.si = None",
            "",
            "    def setStreamIterator(self, si):",
            "        self.si = si",
            "",
            "",
            "ADummyCache = DummyCache()",
            "",
            "",
            "class DummyCacheManager(SimpleItem):",
            "    def ZCacheManager_getCache(self):",
            "        return ADummyCache",
            "",
            "",
            "class EventCatcher(object):",
            "",
            "    def __init__(self):",
            "        self.created = []",
            "        self.modified = []",
            "        self.setUp()",
            "",
            "    def setUp(self):",
            "        from zope.component import provideHandler",
            "        provideHandler(self.handleCreated)",
            "        provideHandler(self.handleModified)",
            "",
            "    def tearDown(self):",
            "        from zope.component import getSiteManager",
            "        getSiteManager().unregisterHandler(self.handleCreated)",
            "        getSiteManager().unregisterHandler(self.handleModified)",
            "",
            "    def reset(self):",
            "        self.created = []",
            "        self.modified = []",
            "",
            "    @adapter(IObjectCreatedEvent)",
            "    def handleCreated(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.created.append(event)",
            "",
            "    @adapter(IObjectModifiedEvent)",
            "    def handleModified(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.modified.append(event)",
            "",
            "",
            "class FileTests(unittest.TestCase):",
            "    content_type = 'application/octet-stream'",
            "    factory = 'manage_addFile'",
            "",
            "    def setUp(self):",
            "        with open(filedata, 'rb') as fd:",
            "            self.data = fd.read()",
            "        self.connection = makeConnection()",
            "        self.eventCatcher = EventCatcher()",
            "        try:",
            "            r = self.connection.root()",
            "            a = Application()",
            "            r['Application'] = a",
            "            self.root = a",
            "            responseOut = self.responseOut = BytesIO()",
            "            self.app = makerequest(self.root, stdout=responseOut)",
            "            self.app.dcm = DummyCacheManager()",
            "            factory = getattr(self.app, self.factory)",
            "            factory('file',",
            "                    file=self.data, content_type=self.content_type)",
            "            self.app.file.ZCacheable_setManagerId('dcm')",
            "            self.app.file.ZCacheable_setEnabled(enabled=1)",
            "            setattr(self.app, ZCM_MANAGERS, ('dcm',))",
            "            # Hack, we need a _p_mtime for the file, so we make sure that it",
            "            # has one.",
            "            transaction.commit()",
            "        except Exception:",
            "            transaction.abort()",
            "            self.connection.close()",
            "            raise",
            "        transaction.begin()",
            "        self.file = getattr(self.app, 'file')",
            "",
            "        # Since we do the create here, let's test the events here too",
            "        self.assertEqual(1, len(self.eventCatcher.created))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.eventCatcher.reset()",
            "",
            "    def tearDown(self):",
            "        del self.file",
            "        transaction.abort()",
            "        self.connection.close()",
            "        del self.app",
            "        del self.responseOut",
            "        del self.root",
            "        del self.connection",
            "        ADummyCache.clear()",
            "        self.eventCatcher.tearDown()",
            "",
            "    def testViewImageOrFile(self):",
            "        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(b'foo')",
            "        self.assertEqual(self.file.size, 3)",
            "        self.assertEqual(self.file.data, b'foo')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testReadData(self):",
            "        s = b'a' * (2 << 16)",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertIsInstance(data, Pdata)",
            "        self.assertEqual(bytes(data), s)",
            "        self.assertEqual(len(s), len(bytes(data)))",
            "        self.assertEqual(len(s), size)",
            "",
            "    def testBigPdata(self):",
            "        # Test that a big enough string is split into several Pdata",
            "        # From a file",
            "        s = b'a' * (1 << 16) * 3",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertNotEqual(data.next, None)",
            "        # From a string",
            "        data, size = self.file._read_data(s)",
            "        self.assertNotEqual(data.next, None)",
            "",
            "    def testManageEditWithFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageEditWithoutFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUpload(self):",
            "        f = BytesIO(b'jammyjohnson')",
            "        self.file.manage_upload(f)",
            "        self.assertEqual(self.file.data, b'jammyjohnson')",
            "        self.assertEqual(self.file.content_type, 'application/octet-stream')",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUploadWithoutFileData(self):",
            "        self.file.manage_upload()",
            "        self.assertEqual(0, len(self.eventCatcher.modified))",
            "",
            "    def testIfModSince(self):",
            "        now = time.time()",
            "        e = {'SERVER_NAME': 'foo',",
            "             'SERVER_PORT': '80',",
            "             'REQUEST_METHOD': 'GET'}",
            "",
            "        # not modified since",
            "        t_notmod = rfc1123_date(now)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 304)",
            "        self.assertEqual(data, b'')",
            "",
            "        # modified since",
            "        t_mod = rfc1123_date(now - 100)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_mod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 200)",
            "        self.assertEqual(data, bytes(self.file.data))",
            "",
            "    def testPUT(self):",
            "        s = b'# some python\\n'",
            "",
            "        # with content type",
            "        data = BytesIO(s)",
            "        req = aputrequest(data, 'text/x-python')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "        # without content type",
            "        data.seek(0)",
            "        req = aputrequest(data, '')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "    def testIndexHtmlWithPdata(self):",
            "        self.file.manage_upload(b'a' * (2 << 16))  # 128K",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testIndexHtmlWithString(self):",
            "        self.file.manage_upload(b'a' * 100)  # 100 bytes",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testPrincipiaSearchSource_not_text(self):",
            "        data = ''.join([chr(x) for x in range(256)])",
            "        if PY3:",
            "            data = data.encode('utf-8')",
            "        self.file.manage_edit('foobar', 'application/octet-stream',",
            "                              filedata=data)",
            "        self.assertEqual(self.file.PrincipiaSearchSource(), b'')",
            "",
            "    def testPrincipiaSearchSource_text(self):",
            "        self.file.manage_edit('foobar', 'text/plain',",
            "                              filedata=b'Now is the time for all good men to '",
            "                                       b'come to the aid of the Party.')",
            "        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())",
            "",
            "    def test_manage_DAVget_binary(self):",
            "        self.assertEqual(self.file.manage_DAVget(), self.data)",
            "",
            "    def test_manage_DAVget_text(self):",
            "        text = (b'Now is the time for all good men to '",
            "                b'come to the aid of the Party.')",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=text)",
            "        self.assertEqual(self.file.manage_DAVget(), text)",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import File",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface",
            "",
            "        verifyClass(HTTPRangeInterface, File)",
            "        verifyClass(IWriteLock, File)",
            "",
            "    def testUnicode(self):",
            "        val = u'some unicode string here'",
            "",
            "        self.assertRaises(TypeError, self.file.update_data,",
            "                          data=val, content_type='text/plain')",
            "",
            "    def testStr(self):",
            "        small_data = b'small data'",
            "        self.file.manage_upload(file=small_data)",
            "        self.assertEqual(str(self.file), small_data.decode())",
            "",
            "        # Make sure Pdata contents are handled correctly",
            "        big_data = b'a' * (2 << 16)",
            "        self.file.manage_upload(file=big_data)",
            "        self.assertEqual(str(self.file), big_data.decode())",
            "",
            "",
            "class ImageTests(FileTests):",
            "    content_type = 'image/gif'",
            "    factory = 'manage_addImage'",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(self.data)",
            "        self.assertEqual(self.file.size, len(self.data))",
            "        self.assertEqual(self.file.data, self.data)",
            "        self.assertEqual(self.file.width, 16)",
            "        self.assertEqual(self.file.height, 16)",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testTag(self):",
            "        tag_fmt = ('<img src=\"http://nohost/file\" '",
            "                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))",
            "        self.file.manage_changeProperties(title='foo')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))",
            "        self.file.manage_changeProperties(alt='bar')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))",
            "",
            "    testStr = testTag",
            "",
            "    def testViewImageOrFile(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import Image",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "",
            "        verifyClass(IWriteLock, Image)",
            "",
            "    def test_text_representation_is_tag(self):",
            "        self.assertEqual(six.text_type(self.file),",
            "                         '<img src=\"http://nohost/file\"'",
            "                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')",
            "",
            "",
            "class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):",
            "    \"\"\"Browser testing ..Image.File\"\"\"",
            "",
            "    def setUp(self):",
            "        super(FileEditTests, self).setUp()",
            "        uf = self.app.acl_users",
            "        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])",
            "        self.app.manage_addFile('file')",
            "",
            "        transaction.commit()",
            "        self.browser = Testing.testbrowser.Browser()",
            "        self.browser.login('manager', 'manager_pass')",
            "",
            "    def test_Image__manage_main__1(self):",
            "        \"\"\"It shows the content of text files as text.\"\"\"",
            "        self.app.file.update_data(u'h\u00e4llo'.encode('utf-8'))",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'h\u00e4llo')",
            "",
            "    @unittest.skipIf(six.PY2, \"feature not supported on Python 2\")",
            "    def test_Image__manage_main__3(self):",
            "        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"",
            "        self.app.file.update_data(u'h\u00e4llo'.encode('latin-1'))",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.assertIn(",
            "            \"The file could not be decoded with 'utf-8'.\",",
            "            self.browser.contents)",
            "",
            "    def test_Image__manage_upload__1(self):",
            "        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.browser.getControl(name='file').add_file(",
            "            b'test text file', 'text/plain', 'TestFile.txt')",
            "        self.browser.getControl('Upload File').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        self.assertEqual(",
            "            self.browser.getControl('Content Type').value, 'text/plain')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'test text file')",
            "",
            "    def test_Image__manage_edit__1(self):",
            "        \"\"\"It it possible to change the file's content via browser.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text_1 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_1, '')",
            "        self.browser.getControl(name='filedata:text').value = u'h\u00e4llo'",
            "        self.browser.getControl('Save Changes').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        text_2 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_2, 'h\u00e4llo')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import os",
            "import sys",
            "import time",
            "import unittest",
            "from io import BytesIO",
            "",
            "import six",
            "from six import PY3",
            "",
            "import OFS.Image",
            "import Testing.testbrowser",
            "import Testing.ZopeTestCase",
            "import transaction",
            "import Zope2",
            "from Acquisition import aq_base",
            "from OFS.Application import Application",
            "from OFS.Cache import ZCM_MANAGERS",
            "from OFS.Image import Pdata",
            "from OFS.SimpleItem import SimpleItem",
            "from Testing.makerequest import makerequest",
            "from zExceptions import Redirect",
            "from zope.component import adapter",
            "from zope.datetime import rfc1123_date",
            "from zope.lifecycleevent.interfaces import IObjectCreatedEvent",
            "from zope.lifecycleevent.interfaces import IObjectModifiedEvent",
            "from ZPublisher.HTTPRequest import HTTPRequest",
            "from ZPublisher.HTTPResponse import HTTPResponse",
            "",
            "",
            "here = os.path.dirname(os.path.abspath(__file__))",
            "filedata = os.path.join(here, 'test.gif')",
            "",
            "Zope2.startup_wsgi()",
            "",
            "",
            "def makeConnection():",
            "    import ZODB",
            "    from ZODB.DemoStorage import DemoStorage",
            "",
            "    s = DemoStorage()",
            "    return ZODB.DB(s).open()",
            "",
            "",
            "def aputrequest(file, content_type):",
            "    resp = HTTPResponse(stdout=sys.stdout)",
            "    environ = {}",
            "    environ['SERVER_NAME'] = 'foo'",
            "    environ['SERVER_PORT'] = '80'",
            "    environ['REQUEST_METHOD'] = 'PUT'",
            "    environ['CONTENT_TYPE'] = content_type",
            "    req = HTTPRequest(stdin=file, environ=environ, response=resp)",
            "    return req",
            "",
            "",
            "class DummyCache(object):",
            "",
            "    def __init__(self):",
            "        self.clear()",
            "",
            "    def ZCache_set(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.set = (ob, data)",
            "",
            "    def ZCache_get(self, ob, data, view_name='', keywords=None,",
            "                   mtime_func=None):",
            "        self.get = ob",
            "        if self.si:",
            "            return self.si",
            "",
            "    def ZCache_invalidate(self, ob):",
            "        self.invalidated = ob",
            "",
            "    def clear(self):",
            "        self.set = None",
            "        self.get = None",
            "        self.invalidated = None",
            "        self.si = None",
            "",
            "    def setStreamIterator(self, si):",
            "        self.si = si",
            "",
            "",
            "ADummyCache = DummyCache()",
            "",
            "",
            "class DummyCacheManager(SimpleItem):",
            "    def ZCacheManager_getCache(self):",
            "        return ADummyCache",
            "",
            "",
            "class EventCatcher(object):",
            "",
            "    def __init__(self):",
            "        self.created = []",
            "        self.modified = []",
            "        self.setUp()",
            "",
            "    def setUp(self):",
            "        from zope.component import provideHandler",
            "        provideHandler(self.handleCreated)",
            "        provideHandler(self.handleModified)",
            "",
            "    def tearDown(self):",
            "        from zope.component import getSiteManager",
            "        getSiteManager().unregisterHandler(self.handleCreated)",
            "        getSiteManager().unregisterHandler(self.handleModified)",
            "",
            "    def reset(self):",
            "        self.created = []",
            "        self.modified = []",
            "",
            "    @adapter(IObjectCreatedEvent)",
            "    def handleCreated(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.created.append(event)",
            "",
            "    @adapter(IObjectModifiedEvent)",
            "    def handleModified(self, event):",
            "        if isinstance(event.object, OFS.Image.File):",
            "            self.modified.append(event)",
            "",
            "",
            "class FileTests(unittest.TestCase):",
            "    content_type = 'application/octet-stream'",
            "    factory = 'manage_addFile'",
            "",
            "    def setUp(self):",
            "        with open(filedata, 'rb') as fd:",
            "            self.data = fd.read()",
            "        self.connection = makeConnection()",
            "        self.eventCatcher = EventCatcher()",
            "        try:",
            "            r = self.connection.root()",
            "            a = Application()",
            "            r['Application'] = a",
            "            self.root = a",
            "            responseOut = self.responseOut = BytesIO()",
            "            self.app = makerequest(self.root, stdout=responseOut)",
            "            self.app.dcm = DummyCacheManager()",
            "            factory = getattr(self.app, self.factory)",
            "            factory('file',",
            "                    file=self.data, content_type=self.content_type)",
            "            self.app.file.ZCacheable_setManagerId('dcm')",
            "            self.app.file.ZCacheable_setEnabled(enabled=1)",
            "            setattr(self.app, ZCM_MANAGERS, ('dcm',))",
            "            # Hack, we need a _p_mtime for the file, so we make sure that it",
            "            # has one.",
            "            transaction.commit()",
            "        except Exception:",
            "            transaction.abort()",
            "            self.connection.close()",
            "            raise",
            "        transaction.begin()",
            "        self.file = getattr(self.app, 'file')",
            "",
            "        # Since we do the create here, let's test the events here too",
            "        self.assertEqual(1, len(self.eventCatcher.created))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(",
            "            aq_base(self.eventCatcher.created[0].object) is aq_base(self.file))",
            "",
            "        self.eventCatcher.reset()",
            "",
            "    def tearDown(self):",
            "        del self.file",
            "        transaction.abort()",
            "        self.connection.close()",
            "        del self.app",
            "        del self.responseOut",
            "        del self.root",
            "        del self.connection",
            "        ADummyCache.clear()",
            "        self.eventCatcher.tearDown()",
            "",
            "    def testViewImageOrFile(self):",
            "        self.assertRaises(Redirect, self.file.view_image_or_file, 'foo')",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(b'foo')",
            "        self.assertEqual(self.file.size, 3)",
            "        self.assertEqual(self.file.data, b'foo')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testReadData(self):",
            "        s = b'a' * (2 << 16)",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertIsInstance(data, Pdata)",
            "        self.assertEqual(bytes(data), s)",
            "        self.assertEqual(len(s), len(bytes(data)))",
            "        self.assertEqual(len(s), size)",
            "",
            "    def testBigPdata(self):",
            "        # Test that a big enough string is split into several Pdata",
            "        # From a file",
            "        s = b'a' * (1 << 16) * 3",
            "        data, size = self.file._read_data(BytesIO(s))",
            "        self.assertNotEqual(data.next, None)",
            "        # From a string",
            "        data, size = self.file._read_data(s)",
            "        self.assertNotEqual(data.next, None)",
            "",
            "    def testManageEditWithFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=b'ASD')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageEditWithoutFileData(self):",
            "        self.file.manage_edit('foobar', 'text/plain')",
            "        self.assertEqual(self.file.title, 'foobar')",
            "        self.assertEqual(self.file.content_type, 'text/plain')",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUpload(self):",
            "        f = BytesIO(b'jammyjohnson')",
            "        self.file.manage_upload(f)",
            "        self.assertEqual(self.file.data, b'jammyjohnson')",
            "        self.assertEqual(self.file.content_type, 'application/octet-stream')",
            "        self.assertEqual(1, len(self.eventCatcher.modified))",
            "        self.assertTrue(self.eventCatcher.modified[0].object is self.file)",
            "",
            "    def testManageUploadWithoutFileData(self):",
            "        self.file.manage_upload()",
            "        self.assertEqual(0, len(self.eventCatcher.modified))",
            "",
            "    def testIfModSince(self):",
            "        now = time.time()",
            "        e = {'SERVER_NAME': 'foo',",
            "             'SERVER_PORT': '80',",
            "             'REQUEST_METHOD': 'GET'}",
            "",
            "        # not modified since",
            "        t_notmod = rfc1123_date(now)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_notmod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 304)",
            "        self.assertEqual(data, b'')",
            "",
            "        # modified since",
            "        t_mod = rfc1123_date(now - 100)",
            "        e['HTTP_IF_MODIFIED_SINCE'] = t_mod",
            "        out = BytesIO()",
            "        resp = HTTPResponse(stdout=out)",
            "        req = HTTPRequest(sys.stdin, e, resp)",
            "        data = self.file.index_html(req, resp)",
            "        self.assertEqual(resp.getStatus(), 200)",
            "        self.assertEqual(data, bytes(self.file.data))",
            "",
            "    def testPUT(self):",
            "        s = b'# some python\\n'",
            "",
            "        # with content type",
            "        data = BytesIO(s)",
            "        req = aputrequest(data, 'text/x-python')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "        # without content type",
            "        data.seek(0)",
            "        req = aputrequest(data, '')",
            "        req.processInputs()",
            "        self.file.PUT(req, req.RESPONSE)",
            "",
            "        self.assertEqual(self.file.content_type, 'text/x-python')",
            "        self.assertEqual(self.file.data, s)",
            "",
            "    def testIndexHtmlWithPdata(self):",
            "        self.file.manage_upload(b'a' * (2 << 16))  # 128K",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testIndexHtmlWithString(self):",
            "        self.file.manage_upload(b'a' * 100)  # 100 bytes",
            "        self.file.index_html(self.app.REQUEST, self.app.REQUEST.RESPONSE)",
            "        self.assertTrue(not self.app.REQUEST.RESPONSE._wrote)",
            "",
            "    def testPrincipiaSearchSource_not_text(self):",
            "        data = ''.join([chr(x) for x in range(256)])",
            "        if PY3:",
            "            data = data.encode('utf-8')",
            "        self.file.manage_edit('foobar', 'application/octet-stream',",
            "                              filedata=data)",
            "        self.assertEqual(self.file.PrincipiaSearchSource(), b'')",
            "",
            "    def testPrincipiaSearchSource_text(self):",
            "        self.file.manage_edit('foobar', 'text/plain',",
            "                              filedata=b'Now is the time for all good men to '",
            "                                       b'come to the aid of the Party.')",
            "        self.assertTrue(b'Party' in self.file.PrincipiaSearchSource())",
            "",
            "    def test_manage_DAVget_binary(self):",
            "        self.assertEqual(self.file.manage_DAVget(), self.data)",
            "",
            "    def test_manage_DAVget_text(self):",
            "        text = (b'Now is the time for all good men to '",
            "                b'come to the aid of the Party.')",
            "        self.file.manage_edit('foobar', 'text/plain', filedata=text)",
            "        self.assertEqual(self.file.manage_DAVget(), text)",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import File",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "        from ZPublisher.HTTPRangeSupport import HTTPRangeInterface",
            "",
            "        verifyClass(HTTPRangeInterface, File)",
            "        verifyClass(IWriteLock, File)",
            "",
            "    def testUnicode(self):",
            "        val = u'some unicode string here'",
            "",
            "        self.assertRaises(TypeError, self.file.update_data,",
            "                          data=val, content_type='text/plain')",
            "",
            "    def testStr(self):",
            "        small_data = b'small data'",
            "        self.file.manage_upload(file=small_data)",
            "        self.assertEqual(str(self.file), small_data.decode())",
            "",
            "        # Make sure Pdata contents are handled correctly",
            "        big_data = b'a' * (2 << 16)",
            "        self.file.manage_upload(file=big_data)",
            "        self.assertEqual(str(self.file), big_data.decode())",
            "",
            "",
            "class ImageTests(FileTests):",
            "    content_type = 'image/gif'",
            "    factory = 'manage_addImage'",
            "",
            "    def testUpdateData(self):",
            "        self.file.update_data(self.data)",
            "        self.assertEqual(self.file.size, len(self.data))",
            "        self.assertEqual(self.file.data, self.data)",
            "        self.assertEqual(self.file.width, 16)",
            "        self.assertEqual(self.file.height, 16)",
            "        self.assertTrue(ADummyCache.invalidated)",
            "        self.assertTrue(ADummyCache.set)",
            "",
            "    def testTag(self):",
            "        tag_fmt = ('<img src=\"http://nohost/file\" '",
            "                   'alt=\"%s\" title=\"%s\" height=\"16\" width=\"16\" />')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', '')))",
            "        self.file.manage_changeProperties(title='foo')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('', 'foo')))",
            "        self.file.manage_changeProperties(alt='bar')",
            "        self.assertEqual(self.file.tag(), (tag_fmt % ('bar', 'foo')))",
            "",
            "    testStr = testTag",
            "",
            "    def testViewImageOrFile(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertIsNone(response.getHeader(\"Content-Disposition\"))",
            "",
            "    def test_interfaces(self):",
            "        from OFS.Image import Image",
            "        from OFS.interfaces import IWriteLock",
            "        from zope.interface.verify import verifyClass",
            "",
            "        verifyClass(IWriteLock, Image)",
            "",
            "    def test_text_representation_is_tag(self):",
            "        self.assertEqual(six.text_type(self.file),",
            "                         '<img src=\"http://nohost/file\"'",
            "                         ' alt=\"\" title=\"\" height=\"16\" width=\"16\" />')",
            "",
            "",
            "class SVGTests(ImageTests):",
            "    content_type = 'image/svg+xml'",
            "",
            "    def testViewImageOrFile(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertEqual(",
            "            response.getHeader(\"Content-Disposition\"),",
            "            \"attachment; filename*=UTF-8''file.svg\",",
            "        )",
            "",
            "    def testViewImageOrFileNonAscii(self):",
            "        try:",
            "            factory = getattr(self.app, self.factory)",
            "            factory('h\u00e4llo',",
            "                    file=self.data, content_type=self.content_type)",
            "            transaction.commit()",
            "        except Exception:",
            "            transaction.abort()",
            "            self.connection.close()",
            "            raise",
            "        transaction.begin()",
            "        image = getattr(self.app, 'h\u00e4llo')",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        result = image.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertEqual(",
            "            response.getHeader(\"Content-Disposition\"),",
            "            \"attachment; filename*=UTF-8''h%C3%A4llo.svg\",",
            "        )",
            "",
            "    def testViewImageOrFile_with_denylist(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        self.file.use_denylist = True",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertEqual(",
            "            response.getHeader(\"Content-Disposition\"),",
            "            \"attachment; filename*=UTF-8''file.svg\",",
            "        )",
            "",
            "    def testViewImageOrFile_with_empty_denylist(self):",
            "        request = self.app.REQUEST",
            "        response = request.RESPONSE",
            "        self.file.use_denylist = True",
            "        self.file.disallowed_inline_mimetypes = []",
            "        result = self.file.index_html(request, response)",
            "        self.assertEqual(result, self.data)",
            "        self.assertIsNone(response.getHeader(\"Content-Disposition\"))",
            "",
            "",
            "class FileEditTests(Testing.ZopeTestCase.FunctionalTestCase):",
            "    \"\"\"Browser testing ..Image.File\"\"\"",
            "",
            "    def setUp(self):",
            "        super(FileEditTests, self).setUp()",
            "        uf = self.app.acl_users",
            "        uf.userFolderAddUser('manager', 'manager_pass', ['Manager'], [])",
            "        self.app.manage_addFile('file')",
            "",
            "        transaction.commit()",
            "        self.browser = Testing.testbrowser.Browser()",
            "        self.browser.login('manager', 'manager_pass')",
            "",
            "    def test_Image__manage_main__1(self):",
            "        \"\"\"It shows the content of text files as text.\"\"\"",
            "        self.app.file.update_data(u'h\u00e4llo'.encode('utf-8'))",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'h\u00e4llo')",
            "",
            "    @unittest.skipIf(six.PY2, \"feature not supported on Python 2\")",
            "    def test_Image__manage_main__3(self):",
            "        \"\"\"It shows an error message if the file content cannot be decoded.\"\"\"",
            "        self.app.file.update_data(u'h\u00e4llo'.encode('latin-1'))",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.assertIn(",
            "            \"The file could not be decoded with 'utf-8'.\",",
            "            self.browser.contents)",
            "",
            "    def test_Image__manage_upload__1(self):",
            "        \"\"\"It uploads a file, replaces the content and sets content type.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        self.browser.getControl(name='file').add_file(",
            "            b'test text file', 'text/plain', 'TestFile.txt')",
            "        self.browser.getControl('Upload File').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        self.assertEqual(",
            "            self.browser.getControl('Content Type').value, 'text/plain')",
            "        text = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text, 'test text file')",
            "",
            "    def test_Image__manage_edit__1(self):",
            "        \"\"\"It it possible to change the file's content via browser.\"\"\"",
            "        self.browser.open('http://localhost/file/manage_main')",
            "        text_1 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_1, '')",
            "        self.browser.getControl(name='filedata:text').value = u'h\u00e4llo'",
            "        self.browser.getControl('Save Changes').click()",
            "        self.assertIn('Saved changes', self.browser.contents)",
            "        text_2 = self.browser.getControl(name='filedata:text').value",
            "        self.assertEqual(text_2, 'h\u00e4llo')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures"
        ]
    }
}