{
    "salt/fileclient.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 787,
                "afterPatchRowNumber": 787,
                "PatchRowcode": "         if not fnd_path:"
            },
            "1": {
                "beforePatchRowNumber": 788,
                "afterPatchRowNumber": 788,
                "PatchRowcode": "             return ''"
            },
            "2": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": 789,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "4": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            fnd_mode = fnd.get('stat', [])[0]"
            },
            "5": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except (IndexError, TypeError):"
            },
            "6": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            fnd_mode = None"
            },
            "7": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "8": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not salt.utils.is_windows():"
            },
            "9": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if fnd_mode is not None:"
            },
            "10": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "11": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if os.stat(dest).st_mode != fnd_mode:"
            },
            "12": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        try:"
            },
            "13": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            os.chmod(dest, fnd_mode)"
            },
            "14": {
                "beforePatchRowNumber": 801,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        except OSError as exc:"
            },
            "15": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            log.warning('Failed to chmod %s: %s', dest, exc)"
            },
            "16": {
                "beforePatchRowNumber": 803,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except Exception:"
            },
            "17": {
                "beforePatchRowNumber": 804,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    pass"
            },
            "18": {
                "beforePatchRowNumber": 805,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "19": {
                "beforePatchRowNumber": 806,
                "afterPatchRowNumber": 790,
                "PatchRowcode": "         return fnd_path"
            },
            "20": {
                "beforePatchRowNumber": 807,
                "afterPatchRowNumber": 791,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 808,
                "afterPatchRowNumber": 792,
                "PatchRowcode": "     def file_list(self, saltenv='base', prefix=''):"
            },
            "22": {
                "beforePatchRowNumber": 1054,
                "afterPatchRowNumber": 1038,
                "PatchRowcode": "                 mode_local = None"
            },
            "23": {
                "beforePatchRowNumber": 1055,
                "afterPatchRowNumber": 1039,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 1056,
                "afterPatchRowNumber": 1040,
                "PatchRowcode": "             if hash_local == hash_server:"
            },
            "25": {
                "beforePatchRowNumber": 1057,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if not salt.utils.is_windows():"
            },
            "26": {
                "beforePatchRowNumber": 1058,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if mode_server is None:"
            },
            "27": {
                "beforePatchRowNumber": 1059,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        log.debug('No file mode available for \\'%s\\'', path)"
            },
            "28": {
                "beforePatchRowNumber": 1060,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    elif mode_local is None:"
            },
            "29": {
                "beforePatchRowNumber": 1061,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        log.debug("
            },
            "30": {
                "beforePatchRowNumber": 1062,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            'No file mode available for \\'%s\\'',"
            },
            "31": {
                "beforePatchRowNumber": 1063,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            dest2check"
            },
            "32": {
                "beforePatchRowNumber": 1064,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        )"
            },
            "33": {
                "beforePatchRowNumber": 1065,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else:"
            },
            "34": {
                "beforePatchRowNumber": 1066,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        if mode_server == mode_local:"
            },
            "35": {
                "beforePatchRowNumber": 1067,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            log.info("
            },
            "36": {
                "beforePatchRowNumber": 1068,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                'Fetching file from saltenv \\'%s\\', '"
            },
            "37": {
                "beforePatchRowNumber": 1069,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                '** skipped ** latest already in cache '"
            },
            "38": {
                "beforePatchRowNumber": 1070,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                '\\'%s\\', mode up-to-date', saltenv, path"
            },
            "39": {
                "beforePatchRowNumber": 1071,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            )"
            },
            "40": {
                "beforePatchRowNumber": 1072,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        else:"
            },
            "41": {
                "beforePatchRowNumber": 1073,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            try:"
            },
            "42": {
                "beforePatchRowNumber": 1074,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                os.chmod(dest2check, mode_server)"
            },
            "43": {
                "beforePatchRowNumber": 1075,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                log.info("
            },
            "44": {
                "beforePatchRowNumber": 1076,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    'Fetching file from saltenv \\'%s\\', '"
            },
            "45": {
                "beforePatchRowNumber": 1077,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    '** updated ** latest already in cache, '"
            },
            "46": {
                "beforePatchRowNumber": 1078,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    '\\'%s\\', mode updated from %s to %s',"
            },
            "47": {
                "beforePatchRowNumber": 1079,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    saltenv,"
            },
            "48": {
                "beforePatchRowNumber": 1080,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    path,"
            },
            "49": {
                "beforePatchRowNumber": 1081,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    salt.utils.st_mode_to_octal(mode_local),"
            },
            "50": {
                "beforePatchRowNumber": 1082,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    salt.utils.st_mode_to_octal(mode_server)"
            },
            "51": {
                "beforePatchRowNumber": 1083,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                )"
            },
            "52": {
                "beforePatchRowNumber": 1084,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            except OSError as exc:"
            },
            "53": {
                "beforePatchRowNumber": 1085,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                log.warning("
            },
            "54": {
                "beforePatchRowNumber": 1086,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    'Failed to chmod %s: %s', dest2check, exc"
            },
            "55": {
                "beforePatchRowNumber": 1087,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                )"
            },
            "56": {
                "beforePatchRowNumber": 1088,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # We may not have been able to check/set the mode, but we"
            },
            "57": {
                "beforePatchRowNumber": 1089,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # don't want to re-download the file because of a failure"
            },
            "58": {
                "beforePatchRowNumber": 1090,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # in mode checking. Return the cached path."
            },
            "59": {
                "beforePatchRowNumber": 1091,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return dest2check"
            },
            "60": {
                "beforePatchRowNumber": 1092,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "61": {
                "beforePatchRowNumber": 1093,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    log.info("
            },
            "62": {
                "beforePatchRowNumber": 1094,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        'Fetching file from saltenv \\'%s\\', ** skipped ** '"
            },
            "63": {
                "beforePatchRowNumber": 1095,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        'latest already in cache \\'%s\\'', saltenv, path"
            },
            "64": {
                "beforePatchRowNumber": 1096,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "65": {
                "beforePatchRowNumber": 1097,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return dest2check"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1041,
                "PatchRowcode": "+                return dest2check"
            },
            "67": {
                "beforePatchRowNumber": 1098,
                "afterPatchRowNumber": 1042,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 1099,
                "afterPatchRowNumber": 1043,
                "PatchRowcode": "         log.debug("
            },
            "69": {
                "beforePatchRowNumber": 1100,
                "afterPatchRowNumber": 1044,
                "PatchRowcode": "             'Fetching file from saltenv \\'%s\\', ** attempting ** \\'%s\\'',"
            },
            "70": {
                "beforePatchRowNumber": 1211,
                "afterPatchRowNumber": 1155,
                "PatchRowcode": "                 saltenv, path"
            },
            "71": {
                "beforePatchRowNumber": 1212,
                "afterPatchRowNumber": 1156,
                "PatchRowcode": "             )"
            },
            "72": {
                "beforePatchRowNumber": 1213,
                "afterPatchRowNumber": 1157,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 1214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not salt.utils.is_windows():"
            },
            "74": {
                "beforePatchRowNumber": 1215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if mode_server is not None:"
            },
            "75": {
                "beforePatchRowNumber": 1216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "76": {
                "beforePatchRowNumber": 1217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if os.stat(dest).st_mode != mode_server:"
            },
            "77": {
                "beforePatchRowNumber": 1218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        try:"
            },
            "78": {
                "beforePatchRowNumber": 1219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            os.chmod(dest, mode_server)"
            },
            "79": {
                "beforePatchRowNumber": 1220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            log.info("
            },
            "80": {
                "beforePatchRowNumber": 1221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                'Fetching file from saltenv \\'%s\\', '"
            },
            "81": {
                "beforePatchRowNumber": 1222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                '** done ** \\'%s\\', mode set to %s',"
            },
            "82": {
                "beforePatchRowNumber": 1223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                saltenv,"
            },
            "83": {
                "beforePatchRowNumber": 1224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                path,"
            },
            "84": {
                "beforePatchRowNumber": 1225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                salt.utils.st_mode_to_octal(mode_server)"
            },
            "85": {
                "beforePatchRowNumber": 1226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            )"
            },
            "86": {
                "beforePatchRowNumber": 1227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        except OSError:"
            },
            "87": {
                "beforePatchRowNumber": 1228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            log.warning('Failed to chmod %s: %s', dest, exc)"
            },
            "88": {
                "beforePatchRowNumber": 1229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except OSError:"
            },
            "89": {
                "beforePatchRowNumber": 1230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    pass"
            },
            "90": {
                "beforePatchRowNumber": 1231,
                "afterPatchRowNumber": 1158,
                "PatchRowcode": "         return dest"
            },
            "91": {
                "beforePatchRowNumber": 1232,
                "afterPatchRowNumber": 1159,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 1233,
                "afterPatchRowNumber": 1160,
                "PatchRowcode": "     def file_list(self, saltenv='base', prefix=''):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Classes that manage file clients",
            "'''",
            "from __future__ import absolute_import",
            "",
            "# Import python libs",
            "import contextlib",
            "import errno",
            "import logging",
            "import os",
            "import string",
            "import shutil",
            "import ftplib",
            "from tornado.httputil import parse_response_start_line, HTTPInputError",
            "",
            "# Import salt libs",
            "from salt.exceptions import (",
            "    CommandExecutionError, MinionError",
            ")",
            "import salt.client",
            "import salt.crypt",
            "import salt.loader",
            "import salt.payload",
            "import salt.transport",
            "import salt.fileserver",
            "import salt.utils",
            "import salt.utils.files",
            "import salt.utils.templates",
            "import salt.utils.url",
            "import salt.utils.gzip_util",
            "import salt.utils.http",
            "import salt.ext.six as six",
            "from salt.utils.locales import sdecode",
            "from salt.utils.openstack.swift import SaltSwift",
            "",
            "# pylint: disable=no-name-in-module,import-error",
            "import salt.ext.six.moves.BaseHTTPServer as BaseHTTPServer",
            "from salt.ext.six.moves.urllib.error import HTTPError, URLError",
            "from salt.ext.six.moves.urllib.parse import urlparse, urlunparse",
            "# pylint: enable=no-name-in-module,import-error",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def get_file_client(opts, pillar=False):",
            "    '''",
            "    Read in the ``file_client`` option and return the correct type of file",
            "    server",
            "    '''",
            "    client = opts.get('file_client', 'remote')",
            "    if pillar and client == 'local':",
            "        client = 'pillar'",
            "    return {",
            "        'remote': RemoteClient,",
            "        'local': FSClient,",
            "        'pillar': LocalClient,",
            "    }.get(client, RemoteClient)(opts)",
            "",
            "",
            "def decode_dict_keys_to_str(src):",
            "    '''",
            "    Convert top level keys from bytes to strings if possible.",
            "    This is necessary because Python 3 makes a distinction",
            "    between these types.",
            "    '''",
            "    if not six.PY3 or not isinstance(src, dict):",
            "        return src",
            "",
            "    output = {}",
            "    for key, val in six.iteritems(src):",
            "        if isinstance(key, bytes):",
            "            try:",
            "                key = key.decode()",
            "            except UnicodeError:",
            "                pass",
            "        output[key] = val",
            "    return output",
            "",
            "",
            "class Client(object):",
            "    '''",
            "    Base class for Salt file interactions",
            "    '''",
            "    def __init__(self, opts):",
            "        self.opts = opts",
            "        self.utils = salt.loader.utils(self.opts)",
            "        self.serial = salt.payload.Serial(self.opts)",
            "",
            "    # Add __setstate__ and __getstate__ so that the object may be",
            "    # deep copied. It normally can't be deep copied because its",
            "    # constructor requires an 'opts' parameter.",
            "    # The TCP transport needs to be able to deep copy this class",
            "    # due to 'salt.utils.context.ContextDict.clone'.",
            "    def __setstate__(self, state):",
            "        # This will polymorphically call __init__",
            "        # in the derived class.",
            "        self.__init__(state['opts'])",
            "",
            "    def __getstate__(self):",
            "        return {'opts': self.opts}",
            "",
            "    def _check_proto(self, path):",
            "        '''",
            "        Make sure that this path is intended for the salt master and trim it",
            "        '''",
            "        if not path.startswith('salt://'):",
            "            raise MinionError(u'Unsupported path: {0}'.format(path))",
            "        file_path, saltenv = salt.utils.url.parse(path)",
            "        return file_path",
            "",
            "    def _file_local_list(self, dest):",
            "        '''",
            "        Helper util to return a list of files in a directory",
            "        '''",
            "        if os.path.isdir(dest):",
            "            destdir = dest",
            "        else:",
            "            destdir = os.path.dirname(dest)",
            "",
            "        filelist = set()",
            "",
            "        for root, dirs, files in os.walk(destdir, followlinks=True):",
            "            for name in files:",
            "                path = os.path.join(root, name)",
            "                filelist.add(path)",
            "",
            "        return filelist",
            "",
            "    @contextlib.contextmanager",
            "    def _cache_loc(self, path, saltenv='base', cachedir=None):",
            "        '''",
            "        Return the local location to cache the file, cache dirs will be made",
            "        '''",
            "        if cachedir is None:",
            "            cachedir = self.opts['cachedir']",
            "        elif not os.path.isabs(cachedir):",
            "            cachedir = os.path.join(self.opts['cachedir'], cachedir)",
            "",
            "        dest = salt.utils.path_join(cachedir,",
            "                                    'files',",
            "                                    saltenv,",
            "                                    path)",
            "        destdir = os.path.dirname(dest)",
            "        cumask = os.umask(63)",
            "",
            "        # remove destdir if it is a regular file to avoid an OSError when",
            "        # running os.makedirs below",
            "        if os.path.isfile(destdir):",
            "            os.remove(destdir)",
            "",
            "        # ensure destdir exists",
            "        try:",
            "            os.makedirs(destdir)",
            "        except OSError as exc:",
            "            if exc.errno != errno.EEXIST:  # ignore if it was there already",
            "                raise",
            "",
            "        yield dest",
            "        os.umask(cumask)",
            "",
            "    def get_file(self,",
            "                 path,",
            "                 dest='',",
            "                 makedirs=False,",
            "                 saltenv='base',",
            "                 gzip=None,",
            "                 cachedir=None):",
            "        '''",
            "        Copies a file from the local files or master depending on",
            "        implementation",
            "        '''",
            "        raise NotImplementedError",
            "",
            "    def file_list_emptydirs(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the empty dirs",
            "        '''",
            "        raise NotImplementedError",
            "",
            "    def cache_file(self, path, saltenv='base', cachedir=None):",
            "        '''",
            "        Pull a file down from the file server and store it in the minion",
            "        file cache",
            "        '''",
            "        return self.get_url(path, '', True, saltenv, cachedir=cachedir)",
            "",
            "    def cache_files(self, paths, saltenv='base', cachedir=None):",
            "        '''",
            "        Download a list of files stored on the master and put them in the",
            "        minion file cache",
            "        '''",
            "        ret = []",
            "        if isinstance(paths, str):",
            "            paths = paths.split(',')",
            "        for path in paths:",
            "            ret.append(self.cache_file(path, saltenv, cachedir=cachedir))",
            "        return ret",
            "",
            "    def cache_master(self, saltenv='base', cachedir=None):",
            "        '''",
            "        Download and cache all files on a master in a specified environment",
            "        '''",
            "        ret = []",
            "        for path in self.file_list(saltenv):",
            "            ret.append(",
            "                self.cache_file(",
            "                    salt.utils.url.create(path), saltenv, cachedir=cachedir)",
            "            )",
            "        return ret",
            "",
            "    def cache_dir(self, path, saltenv='base', include_empty=False,",
            "                  include_pat=None, exclude_pat=None, cachedir=None):",
            "        '''",
            "        Download all of the files in a subdir of the master",
            "        '''",
            "        ret = []",
            "",
            "        path = self._check_proto(sdecode(path))",
            "        # We want to make sure files start with this *directory*, use",
            "        # '/' explicitly because the master (that's generating the",
            "        # list of files) only runs on POSIX",
            "        if not path.endswith('/'):",
            "            path = path + '/'",
            "",
            "        log.info(",
            "            'Caching directory \\'{0}\\' for environment \\'{1}\\''.format(",
            "                path, saltenv",
            "            )",
            "        )",
            "        # go through the list of all files finding ones that are in",
            "        # the target directory and caching them",
            "        for fn_ in self.file_list(saltenv):",
            "            fn_ = sdecode(fn_)",
            "            if fn_.strip() and fn_.startswith(path):",
            "                if salt.utils.check_include_exclude(",
            "                        fn_, include_pat, exclude_pat):",
            "                    fn_ = self.cache_file(",
            "                        salt.utils.url.create(fn_), saltenv, cachedir=cachedir)",
            "                    if fn_:",
            "                        ret.append(fn_)",
            "",
            "        if include_empty:",
            "            # Break up the path into a list containing the bottom-level",
            "            # directory (the one being recursively copied) and the directories",
            "            # preceding it",
            "            # separated = string.rsplit(path, '/', 1)",
            "            # if len(separated) != 2:",
            "            #     # No slashes in path. (So all files in saltenv will be copied)",
            "            #     prefix = ''",
            "            # else:",
            "            #     prefix = separated[0]",
            "            if cachedir is None:",
            "                cachedir = self.opts['cachedir']",
            "            elif not os.path.isabs(cachedir):",
            "                cachedir = os.path.join(self.opts['cachedir'], cachedir)",
            "",
            "            dest = salt.utils.path_join(cachedir, 'files', saltenv)",
            "            for fn_ in self.file_list_emptydirs(saltenv):",
            "                fn_ = sdecode(fn_)",
            "                if fn_.startswith(path):",
            "                    minion_dir = '{0}/{1}'.format(dest, fn_)",
            "                    if not os.path.isdir(minion_dir):",
            "                        os.makedirs(minion_dir)",
            "                    ret.append(minion_dir)",
            "        return ret",
            "",
            "    def cache_local_file(self, path, **kwargs):",
            "        '''",
            "        Cache a local file on the minion in the localfiles cache",
            "        '''",
            "        dest = os.path.join(self.opts['cachedir'], 'localfiles',",
            "                            path.lstrip('/'))",
            "        destdir = os.path.dirname(dest)",
            "",
            "        if not os.path.isdir(destdir):",
            "            os.makedirs(destdir)",
            "",
            "        shutil.copyfile(path, dest)",
            "        return dest",
            "",
            "    def file_local_list(self, saltenv='base'):",
            "        '''",
            "        List files in the local minion files and localfiles caches",
            "        '''",
            "        filesdest = os.path.join(self.opts['cachedir'], 'files', saltenv)",
            "        localfilesdest = os.path.join(self.opts['cachedir'], 'localfiles')",
            "",
            "        fdest = self._file_local_list(filesdest)",
            "        ldest = self._file_local_list(localfilesdest)",
            "        return sorted(fdest.union(ldest))",
            "",
            "    def file_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        This function must be overwritten",
            "        '''",
            "        return []",
            "",
            "    def dir_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        This function must be overwritten",
            "        '''",
            "        return []",
            "",
            "    def symlink_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        This function must be overwritten",
            "        '''",
            "        return {}",
            "",
            "    def is_cached(self, path, saltenv='base', cachedir=None):",
            "        '''",
            "        Returns the full path to a file if it is cached locally on the minion",
            "        otherwise returns a blank string",
            "        '''",
            "        if path.startswith('salt://'):",
            "            path, senv = salt.utils.url.parse(path)",
            "            if senv:",
            "                saltenv = senv",
            "",
            "        escaped = True if salt.utils.url.is_escaped(path) else False",
            "",
            "        # also strip escape character '|'",
            "        localsfilesdest = os.path.join(",
            "            self.opts['cachedir'], 'localfiles', path.lstrip('|/'))",
            "        filesdest = os.path.join(",
            "            self.opts['cachedir'], 'files', saltenv, path.lstrip('|/'))",
            "        extrndest = self._extrn_path(path, saltenv, cachedir=cachedir)",
            "",
            "        if os.path.exists(filesdest):",
            "            return salt.utils.url.escape(filesdest) if escaped else filesdest",
            "        elif os.path.exists(localsfilesdest):",
            "            return salt.utils.url.escape(localsfilesdest) \\",
            "                if escaped \\",
            "                else localsfilesdest",
            "        elif os.path.exists(extrndest):",
            "            return extrndest",
            "",
            "        return ''",
            "",
            "    def list_states(self, saltenv):",
            "        '''",
            "        Return a list of all available sls modules on the master for a given",
            "        environment",
            "        '''",
            "",
            "        limit_traversal = self.opts.get('fileserver_limit_traversal', False)",
            "        states = []",
            "",
            "        if limit_traversal:",
            "            if saltenv not in self.opts['file_roots']:",
            "                log.warning(",
            "                    'During an attempt to list states for saltenv \\'{0}\\', '",
            "                    'the environment could not be found in the configured '",
            "                    'file roots'.format(saltenv)",
            "                )",
            "                return states",
            "            for path in self.opts['file_roots'][saltenv]:",
            "                for root, dirs, files in os.walk(path, topdown=True):",
            "                    log.debug('Searching for states in dirs {0} and files '",
            "                              '{1}'.format(dirs, files))",
            "                    if not [filename.endswith('.sls') for filename in files]:",
            "                        #  Use shallow copy so we don't disturb the memory used by os.walk. Otherwise this breaks!",
            "                        del dirs[:]",
            "                    else:",
            "                        for found_file in files:",
            "                            stripped_root = os.path.relpath(root, path).replace('/', '.')",
            "                            if salt.utils.is_windows():",
            "                                stripped_root = stripped_root.replace('\\\\', '/')",
            "                            if found_file.endswith(('.sls')):",
            "                                if found_file.endswith('init.sls'):",
            "                                    if stripped_root.endswith('.'):",
            "                                        stripped_root = stripped_root.rstrip('.')",
            "                                    states.append(stripped_root)",
            "                                else:",
            "                                    if not stripped_root.endswith('.'):",
            "                                        stripped_root += '.'",
            "                                    if stripped_root.startswith('.'):",
            "                                        stripped_root = stripped_root.lstrip('.')",
            "                                    states.append(stripped_root + found_file[:-4])",
            "        else:",
            "            for path in self.file_list(saltenv):",
            "                if salt.utils.is_windows():",
            "                    path = path.replace('\\\\', '/')",
            "                if path.endswith('.sls'):",
            "                    # is an sls module!",
            "                    if path.endswith('{0}init.sls'.format('/')):",
            "                        states.append(path.replace('/', '.')[:-9])",
            "                    else:",
            "                        states.append(path.replace('/', '.')[:-4])",
            "        return states",
            "",
            "    def get_state(self, sls, saltenv, cachedir=None):",
            "        '''",
            "        Get a state file from the master and store it in the local minion",
            "        cache; return the location of the file",
            "        '''",
            "        if '.' in sls:",
            "            sls = sls.replace('.', '/')",
            "        sls_url = salt.utils.url.create(sls + '.sls')",
            "        init_url = salt.utils.url.create(sls + '/init.sls')",
            "        for path in [sls_url, init_url]:",
            "            dest = self.cache_file(path, saltenv, cachedir=cachedir)",
            "            if dest:",
            "                return {'source': path, 'dest': dest}",
            "        return {}",
            "",
            "    def get_dir(self, path, dest='', saltenv='base', gzip=None,",
            "                cachedir=None):",
            "        '''",
            "        Get a directory recursively from the salt-master",
            "        '''",
            "        ret = []",
            "        # Strip trailing slash",
            "        path = self._check_proto(path).rstrip('/')",
            "        # Break up the path into a list containing the bottom-level directory",
            "        # (the one being recursively copied) and the directories preceding it",
            "        separated = path.rsplit('/', 1)",
            "        if len(separated) != 2:",
            "            # No slashes in path. (This means all files in saltenv will be",
            "            # copied)",
            "            prefix = ''",
            "        else:",
            "            prefix = separated[0]",
            "",
            "        # Copy files from master",
            "        for fn_ in self.file_list(saltenv, prefix=path):",
            "            # Prevent files in \"salt://foobar/\" (or salt://foo.sh) from",
            "            # matching a path of \"salt://foo\"",
            "            try:",
            "                if fn_[len(path)] != '/':",
            "                    continue",
            "            except IndexError:",
            "                continue",
            "            # Remove the leading directories from path to derive",
            "            # the relative path on the minion.",
            "            minion_relpath = fn_[len(prefix):].lstrip('/')",
            "            ret.append(",
            "               self.get_file(",
            "                  salt.utils.url.create(fn_),",
            "                  '{0}/{1}'.format(dest, minion_relpath),",
            "                  True, saltenv, gzip",
            "               )",
            "            )",
            "        # Replicate empty dirs from master",
            "        try:",
            "            for fn_ in self.file_list_emptydirs(saltenv, prefix=path):",
            "                # Prevent an empty dir \"salt://foobar/\" from matching a path of",
            "                # \"salt://foo\"",
            "                try:",
            "                    if fn_[len(path)] != '/':",
            "                        continue",
            "                except IndexError:",
            "                    continue",
            "                # Remove the leading directories from path to derive",
            "                # the relative path on the minion.",
            "                minion_relpath = fn_[len(prefix):].lstrip('/')",
            "                minion_mkdir = '{0}/{1}'.format(dest, minion_relpath)",
            "                if not os.path.isdir(minion_mkdir):",
            "                    os.makedirs(minion_mkdir)",
            "                ret.append(minion_mkdir)",
            "        except TypeError:",
            "            pass",
            "        ret.sort()",
            "        return ret",
            "",
            "    def get_url(self, url, dest, makedirs=False, saltenv='base',",
            "                no_cache=False, cachedir=None):",
            "        '''",
            "        Get a single file from a URL.",
            "        '''",
            "        url_data = urlparse(url)",
            "        url_scheme = url_data.scheme",
            "        url_path = os.path.join(",
            "                url_data.netloc, url_data.path).rstrip(os.sep)",
            "",
            "        if url_scheme and url_scheme.lower() in string.ascii_lowercase:",
            "            url_path = ':'.join((url_scheme, url_path))",
            "            url_scheme = 'file'",
            "",
            "        if url_scheme in ('file', ''):",
            "            # Local filesystem",
            "            if not os.path.isabs(url_path):",
            "                raise CommandExecutionError(",
            "                    'Path \\'{0}\\' is not absolute'.format(url_path)",
            "                )",
            "            if dest is None:",
            "                with salt.utils.fopen(url_path, 'r') as fp_:",
            "                    data = fp_.read()",
            "                return data",
            "            return url_path",
            "",
            "        if url_scheme == 'salt':",
            "            result = self.get_file(url, dest, makedirs, saltenv, cachedir=cachedir)",
            "            if result and dest is None:",
            "                with salt.utils.fopen(result, 'r') as fp_:",
            "                    data = fp_.read()",
            "                return data",
            "            return result",
            "",
            "        if dest:",
            "            destdir = os.path.dirname(dest)",
            "            if not os.path.isdir(destdir):",
            "                if makedirs:",
            "                    os.makedirs(destdir)",
            "                else:",
            "                    return ''",
            "        elif not no_cache:",
            "            dest = self._extrn_path(url, saltenv, cachedir=cachedir)",
            "            destdir = os.path.dirname(dest)",
            "            if not os.path.isdir(destdir):",
            "                os.makedirs(destdir)",
            "",
            "        if url_data.scheme == 's3':",
            "            try:",
            "                def s3_opt(key, default=None):",
            "                    '''Get value of s3.<key> from Minion config or from Pillar'''",
            "                    if 's3.' + key in self.opts:",
            "                        return self.opts['s3.' + key]",
            "                    try:",
            "                        return self.opts['pillar']['s3'][key]",
            "                    except (KeyError, TypeError):",
            "                        return default",
            "                self.utils['s3.query'](method='GET',",
            "                                       bucket=url_data.netloc,",
            "                                       path=url_data.path[1:],",
            "                                       return_bin=False,",
            "                                       local_file=dest,",
            "                                       action=None,",
            "                                       key=s3_opt('key'),",
            "                                       keyid=s3_opt('keyid'),",
            "                                       service_url=s3_opt('service_url'),",
            "                                       verify_ssl=s3_opt('verify_ssl', True),",
            "                                       location=s3_opt('location'))",
            "                return dest",
            "            except Exception as exc:",
            "                raise MinionError(",
            "                    'Could not fetch from {0}. Exception: {1}'.format(url, exc)",
            "                )",
            "        if url_data.scheme == 'ftp':",
            "            try:",
            "                ftp = ftplib.FTP(url_data.hostname)",
            "                ftp.login()",
            "                with salt.utils.fopen(dest, 'wb') as fp_:",
            "                    ftp.retrbinary('RETR {0}'.format(url_data.path), fp_.write)",
            "                return dest",
            "            except Exception as exc:",
            "                raise MinionError('Could not retrieve {0} from FTP server. Exception: {1}'.format(url, exc))",
            "",
            "        if url_data.scheme == 'swift':",
            "            try:",
            "                def swift_opt(key, default):",
            "                    '''Get value of <key> from Minion config or from Pillar'''",
            "                    if key in self.opts:",
            "                        return self.opts[key]",
            "                    try:",
            "                        return self.opts['pillar'][key]",
            "                    except (KeyError, TypeError):",
            "                        return default",
            "",
            "                swift_conn = SaltSwift(swift_opt('keystone.user', None),",
            "                                       swift_opt('keystone.tenant', None),",
            "                                       swift_opt('keystone.auth_url', None),",
            "                                       swift_opt('keystone.password', None))",
            "",
            "                swift_conn.get_object(url_data.netloc,",
            "                                      url_data.path[1:],",
            "                                      dest)",
            "                return dest",
            "            except Exception:",
            "                raise MinionError('Could not fetch from {0}'.format(url))",
            "",
            "        get_kwargs = {}",
            "        if url_data.username is not None \\",
            "                and url_data.scheme in ('http', 'https'):",
            "            netloc = url_data.netloc",
            "            at_sign_pos = netloc.rfind('@')",
            "            if at_sign_pos != -1:",
            "                netloc = netloc[at_sign_pos + 1:]",
            "            fixed_url = urlunparse(",
            "                (url_data.scheme, netloc, url_data.path,",
            "                 url_data.params, url_data.query, url_data.fragment))",
            "            get_kwargs['auth'] = (url_data.username, url_data.password)",
            "        else:",
            "            fixed_url = url",
            "",
            "        destfp = None",
            "        try:",
            "            # Tornado calls streaming_callback on redirect response bodies.",
            "            # But we need streaming to support fetching large files (> RAM avail).",
            "            # Here we working this around by disabling recording the body for redirections.",
            "            # The issue is fixed in Tornado 4.3.0 so on_header callback could be removed",
            "            # when we'll deprecate Tornado<4.3.0.",
            "            # See #27093 and #30431 for details.",
            "",
            "            # Use list here to make it writable inside the on_header callback. Simple bool doesn't",
            "            # work here: on_header creates a new local variable instead. This could be avoided in",
            "            # Py3 with 'nonlocal' statement. There is no Py2 alternative for this.",
            "            write_body = [False]",
            "",
            "            def on_header(hdr):",
            "                try:",
            "                    hdr = parse_response_start_line(hdr)",
            "                except HTTPInputError:",
            "                    # Not the first line, do nothing",
            "                    return",
            "                write_body[0] = hdr.code not in [301, 302, 303, 307]",
            "",
            "            if no_cache:",
            "                result = []",
            "",
            "                def on_chunk(chunk):",
            "                    if write_body[0]:",
            "                        result.append(chunk)",
            "            else:",
            "                dest_tmp = \"{0}.part\".format(dest)",
            "                # We need an open filehandle to use in the on_chunk callback,",
            "                # that's why we're not using a with clause here.",
            "                destfp = salt.utils.fopen(dest_tmp, 'wb')",
            "",
            "                def on_chunk(chunk):",
            "                    if write_body[0]:",
            "                        destfp.write(chunk)",
            "",
            "            query = salt.utils.http.query(",
            "                fixed_url,",
            "                stream=True,",
            "                streaming_callback=on_chunk,",
            "                header_callback=on_header,",
            "                username=url_data.username,",
            "                password=url_data.password,",
            "                opts=self.opts,",
            "                **get_kwargs",
            "            )",
            "            if 'handle' not in query:",
            "                raise MinionError('Error: {0} reading {1}'.format(query['error'], url))",
            "            if no_cache:",
            "                return ''.join(result)",
            "            else:",
            "                destfp.close()",
            "                destfp = None",
            "                salt.utils.files.rename(dest_tmp, dest)",
            "                return dest",
            "        except HTTPError as exc:",
            "            raise MinionError('HTTP error {0} reading {1}: {3}'.format(",
            "                exc.code,",
            "                url,",
            "                *BaseHTTPServer.BaseHTTPRequestHandler.responses[exc.code]))",
            "        except URLError as exc:",
            "            raise MinionError('Error reading {0}: {1}'.format(url, exc.reason))",
            "        finally:",
            "            if destfp is not None:",
            "                destfp.close()",
            "",
            "    def get_template(",
            "            self,",
            "            url,",
            "            dest,",
            "            template='jinja',",
            "            makedirs=False,",
            "            saltenv='base',",
            "            cachedir=None,",
            "            **kwargs):",
            "        '''",
            "        Cache a file then process it as a template",
            "        '''",
            "        if 'env' in kwargs:",
            "            salt.utils.warn_until(",
            "                'Oxygen',",
            "                'Parameter \\'env\\' has been detected in the argument list.  This '",
            "                'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "                'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "                )",
            "            kwargs.pop('env')",
            "",
            "        kwargs['saltenv'] = saltenv",
            "        url_data = urlparse(url)",
            "        sfn = self.cache_file(url, saltenv, cachedir=cachedir)",
            "        if not os.path.exists(sfn):",
            "            return ''",
            "        if template in salt.utils.templates.TEMPLATE_REGISTRY:",
            "            data = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "                sfn,",
            "                **kwargs",
            "            )",
            "        else:",
            "            log.error('Attempted to render template with unavailable engine '",
            "                      '{0}'.format(template))",
            "            return ''",
            "        if not data['result']:",
            "            # Failed to render the template",
            "            log.error(",
            "                'Failed to render template with error: {0}'.format(",
            "                    data['data']",
            "                )",
            "            )",
            "            return ''",
            "        if not dest:",
            "            # No destination passed, set the dest as an extrn_files cache",
            "            dest = self._extrn_path(url, saltenv, cachedir=cachedir)",
            "            # If Salt generated the dest name, create any required dirs",
            "            makedirs = True",
            "",
            "        destdir = os.path.dirname(dest)",
            "        if not os.path.isdir(destdir):",
            "            if makedirs:",
            "                os.makedirs(destdir)",
            "            else:",
            "                salt.utils.safe_rm(data['data'])",
            "                return ''",
            "        shutil.move(data['data'], dest)",
            "        return dest",
            "",
            "    def _extrn_path(self, url, saltenv, cachedir=None):",
            "        '''",
            "        Return the extn_filepath for a given url",
            "        '''",
            "        url_data = urlparse(url)",
            "        if salt.utils.is_windows():",
            "            netloc = salt.utils.sanitize_win_path_string(url_data.netloc)",
            "        else:",
            "            netloc = url_data.netloc",
            "",
            "        # Strip user:pass from URLs",
            "        netloc = netloc.split('@')[-1]",
            "",
            "        if cachedir is None:",
            "            cachedir = self.opts['cachedir']",
            "        elif not os.path.isabs(cachedir):",
            "            cachedir = os.path.join(self.opts['cachedir'], cachedir)",
            "",
            "        if url_data.query:",
            "            file_name = '-'.join([url_data.path, url_data.query])",
            "        else:",
            "            file_name = url_data.path",
            "",
            "        return salt.utils.path_join(",
            "            cachedir,",
            "            'extrn_files',",
            "            saltenv,",
            "            netloc,",
            "            file_name",
            "        )",
            "",
            "",
            "class LocalClient(Client):",
            "    '''",
            "    Use the local_roots option to parse a local file root",
            "    '''",
            "    def __init__(self, opts):",
            "        Client.__init__(self, opts)",
            "",
            "    def _find_file(self, path, saltenv='base'):",
            "        '''",
            "        Locate the file path",
            "        '''",
            "        fnd = {'path': '',",
            "               'rel': ''}",
            "",
            "        if saltenv not in self.opts['file_roots']:",
            "            return fnd",
            "        if salt.utils.url.is_escaped(path):",
            "            # The path arguments are escaped",
            "            path = salt.utils.url.unescape(path)",
            "        for root in self.opts['file_roots'][saltenv]:",
            "            full = os.path.join(root, path)",
            "            if os.path.isfile(full):",
            "                fnd['path'] = full",
            "                fnd['rel'] = path",
            "                return fnd",
            "        return fnd",
            "",
            "    def get_file(self,",
            "                 path,",
            "                 dest='',",
            "                 makedirs=False,",
            "                 saltenv='base',",
            "                 gzip=None,",
            "                 cachedir=None):",
            "        '''",
            "        Copies a file from the local files directory into :param:`dest`",
            "        gzip compression settings are ignored for local files",
            "        '''",
            "        path = self._check_proto(path)",
            "        fnd = self._find_file(path, saltenv)",
            "        fnd_path = fnd.get('path')",
            "        if not fnd_path:",
            "            return ''",
            "",
            "        try:",
            "            fnd_mode = fnd.get('stat', [])[0]",
            "        except (IndexError, TypeError):",
            "            fnd_mode = None",
            "",
            "        if not salt.utils.is_windows():",
            "            if fnd_mode is not None:",
            "                try:",
            "                    if os.stat(dest).st_mode != fnd_mode:",
            "                        try:",
            "                            os.chmod(dest, fnd_mode)",
            "                        except OSError as exc:",
            "                            log.warning('Failed to chmod %s: %s', dest, exc)",
            "                except Exception:",
            "                    pass",
            "",
            "        return fnd_path",
            "",
            "    def file_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        Return a list of files in the given environment",
            "        with optional relative prefix path to limit directory traversal",
            "        '''",
            "        ret = []",
            "        if saltenv not in self.opts['file_roots']:",
            "            return ret",
            "        prefix = prefix.strip('/')",
            "        for path in self.opts['file_roots'][saltenv]:",
            "            for root, dirs, files in os.walk(",
            "                os.path.join(path, prefix), followlinks=True",
            "            ):",
            "                # Don't walk any directories that match file_ignore_regex or glob",
            "                dirs[:] = [d for d in dirs if not salt.fileserver.is_file_ignored(self.opts, d)]",
            "                for fname in files:",
            "                    relpath = os.path.relpath(os.path.join(root, fname), path)",
            "                    ret.append(sdecode(relpath))",
            "        return ret",
            "",
            "    def file_list_emptydirs(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the empty dirs in the file_roots",
            "        with optional relative prefix path to limit directory traversal",
            "        '''",
            "        ret = []",
            "        prefix = prefix.strip('/')",
            "        if saltenv not in self.opts['file_roots']:",
            "            return ret",
            "        for path in self.opts['file_roots'][saltenv]:",
            "            for root, dirs, files in os.walk(",
            "                os.path.join(path, prefix), followlinks=True",
            "            ):",
            "                # Don't walk any directories that match file_ignore_regex or glob",
            "                dirs[:] = [d for d in dirs if not salt.fileserver.is_file_ignored(self.opts, d)]",
            "                if len(dirs) == 0 and len(files) == 0:",
            "                    ret.append(sdecode(os.path.relpath(root, path)))",
            "        return ret",
            "",
            "    def dir_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the dirs in the file_roots",
            "        with optional relative prefix path to limit directory traversal",
            "        '''",
            "        ret = []",
            "        if saltenv not in self.opts['file_roots']:",
            "            return ret",
            "        prefix = prefix.strip('/')",
            "        for path in self.opts['file_roots'][saltenv]:",
            "            for root, dirs, files in os.walk(",
            "                os.path.join(path, prefix), followlinks=True",
            "            ):",
            "                ret.append(sdecode(os.path.relpath(root, path)))",
            "        return ret",
            "",
            "    def __get_file_path(self, path, saltenv='base'):",
            "        '''",
            "        Return either a file path or the result of a remote find_file call.",
            "        '''",
            "        try:",
            "            path = self._check_proto(path)",
            "        except MinionError as err:",
            "            # Local file path",
            "            if not os.path.isfile(path):",
            "                msg = 'specified file {0} is not present to generate hash: {1}'",
            "                log.warning(msg.format(path, err))",
            "                return None",
            "            else:",
            "                return path",
            "        return self._find_file(path, saltenv)",
            "",
            "    def hash_file(self, path, saltenv='base'):",
            "        '''",
            "        Return the hash of a file, to get the hash of a file in the file_roots",
            "        prepend the path with salt://<file on server> otherwise, prepend the",
            "        file with / for a local file.",
            "        '''",
            "        ret = {}",
            "        fnd = self.__get_file_path(path, saltenv)",
            "        if fnd is None:",
            "            return ret",
            "",
            "        try:",
            "            # Remote file path (self._find_file() invoked)",
            "            fnd_path = fnd['path']",
            "        except TypeError:",
            "            # Local file path",
            "            fnd_path = fnd",
            "",
            "        hash_type = self.opts.get('hash_type', 'md5')",
            "        ret['hsum'] = salt.utils.get_hash(fnd_path, form=hash_type)",
            "        ret['hash_type'] = hash_type",
            "        return ret",
            "",
            "    def hash_and_stat_file(self, path, saltenv='base'):",
            "        '''",
            "        Return the hash of a file, to get the hash of a file in the file_roots",
            "        prepend the path with salt://<file on server> otherwise, prepend the",
            "        file with / for a local file.",
            "",
            "        Additionally, return the stat result of the file, or None if no stat",
            "        results were found.",
            "        '''",
            "        ret = {}",
            "        fnd = self.__get_file_path(path, saltenv)",
            "        if fnd is None:",
            "            return ret, None",
            "",
            "        try:",
            "            # Remote file path (self._find_file() invoked)",
            "            fnd_path = fnd['path']",
            "            fnd_stat = fnd.get('stat')",
            "        except TypeError:",
            "            # Local file path",
            "            fnd_path = fnd",
            "            try:",
            "                fnd_stat = list(os.stat(fnd_path))",
            "            except Exception:",
            "                fnd_stat = None",
            "",
            "        hash_type = self.opts.get('hash_type', 'md5')",
            "        ret['hsum'] = salt.utils.get_hash(fnd_path, form=hash_type)",
            "        ret['hash_type'] = hash_type",
            "        return ret, fnd_stat",
            "",
            "    def list_env(self, saltenv='base'):",
            "        '''",
            "        Return a list of the files in the file server's specified environment",
            "        '''",
            "        return self.file_list(saltenv)",
            "",
            "    def master_opts(self):",
            "        '''",
            "        Return the master opts data",
            "        '''",
            "        return self.opts",
            "",
            "    def envs(self):",
            "        '''",
            "        Return the available environments",
            "        '''",
            "        ret = []",
            "        for saltenv in self.opts['file_roots']:",
            "            ret.append(saltenv)",
            "        return ret",
            "",
            "    def ext_nodes(self):",
            "        '''",
            "        Originally returned information via the external_nodes subsystem.",
            "        External_nodes was deprecated and removed in",
            "        2014.1.6 in favor of master_tops (which had been around since pre-0.17).",
            "             salt-call --local state.show_top",
            "        ends up here, but master_tops has not been extended to support",
            "        show_top in a completely local environment yet.  It's worth noting",
            "        that originally this fn started with",
            "            if 'external_nodes' not in opts: return {}",
            "        So since external_nodes is gone now, we are just returning the",
            "        empty dict.",
            "        '''",
            "        return {}",
            "",
            "",
            "class RemoteClient(Client):",
            "    '''",
            "    Interact with the salt master file server.",
            "    '''",
            "    def __init__(self, opts):",
            "        Client.__init__(self, opts)",
            "        self.channel = salt.transport.Channel.factory(self.opts)",
            "        if hasattr(self.channel, 'auth'):",
            "            self.auth = self.channel.auth",
            "        else:",
            "            self.auth = ''",
            "",
            "    def _refresh_channel(self):",
            "        '''",
            "        Reset the channel, in the event of an interruption",
            "        '''",
            "        self.channel = salt.transport.Channel.factory(self.opts)",
            "        return self.channel",
            "",
            "    def get_file(self,",
            "                 path,",
            "                 dest='',",
            "                 makedirs=False,",
            "                 saltenv='base',",
            "                 gzip=None,",
            "                 cachedir=None):",
            "        '''",
            "        Get a single file from the salt-master",
            "        path must be a salt server location, aka, salt://path/to/file, if",
            "        dest is omitted, then the downloaded file will be placed in the minion",
            "        cache",
            "        '''",
            "        path, senv = salt.utils.url.split_env(path)",
            "        if senv:",
            "            saltenv = senv",
            "",
            "        if not salt.utils.is_windows():",
            "            hash_server, stat_server = self.hash_and_stat_file(path, saltenv)",
            "            try:",
            "                mode_server = stat_server[0]",
            "            except (IndexError, TypeError):",
            "                mode_server = None",
            "        else:",
            "            hash_server = self.hash_file(path, saltenv)",
            "            mode_server = None",
            "",
            "        # Check if file exists on server, before creating files and",
            "        # directories",
            "        if hash_server == '':",
            "            log.debug(",
            "                'Could not find file \\'%s\\' in saltenv \\'%s\\'',",
            "                path, saltenv",
            "            )",
            "            return False",
            "",
            "        # Hash compare local copy with master and skip download",
            "        # if no difference found.",
            "        dest2check = dest",
            "        if not dest2check:",
            "            rel_path = self._check_proto(path)",
            "",
            "            log.debug(",
            "                'In saltenv \\'%s\\', looking at rel_path \\'%s\\' to resolve '",
            "                '\\'%s\\'', saltenv, rel_path, path",
            "            )",
            "            with self._cache_loc(",
            "                    rel_path, saltenv, cachedir=cachedir) as cache_dest:",
            "                dest2check = cache_dest",
            "",
            "        log.debug(",
            "            'In saltenv \\'%s\\', ** considering ** path \\'%s\\' to resolve '",
            "            '\\'%s\\'', saltenv, dest2check, path",
            "        )",
            "",
            "        if dest2check and os.path.isfile(dest2check):",
            "            if not salt.utils.is_windows():",
            "                hash_local, stat_local = \\",
            "                    self.hash_and_stat_file(dest2check, saltenv)",
            "                try:",
            "                    mode_local = stat_local[0]",
            "                except (IndexError, TypeError):",
            "                    mode_local = None",
            "            else:",
            "                hash_local = self.hash_file(dest2check, saltenv)",
            "                mode_local = None",
            "",
            "            if hash_local == hash_server:",
            "                if not salt.utils.is_windows():",
            "                    if mode_server is None:",
            "                        log.debug('No file mode available for \\'%s\\'', path)",
            "                    elif mode_local is None:",
            "                        log.debug(",
            "                            'No file mode available for \\'%s\\'',",
            "                            dest2check",
            "                        )",
            "                    else:",
            "                        if mode_server == mode_local:",
            "                            log.info(",
            "                                'Fetching file from saltenv \\'%s\\', '",
            "                                '** skipped ** latest already in cache '",
            "                                '\\'%s\\', mode up-to-date', saltenv, path",
            "                            )",
            "                        else:",
            "                            try:",
            "                                os.chmod(dest2check, mode_server)",
            "                                log.info(",
            "                                    'Fetching file from saltenv \\'%s\\', '",
            "                                    '** updated ** latest already in cache, '",
            "                                    '\\'%s\\', mode updated from %s to %s',",
            "                                    saltenv,",
            "                                    path,",
            "                                    salt.utils.st_mode_to_octal(mode_local),",
            "                                    salt.utils.st_mode_to_octal(mode_server)",
            "                                )",
            "                            except OSError as exc:",
            "                                log.warning(",
            "                                    'Failed to chmod %s: %s', dest2check, exc",
            "                                )",
            "                    # We may not have been able to check/set the mode, but we",
            "                    # don't want to re-download the file because of a failure",
            "                    # in mode checking. Return the cached path.",
            "                    return dest2check",
            "                else:",
            "                    log.info(",
            "                        'Fetching file from saltenv \\'%s\\', ** skipped ** '",
            "                        'latest already in cache \\'%s\\'', saltenv, path",
            "                    )",
            "                    return dest2check",
            "",
            "        log.debug(",
            "            'Fetching file from saltenv \\'%s\\', ** attempting ** \\'%s\\'',",
            "            saltenv, path",
            "        )",
            "        d_tries = 0",
            "        transport_tries = 0",
            "        path = self._check_proto(path)",
            "        load = {'path': path,",
            "                'saltenv': saltenv,",
            "                'cmd': '_serve_file'}",
            "        if gzip:",
            "            gzip = int(gzip)",
            "            load['gzip'] = gzip",
            "",
            "        fn_ = None",
            "        if dest:",
            "            destdir = os.path.dirname(dest)",
            "            if not os.path.isdir(destdir):",
            "                if makedirs:",
            "                    os.makedirs(destdir)",
            "                else:",
            "                    return False",
            "            # We need an open filehandle here, that's why we're not using a",
            "            # with clause:",
            "            fn_ = salt.utils.fopen(dest, 'wb+')",
            "        else:",
            "            log.debug('No dest file found')",
            "",
            "        while True:",
            "            if not fn_:",
            "                load['loc'] = 0",
            "            else:",
            "                load['loc'] = fn_.tell()",
            "            data = self.channel.send(load, raw=True)",
            "            if six.PY3:",
            "                # Sometimes the source is local (eg when using",
            "                # 'salt.filesystem.FSChan'), in which case the keys are",
            "                # already strings. Sometimes the source is remote, in which",
            "                # case the keys are bytes due to raw mode. Standardize on",
            "                # strings for the top-level keys to simplify things.",
            "                data = decode_dict_keys_to_str(data)",
            "            try:",
            "                if not data['data']:",
            "                    if not fn_ and data['dest']:",
            "                        # This is a 0 byte file on the master",
            "                        with self._cache_loc(",
            "                                data['dest'],",
            "                                saltenv,",
            "                                cachedir=cachedir) as cache_dest:",
            "                            dest = cache_dest",
            "                            with salt.utils.fopen(cache_dest, 'wb+') as ofile:",
            "                                ofile.write(data['data'])",
            "                    if 'hsum' in data and d_tries < 3:",
            "                        # Master has prompted a file verification, if the",
            "                        # verification fails, re-download the file. Try 3 times",
            "                        d_tries += 1",
            "                        hsum = salt.utils.get_hash(dest, salt.utils.to_str(data.get('hash_type', b'md5')))",
            "                        if hsum != data['hsum']:",
            "                            log.warning(",
            "                                'Bad download of file %s, attempt %d of 3',",
            "                                path, d_tries",
            "                            )",
            "                            continue",
            "                    break",
            "                if not fn_:",
            "                    with self._cache_loc(",
            "                            data['dest'],",
            "                            saltenv,",
            "                            cachedir=cachedir) as cache_dest:",
            "                        dest = cache_dest",
            "                        # If a directory was formerly cached at this path, then",
            "                        # remove it to avoid a traceback trying to write the file",
            "                        if os.path.isdir(dest):",
            "                            salt.utils.rm_rf(dest)",
            "                        fn_ = salt.utils.fopen(dest, 'wb+')",
            "                if data.get('gzip', None):",
            "                    data = salt.utils.gzip_util.uncompress(data['data'])",
            "                else:",
            "                    data = data['data']",
            "                if six.PY3 and isinstance(data, str):",
            "                    data = data.encode()",
            "                fn_.write(data)",
            "            except (TypeError, KeyError) as exc:",
            "                try:",
            "                    data_type = type(data).__name__",
            "                except AttributeError:",
            "                    # Shouldn't happen, but don't let this cause a traceback.",
            "                    data_type = str(type(data))",
            "                transport_tries += 1",
            "                log.warning(",
            "                    'Data transport is broken, got: %s, type: %s, '",
            "                    'exception: %s, attempt %d of 3',",
            "                    data, data_type, exc, transport_tries",
            "                )",
            "                self._refresh_channel()",
            "                if transport_tries > 3:",
            "                    log.error(",
            "                        'Data transport is broken, got: %s, type: %s, '",
            "                        'exception: %s, retry attempts exhausted',",
            "                        data, data_type, exc",
            "                    )",
            "                    break",
            "",
            "        if fn_:",
            "            fn_.close()",
            "            log.info(",
            "                'Fetching file from saltenv \\'%s\\', ** done ** \\'%s\\'',",
            "                saltenv, path",
            "            )",
            "        else:",
            "            log.debug(",
            "                'In saltenv \\'%s\\', we are ** missing ** the file \\'%s\\'',",
            "                saltenv, path",
            "            )",
            "",
            "        if not salt.utils.is_windows():",
            "            if mode_server is not None:",
            "                try:",
            "                    if os.stat(dest).st_mode != mode_server:",
            "                        try:",
            "                            os.chmod(dest, mode_server)",
            "                            log.info(",
            "                                'Fetching file from saltenv \\'%s\\', '",
            "                                '** done ** \\'%s\\', mode set to %s',",
            "                                saltenv,",
            "                                path,",
            "                                salt.utils.st_mode_to_octal(mode_server)",
            "                            )",
            "                        except OSError:",
            "                            log.warning('Failed to chmod %s: %s', dest, exc)",
            "                except OSError:",
            "                    pass",
            "        return dest",
            "",
            "    def file_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the files on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_file_list'}",
            "",
            "        return [sdecode(fn_) for fn_ in self.channel.send(load)]",
            "",
            "    def file_list_emptydirs(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the empty dirs on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_file_list_emptydirs'}",
            "        self.channel.send(load)",
            "",
            "    def dir_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the dirs on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_dir_list'}",
            "        return self.channel.send(load)",
            "",
            "    def symlink_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List symlinked files and dirs on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_symlink_list'}",
            "        return self.channel.send(load)",
            "",
            "    def __hash_and_stat_file(self, path, saltenv='base'):",
            "        '''",
            "        Common code for hashing and stating files",
            "        '''",
            "        try:",
            "            path = self._check_proto(path)",
            "        except MinionError as err:",
            "            if not os.path.isfile(path):",
            "                msg = 'specified file {0} is not present to generate hash: {1}'",
            "                log.warning(msg.format(path, err))",
            "                return {}",
            "            else:",
            "                ret = {}",
            "                hash_type = self.opts.get('hash_type', 'md5')",
            "                ret['hsum'] = salt.utils.get_hash(path, form=hash_type)",
            "                ret['hash_type'] = hash_type",
            "                return ret",
            "        load = {'path': path,",
            "                'saltenv': saltenv,",
            "                'cmd': '_file_hash'}",
            "        return self.channel.send(load)",
            "",
            "    def hash_file(self, path, saltenv='base'):",
            "        '''",
            "        Return the hash of a file, to get the hash of a file on the salt",
            "        master file server prepend the path with salt://<file on server>",
            "        otherwise, prepend the file with / for a local file.",
            "        '''",
            "        return self.__hash_and_stat_file(path, saltenv)",
            "",
            "    def hash_and_stat_file(self, path, saltenv='base'):",
            "        '''",
            "        The same as hash_file, but also return the file's mode, or None if no",
            "        mode data is present.",
            "        '''",
            "        hash_result = self.hash_file(path, saltenv)",
            "        try:",
            "            path = self._check_proto(path)",
            "        except MinionError as err:",
            "            if not os.path.isfile(path):",
            "                return hash_result, None",
            "            else:",
            "                try:",
            "                    return hash_result, list(os.stat(path))",
            "                except Exception:",
            "                    return hash_result, None",
            "        load = {'path': path,",
            "                'saltenv': saltenv,",
            "                'cmd': '_file_find'}",
            "        fnd = self.channel.send(load)",
            "        try:",
            "            stat_result = fnd.get('stat')",
            "        except AttributeError:",
            "            stat_result = None",
            "        return hash_result, stat_result",
            "",
            "    def list_env(self, saltenv='base'):",
            "        '''",
            "        Return a list of the files in the file server's specified environment",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'cmd': '_file_list'}",
            "        return self.channel.send(load)",
            "",
            "    def envs(self):",
            "        '''",
            "        Return a list of available environments",
            "        '''",
            "        load = {'cmd': '_file_envs'}",
            "        return self.channel.send(load)",
            "",
            "    def master_opts(self):",
            "        '''",
            "        Return the master opts data",
            "        '''",
            "        load = {'cmd': '_master_opts'}",
            "        return self.channel.send(load)",
            "",
            "    def ext_nodes(self):",
            "        '''",
            "        Return the metadata derived from the external nodes system on the",
            "        master.",
            "        '''",
            "        load = {'cmd': '_ext_nodes',",
            "                'id': self.opts['id'],",
            "                'opts': self.opts}",
            "        if self.auth:",
            "            load['tok'] = self.auth.gen_token('salt')",
            "        return self.channel.send(load)",
            "",
            "",
            "class FSClient(RemoteClient):",
            "    '''",
            "    A local client that uses the RemoteClient but substitutes the channel for",
            "    the FSChan object",
            "    '''",
            "    def __init__(self, opts):  # pylint: disable=W0231",
            "        Client.__init__(self, opts)  # pylint: disable=W0233",
            "        self.channel = salt.fileserver.FSChan(opts)",
            "        self.auth = DumbAuth()",
            "",
            "",
            "class DumbAuth(object):",
            "    '''",
            "    The dumbauth class is used to stub out auth calls fired from the FSClient",
            "    subsystem",
            "    '''",
            "    def gen_token(self, clear_tok):",
            "        return clear_tok"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Classes that manage file clients",
            "'''",
            "from __future__ import absolute_import",
            "",
            "# Import python libs",
            "import contextlib",
            "import errno",
            "import logging",
            "import os",
            "import string",
            "import shutil",
            "import ftplib",
            "from tornado.httputil import parse_response_start_line, HTTPInputError",
            "",
            "# Import salt libs",
            "from salt.exceptions import (",
            "    CommandExecutionError, MinionError",
            ")",
            "import salt.client",
            "import salt.crypt",
            "import salt.loader",
            "import salt.payload",
            "import salt.transport",
            "import salt.fileserver",
            "import salt.utils",
            "import salt.utils.files",
            "import salt.utils.templates",
            "import salt.utils.url",
            "import salt.utils.gzip_util",
            "import salt.utils.http",
            "import salt.ext.six as six",
            "from salt.utils.locales import sdecode",
            "from salt.utils.openstack.swift import SaltSwift",
            "",
            "# pylint: disable=no-name-in-module,import-error",
            "import salt.ext.six.moves.BaseHTTPServer as BaseHTTPServer",
            "from salt.ext.six.moves.urllib.error import HTTPError, URLError",
            "from salt.ext.six.moves.urllib.parse import urlparse, urlunparse",
            "# pylint: enable=no-name-in-module,import-error",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def get_file_client(opts, pillar=False):",
            "    '''",
            "    Read in the ``file_client`` option and return the correct type of file",
            "    server",
            "    '''",
            "    client = opts.get('file_client', 'remote')",
            "    if pillar and client == 'local':",
            "        client = 'pillar'",
            "    return {",
            "        'remote': RemoteClient,",
            "        'local': FSClient,",
            "        'pillar': LocalClient,",
            "    }.get(client, RemoteClient)(opts)",
            "",
            "",
            "def decode_dict_keys_to_str(src):",
            "    '''",
            "    Convert top level keys from bytes to strings if possible.",
            "    This is necessary because Python 3 makes a distinction",
            "    between these types.",
            "    '''",
            "    if not six.PY3 or not isinstance(src, dict):",
            "        return src",
            "",
            "    output = {}",
            "    for key, val in six.iteritems(src):",
            "        if isinstance(key, bytes):",
            "            try:",
            "                key = key.decode()",
            "            except UnicodeError:",
            "                pass",
            "        output[key] = val",
            "    return output",
            "",
            "",
            "class Client(object):",
            "    '''",
            "    Base class for Salt file interactions",
            "    '''",
            "    def __init__(self, opts):",
            "        self.opts = opts",
            "        self.utils = salt.loader.utils(self.opts)",
            "        self.serial = salt.payload.Serial(self.opts)",
            "",
            "    # Add __setstate__ and __getstate__ so that the object may be",
            "    # deep copied. It normally can't be deep copied because its",
            "    # constructor requires an 'opts' parameter.",
            "    # The TCP transport needs to be able to deep copy this class",
            "    # due to 'salt.utils.context.ContextDict.clone'.",
            "    def __setstate__(self, state):",
            "        # This will polymorphically call __init__",
            "        # in the derived class.",
            "        self.__init__(state['opts'])",
            "",
            "    def __getstate__(self):",
            "        return {'opts': self.opts}",
            "",
            "    def _check_proto(self, path):",
            "        '''",
            "        Make sure that this path is intended for the salt master and trim it",
            "        '''",
            "        if not path.startswith('salt://'):",
            "            raise MinionError(u'Unsupported path: {0}'.format(path))",
            "        file_path, saltenv = salt.utils.url.parse(path)",
            "        return file_path",
            "",
            "    def _file_local_list(self, dest):",
            "        '''",
            "        Helper util to return a list of files in a directory",
            "        '''",
            "        if os.path.isdir(dest):",
            "            destdir = dest",
            "        else:",
            "            destdir = os.path.dirname(dest)",
            "",
            "        filelist = set()",
            "",
            "        for root, dirs, files in os.walk(destdir, followlinks=True):",
            "            for name in files:",
            "                path = os.path.join(root, name)",
            "                filelist.add(path)",
            "",
            "        return filelist",
            "",
            "    @contextlib.contextmanager",
            "    def _cache_loc(self, path, saltenv='base', cachedir=None):",
            "        '''",
            "        Return the local location to cache the file, cache dirs will be made",
            "        '''",
            "        if cachedir is None:",
            "            cachedir = self.opts['cachedir']",
            "        elif not os.path.isabs(cachedir):",
            "            cachedir = os.path.join(self.opts['cachedir'], cachedir)",
            "",
            "        dest = salt.utils.path_join(cachedir,",
            "                                    'files',",
            "                                    saltenv,",
            "                                    path)",
            "        destdir = os.path.dirname(dest)",
            "        cumask = os.umask(63)",
            "",
            "        # remove destdir if it is a regular file to avoid an OSError when",
            "        # running os.makedirs below",
            "        if os.path.isfile(destdir):",
            "            os.remove(destdir)",
            "",
            "        # ensure destdir exists",
            "        try:",
            "            os.makedirs(destdir)",
            "        except OSError as exc:",
            "            if exc.errno != errno.EEXIST:  # ignore if it was there already",
            "                raise",
            "",
            "        yield dest",
            "        os.umask(cumask)",
            "",
            "    def get_file(self,",
            "                 path,",
            "                 dest='',",
            "                 makedirs=False,",
            "                 saltenv='base',",
            "                 gzip=None,",
            "                 cachedir=None):",
            "        '''",
            "        Copies a file from the local files or master depending on",
            "        implementation",
            "        '''",
            "        raise NotImplementedError",
            "",
            "    def file_list_emptydirs(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the empty dirs",
            "        '''",
            "        raise NotImplementedError",
            "",
            "    def cache_file(self, path, saltenv='base', cachedir=None):",
            "        '''",
            "        Pull a file down from the file server and store it in the minion",
            "        file cache",
            "        '''",
            "        return self.get_url(path, '', True, saltenv, cachedir=cachedir)",
            "",
            "    def cache_files(self, paths, saltenv='base', cachedir=None):",
            "        '''",
            "        Download a list of files stored on the master and put them in the",
            "        minion file cache",
            "        '''",
            "        ret = []",
            "        if isinstance(paths, str):",
            "            paths = paths.split(',')",
            "        for path in paths:",
            "            ret.append(self.cache_file(path, saltenv, cachedir=cachedir))",
            "        return ret",
            "",
            "    def cache_master(self, saltenv='base', cachedir=None):",
            "        '''",
            "        Download and cache all files on a master in a specified environment",
            "        '''",
            "        ret = []",
            "        for path in self.file_list(saltenv):",
            "            ret.append(",
            "                self.cache_file(",
            "                    salt.utils.url.create(path), saltenv, cachedir=cachedir)",
            "            )",
            "        return ret",
            "",
            "    def cache_dir(self, path, saltenv='base', include_empty=False,",
            "                  include_pat=None, exclude_pat=None, cachedir=None):",
            "        '''",
            "        Download all of the files in a subdir of the master",
            "        '''",
            "        ret = []",
            "",
            "        path = self._check_proto(sdecode(path))",
            "        # We want to make sure files start with this *directory*, use",
            "        # '/' explicitly because the master (that's generating the",
            "        # list of files) only runs on POSIX",
            "        if not path.endswith('/'):",
            "            path = path + '/'",
            "",
            "        log.info(",
            "            'Caching directory \\'{0}\\' for environment \\'{1}\\''.format(",
            "                path, saltenv",
            "            )",
            "        )",
            "        # go through the list of all files finding ones that are in",
            "        # the target directory and caching them",
            "        for fn_ in self.file_list(saltenv):",
            "            fn_ = sdecode(fn_)",
            "            if fn_.strip() and fn_.startswith(path):",
            "                if salt.utils.check_include_exclude(",
            "                        fn_, include_pat, exclude_pat):",
            "                    fn_ = self.cache_file(",
            "                        salt.utils.url.create(fn_), saltenv, cachedir=cachedir)",
            "                    if fn_:",
            "                        ret.append(fn_)",
            "",
            "        if include_empty:",
            "            # Break up the path into a list containing the bottom-level",
            "            # directory (the one being recursively copied) and the directories",
            "            # preceding it",
            "            # separated = string.rsplit(path, '/', 1)",
            "            # if len(separated) != 2:",
            "            #     # No slashes in path. (So all files in saltenv will be copied)",
            "            #     prefix = ''",
            "            # else:",
            "            #     prefix = separated[0]",
            "            if cachedir is None:",
            "                cachedir = self.opts['cachedir']",
            "            elif not os.path.isabs(cachedir):",
            "                cachedir = os.path.join(self.opts['cachedir'], cachedir)",
            "",
            "            dest = salt.utils.path_join(cachedir, 'files', saltenv)",
            "            for fn_ in self.file_list_emptydirs(saltenv):",
            "                fn_ = sdecode(fn_)",
            "                if fn_.startswith(path):",
            "                    minion_dir = '{0}/{1}'.format(dest, fn_)",
            "                    if not os.path.isdir(minion_dir):",
            "                        os.makedirs(minion_dir)",
            "                    ret.append(minion_dir)",
            "        return ret",
            "",
            "    def cache_local_file(self, path, **kwargs):",
            "        '''",
            "        Cache a local file on the minion in the localfiles cache",
            "        '''",
            "        dest = os.path.join(self.opts['cachedir'], 'localfiles',",
            "                            path.lstrip('/'))",
            "        destdir = os.path.dirname(dest)",
            "",
            "        if not os.path.isdir(destdir):",
            "            os.makedirs(destdir)",
            "",
            "        shutil.copyfile(path, dest)",
            "        return dest",
            "",
            "    def file_local_list(self, saltenv='base'):",
            "        '''",
            "        List files in the local minion files and localfiles caches",
            "        '''",
            "        filesdest = os.path.join(self.opts['cachedir'], 'files', saltenv)",
            "        localfilesdest = os.path.join(self.opts['cachedir'], 'localfiles')",
            "",
            "        fdest = self._file_local_list(filesdest)",
            "        ldest = self._file_local_list(localfilesdest)",
            "        return sorted(fdest.union(ldest))",
            "",
            "    def file_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        This function must be overwritten",
            "        '''",
            "        return []",
            "",
            "    def dir_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        This function must be overwritten",
            "        '''",
            "        return []",
            "",
            "    def symlink_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        This function must be overwritten",
            "        '''",
            "        return {}",
            "",
            "    def is_cached(self, path, saltenv='base', cachedir=None):",
            "        '''",
            "        Returns the full path to a file if it is cached locally on the minion",
            "        otherwise returns a blank string",
            "        '''",
            "        if path.startswith('salt://'):",
            "            path, senv = salt.utils.url.parse(path)",
            "            if senv:",
            "                saltenv = senv",
            "",
            "        escaped = True if salt.utils.url.is_escaped(path) else False",
            "",
            "        # also strip escape character '|'",
            "        localsfilesdest = os.path.join(",
            "            self.opts['cachedir'], 'localfiles', path.lstrip('|/'))",
            "        filesdest = os.path.join(",
            "            self.opts['cachedir'], 'files', saltenv, path.lstrip('|/'))",
            "        extrndest = self._extrn_path(path, saltenv, cachedir=cachedir)",
            "",
            "        if os.path.exists(filesdest):",
            "            return salt.utils.url.escape(filesdest) if escaped else filesdest",
            "        elif os.path.exists(localsfilesdest):",
            "            return salt.utils.url.escape(localsfilesdest) \\",
            "                if escaped \\",
            "                else localsfilesdest",
            "        elif os.path.exists(extrndest):",
            "            return extrndest",
            "",
            "        return ''",
            "",
            "    def list_states(self, saltenv):",
            "        '''",
            "        Return a list of all available sls modules on the master for a given",
            "        environment",
            "        '''",
            "",
            "        limit_traversal = self.opts.get('fileserver_limit_traversal', False)",
            "        states = []",
            "",
            "        if limit_traversal:",
            "            if saltenv not in self.opts['file_roots']:",
            "                log.warning(",
            "                    'During an attempt to list states for saltenv \\'{0}\\', '",
            "                    'the environment could not be found in the configured '",
            "                    'file roots'.format(saltenv)",
            "                )",
            "                return states",
            "            for path in self.opts['file_roots'][saltenv]:",
            "                for root, dirs, files in os.walk(path, topdown=True):",
            "                    log.debug('Searching for states in dirs {0} and files '",
            "                              '{1}'.format(dirs, files))",
            "                    if not [filename.endswith('.sls') for filename in files]:",
            "                        #  Use shallow copy so we don't disturb the memory used by os.walk. Otherwise this breaks!",
            "                        del dirs[:]",
            "                    else:",
            "                        for found_file in files:",
            "                            stripped_root = os.path.relpath(root, path).replace('/', '.')",
            "                            if salt.utils.is_windows():",
            "                                stripped_root = stripped_root.replace('\\\\', '/')",
            "                            if found_file.endswith(('.sls')):",
            "                                if found_file.endswith('init.sls'):",
            "                                    if stripped_root.endswith('.'):",
            "                                        stripped_root = stripped_root.rstrip('.')",
            "                                    states.append(stripped_root)",
            "                                else:",
            "                                    if not stripped_root.endswith('.'):",
            "                                        stripped_root += '.'",
            "                                    if stripped_root.startswith('.'):",
            "                                        stripped_root = stripped_root.lstrip('.')",
            "                                    states.append(stripped_root + found_file[:-4])",
            "        else:",
            "            for path in self.file_list(saltenv):",
            "                if salt.utils.is_windows():",
            "                    path = path.replace('\\\\', '/')",
            "                if path.endswith('.sls'):",
            "                    # is an sls module!",
            "                    if path.endswith('{0}init.sls'.format('/')):",
            "                        states.append(path.replace('/', '.')[:-9])",
            "                    else:",
            "                        states.append(path.replace('/', '.')[:-4])",
            "        return states",
            "",
            "    def get_state(self, sls, saltenv, cachedir=None):",
            "        '''",
            "        Get a state file from the master and store it in the local minion",
            "        cache; return the location of the file",
            "        '''",
            "        if '.' in sls:",
            "            sls = sls.replace('.', '/')",
            "        sls_url = salt.utils.url.create(sls + '.sls')",
            "        init_url = salt.utils.url.create(sls + '/init.sls')",
            "        for path in [sls_url, init_url]:",
            "            dest = self.cache_file(path, saltenv, cachedir=cachedir)",
            "            if dest:",
            "                return {'source': path, 'dest': dest}",
            "        return {}",
            "",
            "    def get_dir(self, path, dest='', saltenv='base', gzip=None,",
            "                cachedir=None):",
            "        '''",
            "        Get a directory recursively from the salt-master",
            "        '''",
            "        ret = []",
            "        # Strip trailing slash",
            "        path = self._check_proto(path).rstrip('/')",
            "        # Break up the path into a list containing the bottom-level directory",
            "        # (the one being recursively copied) and the directories preceding it",
            "        separated = path.rsplit('/', 1)",
            "        if len(separated) != 2:",
            "            # No slashes in path. (This means all files in saltenv will be",
            "            # copied)",
            "            prefix = ''",
            "        else:",
            "            prefix = separated[0]",
            "",
            "        # Copy files from master",
            "        for fn_ in self.file_list(saltenv, prefix=path):",
            "            # Prevent files in \"salt://foobar/\" (or salt://foo.sh) from",
            "            # matching a path of \"salt://foo\"",
            "            try:",
            "                if fn_[len(path)] != '/':",
            "                    continue",
            "            except IndexError:",
            "                continue",
            "            # Remove the leading directories from path to derive",
            "            # the relative path on the minion.",
            "            minion_relpath = fn_[len(prefix):].lstrip('/')",
            "            ret.append(",
            "               self.get_file(",
            "                  salt.utils.url.create(fn_),",
            "                  '{0}/{1}'.format(dest, minion_relpath),",
            "                  True, saltenv, gzip",
            "               )",
            "            )",
            "        # Replicate empty dirs from master",
            "        try:",
            "            for fn_ in self.file_list_emptydirs(saltenv, prefix=path):",
            "                # Prevent an empty dir \"salt://foobar/\" from matching a path of",
            "                # \"salt://foo\"",
            "                try:",
            "                    if fn_[len(path)] != '/':",
            "                        continue",
            "                except IndexError:",
            "                    continue",
            "                # Remove the leading directories from path to derive",
            "                # the relative path on the minion.",
            "                minion_relpath = fn_[len(prefix):].lstrip('/')",
            "                minion_mkdir = '{0}/{1}'.format(dest, minion_relpath)",
            "                if not os.path.isdir(minion_mkdir):",
            "                    os.makedirs(minion_mkdir)",
            "                ret.append(minion_mkdir)",
            "        except TypeError:",
            "            pass",
            "        ret.sort()",
            "        return ret",
            "",
            "    def get_url(self, url, dest, makedirs=False, saltenv='base',",
            "                no_cache=False, cachedir=None):",
            "        '''",
            "        Get a single file from a URL.",
            "        '''",
            "        url_data = urlparse(url)",
            "        url_scheme = url_data.scheme",
            "        url_path = os.path.join(",
            "                url_data.netloc, url_data.path).rstrip(os.sep)",
            "",
            "        if url_scheme and url_scheme.lower() in string.ascii_lowercase:",
            "            url_path = ':'.join((url_scheme, url_path))",
            "            url_scheme = 'file'",
            "",
            "        if url_scheme in ('file', ''):",
            "            # Local filesystem",
            "            if not os.path.isabs(url_path):",
            "                raise CommandExecutionError(",
            "                    'Path \\'{0}\\' is not absolute'.format(url_path)",
            "                )",
            "            if dest is None:",
            "                with salt.utils.fopen(url_path, 'r') as fp_:",
            "                    data = fp_.read()",
            "                return data",
            "            return url_path",
            "",
            "        if url_scheme == 'salt':",
            "            result = self.get_file(url, dest, makedirs, saltenv, cachedir=cachedir)",
            "            if result and dest is None:",
            "                with salt.utils.fopen(result, 'r') as fp_:",
            "                    data = fp_.read()",
            "                return data",
            "            return result",
            "",
            "        if dest:",
            "            destdir = os.path.dirname(dest)",
            "            if not os.path.isdir(destdir):",
            "                if makedirs:",
            "                    os.makedirs(destdir)",
            "                else:",
            "                    return ''",
            "        elif not no_cache:",
            "            dest = self._extrn_path(url, saltenv, cachedir=cachedir)",
            "            destdir = os.path.dirname(dest)",
            "            if not os.path.isdir(destdir):",
            "                os.makedirs(destdir)",
            "",
            "        if url_data.scheme == 's3':",
            "            try:",
            "                def s3_opt(key, default=None):",
            "                    '''Get value of s3.<key> from Minion config or from Pillar'''",
            "                    if 's3.' + key in self.opts:",
            "                        return self.opts['s3.' + key]",
            "                    try:",
            "                        return self.opts['pillar']['s3'][key]",
            "                    except (KeyError, TypeError):",
            "                        return default",
            "                self.utils['s3.query'](method='GET',",
            "                                       bucket=url_data.netloc,",
            "                                       path=url_data.path[1:],",
            "                                       return_bin=False,",
            "                                       local_file=dest,",
            "                                       action=None,",
            "                                       key=s3_opt('key'),",
            "                                       keyid=s3_opt('keyid'),",
            "                                       service_url=s3_opt('service_url'),",
            "                                       verify_ssl=s3_opt('verify_ssl', True),",
            "                                       location=s3_opt('location'))",
            "                return dest",
            "            except Exception as exc:",
            "                raise MinionError(",
            "                    'Could not fetch from {0}. Exception: {1}'.format(url, exc)",
            "                )",
            "        if url_data.scheme == 'ftp':",
            "            try:",
            "                ftp = ftplib.FTP(url_data.hostname)",
            "                ftp.login()",
            "                with salt.utils.fopen(dest, 'wb') as fp_:",
            "                    ftp.retrbinary('RETR {0}'.format(url_data.path), fp_.write)",
            "                return dest",
            "            except Exception as exc:",
            "                raise MinionError('Could not retrieve {0} from FTP server. Exception: {1}'.format(url, exc))",
            "",
            "        if url_data.scheme == 'swift':",
            "            try:",
            "                def swift_opt(key, default):",
            "                    '''Get value of <key> from Minion config or from Pillar'''",
            "                    if key in self.opts:",
            "                        return self.opts[key]",
            "                    try:",
            "                        return self.opts['pillar'][key]",
            "                    except (KeyError, TypeError):",
            "                        return default",
            "",
            "                swift_conn = SaltSwift(swift_opt('keystone.user', None),",
            "                                       swift_opt('keystone.tenant', None),",
            "                                       swift_opt('keystone.auth_url', None),",
            "                                       swift_opt('keystone.password', None))",
            "",
            "                swift_conn.get_object(url_data.netloc,",
            "                                      url_data.path[1:],",
            "                                      dest)",
            "                return dest",
            "            except Exception:",
            "                raise MinionError('Could not fetch from {0}'.format(url))",
            "",
            "        get_kwargs = {}",
            "        if url_data.username is not None \\",
            "                and url_data.scheme in ('http', 'https'):",
            "            netloc = url_data.netloc",
            "            at_sign_pos = netloc.rfind('@')",
            "            if at_sign_pos != -1:",
            "                netloc = netloc[at_sign_pos + 1:]",
            "            fixed_url = urlunparse(",
            "                (url_data.scheme, netloc, url_data.path,",
            "                 url_data.params, url_data.query, url_data.fragment))",
            "            get_kwargs['auth'] = (url_data.username, url_data.password)",
            "        else:",
            "            fixed_url = url",
            "",
            "        destfp = None",
            "        try:",
            "            # Tornado calls streaming_callback on redirect response bodies.",
            "            # But we need streaming to support fetching large files (> RAM avail).",
            "            # Here we working this around by disabling recording the body for redirections.",
            "            # The issue is fixed in Tornado 4.3.0 so on_header callback could be removed",
            "            # when we'll deprecate Tornado<4.3.0.",
            "            # See #27093 and #30431 for details.",
            "",
            "            # Use list here to make it writable inside the on_header callback. Simple bool doesn't",
            "            # work here: on_header creates a new local variable instead. This could be avoided in",
            "            # Py3 with 'nonlocal' statement. There is no Py2 alternative for this.",
            "            write_body = [False]",
            "",
            "            def on_header(hdr):",
            "                try:",
            "                    hdr = parse_response_start_line(hdr)",
            "                except HTTPInputError:",
            "                    # Not the first line, do nothing",
            "                    return",
            "                write_body[0] = hdr.code not in [301, 302, 303, 307]",
            "",
            "            if no_cache:",
            "                result = []",
            "",
            "                def on_chunk(chunk):",
            "                    if write_body[0]:",
            "                        result.append(chunk)",
            "            else:",
            "                dest_tmp = \"{0}.part\".format(dest)",
            "                # We need an open filehandle to use in the on_chunk callback,",
            "                # that's why we're not using a with clause here.",
            "                destfp = salt.utils.fopen(dest_tmp, 'wb')",
            "",
            "                def on_chunk(chunk):",
            "                    if write_body[0]:",
            "                        destfp.write(chunk)",
            "",
            "            query = salt.utils.http.query(",
            "                fixed_url,",
            "                stream=True,",
            "                streaming_callback=on_chunk,",
            "                header_callback=on_header,",
            "                username=url_data.username,",
            "                password=url_data.password,",
            "                opts=self.opts,",
            "                **get_kwargs",
            "            )",
            "            if 'handle' not in query:",
            "                raise MinionError('Error: {0} reading {1}'.format(query['error'], url))",
            "            if no_cache:",
            "                return ''.join(result)",
            "            else:",
            "                destfp.close()",
            "                destfp = None",
            "                salt.utils.files.rename(dest_tmp, dest)",
            "                return dest",
            "        except HTTPError as exc:",
            "            raise MinionError('HTTP error {0} reading {1}: {3}'.format(",
            "                exc.code,",
            "                url,",
            "                *BaseHTTPServer.BaseHTTPRequestHandler.responses[exc.code]))",
            "        except URLError as exc:",
            "            raise MinionError('Error reading {0}: {1}'.format(url, exc.reason))",
            "        finally:",
            "            if destfp is not None:",
            "                destfp.close()",
            "",
            "    def get_template(",
            "            self,",
            "            url,",
            "            dest,",
            "            template='jinja',",
            "            makedirs=False,",
            "            saltenv='base',",
            "            cachedir=None,",
            "            **kwargs):",
            "        '''",
            "        Cache a file then process it as a template",
            "        '''",
            "        if 'env' in kwargs:",
            "            salt.utils.warn_until(",
            "                'Oxygen',",
            "                'Parameter \\'env\\' has been detected in the argument list.  This '",
            "                'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "                'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "                )",
            "            kwargs.pop('env')",
            "",
            "        kwargs['saltenv'] = saltenv",
            "        url_data = urlparse(url)",
            "        sfn = self.cache_file(url, saltenv, cachedir=cachedir)",
            "        if not os.path.exists(sfn):",
            "            return ''",
            "        if template in salt.utils.templates.TEMPLATE_REGISTRY:",
            "            data = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "                sfn,",
            "                **kwargs",
            "            )",
            "        else:",
            "            log.error('Attempted to render template with unavailable engine '",
            "                      '{0}'.format(template))",
            "            return ''",
            "        if not data['result']:",
            "            # Failed to render the template",
            "            log.error(",
            "                'Failed to render template with error: {0}'.format(",
            "                    data['data']",
            "                )",
            "            )",
            "            return ''",
            "        if not dest:",
            "            # No destination passed, set the dest as an extrn_files cache",
            "            dest = self._extrn_path(url, saltenv, cachedir=cachedir)",
            "            # If Salt generated the dest name, create any required dirs",
            "            makedirs = True",
            "",
            "        destdir = os.path.dirname(dest)",
            "        if not os.path.isdir(destdir):",
            "            if makedirs:",
            "                os.makedirs(destdir)",
            "            else:",
            "                salt.utils.safe_rm(data['data'])",
            "                return ''",
            "        shutil.move(data['data'], dest)",
            "        return dest",
            "",
            "    def _extrn_path(self, url, saltenv, cachedir=None):",
            "        '''",
            "        Return the extn_filepath for a given url",
            "        '''",
            "        url_data = urlparse(url)",
            "        if salt.utils.is_windows():",
            "            netloc = salt.utils.sanitize_win_path_string(url_data.netloc)",
            "        else:",
            "            netloc = url_data.netloc",
            "",
            "        # Strip user:pass from URLs",
            "        netloc = netloc.split('@')[-1]",
            "",
            "        if cachedir is None:",
            "            cachedir = self.opts['cachedir']",
            "        elif not os.path.isabs(cachedir):",
            "            cachedir = os.path.join(self.opts['cachedir'], cachedir)",
            "",
            "        if url_data.query:",
            "            file_name = '-'.join([url_data.path, url_data.query])",
            "        else:",
            "            file_name = url_data.path",
            "",
            "        return salt.utils.path_join(",
            "            cachedir,",
            "            'extrn_files',",
            "            saltenv,",
            "            netloc,",
            "            file_name",
            "        )",
            "",
            "",
            "class LocalClient(Client):",
            "    '''",
            "    Use the local_roots option to parse a local file root",
            "    '''",
            "    def __init__(self, opts):",
            "        Client.__init__(self, opts)",
            "",
            "    def _find_file(self, path, saltenv='base'):",
            "        '''",
            "        Locate the file path",
            "        '''",
            "        fnd = {'path': '',",
            "               'rel': ''}",
            "",
            "        if saltenv not in self.opts['file_roots']:",
            "            return fnd",
            "        if salt.utils.url.is_escaped(path):",
            "            # The path arguments are escaped",
            "            path = salt.utils.url.unescape(path)",
            "        for root in self.opts['file_roots'][saltenv]:",
            "            full = os.path.join(root, path)",
            "            if os.path.isfile(full):",
            "                fnd['path'] = full",
            "                fnd['rel'] = path",
            "                return fnd",
            "        return fnd",
            "",
            "    def get_file(self,",
            "                 path,",
            "                 dest='',",
            "                 makedirs=False,",
            "                 saltenv='base',",
            "                 gzip=None,",
            "                 cachedir=None):",
            "        '''",
            "        Copies a file from the local files directory into :param:`dest`",
            "        gzip compression settings are ignored for local files",
            "        '''",
            "        path = self._check_proto(path)",
            "        fnd = self._find_file(path, saltenv)",
            "        fnd_path = fnd.get('path')",
            "        if not fnd_path:",
            "            return ''",
            "",
            "        return fnd_path",
            "",
            "    def file_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        Return a list of files in the given environment",
            "        with optional relative prefix path to limit directory traversal",
            "        '''",
            "        ret = []",
            "        if saltenv not in self.opts['file_roots']:",
            "            return ret",
            "        prefix = prefix.strip('/')",
            "        for path in self.opts['file_roots'][saltenv]:",
            "            for root, dirs, files in os.walk(",
            "                os.path.join(path, prefix), followlinks=True",
            "            ):",
            "                # Don't walk any directories that match file_ignore_regex or glob",
            "                dirs[:] = [d for d in dirs if not salt.fileserver.is_file_ignored(self.opts, d)]",
            "                for fname in files:",
            "                    relpath = os.path.relpath(os.path.join(root, fname), path)",
            "                    ret.append(sdecode(relpath))",
            "        return ret",
            "",
            "    def file_list_emptydirs(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the empty dirs in the file_roots",
            "        with optional relative prefix path to limit directory traversal",
            "        '''",
            "        ret = []",
            "        prefix = prefix.strip('/')",
            "        if saltenv not in self.opts['file_roots']:",
            "            return ret",
            "        for path in self.opts['file_roots'][saltenv]:",
            "            for root, dirs, files in os.walk(",
            "                os.path.join(path, prefix), followlinks=True",
            "            ):",
            "                # Don't walk any directories that match file_ignore_regex or glob",
            "                dirs[:] = [d for d in dirs if not salt.fileserver.is_file_ignored(self.opts, d)]",
            "                if len(dirs) == 0 and len(files) == 0:",
            "                    ret.append(sdecode(os.path.relpath(root, path)))",
            "        return ret",
            "",
            "    def dir_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the dirs in the file_roots",
            "        with optional relative prefix path to limit directory traversal",
            "        '''",
            "        ret = []",
            "        if saltenv not in self.opts['file_roots']:",
            "            return ret",
            "        prefix = prefix.strip('/')",
            "        for path in self.opts['file_roots'][saltenv]:",
            "            for root, dirs, files in os.walk(",
            "                os.path.join(path, prefix), followlinks=True",
            "            ):",
            "                ret.append(sdecode(os.path.relpath(root, path)))",
            "        return ret",
            "",
            "    def __get_file_path(self, path, saltenv='base'):",
            "        '''",
            "        Return either a file path or the result of a remote find_file call.",
            "        '''",
            "        try:",
            "            path = self._check_proto(path)",
            "        except MinionError as err:",
            "            # Local file path",
            "            if not os.path.isfile(path):",
            "                msg = 'specified file {0} is not present to generate hash: {1}'",
            "                log.warning(msg.format(path, err))",
            "                return None",
            "            else:",
            "                return path",
            "        return self._find_file(path, saltenv)",
            "",
            "    def hash_file(self, path, saltenv='base'):",
            "        '''",
            "        Return the hash of a file, to get the hash of a file in the file_roots",
            "        prepend the path with salt://<file on server> otherwise, prepend the",
            "        file with / for a local file.",
            "        '''",
            "        ret = {}",
            "        fnd = self.__get_file_path(path, saltenv)",
            "        if fnd is None:",
            "            return ret",
            "",
            "        try:",
            "            # Remote file path (self._find_file() invoked)",
            "            fnd_path = fnd['path']",
            "        except TypeError:",
            "            # Local file path",
            "            fnd_path = fnd",
            "",
            "        hash_type = self.opts.get('hash_type', 'md5')",
            "        ret['hsum'] = salt.utils.get_hash(fnd_path, form=hash_type)",
            "        ret['hash_type'] = hash_type",
            "        return ret",
            "",
            "    def hash_and_stat_file(self, path, saltenv='base'):",
            "        '''",
            "        Return the hash of a file, to get the hash of a file in the file_roots",
            "        prepend the path with salt://<file on server> otherwise, prepend the",
            "        file with / for a local file.",
            "",
            "        Additionally, return the stat result of the file, or None if no stat",
            "        results were found.",
            "        '''",
            "        ret = {}",
            "        fnd = self.__get_file_path(path, saltenv)",
            "        if fnd is None:",
            "            return ret, None",
            "",
            "        try:",
            "            # Remote file path (self._find_file() invoked)",
            "            fnd_path = fnd['path']",
            "            fnd_stat = fnd.get('stat')",
            "        except TypeError:",
            "            # Local file path",
            "            fnd_path = fnd",
            "            try:",
            "                fnd_stat = list(os.stat(fnd_path))",
            "            except Exception:",
            "                fnd_stat = None",
            "",
            "        hash_type = self.opts.get('hash_type', 'md5')",
            "        ret['hsum'] = salt.utils.get_hash(fnd_path, form=hash_type)",
            "        ret['hash_type'] = hash_type",
            "        return ret, fnd_stat",
            "",
            "    def list_env(self, saltenv='base'):",
            "        '''",
            "        Return a list of the files in the file server's specified environment",
            "        '''",
            "        return self.file_list(saltenv)",
            "",
            "    def master_opts(self):",
            "        '''",
            "        Return the master opts data",
            "        '''",
            "        return self.opts",
            "",
            "    def envs(self):",
            "        '''",
            "        Return the available environments",
            "        '''",
            "        ret = []",
            "        for saltenv in self.opts['file_roots']:",
            "            ret.append(saltenv)",
            "        return ret",
            "",
            "    def ext_nodes(self):",
            "        '''",
            "        Originally returned information via the external_nodes subsystem.",
            "        External_nodes was deprecated and removed in",
            "        2014.1.6 in favor of master_tops (which had been around since pre-0.17).",
            "             salt-call --local state.show_top",
            "        ends up here, but master_tops has not been extended to support",
            "        show_top in a completely local environment yet.  It's worth noting",
            "        that originally this fn started with",
            "            if 'external_nodes' not in opts: return {}",
            "        So since external_nodes is gone now, we are just returning the",
            "        empty dict.",
            "        '''",
            "        return {}",
            "",
            "",
            "class RemoteClient(Client):",
            "    '''",
            "    Interact with the salt master file server.",
            "    '''",
            "    def __init__(self, opts):",
            "        Client.__init__(self, opts)",
            "        self.channel = salt.transport.Channel.factory(self.opts)",
            "        if hasattr(self.channel, 'auth'):",
            "            self.auth = self.channel.auth",
            "        else:",
            "            self.auth = ''",
            "",
            "    def _refresh_channel(self):",
            "        '''",
            "        Reset the channel, in the event of an interruption",
            "        '''",
            "        self.channel = salt.transport.Channel.factory(self.opts)",
            "        return self.channel",
            "",
            "    def get_file(self,",
            "                 path,",
            "                 dest='',",
            "                 makedirs=False,",
            "                 saltenv='base',",
            "                 gzip=None,",
            "                 cachedir=None):",
            "        '''",
            "        Get a single file from the salt-master",
            "        path must be a salt server location, aka, salt://path/to/file, if",
            "        dest is omitted, then the downloaded file will be placed in the minion",
            "        cache",
            "        '''",
            "        path, senv = salt.utils.url.split_env(path)",
            "        if senv:",
            "            saltenv = senv",
            "",
            "        if not salt.utils.is_windows():",
            "            hash_server, stat_server = self.hash_and_stat_file(path, saltenv)",
            "            try:",
            "                mode_server = stat_server[0]",
            "            except (IndexError, TypeError):",
            "                mode_server = None",
            "        else:",
            "            hash_server = self.hash_file(path, saltenv)",
            "            mode_server = None",
            "",
            "        # Check if file exists on server, before creating files and",
            "        # directories",
            "        if hash_server == '':",
            "            log.debug(",
            "                'Could not find file \\'%s\\' in saltenv \\'%s\\'',",
            "                path, saltenv",
            "            )",
            "            return False",
            "",
            "        # Hash compare local copy with master and skip download",
            "        # if no difference found.",
            "        dest2check = dest",
            "        if not dest2check:",
            "            rel_path = self._check_proto(path)",
            "",
            "            log.debug(",
            "                'In saltenv \\'%s\\', looking at rel_path \\'%s\\' to resolve '",
            "                '\\'%s\\'', saltenv, rel_path, path",
            "            )",
            "            with self._cache_loc(",
            "                    rel_path, saltenv, cachedir=cachedir) as cache_dest:",
            "                dest2check = cache_dest",
            "",
            "        log.debug(",
            "            'In saltenv \\'%s\\', ** considering ** path \\'%s\\' to resolve '",
            "            '\\'%s\\'', saltenv, dest2check, path",
            "        )",
            "",
            "        if dest2check and os.path.isfile(dest2check):",
            "            if not salt.utils.is_windows():",
            "                hash_local, stat_local = \\",
            "                    self.hash_and_stat_file(dest2check, saltenv)",
            "                try:",
            "                    mode_local = stat_local[0]",
            "                except (IndexError, TypeError):",
            "                    mode_local = None",
            "            else:",
            "                hash_local = self.hash_file(dest2check, saltenv)",
            "                mode_local = None",
            "",
            "            if hash_local == hash_server:",
            "                return dest2check",
            "",
            "        log.debug(",
            "            'Fetching file from saltenv \\'%s\\', ** attempting ** \\'%s\\'',",
            "            saltenv, path",
            "        )",
            "        d_tries = 0",
            "        transport_tries = 0",
            "        path = self._check_proto(path)",
            "        load = {'path': path,",
            "                'saltenv': saltenv,",
            "                'cmd': '_serve_file'}",
            "        if gzip:",
            "            gzip = int(gzip)",
            "            load['gzip'] = gzip",
            "",
            "        fn_ = None",
            "        if dest:",
            "            destdir = os.path.dirname(dest)",
            "            if not os.path.isdir(destdir):",
            "                if makedirs:",
            "                    os.makedirs(destdir)",
            "                else:",
            "                    return False",
            "            # We need an open filehandle here, that's why we're not using a",
            "            # with clause:",
            "            fn_ = salt.utils.fopen(dest, 'wb+')",
            "        else:",
            "            log.debug('No dest file found')",
            "",
            "        while True:",
            "            if not fn_:",
            "                load['loc'] = 0",
            "            else:",
            "                load['loc'] = fn_.tell()",
            "            data = self.channel.send(load, raw=True)",
            "            if six.PY3:",
            "                # Sometimes the source is local (eg when using",
            "                # 'salt.filesystem.FSChan'), in which case the keys are",
            "                # already strings. Sometimes the source is remote, in which",
            "                # case the keys are bytes due to raw mode. Standardize on",
            "                # strings for the top-level keys to simplify things.",
            "                data = decode_dict_keys_to_str(data)",
            "            try:",
            "                if not data['data']:",
            "                    if not fn_ and data['dest']:",
            "                        # This is a 0 byte file on the master",
            "                        with self._cache_loc(",
            "                                data['dest'],",
            "                                saltenv,",
            "                                cachedir=cachedir) as cache_dest:",
            "                            dest = cache_dest",
            "                            with salt.utils.fopen(cache_dest, 'wb+') as ofile:",
            "                                ofile.write(data['data'])",
            "                    if 'hsum' in data and d_tries < 3:",
            "                        # Master has prompted a file verification, if the",
            "                        # verification fails, re-download the file. Try 3 times",
            "                        d_tries += 1",
            "                        hsum = salt.utils.get_hash(dest, salt.utils.to_str(data.get('hash_type', b'md5')))",
            "                        if hsum != data['hsum']:",
            "                            log.warning(",
            "                                'Bad download of file %s, attempt %d of 3',",
            "                                path, d_tries",
            "                            )",
            "                            continue",
            "                    break",
            "                if not fn_:",
            "                    with self._cache_loc(",
            "                            data['dest'],",
            "                            saltenv,",
            "                            cachedir=cachedir) as cache_dest:",
            "                        dest = cache_dest",
            "                        # If a directory was formerly cached at this path, then",
            "                        # remove it to avoid a traceback trying to write the file",
            "                        if os.path.isdir(dest):",
            "                            salt.utils.rm_rf(dest)",
            "                        fn_ = salt.utils.fopen(dest, 'wb+')",
            "                if data.get('gzip', None):",
            "                    data = salt.utils.gzip_util.uncompress(data['data'])",
            "                else:",
            "                    data = data['data']",
            "                if six.PY3 and isinstance(data, str):",
            "                    data = data.encode()",
            "                fn_.write(data)",
            "            except (TypeError, KeyError) as exc:",
            "                try:",
            "                    data_type = type(data).__name__",
            "                except AttributeError:",
            "                    # Shouldn't happen, but don't let this cause a traceback.",
            "                    data_type = str(type(data))",
            "                transport_tries += 1",
            "                log.warning(",
            "                    'Data transport is broken, got: %s, type: %s, '",
            "                    'exception: %s, attempt %d of 3',",
            "                    data, data_type, exc, transport_tries",
            "                )",
            "                self._refresh_channel()",
            "                if transport_tries > 3:",
            "                    log.error(",
            "                        'Data transport is broken, got: %s, type: %s, '",
            "                        'exception: %s, retry attempts exhausted',",
            "                        data, data_type, exc",
            "                    )",
            "                    break",
            "",
            "        if fn_:",
            "            fn_.close()",
            "            log.info(",
            "                'Fetching file from saltenv \\'%s\\', ** done ** \\'%s\\'',",
            "                saltenv, path",
            "            )",
            "        else:",
            "            log.debug(",
            "                'In saltenv \\'%s\\', we are ** missing ** the file \\'%s\\'',",
            "                saltenv, path",
            "            )",
            "",
            "        return dest",
            "",
            "    def file_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the files on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_file_list'}",
            "",
            "        return [sdecode(fn_) for fn_ in self.channel.send(load)]",
            "",
            "    def file_list_emptydirs(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the empty dirs on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_file_list_emptydirs'}",
            "        self.channel.send(load)",
            "",
            "    def dir_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List the dirs on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_dir_list'}",
            "        return self.channel.send(load)",
            "",
            "    def symlink_list(self, saltenv='base', prefix=''):",
            "        '''",
            "        List symlinked files and dirs on the master",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'prefix': prefix,",
            "                'cmd': '_symlink_list'}",
            "        return self.channel.send(load)",
            "",
            "    def __hash_and_stat_file(self, path, saltenv='base'):",
            "        '''",
            "        Common code for hashing and stating files",
            "        '''",
            "        try:",
            "            path = self._check_proto(path)",
            "        except MinionError as err:",
            "            if not os.path.isfile(path):",
            "                msg = 'specified file {0} is not present to generate hash: {1}'",
            "                log.warning(msg.format(path, err))",
            "                return {}",
            "            else:",
            "                ret = {}",
            "                hash_type = self.opts.get('hash_type', 'md5')",
            "                ret['hsum'] = salt.utils.get_hash(path, form=hash_type)",
            "                ret['hash_type'] = hash_type",
            "                return ret",
            "        load = {'path': path,",
            "                'saltenv': saltenv,",
            "                'cmd': '_file_hash'}",
            "        return self.channel.send(load)",
            "",
            "    def hash_file(self, path, saltenv='base'):",
            "        '''",
            "        Return the hash of a file, to get the hash of a file on the salt",
            "        master file server prepend the path with salt://<file on server>",
            "        otherwise, prepend the file with / for a local file.",
            "        '''",
            "        return self.__hash_and_stat_file(path, saltenv)",
            "",
            "    def hash_and_stat_file(self, path, saltenv='base'):",
            "        '''",
            "        The same as hash_file, but also return the file's mode, or None if no",
            "        mode data is present.",
            "        '''",
            "        hash_result = self.hash_file(path, saltenv)",
            "        try:",
            "            path = self._check_proto(path)",
            "        except MinionError as err:",
            "            if not os.path.isfile(path):",
            "                return hash_result, None",
            "            else:",
            "                try:",
            "                    return hash_result, list(os.stat(path))",
            "                except Exception:",
            "                    return hash_result, None",
            "        load = {'path': path,",
            "                'saltenv': saltenv,",
            "                'cmd': '_file_find'}",
            "        fnd = self.channel.send(load)",
            "        try:",
            "            stat_result = fnd.get('stat')",
            "        except AttributeError:",
            "            stat_result = None",
            "        return hash_result, stat_result",
            "",
            "    def list_env(self, saltenv='base'):",
            "        '''",
            "        Return a list of the files in the file server's specified environment",
            "        '''",
            "        load = {'saltenv': saltenv,",
            "                'cmd': '_file_list'}",
            "        return self.channel.send(load)",
            "",
            "    def envs(self):",
            "        '''",
            "        Return a list of available environments",
            "        '''",
            "        load = {'cmd': '_file_envs'}",
            "        return self.channel.send(load)",
            "",
            "    def master_opts(self):",
            "        '''",
            "        Return the master opts data",
            "        '''",
            "        load = {'cmd': '_master_opts'}",
            "        return self.channel.send(load)",
            "",
            "    def ext_nodes(self):",
            "        '''",
            "        Return the metadata derived from the external nodes system on the",
            "        master.",
            "        '''",
            "        load = {'cmd': '_ext_nodes',",
            "                'id': self.opts['id'],",
            "                'opts': self.opts}",
            "        if self.auth:",
            "            load['tok'] = self.auth.gen_token('salt')",
            "        return self.channel.send(load)",
            "",
            "",
            "class FSClient(RemoteClient):",
            "    '''",
            "    A local client that uses the RemoteClient but substitutes the channel for",
            "    the FSChan object",
            "    '''",
            "    def __init__(self, opts):  # pylint: disable=W0231",
            "        Client.__init__(self, opts)  # pylint: disable=W0233",
            "        self.channel = salt.fileserver.FSChan(opts)",
            "        self.auth = DumbAuth()",
            "",
            "",
            "class DumbAuth(object):",
            "    '''",
            "    The dumbauth class is used to stub out auth calls fired from the FSClient",
            "    subsystem",
            "    '''",
            "    def gen_token(self, clear_tok):",
            "        return clear_tok"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "790": [
                "LocalClient",
                "get_file"
            ],
            "791": [
                "LocalClient",
                "get_file"
            ],
            "792": [
                "LocalClient",
                "get_file"
            ],
            "793": [
                "LocalClient",
                "get_file"
            ],
            "794": [
                "LocalClient",
                "get_file"
            ],
            "795": [
                "LocalClient",
                "get_file"
            ],
            "796": [
                "LocalClient",
                "get_file"
            ],
            "797": [
                "LocalClient",
                "get_file"
            ],
            "798": [
                "LocalClient",
                "get_file"
            ],
            "799": [
                "LocalClient",
                "get_file"
            ],
            "800": [
                "LocalClient",
                "get_file"
            ],
            "801": [
                "LocalClient",
                "get_file"
            ],
            "802": [
                "LocalClient",
                "get_file"
            ],
            "803": [
                "LocalClient",
                "get_file"
            ],
            "804": [
                "LocalClient",
                "get_file"
            ],
            "805": [
                "LocalClient",
                "get_file"
            ],
            "1057": [
                "RemoteClient",
                "get_file"
            ],
            "1058": [
                "RemoteClient",
                "get_file"
            ],
            "1059": [
                "RemoteClient",
                "get_file"
            ],
            "1060": [
                "RemoteClient",
                "get_file"
            ],
            "1061": [
                "RemoteClient",
                "get_file"
            ],
            "1062": [
                "RemoteClient",
                "get_file"
            ],
            "1063": [
                "RemoteClient",
                "get_file"
            ],
            "1064": [
                "RemoteClient",
                "get_file"
            ],
            "1065": [
                "RemoteClient",
                "get_file"
            ],
            "1066": [
                "RemoteClient",
                "get_file"
            ],
            "1067": [
                "RemoteClient",
                "get_file"
            ],
            "1068": [
                "RemoteClient",
                "get_file"
            ],
            "1069": [
                "RemoteClient",
                "get_file"
            ],
            "1070": [
                "RemoteClient",
                "get_file"
            ],
            "1071": [
                "RemoteClient",
                "get_file"
            ],
            "1072": [
                "RemoteClient",
                "get_file"
            ],
            "1073": [
                "RemoteClient",
                "get_file"
            ],
            "1074": [
                "RemoteClient",
                "get_file"
            ],
            "1075": [
                "RemoteClient",
                "get_file"
            ],
            "1076": [
                "RemoteClient",
                "get_file"
            ],
            "1077": [
                "RemoteClient",
                "get_file"
            ],
            "1078": [
                "RemoteClient",
                "get_file"
            ],
            "1079": [
                "RemoteClient",
                "get_file"
            ],
            "1080": [
                "RemoteClient",
                "get_file"
            ],
            "1081": [
                "RemoteClient",
                "get_file"
            ],
            "1082": [
                "RemoteClient",
                "get_file"
            ],
            "1083": [
                "RemoteClient",
                "get_file"
            ],
            "1084": [
                "RemoteClient",
                "get_file"
            ],
            "1085": [
                "RemoteClient",
                "get_file"
            ],
            "1086": [
                "RemoteClient",
                "get_file"
            ],
            "1087": [
                "RemoteClient",
                "get_file"
            ],
            "1088": [
                "RemoteClient",
                "get_file"
            ],
            "1089": [
                "RemoteClient",
                "get_file"
            ],
            "1090": [
                "RemoteClient",
                "get_file"
            ],
            "1091": [
                "RemoteClient",
                "get_file"
            ],
            "1092": [
                "RemoteClient",
                "get_file"
            ],
            "1093": [
                "RemoteClient",
                "get_file"
            ],
            "1094": [
                "RemoteClient",
                "get_file"
            ],
            "1095": [
                "RemoteClient",
                "get_file"
            ],
            "1096": [
                "RemoteClient",
                "get_file"
            ],
            "1097": [
                "RemoteClient",
                "get_file"
            ],
            "1214": [
                "RemoteClient",
                "get_file"
            ],
            "1215": [
                "RemoteClient",
                "get_file"
            ],
            "1216": [
                "RemoteClient",
                "get_file"
            ],
            "1217": [
                "RemoteClient",
                "get_file"
            ],
            "1218": [
                "RemoteClient",
                "get_file"
            ],
            "1219": [
                "RemoteClient",
                "get_file"
            ],
            "1220": [
                "RemoteClient",
                "get_file"
            ],
            "1221": [
                "RemoteClient",
                "get_file"
            ],
            "1222": [
                "RemoteClient",
                "get_file"
            ],
            "1223": [
                "RemoteClient",
                "get_file"
            ],
            "1224": [
                "RemoteClient",
                "get_file"
            ],
            "1225": [
                "RemoteClient",
                "get_file"
            ],
            "1226": [
                "RemoteClient",
                "get_file"
            ],
            "1227": [
                "RemoteClient",
                "get_file"
            ],
            "1228": [
                "RemoteClient",
                "get_file"
            ],
            "1229": [
                "RemoteClient",
                "get_file"
            ],
            "1230": [
                "RemoteClient",
                "get_file"
            ]
        },
        "addLocation": []
    },
    "salt/modules/cp.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 631,
                "PatchRowcode": "     return _client().hash_file(path, saltenv)"
            },
            "1": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 632,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 633,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 634,
                "PatchRowcode": "+def stat_file(path, saltenv='base', octal=True):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 635,
                "PatchRowcode": "+    '''"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 636,
                "PatchRowcode": "+    Return the permissions of a file, to get the permissions of a file on the"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 637,
                "PatchRowcode": "+    salt master file server prepend the path with salt://<file on server>"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 638,
                "PatchRowcode": "+    otherwise, prepend the file with / for a local file."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 640,
                "PatchRowcode": "+    CLI Example:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 641,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 642,
                "PatchRowcode": "+    .. code-block:: bash"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 643,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 644,
                "PatchRowcode": "+        salt '*' cp.stat_file salt://path/to/file"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 645,
                "PatchRowcode": "+    '''"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 646,
                "PatchRowcode": "+    path, senv = salt.utils.url.split_env(path)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 647,
                "PatchRowcode": "+    if senv:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 648,
                "PatchRowcode": "+        saltenv = senv"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 650,
                "PatchRowcode": "+    stat = _client().hash_and_stat_file(path, saltenv)[1]"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+    if stat is None:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 652,
                "PatchRowcode": "+        return stat"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 653,
                "PatchRowcode": "+    return salt.utils.st_mode_to_octal(stat[0]) if octal is True else stat[0]"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 634,
                "afterPatchRowNumber": 656,
                "PatchRowcode": " def push(path, keep_symlinks=False, upload_path=None, remove_source=False):"
            },
            "26": {
                "beforePatchRowNumber": 635,
                "afterPatchRowNumber": 657,
                "PatchRowcode": "     '''"
            },
            "27": {
                "beforePatchRowNumber": 636,
                "afterPatchRowNumber": 658,
                "PatchRowcode": "     WARNING Files pushed to the master will have global read permissions.."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Minion side functions for salt-cp",
            "'''",
            "",
            "# Import python libs",
            "from __future__ import absolute_import",
            "import os",
            "import logging",
            "import fnmatch",
            "",
            "# Import salt libs",
            "import salt.minion",
            "import salt.fileclient",
            "import salt.utils",
            "import salt.utils.url",
            "import salt.crypt",
            "import salt.transport",
            "from salt.exceptions import CommandExecutionError",
            "from salt.ext.six.moves.urllib.parse import urlparse as _urlparse  # pylint: disable=import-error,no-name-in-module",
            "",
            "# Import 3rd-party libs",
            "import salt.ext.six as six",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "__proxyenabled__ = ['*']",
            "",
            "",
            "def _auth():",
            "    '''",
            "    Return the auth object",
            "    '''",
            "    if 'auth' not in __context__:",
            "        __context__['auth'] = salt.crypt.SAuth(__opts__)",
            "    return __context__['auth']",
            "",
            "",
            "def _gather_pillar(pillarenv, pillar_override):",
            "    '''",
            "    Whenever a state run starts, gather the pillar data fresh",
            "    '''",
            "    pillar = salt.pillar.get_pillar(",
            "        __opts__,",
            "        __grains__,",
            "        __opts__['id'],",
            "        __opts__['environment'],",
            "        pillar=pillar_override,",
            "        pillarenv=pillarenv",
            "    )",
            "    ret = pillar.compile_pillar()",
            "    if pillar_override and isinstance(pillar_override, dict):",
            "        ret.update(pillar_override)",
            "    return ret",
            "",
            "",
            "def recv(files, dest):",
            "    '''",
            "    Used with salt-cp, pass the files dict, and the destination.",
            "",
            "    This function receives small fast copy files from the master via salt-cp.",
            "    It does not work via the CLI.",
            "    '''",
            "    ret = {}",
            "    for path, data in six.iteritems(files):",
            "        if os.path.basename(path) == os.path.basename(dest) \\",
            "                and not os.path.isdir(dest):",
            "            final = dest",
            "        elif os.path.isdir(dest):",
            "            final = os.path.join(dest, os.path.basename(path))",
            "        elif os.path.isdir(os.path.dirname(dest)):",
            "            final = dest",
            "        else:",
            "            return 'Destination unavailable'",
            "",
            "        try:",
            "            with salt.utils.fopen(final, 'w+') as fp_:",
            "                fp_.write(data)",
            "            ret[final] = True",
            "        except IOError:",
            "            ret[final] = False",
            "",
            "    return ret",
            "",
            "",
            "def _mk_client():",
            "    '''",
            "    Create a file client and add it to the context.",
            "",
            "    Each file client needs to correspond to a unique copy",
            "    of the opts dictionary, therefore it's hashed by the",
            "    id of the __opts__ dict",
            "    '''",
            "    if 'cp.fileclient_{0}'.format(id(__opts__)) not in __context__:",
            "        __context__['cp.fileclient_{0}'.format(id(__opts__))] = \\",
            "                salt.fileclient.get_file_client(__opts__)",
            "",
            "",
            "def _client():",
            "    '''",
            "    Return a client, hashed by the list of masters",
            "    '''",
            "    _mk_client()",
            "    return __context__['cp.fileclient_{0}'.format(id(__opts__))]",
            "",
            "",
            "def _render_filenames(path, dest, saltenv, template, **kw):",
            "    '''",
            "    Process markup in the :param:`path` and :param:`dest` variables (NOT the",
            "    files under the paths they ultimately point to) according to the markup",
            "    format provided by :param:`template`.",
            "    '''",
            "    if not template:",
            "        return (path, dest)",
            "",
            "    # render the path as a template using path_template_engine as the engine",
            "    if template not in salt.utils.templates.TEMPLATE_REGISTRY:",
            "        raise CommandExecutionError(",
            "            'Attempted to render file paths with unavailable engine '",
            "            '{0}'.format(template)",
            "        )",
            "",
            "    kwargs = {}",
            "    kwargs['salt'] = __salt__",
            "    if 'pillarenv' in kw or 'pillar' in kw:",
            "        pillarenv = kw.get('pillarenv', __opts__.get('pillarenv'))",
            "        kwargs['pillar'] = _gather_pillar(pillarenv, kw.get('pillar'))",
            "    else:",
            "        kwargs['pillar'] = __pillar__",
            "    kwargs['grains'] = __grains__",
            "    kwargs['opts'] = __opts__",
            "    kwargs['saltenv'] = saltenv",
            "",
            "    def _render(contents):",
            "        '''",
            "        Render :param:`contents` into a literal pathname by writing it to a",
            "        temp file, rendering that file, and returning the result.",
            "        '''",
            "        # write out path to temp file",
            "        tmp_path_fn = salt.utils.mkstemp()",
            "        with salt.utils.fopen(tmp_path_fn, 'w+') as fp_:",
            "            fp_.write(contents)",
            "        data = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "            tmp_path_fn,",
            "            to_str=True,",
            "            **kwargs",
            "        )",
            "        salt.utils.safe_rm(tmp_path_fn)",
            "        if not data['result']:",
            "            # Failed to render the template",
            "            raise CommandExecutionError(",
            "                'Failed to render file path with error: {0}'.format(",
            "                    data['data']",
            "                )",
            "            )",
            "        else:",
            "            return data['data']",
            "",
            "    path = _render(path)",
            "    dest = _render(dest)",
            "    return (path, dest)",
            "",
            "",
            "def get_file(path,",
            "             dest,",
            "             saltenv='base',",
            "             makedirs=False,",
            "             template=None,",
            "             gzip=None,",
            "             **kwargs):",
            "    '''",
            "    Used to get a single file from the salt master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file salt://path/to/file /minion/dest",
            "",
            "    Template rendering can be enabled on both the source and destination file",
            "    names like so:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file \"salt://{{grains.os}}/vimrc\" /etc/vimrc template=jinja",
            "",
            "    This example would instruct all Salt minions to download the vimrc from a",
            "    directory with the same name as their os grain and copy it to /etc/vimrc",
            "",
            "    For larger files, the cp.get_file module also supports gzip compression.",
            "    Because gzip is CPU-intensive, this should only be used in scenarios where",
            "    the compression ratio is very high (e.g. pretty-printed JSON or YAML",
            "    files).",
            "",
            "    Use the *gzip* named argument to enable it.  Valid values are 1..9, where 1",
            "    is the lightest compression and 9 the heaviest.  1 uses the least CPU on",
            "    the master (and minion), 9 uses the most.",
            "",
            "    There are two ways of defining the fileserver environment (a.k.a.",
            "    ``saltenv``) from which to retrieve the file. One is to use the ``saltenv``",
            "    parameter, and the other is to use a querystring syntax in the ``salt://``",
            "    URL. The below two examples are equivalent:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file salt://foo/bar.conf /etc/foo/bar.conf saltenv=config",
            "        salt '*' cp.get_file salt://foo/bar.conf?saltenv=config /etc/foo/bar.conf",
            "",
            "    .. note::",
            "        It may be necessary to quote the URL when using the querystring method,",
            "        depending on the shell being used to run the command.",
            "    '''",
            "    (path, dest) = _render_filenames(path, dest, saltenv, template, **kwargs)",
            "",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    if not hash_file(path, saltenv):",
            "        return ''",
            "    else:",
            "        return _client().get_file(",
            "                path,",
            "                dest,",
            "                makedirs,",
            "                saltenv,",
            "                gzip)",
            "",
            "",
            "def get_template(path,",
            "                 dest,",
            "                 template='jinja',",
            "                 saltenv='base',",
            "                 makedirs=False,",
            "                 **kwargs):",
            "    '''",
            "    Render a file as a template before setting it down.",
            "    Warning, order is not the same as in fileclient.cp for",
            "    non breaking old API.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_template salt://path/to/template /minion/dest",
            "    '''",
            "    if 'salt' not in kwargs:",
            "        kwargs['salt'] = __salt__",
            "    if 'pillar' not in kwargs:",
            "        kwargs['pillar'] = __pillar__",
            "    if 'grains' not in kwargs:",
            "        kwargs['grains'] = __grains__",
            "    if 'opts' not in kwargs:",
            "        kwargs['opts'] = __opts__",
            "    return _client().get_template(",
            "            path,",
            "            dest,",
            "            template,",
            "            makedirs,",
            "            saltenv,",
            "            **kwargs)",
            "",
            "",
            "def get_dir(path, dest, saltenv='base', template=None, gzip=None, **kwargs):",
            "    '''",
            "    Used to recursively copy a directory from the salt master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_dir salt://path/to/dir/ /minion/dest",
            "",
            "    get_dir supports the same template and gzip arguments as get_file.",
            "    '''",
            "    (path, dest) = _render_filenames(path, dest, saltenv, template, **kwargs)",
            "",
            "    return _client().get_dir(path, dest, saltenv, gzip)",
            "",
            "",
            "def get_url(path, dest='', saltenv='base', makedirs=False):",
            "    '''",
            "    Used to get a single file from a URL.",
            "",
            "    path",
            "        A URL to download a file from. Supported URL schemes are: ``salt://``,",
            "        ``http://``, ``https://``, ``ftp://``, ``s3://``, ``swift://`` and",
            "        ``file://`` (local filesystem). If no scheme was specified, this is",
            "        equivalent of using ``file://``.",
            "        If a ``file://`` URL is given, the function just returns absolute path",
            "        to that file on a local filesystem.",
            "        The function returns ``False`` if Salt was unable to fetch a file from",
            "        a ``salt://`` URL.",
            "",
            "    dest",
            "        The default behaviour is to write the fetched file to the given",
            "        destination path. If this parameter is omitted or set as empty string",
            "        (``''``), the function places the remote file on the local filesystem",
            "        inside the Minion cache directory and returns the path to that file.",
            "",
            "        .. note::",
            "",
            "            To simply return the file contents instead, set destination to",
            "            ``None``. This works with ``salt://``, ``http://``, ``https://``",
            "            and ``file://`` URLs. The files fetched by ``http://`` and",
            "            ``https://`` will not be cached.",
            "",
            "    saltenv : base",
            "        Salt fileserver envrionment from which to retrieve the file. Ignored if",
            "        ``path`` is not a ``salt://`` URL.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_url salt://my/file /tmp/this_file_is_mine",
            "        salt '*' cp.get_url http://www.slashdot.org /tmp/index.html",
            "    '''",
            "    if isinstance(dest, six.string_types):",
            "        result = _client().get_url(path, dest, makedirs, saltenv)",
            "    else:",
            "        result = _client().get_url(path, None, makedirs, saltenv, no_cache=True)",
            "    if not result:",
            "        log.error(",
            "            'Unable to fetch file {0} from saltenv {1}.'.format(",
            "                path, saltenv",
            "            )",
            "        )",
            "    return result",
            "",
            "",
            "def get_file_str(path, saltenv='base'):",
            "    '''",
            "    Download a file from a URL to the Minion cache directory and return the",
            "    contents of that file",
            "",
            "    Returns ``False`` if Salt was unable to cache a file from a URL.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file_str salt://my/file",
            "    '''",
            "    fn_ = cache_file(path, saltenv)",
            "    if isinstance(fn_, six.string_types):",
            "        with salt.utils.fopen(fn_, 'r') as fp_:",
            "            data = fp_.read()",
            "        return data",
            "    return fn_",
            "",
            "",
            "def cache_file(path, saltenv='base'):",
            "    '''",
            "    Used to cache a single file on the Minion",
            "",
            "    Returns the location of the new cached file on the Minion.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_file salt://path/to/file",
            "",
            "    There are two ways of defining the fileserver environment (a.k.a.",
            "    ``saltenv``) from which to cache the file. One is to use the ``saltenv``",
            "    parameter, and the other is to use a querystring syntax in the ``salt://``",
            "    URL. The below two examples are equivalent:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_file salt://foo/bar.conf saltenv=config",
            "        salt '*' cp.cache_file salt://foo/bar.conf?saltenv=config",
            "",
            "    If the path being cached is a ``salt://`` URI, and the path does not exist,",
            "    then ``False`` will be returned.",
            "",
            "    .. note::",
            "        It may be necessary to quote the URL when using the querystring method,",
            "        depending on the shell being used to run the command.",
            "    '''",
            "    contextkey = '{0}_|-{1}_|-{2}'.format('cp.cache_file', path, saltenv)",
            "    path_is_remote = _urlparse(path).scheme in ('http', 'https', 'ftp')",
            "    try:",
            "        if path_is_remote and contextkey in __context__:",
            "            # Prevent multiple caches in the same salt run. Affects remote URLs",
            "            # since the master won't know their hash, so the fileclient",
            "            # wouldn't be able to prevent multiple caches if we try to cache",
            "            # the remote URL more than once.",
            "            if os.path.isfile(__context__[contextkey]):",
            "                return __context__[contextkey]",
            "            else:",
            "                # File is in __context__ but no longer exists in the minion",
            "                # cache, get rid of the context key and re-cache below.",
            "                # Accounts for corner case where file is removed from minion",
            "                # cache between cp.cache_file calls in the same salt-run.",
            "                __context__.pop(contextkey)",
            "    except AttributeError:",
            "        pass",
            "",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    result = _client().cache_file(path, saltenv)",
            "    if not result:",
            "        log.error(",
            "            'Unable to cache file \\'{0}\\' from saltenv \\'{1}\\'.'.format(",
            "                path, saltenv",
            "            )",
            "        )",
            "    if path_is_remote:",
            "        # Cache was successful, store the result in __context__ to prevent",
            "        # multiple caches (see above).",
            "        __context__[contextkey] = result",
            "    return result",
            "",
            "",
            "def cache_files(paths, saltenv='base'):",
            "    '''",
            "    Used to gather many files from the Master, the gathered files will be",
            "    saved in the minion cachedir reflective to the paths retrieved from the",
            "    Master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_files salt://pathto/file1,salt://pathto/file1",
            "",
            "    There are two ways of defining the fileserver environment (a.k.a.",
            "    ``saltenv``) from which to cache the files. One is to use the ``saltenv``",
            "    parameter, and the other is to use a querystring syntax in the ``salt://``",
            "    URL. The below two examples are equivalent:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_files salt://foo/bar.conf,salt://foo/baz.conf saltenv=config",
            "        salt '*' cp.cache_files salt://foo/bar.conf?saltenv=config,salt://foo/baz.conf?saltenv=config",
            "",
            "    The querystring method is less useful when all files are being cached from",
            "    the same environment, but is a good way of caching files from multiple",
            "    different environments in the same command. For example, the below command",
            "    will cache the first file from the ``config1`` environment, and the second",
            "    one from the ``config2`` environment.",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_files salt://foo/bar.conf?saltenv=config1,salt://foo/bar.conf?saltenv=config2",
            "",
            "    .. note::",
            "        It may be necessary to quote the URL when using the querystring method,",
            "        depending on the shell being used to run the command.",
            "    '''",
            "    return _client().cache_files(paths, saltenv)",
            "",
            "",
            "def cache_dir(path, saltenv='base', include_empty=False, include_pat=None,",
            "              exclude_pat=None):",
            "    '''",
            "    Download and cache everything under a directory from the master",
            "",
            "",
            "    include_pat : None",
            "        Glob or regex to narrow down the files cached from the given path. If",
            "        matching with a regex, the regex must be prefixed with ``E@``,",
            "        otherwise the expression will be interpreted as a glob.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    exclude_pat : None",
            "        Glob or regex to exclude certain files from being cached from the given",
            "        path. If matching with a regex, the regex must be prefixed with ``E@``,",
            "        otherwise the expression will be interpreted as a glob.",
            "",
            "        .. note::",
            "",
            "            If used with ``include_pat``, files matching this pattern will be",
            "            excluded from the subset of files defined by ``include_pat``.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_dir salt://path/to/dir",
            "        salt '*' cp.cache_dir salt://path/to/dir include_pat='E@*.py$'",
            "    '''",
            "    return _client().cache_dir(",
            "        path, saltenv, include_empty, include_pat, exclude_pat",
            "    )",
            "",
            "",
            "def cache_master(saltenv='base'):",
            "    '''",
            "    Retrieve all of the files on the master and cache them locally",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_master",
            "    '''",
            "    return _client().cache_master(saltenv)",
            "",
            "",
            "def cache_local_file(path):",
            "    '''",
            "    Cache a local file on the minion in the localfiles cache",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_local_file /etc/hosts",
            "    '''",
            "    if not os.path.exists(path):",
            "        return ''",
            "",
            "    path_cached = is_cached(path)",
            "",
            "    # If the file has already been cached, return the path",
            "    if path_cached:",
            "        path_hash = hash_file(path)",
            "        path_cached_hash = hash_file(path_cached)",
            "",
            "        if path_hash['hsum'] == path_cached_hash['hsum']:",
            "            return path_cached",
            "",
            "    # The file hasn't been cached or has changed; cache it",
            "    return _client().cache_local_file(path)",
            "",
            "",
            "def list_states(saltenv='base'):",
            "    '''",
            "    List all of the available state modules in an environment",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_states",
            "    '''",
            "    return _client().list_states(saltenv)",
            "",
            "",
            "def list_master(saltenv='base', prefix=''):",
            "    '''",
            "    List all of the files stored on the master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_master",
            "    '''",
            "    return _client().file_list(saltenv, prefix)",
            "",
            "",
            "def list_master_dirs(saltenv='base', prefix=''):",
            "    '''",
            "    List all of the directories stored on the master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_master_dirs",
            "    '''",
            "    return _client().dir_list(saltenv, prefix)",
            "",
            "",
            "def list_master_symlinks(saltenv='base', prefix=''):",
            "    '''",
            "    List all of the symlinks stored on the master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_master_symlinks",
            "    '''",
            "    return _client().symlink_list(saltenv, prefix)",
            "",
            "",
            "def list_minion(saltenv='base'):",
            "    '''",
            "    List all of the files cached on the minion",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_minion",
            "    '''",
            "    return _client().file_local_list(saltenv)",
            "",
            "",
            "def is_cached(path, saltenv='base'):",
            "    '''",
            "    Return a boolean if the given path on the master has been cached on the",
            "    minion",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.is_cached salt://path/to/file",
            "    '''",
            "    return _client().is_cached(path, saltenv)",
            "",
            "",
            "def hash_file(path, saltenv='base'):",
            "    '''",
            "    Return the hash of a file, to get the hash of a file on the",
            "    salt master file server prepend the path with salt://<file on server>",
            "    otherwise, prepend the file with / for a local file.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.hash_file salt://path/to/file",
            "    '''",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    return _client().hash_file(path, saltenv)",
            "",
            "",
            "def push(path, keep_symlinks=False, upload_path=None, remove_source=False):",
            "    '''",
            "    WARNING Files pushed to the master will have global read permissions..",
            "",
            "    Push a file from the minion up to the master, the file will be saved to",
            "    the salt master in the master's minion files cachedir",
            "    (defaults to ``/var/cache/salt/master/minions/minion-id/files``)",
            "",
            "    Since this feature allows a minion to push a file up to the master server",
            "    it is disabled by default for security purposes. To enable, set",
            "    ``file_recv`` to ``True`` in the master configuration file, and restart the",
            "    master.",
            "",
            "    keep_symlinks",
            "        Keep the path value without resolving its canonical form",
            "",
            "    upload_path",
            "        Provide a different path inside the master's minion files cachedir",
            "",
            "    remove_source",
            "        Remove the source file on the minion",
            "",
            "        .. versionadded:: 2016.3.0",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.push /etc/fstab",
            "        salt '*' cp.push /etc/system-release keep_symlinks=True",
            "        salt '*' cp.push /etc/fstab upload_path='/new/path/fstab'",
            "        salt '*' cp.push /tmp/filename remove_source=True",
            "    '''",
            "    log.debug('Trying to copy \\'{0}\\' to master'.format(path))",
            "    if '../' in path or not os.path.isabs(path):",
            "        log.debug('Path must be absolute, returning False')",
            "        return False",
            "    if not keep_symlinks:",
            "        path = os.path.realpath(path)",
            "    if not os.path.isfile(path):",
            "        log.debug('Path failed os.path.isfile check, returning False')",
            "        return False",
            "    auth = _auth()",
            "",
            "    if upload_path:",
            "        if '../' in upload_path:",
            "            log.debug('Path must be absolute, returning False')",
            "            log.debug('Bad path: {0}'.format(upload_path))",
            "            return False",
            "        load_path = upload_path.lstrip(os.sep)",
            "    else:",
            "        load_path = path.lstrip(os.sep)",
            "    # Normalize the path. This does not eliminate",
            "    # the possibility that relative entries will still be present",
            "    load_path_normal = os.path.normpath(load_path)",
            "",
            "    # If this is Windows and a drive letter is present, remove it",
            "    load_path_split_drive = os.path.splitdrive(load_path_normal)[1]",
            "",
            "    # Finally, split the remaining path into a list for delivery to the master",
            "    load_path_list = [_f for _f in load_path_split_drive.split(os.sep) if _f]",
            "",
            "    load = {'cmd': '_file_recv',",
            "            'id': __opts__['id'],",
            "            'path': load_path_list,",
            "            'tok': auth.gen_token('salt')}",
            "    channel = salt.transport.Channel.factory(__opts__)",
            "    with salt.utils.fopen(path, 'rb') as fp_:",
            "        init_send = False",
            "        while True:",
            "            load['loc'] = fp_.tell()",
            "            load['data'] = fp_.read(__opts__['file_buffer_size'])",
            "            if not load['data'] and init_send:",
            "                if remove_source:",
            "                    try:",
            "                        salt.utils.rm_rf(path)",
            "                        log.debug('Removing source file \\'{0}\\''.format(path))",
            "                    except IOError:",
            "                        log.error('cp.push failed to remove file \\",
            "                                  \\'{0}\\''.format(path))",
            "                        return False",
            "                return True",
            "            ret = channel.send(load)",
            "            if not ret:",
            "                log.error('cp.push Failed transfer failed. Ensure master has '",
            "                          '\\'file_recv\\' set to \\'True\\' and that the file '",
            "                          'is not larger than the \\'file_recv_size_max\\' '",
            "                          'setting on the master.')",
            "                return ret",
            "            init_send = True",
            "",
            "",
            "def push_dir(path, glob=None, upload_path=None):",
            "    '''",
            "    Push a directory from the minion up to the master, the files will be saved",
            "    to the salt master in the master's minion files cachedir (defaults to",
            "    ``/var/cache/salt/master/minions/minion-id/files``).  It also has a glob",
            "    for matching specific files using globbing.",
            "",
            "    .. versionadded:: 2014.7.0",
            "",
            "    Since this feature allows a minion to push files up to the master server it",
            "    is disabled by default for security purposes. To enable, set ``file_recv``",
            "    to ``True`` in the master configuration file, and restart the master.",
            "",
            "    upload_path",
            "        Provide a different path and directory name inside the master's minion",
            "        files cachedir",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.push /usr/lib/mysql",
            "        salt '*' cp.push /usr/lib/mysql upload_path='/newmysql/path'",
            "        salt '*' cp.push_dir /etc/modprobe.d/ glob='*.conf'",
            "    '''",
            "    if '../' in path or not os.path.isabs(path):",
            "        return False",
            "    tmpupload_path = upload_path",
            "    path = os.path.realpath(path)",
            "    if os.path.isfile(path):",
            "        return push(path, upload_path=upload_path)",
            "    else:",
            "        filelist = []",
            "        for root, _, files in os.walk(path):",
            "            filelist += [os.path.join(root, tmpfile) for tmpfile in files]",
            "        if glob is not None:",
            "            filelist = [fi for fi in filelist if fnmatch.fnmatch(os.path.basename(fi), glob)]",
            "        if not filelist:",
            "            return False",
            "        for tmpfile in filelist:",
            "            if upload_path and tmpfile.startswith(path):",
            "                tmpupload_path = os.path.join(os.path.sep,",
            "                                              upload_path.strip(os.path.sep),",
            "                                              tmpfile.replace(path, '')",
            "                                              .strip(os.path.sep))",
            "            ret = push(tmpfile, upload_path=tmpupload_path)",
            "            if not ret:",
            "                return ret",
            "    return True"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Minion side functions for salt-cp",
            "'''",
            "",
            "# Import python libs",
            "from __future__ import absolute_import",
            "import os",
            "import logging",
            "import fnmatch",
            "",
            "# Import salt libs",
            "import salt.minion",
            "import salt.fileclient",
            "import salt.utils",
            "import salt.utils.url",
            "import salt.crypt",
            "import salt.transport",
            "from salt.exceptions import CommandExecutionError",
            "from salt.ext.six.moves.urllib.parse import urlparse as _urlparse  # pylint: disable=import-error,no-name-in-module",
            "",
            "# Import 3rd-party libs",
            "import salt.ext.six as six",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "__proxyenabled__ = ['*']",
            "",
            "",
            "def _auth():",
            "    '''",
            "    Return the auth object",
            "    '''",
            "    if 'auth' not in __context__:",
            "        __context__['auth'] = salt.crypt.SAuth(__opts__)",
            "    return __context__['auth']",
            "",
            "",
            "def _gather_pillar(pillarenv, pillar_override):",
            "    '''",
            "    Whenever a state run starts, gather the pillar data fresh",
            "    '''",
            "    pillar = salt.pillar.get_pillar(",
            "        __opts__,",
            "        __grains__,",
            "        __opts__['id'],",
            "        __opts__['environment'],",
            "        pillar=pillar_override,",
            "        pillarenv=pillarenv",
            "    )",
            "    ret = pillar.compile_pillar()",
            "    if pillar_override and isinstance(pillar_override, dict):",
            "        ret.update(pillar_override)",
            "    return ret",
            "",
            "",
            "def recv(files, dest):",
            "    '''",
            "    Used with salt-cp, pass the files dict, and the destination.",
            "",
            "    This function receives small fast copy files from the master via salt-cp.",
            "    It does not work via the CLI.",
            "    '''",
            "    ret = {}",
            "    for path, data in six.iteritems(files):",
            "        if os.path.basename(path) == os.path.basename(dest) \\",
            "                and not os.path.isdir(dest):",
            "            final = dest",
            "        elif os.path.isdir(dest):",
            "            final = os.path.join(dest, os.path.basename(path))",
            "        elif os.path.isdir(os.path.dirname(dest)):",
            "            final = dest",
            "        else:",
            "            return 'Destination unavailable'",
            "",
            "        try:",
            "            with salt.utils.fopen(final, 'w+') as fp_:",
            "                fp_.write(data)",
            "            ret[final] = True",
            "        except IOError:",
            "            ret[final] = False",
            "",
            "    return ret",
            "",
            "",
            "def _mk_client():",
            "    '''",
            "    Create a file client and add it to the context.",
            "",
            "    Each file client needs to correspond to a unique copy",
            "    of the opts dictionary, therefore it's hashed by the",
            "    id of the __opts__ dict",
            "    '''",
            "    if 'cp.fileclient_{0}'.format(id(__opts__)) not in __context__:",
            "        __context__['cp.fileclient_{0}'.format(id(__opts__))] = \\",
            "                salt.fileclient.get_file_client(__opts__)",
            "",
            "",
            "def _client():",
            "    '''",
            "    Return a client, hashed by the list of masters",
            "    '''",
            "    _mk_client()",
            "    return __context__['cp.fileclient_{0}'.format(id(__opts__))]",
            "",
            "",
            "def _render_filenames(path, dest, saltenv, template, **kw):",
            "    '''",
            "    Process markup in the :param:`path` and :param:`dest` variables (NOT the",
            "    files under the paths they ultimately point to) according to the markup",
            "    format provided by :param:`template`.",
            "    '''",
            "    if not template:",
            "        return (path, dest)",
            "",
            "    # render the path as a template using path_template_engine as the engine",
            "    if template not in salt.utils.templates.TEMPLATE_REGISTRY:",
            "        raise CommandExecutionError(",
            "            'Attempted to render file paths with unavailable engine '",
            "            '{0}'.format(template)",
            "        )",
            "",
            "    kwargs = {}",
            "    kwargs['salt'] = __salt__",
            "    if 'pillarenv' in kw or 'pillar' in kw:",
            "        pillarenv = kw.get('pillarenv', __opts__.get('pillarenv'))",
            "        kwargs['pillar'] = _gather_pillar(pillarenv, kw.get('pillar'))",
            "    else:",
            "        kwargs['pillar'] = __pillar__",
            "    kwargs['grains'] = __grains__",
            "    kwargs['opts'] = __opts__",
            "    kwargs['saltenv'] = saltenv",
            "",
            "    def _render(contents):",
            "        '''",
            "        Render :param:`contents` into a literal pathname by writing it to a",
            "        temp file, rendering that file, and returning the result.",
            "        '''",
            "        # write out path to temp file",
            "        tmp_path_fn = salt.utils.mkstemp()",
            "        with salt.utils.fopen(tmp_path_fn, 'w+') as fp_:",
            "            fp_.write(contents)",
            "        data = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "            tmp_path_fn,",
            "            to_str=True,",
            "            **kwargs",
            "        )",
            "        salt.utils.safe_rm(tmp_path_fn)",
            "        if not data['result']:",
            "            # Failed to render the template",
            "            raise CommandExecutionError(",
            "                'Failed to render file path with error: {0}'.format(",
            "                    data['data']",
            "                )",
            "            )",
            "        else:",
            "            return data['data']",
            "",
            "    path = _render(path)",
            "    dest = _render(dest)",
            "    return (path, dest)",
            "",
            "",
            "def get_file(path,",
            "             dest,",
            "             saltenv='base',",
            "             makedirs=False,",
            "             template=None,",
            "             gzip=None,",
            "             **kwargs):",
            "    '''",
            "    Used to get a single file from the salt master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file salt://path/to/file /minion/dest",
            "",
            "    Template rendering can be enabled on both the source and destination file",
            "    names like so:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file \"salt://{{grains.os}}/vimrc\" /etc/vimrc template=jinja",
            "",
            "    This example would instruct all Salt minions to download the vimrc from a",
            "    directory with the same name as their os grain and copy it to /etc/vimrc",
            "",
            "    For larger files, the cp.get_file module also supports gzip compression.",
            "    Because gzip is CPU-intensive, this should only be used in scenarios where",
            "    the compression ratio is very high (e.g. pretty-printed JSON or YAML",
            "    files).",
            "",
            "    Use the *gzip* named argument to enable it.  Valid values are 1..9, where 1",
            "    is the lightest compression and 9 the heaviest.  1 uses the least CPU on",
            "    the master (and minion), 9 uses the most.",
            "",
            "    There are two ways of defining the fileserver environment (a.k.a.",
            "    ``saltenv``) from which to retrieve the file. One is to use the ``saltenv``",
            "    parameter, and the other is to use a querystring syntax in the ``salt://``",
            "    URL. The below two examples are equivalent:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file salt://foo/bar.conf /etc/foo/bar.conf saltenv=config",
            "        salt '*' cp.get_file salt://foo/bar.conf?saltenv=config /etc/foo/bar.conf",
            "",
            "    .. note::",
            "        It may be necessary to quote the URL when using the querystring method,",
            "        depending on the shell being used to run the command.",
            "    '''",
            "    (path, dest) = _render_filenames(path, dest, saltenv, template, **kwargs)",
            "",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    if not hash_file(path, saltenv):",
            "        return ''",
            "    else:",
            "        return _client().get_file(",
            "                path,",
            "                dest,",
            "                makedirs,",
            "                saltenv,",
            "                gzip)",
            "",
            "",
            "def get_template(path,",
            "                 dest,",
            "                 template='jinja',",
            "                 saltenv='base',",
            "                 makedirs=False,",
            "                 **kwargs):",
            "    '''",
            "    Render a file as a template before setting it down.",
            "    Warning, order is not the same as in fileclient.cp for",
            "    non breaking old API.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_template salt://path/to/template /minion/dest",
            "    '''",
            "    if 'salt' not in kwargs:",
            "        kwargs['salt'] = __salt__",
            "    if 'pillar' not in kwargs:",
            "        kwargs['pillar'] = __pillar__",
            "    if 'grains' not in kwargs:",
            "        kwargs['grains'] = __grains__",
            "    if 'opts' not in kwargs:",
            "        kwargs['opts'] = __opts__",
            "    return _client().get_template(",
            "            path,",
            "            dest,",
            "            template,",
            "            makedirs,",
            "            saltenv,",
            "            **kwargs)",
            "",
            "",
            "def get_dir(path, dest, saltenv='base', template=None, gzip=None, **kwargs):",
            "    '''",
            "    Used to recursively copy a directory from the salt master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_dir salt://path/to/dir/ /minion/dest",
            "",
            "    get_dir supports the same template and gzip arguments as get_file.",
            "    '''",
            "    (path, dest) = _render_filenames(path, dest, saltenv, template, **kwargs)",
            "",
            "    return _client().get_dir(path, dest, saltenv, gzip)",
            "",
            "",
            "def get_url(path, dest='', saltenv='base', makedirs=False):",
            "    '''",
            "    Used to get a single file from a URL.",
            "",
            "    path",
            "        A URL to download a file from. Supported URL schemes are: ``salt://``,",
            "        ``http://``, ``https://``, ``ftp://``, ``s3://``, ``swift://`` and",
            "        ``file://`` (local filesystem). If no scheme was specified, this is",
            "        equivalent of using ``file://``.",
            "        If a ``file://`` URL is given, the function just returns absolute path",
            "        to that file on a local filesystem.",
            "        The function returns ``False`` if Salt was unable to fetch a file from",
            "        a ``salt://`` URL.",
            "",
            "    dest",
            "        The default behaviour is to write the fetched file to the given",
            "        destination path. If this parameter is omitted or set as empty string",
            "        (``''``), the function places the remote file on the local filesystem",
            "        inside the Minion cache directory and returns the path to that file.",
            "",
            "        .. note::",
            "",
            "            To simply return the file contents instead, set destination to",
            "            ``None``. This works with ``salt://``, ``http://``, ``https://``",
            "            and ``file://`` URLs. The files fetched by ``http://`` and",
            "            ``https://`` will not be cached.",
            "",
            "    saltenv : base",
            "        Salt fileserver envrionment from which to retrieve the file. Ignored if",
            "        ``path`` is not a ``salt://`` URL.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_url salt://my/file /tmp/this_file_is_mine",
            "        salt '*' cp.get_url http://www.slashdot.org /tmp/index.html",
            "    '''",
            "    if isinstance(dest, six.string_types):",
            "        result = _client().get_url(path, dest, makedirs, saltenv)",
            "    else:",
            "        result = _client().get_url(path, None, makedirs, saltenv, no_cache=True)",
            "    if not result:",
            "        log.error(",
            "            'Unable to fetch file {0} from saltenv {1}.'.format(",
            "                path, saltenv",
            "            )",
            "        )",
            "    return result",
            "",
            "",
            "def get_file_str(path, saltenv='base'):",
            "    '''",
            "    Download a file from a URL to the Minion cache directory and return the",
            "    contents of that file",
            "",
            "    Returns ``False`` if Salt was unable to cache a file from a URL.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.get_file_str salt://my/file",
            "    '''",
            "    fn_ = cache_file(path, saltenv)",
            "    if isinstance(fn_, six.string_types):",
            "        with salt.utils.fopen(fn_, 'r') as fp_:",
            "            data = fp_.read()",
            "        return data",
            "    return fn_",
            "",
            "",
            "def cache_file(path, saltenv='base'):",
            "    '''",
            "    Used to cache a single file on the Minion",
            "",
            "    Returns the location of the new cached file on the Minion.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_file salt://path/to/file",
            "",
            "    There are two ways of defining the fileserver environment (a.k.a.",
            "    ``saltenv``) from which to cache the file. One is to use the ``saltenv``",
            "    parameter, and the other is to use a querystring syntax in the ``salt://``",
            "    URL. The below two examples are equivalent:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_file salt://foo/bar.conf saltenv=config",
            "        salt '*' cp.cache_file salt://foo/bar.conf?saltenv=config",
            "",
            "    If the path being cached is a ``salt://`` URI, and the path does not exist,",
            "    then ``False`` will be returned.",
            "",
            "    .. note::",
            "        It may be necessary to quote the URL when using the querystring method,",
            "        depending on the shell being used to run the command.",
            "    '''",
            "    contextkey = '{0}_|-{1}_|-{2}'.format('cp.cache_file', path, saltenv)",
            "    path_is_remote = _urlparse(path).scheme in ('http', 'https', 'ftp')",
            "    try:",
            "        if path_is_remote and contextkey in __context__:",
            "            # Prevent multiple caches in the same salt run. Affects remote URLs",
            "            # since the master won't know their hash, so the fileclient",
            "            # wouldn't be able to prevent multiple caches if we try to cache",
            "            # the remote URL more than once.",
            "            if os.path.isfile(__context__[contextkey]):",
            "                return __context__[contextkey]",
            "            else:",
            "                # File is in __context__ but no longer exists in the minion",
            "                # cache, get rid of the context key and re-cache below.",
            "                # Accounts for corner case where file is removed from minion",
            "                # cache between cp.cache_file calls in the same salt-run.",
            "                __context__.pop(contextkey)",
            "    except AttributeError:",
            "        pass",
            "",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    result = _client().cache_file(path, saltenv)",
            "    if not result:",
            "        log.error(",
            "            'Unable to cache file \\'{0}\\' from saltenv \\'{1}\\'.'.format(",
            "                path, saltenv",
            "            )",
            "        )",
            "    if path_is_remote:",
            "        # Cache was successful, store the result in __context__ to prevent",
            "        # multiple caches (see above).",
            "        __context__[contextkey] = result",
            "    return result",
            "",
            "",
            "def cache_files(paths, saltenv='base'):",
            "    '''",
            "    Used to gather many files from the Master, the gathered files will be",
            "    saved in the minion cachedir reflective to the paths retrieved from the",
            "    Master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_files salt://pathto/file1,salt://pathto/file1",
            "",
            "    There are two ways of defining the fileserver environment (a.k.a.",
            "    ``saltenv``) from which to cache the files. One is to use the ``saltenv``",
            "    parameter, and the other is to use a querystring syntax in the ``salt://``",
            "    URL. The below two examples are equivalent:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_files salt://foo/bar.conf,salt://foo/baz.conf saltenv=config",
            "        salt '*' cp.cache_files salt://foo/bar.conf?saltenv=config,salt://foo/baz.conf?saltenv=config",
            "",
            "    The querystring method is less useful when all files are being cached from",
            "    the same environment, but is a good way of caching files from multiple",
            "    different environments in the same command. For example, the below command",
            "    will cache the first file from the ``config1`` environment, and the second",
            "    one from the ``config2`` environment.",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_files salt://foo/bar.conf?saltenv=config1,salt://foo/bar.conf?saltenv=config2",
            "",
            "    .. note::",
            "        It may be necessary to quote the URL when using the querystring method,",
            "        depending on the shell being used to run the command.",
            "    '''",
            "    return _client().cache_files(paths, saltenv)",
            "",
            "",
            "def cache_dir(path, saltenv='base', include_empty=False, include_pat=None,",
            "              exclude_pat=None):",
            "    '''",
            "    Download and cache everything under a directory from the master",
            "",
            "",
            "    include_pat : None",
            "        Glob or regex to narrow down the files cached from the given path. If",
            "        matching with a regex, the regex must be prefixed with ``E@``,",
            "        otherwise the expression will be interpreted as a glob.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    exclude_pat : None",
            "        Glob or regex to exclude certain files from being cached from the given",
            "        path. If matching with a regex, the regex must be prefixed with ``E@``,",
            "        otherwise the expression will be interpreted as a glob.",
            "",
            "        .. note::",
            "",
            "            If used with ``include_pat``, files matching this pattern will be",
            "            excluded from the subset of files defined by ``include_pat``.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_dir salt://path/to/dir",
            "        salt '*' cp.cache_dir salt://path/to/dir include_pat='E@*.py$'",
            "    '''",
            "    return _client().cache_dir(",
            "        path, saltenv, include_empty, include_pat, exclude_pat",
            "    )",
            "",
            "",
            "def cache_master(saltenv='base'):",
            "    '''",
            "    Retrieve all of the files on the master and cache them locally",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_master",
            "    '''",
            "    return _client().cache_master(saltenv)",
            "",
            "",
            "def cache_local_file(path):",
            "    '''",
            "    Cache a local file on the minion in the localfiles cache",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.cache_local_file /etc/hosts",
            "    '''",
            "    if not os.path.exists(path):",
            "        return ''",
            "",
            "    path_cached = is_cached(path)",
            "",
            "    # If the file has already been cached, return the path",
            "    if path_cached:",
            "        path_hash = hash_file(path)",
            "        path_cached_hash = hash_file(path_cached)",
            "",
            "        if path_hash['hsum'] == path_cached_hash['hsum']:",
            "            return path_cached",
            "",
            "    # The file hasn't been cached or has changed; cache it",
            "    return _client().cache_local_file(path)",
            "",
            "",
            "def list_states(saltenv='base'):",
            "    '''",
            "    List all of the available state modules in an environment",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_states",
            "    '''",
            "    return _client().list_states(saltenv)",
            "",
            "",
            "def list_master(saltenv='base', prefix=''):",
            "    '''",
            "    List all of the files stored on the master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_master",
            "    '''",
            "    return _client().file_list(saltenv, prefix)",
            "",
            "",
            "def list_master_dirs(saltenv='base', prefix=''):",
            "    '''",
            "    List all of the directories stored on the master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_master_dirs",
            "    '''",
            "    return _client().dir_list(saltenv, prefix)",
            "",
            "",
            "def list_master_symlinks(saltenv='base', prefix=''):",
            "    '''",
            "    List all of the symlinks stored on the master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_master_symlinks",
            "    '''",
            "    return _client().symlink_list(saltenv, prefix)",
            "",
            "",
            "def list_minion(saltenv='base'):",
            "    '''",
            "    List all of the files cached on the minion",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.list_minion",
            "    '''",
            "    return _client().file_local_list(saltenv)",
            "",
            "",
            "def is_cached(path, saltenv='base'):",
            "    '''",
            "    Return a boolean if the given path on the master has been cached on the",
            "    minion",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.is_cached salt://path/to/file",
            "    '''",
            "    return _client().is_cached(path, saltenv)",
            "",
            "",
            "def hash_file(path, saltenv='base'):",
            "    '''",
            "    Return the hash of a file, to get the hash of a file on the",
            "    salt master file server prepend the path with salt://<file on server>",
            "    otherwise, prepend the file with / for a local file.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.hash_file salt://path/to/file",
            "    '''",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    return _client().hash_file(path, saltenv)",
            "",
            "",
            "def stat_file(path, saltenv='base', octal=True):",
            "    '''",
            "    Return the permissions of a file, to get the permissions of a file on the",
            "    salt master file server prepend the path with salt://<file on server>",
            "    otherwise, prepend the file with / for a local file.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.stat_file salt://path/to/file",
            "    '''",
            "    path, senv = salt.utils.url.split_env(path)",
            "    if senv:",
            "        saltenv = senv",
            "",
            "    stat = _client().hash_and_stat_file(path, saltenv)[1]",
            "    if stat is None:",
            "        return stat",
            "    return salt.utils.st_mode_to_octal(stat[0]) if octal is True else stat[0]",
            "",
            "",
            "def push(path, keep_symlinks=False, upload_path=None, remove_source=False):",
            "    '''",
            "    WARNING Files pushed to the master will have global read permissions..",
            "",
            "    Push a file from the minion up to the master, the file will be saved to",
            "    the salt master in the master's minion files cachedir",
            "    (defaults to ``/var/cache/salt/master/minions/minion-id/files``)",
            "",
            "    Since this feature allows a minion to push a file up to the master server",
            "    it is disabled by default for security purposes. To enable, set",
            "    ``file_recv`` to ``True`` in the master configuration file, and restart the",
            "    master.",
            "",
            "    keep_symlinks",
            "        Keep the path value without resolving its canonical form",
            "",
            "    upload_path",
            "        Provide a different path inside the master's minion files cachedir",
            "",
            "    remove_source",
            "        Remove the source file on the minion",
            "",
            "        .. versionadded:: 2016.3.0",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.push /etc/fstab",
            "        salt '*' cp.push /etc/system-release keep_symlinks=True",
            "        salt '*' cp.push /etc/fstab upload_path='/new/path/fstab'",
            "        salt '*' cp.push /tmp/filename remove_source=True",
            "    '''",
            "    log.debug('Trying to copy \\'{0}\\' to master'.format(path))",
            "    if '../' in path or not os.path.isabs(path):",
            "        log.debug('Path must be absolute, returning False')",
            "        return False",
            "    if not keep_symlinks:",
            "        path = os.path.realpath(path)",
            "    if not os.path.isfile(path):",
            "        log.debug('Path failed os.path.isfile check, returning False')",
            "        return False",
            "    auth = _auth()",
            "",
            "    if upload_path:",
            "        if '../' in upload_path:",
            "            log.debug('Path must be absolute, returning False')",
            "            log.debug('Bad path: {0}'.format(upload_path))",
            "            return False",
            "        load_path = upload_path.lstrip(os.sep)",
            "    else:",
            "        load_path = path.lstrip(os.sep)",
            "    # Normalize the path. This does not eliminate",
            "    # the possibility that relative entries will still be present",
            "    load_path_normal = os.path.normpath(load_path)",
            "",
            "    # If this is Windows and a drive letter is present, remove it",
            "    load_path_split_drive = os.path.splitdrive(load_path_normal)[1]",
            "",
            "    # Finally, split the remaining path into a list for delivery to the master",
            "    load_path_list = [_f for _f in load_path_split_drive.split(os.sep) if _f]",
            "",
            "    load = {'cmd': '_file_recv',",
            "            'id': __opts__['id'],",
            "            'path': load_path_list,",
            "            'tok': auth.gen_token('salt')}",
            "    channel = salt.transport.Channel.factory(__opts__)",
            "    with salt.utils.fopen(path, 'rb') as fp_:",
            "        init_send = False",
            "        while True:",
            "            load['loc'] = fp_.tell()",
            "            load['data'] = fp_.read(__opts__['file_buffer_size'])",
            "            if not load['data'] and init_send:",
            "                if remove_source:",
            "                    try:",
            "                        salt.utils.rm_rf(path)",
            "                        log.debug('Removing source file \\'{0}\\''.format(path))",
            "                    except IOError:",
            "                        log.error('cp.push failed to remove file \\",
            "                                  \\'{0}\\''.format(path))",
            "                        return False",
            "                return True",
            "            ret = channel.send(load)",
            "            if not ret:",
            "                log.error('cp.push Failed transfer failed. Ensure master has '",
            "                          '\\'file_recv\\' set to \\'True\\' and that the file '",
            "                          'is not larger than the \\'file_recv_size_max\\' '",
            "                          'setting on the master.')",
            "                return ret",
            "            init_send = True",
            "",
            "",
            "def push_dir(path, glob=None, upload_path=None):",
            "    '''",
            "    Push a directory from the minion up to the master, the files will be saved",
            "    to the salt master in the master's minion files cachedir (defaults to",
            "    ``/var/cache/salt/master/minions/minion-id/files``).  It also has a glob",
            "    for matching specific files using globbing.",
            "",
            "    .. versionadded:: 2014.7.0",
            "",
            "    Since this feature allows a minion to push files up to the master server it",
            "    is disabled by default for security purposes. To enable, set ``file_recv``",
            "    to ``True`` in the master configuration file, and restart the master.",
            "",
            "    upload_path",
            "        Provide a different path and directory name inside the master's minion",
            "        files cachedir",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' cp.push /usr/lib/mysql",
            "        salt '*' cp.push /usr/lib/mysql upload_path='/newmysql/path'",
            "        salt '*' cp.push_dir /etc/modprobe.d/ glob='*.conf'",
            "    '''",
            "    if '../' in path or not os.path.isabs(path):",
            "        return False",
            "    tmpupload_path = upload_path",
            "    path = os.path.realpath(path)",
            "    if os.path.isfile(path):",
            "        return push(path, upload_path=upload_path)",
            "    else:",
            "        filelist = []",
            "        for root, _, files in os.walk(path):",
            "            filelist += [os.path.join(root, tmpfile) for tmpfile in files]",
            "        if glob is not None:",
            "            filelist = [fi for fi in filelist if fnmatch.fnmatch(os.path.basename(fi), glob)]",
            "        if not filelist:",
            "            return False",
            "        for tmpfile in filelist:",
            "            if upload_path and tmpfile.startswith(path):",
            "                tmpupload_path = os.path.join(os.path.sep,",
            "                                              upload_path.strip(os.path.sep),",
            "                                              tmpfile.replace(path, '')",
            "                                              .strip(os.path.sep))",
            "            ret = push(tmpfile, upload_path=tmpupload_path)",
            "            if not ret:",
            "                return ret",
            "    return True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "knowledge_repo.app.routes.comment"
        ]
    },
    "salt/modules/file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4349,
                "afterPatchRowNumber": 4349,
                "PatchRowcode": "             if _urlparse(source).scheme in ('salt', 'file') \\"
            },
            "1": {
                "beforePatchRowNumber": 4350,
                "afterPatchRowNumber": 4350,
                "PatchRowcode": "                     or source.startswith('/'):"
            },
            "2": {
                "beforePatchRowNumber": 4351,
                "afterPatchRowNumber": 4351,
                "PatchRowcode": "                 try:"
            },
            "3": {
                "beforePatchRowNumber": 4352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mode = salt.utils.st_mode_to_octal(os.stat(sfn).st_mode)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4352,
                "PatchRowcode": "+                    mode = __salt__['cp.stat_file'](source, saltenv=saltenv, octal=True)"
            },
            "5": {
                "beforePatchRowNumber": 4353,
                "afterPatchRowNumber": 4353,
                "PatchRowcode": "                 except Exception as exc:"
            },
            "6": {
                "beforePatchRowNumber": 4354,
                "afterPatchRowNumber": 4354,
                "PatchRowcode": "                     log.warning('Unable to stat %s: %s', sfn, exc)"
            },
            "7": {
                "beforePatchRowNumber": 4355,
                "afterPatchRowNumber": 4355,
                "PatchRowcode": "     changes = check_file_meta(name, sfn, source, source_sum, user,"
            },
            "8": {
                "beforePatchRowNumber": 4607,
                "afterPatchRowNumber": 4607,
                "PatchRowcode": "         a local file on the minion), the mode of the destination file will be"
            },
            "9": {
                "beforePatchRowNumber": 4608,
                "afterPatchRowNumber": 4608,
                "PatchRowcode": "         set to the mode of the source file."
            },
            "10": {
                "beforePatchRowNumber": 4609,
                "afterPatchRowNumber": 4609,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4610,
                "PatchRowcode": "+        .. note:: keep_mode does not work with salt-ssh."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4611,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4612,
                "PatchRowcode": "+            As a consequence of how the files are transfered to the minion, and"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4613,
                "PatchRowcode": "+            the inability to connect back to the master with salt-ssh, salt is"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4614,
                "PatchRowcode": "+            unable to stat the file as it exists on the fileserver and thus"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4615,
                "PatchRowcode": "+            cannot mirror the mode on the salt-ssh minion"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4616,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 4610,
                "afterPatchRowNumber": 4617,
                "PatchRowcode": "     CLI Example:"
            },
            "19": {
                "beforePatchRowNumber": 4611,
                "afterPatchRowNumber": 4618,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 4612,
                "afterPatchRowNumber": 4619,
                "PatchRowcode": "     .. code-block:: bash"
            },
            "21": {
                "beforePatchRowNumber": 4641,
                "afterPatchRowNumber": 4648,
                "PatchRowcode": "             if _urlparse(source).scheme in ('salt', 'file') \\"
            },
            "22": {
                "beforePatchRowNumber": 4642,
                "afterPatchRowNumber": 4649,
                "PatchRowcode": "                     or source.startswith('/'):"
            },
            "23": {
                "beforePatchRowNumber": 4643,
                "afterPatchRowNumber": 4650,
                "PatchRowcode": "                 try:"
            },
            "24": {
                "beforePatchRowNumber": 4644,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mode = salt.utils.st_mode_to_octal(os.stat(sfn).st_mode)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4651,
                "PatchRowcode": "+                    mode = __salt__['cp.stat_file'](source, saltenv=saltenv, octal=True)"
            },
            "26": {
                "beforePatchRowNumber": 4645,
                "afterPatchRowNumber": 4652,
                "PatchRowcode": "                 except Exception as exc:"
            },
            "27": {
                "beforePatchRowNumber": 4646,
                "afterPatchRowNumber": 4653,
                "PatchRowcode": "                     log.warning('Unable to stat %s: %s', sfn, exc)"
            },
            "28": {
                "beforePatchRowNumber": 4647,
                "afterPatchRowNumber": 4654,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Manage information about regular files, directories,",
            "and special files on the minion, set/read user,",
            "group, mode, and data",
            "'''",
            "",
            "# TODO: We should add the capability to do u+r type operations here",
            "# some time in the future",
            "",
            "from __future__ import absolute_import, print_function",
            "",
            "# Import python libs",
            "import datetime",
            "import difflib",
            "import errno",
            "import fileinput",
            "import fnmatch",
            "import itertools",
            "import logging",
            "import operator",
            "import os",
            "import re",
            "import shutil",
            "import stat",
            "import string",
            "import sys",
            "import tempfile",
            "import time",
            "import glob",
            "import hashlib",
            "import mmap",
            "from functools import reduce  # pylint: disable=redefined-builtin",
            "from collections import Iterable, Mapping",
            "",
            "# pylint: disable=import-error,no-name-in-module,redefined-builtin",
            "import salt.ext.six as six",
            "from salt.ext.six.moves import range, zip",
            "from salt.ext.six.moves.urllib.parse import urlparse as _urlparse",
            "# pylint: enable=import-error,no-name-in-module,redefined-builtin",
            "",
            "try:",
            "    import grp",
            "    import pwd",
            "except ImportError:",
            "    pass",
            "",
            "# Import salt libs",
            "import salt.utils",
            "import salt.utils.atomicfile",
            "import salt.utils.find",
            "import salt.utils.filebuffer",
            "import salt.utils.files",
            "import salt.utils.locales",
            "import salt.utils.templates",
            "import salt.utils.url",
            "from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError, get_error_message as _get_error_message",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "__func_alias__ = {",
            "    'makedirs_': 'makedirs'",
            "}",
            "",
            "HASHES = {",
            "    'sha512': 128,",
            "    'sha384': 96,",
            "    'sha256': 64,",
            "    'sha224': 56,",
            "    'sha1': 40,",
            "    'md5': 32,",
            "}",
            "HASHES_REVMAP = dict([(y, x) for x, y in six.iteritems(HASHES)])",
            "",
            "",
            "def __virtual__():",
            "    '''",
            "    Only work on POSIX-like systems",
            "    '''",
            "    # win_file takes care of windows",
            "    if salt.utils.is_windows():",
            "        return (False, 'The file execution module cannot be loaded: only available on non-Windows systems - use win_file instead.')",
            "    return True",
            "",
            "",
            "def __clean_tmp(sfn):",
            "    '''",
            "    Clean out a template temp file",
            "    '''",
            "    if sfn.startswith(os.path.join(tempfile.gettempdir(),",
            "                                   salt.utils.files.TEMPFILE_PREFIX)):",
            "        # Don't remove if it exists in file_roots (any saltenv)",
            "        all_roots = itertools.chain.from_iterable(",
            "                six.itervalues(__opts__['file_roots']))",
            "        in_roots = any(sfn.startswith(root) for root in all_roots)",
            "        # Only clean up files that exist",
            "        if os.path.exists(sfn) and not in_roots:",
            "            os.remove(sfn)",
            "",
            "",
            "def _error(ret, err_msg):",
            "    '''",
            "    Common function for setting error information for return dicts",
            "    '''",
            "    ret['result'] = False",
            "    ret['comment'] = err_msg",
            "    return ret",
            "",
            "",
            "def _binary_replace(old, new):",
            "    '''",
            "    This function does NOT do any diffing, it just checks the old and new files",
            "    to see if either is binary, and provides an appropriate string noting the",
            "    difference between the two files. If neither file is binary, an empty",
            "    string is returned.",
            "",
            "    This function should only be run AFTER it has been determined that the",
            "    files differ.",
            "    '''",
            "    old_isbin = not salt.utils.istextfile(old)",
            "    new_isbin = not salt.utils.istextfile(new)",
            "    if any((old_isbin, new_isbin)):",
            "        if all((old_isbin, new_isbin)):",
            "            return 'Replace binary file'",
            "        elif old_isbin:",
            "            return 'Replace binary file with text file'",
            "        elif new_isbin:",
            "            return 'Replace text file with binary file'",
            "    return ''",
            "",
            "",
            "def _get_bkroot():",
            "    '''",
            "    Get the location of the backup dir in the minion cache",
            "    '''",
            "    # Get the cachedir from the minion config",
            "    return os.path.join(__salt__['config.get']('cachedir'), 'file_backup')",
            "",
            "",
            "def _splitlines_preserving_trailing_newline(str):",
            "    '''",
            "    Returns a list of the lines in the string, breaking at line boundaries and",
            "    preserving a trailing newline (if present).",
            "",
            "    Essentially, this works like ``str.striplines(False)`` but preserves an",
            "    empty line at the end. This is equivalent to the following code:",
            "",
            "    .. code-block:: python",
            "",
            "        lines = str.splitlines()",
            "        if str.endswith('\\n') or str.endswith('\\r'):",
            "            lines.append('')",
            "    '''",
            "    lines = str.splitlines()",
            "    if str.endswith('\\n') or str.endswith('\\r'):",
            "        lines.append('')",
            "    return lines",
            "",
            "",
            "def gid_to_group(gid):",
            "    '''",
            "    Convert the group id to the group name on this system",
            "",
            "    gid",
            "        gid to convert to a group name",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.gid_to_group 0",
            "    '''",
            "    try:",
            "        gid = int(gid)",
            "    except ValueError:",
            "        # This is not an integer, maybe it's already the group name?",
            "        gid = group_to_gid(gid)",
            "",
            "    if gid == '':",
            "        # Don't even bother to feed it to grp",
            "        return ''",
            "",
            "    try:",
            "        return grp.getgrgid(gid).gr_name",
            "    except (KeyError, NameError):",
            "        # If group is not present, fall back to the gid.",
            "        return gid",
            "",
            "",
            "def group_to_gid(group):",
            "    '''",
            "    Convert the group to the gid on this system",
            "",
            "    group",
            "        group to convert to its gid",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.group_to_gid root",
            "    '''",
            "    if group is None:",
            "        return ''",
            "    try:",
            "        if isinstance(group, int):",
            "            return group",
            "        return grp.getgrnam(group).gr_gid",
            "    except KeyError:",
            "        return ''",
            "",
            "",
            "def get_gid(path, follow_symlinks=True):",
            "    '''",
            "    Return the id of the group that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the gid",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_gid /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('gid', -1)",
            "",
            "",
            "def get_group(path, follow_symlinks=True):",
            "    '''",
            "    Return the group that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the group",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_group /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('group', False)",
            "",
            "",
            "def uid_to_user(uid):",
            "    '''",
            "    Convert a uid to a user name",
            "",
            "    uid",
            "        uid to convert to a username",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.uid_to_user 0",
            "    '''",
            "    try:",
            "        return pwd.getpwuid(uid).pw_name",
            "    except (KeyError, NameError):",
            "        # If user is not present, fall back to the uid.",
            "        return uid",
            "",
            "",
            "def user_to_uid(user):",
            "    '''",
            "    Convert user name to a uid",
            "",
            "    user",
            "        user name to convert to its uid",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.user_to_uid root",
            "    '''",
            "    if user is None:",
            "        user = salt.utils.get_user()",
            "    try:",
            "        if isinstance(user, int):",
            "            return user",
            "        return pwd.getpwnam(user).pw_uid",
            "    except KeyError:",
            "        return ''",
            "",
            "",
            "def get_uid(path, follow_symlinks=True):",
            "    '''",
            "    Return the id of the user that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the uid",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_uid /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('uid', -1)",
            "",
            "",
            "def get_user(path, follow_symlinks=True):",
            "    '''",
            "    Return the user that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the user",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_user /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('user', False)",
            "",
            "",
            "def get_mode(path, follow_symlinks=True):",
            "    '''",
            "    Return the mode of a file",
            "",
            "    path",
            "        file or directory of which to get the mode",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_mode /etc/passwd",
            "",
            "    .. versionchanged:: 2014.1.0",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('mode', '')",
            "",
            "",
            "def set_mode(path, mode):",
            "    '''",
            "    Set the mode of a file",
            "",
            "    path",
            "        file or directory of which to set the mode",
            "",
            "    mode",
            "        mode to set the path to",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.set_mode /etc/passwd 0644",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    mode = str(mode).lstrip('0Oo')",
            "    if not mode:",
            "        mode = '0'",
            "    if not os.path.exists(path):",
            "        raise CommandExecutionError('{0}: File not found'.format(path))",
            "    try:",
            "        os.chmod(path, int(mode, 8))",
            "    except Exception:",
            "        return 'Invalid Mode ' + mode",
            "    return get_mode(path)",
            "",
            "",
            "def lchown(path, user, group):",
            "    '''",
            "    Chown a file, pass the file the desired user and group without following",
            "    symlinks.",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    user",
            "        user owner",
            "",
            "    group",
            "        group owner",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.chown /etc/passwd root root",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    uid = user_to_uid(user)",
            "    gid = group_to_gid(group)",
            "    err = ''",
            "    if uid == '':",
            "        if user:",
            "            err += 'User does not exist\\n'",
            "        else:",
            "            uid = -1",
            "    if gid == '':",
            "        if group:",
            "            err += 'Group does not exist\\n'",
            "        else:",
            "            gid = -1",
            "",
            "    return os.lchown(path, uid, gid)",
            "",
            "",
            "def chown(path, user, group):",
            "    '''",
            "    Chown a file, pass the file the desired user and group",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    user",
            "        user owner",
            "",
            "    group",
            "        group owner",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.chown /etc/passwd root root",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    uid = user_to_uid(user)",
            "    gid = group_to_gid(group)",
            "    err = ''",
            "    if uid == '':",
            "        if user:",
            "            err += 'User does not exist\\n'",
            "        else:",
            "            uid = -1",
            "    if gid == '':",
            "        if group:",
            "            err += 'Group does not exist\\n'",
            "        else:",
            "            gid = -1",
            "    if not os.path.exists(path):",
            "        try:",
            "            # Broken symlinks will return false, but still need to be chowned",
            "            return os.lchown(path, uid, gid)",
            "        except OSError:",
            "            pass",
            "        err += 'File not found'",
            "    if err:",
            "        return err",
            "    return os.chown(path, uid, gid)",
            "",
            "",
            "def chgrp(path, group):",
            "    '''",
            "    Change the group of a file",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    group",
            "        group owner",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.chgrp /etc/passwd root",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    user = get_user(path)",
            "    return chown(path, user, group)",
            "",
            "",
            "def get_sum(path, form='sha256'):",
            "    '''",
            "    Return the checksum for the given file. The following checksum algorithms",
            "    are supported:",
            "",
            "    * md5",
            "    * sha1",
            "    * sha224",
            "    * sha256 **(default)**",
            "    * sha384",
            "    * sha512",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    form",
            "        desired sum format",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_sum /etc/passwd sha512",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isfile(path):",
            "        return 'File not found'",
            "    return salt.utils.get_hash(path, form, 4096)",
            "",
            "",
            "def get_hash(path, form='sha256', chunk_size=65536):",
            "    '''",
            "    Get the hash sum of a file",
            "",
            "    This is better than ``get_sum`` for the following reasons:",
            "        - It does not read the entire file into memory.",
            "        - It does not return a string on error. The returned value of",
            "            ``get_sum`` cannot really be trusted since it is vulnerable to",
            "            collisions: ``get_sum(..., 'xyz') == 'Hash xyz not supported'``",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    form",
            "        desired sum format",
            "",
            "    chunk_size",
            "        amount to sum at once",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_hash /etc/shadow",
            "    '''",
            "    return salt.utils.get_hash(os.path.expanduser(path), form, chunk_size)",
            "",
            "",
            "def get_source_sum(file_name='',",
            "                   source='',",
            "                   source_hash=None,",
            "                   source_hash_name=None,",
            "                   saltenv='base'):",
            "    '''",
            "    .. versionadded:: 2016.11.0",
            "",
            "    Used by :py:func:`file.get_managed <salt.modules.file.get_managed>` to",
            "    obtain the hash and hash type from the parameters specified below.",
            "",
            "    file_name",
            "        Optional file name being managed, for matching with",
            "        :py:func:`file.extract_hash <salt.modules.file.extract_hash>`.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    source",
            "        Source file, as used in :py:mod:`file <salt.states.file>` and other",
            "        states. If ``source_hash`` refers to a file containing hashes, then",
            "        this filename will be used to match a filename in that file. If the",
            "        ``source_hash`` is a hash expression, then this argument will be",
            "        ignored.",
            "",
            "    source_hash",
            "        Hash file/expression, as used in :py:mod:`file <salt.states.file>` and",
            "        other states. If this value refers to a remote URL or absolute path to",
            "        a local file, it will be cached and :py:func:`file.extract_hash",
            "        <salt.modules.file.extract_hash>` will be used to obtain a hash from",
            "        it.",
            "",
            "    source_hash_name",
            "        Specific file name to look for when ``source_hash`` refers to a remote",
            "        file, used to disambiguate ambiguous matches.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    saltenv : base",
            "        Salt fileserver environment from which to retrive the source_hash. This",
            "        value will only be used when ``source_hash`` refers to a file on the",
            "        Salt fileserver (i.e. one beginning with ``salt://``).",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_source_sum /tmp/foo.tar.gz source=http://mydomain.tld/foo.tar.gz source_hash=499ae16dcae71eeb7c3a30c75ea7a1a6",
            "        salt '*' file.get_source_sum /tmp/foo.tar.gz source=http://mydomain.tld/foo.tar.gz source_hash=https://mydomain.tld/hashes.md5",
            "        salt '*' file.get_source_sum /tmp/foo.tar.gz source=http://mydomain.tld/foo.tar.gz source_hash=https://mydomain.tld/hashes.md5 source_hash_name=./dir2/foo.tar.gz",
            "    '''",
            "    def _invalid_source_hash_format():",
            "        '''",
            "        DRY helper for reporting invalid source_hash input",
            "        '''",
            "        raise CommandExecutionError(",
            "            'Source hash {0} format is invalid. The supported formats are: '",
            "            '1) a hash, 2) an expression in the format <hash_type>=<hash>, or '",
            "            '3) either a path to a local file containing hashes, or a URI of '",
            "            'a remote hash file. Supported protocols for remote hash files '",
            "            'are: {1}. The hash may also not be of a valid length, the '",
            "            'following are supported hash types and lengths: {2}.'.format(",
            "                source_hash,",
            "                ', '.join(salt.utils.files.VALID_PROTOS),",
            "                ', '.join(",
            "                    ['{0} ({1})'.format(HASHES_REVMAP[x], x)",
            "                     for x in sorted(HASHES_REVMAP)]",
            "                ),",
            "            )",
            "        )",
            "",
            "    hash_fn = None",
            "    if os.path.isabs(source_hash):",
            "        hash_fn = source_hash",
            "    else:",
            "        try:",
            "            proto = _urlparse(source_hash).scheme",
            "            if proto in salt.utils.files.VALID_PROTOS:",
            "                hash_fn = __salt__['cp.cache_file'](source_hash, saltenv)",
            "                if not hash_fn:",
            "                    raise CommandExecutionError(",
            "                        'Source hash file {0} not found'.format(source_hash)",
            "                    )",
            "            else:",
            "                if proto != '':",
            "                    # Some unsupported protocol (e.g. foo://) is being used.",
            "                    # We'll get into this else block if a hash expression",
            "                    # (like md5=<md5 checksum here>), but in those cases, the",
            "                    # protocol will be an empty string, in which case we avoid",
            "                    # this error condition.",
            "                    _invalid_source_hash_format()",
            "        except (AttributeError, TypeError):",
            "            _invalid_source_hash_format()",
            "",
            "    if hash_fn is not None:",
            "        ret = extract_hash(hash_fn, '', file_name, source, source_hash_name)",
            "        if ret is None:",
            "            _invalid_source_hash_format()",
            "        return ret",
            "    else:",
            "        # The source_hash is a hash expression",
            "        ret = {}",
            "        try:",
            "            ret['hash_type'], ret['hsum'] = \\",
            "                [x.strip() for x in source_hash.split('=', 1)]",
            "        except AttributeError:",
            "            _invalid_source_hash_format()",
            "        except ValueError:",
            "            # No hash type, try to figure out by hash length",
            "            if not re.match('^[{0}]+$'.format(string.hexdigits), source_hash):",
            "                _invalid_source_hash_format()",
            "            ret['hsum'] = source_hash",
            "            source_hash_len = len(source_hash)",
            "            if source_hash_len in HASHES_REVMAP:",
            "                ret['hash_type'] = HASHES_REVMAP[source_hash_len]",
            "            else:",
            "                _invalid_source_hash_format()",
            "",
            "        if ret['hash_type'] not in HASHES:",
            "            raise CommandExecutionError(",
            "                'Invalid hash type \\'{0}\\'. Supported hash types are: {1}. '",
            "                'Either remove the hash type and simply use \\'{2}\\' as the '",
            "                'source_hash, or change the hash type to a supported type.'",
            "                .format(ret['hash_type'], ', '.join(HASHES), ret['hsum'])",
            "            )",
            "        else:",
            "            hsum_len = len(ret['hsum'])",
            "            if hsum_len not in HASHES_REVMAP:",
            "                _invalid_source_hash_format()",
            "            elif hsum_len != HASHES[ret['hash_type']]:",
            "                raise CommandExecutionError(",
            "                    'Invalid length ({0}) for hash type \\'{1}\\'. Either '",
            "                    'remove the hash type and simply use \\'{2}\\' as the '",
            "                    'source_hash, or change the hash type to \\'{3}\\''.format(",
            "                        hsum_len,",
            "                        ret['hash_type'],",
            "                        ret['hsum'],",
            "                        HASHES_REVMAP[hsum_len],",
            "                    )",
            "                )",
            "",
            "        return ret",
            "",
            "",
            "def check_hash(path, file_hash):",
            "    '''",
            "    Check if a file matches the given hash string",
            "",
            "    Returns ``True`` if the hash matches, otherwise ``False``.",
            "",
            "    path",
            "        Path to a file local to the minion.",
            "",
            "    hash",
            "        The hash to check against the file specified in the ``path`` argument.",
            "        For versions 2016.11.4 and newer, the hash can be specified without an",
            "        accompanying hash type (e.g. ``e138491e9d5b97023cea823fe17bac22``),",
            "        but for earlier releases it is necessary to also specify the hash type",
            "        in the format ``<hash_type>:<hash_value>`` (e.g.",
            "        ``md5:e138491e9d5b97023cea823fe17bac22``).",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_hash /etc/fstab e138491e9d5b97023cea823fe17bac22",
            "        salt '*' file.check_hash /etc/fstab md5:e138491e9d5b97023cea823fe17bac22",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not isinstance(file_hash, six.string_types):",
            "        raise SaltInvocationError('hash must be a string')",
            "",
            "    for sep in (':', '='):",
            "        if sep in file_hash:",
            "            hash_type, hash_value = file_hash.split(sep, 1)",
            "            break",
            "    else:",
            "        hash_value = file_hash",
            "        hash_len = len(file_hash)",
            "        hash_type = HASHES_REVMAP.get(hash_len)",
            "        if hash_type is None:",
            "            raise SaltInvocationError(",
            "                'Hash {0} (length: {1}) could not be matched to a supported '",
            "                'hash type. The supported hash types and lengths are: '",
            "                '{2}'.format(",
            "                    file_hash,",
            "                    hash_len,",
            "                    ', '.join(",
            "                        ['{0} ({1})'.format(HASHES_REVMAP[x], x)",
            "                         for x in sorted(HASHES_REVMAP)]",
            "                    ),",
            "                )",
            "            )",
            "",
            "    return get_hash(path, hash_type) == hash_value",
            "",
            "",
            "def find(path, *args, **kwargs):",
            "    '''",
            "    Approximate the Unix ``find(1)`` command and return a list of paths that",
            "    meet the specified criteria.",
            "",
            "    The options include match criteria:",
            "",
            "    .. code-block:: text",
            "",
            "        name    = path-glob                 # case sensitive",
            "        iname   = path-glob                 # case insensitive",
            "        regex   = path-regex                # case sensitive",
            "        iregex  = path-regex                # case insensitive",
            "        type    = file-types                # match any listed type",
            "        user    = users                     # match any listed user",
            "        group   = groups                    # match any listed group",
            "        size    = [+-]number[size-unit]     # default unit = byte",
            "        mtime   = interval                  # modified since date",
            "        grep    = regex                     # search file contents",
            "",
            "    and/or actions:",
            "",
            "    .. code-block:: text",
            "",
            "        delete [= file-types]               # default type = 'f'",
            "        exec    = command [arg ...]         # where {} is replaced by pathname",
            "        print  [= print-opts]",
            "",
            "    and/or depth criteria:",
            "",
            "    .. code-block:: text",
            "",
            "        maxdepth = maximum depth to transverse in path",
            "        mindepth = minimum depth to transverse before checking files or directories",
            "",
            "    The default action is ``print=path``",
            "",
            "    ``path-glob``:",
            "",
            "    .. code-block:: text",
            "",
            "        *                = match zero or more chars",
            "        ?                = match any char",
            "        [abc]            = match a, b, or c",
            "        [!abc] or [^abc] = match anything except a, b, and c",
            "        [x-y]            = match chars x through y",
            "        [!x-y] or [^x-y] = match anything except chars x through y",
            "        {a,b,c}          = match a or b or c",
            "",
            "    ``path-regex``: a Python Regex (regular expression) pattern to match pathnames",
            "",
            "    ``file-types``: a string of one or more of the following:",
            "",
            "    .. code-block:: text",
            "",
            "        a: all file types",
            "        b: block device",
            "        c: character device",
            "        d: directory",
            "        p: FIFO (named pipe)",
            "        f: plain file",
            "        l: symlink",
            "        s: socket",
            "",
            "    ``users``: a space and/or comma separated list of user names and/or uids",
            "",
            "    ``groups``: a space and/or comma separated list of group names and/or gids",
            "",
            "    ``size-unit``:",
            "",
            "    .. code-block:: text",
            "",
            "        b: bytes",
            "        k: kilobytes",
            "        m: megabytes",
            "        g: gigabytes",
            "        t: terabytes",
            "",
            "    interval:",
            "",
            "    .. code-block:: text",
            "",
            "        [<num>w] [<num>d] [<num>h] [<num>m] [<num>s]",
            "",
            "        where:",
            "            w: week",
            "            d: day",
            "            h: hour",
            "            m: minute",
            "            s: second",
            "",
            "    print-opts: a comma and/or space separated list of one or more of the",
            "    following:",
            "",
            "    .. code-block:: text",
            "",
            "        group: group name",
            "        md5:   MD5 digest of file contents",
            "        mode:  file permissions (as integer)",
            "        mtime: last modification time (as time_t)",
            "        name:  file basename",
            "        path:  file absolute path",
            "        size:  file size in bytes",
            "        type:  file type",
            "        user:  user name",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.find / type=f name=\\\\*.bak size=+10m",
            "        salt '*' file.find /var mtime=+30d size=+10m print=path,size,mtime",
            "        salt '*' file.find /var/log name=\\\\*.[0-9] mtime=+30d size=+10m delete",
            "    '''",
            "    if 'delete' in args:",
            "        kwargs['delete'] = 'f'",
            "    elif 'print' in args:",
            "        kwargs['print'] = 'path'",
            "",
            "    try:",
            "        finder = salt.utils.find.Finder(kwargs)",
            "    except ValueError as ex:",
            "        return 'error: {0}'.format(ex)",
            "",
            "    ret = [item for i in [finder.find(p) for p in glob.glob(os.path.expanduser(path))] for item in i]",
            "    ret.sort()",
            "    return ret",
            "",
            "",
            "def _sed_esc(string, escape_all=False):",
            "    '''",
            "    Escape single quotes and forward slashes",
            "    '''",
            "    special_chars = \"^.[$()|*+?{\"",
            "    string = string.replace(\"'\", \"'\\\"'\\\"'\").replace(\"/\", \"\\\\/\")",
            "    if escape_all is True:",
            "        for char in special_chars:",
            "            string = string.replace(char, \"\\\\\" + char)",
            "    return string",
            "",
            "",
            "def sed(path,",
            "        before,",
            "        after,",
            "        limit='',",
            "        backup='.bak',",
            "        options='-r -e',",
            "        flags='g',",
            "        escape_all=False,",
            "        negate_match=False):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Make a simple edit to a file",
            "",
            "    Equivalent to:",
            "",
            "    .. code-block:: bash",
            "",
            "        sed <backup> <options> \"/<limit>/ s/<before>/<after>/<flags> <file>\"",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    before",
            "        A pattern to find in order to replace with ``after``",
            "    after",
            "        Text that will replace ``before``",
            "    limit : ``''``",
            "        An initial pattern to search for before searching for ``before``",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "        **WARNING:** each time ``sed``/``comment``/``uncomment`` is called will",
            "        overwrite this backup",
            "    options : ``-r -e``",
            "        Options to pass to sed",
            "    flags : ``g``",
            "        Flags to modify the sed search; e.g., ``i`` for case-insensitive pattern",
            "        matching",
            "    negate_match : False",
            "        Negate the search command (``!``)",
            "",
            "        .. versionadded:: 0.17.0",
            "",
            "    Forward slashes and single quotes will be escaped automatically in the",
            "    ``before`` and ``after`` patterns.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.sed /etc/httpd/httpd.conf 'LogLevel warn' 'LogLevel info'",
            "    '''",
            "    # Largely inspired by Fabric's contrib.files.sed()",
            "    # XXX:dc: Do we really want to always force escaping?",
            "    #",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    # Mandate that before and after are strings",
            "    before = str(before)",
            "    after = str(after)",
            "    before = _sed_esc(before, escape_all)",
            "    after = _sed_esc(after, escape_all)",
            "    limit = _sed_esc(limit, escape_all)",
            "    if sys.platform == 'darwin':",
            "        options = options.replace('-r', '-E')",
            "",
            "    cmd = ['sed']",
            "    cmd.append('-i{0}'.format(backup) if backup else '-i')",
            "    cmd.extend(salt.utils.shlex_split(options))",
            "    cmd.append(",
            "        r'{limit}{negate_match}s/{before}/{after}/{flags}'.format(",
            "            limit='/{0}/ '.format(limit) if limit else '',",
            "            negate_match='!' if negate_match else '',",
            "            before=before,",
            "            after=after,",
            "            flags=flags",
            "        )",
            "    )",
            "    cmd.append(path)",
            "",
            "    return __salt__['cmd.run_all'](cmd, python_shell=False)",
            "",
            "",
            "def sed_contains(path,",
            "                 text,",
            "                 limit='',",
            "                 flags='g'):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return True if the file at ``path`` contains ``text``. Utilizes sed to",
            "    perform the search (line-wise search).",
            "",
            "    Note: the ``p`` flag will be added to any flags you pass in.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains /etc/crontab 'mymaintenance.sh'",
            "    '''",
            "    # Largely inspired by Fabric's contrib.files.contains()",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    before = _sed_esc(str(text), False)",
            "    limit = _sed_esc(str(limit), False)",
            "    options = '-n -r -e'",
            "    if sys.platform == 'darwin':",
            "        options = options.replace('-r', '-E')",
            "",
            "    cmd = ['sed']",
            "    cmd.extend(salt.utils.shlex_split(options))",
            "    cmd.append(",
            "        r'{limit}s/{before}/$/{flags}'.format(",
            "            limit='/{0}/ '.format(limit) if limit else '',",
            "            before=before,",
            "            flags='p{0}'.format(flags)",
            "        )",
            "    )",
            "    cmd.append(path)",
            "",
            "    result = __salt__['cmd.run'](cmd, python_shell=False)",
            "",
            "    return bool(result)",
            "",
            "",
            "def psed(path,",
            "         before,",
            "         after,",
            "         limit='',",
            "         backup='.bak',",
            "         flags='gMS',",
            "         escape_all=False,",
            "         multi=False):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Make a simple edit to a file (pure Python version)",
            "",
            "    Equivalent to:",
            "",
            "    .. code-block:: bash",
            "",
            "        sed <backup> <options> \"/<limit>/ s/<before>/<after>/<flags> <file>\"",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    before",
            "        A pattern to find in order to replace with ``after``",
            "    after",
            "        Text that will replace ``before``",
            "    limit : ``''``",
            "        An initial pattern to search for before searching for ``before``",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "        **WARNING:** each time ``sed``/``comment``/``uncomment`` is called will",
            "        overwrite this backup",
            "    flags : ``gMS``",
            "        Flags to modify the search. Valid values are:",
            "          - ``g``: Replace all occurrences of the pattern, not just the first.",
            "          - ``I``: Ignore case.",
            "          - ``L``: Make ``\\\\w``, ``\\\\W``, ``\\\\b``, ``\\\\B``, ``\\\\s`` and ``\\\\S``",
            "            dependent on the locale.",
            "          - ``M``: Treat multiple lines as a single line.",
            "          - ``S``: Make `.` match all characters, including newlines.",
            "          - ``U``: Make ``\\\\w``, ``\\\\W``, ``\\\\b``, ``\\\\B``, ``\\\\d``, ``\\\\D``,",
            "            ``\\\\s`` and ``\\\\S`` dependent on Unicode.",
            "          - ``X``: Verbose (whitespace is ignored).",
            "    multi: ``False``",
            "        If True, treat the entire file as a single line",
            "",
            "    Forward slashes and single quotes will be escaped automatically in the",
            "    ``before`` and ``after`` patterns.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.sed /etc/httpd/httpd.conf 'LogLevel warn' 'LogLevel info'",
            "    '''",
            "    # Largely inspired by Fabric's contrib.files.sed()",
            "    # XXX:dc: Do we really want to always force escaping?",
            "    #",
            "    # Mandate that before and after are strings",
            "    path = os.path.expanduser(path)",
            "",
            "    multi = bool(multi)",
            "",
            "    before = str(before)",
            "    after = str(after)",
            "    before = _sed_esc(before, escape_all)",
            "    # The pattern to replace with does not need to be escaped!!!",
            "    #after = _sed_esc(after, escape_all)",
            "    limit = _sed_esc(limit, escape_all)",
            "",
            "    shutil.copy2(path, '{0}{1}'.format(path, backup))",
            "",
            "    with salt.utils.fopen(path, 'w') as ofile:",
            "        with salt.utils.fopen('{0}{1}'.format(path, backup), 'r') as ifile:",
            "            if multi is True:",
            "                for line in ifile.readline():",
            "                    ofile.write(_psed(line, before, after, limit, flags))",
            "            else:",
            "                ofile.write(_psed(ifile.read(), before, after, limit, flags))",
            "",
            "",
            "RE_FLAG_TABLE = {'I': re.I,",
            "                 'L': re.L,",
            "                 'M': re.M,",
            "                 'S': re.S,",
            "                 'U': re.U,",
            "                 'X': re.X}",
            "",
            "",
            "def _psed(text,",
            "          before,",
            "          after,",
            "          limit,",
            "          flags):",
            "    '''",
            "    Does the actual work for file.psed, so that single lines can be passed in",
            "    '''",
            "    atext = text",
            "    if limit:",
            "        limit = re.compile(limit)",
            "        comps = text.split(limit)",
            "        atext = ''.join(comps[1:])",
            "",
            "    count = 1",
            "    if 'g' in flags:",
            "        count = 0",
            "        flags = flags.replace('g', '')",
            "",
            "    aflags = 0",
            "    for flag in flags:",
            "        aflags |= RE_FLAG_TABLE[flag]",
            "",
            "    before = re.compile(before, flags=aflags)",
            "    text = re.sub(before, after, atext, count=count)",
            "",
            "    return text",
            "",
            "",
            "def uncomment(path,",
            "              regex,",
            "              char='#',",
            "              backup='.bak'):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Uncomment specified commented lines in a file",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be uncommented.",
            "        This regex should not include the comment character. A leading ``^``",
            "        character will be stripped for convenience (for easily switching",
            "        between comment() and uncomment()).",
            "    char : ``#``",
            "        The character to remove in order to uncomment a line",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "        **WARNING:** each time ``sed``/``comment``/``uncomment`` is called will",
            "        overwrite this backup",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.uncomment /etc/hosts.deny 'ALL: PARANOID'",
            "    '''",
            "    return comment_line(path=path,",
            "                        regex=regex,",
            "                        char=char,",
            "                        cmnt=False,",
            "                        backup=backup)",
            "",
            "",
            "def comment(path,",
            "            regex,",
            "            char='#',",
            "            backup='.bak'):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Comment out specified lines in a file",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be commented;",
            "        this pattern will be wrapped in parenthesis and will move any",
            "        preceding/trailing ``^`` or ``$`` characters outside the parenthesis",
            "        (e.g., the pattern ``^foo$`` will be rewritten as ``^(foo)$``)",
            "    char : ``#``",
            "        The character to be inserted at the beginning of a line in order to",
            "        comment it out",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension",
            "",
            "        .. warning::",
            "",
            "            This backup will be overwritten each time ``sed`` / ``comment`` /",
            "            ``uncomment`` is called. Meaning the backup will only be useful",
            "            after the first invocation.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.comment /etc/modules pcspkr",
            "    '''",
            "    return comment_line(path=path,",
            "                        regex=regex,",
            "                        char=char,",
            "                        cmnt=True,",
            "                        backup=backup)",
            "",
            "",
            "def comment_line(path,",
            "                 regex,",
            "                 char='#',",
            "                 cmnt=True,",
            "                 backup='.bak'):",
            "    r'''",
            "    Comment or Uncomment a line in a text file.",
            "",
            "    :param path: string",
            "        The full path to the text file.",
            "",
            "    :param regex: string",
            "        A regex expression that begins with ``^`` that will find the line you wish",
            "        to comment. Can be as simple as ``^color =``",
            "",
            "    :param char: string",
            "        The character used to comment a line in the type of file you're referencing.",
            "        Default is ``#``",
            "",
            "    :param cmnt: boolean",
            "        True to comment the line. False to uncomment the line. Default is True.",
            "",
            "    :param backup: string",
            "        The file extension to give the backup file. Default is ``.bak``",
            "        Set to False/None to not keep a backup.",
            "",
            "    :return: boolean",
            "        Returns True if successful, False if not",
            "",
            "    CLI Example:",
            "",
            "    The following example will comment out the ``pcspkr`` line in the",
            "    ``/etc/modules`` file using the default ``#`` character and create a backup",
            "    file named ``modules.bak``",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.comment_line '/etc/modules' '^pcspkr'",
            "",
            "",
            "    CLI Example:",
            "",
            "    The following example will uncomment the ``log_level`` setting in ``minion``",
            "    config file if it is set to either ``warning``, ``info``, or ``debug`` using",
            "    the ``#`` character and create a backup file named ``minion.bk``",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.comment_line 'C:\\salt\\conf\\minion' '^log_level: (warning|info|debug)' '#' False '.bk'",
            "    '''",
            "    # Get the regex for comment or uncomment",
            "    if cmnt:",
            "        regex = '{0}({1}){2}'.format(",
            "                '^' if regex.startswith('^') else '',",
            "                regex.lstrip('^').rstrip('$'),",
            "                '$' if regex.endswith('$') else '')",
            "    else:",
            "        regex = r'^{0}\\s*({1}){2}'.format(",
            "                char,",
            "                regex.lstrip('^').rstrip('$'),",
            "                '$' if regex.endswith('$') else '')",
            "",
            "    # Load the real path to the file",
            "    path = os.path.realpath(os.path.expanduser(path))",
            "",
            "    # Make sure the file exists",
            "    if not os.path.isfile(path):",
            "        raise SaltInvocationError('File not found: {0}'.format(path))",
            "",
            "    # Make sure it is a text file",
            "    if not salt.utils.istextfile(path):",
            "        raise SaltInvocationError(",
            "            'Cannot perform string replacements on a binary file: {0}'.format(path))",
            "",
            "    # First check the whole file, determine whether to make the replacement",
            "    # Searching first avoids modifying the time stamp if there are no changes",
            "    found = False",
            "    # Dictionaries for comparing changes",
            "    orig_file = []",
            "    new_file = []",
            "    # Buffer size for fopen",
            "    bufsize = os.path.getsize(path)",
            "    try:",
            "        # Use a read-only handle to open the file",
            "        with salt.utils.fopen(path,",
            "                              mode='rb',",
            "                              buffering=bufsize) as r_file:",
            "            # Loop through each line of the file and look for a match",
            "            for line in r_file:",
            "                # Is it in this line",
            "                if re.match(regex, line):",
            "                    # Load lines into dictionaries, set found to True",
            "                    orig_file.append(line)",
            "                    if cmnt:",
            "                        new_file.append('{0}{1}'.format(char, line))",
            "                    else:",
            "                        new_file.append(line.lstrip(char))",
            "                    found = True",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to open file '{0}'. \"",
            "            \"Exception: {1}\".format(path, exc)",
            "        )",
            "",
            "    # We've searched the whole file. If we didn't find anything, return False",
            "    if not found:",
            "        return False",
            "",
            "    if not salt.utils.is_windows():",
            "        pre_user = get_user(path)",
            "        pre_group = get_group(path)",
            "        pre_mode = salt.utils.normalize_mode(get_mode(path))",
            "",
            "    # Create a copy to read from and to use as a backup later",
            "    try:",
            "        temp_file = _mkstemp_copy(path=path, preserve_inode=False)",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "    try:",
            "        # Open the file in write mode",
            "        with salt.utils.fopen(path,",
            "                              mode='wb',",
            "                              buffering=bufsize) as w_file:",
            "            try:",
            "                # Open the temp file in read mode",
            "                with salt.utils.fopen(temp_file,",
            "                                      mode='rb',",
            "                                      buffering=bufsize) as r_file:",
            "                    # Loop through each line of the file and look for a match",
            "                    for line in r_file:",
            "                        try:",
            "                            # Is it in this line",
            "                            if re.match(regex, line):",
            "                                # Write the new line",
            "                                if cmnt:",
            "                                    w_file.write('{0}{1}'.format(char, line))",
            "                                else:",
            "                                    w_file.write(line.lstrip(char))",
            "                            else:",
            "                                # Write the existing line (no change)",
            "                                w_file.write(line)",
            "                        except (OSError, IOError) as exc:",
            "                            raise CommandExecutionError(",
            "                                \"Unable to write file '{0}'. Contents may \"",
            "                                \"be truncated. Temporary file contains copy \"",
            "                                \"at '{1}'. \"",
            "                                \"Exception: {2}\".format(path, temp_file, exc)",
            "                            )",
            "            except (OSError, IOError) as exc:",
            "                raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "    if backup:",
            "        # Move the backup file to the original directory",
            "        backup_name = '{0}{1}'.format(path, backup)",
            "        try:",
            "            shutil.move(temp_file, backup_name)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to move the temp file '{0}' to the \"",
            "                \"backup file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "            )",
            "    else:",
            "        os.remove(temp_file)",
            "",
            "    if not salt.utils.is_windows():",
            "        check_perms(path, None, pre_user, pre_group, pre_mode)",
            "",
            "    # Return a diff using the two dictionaries",
            "    return ''.join(difflib.unified_diff(orig_file, new_file))",
            "",
            "",
            "def _get_flags(flags):",
            "    '''",
            "    Return an integer appropriate for use as a flag for the re module from a",
            "    list of human-readable strings",
            "",
            "    .. code-block:: python",
            "",
            "        >>> _get_flags(['MULTILINE', 'IGNORECASE'])",
            "        10",
            "        >>> _get_flags('MULTILINE')",
            "        8",
            "        >>> _get_flags(2)",
            "        2",
            "    '''",
            "    if isinstance(flags, six.string_types):",
            "        flags = [flags]",
            "",
            "    if isinstance(flags, Iterable) and not isinstance(flags, Mapping):",
            "        _flags_acc = []",
            "        for flag in flags:",
            "            _flag = getattr(re, str(flag).upper())",
            "",
            "            if not isinstance(_flag, six.integer_types):",
            "                raise SaltInvocationError(",
            "                    'Invalid re flag given: {0}'.format(flag)",
            "                )",
            "",
            "            _flags_acc.append(_flag)",
            "",
            "        return reduce(operator.__or__, _flags_acc)",
            "    elif isinstance(flags, six.integer_types):",
            "        return flags",
            "    else:",
            "        raise SaltInvocationError(",
            "            'Invalid re flags: \"{0}\", must be given either as a single flag '",
            "            'string, a list of strings, or as an integer'.format(flags)",
            "        )",
            "",
            "",
            "def _add_flags(flags, new_flags):",
            "    '''",
            "    Combine ``flags`` and ``new_flags``",
            "    '''",
            "    flags = _get_flags(flags)",
            "    new_flags = _get_flags(new_flags)",
            "    return flags | new_flags",
            "",
            "",
            "def _mkstemp_copy(path,",
            "                  preserve_inode=True):",
            "    '''",
            "    Create a temp file and move/copy the contents of ``path`` to the temp file.",
            "    Return the path to the temp file.",
            "",
            "    path",
            "        The full path to the file whose contents will be moved/copied to a temp file.",
            "        Whether it's moved or copied depends on the value of ``preserve_inode``.",
            "    preserve_inode",
            "        Preserve the inode of the file, so that any hard links continue to share the",
            "        inode with the original filename. This works by *copying* the file, reading",
            "        from the copy, and writing to the file at the original inode. If ``False``, the",
            "        file will be *moved* rather than copied, and a new file will be written to a",
            "        new inode, but using the original filename. Hard links will then share an inode",
            "        with the backup, instead (if using ``backup`` to create a backup copy).",
            "        Default is ``True``.",
            "    '''",
            "    temp_file = None",
            "    # Create the temp file",
            "    try:",
            "        temp_file = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX)",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to create temp file. \"",
            "            \"Exception: {0}\".format(exc)",
            "            )",
            "    # use `copy` to preserve the inode of the",
            "    # original file, and thus preserve hardlinks",
            "    # to the inode. otherwise, use `move` to",
            "    # preserve prior behavior, which results in",
            "    # writing the file to a new inode.",
            "    if preserve_inode:",
            "        try:",
            "            shutil.copy2(path, temp_file)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to copy file '{0}' to the \"",
            "                \"temp file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "                )",
            "    else:",
            "        try:",
            "            shutil.move(path, temp_file)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to move file '{0}' to the \"",
            "                \"temp file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "                )",
            "",
            "    return temp_file",
            "",
            "",
            "def _starts_till(src, probe, strip_comments=True):",
            "    '''",
            "    Returns True if src and probe at least begins till some point.",
            "    '''",
            "    def _strip_comments(txt):",
            "        '''",
            "        Strip possible comments.",
            "        Usually commends are one or two symbols",
            "        '''",
            "        buff = txt.split(\" \", 1)",
            "        return len(buff) == 2 and len(buff[0]) < 2 and buff[1] or txt",
            "",
            "    def _to_words(txt):",
            "        '''",
            "        Split by words",
            "        '''",
            "        return txt and [w for w in txt.strip().split(\" \") if w.strip()] or txt",
            "",
            "    no_match = -1",
            "    equal = 0",
            "    if not src or not probe:",
            "        return no_match",
            "",
            "    if src == probe:",
            "        return equal",
            "",
            "    src = _to_words(strip_comments and _strip_comments(src) or src)",
            "    probe = _to_words(strip_comments and _strip_comments(probe) or probe)",
            "",
            "    a_buff, b_buff = len(src) < len(probe) and (src, probe) or (probe, src)",
            "    b_buff = ' '.join(b_buff)",
            "    for idx in range(len(a_buff)):",
            "        prb = ' '.join(a_buff[:-(idx + 1)])",
            "        if prb and b_buff.startswith(prb):",
            "            return idx",
            "",
            "    return no_match",
            "",
            "",
            "def _regex_to_static(src, regex):",
            "    '''",
            "    Expand regular expression to static match.",
            "    '''",
            "    if not src or not regex:",
            "        return None",
            "",
            "    try:",
            "        src = re.search(regex, src)",
            "    except Exception as ex:",
            "        raise CommandExecutionError(\"{0}: '{1}'\".format(_get_error_message(ex), regex))",
            "",
            "    return src and src.group() or regex",
            "",
            "",
            "def _assert_occurrence(src, probe, target, amount=1):",
            "    '''",
            "    Raise an exception, if there are different amount of specified occurrences in src.",
            "    '''",
            "    occ = src.count(probe)",
            "    if occ > amount:",
            "        msg = 'more than'",
            "    elif occ < amount:",
            "        msg = 'less than'",
            "    elif not occ:",
            "        msg = 'no'",
            "    else:",
            "        msg = None",
            "",
            "    if msg:",
            "        raise CommandExecutionError('Found {0} expected occurrences in \"{1}\" expression'.format(msg, target))",
            "",
            "",
            "def _get_line_indent(src, line, indent):",
            "    '''",
            "    Indent the line with the source line.",
            "    '''",
            "    if not indent:",
            "        return line",
            "",
            "    idt = []",
            "    for c in src:",
            "        if c not in ['\\t', ' ']:",
            "            break",
            "        idt.append(c)",
            "",
            "    return ''.join(idt) + line.strip()",
            "",
            "",
            "def line(path, content, match=None, mode=None, location=None,",
            "         before=None, after=None, show_changes=True, backup=False,",
            "         quiet=False, indent=True):",
            "    '''",
            "    .. versionadded:: 2015.8.0",
            "",
            "    Edit a line in the configuration file. The ``path`` and ``content``",
            "    arguments are required, as well as passing in one of the ``mode``",
            "    options.",
            "",
            "    path",
            "        Filesystem path to the file to be edited.",
            "",
            "    content",
            "        Content of the line.",
            "",
            "    match",
            "        Match the target line for an action by",
            "        a fragment of a string or regular expression.",
            "",
            "        If neither ``before`` nor ``after`` are provided, and ``match``",
            "        is also ``None``, match becomes the ``content`` value.",
            "",
            "    mode",
            "        Defines how to edit a line. One of the following options is",
            "        required:",
            "",
            "        - ensure",
            "            If line does not exist, it will be added. This is based on the",
            "            ``content`` argument.",
            "        - replace",
            "            If line already exists, it will be replaced.",
            "        - delete",
            "            Delete the line, once found.",
            "        - insert",
            "            Insert a line.",
            "",
            "        .. note::",
            "",
            "            If ``mode=insert`` is used, at least one of the following",
            "            options must also be defined: ``location``, ``before``, or",
            "            ``after``. If ``location`` is used, it takes precedence",
            "            over the other two options.",
            "",
            "    location",
            "        Defines where to place content in the line. Note this option is only",
            "        used when ``mode=insert`` is specified. If a location is passed in, it",
            "        takes precedence over both the ``before`` and ``after`` kwargs. Valid",
            "        locations are:",
            "",
            "        - start",
            "            Place the content at the beginning of the file.",
            "        - end",
            "            Place the content at the end of the file.",
            "",
            "    before",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    after",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file.",
            "        If ``False`` return a boolean if any changes were made.",
            "        Default is ``True``",
            "",
            "        .. note::",
            "            Using this option will store two copies of the file in-memory",
            "            (the original version and the edited version) in order to generate the diff.",
            "",
            "    backup",
            "        Create a backup of the original file with the extension:",
            "        \"Year-Month-Day-Hour-Minutes-Seconds\".",
            "",
            "    quiet",
            "        Do not raise any exceptions. E.g. ignore the fact that the file that is",
            "        tried to be edited does not exist and nothing really happened.",
            "",
            "    indent",
            "        Keep indentation with the previous line. This option is not considered when",
            "        the ``delete`` mode is specified.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.line /etc/nsswitch.conf \"networks:\\tfiles dns\" after=\"hosts:.*?\" mode='ensure'",
            "",
            "    .. note::",
            "",
            "        If an equal sign (``=``) appears in an argument to a Salt command, it is",
            "        interpreted as a keyword argument in the format of ``key=val``. That",
            "        processing can be bypassed in order to pass an equal sign through to the",
            "        remote shell command by manually specifying the kwarg:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.line /path/to/file content=\"CREATEMAIL_SPOOL=no\" match=\"CREATE_MAIL_SPOOL=yes\" mode=\"replace\"",
            "    '''",
            "    path = os.path.realpath(os.path.expanduser(path))",
            "    if not os.path.isfile(path):",
            "        if not quiet:",
            "            raise CommandExecutionError('File \"{0}\" does not exists or is not a file.'.format(path))",
            "        return False  # No changes had happened",
            "",
            "    mode = mode and mode.lower() or mode",
            "    if mode not in ['insert', 'ensure', 'delete', 'replace']:",
            "        if mode is None:",
            "            raise CommandExecutionError('Mode was not defined. How to process the file?')",
            "        else:",
            "            raise CommandExecutionError('Unknown mode: \"{0}\"'.format(mode))",
            "",
            "    # Before/after has privilege. If nothing defined, match is used by content.",
            "    if before is None and after is None and not match:",
            "        match = content",
            "",
            "    with salt.utils.fopen(path, mode='r') as fp_:",
            "        body = fp_.read()",
            "    body_before = hashlib.sha256(salt.utils.to_bytes(body)).hexdigest()",
            "    after = _regex_to_static(body, after)",
            "    before = _regex_to_static(body, before)",
            "    match = _regex_to_static(body, match)",
            "",
            "    if os.stat(path).st_size == 0 and mode in ('delete', 'replace'):",
            "        log.warning('Cannot find text to {0}. File \\'{1}\\' is empty.'.format(mode, path))",
            "        body = ''",
            "    elif mode == 'delete':",
            "        body = os.linesep.join([line for line in body.split(os.linesep) if line.find(match) < 0])",
            "    elif mode == 'replace':",
            "        body = os.linesep.join([(_get_line_indent(file_line, content, indent)",
            "                                if (file_line.find(match) > -1 and not file_line == content) else file_line)",
            "                                for file_line in body.split(os.linesep)])",
            "    elif mode == 'insert':",
            "        if not location and not before and not after:",
            "            raise CommandExecutionError('On insert must be defined either \"location\" or \"before/after\" conditions.')",
            "",
            "        if not location:",
            "            if before and after:",
            "                _assert_occurrence(body, before, 'before')",
            "                _assert_occurrence(body, after, 'after')",
            "                out = []",
            "                lines = body.split(os.linesep)",
            "                for idx in range(len(lines)):",
            "                    _line = lines[idx]",
            "                    if _line.find(before) > -1 and idx <= len(lines) and lines[idx - 1].find(after) > -1:",
            "                        out.append(_get_line_indent(_line, content, indent))",
            "                        out.append(_line)",
            "                    else:",
            "                        out.append(_line)",
            "                body = os.linesep.join(out)",
            "",
            "            if before and not after:",
            "                _assert_occurrence(body, before, 'before')",
            "                out = []",
            "                lines = body.split(os.linesep)",
            "                for idx in range(len(lines)):",
            "                    _line = lines[idx]",
            "                    if _line.find(before) > -1:",
            "                        cnd = _get_line_indent(_line, content, indent)",
            "                        if not idx or (idx and _starts_till(lines[idx - 1], cnd) < 0):  # Job for replace instead",
            "                            out.append(cnd)",
            "                    out.append(_line)",
            "                body = os.linesep.join(out)",
            "",
            "            elif after and not before:",
            "                _assert_occurrence(body, after, 'after')",
            "                out = []",
            "                lines = body.split(os.linesep)",
            "                for idx in range(len(lines)):",
            "                    _line = lines[idx]",
            "                    out.append(_line)",
            "                    cnd = _get_line_indent(_line, content, indent)",
            "                    if _line.find(after) > -1:",
            "                        # No dupes or append, if \"after\" is the last line",
            "                        if (idx < len(lines) and _starts_till(lines[idx + 1], cnd) < 0) or idx + 1 == len(lines):",
            "                            out.append(cnd)",
            "                body = os.linesep.join(out)",
            "",
            "        else:",
            "            if location == 'start':",
            "                body = ''.join([content, body])",
            "            elif location == 'end':",
            "                body = ''.join([body, _get_line_indent(body[-1], content, indent) if body else content])",
            "",
            "    elif mode == 'ensure':",
            "        after = after and after.strip()",
            "        before = before and before.strip()",
            "",
            "        if before and after:",
            "            _assert_occurrence(body, before, 'before')",
            "            _assert_occurrence(body, after, 'after')",
            "",
            "            a_idx = b_idx = -1",
            "            idx = 0",
            "            body = body.split(os.linesep)",
            "            for _line in body:",
            "                idx += 1",
            "                if _line.find(before) > -1 and b_idx < 0:",
            "                    b_idx = idx",
            "                if _line.find(after) > -1 and a_idx < 0:",
            "                    a_idx = idx",
            "",
            "            # Add",
            "            if not b_idx - a_idx - 1:",
            "                body = body[:a_idx] + [content] + body[b_idx - 1:]",
            "            elif b_idx - a_idx - 1 == 1:",
            "                if _starts_till(body[a_idx:b_idx - 1][0], content) > -1:",
            "                    body[a_idx] = _get_line_indent(body[a_idx - 1], content, indent)",
            "            else:",
            "                raise CommandExecutionError('Found more than one line between boundaries \"before\" and \"after\".')",
            "            body = os.linesep.join(body)",
            "",
            "        elif before and not after:",
            "            _assert_occurrence(body, before, 'before')",
            "            body = body.split(os.linesep)",
            "            out = []",
            "            for idx in range(len(body)):",
            "                if body[idx].find(before) > -1:",
            "                    prev = (idx > 0 and idx or 1) - 1",
            "                    out.append(_get_line_indent(body[prev], content, indent))",
            "                    if _starts_till(out[prev], content) > -1:",
            "                        del out[prev]",
            "                out.append(body[idx])",
            "            body = os.linesep.join(out)",
            "",
            "        elif not before and after:",
            "            _assert_occurrence(body, after, 'after')",
            "            body = body.split(os.linesep)",
            "            skip = None",
            "            out = []",
            "            for idx in range(len(body)):",
            "                if skip != body[idx]:",
            "                    out.append(body[idx])",
            "",
            "                if body[idx].find(after) > -1:",
            "                    next_line = idx + 1 < len(body) and body[idx + 1] or None",
            "                    if next_line is not None and _starts_till(next_line, content) > -1:",
            "                        skip = next_line",
            "                    out.append(_get_line_indent(body[idx], content, indent))",
            "            body = os.linesep.join(out)",
            "",
            "        else:",
            "            raise CommandExecutionError(\"Wrong conditions? \"",
            "                                        \"Unable to ensure line without knowing \"",
            "                                        \"where to put it before and/or after.\")",
            "",
            "    changed = body_before != hashlib.sha256(salt.utils.to_bytes(body)).hexdigest()",
            "",
            "    if backup and changed and __opts__['test'] is False:",
            "        try:",
            "            temp_file = _mkstemp_copy(path=path, preserve_inode=True)",
            "            shutil.move(temp_file, '{0}.{1}'.format(path, time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime())))",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(\"Unable to create the backup file of {0}. Exception: {1}\".format(path, exc))",
            "",
            "    changes_diff = None",
            "",
            "    if changed:",
            "        if show_changes:",
            "            with salt.utils.fopen(path, 'r') as fp_:",
            "                path_content = _splitlines_preserving_trailing_newline(",
            "                    fp_.read())",
            "            changes_diff = ''.join(difflib.unified_diff(",
            "                path_content, _splitlines_preserving_trailing_newline(body)))",
            "        if __opts__['test'] is False:",
            "            fh_ = None",
            "            try:",
            "                fh_ = salt.utils.atomicfile.atomic_open(path, 'w')",
            "                fh_.write(body)",
            "            finally:",
            "                if fh_:",
            "                    fh_.close()",
            "",
            "    return show_changes and changes_diff or changed",
            "",
            "",
            "def replace(path,",
            "            pattern,",
            "            repl,",
            "            count=0,",
            "            flags=8,",
            "            bufsize=1,",
            "            append_if_not_found=False,",
            "            prepend_if_not_found=False,",
            "            not_found_content=None,",
            "            backup='.bak',",
            "            dry_run=False,",
            "            search_only=False,",
            "            show_changes=True,",
            "            ignore_if_missing=False,",
            "            preserve_inode=True,",
            "        ):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Replace occurrences of a pattern in a file. If ``show_changes`` is",
            "    ``True``, then a diff of what changed will be returned, otherwise a",
            "    ``True`` will be returned when changes are made, and ``False`` when",
            "    no changes are made.",
            "",
            "    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.",
            "",
            "    path",
            "        Filesystem path to the file to be edited. If a symlink is specified, it",
            "        will be resolved to its target.",
            "",
            "    pattern",
            "        A regular expression, to be matched using Python's",
            "        :py:func:`~re.search`.",
            "",
            "    repl",
            "        The replacement text",
            "",
            "    count : 0",
            "        Maximum number of pattern occurrences to be replaced. If count is a",
            "        positive integer ``n``, only ``n`` occurrences will be replaced,",
            "        otherwise all occurrences will be replaced.",
            "",
            "    flags (list or int)",
            "        A list of flags defined in the :ref:`re module documentation",
            "        <contents-of-module-re>`. Each list item should be a string that will",
            "        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',",
            "        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value",
            "        corresponding to the XOR (``|``) of all the desired flags. Defaults to",
            "        8 (which supports 'MULTILINE').",
            "",
            "    bufsize (int or str)",
            "        How much of the file to buffer into memory at once. The",
            "        default value ``1`` processes one line at a time. The special value",
            "        ``file`` may be specified which will read the entire file into memory",
            "        before processing.",
            "",
            "    append_if_not_found : False",
            "        .. versionadded:: 2014.7.0",
            "",
            "        If set to ``True``, and pattern is not found, then the content will be",
            "        appended to the file.",
            "",
            "    prepend_if_not_found : False",
            "        .. versionadded:: 2014.7.0",
            "",
            "        If set to ``True`` and pattern is not found, then the content will be",
            "        prepended to the file.",
            "",
            "    not_found_content",
            "        .. versionadded:: 2014.7.0",
            "",
            "        Content to use for append/prepend if not found. If None (default), uses",
            "        ``repl``. Useful when ``repl`` uses references to group in pattern.",
            "",
            "    backup : .bak",
            "        The file extension to use for a backup of the file before editing. Set",
            "        to ``False`` to skip making a backup.",
            "",
            "    dry_run : False",
            "        If set to ``True``, no changes will be made to the file, the function",
            "        will just return the changes that would have been made (or a",
            "        ``True``/``False`` value if ``show_changes`` is set to ``False``).",
            "",
            "    search_only : False",
            "        If set to true, this no changes will be performed on the file, and this",
            "        function will simply return ``True`` if the pattern was matched, and",
            "        ``False`` if not.",
            "",
            "    show_changes : True",
            "        If ``True``, return a diff of changes made. Otherwise, return ``True``",
            "        if changes were made, and ``False`` if not.",
            "",
            "        .. note::",
            "            Using this option will store two copies of the file in memory (the",
            "            original version and the edited version) in order to generate the",
            "            diff. This may not normally be a concern, but could impact",
            "            performance if used with large files.",
            "",
            "    ignore_if_missing : False",
            "        .. versionadded:: 2015.8.0",
            "",
            "        If set to ``True``, this function will simply return ``False``",
            "        if the file doesn't exist. Otherwise, an error will be thrown.",
            "",
            "    preserve_inode : True",
            "        .. versionadded:: 2015.8.0",
            "",
            "        Preserve the inode of the file, so that any hard links continue to",
            "        share the inode with the original filename. This works by *copying* the",
            "        file, reading from the copy, and writing to the file at the original",
            "        inode. If ``False``, the file will be *moved* rather than copied, and a",
            "        new file will be written to a new inode, but using the original",
            "        filename. Hard links will then share an inode with the backup, instead",
            "        (if using ``backup`` to create a backup copy).",
            "",
            "    If an equal sign (``=``) appears in an argument to a Salt command it is",
            "    interpreted as a keyword argument in the format ``key=val``. That",
            "    processing can be bypassed in order to pass an equal sign through to the",
            "    remote shell command by manually specifying the kwarg:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.replace /path/to/file pattern='=' repl=':'",
            "        salt '*' file.replace /path/to/file pattern=\"bind-address\\\\s*=\" repl='bind-address:'",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.replace /etc/httpd/httpd.conf pattern='LogLevel warn' repl='LogLevel info'",
            "        salt '*' file.replace /some/file pattern='before' repl='after' flags='[MULTILINE, IGNORECASE]'",
            "    '''",
            "    symlink = False",
            "    if is_link(path):",
            "        symlink = True",
            "        target_path = os.readlink(path)",
            "        given_path = os.path.expanduser(path)",
            "",
            "    path = os.path.realpath(os.path.expanduser(path))",
            "",
            "    if not os.path.exists(path):",
            "        if ignore_if_missing:",
            "            return False",
            "        else:",
            "            raise SaltInvocationError('File not found: {0}'.format(path))",
            "",
            "    if not salt.utils.istextfile(path):",
            "        raise SaltInvocationError(",
            "            'Cannot perform string replacements on a binary file: {0}'",
            "            .format(path)",
            "        )",
            "",
            "    if search_only and (append_if_not_found or prepend_if_not_found):",
            "        raise SaltInvocationError(",
            "            'search_only cannot be used with append/prepend_if_not_found'",
            "        )",
            "",
            "    if append_if_not_found and prepend_if_not_found:",
            "        raise SaltInvocationError(",
            "            'Only one of append and prepend_if_not_found is permitted'",
            "        )",
            "",
            "    flags_num = _get_flags(flags)",
            "    cpattern = re.compile(salt.utils.to_bytes(pattern), flags_num)",
            "    filesize = os.path.getsize(path)",
            "    if bufsize == 'file':",
            "        bufsize = filesize",
            "",
            "    # Search the file; track if any changes have been made for the return val",
            "    has_changes = False",
            "    orig_file = []  # used if show_changes",
            "    new_file = []  # used if show_changes",
            "    if not salt.utils.is_windows():",
            "        pre_user = get_user(path)",
            "        pre_group = get_group(path)",
            "        pre_mode = salt.utils.normalize_mode(get_mode(path))",
            "",
            "    # Avoid TypeErrors by forcing repl to be bytearray related to mmap",
            "    # Replacement text may contains integer: 123 for example",
            "    repl = salt.utils.to_bytes(str(repl))",
            "    if not_found_content:",
            "        not_found_content = salt.utils.to_bytes(not_found_content)",
            "",
            "    found = False",
            "    temp_file = None",
            "    content = salt.utils.to_str(not_found_content) if not_found_content and \\",
            "                                       (prepend_if_not_found or",
            "                                        append_if_not_found) \\",
            "                                     else salt.utils.to_str(repl)",
            "",
            "    try:",
            "        # First check the whole file, determine whether to make the replacement",
            "        # Searching first avoids modifying the time stamp if there are no changes",
            "        r_data = None",
            "        # Use a read-only handle to open the file",
            "        with salt.utils.fopen(path,",
            "                              mode='rb',",
            "                              buffering=bufsize) as r_file:",
            "            try:",
            "                # mmap throws a ValueError if the file is empty.",
            "                r_data = mmap.mmap(r_file.fileno(),",
            "                                   0,",
            "                                   access=mmap.ACCESS_READ)",
            "            except (ValueError, mmap.error):",
            "                # size of file in /proc is 0, but contains data",
            "                r_data = salt.utils.to_bytes(\"\".join(r_file))",
            "            if search_only:",
            "                # Just search; bail as early as a match is found",
            "                if re.search(cpattern, r_data):",
            "                    return True  # `with` block handles file closure",
            "            else:",
            "                result, nrepl = re.subn(cpattern, repl, r_data, count)",
            "",
            "                # found anything? (even if no change)",
            "                if nrepl > 0:",
            "                    found = True",
            "                    # Identity check the potential change",
            "                    has_changes = True if pattern != repl else has_changes",
            "",
            "                if prepend_if_not_found or append_if_not_found:",
            "                    # Search for content, to avoid pre/appending the",
            "                    # content if it was pre/appended in a previous run.",
            "                    if re.search(salt.utils.to_bytes('^{0}$'.format(re.escape(content))),",
            "                                 r_data,",
            "                                 flags=flags_num):",
            "                        # Content was found, so set found.",
            "                        found = True",
            "",
            "                # Keep track of show_changes here, in case the file isn't",
            "                # modified",
            "                if show_changes or append_if_not_found or \\",
            "                   prepend_if_not_found:",
            "                    orig_file = r_data.read(filesize).splitlines(True) \\",
            "                        if isinstance(r_data, mmap.mmap) \\",
            "                        else r_data.splitlines(True)",
            "                    new_file = result.splitlines(True)",
            "",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to open file '{0}'. \"",
            "            \"Exception: {1}\".format(path, exc)",
            "            )",
            "    finally:",
            "        if r_data and isinstance(r_data, mmap.mmap):",
            "            r_data.close()",
            "",
            "    if has_changes and not dry_run:",
            "        # Write the replacement text in this block.",
            "        try:",
            "            # Create a copy to read from and to use as a backup later",
            "            temp_file = _mkstemp_copy(path=path,",
            "                                      preserve_inode=preserve_inode)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "        r_data = None",
            "        try:",
            "            # Open the file in write mode",
            "            with salt.utils.fopen(path,",
            "                        mode='w',",
            "                        buffering=bufsize) as w_file:",
            "                try:",
            "                    # Open the temp file in read mode",
            "                    with salt.utils.fopen(temp_file,",
            "                                          mode='r',",
            "                                          buffering=bufsize) as r_file:",
            "                        r_data = mmap.mmap(r_file.fileno(),",
            "                                           0,",
            "                                           access=mmap.ACCESS_READ)",
            "                        result, nrepl = re.subn(cpattern, repl,",
            "                                                r_data, count)",
            "                        try:",
            "                            w_file.write(salt.utils.to_str(result))",
            "                        except (OSError, IOError) as exc:",
            "                            raise CommandExecutionError(",
            "                                \"Unable to write file '{0}'. Contents may \"",
            "                                \"be truncated. Temporary file contains copy \"",
            "                                \"at '{1}'. \"",
            "                                \"Exception: {2}\".format(path, temp_file, exc)",
            "                                )",
            "                except (OSError, IOError) as exc:",
            "                    raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "                finally:",
            "                    if r_data and isinstance(r_data, mmap.mmap):",
            "                        r_data.close()",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "    if not found and (append_if_not_found or prepend_if_not_found):",
            "        if not_found_content is None:",
            "            not_found_content = repl",
            "        if prepend_if_not_found:",
            "            new_file.insert(0, not_found_content + b'\\n')",
            "        else:",
            "            # append_if_not_found",
            "            # Make sure we have a newline at the end of the file",
            "            if 0 != len(new_file):",
            "                if not new_file[-1].endswith(b'\\n'):",
            "                    new_file[-1] += b'\\n'",
            "            new_file.append(not_found_content + b'\\n')",
            "        has_changes = True",
            "        if not dry_run:",
            "            try:",
            "                # Create a copy to read from and for later use as a backup",
            "                temp_file = _mkstemp_copy(path=path,",
            "                                          preserve_inode=preserve_inode)",
            "            except (OSError, IOError) as exc:",
            "                raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "            # write new content in the file while avoiding partial reads",
            "            try:",
            "                fh_ = salt.utils.atomicfile.atomic_open(path, 'w')",
            "                for line in new_file:",
            "                    fh_.write(salt.utils.to_str(line))",
            "            finally:",
            "                fh_.close()",
            "",
            "    if backup and has_changes and not dry_run:",
            "        # keep the backup only if it was requested",
            "        # and only if there were any changes",
            "        backup_name = '{0}{1}'.format(path, backup)",
            "        try:",
            "            shutil.move(temp_file, backup_name)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to move the temp file '{0}' to the \"",
            "                \"backup file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "                )",
            "        if symlink:",
            "            symlink_backup = '{0}{1}'.format(given_path, backup)",
            "            target_backup = '{0}{1}'.format(target_path, backup)",
            "            # Always clobber any existing symlink backup",
            "            # to match the behaviour of the 'backup' option",
            "            try:",
            "                os.symlink(target_backup, symlink_backup)",
            "            except OSError:",
            "                os.remove(symlink_backup)",
            "                os.symlink(target_backup, symlink_backup)",
            "            except:",
            "                raise CommandExecutionError(",
            "                    \"Unable create backup symlink '{0}'. \"",
            "                    \"Target was '{1}'. \"",
            "                    \"Exception: {2}\".format(symlink_backup, target_backup,",
            "                                            exc)",
            "                    )",
            "    elif temp_file:",
            "        try:",
            "            os.remove(temp_file)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to delete temp file '{0}'. \"",
            "                \"Exception: {1}\".format(temp_file, exc)",
            "                )",
            "",
            "    if not dry_run and not salt.utils.is_windows():",
            "        check_perms(path, None, pre_user, pre_group, pre_mode)",
            "",
            "    if show_changes:",
            "        orig_file_as_str = ''.join([salt.utils.to_str(x) for x in orig_file])",
            "        new_file_as_str = ''.join([salt.utils.to_str(x) for x in new_file])",
            "        return ''.join(difflib.unified_diff(orig_file_as_str, new_file_as_str))",
            "",
            "    return has_changes",
            "",
            "",
            "def blockreplace(path,",
            "        marker_start='#-- start managed zone --',",
            "        marker_end='#-- end managed zone --',",
            "        content='',",
            "        append_if_not_found=False,",
            "        prepend_if_not_found=False,",
            "        backup='.bak',",
            "        dry_run=False,",
            "        show_changes=True,",
            "        append_newline=False,",
            "        ):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Replace content of a text block in a file, delimited by line markers",
            "",
            "    A block of content delimited by comments can help you manage several lines",
            "    entries without worrying about old entries removal.",
            "",
            "    .. note::",
            "",
            "        This function will store two copies of the file in-memory (the original",
            "        version and the edited version) in order to detect changes and only",
            "        edit the targeted file if necessary.",
            "",
            "    path",
            "        Filesystem path to the file to be edited",
            "",
            "    marker_start",
            "        The line content identifying a line as the start of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output",
            "",
            "    marker_end",
            "        The line content identifying a line as the end of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output",
            "",
            "    content",
            "        The content to be used between the two lines identified by marker_start",
            "        and marker_stop.",
            "",
            "    append_if_not_found : False",
            "        If markers are not found and set to ``True`` then, the markers and",
            "        content will be appended to the file.",
            "",
            "    prepend_if_not_found : False",
            "        If markers are not found and set to ``True`` then, the markers and",
            "        content will be prepended to the file.",
            "",
            "",
            "    backup",
            "        The file extension to use for a backup of the file if any edit is made.",
            "        Set to ``False`` to skip making a backup.",
            "",
            "    dry_run",
            "        Don't make any edits to the file.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``,",
            "        return a boolean if any changes were made.",
            "",
            "    append_newline:",
            "        Append a newline to the content block. For more information see:",
            "        https://github.com/saltstack/salt/issues/33686",
            "",
            "        .. versionadded:: 2016.3.4",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.blockreplace /etc/hosts '#-- start managed zone foobar : DO NOT EDIT --' \\\\",
            "        '#-- end managed zone foobar --' $'10.0.1.1 foo.foobar\\\\n10.0.1.2 bar.foobar' True",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        raise SaltInvocationError('File not found: {0}'.format(path))",
            "",
            "    if append_if_not_found and prepend_if_not_found:",
            "        raise SaltInvocationError(",
            "            'Only one of append and prepend_if_not_found is permitted'",
            "        )",
            "",
            "    if not salt.utils.istextfile(path):",
            "        raise SaltInvocationError(",
            "            'Cannot perform string replacements on a binary file: {0}'",
            "            .format(path)",
            "        )",
            "",
            "    # Search the file; track if any changes have been made for the return val",
            "    has_changes = False",
            "    orig_file = []",
            "    new_file = []",
            "    in_block = False",
            "    old_content = ''",
            "    done = False",
            "    # we do not use in_place editing to avoid file attrs modifications when",
            "    # no changes are required and to avoid any file access on a partially",
            "    # written file.",
            "    # we could also use salt.utils.filebuffer.BufferedReader",
            "    try:",
            "        fi_file = fileinput.input(path,",
            "                    inplace=False, backup=False,",
            "                    bufsize=1, mode='r')",
            "        for line in fi_file:",
            "",
            "            result = line",
            "",
            "            if marker_start in line:",
            "                # managed block start found, start recording",
            "                in_block = True",
            "",
            "            else:",
            "                if in_block:",
            "                    if marker_end in line:",
            "                        # end of block detected",
            "                        in_block = False",
            "",
            "                        # Check for multi-line '\\n' terminated content as split will",
            "                        # introduce an unwanted additional new line.",
            "                        if content and content[-1] == '\\n':",
            "                            content = content[:-1]",
            "",
            "                        # push new block content in file",
            "                        for cline in content.split('\\n'):",
            "                            new_file.append(cline + '\\n')",
            "",
            "                        done = True",
            "",
            "                    else:",
            "                        # remove old content, but keep a trace",
            "                        old_content += line",
            "                        result = None",
            "            # else: we are not in the marked block, keep saving things",
            "",
            "            orig_file.append(line)",
            "            if result is not None:",
            "                new_file.append(result)",
            "        # end for. If we are here without block management we maybe have some problems,",
            "        # or we need to initialise the marked block",
            "",
            "    finally:",
            "        fi_file.close()",
            "",
            "    if in_block:",
            "        # unterminated block => bad, always fail",
            "        raise CommandExecutionError(",
            "            'Unterminated marked block. End of file reached before marker_end.'",
            "        )",
            "",
            "    if not done:",
            "        if prepend_if_not_found:",
            "            # add the markers and content at the beginning of file",
            "            new_file.insert(0, marker_end + '\\n')",
            "            if append_newline is True:",
            "                new_file.insert(0, content + '\\n')",
            "            else:",
            "                new_file.insert(0, content)",
            "            new_file.insert(0, marker_start + '\\n')",
            "            done = True",
            "        elif append_if_not_found:",
            "            # Make sure we have a newline at the end of the file",
            "            if 0 != len(new_file):",
            "                if not new_file[-1].endswith('\\n'):",
            "                    new_file[-1] += '\\n'",
            "            # add the markers and content at the end of file",
            "            new_file.append(marker_start + '\\n')",
            "            if append_newline is True:",
            "                new_file.append(content + '\\n')",
            "            else:",
            "                new_file.append(content)",
            "            new_file.append(marker_end + '\\n')",
            "            done = True",
            "        else:",
            "            raise CommandExecutionError(",
            "                'Cannot edit marked block. Markers were not found in file.'",
            "            )",
            "",
            "    if done:",
            "        diff = ''.join(difflib.unified_diff(orig_file, new_file))",
            "        has_changes = diff is not ''",
            "        if has_changes and not dry_run:",
            "            # changes detected",
            "            # backup file attrs",
            "            perms = {}",
            "            perms['user'] = get_user(path)",
            "            perms['group'] = get_group(path)",
            "            perms['mode'] = salt.utils.normalize_mode(get_mode(path))",
            "",
            "            # backup old content",
            "            if backup is not False:",
            "                backup_path = '{0}{1}'.format(path, backup)",
            "                shutil.copy2(path, backup_path)",
            "                # copy2 does not preserve ownership",
            "                check_perms(backup_path,",
            "                        None,",
            "                        perms['user'],",
            "                        perms['group'],",
            "                        perms['mode'])",
            "",
            "            # write new content in the file while avoiding partial reads",
            "            try:",
            "                fh_ = salt.utils.atomicfile.atomic_open(path, 'w')",
            "                for line in new_file:",
            "                    fh_.write(line)",
            "            finally:",
            "                fh_.close()",
            "",
            "            # this may have overwritten file attrs",
            "            check_perms(path,",
            "                    None,",
            "                    perms['user'],",
            "                    perms['group'],",
            "                    perms['mode'])",
            "",
            "        if show_changes:",
            "            return diff",
            "",
            "    return has_changes",
            "",
            "",
            "def search(path,",
            "        pattern,",
            "        flags=8,",
            "        bufsize=1,",
            "        ignore_if_missing=False,",
            "        multiline=False",
            "        ):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Search for occurrences of a pattern in a file",
            "",
            "    Except for multiline, params are identical to",
            "    :py:func:`~salt.modules.file.replace`.",
            "",
            "    multiline",
            "        If true, inserts 'MULTILINE' into ``flags`` and sets ``bufsize`` to",
            "        'file'.",
            "",
            "        .. versionadded:: 2015.8.0",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.search /etc/crontab 'mymaintenance.sh'",
            "    '''",
            "    if multiline:",
            "        flags = _add_flags(flags, 'MULTILINE')",
            "        bufsize = 'file'",
            "",
            "    # This function wraps file.replace on purpose in order to enforce",
            "    # consistent usage, compatible regex's, expected behavior, *and* bugs. :)",
            "    # Any enhancements or fixes to one should affect the other.",
            "    return replace(path,",
            "            pattern,",
            "            '',",
            "            flags=flags,",
            "            bufsize=bufsize,",
            "            dry_run=True,",
            "            search_only=True,",
            "            show_changes=False,",
            "            ignore_if_missing=ignore_if_missing)",
            "",
            "",
            "def patch(originalfile, patchfile, options='', dry_run=False):",
            "    '''",
            "    .. versionadded:: 0.10.4",
            "",
            "    Apply a patch to a file or directory.",
            "",
            "    Equivalent to:",
            "",
            "    .. code-block:: bash",
            "",
            "        patch <options> -i <patchfile> <originalfile>",
            "",
            "    Or, when a directory is patched:",
            "",
            "    .. code-block:: bash",
            "",
            "        patch <options> -i <patchfile> -d <originalfile> -p0",
            "",
            "    originalfile",
            "        The full path to the file or directory to be patched",
            "    patchfile",
            "        A patch file to apply to ``originalfile``",
            "    options",
            "        Options to pass to patch.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.patch /opt/file.txt /tmp/file.txt.patch",
            "    '''",
            "    patchpath = salt.utils.which('patch')",
            "    if not patchpath:",
            "        raise CommandExecutionError(",
            "            'patch executable not found. Is the distribution\\'s patch '",
            "            'package installed?'",
            "        )",
            "",
            "    cmd = [patchpath]",
            "    cmd.extend(salt.utils.shlex_split(options))",
            "    if dry_run:",
            "        if __grains__['kernel'] in ('FreeBSD', 'OpenBSD'):",
            "            cmd.append('-C')",
            "        else:",
            "            cmd.append('--dry-run')",
            "",
            "    # this argument prevents interactive prompts when the patch fails to apply.",
            "    # the exit code will still be greater than 0 if that is the case.",
            "    if '-N' not in cmd and '--forward' not in cmd:",
            "        cmd.append('--forward')",
            "",
            "    has_rejectfile_option = False",
            "    for option in cmd:",
            "        if option == '-r' or option.startswith('-r ') \\",
            "                or option.startswith('--reject-file'):",
            "            has_rejectfile_option = True",
            "            break",
            "",
            "    # by default, patch will write rejected patch files to <filename>.rej.",
            "    # this option prevents that.",
            "    if not has_rejectfile_option:",
            "        cmd.append('--reject-file=-')",
            "",
            "    cmd.extend(['-i', patchfile])",
            "",
            "    if os.path.isdir(originalfile):",
            "        cmd.extend(['-d', originalfile])",
            "",
            "        has_strip_option = False",
            "        for option in cmd:",
            "            if option.startswith('-p') or option.startswith('--strip='):",
            "                has_strip_option = True",
            "                break",
            "",
            "        if not has_strip_option:",
            "            cmd.append('--strip=0')",
            "    else:",
            "        cmd.append(originalfile)",
            "",
            "    return __salt__['cmd.run_all'](cmd, python_shell=False)",
            "",
            "",
            "def contains(path, text):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return ``True`` if the file at ``path`` contains ``text``",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains /etc/crontab 'mymaintenance.sh'",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    stripped_text = str(text).strip()",
            "    try:",
            "        with salt.utils.filebuffer.BufferedReader(path) as breader:",
            "            for chunk in breader:",
            "                if stripped_text in chunk:",
            "                    return True",
            "        return False",
            "    except (IOError, OSError):",
            "        return False",
            "",
            "",
            "def contains_regex(path, regex, lchar=''):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return True if the given regular expression matches on any line in the text",
            "    of a given file.",
            "",
            "    If the lchar argument (leading char) is specified, it",
            "    will strip `lchar` from the left side of each line before trying to match",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains_regex /etc/crontab",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    try:",
            "        with salt.utils.fopen(path, 'r') as target:",
            "            for line in target:",
            "                if lchar:",
            "                    line = line.lstrip(lchar)",
            "                if re.search(regex, line):",
            "                    return True",
            "            return False",
            "    except (IOError, OSError):",
            "        return False",
            "",
            "",
            "def contains_glob(path, glob_expr):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return ``True`` if the given glob matches a string in the named file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains_glob /etc/foobar '*cheese*'",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    try:",
            "        with salt.utils.filebuffer.BufferedReader(path) as breader:",
            "            for chunk in breader:",
            "                if fnmatch.fnmatch(chunk, glob_expr):",
            "                    return True",
            "            return False",
            "    except (IOError, OSError):",
            "        return False",
            "",
            "",
            "def append(path, *args, **kwargs):",
            "    '''",
            "    .. versionadded:: 0.9.5",
            "",
            "    Append text to the end of a file",
            "",
            "    path",
            "        path to file",
            "",
            "    `*args`",
            "        strings to append to file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.append /etc/motd \\\\",
            "                \"With all thine offerings thou shalt offer salt.\" \\\\",
            "                \"Salt is what makes things taste bad when it isn't in them.\"",
            "",
            "    .. admonition:: Attention",
            "",
            "        If you need to pass a string to append and that string contains",
            "        an equal sign, you **must** include the argument name, args.",
            "        For example:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.append /etc/motd args='cheese=spam'",
            "",
            "            salt '*' file.append /etc/motd args=\"['cheese=spam','spam=cheese']\"",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    # Largely inspired by Fabric's contrib.files.append()",
            "",
            "    if 'args' in kwargs:",
            "        if isinstance(kwargs['args'], list):",
            "            args = kwargs['args']",
            "        else:",
            "            args = [kwargs['args']]",
            "",
            "    # Make sure we have a newline at the end of the file. Do this in binary",
            "    # mode so SEEK_END with nonzero offset will work.",
            "    with salt.utils.fopen(path, 'rb+') as ofile:",
            "        linesep = salt.utils.to_bytes(os.linesep)",
            "        try:",
            "            ofile.seek(-len(linesep), os.SEEK_END)",
            "        except IOError as exc:",
            "            if exc.errno in (errno.EINVAL, errno.ESPIPE):",
            "                # Empty file, simply append lines at the beginning of the file",
            "                pass",
            "            else:",
            "                raise",
            "        else:",
            "            if ofile.read(len(linesep)) != linesep:",
            "                ofile.seek(0, os.SEEK_END)",
            "                ofile.write(linesep)",
            "",
            "    # Append lines in text mode",
            "    with salt.utils.fopen(path, 'a') as ofile:",
            "        for new_line in args:",
            "            ofile.write('{0}{1}'.format(new_line, os.linesep))",
            "",
            "    return 'Wrote {0} lines to \"{1}\"'.format(len(args), path)",
            "",
            "",
            "def prepend(path, *args, **kwargs):",
            "    '''",
            "    .. versionadded:: 2014.7.0",
            "",
            "    Prepend text to the beginning of a file",
            "",
            "    path",
            "        path to file",
            "",
            "    `*args`",
            "        strings to prepend to the file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.prepend /etc/motd \\\\",
            "                \"With all thine offerings thou shalt offer salt.\" \\\\",
            "                \"Salt is what makes things taste bad when it isn't in them.\"",
            "",
            "    .. admonition:: Attention",
            "",
            "        If you need to pass a string to append and that string contains",
            "        an equal sign, you **must** include the argument name, args.",
            "        For example:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.prepend /etc/motd args='cheese=spam'",
            "",
            "            salt '*' file.prepend /etc/motd args=\"['cheese=spam','spam=cheese']\"",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if 'args' in kwargs:",
            "        if isinstance(kwargs['args'], list):",
            "            args = kwargs['args']",
            "        else:",
            "            args = [kwargs['args']]",
            "",
            "    try:",
            "        with salt.utils.fopen(path) as fhr:",
            "            contents = fhr.readlines()",
            "    except IOError:",
            "        contents = []",
            "",
            "    preface = []",
            "    for line in args:",
            "        preface.append('{0}\\n'.format(line))",
            "",
            "    with salt.utils.fopen(path, \"w\") as ofile:",
            "        contents = preface + contents",
            "        ofile.write(''.join(contents))",
            "    return 'Prepended {0} lines to \"{1}\"'.format(len(args), path)",
            "",
            "",
            "def write(path, *args, **kwargs):",
            "    '''",
            "    .. versionadded:: 2014.7.0",
            "",
            "    Write text to a file, overwriting any existing contents.",
            "",
            "    path",
            "        path to file",
            "",
            "    `*args`",
            "        strings to write to the file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.write /etc/motd \\\\",
            "                \"With all thine offerings thou shalt offer salt.\"",
            "",
            "    .. admonition:: Attention",
            "",
            "        If you need to pass a string to append and that string contains",
            "        an equal sign, you **must** include the argument name, args.",
            "        For example:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.write /etc/motd args='cheese=spam'",
            "",
            "            salt '*' file.write /etc/motd args=\"['cheese=spam','spam=cheese']\"",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if 'args' in kwargs:",
            "        if isinstance(kwargs['args'], list):",
            "            args = kwargs['args']",
            "        else:",
            "            args = [kwargs['args']]",
            "",
            "    contents = []",
            "    for line in args:",
            "        contents.append('{0}\\n'.format(line))",
            "    with salt.utils.fopen(path, \"w\") as ofile:",
            "        ofile.write(''.join(contents))",
            "    return 'Wrote {0} lines to \"{1}\"'.format(len(contents), path)",
            "",
            "",
            "def touch(name, atime=None, mtime=None):",
            "    '''",
            "    .. versionadded:: 0.9.5",
            "",
            "    Just like the ``touch`` command, create a file if it doesn't exist or",
            "    simply update the atime and mtime if it already does.",
            "",
            "    atime:",
            "        Access time in Unix epoch time",
            "    mtime:",
            "        Last modification in Unix epoch time",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.touch /var/log/emptyfile",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if atime and atime.isdigit():",
            "        atime = int(atime)",
            "    if mtime and mtime.isdigit():",
            "        mtime = int(mtime)",
            "    try:",
            "        if not os.path.exists(name):",
            "            with salt.utils.fopen(name, 'a') as fhw:",
            "                fhw.write('')",
            "",
            "        if not atime and not mtime:",
            "            times = None",
            "        elif not mtime and atime:",
            "            times = (atime, time.time())",
            "        elif not atime and mtime:",
            "            times = (time.time(), mtime)",
            "        else:",
            "            times = (atime, mtime)",
            "        os.utime(name, times)",
            "",
            "    except TypeError:",
            "        raise SaltInvocationError('atime and mtime must be integers')",
            "    except (IOError, OSError) as exc:",
            "        raise CommandExecutionError(exc.strerror)",
            "",
            "    return os.path.exists(name)",
            "",
            "",
            "def seek_read(path, size, offset):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Seek to a position on a file and read it",
            "",
            "    path",
            "        path to file",
            "",
            "    seek",
            "        amount to read at once",
            "",
            "    offset",
            "        offset to start into the file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.seek_read /path/to/file 4096 0",
            "    '''",
            "    path = os.path.expanduser(path)",
            "    try:",
            "        seek_fh = os.open(path, os.O_RDONLY)",
            "        os.lseek(seek_fh, int(offset), 0)",
            "        data = os.read(seek_fh, int(size))",
            "    finally:",
            "        os.close(seek_fh)",
            "    return data",
            "",
            "",
            "def seek_write(path, data, offset):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Seek to a position on a file and write to it",
            "",
            "    path",
            "        path to file",
            "",
            "    data",
            "        data to write to file",
            "",
            "    offset",
            "        position in file to start writing",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.seek_write /path/to/file 'some data' 4096",
            "    '''",
            "    path = os.path.expanduser(path)",
            "    try:",
            "        seek_fh = os.open(path, os.O_WRONLY)",
            "        os.lseek(seek_fh, int(offset), 0)",
            "        ret = os.write(seek_fh, data)",
            "        os.fsync(seek_fh)",
            "    finally:",
            "        os.close(seek_fh)",
            "    return ret",
            "",
            "",
            "def truncate(path, length):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Seek to a position on a file and delete everything after that point",
            "",
            "    path",
            "        path to file",
            "",
            "    length",
            "        offset into file to truncate",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.truncate /path/to/file 512",
            "    '''",
            "    path = os.path.expanduser(path)",
            "    with salt.utils.fopen(path, 'rb+') as seek_fh:",
            "        seek_fh.truncate(int(length))",
            "",
            "",
            "def link(src, path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Create a hard link to a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.link /path/to/file /path/to/link",
            "    '''",
            "    src = os.path.expanduser(src)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        os.link(src, path)",
            "        return True",
            "    except (OSError, IOError):",
            "        raise CommandExecutionError('Could not create \\'{0}\\''.format(path))",
            "    return False",
            "",
            "",
            "def is_link(path):",
            "    '''",
            "    Check if the path is a symbolic link",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_link /path/to/link",
            "    '''",
            "    # This function exists because os.path.islink does not support Windows,",
            "    # therefore a custom function will need to be called. This function",
            "    # therefore helps API consistency by providing a single function to call for",
            "    # both operating systems.",
            "",
            "    return os.path.islink(os.path.expanduser(path))",
            "",
            "",
            "def symlink(src, path):",
            "    '''",
            "    Create a symbolic link (symlink, soft link) to a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.symlink /path/to/file /path/to/link",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        os.symlink(src, path)",
            "        return True",
            "    except (OSError, IOError):",
            "        raise CommandExecutionError('Could not create \\'{0}\\''.format(path))",
            "    return False",
            "",
            "",
            "def rename(src, dst):",
            "    '''",
            "    Rename a file or directory",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.rename /path/to/src /path/to/dst",
            "    '''",
            "    src = os.path.expanduser(src)",
            "    dst = os.path.expanduser(dst)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        os.rename(src, dst)",
            "        return True",
            "    except OSError:",
            "        raise CommandExecutionError(",
            "            'Could not rename \\'{0}\\' to \\'{1}\\''.format(src, dst)",
            "        )",
            "    return False",
            "",
            "",
            "def copy(src, dst, recurse=False, remove_existing=False):",
            "    '''",
            "    Copy a file or directory from source to dst",
            "",
            "    In order to copy a directory, the recurse flag is required, and",
            "    will by default overwrite files in the destination with the same path,",
            "    and retain all other existing files. (similar to cp -r on unix)",
            "",
            "    remove_existing will remove all files in the target directory,",
            "    and then copy files from the source.",
            "",
            "    .. note::",
            "        The copy function accepts paths that are local to the Salt minion.",
            "        This function does not support salt://, http://, or the other",
            "        additional file paths that are supported by :mod:`states.file.managed",
            "        <salt.states.file.managed>` and :mod:`states.file.recurse",
            "        <salt.states.file.recurse>`.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.copy /path/to/src /path/to/dst",
            "        salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True",
            "        salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True remove_existing=True",
            "",
            "    '''",
            "    src = os.path.expanduser(src)",
            "    dst = os.path.expanduser(dst)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    if not os.path.exists(src):",
            "        raise CommandExecutionError('No such file or directory \\'{0}\\''.format(src))",
            "",
            "    if not salt.utils.is_windows():",
            "        pre_user = get_user(src)",
            "        pre_group = get_group(src)",
            "        pre_mode = salt.utils.normalize_mode(get_mode(src))",
            "",
            "    try:",
            "        if (os.path.exists(dst) and os.path.isdir(dst)) or os.path.isdir(src):",
            "            if not recurse:",
            "                raise SaltInvocationError(",
            "                    \"Cannot copy overwriting a directory without recurse flag set to true!\")",
            "            if remove_existing:",
            "                if os.path.exists(dst):",
            "                    shutil.rmtree(dst)",
            "                shutil.copytree(src, dst)",
            "            else:",
            "                salt.utils.files.recursive_copy(src, dst)",
            "        else:",
            "            shutil.copyfile(src, dst)",
            "    except OSError:",
            "        raise CommandExecutionError(",
            "            'Could not copy \\'{0}\\' to \\'{1}\\''.format(src, dst)",
            "        )",
            "",
            "    if not salt.utils.is_windows():",
            "        check_perms(dst, None, pre_user, pre_group, pre_mode)",
            "    return True",
            "",
            "",
            "def lstat(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Returns the lstat attributes for the given file or dir. Does not support",
            "    symbolic links.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.lstat /path/to/file",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Path to file must be absolute.')",
            "",
            "    try:",
            "        lst = os.lstat(path)",
            "        return dict((key, getattr(lst, key)) for key in ('st_atime', 'st_ctime',",
            "            'st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size', 'st_uid'))",
            "    except Exception:",
            "        return {}",
            "",
            "",
            "def access(path, mode):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Test whether the Salt process has the specified access to the file. One of",
            "    the following modes must be specified:",
            "",
            "    .. code-block::text",
            "",
            "        f: Test the existence of the path",
            "        r: Test the readability of the path",
            "        w: Test the writability of the path",
            "        x: Test whether the path can be executed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.access /path/to/file f",
            "        salt '*' file.access /path/to/file x",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Path to link must be absolute.')",
            "",
            "    modes = {'f': os.F_OK,",
            "             'r': os.R_OK,",
            "             'w': os.W_OK,",
            "             'x': os.X_OK}",
            "",
            "    if mode in modes:",
            "        return os.access(path, modes[mode])",
            "    elif mode in six.itervalues(modes):",
            "        return os.access(path, mode)",
            "    else:",
            "        raise SaltInvocationError('Invalid mode specified.')",
            "",
            "",
            "def readlink(path, canonicalize=False):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Return the path that a symlink points to",
            "    If canonicalize is set to True, then it return the final target",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.readlink /path/to/link",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Path to link must be absolute.')",
            "",
            "    if not os.path.islink(path):",
            "        raise SaltInvocationError('A valid link was not specified.')",
            "",
            "    if canonicalize:",
            "        return os.path.realpath(path)",
            "    else:",
            "        return os.readlink(path)",
            "",
            "",
            "def readdir(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Return a list containing the contents of a directory",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.readdir /path/to/dir/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Dir path must be absolute.')",
            "",
            "    if not os.path.isdir(path):",
            "        raise SaltInvocationError('A valid directory was not specified.')",
            "",
            "    dirents = ['.', '..']",
            "    dirents.extend(os.listdir(path))",
            "    return dirents",
            "",
            "",
            "def statvfs(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Perform a statvfs call against the filesystem that the file resides on",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.statvfs /path/to/file",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        stv = os.statvfs(path)",
            "        return dict((key, getattr(stv, key)) for key in ('f_bavail', 'f_bfree',",
            "            'f_blocks', 'f_bsize', 'f_favail', 'f_ffree', 'f_files', 'f_flag',",
            "            'f_frsize', 'f_namemax'))",
            "    except (OSError, IOError):",
            "        raise CommandExecutionError('Could not statvfs \\'{0}\\''.format(path))",
            "    return False",
            "",
            "",
            "def stats(path, hash_type=None, follow_symlinks=True):",
            "    '''",
            "    Return a dict containing the stats for a given file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.stats /etc/passwd",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    ret = {}",
            "    if not os.path.exists(path):",
            "        try:",
            "            # Broken symlinks will return False for os.path.exists(), but still",
            "            # have a uid and gid",
            "            pstat = os.lstat(path)",
            "        except OSError:",
            "            # Not a broken symlink, just a nonexistent path",
            "            return ret",
            "    else:",
            "        if follow_symlinks:",
            "            pstat = os.stat(path)",
            "        else:",
            "            pstat = os.lstat(path)",
            "    ret['inode'] = pstat.st_ino",
            "    ret['uid'] = pstat.st_uid",
            "    ret['gid'] = pstat.st_gid",
            "    ret['group'] = gid_to_group(pstat.st_gid)",
            "    ret['user'] = uid_to_user(pstat.st_uid)",
            "    ret['atime'] = pstat.st_atime",
            "    ret['mtime'] = pstat.st_mtime",
            "    ret['ctime'] = pstat.st_ctime",
            "    ret['size'] = pstat.st_size",
            "    ret['mode'] = str(oct(stat.S_IMODE(pstat.st_mode)))",
            "    if hash_type:",
            "        ret['sum'] = get_hash(path, hash_type)",
            "    ret['type'] = 'file'",
            "    if stat.S_ISDIR(pstat.st_mode):",
            "        ret['type'] = 'dir'",
            "    if stat.S_ISCHR(pstat.st_mode):",
            "        ret['type'] = 'char'",
            "    if stat.S_ISBLK(pstat.st_mode):",
            "        ret['type'] = 'block'",
            "    if stat.S_ISREG(pstat.st_mode):",
            "        ret['type'] = 'file'",
            "    if stat.S_ISLNK(pstat.st_mode):",
            "        ret['type'] = 'link'",
            "    if stat.S_ISFIFO(pstat.st_mode):",
            "        ret['type'] = 'pipe'",
            "    if stat.S_ISSOCK(pstat.st_mode):",
            "        ret['type'] = 'socket'",
            "    ret['target'] = os.path.realpath(path)",
            "    return ret",
            "",
            "",
            "def rmdir(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Remove the specified directory. Fails if a directory is not empty.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.rmdir /tmp/foo/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    if not os.path.isdir(path):",
            "        raise SaltInvocationError('A valid directory was not specified.')",
            "",
            "    try:",
            "        os.rmdir(path)",
            "        return True",
            "    except OSError as exc:",
            "        return exc.strerror",
            "",
            "",
            "def remove(path):",
            "    '''",
            "    Remove the named file. If a directory is supplied, it will be recursively",
            "    deleted.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.remove /tmp/foo",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute: {0}'.format(path))",
            "",
            "    try:",
            "        if os.path.isfile(path) or os.path.islink(path):",
            "            os.remove(path)",
            "            return True",
            "        elif os.path.isdir(path):",
            "            shutil.rmtree(path)",
            "            return True",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            'Could not remove \\'{0}\\': {1}'.format(path, exc)",
            "        )",
            "    return False",
            "",
            "",
            "def directory_exists(path):",
            "    '''",
            "    Tests to see if path is a valid directory.  Returns True/False.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.directory_exists /etc",
            "",
            "    '''",
            "    return os.path.isdir(os.path.expanduser(path))",
            "",
            "",
            "def file_exists(path):",
            "    '''",
            "    Tests to see if path is a valid file.  Returns True/False.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.file_exists /etc/passwd",
            "",
            "    '''",
            "    return os.path.isfile(os.path.expanduser(path))",
            "",
            "",
            "def path_exists_glob(path):",
            "    '''",
            "    Tests to see if path after expansion is a valid path (file or directory).",
            "    Expansion allows usage of ? * and character ranges []. Tilde expansion",
            "    is not supported. Returns True/False.",
            "",
            "    .. versionadded:: Hellium",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.path_exists_glob /etc/pam*/pass*",
            "",
            "    '''",
            "    return True if glob.glob(os.path.expanduser(path)) else False",
            "",
            "",
            "def restorecon(path, recursive=False):",
            "    '''",
            "    Reset the SELinux context on a given path",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "         salt '*' file.restorecon /home/user/.ssh/authorized_keys",
            "    '''",
            "    if recursive:",
            "        cmd = ['restorecon', '-FR', path]",
            "    else:",
            "        cmd = ['restorecon', '-F', path]",
            "    return not __salt__['cmd.retcode'](cmd, python_shell=False)",
            "",
            "",
            "def get_selinux_context(path):",
            "    '''",
            "    Get an SELinux context from a given path",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_selinux_context /etc/hosts",
            "    '''",
            "    out = __salt__['cmd.run'](['ls', '-Z', path], python_shell=False)",
            "",
            "    try:",
            "        ret = re.search(r'\\w+:\\w+:\\w+:\\w+', out).group(0)",
            "    except AttributeError:",
            "        ret = (",
            "            'No selinux context information is available for {0}'.format(path)",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def set_selinux_context(path,",
            "                        user=None,",
            "                        role=None,",
            "                        type=None,    # pylint: disable=W0622",
            "                        range=None):  # pylint: disable=W0622",
            "    '''",
            "    Set a specific SELinux label on a given path",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.set_selinux_context path <role> <type> <range>",
            "    '''",
            "    if not any((user, role, type, range)):",
            "        return False",
            "",
            "    cmd = ['chcon']",
            "    if user:",
            "        cmd.extend(['-u', user])",
            "    if role:",
            "        cmd.extend(['-r', role])",
            "    if type:",
            "        cmd.extend(['-t', type])",
            "    if range:",
            "        cmd.extend(['-l', range])",
            "    cmd.append(path)",
            "",
            "    ret = not __salt__['cmd.retcode'](cmd, python_shell=False)",
            "    if ret:",
            "        return get_selinux_context(path)",
            "    else:",
            "        return ret",
            "",
            "",
            "def source_list(source, source_hash, saltenv):",
            "    '''",
            "    Check the source list and return the source to use",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.source_list salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' base",
            "    '''",
            "    contextkey = '{0}_|-{1}_|-{2}'.format(source, source_hash, saltenv)",
            "    if contextkey in __context__:",
            "        return __context__[contextkey]",
            "",
            "    # get the master file list",
            "    if isinstance(source, list):",
            "        mfiles = [(f, saltenv) for f in __salt__['cp.list_master'](saltenv)]",
            "        mdirs = [(d, saltenv) for d in __salt__['cp.list_master_dirs'](saltenv)]",
            "        for single in source:",
            "            if isinstance(single, dict):",
            "                single = next(iter(single))",
            "",
            "            path, senv = salt.utils.url.parse(single)",
            "            if senv:",
            "                mfiles += [(f, senv) for f in __salt__['cp.list_master'](senv)]",
            "                mdirs += [(d, senv) for d in __salt__['cp.list_master_dirs'](senv)]",
            "",
            "        ret = None",
            "        for single in source:",
            "            if isinstance(single, dict):",
            "                # check the proto, if it is http or ftp then download the file",
            "                # to check, if it is salt then check the master list",
            "                # if it is a local file, check if the file exists",
            "                if len(single) != 1:",
            "                    continue",
            "                single_src = next(iter(single))",
            "                single_hash = single[single_src] if single[single_src] else source_hash",
            "                urlparsed_single_src = _urlparse(single_src)",
            "                proto = urlparsed_single_src.scheme",
            "                if proto == 'salt':",
            "                    path, senv = salt.utils.url.parse(single_src)",
            "                    if not senv:",
            "                        senv = saltenv",
            "                    if (path, saltenv) in mfiles or (path, saltenv) in mdirs:",
            "                        ret = (single_src, single_hash)",
            "                        break",
            "                elif proto.startswith('http') or proto == 'ftp':",
            "                    try:",
            "                        if __salt__['cp.cache_file'](single_src):",
            "                            ret = (single_src, single_hash)",
            "                            break",
            "                    except MinionError as exc:",
            "                        # Error downloading file. Log the caught exception and",
            "                        # continue on to the next source.",
            "                        log.exception(exc)",
            "                elif proto == 'file' and os.path.exists(urlparsed_single_src.path):",
            "                    ret = (single_src, single_hash)",
            "                    break",
            "                elif single_src.startswith('/') and os.path.exists(single_src):",
            "                    ret = (single_src, single_hash)",
            "                    break",
            "            elif isinstance(single, six.string_types):",
            "                path, senv = salt.utils.url.parse(single)",
            "                if not senv:",
            "                    senv = saltenv",
            "                if (path, senv) in mfiles or (path, senv) in mdirs:",
            "                    ret = (single, source_hash)",
            "                    break",
            "                urlparsed_src = _urlparse(single)",
            "                proto = urlparsed_src.scheme",
            "                if proto == 'file' and os.path.exists(urlparsed_src.path):",
            "                    ret = (single, source_hash)",
            "                    break",
            "                elif proto.startswith('http') or proto == 'ftp':",
            "                    if __salt__['cp.cache_file'](single):",
            "                        ret = (single, source_hash)",
            "                        break",
            "                elif single.startswith('/') and os.path.exists(single):",
            "                    ret = (single, source_hash)",
            "                    break",
            "        if ret is None:",
            "            # None of the list items matched",
            "            raise CommandExecutionError(",
            "                'none of the specified sources were found'",
            "            )",
            "    else:",
            "        ret = (source, source_hash)",
            "",
            "    __context__[contextkey] = ret",
            "    return ret",
            "",
            "",
            "def apply_template_on_contents(",
            "        contents,",
            "        template,",
            "        context,",
            "        defaults,",
            "        saltenv):",
            "    '''",
            "    Return the contents after applying the templating engine",
            "",
            "    contents",
            "        template string",
            "",
            "    template",
            "        template format",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.apply_template_on_contents \\\\",
            "            contents='This is a {{ template }} string.' \\\\",
            "            template=jinja \\\\",
            "            \"context={}\" \"defaults={'template': 'cool'}\" \\\\",
            "            saltenv=base",
            "    '''",
            "    if template in salt.utils.templates.TEMPLATE_REGISTRY:",
            "        context_dict = defaults if defaults else {}",
            "        if context:",
            "            context_dict.update(context)",
            "        # Apply templating",
            "        contents = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "            contents,",
            "            from_str=True,",
            "            to_str=True,",
            "            context=context_dict,",
            "            saltenv=saltenv,",
            "            grains=__opts__['grains'],",
            "            pillar=__pillar__,",
            "            salt=__salt__,",
            "            opts=__opts__)['data']",
            "        if six.PY2:",
            "            contents = contents.encode('utf-8')",
            "    else:",
            "        ret = {}",
            "        ret['result'] = False",
            "        ret['comment'] = ('Specified template format {0} is not supported'",
            "                          ).format(template)",
            "        return ret",
            "    return contents",
            "",
            "",
            "def get_managed(",
            "        name,",
            "        template,",
            "        source,",
            "        source_hash,",
            "        source_hash_name,",
            "        user,",
            "        group,",
            "        mode,",
            "        saltenv,",
            "        context,",
            "        defaults,",
            "        skip_verify=False,",
            "        **kwargs):",
            "    '''",
            "    Return the managed file data for file.managed",
            "",
            "    name",
            "        location where the file lives on the server",
            "",
            "    template",
            "        template format",
            "",
            "    source",
            "        managed source file",
            "",
            "    source_hash",
            "        hash of the source file",
            "",
            "    source_hash_name",
            "        When ``source_hash`` refers to a remote file, this specifies the",
            "        filename to look for in that file.",
            "",
            "        .. versionadded:: 2016.3.5",
            "",
            "    user",
            "        Owner of file",
            "",
            "    group",
            "        Group owner of file",
            "",
            "    mode",
            "        Permissions of file",
            "",
            "    context",
            "        Variables to add to the template context",
            "",
            "    defaults",
            "        Default values of for context_dict",
            "",
            "    skip_verify",
            "        If ``True``, hash verification of remote file sources (``http://``,",
            "        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``",
            "        argument will be ignored.",
            "",
            "        .. versionadded:: 2016.3.0",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_managed /etc/httpd/conf.d/httpd.conf jinja salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' None root root '755' base None None",
            "    '''",
            "    # Copy the file to the minion and templatize it",
            "    sfn = ''",
            "    source_sum = {}",
            "",
            "    def _get_local_file_source_sum(path):",
            "        '''",
            "        DRY helper for getting the source_sum value from a locally cached",
            "        path.",
            "        '''",
            "        return {'hsum': get_hash(path, form='sha256'), 'hash_type': 'sha256'}",
            "",
            "    # If we have a source defined, let's figure out what the hash is",
            "    if source:",
            "        urlparsed_source = _urlparse(source)",
            "        parsed_scheme = urlparsed_source.scheme",
            "        parsed_path = os.path.join(",
            "                urlparsed_source.netloc, urlparsed_source.path).rstrip(os.sep)",
            "",
            "        if parsed_scheme and parsed_scheme.lower() in 'abcdefghijklmnopqrstuvwxyz':",
            "            parsed_path = ':'.join([parsed_scheme, parsed_path])",
            "            parsed_scheme = 'file'",
            "",
            "        if parsed_scheme == 'salt':",
            "            source_sum = __salt__['cp.hash_file'](source, saltenv)",
            "            if not source_sum:",
            "                return '', {}, 'Source file {0} not found'.format(source)",
            "        elif not source_hash and parsed_scheme == 'file':",
            "            source_sum = _get_local_file_source_sum(parsed_path)",
            "        elif not source_hash and source.startswith(os.sep):",
            "            source_sum = _get_local_file_source_sum(source)",
            "        else:",
            "            if not skip_verify:",
            "                if source_hash:",
            "                    try:",
            "                        source_sum = get_source_sum(name,",
            "                                                    source,",
            "                                                    source_hash,",
            "                                                    source_hash_name,",
            "                                                    saltenv)",
            "                    except CommandExecutionError as exc:",
            "                        return '', {}, exc.strerror",
            "                else:",
            "                    msg = (",
            "                        'Unable to verify upstream hash of source file {0}, '",
            "                        'please set source_hash or set skip_verify to True'",
            "                        .format(source)",
            "                    )",
            "                    return '', {}, msg",
            "",
            "    if source and (template or parsed_scheme in salt.utils.files.REMOTE_PROTOS):",
            "        # Check if we have the template or remote file cached",
            "        cache_refetch = False",
            "        cached_dest = __salt__['cp.is_cached'](source, saltenv)",
            "        if cached_dest and (source_hash or skip_verify):",
            "            htype = source_sum.get('hash_type', 'sha256')",
            "            cached_sum = get_hash(cached_dest, form=htype)",
            "            if skip_verify:",
            "                # prev: if skip_verify or cached_sum == source_sum['hsum']:",
            "                # but `cached_sum == source_sum['hsum']` is elliptical as prev if",
            "                sfn = cached_dest",
            "                source_sum = {'hsum': cached_sum, 'hash_type': htype}",
            "            elif cached_sum != source_sum.get('hsum', __opts__['hash_type']):",
            "                cache_refetch = True",
            "",
            "        # If we didn't have the template or remote file, let's get it",
            "        # Similarly when the file has been updated and the cache has to be refreshed",
            "        if not sfn or cache_refetch:",
            "            try:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            except Exception as exc:",
            "                # A 404 or other error code may raise an exception, catch it",
            "                # and return a comment that will fail the calling state.",
            "                return '', {}, 'Failed to cache {0}: {1}'.format(source, exc)",
            "",
            "        # If cache failed, sfn will be False, so do a truth check on sfn first",
            "        # as invoking os.path.exists() on a bool raises a TypeError.",
            "        if not sfn or not os.path.exists(sfn):",
            "            return sfn, {}, 'Source file \\'{0}\\' not found'.format(source)",
            "        if sfn == name:",
            "            raise SaltInvocationError(",
            "                'Source file cannot be the same as destination'",
            "            )",
            "",
            "        if template:",
            "            if template in salt.utils.templates.TEMPLATE_REGISTRY:",
            "                context_dict = defaults if defaults else {}",
            "                if context:",
            "                    context_dict.update(context)",
            "                data = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "                    sfn,",
            "                    name=name,",
            "                    source=source,",
            "                    user=user,",
            "                    group=group,",
            "                    mode=mode,",
            "                    saltenv=saltenv,",
            "                    context=context_dict,",
            "                    salt=__salt__,",
            "                    pillar=__pillar__,",
            "                    grains=__opts__['grains'],",
            "                    opts=__opts__,",
            "                    **kwargs)",
            "            else:",
            "                return sfn, {}, ('Specified template format {0} is not supported'",
            "                                 ).format(template)",
            "",
            "            if data['result']:",
            "                sfn = data['data']",
            "                hsum = get_hash(sfn, form='sha256')",
            "                source_sum = {'hash_type': 'sha256',",
            "                              'hsum': hsum}",
            "            else:",
            "                __clean_tmp(sfn)",
            "                return sfn, {}, data['data']",
            "",
            "    return sfn, source_sum, ''",
            "",
            "",
            "def extract_hash(hash_fn,",
            "                 hash_type='sha256',",
            "                 file_name='',",
            "                 source='',",
            "                 source_hash_name=None):",
            "    '''",
            "    .. versionchanged:: 2016.3.5",
            "        Prior to this version, only the ``file_name`` argument was considered",
            "        for filename matches in the hash file. This would be problematic for",
            "        cases in which the user was relying on a remote checksum file that they",
            "        do not control, and they wished to use a different name for that file",
            "        on the minion from the filename on the remote server (and in the",
            "        checksum file). For example, managing ``/tmp/myfile.tar.gz`` when the",
            "        remote file was at ``https://mydomain.tld/different_name.tar.gz``. The",
            "        :py:func:`file.managed <salt.states.file.managed>` state now also",
            "        passes this function the source URI as well as the ``source_hash_name``",
            "        (if specified). In cases where ``source_hash_name`` is specified, it",
            "        takes precedence over both the ``file_name`` and ``source``. When it is",
            "        not specified, ``file_name`` takes precedence over ``source``. This",
            "        allows for better capability for matching hashes.",
            "    .. versionchanged:: 2016.11.0",
            "        File name and source URI matches are no longer disregarded when",
            "        ``source_hash_name`` is specified. They will be used as fallback",
            "        matches if there is no match to the ``source_hash_name`` value.",
            "",
            "    This routine is called from the :mod:`file.managed",
            "    <salt.states.file.managed>` state to pull a hash from a remote file.",
            "    Regular expressions are used line by line on the ``source_hash`` file, to",
            "    find a potential candidate of the indicated hash type. This avoids many",
            "    problems of arbitrary file layout rules. It specifically permits pulling",
            "    hash codes from debian ``*.dsc`` files.",
            "",
            "    If no exact match of a hash and filename are found, then the first hash",
            "    found (if any) will be returned. If no hashes at all are found, then",
            "    ``None`` will be returned.",
            "",
            "    For example:",
            "",
            "    .. code-block:: yaml",
            "",
            "        openerp_7.0-latest-1.tar.gz:",
            "          file.managed:",
            "            - name: /tmp/openerp_7.0-20121227-075624-1_all.deb",
            "            - source: http://nightly.openerp.com/7.0/nightly/deb/openerp_7.0-20121227-075624-1.tar.gz",
            "            - source_hash: http://nightly.openerp.com/7.0/nightly/deb/openerp_7.0-20121227-075624-1.dsc",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.extract_hash /path/to/hash/file sha512 /etc/foo",
            "    '''",
            "    hash_len = HASHES.get(hash_type)",
            "    if hash_len is None:",
            "        if hash_type:",
            "            log.warning(",
            "                'file.extract_hash: Unsupported hash_type \\'%s\\', falling '",
            "                'back to matching any supported hash_type', hash_type",
            "            )",
            "            hash_type = ''",
            "        hash_len_expr = '{0},{1}'.format(min(HASHES_REVMAP), max(HASHES_REVMAP))",
            "    else:",
            "        hash_len_expr = str(hash_len)",
            "",
            "    filename_separators = string.whitespace + r'\\/'",
            "",
            "    if source_hash_name:",
            "        if not isinstance(source_hash_name, six.string_types):",
            "            source_hash_name = str(source_hash_name)",
            "        source_hash_name_idx = (len(source_hash_name) + 1) * -1",
            "        log.debug(",
            "            'file.extract_hash: Extracting %s hash for file matching '",
            "            'source_hash_name \\'%s\\'',",
            "            'any supported' if not hash_type else hash_type,",
            "            source_hash_name",
            "        )",
            "    if file_name:",
            "        if not isinstance(file_name, six.string_types):",
            "            file_name = str(file_name)",
            "        file_name_basename = os.path.basename(file_name)",
            "        file_name_idx = (len(file_name_basename) + 1) * -1",
            "    if source:",
            "        if not isinstance(source, six.string_types):",
            "            source = str(source)",
            "        urlparsed_source = _urlparse(source)",
            "        source_basename = os.path.basename(",
            "            urlparsed_source.path or urlparsed_source.netloc",
            "        )",
            "        source_idx = (len(source_basename) + 1) * -1",
            "",
            "    basename_searches = [x for x in (file_name, source) if x]",
            "    if basename_searches:",
            "        log.debug(",
            "            'file.extract_hash: %s %s hash for file matching%s: %s',",
            "            'If no source_hash_name match found, will extract'",
            "                if source_hash_name",
            "                else 'Extracting',",
            "            'any supported' if not hash_type else hash_type,",
            "            '' if len(basename_searches) == 1 else ' either of the following',",
            "            ', '.join(basename_searches)",
            "        )",
            "",
            "    partial = None",
            "    found = {}",
            "",
            "    with salt.utils.fopen(hash_fn, 'r') as fp_:",
            "        for line in fp_:",
            "            line = line.strip()",
            "            hash_re = r'(?i)(?<![a-z0-9])([a-f0-9]{' + hash_len_expr + '})(?![a-z0-9])'",
            "            hash_match = re.search(hash_re, line)",
            "            matched = None",
            "            if hash_match:",
            "                matched_hsum = hash_match.group(1)",
            "                if matched_hsum is not None:",
            "                    matched_type = HASHES_REVMAP.get(len(matched_hsum))",
            "                    if matched_type is None:",
            "                        # There was a match, but it's not of the correct length",
            "                        # to match one of the supported hash types.",
            "                        matched = None",
            "                    else:",
            "                        matched = {'hsum': matched_hsum,",
            "                                   'hash_type': matched_type}",
            "",
            "            if matched is None:",
            "                log.debug(",
            "                    'file.extract_hash: In line \\'%s\\', no %shash found',",
            "                    line,",
            "                    '' if not hash_type else hash_type + ' '",
            "                )",
            "                continue",
            "",
            "            if partial is None:",
            "                partial = matched",
            "",
            "            def _add_to_matches(found, line, match_type, value, matched):",
            "                log.debug(",
            "                    'file.extract_hash: Line \\'%s\\' matches %s \\'%s\\'',",
            "                    line, match_type, value",
            "                )",
            "                found.setdefault(match_type, []).append(matched)",
            "",
            "            hash_matched = False",
            "            if source_hash_name:",
            "                if line.endswith(source_hash_name):",
            "                    # Checking the character before where the basename",
            "                    # should start for either whitespace or a path",
            "                    # separator. We can't just rsplit on spaces/whitespace,",
            "                    # because the filename may contain spaces.",
            "                    try:",
            "                        if line[source_hash_name_idx] in string.whitespace:",
            "                            _add_to_matches(found, line, 'source_hash_name',",
            "                                            source_hash_name, matched)",
            "                            hash_matched = True",
            "                    except IndexError:",
            "                        pass",
            "                elif re.match(source_hash_name.replace('.', r'\\.') + r'\\s+',",
            "                              line):",
            "                    _add_to_matches(found, line, 'source_hash_name',",
            "                                    source_hash_name, matched)",
            "                    hash_matched = True",
            "            if file_name:",
            "                if line.endswith(file_name_basename):",
            "                    # Checking the character before where the basename",
            "                    # should start for either whitespace or a path",
            "                    # separator. We can't just rsplit on spaces/whitespace,",
            "                    # because the filename may contain spaces.",
            "                    try:",
            "                        if line[file_name_idx] in filename_separators:",
            "                            _add_to_matches(found, line, 'file_name',",
            "                                            file_name, matched)",
            "                            hash_matched = True",
            "                    except IndexError:",
            "                        pass",
            "                elif re.match(file_name.replace('.', r'\\.') + r'\\s+', line):",
            "                    _add_to_matches(found, line, 'file_name',",
            "                                    file_name, matched)",
            "                    hash_matched = True",
            "            if source:",
            "                if line.endswith(source_basename):",
            "                    # Same as above, we can't just do an rsplit here.",
            "                    try:",
            "                        if line[source_idx] in filename_separators:",
            "                            _add_to_matches(found, line, 'source',",
            "                                            source, matched)",
            "                            hash_matched = True",
            "                    except IndexError:",
            "                        pass",
            "                elif re.match(source.replace('.', r'\\.') + r'\\s+', line):",
            "                    _add_to_matches(found, line, 'source', source, matched)",
            "                    hash_matched = True",
            "",
            "            if not hash_matched:",
            "                log.debug(",
            "                    'file.extract_hash: Line \\'%s\\' contains %s hash '",
            "                    '\\'%s\\', but line did not meet the search criteria',",
            "                    line, matched['hash_type'], matched['hsum']",
            "                )",
            "",
            "    for found_type, found_str in (('source_hash_name', source_hash_name),",
            "                                  ('file_name', file_name),",
            "                                  ('source', source)):",
            "        if found_type in found:",
            "            if len(found[found_type]) > 1:",
            "                log.debug(",
            "                    'file.extract_hash: Multiple %s matches for %s: %s',",
            "                    found_type,",
            "                    found_str,",
            "                    ', '.join(",
            "                        ['{0} ({1})'.format(x['hsum'], x['hash_type'])",
            "                         for x in found[found_type]]",
            "                    )",
            "                )",
            "            ret = found[found_type][0]",
            "            log.debug(",
            "                'file.extract_hash: Returning %s hash \\'%s\\' as a match of %s',",
            "                ret['hash_type'], ret['hsum'], found_str",
            "            )",
            "            return ret",
            "",
            "    if partial:",
            "        log.debug(",
            "            'file.extract_hash: Returning the partially identified %s hash '",
            "            '\\'%s\\'', partial['hash_type'], partial['hsum']",
            "        )",
            "        return partial",
            "",
            "    log.debug('file.extract_hash: No matches, returning None')",
            "    return None",
            "",
            "",
            "def check_perms(name, ret, user, group, mode, follow_symlinks=False):",
            "    '''",
            "    Check the permissions on files and chown if needed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_perms /etc/sudoers '{}' root root 400",
            "",
            "    .. versionchanged:: 2014.1.3",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if not ret:",
            "        ret = {'name': name,",
            "               'changes': {},",
            "               'comment': [],",
            "               'result': True}",
            "        orig_comment = ''",
            "    else:",
            "        orig_comment = ret['comment']",
            "        ret['comment'] = []",
            "",
            "    # Check permissions",
            "    perms = {}",
            "    cur = stats(name, follow_symlinks=follow_symlinks)",
            "    if not cur:",
            "        # NOTE: The file.directory state checks the content of the error",
            "        # message in this exception. Any changes made to the message for this",
            "        # exception will reflect the file.directory state as well, and will",
            "        # likely require changes there.",
            "        raise CommandExecutionError('{0} does not exist'.format(name))",
            "    perms['luser'] = cur['user']",
            "    perms['lgroup'] = cur['group']",
            "    perms['lmode'] = salt.utils.normalize_mode(cur['mode'])",
            "",
            "    # Mode changes if needed",
            "    if mode is not None:",
            "        # File is a symlink, ignore the mode setting",
            "        # if follow_symlinks is False",
            "        if os.path.islink(name) and not follow_symlinks:",
            "            pass",
            "        else:",
            "            mode = salt.utils.normalize_mode(mode)",
            "            if mode != perms['lmode']:",
            "                if __opts__['test'] is True:",
            "                    ret['changes']['mode'] = mode",
            "                else:",
            "                    set_mode(name, mode)",
            "                    if mode != salt.utils.normalize_mode(get_mode(name)):",
            "                        ret['result'] = False",
            "                        ret['comment'].append(",
            "                            'Failed to change mode to {0}'.format(mode)",
            "                        )",
            "                    else:",
            "                        ret['changes']['mode'] = mode",
            "    # user/group changes if needed, then check if it worked",
            "    if user:",
            "        if isinstance(user, int):",
            "            user = uid_to_user(user)",
            "        if (salt.utils.is_windows() and",
            "                user_to_uid(user) != user_to_uid(perms['luser'])",
            "            ) or (",
            "            not salt.utils.is_windows() and user != perms['luser']",
            "        ):",
            "            perms['cuser'] = user",
            "",
            "    if group:",
            "        if isinstance(group, int):",
            "            group = gid_to_group(group)",
            "        if (salt.utils.is_windows() and",
            "                group_to_gid(group) != group_to_gid(perms['lgroup'])",
            "            ) or (",
            "                not salt.utils.is_windows() and group != perms['lgroup']",
            "        ):",
            "            perms['cgroup'] = group",
            "",
            "    if 'cuser' in perms or 'cgroup' in perms:",
            "        if not __opts__['test']:",
            "            if os.path.islink(name) and not follow_symlinks:",
            "                chown_func = lchown",
            "            else:",
            "                chown_func = chown",
            "            if user is None:",
            "                user = perms['luser']",
            "            if group is None:",
            "                group = perms['lgroup']",
            "            try:",
            "                chown_func(name, user, group)",
            "            except OSError:",
            "                ret['result'] = False",
            "",
            "    if user:",
            "        if isinstance(user, int):",
            "            user = uid_to_user(user)",
            "        if (salt.utils.is_windows() and",
            "                user_to_uid(user) != user_to_uid(",
            "                    get_user(name, follow_symlinks=follow_symlinks)) and",
            "                user != ''",
            "            ) or (",
            "            not salt.utils.is_windows() and",
            "                user != get_user(name, follow_symlinks=follow_symlinks) and",
            "                user != ''",
            "        ):",
            "            if __opts__['test'] is True:",
            "                ret['changes']['user'] = user",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'].append('Failed to change user to {0}'",
            "                                          .format(user))",
            "        elif 'cuser' in perms and user != '':",
            "            ret['changes']['user'] = user",
            "    if group:",
            "        if isinstance(group, int):",
            "            group = gid_to_group(group)",
            "        if (salt.utils.is_windows() and",
            "                group_to_gid(group) != group_to_gid(",
            "                    get_group(name, follow_symlinks=follow_symlinks)) and",
            "                user != '') or (",
            "            not salt.utils.is_windows() and",
            "                group != get_group(name, follow_symlinks=follow_symlinks) and",
            "                user != ''",
            "        ):",
            "            if __opts__['test'] is True:",
            "                ret['changes']['group'] = group",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'].append('Failed to change group to {0}'",
            "                                      .format(group))",
            "        elif 'cgroup' in perms and user != '':",
            "            ret['changes']['group'] = group",
            "",
            "    if isinstance(orig_comment, six.string_types):",
            "        if orig_comment:",
            "            ret['comment'].insert(0, orig_comment)",
            "        ret['comment'] = '; '.join(ret['comment'])",
            "    if __opts__['test'] is True and ret['changes']:",
            "        ret['result'] = None",
            "    return ret, perms",
            "",
            "",
            "def check_managed(",
            "        name,",
            "        source,",
            "        source_hash,",
            "        source_hash_name,",
            "        user,",
            "        group,",
            "        mode,",
            "        template,",
            "        context,",
            "        defaults,",
            "        saltenv,",
            "        contents=None,",
            "        skip_verify=False,",
            "        **kwargs):",
            "    '''",
            "    Check to see what changes need to be made for a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_managed /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root, root, '755' jinja True None None base",
            "    '''",
            "    # If the source is a list then find which file exists",
            "    source, source_hash = source_list(source,           # pylint: disable=W0633",
            "                                      source_hash,",
            "                                      saltenv)",
            "",
            "    sfn = ''",
            "    source_sum = None",
            "",
            "    if contents is None:",
            "        # Gather the source file from the server",
            "        sfn, source_sum, comments = get_managed(",
            "            name,",
            "            template,",
            "            source,",
            "            source_hash,",
            "            source_hash_name,",
            "            user,",
            "            group,",
            "            mode,",
            "            saltenv,",
            "            context,",
            "            defaults,",
            "            skip_verify,",
            "            **kwargs)",
            "        if comments:",
            "            __clean_tmp(sfn)",
            "            return False, comments",
            "    changes = check_file_meta(name, sfn, source, source_sum, user,",
            "                              group, mode, saltenv, contents)",
            "    # Ignore permission for files written temporary directories",
            "    # Files in any path will still be set correctly using get_managed()",
            "    if name.startswith(tempfile.gettempdir()):",
            "        for key in ['user', 'group', 'mode']:",
            "            changes.pop(key, None)",
            "    __clean_tmp(sfn)",
            "    if changes:",
            "        log.info(changes)",
            "        comments = ['The following values are set to be changed:\\n']",
            "        comments.extend('{0}: {1}\\n'.format(key, val)",
            "                        for key, val in six.iteritems(changes))",
            "        return None, ''.join(comments)",
            "    return True, 'The file {0} is in the correct state'.format(name)",
            "",
            "",
            "def check_managed_changes(",
            "        name,",
            "        source,",
            "        source_hash,",
            "        source_hash_name,",
            "        user,",
            "        group,",
            "        mode,",
            "        template,",
            "        context,",
            "        defaults,",
            "        saltenv,",
            "        contents=None,",
            "        skip_verify=False,",
            "        keep_mode=False,",
            "        **kwargs):",
            "    '''",
            "    Return a dictionary of what changes need to be made for a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_managed_changes /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root, root, '755' jinja True None None base",
            "    '''",
            "    # If the source is a list then find which file exists",
            "    source, source_hash = source_list(source,           # pylint: disable=W0633",
            "                                      source_hash,",
            "                                      saltenv)",
            "",
            "    sfn = ''",
            "    source_sum = None",
            "",
            "    if contents is None:",
            "        # Gather the source file from the server",
            "        sfn, source_sum, comments = get_managed(",
            "            name,",
            "            template,",
            "            source,",
            "            source_hash,",
            "            source_hash_name,",
            "            user,",
            "            group,",
            "            mode,",
            "            saltenv,",
            "            context,",
            "            defaults,",
            "            skip_verify,",
            "            **kwargs)",
            "        if comments:",
            "            __clean_tmp(sfn)",
            "            return False, comments",
            "        if sfn and source and keep_mode:",
            "            if _urlparse(source).scheme in ('salt', 'file') \\",
            "                    or source.startswith('/'):",
            "                try:",
            "                    mode = salt.utils.st_mode_to_octal(os.stat(sfn).st_mode)",
            "                except Exception as exc:",
            "                    log.warning('Unable to stat %s: %s', sfn, exc)",
            "    changes = check_file_meta(name, sfn, source, source_sum, user,",
            "                              group, mode, saltenv, contents)",
            "    __clean_tmp(sfn)",
            "    return changes",
            "",
            "",
            "def check_file_meta(",
            "        name,",
            "        sfn,",
            "        source,",
            "        source_sum,",
            "        user,",
            "        group,",
            "        mode,",
            "        saltenv,",
            "        contents=None):",
            "    '''",
            "    Check for the changes in the file metadata.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_file_meta /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root, root, '755' base",
            "",
            "    .. note::",
            "",
            "        Supported hash types include sha512, sha384, sha256, sha224, sha1, and",
            "        md5.",
            "",
            "    name",
            "        Path to file destination",
            "",
            "    sfn",
            "        Template-processed source file contents",
            "",
            "    source",
            "        URL to file source",
            "",
            "    source_sum",
            "        File checksum information as a dictionary",
            "",
            "        .. code-block:: yaml",
            "",
            "            {hash_type: md5, hsum: <md5sum>}",
            "",
            "    user",
            "        Destination file user owner",
            "",
            "    group",
            "        Destination file group owner",
            "",
            "    mode",
            "        Destination file permissions mode",
            "",
            "    saltenv",
            "        Salt environment used to resolve source files",
            "",
            "    contents",
            "        File contents",
            "    '''",
            "    changes = {}",
            "    if not source_sum:",
            "        source_sum = dict()",
            "    lstats = stats(name, hash_type=source_sum.get('hash_type', None), follow_symlinks=False)",
            "    if not lstats:",
            "        changes['newfile'] = name",
            "        return changes",
            "    if 'hsum' in source_sum:",
            "        if source_sum['hsum'] != lstats['sum']:",
            "            if not sfn and source:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if sfn:",
            "                if __salt__['config.option']('obfuscate_templates'):",
            "                    changes['diff'] = '<Obfuscated Template>'",
            "                else:",
            "                    # Check to see if the files are bins",
            "                    bdiff = _binary_replace(name, sfn)",
            "                    if bdiff:",
            "                        changes['diff'] = bdiff",
            "                    else:",
            "                        with salt.utils.fopen(sfn, 'r') as src:",
            "                            slines = src.readlines()",
            "                        with salt.utils.fopen(name, 'r') as name_:",
            "                            nlines = name_.readlines()",
            "                        changes['diff'] = \\",
            "                            ''.join(difflib.unified_diff(nlines, slines))",
            "            else:",
            "                changes['sum'] = 'Checksum differs'",
            "",
            "    if contents is not None:",
            "        # Write a tempfile with the static contents",
            "        tmp = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX,",
            "                                 text=True)",
            "        if salt.utils.is_windows():",
            "            contents = os.linesep.join(",
            "                _splitlines_preserving_trailing_newline(contents))",
            "        with salt.utils.fopen(tmp, 'w') as tmp_:",
            "            tmp_.write(str(contents))",
            "        # Compare the static contents with the named file",
            "        with salt.utils.fopen(tmp, 'r') as src:",
            "            slines = src.readlines()",
            "        with salt.utils.fopen(name, 'r') as name_:",
            "            nlines = name_.readlines()",
            "        __clean_tmp(tmp)",
            "        if ''.join(nlines) != ''.join(slines):",
            "            if __salt__['config.option']('obfuscate_templates'):",
            "                changes['diff'] = '<Obfuscated Template>'",
            "            else:",
            "                if salt.utils.istextfile(name):",
            "                    changes['diff'] = \\",
            "                        ''.join(difflib.unified_diff(nlines, slines))",
            "                else:",
            "                    changes['diff'] = 'Replace binary file with text file'",
            "",
            "    if (user is not None",
            "            and user != lstats['user']",
            "            and user != lstats['uid']):",
            "        changes['user'] = user",
            "    if (group is not None",
            "            and group != lstats['group']",
            "            and group != lstats['gid']):",
            "        changes['group'] = group",
            "    # Normalize the file mode",
            "    smode = salt.utils.normalize_mode(lstats['mode'])",
            "    mode = salt.utils.normalize_mode(mode)",
            "    if mode is not None and mode != smode:",
            "        changes['mode'] = mode",
            "    return changes",
            "",
            "",
            "def get_diff(",
            "        minionfile,",
            "        masterfile,",
            "        saltenv='base'):",
            "    '''",
            "    Return unified diff of file compared to file on master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_diff /home/fred/.vimrc salt://users/fred/.vimrc",
            "    '''",
            "    minionfile = os.path.expanduser(minionfile)",
            "",
            "    ret = ''",
            "",
            "    if not os.path.exists(minionfile):",
            "        ret = 'File {0} does not exist on the minion'.format(minionfile)",
            "        return ret",
            "",
            "    sfn = __salt__['cp.cache_file'](masterfile, saltenv)",
            "    if sfn:",
            "        with salt.utils.fopen(sfn, 'r') as src:",
            "            slines = src.readlines()",
            "        with salt.utils.fopen(minionfile, 'r') as name_:",
            "            nlines = name_.readlines()",
            "        if ''.join(nlines) != ''.join(slines):",
            "            bdiff = _binary_replace(minionfile, sfn)",
            "            if bdiff:",
            "                ret += bdiff",
            "            else:",
            "                ret += ''.join(difflib.unified_diff(nlines, slines,",
            "                                                    minionfile, masterfile))",
            "    else:",
            "        ret = 'Failed to copy file from master'",
            "",
            "    return ret",
            "",
            "",
            "def manage_file(name,",
            "                sfn,",
            "                ret,",
            "                source,",
            "                source_sum,",
            "                user,",
            "                group,",
            "                mode,",
            "                saltenv,",
            "                backup,",
            "                makedirs=False,",
            "                template=None,   # pylint: disable=W0613",
            "                show_changes=True,",
            "                contents=None,",
            "                dir_mode=None,",
            "                follow_symlinks=True,",
            "                skip_verify=False,",
            "                keep_mode=False,",
            "                **kwargs):",
            "    '''",
            "    Checks the destination against what was retrieved with get_managed and",
            "    makes the appropriate modifications (if necessary).",
            "",
            "    name",
            "        location to place the file",
            "",
            "    sfn",
            "        location of cached file on the minion",
            "",
            "        This is the path to the file stored on the minion. This file is placed",
            "        on the minion using cp.cache_file.  If the hash sum of that file",
            "        matches the source_sum, we do not transfer the file to the minion",
            "        again.",
            "",
            "        This file is then grabbed and if it has template set, it renders the",
            "        file to be placed into the correct place on the system using",
            "        salt.files.utils.copyfile()",
            "",
            "    ret",
            "        The initial state return data structure. Pass in ``None`` to use the",
            "        default structure.",
            "",
            "    source",
            "        file reference on the master",
            "",
            "    source_hash",
            "        sum hash for source",
            "",
            "    user",
            "        user owner",
            "",
            "    group",
            "        group owner",
            "",
            "    backup",
            "        backup_mode",
            "",
            "    makedirs",
            "        make directories if they do not exist",
            "",
            "    template",
            "        format of templating",
            "",
            "    show_changes",
            "        Include diff in state return",
            "",
            "    contents:",
            "        contents to be placed in the file",
            "",
            "    dir_mode",
            "        mode for directories created with makedirs",
            "",
            "    skip_verify : False",
            "        If ``True``, hash verification of remote file sources (``http://``,",
            "        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``",
            "        argument will be ignored.",
            "",
            "        .. versionadded:: 2016.3.0",
            "",
            "    keep_mode : False",
            "        If ``True``, and the ``source`` is a file from the Salt fileserver (or",
            "        a local file on the minion), the mode of the destination file will be",
            "        set to the mode of the source file.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.manage_file /etc/httpd/conf.d/httpd.conf '' '{}' salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root root '755' base ''",
            "",
            "    .. versionchanged:: 2014.7.0",
            "        ``follow_symlinks`` option added",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if not ret:",
            "        ret = {'name': name,",
            "               'changes': {},",
            "               'comment': '',",
            "               'result': True}",
            "",
            "    if source and not sfn:",
            "        # File is not present, cache it",
            "        sfn = __salt__['cp.cache_file'](source, saltenv)",
            "        if not sfn:",
            "            return _error(",
            "                ret, 'Source file \\'{0}\\' not found'.format(source))",
            "        htype = source_sum.get('hash_type', __opts__['hash_type'])",
            "        # Recalculate source sum now that file has been cached",
            "        source_sum = {",
            "            'hash_type': htype,",
            "            'hsum': get_hash(sfn, form=htype)",
            "        }",
            "        if keep_mode:",
            "            if _urlparse(source).scheme in ('salt', 'file') \\",
            "                    or source.startswith('/'):",
            "                try:",
            "                    mode = salt.utils.st_mode_to_octal(os.stat(sfn).st_mode)",
            "                except Exception as exc:",
            "                    log.warning('Unable to stat %s: %s', sfn, exc)",
            "",
            "    # Check changes if the target file exists",
            "    if os.path.isfile(name) or os.path.islink(name):",
            "        if os.path.islink(name) and follow_symlinks:",
            "            real_name = os.path.realpath(name)",
            "        else:",
            "            real_name = name",
            "",
            "        # Only test the checksums on files with managed contents",
            "        if source and not (not follow_symlinks and os.path.islink(real_name)):",
            "            name_sum = get_hash(real_name, source_sum.get('hash_type', __opts__['hash_type']))",
            "        else:",
            "            name_sum = None",
            "",
            "        # Check if file needs to be replaced",
            "        if source and (name_sum is None or source_sum.get('hsum', __opts__['hash_type']) != name_sum):",
            "            if not sfn:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if not sfn:",
            "                return _error(",
            "                    ret, 'Source file \\'{0}\\' not found'.format(source))",
            "            # If the downloaded file came from a non salt server or local",
            "            # source, and we are not skipping checksum verification, then",
            "            # verify that it matches the specified checksum.",
            "            if not skip_verify \\",
            "                    and _urlparse(source).scheme not in ('salt', ''):",
            "                dl_sum = get_hash(sfn, source_sum['hash_type'])",
            "                if dl_sum != source_sum['hsum']:",
            "                    ret['comment'] = (",
            "                        'Specified {0} checksum for {1} ({2}) does not match '",
            "                        'actual checksum ({3}). If the \\'source_hash\\' value '",
            "                        'refers to a remote file with multiple possible '",
            "                        'matches, then it may be necessary to set '",
            "                        '\\'source_hash_name\\'.'.format(",
            "                            source_sum['hash_type'],",
            "                            source,",
            "                            source_sum['hsum'],",
            "                            dl_sum",
            "                        )",
            "                    )",
            "                    ret['result'] = False",
            "                    return ret",
            "",
            "            # Print a diff equivalent to diff -u old new",
            "            if __salt__['config.option']('obfuscate_templates'):",
            "                ret['changes']['diff'] = '<Obfuscated Template>'",
            "            elif not show_changes:",
            "                ret['changes']['diff'] = '<show_changes=False>'",
            "            else:",
            "                # Check to see if the files are bins",
            "                bdiff = _binary_replace(real_name, sfn)",
            "                if bdiff:",
            "                    ret['changes']['diff'] = bdiff",
            "                else:",
            "                    with salt.utils.fopen(sfn, 'r') as src:",
            "                        slines = src.readlines()",
            "                    with salt.utils.fopen(real_name, 'r') as name_:",
            "                        nlines = name_.readlines()",
            "",
            "                    sndiff = ''.join(difflib.unified_diff(nlines, slines))",
            "                    if sndiff:",
            "                        ret['changes']['diff'] = sndiff",
            "",
            "            # Pre requisites are met, and the file needs to be replaced, do it",
            "            try:",
            "                salt.utils.files.copyfile(sfn,",
            "                                    real_name,",
            "                                    __salt__['config.backup_mode'](backup),",
            "                                    __opts__['cachedir'])",
            "            except IOError as io_error:",
            "                __clean_tmp(sfn)",
            "                return _error(",
            "                    ret, 'Failed to commit change: {0}'.format(io_error))",
            "",
            "        if contents is not None:",
            "            # Write the static contents to a temporary file",
            "            tmp = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX,",
            "                                     text=True)",
            "            if salt.utils.is_windows():",
            "                contents = os.linesep.join(",
            "                    _splitlines_preserving_trailing_newline(contents))",
            "            with salt.utils.fopen(tmp, 'w') as tmp_:",
            "                tmp_.write(str(contents))",
            "",
            "            # Compare contents of files to know if we need to replace",
            "            with salt.utils.fopen(tmp, 'r') as src:",
            "                slines = src.readlines()",
            "            with salt.utils.fopen(real_name, 'r') as name_:",
            "                nlines = name_.readlines()",
            "                different = ''.join(slines) != ''.join(nlines)",
            "",
            "            if different:",
            "                if __salt__['config.option']('obfuscate_templates'):",
            "                    ret['changes']['diff'] = '<Obfuscated Template>'",
            "                elif not show_changes:",
            "                    ret['changes']['diff'] = '<show_changes=False>'",
            "                else:",
            "                    if salt.utils.istextfile(real_name):",
            "                        ret['changes']['diff'] = \\",
            "                            ''.join(difflib.unified_diff(nlines, slines))",
            "                    else:",
            "                        ret['changes']['diff'] = \\",
            "                            'Replace binary file with text file'",
            "",
            "                # Pre requisites are met, the file needs to be replaced, do it",
            "                try:",
            "                    salt.utils.files.copyfile(tmp,",
            "                                        real_name,",
            "                                        __salt__['config.backup_mode'](backup),",
            "                                        __opts__['cachedir'])",
            "                except IOError as io_error:",
            "                    __clean_tmp(tmp)",
            "                    return _error(",
            "                        ret, 'Failed to commit change: {0}'.format(io_error))",
            "            __clean_tmp(tmp)",
            "",
            "        # Check for changing symlink to regular file here",
            "        if os.path.islink(name) and not follow_symlinks:",
            "            if not sfn:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if not sfn:",
            "                return _error(",
            "                    ret, 'Source file \\'{0}\\' not found'.format(source))",
            "            # If the downloaded file came from a non salt server source verify",
            "            # that it matches the intended sum value",
            "            if not skip_verify and _urlparse(source).scheme != 'salt':",
            "                dl_sum = get_hash(sfn, source_sum['hash_type'])",
            "                if dl_sum != source_sum['hsum']:",
            "                    ret['comment'] = (",
            "                        'Specified {0} checksum for {1} ({2}) does not match '",
            "                        'actual checksum ({3})'.format(",
            "                            source_sum['hash_type'],",
            "                            name,",
            "                            source_sum['hsum'],",
            "                            dl_sum",
            "                        )",
            "                    )",
            "                    ret['result'] = False",
            "                    return ret",
            "",
            "            try:",
            "                salt.utils.files.copyfile(sfn,",
            "                                    name,",
            "                                    __salt__['config.backup_mode'](backup),",
            "                                    __opts__['cachedir'])",
            "            except IOError as io_error:",
            "                __clean_tmp(sfn)",
            "                return _error(",
            "                    ret, 'Failed to commit change: {0}'.format(io_error))",
            "",
            "            ret['changes']['diff'] = \\",
            "                'Replace symbolic link with regular file'",
            "",
            "        ret, _ = check_perms(name, ret, user, group, mode, follow_symlinks)",
            "",
            "        if ret['changes']:",
            "            ret['comment'] = 'File {0} updated'.format(name)",
            "",
            "        elif not ret['changes'] and ret['result']:",
            "            ret['comment'] = u'File {0} is in the correct state'.format(",
            "                salt.utils.locales.sdecode(name)",
            "            )",
            "        if sfn:",
            "            __clean_tmp(sfn)",
            "        return ret",
            "    else:  # target file does not exist",
            "        contain_dir = os.path.dirname(name)",
            "",
            "        def _set_mode_and_make_dirs(name, dir_mode, mode, user, group):",
            "            # check for existence of windows drive letter",
            "            if salt.utils.is_windows():",
            "                drive, _ = os.path.splitdrive(name)",
            "                if drive and not os.path.exists(drive):",
            "                    __clean_tmp(sfn)",
            "                    return _error(ret,",
            "                                  '{0} drive not present'.format(drive))",
            "            if dir_mode is None and mode is not None:",
            "                # Add execute bit to each nonzero digit in the mode, if",
            "                # dir_mode was not specified. Otherwise, any",
            "                # directories created with makedirs_() below can't be",
            "                # listed via a shell.",
            "                mode_list = [x for x in str(mode)][-3:]",
            "                for idx in range(len(mode_list)):",
            "                    if mode_list[idx] != '0':",
            "                        mode_list[idx] = str(int(mode_list[idx]) | 1)",
            "                dir_mode = ''.join(mode_list)",
            "            makedirs_(name, user=user,",
            "                      group=group, mode=dir_mode)",
            "",
            "        if source:",
            "            # It is a new file, set the diff accordingly",
            "            ret['changes']['diff'] = 'New file'",
            "            # Apply the new file",
            "            if not sfn:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if not sfn:",
            "                return _error(",
            "                    ret, 'Source file \\'{0}\\' not found'.format(source))",
            "            # If the downloaded file came from a non salt server source verify",
            "            # that it matches the intended sum value",
            "            if not skip_verify \\",
            "                    and _urlparse(source).scheme != 'salt':",
            "                dl_sum = get_hash(sfn, source_sum['hash_type'])",
            "                if dl_sum != source_sum['hsum']:",
            "                    ret['comment'] = (",
            "                        'Specified {0} checksum for {1} ({2}) does not match '",
            "                        'actual checksum ({3})'.format(",
            "                            source_sum['hash_type'],",
            "                            name,",
            "                            source_sum['hsum'],",
            "                            dl_sum",
            "                        )",
            "                    )",
            "                    ret['result'] = False",
            "                    return ret",
            "            if not os.path.isdir(contain_dir):",
            "                if makedirs:",
            "                    _set_mode_and_make_dirs(name, dir_mode, mode, user, group)",
            "                else:",
            "                    __clean_tmp(sfn)",
            "                    # No changes actually made",
            "                    ret['changes'].pop('diff', None)",
            "                    return _error(ret, 'Parent directory not present')",
            "        else:  # source != True",
            "            if not os.path.isdir(contain_dir):",
            "                if makedirs:",
            "                    _set_mode_and_make_dirs(name, dir_mode, mode, user, group)",
            "                else:",
            "                    __clean_tmp(sfn)",
            "                    # No changes actually made",
            "                    ret['changes'].pop('diff', None)",
            "                    return _error(ret, 'Parent directory not present')",
            "",
            "            # Create the file, user rw-only if mode will be set to prevent",
            "            # a small security race problem before the permissions are set",
            "            if mode:",
            "                current_umask = os.umask(0o77)",
            "",
            "            # Create a new file when test is False and source is None",
            "            if contents is None:",
            "                if not __opts__['test']:",
            "                    if touch(name):",
            "                        ret['changes']['new'] = 'file {0} created'.format(name)",
            "                        ret['comment'] = 'Empty file'",
            "                    else:",
            "                        return _error(",
            "                            ret, 'Empty file {0} not created'.format(name)",
            "                        )",
            "            else:",
            "                if not __opts__['test']:",
            "                    if touch(name):",
            "                        ret['changes']['diff'] = 'New file'",
            "                    else:",
            "                        return _error(",
            "                            ret, 'File {0} not created'.format(name)",
            "                        )",
            "",
            "            if mode:",
            "                os.umask(current_umask)",
            "",
            "        if contents is not None:",
            "            # Write the static contents to a temporary file",
            "            tmp = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX,",
            "                                     text=True)",
            "            if salt.utils.is_windows():",
            "                contents = os.linesep.join(",
            "                    _splitlines_preserving_trailing_newline(contents))",
            "            with salt.utils.fopen(tmp, 'w') as tmp_:",
            "                tmp_.write(str(contents))",
            "            # Copy into place",
            "            salt.utils.files.copyfile(tmp,",
            "                                name,",
            "                                __salt__['config.backup_mode'](backup),",
            "                                __opts__['cachedir'])",
            "            __clean_tmp(tmp)",
            "        # Now copy the file contents if there is a source file",
            "        elif sfn:",
            "            salt.utils.files.copyfile(sfn,",
            "                                name,",
            "                                __salt__['config.backup_mode'](backup),",
            "                                __opts__['cachedir'])",
            "            __clean_tmp(sfn)",
            "",
            "        # This is a new file, if no mode specified, use the umask to figure",
            "        # out what mode to use for the new file.",
            "        if mode is None and not salt.utils.is_windows():",
            "            # Get current umask",
            "            mask = os.umask(0)",
            "            os.umask(mask)",
            "            # Calculate the mode value that results from the umask",
            "            mode = oct((0o777 ^ mask) & 0o666)",
            "        ret, _ = check_perms(name, ret, user, group, mode)",
            "",
            "        if not ret['comment']:",
            "            ret['comment'] = 'File ' + name + ' updated'",
            "",
            "        if __opts__['test']:",
            "            ret['comment'] = 'File ' + name + ' not updated'",
            "        elif not ret['changes'] and ret['result']:",
            "            ret['comment'] = 'File ' + name + ' is in the correct state'",
            "        if sfn:",
            "            __clean_tmp(sfn)",
            "        return ret",
            "",
            "",
            "def mkdir(dir_path,",
            "          user=None,",
            "          group=None,",
            "          mode=None):",
            "    '''",
            "    Ensure that a directory is available.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.mkdir /opt/jetty/context",
            "    '''",
            "    dir_path = os.path.expanduser(dir_path)",
            "",
            "    directory = os.path.normpath(dir_path)",
            "",
            "    if not os.path.isdir(directory):",
            "        # If a caller such as managed() is invoked  with makedirs=True, make",
            "        # sure that any created dirs are created with the same user and group",
            "        # to follow the principal of least surprise method.",
            "        makedirs_perms(directory, user, group, mode)",
            "",
            "    return True",
            "",
            "",
            "def makedirs_(path,",
            "              user=None,",
            "              group=None,",
            "              mode=None):",
            "    '''",
            "    Ensure that the directory containing this path is available.",
            "",
            "    .. note::",
            "",
            "        The path must end with a trailing slash otherwise the directory/directories",
            "        will be created up to the parent directory. For example if path is",
            "        ``/opt/code``, then it would be treated as ``/opt/`` but if the path",
            "        ends with a trailing slash like ``/opt/code/``, then it would be",
            "        treated as ``/opt/code/``.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.makedirs /opt/code/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    # walk up the directory structure until we find the first existing",
            "    # directory",
            "    dirname = os.path.normpath(os.path.dirname(path))",
            "",
            "    if os.path.isdir(dirname):",
            "        # There's nothing for us to do",
            "        msg = 'Directory \\'{0}\\' already exists'.format(dirname)",
            "        log.debug(msg)",
            "        return msg",
            "",
            "    if os.path.exists(dirname):",
            "        msg = 'The path \\'{0}\\' already exists and is not a directory'.format(",
            "            dirname",
            "        )",
            "        log.debug(msg)",
            "        return msg",
            "",
            "    directories_to_create = []",
            "    while True:",
            "        if os.path.isdir(dirname):",
            "            break",
            "",
            "        directories_to_create.append(dirname)",
            "        current_dirname = dirname",
            "        dirname = os.path.dirname(dirname)",
            "",
            "        if current_dirname == dirname:",
            "            raise SaltInvocationError(",
            "                'Recursive creation for path \\'{0}\\' would result in an '",
            "                'infinite loop. Please use an absolute path.'.format(dirname)",
            "            )",
            "",
            "    # create parent directories from the topmost to the most deeply nested one",
            "    directories_to_create.reverse()",
            "    for directory_to_create in directories_to_create:",
            "        # all directories have the user, group and mode set!!",
            "        log.debug('Creating directory: %s', directory_to_create)",
            "        mkdir(directory_to_create, user=user, group=group, mode=mode)",
            "",
            "",
            "def makedirs_perms(name,",
            "                   user=None,",
            "                   group=None,",
            "                   mode='0755'):",
            "    '''",
            "    Taken and modified from os.makedirs to set user, group and mode for each",
            "    directory created.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.makedirs_perms /opt/code",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    path = os.path",
            "    head, tail = path.split(name)",
            "    if not tail:",
            "        head, tail = path.split(head)",
            "    if head and tail and not path.exists(head):",
            "        try:",
            "            makedirs_perms(head, user, group, mode)",
            "        except OSError as exc:",
            "            # be happy if someone already created the path",
            "            if exc.errno != errno.EEXIST:",
            "                raise",
            "        if tail == os.curdir:  # xxx/newdir/. exists if xxx/newdir exists",
            "            return",
            "    os.mkdir(name)",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "",
            "",
            "def get_devmm(name):",
            "    '''",
            "    Get major/minor info from a device",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.get_devmm /dev/chr",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if is_chrdev(name) or is_blkdev(name):",
            "        stat_structure = os.stat(name)",
            "        return (",
            "                os.major(stat_structure.st_rdev),",
            "                os.minor(stat_structure.st_rdev))",
            "    else:",
            "        return (0, 0)",
            "",
            "",
            "def is_chrdev(name):",
            "    '''",
            "    Check if a file exists and is a character device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_chrdev /dev/chr",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    stat_structure = None",
            "    try:",
            "        stat_structure = os.stat(name)",
            "    except OSError as exc:",
            "        if exc.errno == errno.ENOENT:",
            "            # If the character device does not exist in the first place",
            "            return False",
            "        else:",
            "            raise",
            "    return stat.S_ISCHR(stat_structure.st_mode)",
            "",
            "",
            "def mknod_chrdev(name,",
            "                 major,",
            "                 minor,",
            "                 user=None,",
            "                 group=None,",
            "                 mode='0660'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a character device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.mknod_chrdev /dev/chr 180 31",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    log.debug('Creating character device name:{0} major:{1} minor:{2} mode:{3}'",
            "              .format(name, major, minor, mode))",
            "    try:",
            "        if __opts__['test']:",
            "            ret['changes'] = {'new': 'Character device {0} created.'.format(name)}",
            "            ret['result'] = None",
            "        else:",
            "            if os.mknod(name,",
            "                        int(str(mode).lstrip('0Oo'), 8) | stat.S_IFCHR,",
            "                        os.makedev(major, minor)) is None:",
            "                ret['changes'] = {'new': 'Character device {0} created.'.format(name)}",
            "                ret['result'] = True",
            "    except OSError as exc:",
            "        # be happy it is already there....however, if you are trying to change the",
            "        # major/minor, you will need to unlink it first as os.mknod will not overwrite",
            "        if exc.errno != errno.EEXIST:",
            "            raise",
            "        else:",
            "            ret['comment'] = 'File {0} exists and cannot be overwritten'.format(name)",
            "    # quick pass at verifying the permissions of the newly created character device",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "    return ret",
            "",
            "",
            "def is_blkdev(name):",
            "    '''",
            "    Check if a file exists and is a block device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_blkdev /dev/blk",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    stat_structure = None",
            "    try:",
            "        stat_structure = os.stat(name)",
            "    except OSError as exc:",
            "        if exc.errno == errno.ENOENT:",
            "            # If the block device does not exist in the first place",
            "            return False",
            "        else:",
            "            raise",
            "    return stat.S_ISBLK(stat_structure.st_mode)",
            "",
            "",
            "def mknod_blkdev(name,",
            "                 major,",
            "                 minor,",
            "                 user=None,",
            "                 group=None,",
            "                 mode='0660'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a block device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.mknod_blkdev /dev/blk 8 999",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    log.debug('Creating block device name:{0} major:{1} minor:{2} mode:{3}'",
            "              .format(name, major, minor, mode))",
            "    try:",
            "        if __opts__['test']:",
            "            ret['changes'] = {'new': 'Block device {0} created.'.format(name)}",
            "            ret['result'] = None",
            "        else:",
            "            if os.mknod(name,",
            "                        int(str(mode).lstrip('0Oo'), 8) | stat.S_IFBLK,",
            "                        os.makedev(major, minor)) is None:",
            "                ret['changes'] = {'new': 'Block device {0} created.'.format(name)}",
            "                ret['result'] = True",
            "    except OSError as exc:",
            "        # be happy it is already there....however, if you are trying to change the",
            "        # major/minor, you will need to unlink it first as os.mknod will not overwrite",
            "        if exc.errno != errno.EEXIST:",
            "            raise",
            "        else:",
            "            ret['comment'] = 'File {0} exists and cannot be overwritten'.format(name)",
            "    # quick pass at verifying the permissions of the newly created block device",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "    return ret",
            "",
            "",
            "def is_fifo(name):",
            "    '''",
            "    Check if a file exists and is a FIFO.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_fifo /dev/fifo",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    stat_structure = None",
            "    try:",
            "        stat_structure = os.stat(name)",
            "    except OSError as exc:",
            "        if exc.errno == errno.ENOENT:",
            "            # If the fifo does not exist in the first place",
            "            return False",
            "        else:",
            "            raise",
            "    return stat.S_ISFIFO(stat_structure.st_mode)",
            "",
            "",
            "def mknod_fifo(name,",
            "               user=None,",
            "               group=None,",
            "               mode='0660'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a FIFO pipe.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.mknod_fifo /dev/fifo",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    log.debug('Creating FIFO name: {0}'.format(name))",
            "    try:",
            "        if __opts__['test']:",
            "            ret['changes'] = {'new': 'Fifo pipe {0} created.'.format(name)}",
            "            ret['result'] = None",
            "        else:",
            "            if os.mkfifo(name, int(str(mode).lstrip('0Oo'), 8)) is None:",
            "                ret['changes'] = {'new': 'Fifo pipe {0} created.'.format(name)}",
            "                ret['result'] = True",
            "    except OSError as exc:",
            "        # be happy it is already there",
            "        if exc.errno != errno.EEXIST:",
            "            raise",
            "        else:",
            "            ret['comment'] = 'File {0} exists and cannot be overwritten'.format(name)",
            "    # quick pass at verifying the permissions of the newly created fifo",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "    return ret",
            "",
            "",
            "def mknod(name,",
            "          ntype,",
            "          major=0,",
            "          minor=0,",
            "          user=None,",
            "          group=None,",
            "          mode='0600'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a block device, character device, or fifo pipe.",
            "    Identical to the gnu mknod.",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.mknod /dev/chr c 180 31",
            "        salt '*' file.mknod /dev/blk b 8 999",
            "        salt '*' file.nknod /dev/fifo p",
            "    '''",
            "    ret = False",
            "    makedirs_(name, user, group)",
            "    if ntype == 'c':",
            "        ret = mknod_chrdev(name, major, minor, user, group, mode)",
            "    elif ntype == 'b':",
            "        ret = mknod_blkdev(name, major, minor, user, group, mode)",
            "    elif ntype == 'p':",
            "        ret = mknod_fifo(name, user, group, mode)",
            "    else:",
            "        raise SaltInvocationError(",
            "            'Node type unavailable: \\'{0}\\'. Available node types are '",
            "            'character (\\'c\\'), block (\\'b\\'), and pipe (\\'p\\').'.format(ntype)",
            "        )",
            "    return ret",
            "",
            "",
            "def list_backups(path, limit=None):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Lists the previous versions of a file backed up using Salt's :ref:`file",
            "    state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The path on the minion to check for backups",
            "    limit",
            "        Limit the number of results to the most recent N backups",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.list_backups /foo/bar/baz.txt",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    try:",
            "        limit = int(limit)",
            "    except TypeError:",
            "        pass",
            "    except ValueError:",
            "        log.error('file.list_backups: \\'limit\\' value must be numeric')",
            "        limit = None",
            "",
            "    bkroot = _get_bkroot()",
            "    parent_dir, basename = os.path.split(path)",
            "    if salt.utils.is_windows():",
            "        # ':' is an illegal filesystem path character on Windows",
            "        src_dir = parent_dir.replace(':', '_')",
            "    else:",
            "        src_dir = parent_dir[1:]",
            "    # Figure out full path of location of backup file in minion cache",
            "    bkdir = os.path.join(bkroot, src_dir)",
            "",
            "    if not os.path.isdir(bkdir):",
            "        return {}",
            "",
            "    files = {}",
            "    for fname in [x for x in os.listdir(bkdir)",
            "                  if os.path.isfile(os.path.join(bkdir, x))]:",
            "        if salt.utils.is_windows():",
            "            # ':' is an illegal filesystem path character on Windows",
            "            strpfmt = '{0}_%a_%b_%d_%H-%M-%S_%f_%Y'.format(basename)",
            "        else:",
            "            strpfmt = '{0}_%a_%b_%d_%H:%M:%S_%f_%Y'.format(basename)",
            "        try:",
            "            timestamp = datetime.datetime.strptime(fname, strpfmt)",
            "        except ValueError:",
            "            # File didn't match the strp format string, so it's not a backup",
            "            # for this file. Move on to the next one.",
            "            continue",
            "        if salt.utils.is_windows():",
            "            str_format = '%a %b %d %Y %H-%M-%S.%f'",
            "        else:",
            "            str_format = '%a %b %d %Y %H:%M:%S.%f'",
            "        files.setdefault(timestamp, {})['Backup Time'] = \\",
            "            timestamp.strftime(str_format)",
            "        location = os.path.join(bkdir, fname)",
            "        files[timestamp]['Size'] = os.stat(location).st_size",
            "        files[timestamp]['Location'] = location",
            "",
            "    return dict(list(zip(",
            "        list(range(len(files))),",
            "        [files[x] for x in sorted(files, reverse=True)[:limit]]",
            "    )))",
            "",
            "list_backup = salt.utils.alias_function(list_backups, 'list_backup')",
            "",
            "",
            "def list_backups_dir(path, limit=None):",
            "    '''",
            "    Lists the previous versions of a directory backed up using Salt's :ref:`file",
            "    state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The directory on the minion to check for backups",
            "    limit",
            "        Limit the number of results to the most recent N backups",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.list_backups_dir /foo/bar/baz/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    try:",
            "        limit = int(limit)",
            "    except TypeError:",
            "        pass",
            "    except ValueError:",
            "        log.error('file.list_backups_dir: \\'limit\\' value must be numeric')",
            "        limit = None",
            "",
            "    bkroot = _get_bkroot()",
            "    parent_dir, basename = os.path.split(path)",
            "    # Figure out full path of location of backup folder in minion cache",
            "    bkdir = os.path.join(bkroot, parent_dir[1:])",
            "",
            "    if not os.path.isdir(bkdir):",
            "        return {}",
            "",
            "    files = {}",
            "    f = dict([(i, len(list(n))) for i, n in itertools.groupby([x.split(\"_\")[0] for x in sorted(os.listdir(bkdir))])])",
            "    ff = os.listdir(bkdir)",
            "    for i, n in six.iteritems(f):",
            "        ssfile = {}",
            "        for x in sorted(ff):",
            "            basename = x.split('_')[0]",
            "            if i == basename:",
            "                strpfmt = '{0}_%a_%b_%d_%H:%M:%S_%f_%Y'.format(basename)",
            "                try:",
            "                    timestamp = datetime.datetime.strptime(x, strpfmt)",
            "                except ValueError:",
            "                    # Folder didn't match the strp format string, so it's not a backup",
            "                    # for this folder. Move on to the next one.",
            "                    continue",
            "                ssfile.setdefault(timestamp, {})['Backup Time'] = \\",
            "                    timestamp.strftime('%a %b %d %Y %H:%M:%S.%f')",
            "                location = os.path.join(bkdir, x)",
            "                ssfile[timestamp]['Size'] = os.stat(location).st_size",
            "                ssfile[timestamp]['Location'] = location",
            "",
            "        sfiles = dict(list(zip(list(range(n)), [ssfile[x] for x in sorted(ssfile, reverse=True)[:limit]])))",
            "        sefiles = {i: sfiles}",
            "        files.update(sefiles)",
            "    return files",
            "",
            "",
            "def restore_backup(path, backup_id):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Restore a previous version of a file that was backed up using Salt's",
            "    :ref:`file state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The path on the minion to check for backups",
            "    backup_id",
            "        The numeric id for the backup you wish to restore, as found using",
            "        :mod:`file.list_backups <salt.modules.file.list_backups>`",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.restore_backup /foo/bar/baz.txt 0",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    # Note: This only supports minion backups, so this function will need to be",
            "    # modified if/when master backups are implemented.",
            "    ret = {'result': False,",
            "           'comment': 'Invalid backup_id \\'{0}\\''.format(backup_id)}",
            "    try:",
            "        if len(str(backup_id)) == len(str(int(backup_id))):",
            "            backup = list_backups(path)[int(backup_id)]",
            "        else:",
            "            return ret",
            "    except ValueError:",
            "        return ret",
            "    except KeyError:",
            "        ret['comment'] = 'backup_id \\'{0}\\' does not exist for ' \\",
            "                         '{1}'.format(backup_id, path)",
            "        return ret",
            "",
            "    salt.utils.backup_minion(path, _get_bkroot())",
            "    try:",
            "        shutil.copyfile(backup['Location'], path)",
            "    except IOError as exc:",
            "        ret['comment'] = \\",
            "            'Unable to restore {0} to {1}: ' \\",
            "            '{2}'.format(backup['Location'], path, exc)",
            "        return ret",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'Successfully restored {0} to ' \\",
            "                         '{1}'.format(backup['Location'], path)",
            "",
            "    # Try to set proper ownership",
            "    if not salt.utils.is_windows():",
            "        try:",
            "            fstat = os.stat(path)",
            "        except (OSError, IOError):",
            "            ret['comment'] += ', but was unable to set ownership'",
            "        else:",
            "            os.chown(path, fstat.st_uid, fstat.st_gid)",
            "",
            "    return ret",
            "",
            "",
            "def delete_backup(path, backup_id):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Delete a previous version of a file that was backed up using Salt's",
            "    :ref:`file state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The path on the minion to check for backups",
            "    backup_id",
            "        The numeric id for the backup you wish to delete, as found using",
            "        :mod:`file.list_backups <salt.modules.file.list_backups>`",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.delete_backup /var/cache/salt/minion/file_backup/home/foo/bar/baz.txt 0",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    ret = {'result': False,",
            "           'comment': 'Invalid backup_id \\'{0}\\''.format(backup_id)}",
            "    try:",
            "        if len(str(backup_id)) == len(str(int(backup_id))):",
            "            backup = list_backups(path)[int(backup_id)]",
            "        else:",
            "            return ret",
            "    except ValueError:",
            "        return ret",
            "    except KeyError:",
            "        ret['comment'] = 'backup_id \\'{0}\\' does not exist for ' \\",
            "                         '{1}'.format(backup_id, path)",
            "        return ret",
            "",
            "    try:",
            "        os.remove(backup['Location'])",
            "    except IOError as exc:",
            "        ret['comment'] = 'Unable to remove {0}: {1}'.format(backup['Location'],",
            "                                                            exc)",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'Successfully removed {0}'.format(backup['Location'])",
            "",
            "    return ret",
            "",
            "remove_backup = salt.utils.alias_function(delete_backup, 'remove_backup')",
            "",
            "",
            "def grep(path,",
            "         pattern,",
            "         *opts):",
            "    '''",
            "    Grep for a string in the specified file",
            "",
            "    .. note::",
            "        This function's return value is slated for refinement in future",
            "        versions of Salt",
            "",
            "    path",
            "        Path to the file to be searched",
            "",
            "        .. note::",
            "            Globbing is supported (i.e. ``/var/log/foo/*.log``, but if globbing",
            "            is being used then the path should be quoted to keep the shell from",
            "            attempting to expand the glob expression.",
            "",
            "    pattern",
            "        Pattern to match. For example: ``test``, or ``a[0-5]``",
            "",
            "    opts",
            "        Additional command-line flags to pass to the grep command. For example:",
            "        ``-v``, or ``-i -B2``",
            "",
            "        .. note::",
            "            The options should come after a double-dash (as shown in the",
            "            examples below) to keep Salt's own argument parser from",
            "            interpreting them.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.grep /etc/passwd nobody",
            "        salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr -- -i",
            "        salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr -- -i -B2",
            "        salt '*' file.grep \"/etc/sysconfig/network-scripts/*\" ipaddr -- -i -l",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    split_opts = []",
            "    for opt in opts:",
            "        try:",
            "            split = salt.utils.shlex_split(opt)",
            "        except AttributeError:",
            "            split = salt.utils.shlex_split(str(opt))",
            "        if len(split) > 1:",
            "            raise SaltInvocationError(",
            "                'Passing multiple command line arguments in a single string '",
            "                'is not supported, please pass the following arguments '",
            "                'separately: {0}'.format(opt)",
            "            )",
            "        split_opts.extend(split)",
            "",
            "    cmd = ['grep'] + split_opts + [pattern, path]",
            "    try:",
            "        ret = __salt__['cmd.run_all'](cmd, python_shell=False)",
            "    except (IOError, OSError) as exc:",
            "        raise CommandExecutionError(exc.strerror)",
            "",
            "    return ret",
            "",
            "",
            "def open_files(by_pid=False):",
            "    '''",
            "    Return a list of all physical open files on the system.",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.open_files",
            "        salt '*' file.open_files by_pid=True",
            "    '''",
            "    # First we collect valid PIDs",
            "    pids = {}",
            "    procfs = os.listdir('/proc/')",
            "    for pfile in procfs:",
            "        try:",
            "            pids[int(pfile)] = []",
            "        except ValueError:",
            "            # Not a valid PID, move on",
            "            pass",
            "",
            "    # Then we look at the open files for each PID",
            "    files = {}",
            "    for pid in pids:",
            "        ppath = '/proc/{0}'.format(pid)",
            "        try:",
            "            tids = os.listdir('{0}/task'.format(ppath))",
            "        except OSError:",
            "            continue",
            "",
            "        # Collect the names of all of the file descriptors",
            "        fd_ = []",
            "",
            "        #try:",
            "        #    fd_.append(os.path.realpath('{0}/task/{1}exe'.format(ppath, tid)))",
            "        #except:",
            "        #    pass",
            "",
            "        for fpath in os.listdir('{0}/fd'.format(ppath)):",
            "            fd_.append('{0}/fd/{1}'.format(ppath, fpath))",
            "",
            "        for tid in tids:",
            "            try:",
            "                fd_.append(",
            "                    os.path.realpath('{0}/task/{1}/exe'.format(ppath, tid))",
            "                )",
            "            except OSError:",
            "                continue",
            "",
            "            for tpath in os.listdir('{0}/task/{1}/fd'.format(ppath, tid)):",
            "                fd_.append('{0}/task/{1}/fd/{2}'.format(ppath, tid, tpath))",
            "",
            "        fd_ = sorted(set(fd_))",
            "",
            "        # Loop through file descriptors and return useful data for each file",
            "        for fdpath in fd_:",
            "            # Sometimes PIDs and TIDs disappear before we can query them",
            "            try:",
            "                name = os.path.realpath(fdpath)",
            "                # Running stat on the file cuts out all of the sockets and",
            "                # deleted files from the list",
            "                os.stat(name)",
            "            except OSError:",
            "                continue",
            "",
            "            if name not in files:",
            "                files[name] = [pid]",
            "            else:",
            "                # We still want to know which PIDs are using each file",
            "                files[name].append(pid)",
            "                files[name] = sorted(set(files[name]))",
            "",
            "            pids[pid].append(name)",
            "            pids[pid] = sorted(set(pids[pid]))",
            "",
            "    if by_pid:",
            "        return pids",
            "    return files",
            "",
            "",
            "def pardir():",
            "    '''",
            "    Return the relative parent directory path symbol for underlying OS",
            "",
            "    .. versionadded:: 2014.7.0",
            "",
            "    This can be useful when constructing Salt Formulas.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {% set pardir = salt['file.pardir']() %}",
            "        {% set final_path = salt['file.join']('subdir', pardir, 'confdir') %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.pardir",
            "    '''",
            "    return os.path.pardir",
            "",
            "",
            "def normpath(path):",
            "    '''",
            "    Returns Normalize path, eliminating double slashes, etc.",
            "",
            "    .. versionadded:: 2015.5.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {%- from salt['file.normpath'](tpldir + '/../vars.jinja') import parent_vars %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.normpath 'a/b/c/..'",
            "    '''",
            "    return os.path.normpath(path)",
            "",
            "",
            "def basename(path):",
            "    '''",
            "    Returns the final component of a pathname",
            "",
            "    .. versionadded:: 2015.5.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {%- set filename = salt['file.basename'](source_file) %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.basename 'test/test.config'",
            "    '''",
            "    return os.path.basename(path)",
            "",
            "",
            "def dirname(path):",
            "    '''",
            "    Returns the directory component of a pathname",
            "",
            "    .. versionadded:: 2015.5.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {%- from salt['file.dirname'](tpldir) + '/vars.jinja' import parent_vars %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.dirname 'test/path/filename.config'",
            "    '''",
            "    return os.path.dirname(path)",
            "",
            "",
            "def join(*args):",
            "    '''",
            "    Return a normalized file system path for the underlying OS",
            "",
            "    .. versionadded:: 2014.7.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting",
            "    combining path variables:",
            "",
            "    .. code-block:: jinja",
            "",
            "        {% set www_root = '/var' %}",
            "        {% set app_dir = 'myapp' %}",
            "",
            "        myapp_config:",
            "          file:",
            "            - managed",
            "            - name: {{ salt['file.join'](www_root, app_dir, 'config.yaml') }}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.join '/' 'usr' 'local' 'bin'",
            "    '''",
            "    return os.path.join(*args)",
            "",
            "",
            "def move(src, dst):",
            "    '''",
            "    Move a file or directory",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.move /path/to/src /path/to/dst",
            "    '''",
            "    src = os.path.expanduser(src)",
            "    dst = os.path.expanduser(dst)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('Source path must be absolute.')",
            "",
            "    if not os.path.isabs(dst):",
            "        raise SaltInvocationError('Destination path must be absolute.')",
            "",
            "    ret = {",
            "        'result': True,",
            "        'comment': \"'{0}' moved to '{1}'\".format(src, dst),",
            "    }",
            "",
            "    try:",
            "        shutil.move(src, dst)",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to move '{0}' to '{1}': {2}\".format(src, dst, exc)",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def diskusage(path):",
            "    '''",
            "    Recursively calculate disk usage of path and return it",
            "    in bytes",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.diskusage /path/to/check",
            "    '''",
            "",
            "    total_size = 0",
            "    seen = set()",
            "    if os.path.isfile(path):",
            "        stat_structure = os.stat(path)",
            "        ret = stat_structure.st_size",
            "        return ret",
            "",
            "    for dirpath, dirnames, filenames in os.walk(path):",
            "        for f in filenames:",
            "            fp = os.path.join(dirpath, f)",
            "",
            "            try:",
            "                stat_structure = os.stat(fp)",
            "            except OSError:",
            "                continue",
            "",
            "            if stat_structure.st_ino in seen:",
            "                continue",
            "",
            "            seen.add(stat_structure.st_ino)",
            "",
            "            total_size += stat_structure.st_size",
            "",
            "    ret = total_size",
            "    return ret"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Manage information about regular files, directories,",
            "and special files on the minion, set/read user,",
            "group, mode, and data",
            "'''",
            "",
            "# TODO: We should add the capability to do u+r type operations here",
            "# some time in the future",
            "",
            "from __future__ import absolute_import, print_function",
            "",
            "# Import python libs",
            "import datetime",
            "import difflib",
            "import errno",
            "import fileinput",
            "import fnmatch",
            "import itertools",
            "import logging",
            "import operator",
            "import os",
            "import re",
            "import shutil",
            "import stat",
            "import string",
            "import sys",
            "import tempfile",
            "import time",
            "import glob",
            "import hashlib",
            "import mmap",
            "from functools import reduce  # pylint: disable=redefined-builtin",
            "from collections import Iterable, Mapping",
            "",
            "# pylint: disable=import-error,no-name-in-module,redefined-builtin",
            "import salt.ext.six as six",
            "from salt.ext.six.moves import range, zip",
            "from salt.ext.six.moves.urllib.parse import urlparse as _urlparse",
            "# pylint: enable=import-error,no-name-in-module,redefined-builtin",
            "",
            "try:",
            "    import grp",
            "    import pwd",
            "except ImportError:",
            "    pass",
            "",
            "# Import salt libs",
            "import salt.utils",
            "import salt.utils.atomicfile",
            "import salt.utils.find",
            "import salt.utils.filebuffer",
            "import salt.utils.files",
            "import salt.utils.locales",
            "import salt.utils.templates",
            "import salt.utils.url",
            "from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError, get_error_message as _get_error_message",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "__func_alias__ = {",
            "    'makedirs_': 'makedirs'",
            "}",
            "",
            "HASHES = {",
            "    'sha512': 128,",
            "    'sha384': 96,",
            "    'sha256': 64,",
            "    'sha224': 56,",
            "    'sha1': 40,",
            "    'md5': 32,",
            "}",
            "HASHES_REVMAP = dict([(y, x) for x, y in six.iteritems(HASHES)])",
            "",
            "",
            "def __virtual__():",
            "    '''",
            "    Only work on POSIX-like systems",
            "    '''",
            "    # win_file takes care of windows",
            "    if salt.utils.is_windows():",
            "        return (False, 'The file execution module cannot be loaded: only available on non-Windows systems - use win_file instead.')",
            "    return True",
            "",
            "",
            "def __clean_tmp(sfn):",
            "    '''",
            "    Clean out a template temp file",
            "    '''",
            "    if sfn.startswith(os.path.join(tempfile.gettempdir(),",
            "                                   salt.utils.files.TEMPFILE_PREFIX)):",
            "        # Don't remove if it exists in file_roots (any saltenv)",
            "        all_roots = itertools.chain.from_iterable(",
            "                six.itervalues(__opts__['file_roots']))",
            "        in_roots = any(sfn.startswith(root) for root in all_roots)",
            "        # Only clean up files that exist",
            "        if os.path.exists(sfn) and not in_roots:",
            "            os.remove(sfn)",
            "",
            "",
            "def _error(ret, err_msg):",
            "    '''",
            "    Common function for setting error information for return dicts",
            "    '''",
            "    ret['result'] = False",
            "    ret['comment'] = err_msg",
            "    return ret",
            "",
            "",
            "def _binary_replace(old, new):",
            "    '''",
            "    This function does NOT do any diffing, it just checks the old and new files",
            "    to see if either is binary, and provides an appropriate string noting the",
            "    difference between the two files. If neither file is binary, an empty",
            "    string is returned.",
            "",
            "    This function should only be run AFTER it has been determined that the",
            "    files differ.",
            "    '''",
            "    old_isbin = not salt.utils.istextfile(old)",
            "    new_isbin = not salt.utils.istextfile(new)",
            "    if any((old_isbin, new_isbin)):",
            "        if all((old_isbin, new_isbin)):",
            "            return 'Replace binary file'",
            "        elif old_isbin:",
            "            return 'Replace binary file with text file'",
            "        elif new_isbin:",
            "            return 'Replace text file with binary file'",
            "    return ''",
            "",
            "",
            "def _get_bkroot():",
            "    '''",
            "    Get the location of the backup dir in the minion cache",
            "    '''",
            "    # Get the cachedir from the minion config",
            "    return os.path.join(__salt__['config.get']('cachedir'), 'file_backup')",
            "",
            "",
            "def _splitlines_preserving_trailing_newline(str):",
            "    '''",
            "    Returns a list of the lines in the string, breaking at line boundaries and",
            "    preserving a trailing newline (if present).",
            "",
            "    Essentially, this works like ``str.striplines(False)`` but preserves an",
            "    empty line at the end. This is equivalent to the following code:",
            "",
            "    .. code-block:: python",
            "",
            "        lines = str.splitlines()",
            "        if str.endswith('\\n') or str.endswith('\\r'):",
            "            lines.append('')",
            "    '''",
            "    lines = str.splitlines()",
            "    if str.endswith('\\n') or str.endswith('\\r'):",
            "        lines.append('')",
            "    return lines",
            "",
            "",
            "def gid_to_group(gid):",
            "    '''",
            "    Convert the group id to the group name on this system",
            "",
            "    gid",
            "        gid to convert to a group name",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.gid_to_group 0",
            "    '''",
            "    try:",
            "        gid = int(gid)",
            "    except ValueError:",
            "        # This is not an integer, maybe it's already the group name?",
            "        gid = group_to_gid(gid)",
            "",
            "    if gid == '':",
            "        # Don't even bother to feed it to grp",
            "        return ''",
            "",
            "    try:",
            "        return grp.getgrgid(gid).gr_name",
            "    except (KeyError, NameError):",
            "        # If group is not present, fall back to the gid.",
            "        return gid",
            "",
            "",
            "def group_to_gid(group):",
            "    '''",
            "    Convert the group to the gid on this system",
            "",
            "    group",
            "        group to convert to its gid",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.group_to_gid root",
            "    '''",
            "    if group is None:",
            "        return ''",
            "    try:",
            "        if isinstance(group, int):",
            "            return group",
            "        return grp.getgrnam(group).gr_gid",
            "    except KeyError:",
            "        return ''",
            "",
            "",
            "def get_gid(path, follow_symlinks=True):",
            "    '''",
            "    Return the id of the group that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the gid",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_gid /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('gid', -1)",
            "",
            "",
            "def get_group(path, follow_symlinks=True):",
            "    '''",
            "    Return the group that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the group",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_group /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('group', False)",
            "",
            "",
            "def uid_to_user(uid):",
            "    '''",
            "    Convert a uid to a user name",
            "",
            "    uid",
            "        uid to convert to a username",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.uid_to_user 0",
            "    '''",
            "    try:",
            "        return pwd.getpwuid(uid).pw_name",
            "    except (KeyError, NameError):",
            "        # If user is not present, fall back to the uid.",
            "        return uid",
            "",
            "",
            "def user_to_uid(user):",
            "    '''",
            "    Convert user name to a uid",
            "",
            "    user",
            "        user name to convert to its uid",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.user_to_uid root",
            "    '''",
            "    if user is None:",
            "        user = salt.utils.get_user()",
            "    try:",
            "        if isinstance(user, int):",
            "            return user",
            "        return pwd.getpwnam(user).pw_uid",
            "    except KeyError:",
            "        return ''",
            "",
            "",
            "def get_uid(path, follow_symlinks=True):",
            "    '''",
            "    Return the id of the user that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the uid",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_uid /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('uid', -1)",
            "",
            "",
            "def get_user(path, follow_symlinks=True):",
            "    '''",
            "    Return the user that owns a given file",
            "",
            "    path",
            "        file or directory of which to get the user",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_user /etc/passwd",
            "",
            "    .. versionchanged:: 0.16.4",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('user', False)",
            "",
            "",
            "def get_mode(path, follow_symlinks=True):",
            "    '''",
            "    Return the mode of a file",
            "",
            "    path",
            "        file or directory of which to get the mode",
            "",
            "    follow_symlinks",
            "        indicated if symlinks should be followed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_mode /etc/passwd",
            "",
            "    .. versionchanged:: 2014.1.0",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get('mode', '')",
            "",
            "",
            "def set_mode(path, mode):",
            "    '''",
            "    Set the mode of a file",
            "",
            "    path",
            "        file or directory of which to set the mode",
            "",
            "    mode",
            "        mode to set the path to",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.set_mode /etc/passwd 0644",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    mode = str(mode).lstrip('0Oo')",
            "    if not mode:",
            "        mode = '0'",
            "    if not os.path.exists(path):",
            "        raise CommandExecutionError('{0}: File not found'.format(path))",
            "    try:",
            "        os.chmod(path, int(mode, 8))",
            "    except Exception:",
            "        return 'Invalid Mode ' + mode",
            "    return get_mode(path)",
            "",
            "",
            "def lchown(path, user, group):",
            "    '''",
            "    Chown a file, pass the file the desired user and group without following",
            "    symlinks.",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    user",
            "        user owner",
            "",
            "    group",
            "        group owner",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.chown /etc/passwd root root",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    uid = user_to_uid(user)",
            "    gid = group_to_gid(group)",
            "    err = ''",
            "    if uid == '':",
            "        if user:",
            "            err += 'User does not exist\\n'",
            "        else:",
            "            uid = -1",
            "    if gid == '':",
            "        if group:",
            "            err += 'Group does not exist\\n'",
            "        else:",
            "            gid = -1",
            "",
            "    return os.lchown(path, uid, gid)",
            "",
            "",
            "def chown(path, user, group):",
            "    '''",
            "    Chown a file, pass the file the desired user and group",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    user",
            "        user owner",
            "",
            "    group",
            "        group owner",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.chown /etc/passwd root root",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    uid = user_to_uid(user)",
            "    gid = group_to_gid(group)",
            "    err = ''",
            "    if uid == '':",
            "        if user:",
            "            err += 'User does not exist\\n'",
            "        else:",
            "            uid = -1",
            "    if gid == '':",
            "        if group:",
            "            err += 'Group does not exist\\n'",
            "        else:",
            "            gid = -1",
            "    if not os.path.exists(path):",
            "        try:",
            "            # Broken symlinks will return false, but still need to be chowned",
            "            return os.lchown(path, uid, gid)",
            "        except OSError:",
            "            pass",
            "        err += 'File not found'",
            "    if err:",
            "        return err",
            "    return os.chown(path, uid, gid)",
            "",
            "",
            "def chgrp(path, group):",
            "    '''",
            "    Change the group of a file",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    group",
            "        group owner",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.chgrp /etc/passwd root",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    user = get_user(path)",
            "    return chown(path, user, group)",
            "",
            "",
            "def get_sum(path, form='sha256'):",
            "    '''",
            "    Return the checksum for the given file. The following checksum algorithms",
            "    are supported:",
            "",
            "    * md5",
            "    * sha1",
            "    * sha224",
            "    * sha256 **(default)**",
            "    * sha384",
            "    * sha512",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    form",
            "        desired sum format",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_sum /etc/passwd sha512",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isfile(path):",
            "        return 'File not found'",
            "    return salt.utils.get_hash(path, form, 4096)",
            "",
            "",
            "def get_hash(path, form='sha256', chunk_size=65536):",
            "    '''",
            "    Get the hash sum of a file",
            "",
            "    This is better than ``get_sum`` for the following reasons:",
            "        - It does not read the entire file into memory.",
            "        - It does not return a string on error. The returned value of",
            "            ``get_sum`` cannot really be trusted since it is vulnerable to",
            "            collisions: ``get_sum(..., 'xyz') == 'Hash xyz not supported'``",
            "",
            "    path",
            "        path to the file or directory",
            "",
            "    form",
            "        desired sum format",
            "",
            "    chunk_size",
            "        amount to sum at once",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_hash /etc/shadow",
            "    '''",
            "    return salt.utils.get_hash(os.path.expanduser(path), form, chunk_size)",
            "",
            "",
            "def get_source_sum(file_name='',",
            "                   source='',",
            "                   source_hash=None,",
            "                   source_hash_name=None,",
            "                   saltenv='base'):",
            "    '''",
            "    .. versionadded:: 2016.11.0",
            "",
            "    Used by :py:func:`file.get_managed <salt.modules.file.get_managed>` to",
            "    obtain the hash and hash type from the parameters specified below.",
            "",
            "    file_name",
            "        Optional file name being managed, for matching with",
            "        :py:func:`file.extract_hash <salt.modules.file.extract_hash>`.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    source",
            "        Source file, as used in :py:mod:`file <salt.states.file>` and other",
            "        states. If ``source_hash`` refers to a file containing hashes, then",
            "        this filename will be used to match a filename in that file. If the",
            "        ``source_hash`` is a hash expression, then this argument will be",
            "        ignored.",
            "",
            "    source_hash",
            "        Hash file/expression, as used in :py:mod:`file <salt.states.file>` and",
            "        other states. If this value refers to a remote URL or absolute path to",
            "        a local file, it will be cached and :py:func:`file.extract_hash",
            "        <salt.modules.file.extract_hash>` will be used to obtain a hash from",
            "        it.",
            "",
            "    source_hash_name",
            "        Specific file name to look for when ``source_hash`` refers to a remote",
            "        file, used to disambiguate ambiguous matches.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    saltenv : base",
            "        Salt fileserver environment from which to retrive the source_hash. This",
            "        value will only be used when ``source_hash`` refers to a file on the",
            "        Salt fileserver (i.e. one beginning with ``salt://``).",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_source_sum /tmp/foo.tar.gz source=http://mydomain.tld/foo.tar.gz source_hash=499ae16dcae71eeb7c3a30c75ea7a1a6",
            "        salt '*' file.get_source_sum /tmp/foo.tar.gz source=http://mydomain.tld/foo.tar.gz source_hash=https://mydomain.tld/hashes.md5",
            "        salt '*' file.get_source_sum /tmp/foo.tar.gz source=http://mydomain.tld/foo.tar.gz source_hash=https://mydomain.tld/hashes.md5 source_hash_name=./dir2/foo.tar.gz",
            "    '''",
            "    def _invalid_source_hash_format():",
            "        '''",
            "        DRY helper for reporting invalid source_hash input",
            "        '''",
            "        raise CommandExecutionError(",
            "            'Source hash {0} format is invalid. The supported formats are: '",
            "            '1) a hash, 2) an expression in the format <hash_type>=<hash>, or '",
            "            '3) either a path to a local file containing hashes, or a URI of '",
            "            'a remote hash file. Supported protocols for remote hash files '",
            "            'are: {1}. The hash may also not be of a valid length, the '",
            "            'following are supported hash types and lengths: {2}.'.format(",
            "                source_hash,",
            "                ', '.join(salt.utils.files.VALID_PROTOS),",
            "                ', '.join(",
            "                    ['{0} ({1})'.format(HASHES_REVMAP[x], x)",
            "                     for x in sorted(HASHES_REVMAP)]",
            "                ),",
            "            )",
            "        )",
            "",
            "    hash_fn = None",
            "    if os.path.isabs(source_hash):",
            "        hash_fn = source_hash",
            "    else:",
            "        try:",
            "            proto = _urlparse(source_hash).scheme",
            "            if proto in salt.utils.files.VALID_PROTOS:",
            "                hash_fn = __salt__['cp.cache_file'](source_hash, saltenv)",
            "                if not hash_fn:",
            "                    raise CommandExecutionError(",
            "                        'Source hash file {0} not found'.format(source_hash)",
            "                    )",
            "            else:",
            "                if proto != '':",
            "                    # Some unsupported protocol (e.g. foo://) is being used.",
            "                    # We'll get into this else block if a hash expression",
            "                    # (like md5=<md5 checksum here>), but in those cases, the",
            "                    # protocol will be an empty string, in which case we avoid",
            "                    # this error condition.",
            "                    _invalid_source_hash_format()",
            "        except (AttributeError, TypeError):",
            "            _invalid_source_hash_format()",
            "",
            "    if hash_fn is not None:",
            "        ret = extract_hash(hash_fn, '', file_name, source, source_hash_name)",
            "        if ret is None:",
            "            _invalid_source_hash_format()",
            "        return ret",
            "    else:",
            "        # The source_hash is a hash expression",
            "        ret = {}",
            "        try:",
            "            ret['hash_type'], ret['hsum'] = \\",
            "                [x.strip() for x in source_hash.split('=', 1)]",
            "        except AttributeError:",
            "            _invalid_source_hash_format()",
            "        except ValueError:",
            "            # No hash type, try to figure out by hash length",
            "            if not re.match('^[{0}]+$'.format(string.hexdigits), source_hash):",
            "                _invalid_source_hash_format()",
            "            ret['hsum'] = source_hash",
            "            source_hash_len = len(source_hash)",
            "            if source_hash_len in HASHES_REVMAP:",
            "                ret['hash_type'] = HASHES_REVMAP[source_hash_len]",
            "            else:",
            "                _invalid_source_hash_format()",
            "",
            "        if ret['hash_type'] not in HASHES:",
            "            raise CommandExecutionError(",
            "                'Invalid hash type \\'{0}\\'. Supported hash types are: {1}. '",
            "                'Either remove the hash type and simply use \\'{2}\\' as the '",
            "                'source_hash, or change the hash type to a supported type.'",
            "                .format(ret['hash_type'], ', '.join(HASHES), ret['hsum'])",
            "            )",
            "        else:",
            "            hsum_len = len(ret['hsum'])",
            "            if hsum_len not in HASHES_REVMAP:",
            "                _invalid_source_hash_format()",
            "            elif hsum_len != HASHES[ret['hash_type']]:",
            "                raise CommandExecutionError(",
            "                    'Invalid length ({0}) for hash type \\'{1}\\'. Either '",
            "                    'remove the hash type and simply use \\'{2}\\' as the '",
            "                    'source_hash, or change the hash type to \\'{3}\\''.format(",
            "                        hsum_len,",
            "                        ret['hash_type'],",
            "                        ret['hsum'],",
            "                        HASHES_REVMAP[hsum_len],",
            "                    )",
            "                )",
            "",
            "        return ret",
            "",
            "",
            "def check_hash(path, file_hash):",
            "    '''",
            "    Check if a file matches the given hash string",
            "",
            "    Returns ``True`` if the hash matches, otherwise ``False``.",
            "",
            "    path",
            "        Path to a file local to the minion.",
            "",
            "    hash",
            "        The hash to check against the file specified in the ``path`` argument.",
            "        For versions 2016.11.4 and newer, the hash can be specified without an",
            "        accompanying hash type (e.g. ``e138491e9d5b97023cea823fe17bac22``),",
            "        but for earlier releases it is necessary to also specify the hash type",
            "        in the format ``<hash_type>:<hash_value>`` (e.g.",
            "        ``md5:e138491e9d5b97023cea823fe17bac22``).",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_hash /etc/fstab e138491e9d5b97023cea823fe17bac22",
            "        salt '*' file.check_hash /etc/fstab md5:e138491e9d5b97023cea823fe17bac22",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not isinstance(file_hash, six.string_types):",
            "        raise SaltInvocationError('hash must be a string')",
            "",
            "    for sep in (':', '='):",
            "        if sep in file_hash:",
            "            hash_type, hash_value = file_hash.split(sep, 1)",
            "            break",
            "    else:",
            "        hash_value = file_hash",
            "        hash_len = len(file_hash)",
            "        hash_type = HASHES_REVMAP.get(hash_len)",
            "        if hash_type is None:",
            "            raise SaltInvocationError(",
            "                'Hash {0} (length: {1}) could not be matched to a supported '",
            "                'hash type. The supported hash types and lengths are: '",
            "                '{2}'.format(",
            "                    file_hash,",
            "                    hash_len,",
            "                    ', '.join(",
            "                        ['{0} ({1})'.format(HASHES_REVMAP[x], x)",
            "                         for x in sorted(HASHES_REVMAP)]",
            "                    ),",
            "                )",
            "            )",
            "",
            "    return get_hash(path, hash_type) == hash_value",
            "",
            "",
            "def find(path, *args, **kwargs):",
            "    '''",
            "    Approximate the Unix ``find(1)`` command and return a list of paths that",
            "    meet the specified criteria.",
            "",
            "    The options include match criteria:",
            "",
            "    .. code-block:: text",
            "",
            "        name    = path-glob                 # case sensitive",
            "        iname   = path-glob                 # case insensitive",
            "        regex   = path-regex                # case sensitive",
            "        iregex  = path-regex                # case insensitive",
            "        type    = file-types                # match any listed type",
            "        user    = users                     # match any listed user",
            "        group   = groups                    # match any listed group",
            "        size    = [+-]number[size-unit]     # default unit = byte",
            "        mtime   = interval                  # modified since date",
            "        grep    = regex                     # search file contents",
            "",
            "    and/or actions:",
            "",
            "    .. code-block:: text",
            "",
            "        delete [= file-types]               # default type = 'f'",
            "        exec    = command [arg ...]         # where {} is replaced by pathname",
            "        print  [= print-opts]",
            "",
            "    and/or depth criteria:",
            "",
            "    .. code-block:: text",
            "",
            "        maxdepth = maximum depth to transverse in path",
            "        mindepth = minimum depth to transverse before checking files or directories",
            "",
            "    The default action is ``print=path``",
            "",
            "    ``path-glob``:",
            "",
            "    .. code-block:: text",
            "",
            "        *                = match zero or more chars",
            "        ?                = match any char",
            "        [abc]            = match a, b, or c",
            "        [!abc] or [^abc] = match anything except a, b, and c",
            "        [x-y]            = match chars x through y",
            "        [!x-y] or [^x-y] = match anything except chars x through y",
            "        {a,b,c}          = match a or b or c",
            "",
            "    ``path-regex``: a Python Regex (regular expression) pattern to match pathnames",
            "",
            "    ``file-types``: a string of one or more of the following:",
            "",
            "    .. code-block:: text",
            "",
            "        a: all file types",
            "        b: block device",
            "        c: character device",
            "        d: directory",
            "        p: FIFO (named pipe)",
            "        f: plain file",
            "        l: symlink",
            "        s: socket",
            "",
            "    ``users``: a space and/or comma separated list of user names and/or uids",
            "",
            "    ``groups``: a space and/or comma separated list of group names and/or gids",
            "",
            "    ``size-unit``:",
            "",
            "    .. code-block:: text",
            "",
            "        b: bytes",
            "        k: kilobytes",
            "        m: megabytes",
            "        g: gigabytes",
            "        t: terabytes",
            "",
            "    interval:",
            "",
            "    .. code-block:: text",
            "",
            "        [<num>w] [<num>d] [<num>h] [<num>m] [<num>s]",
            "",
            "        where:",
            "            w: week",
            "            d: day",
            "            h: hour",
            "            m: minute",
            "            s: second",
            "",
            "    print-opts: a comma and/or space separated list of one or more of the",
            "    following:",
            "",
            "    .. code-block:: text",
            "",
            "        group: group name",
            "        md5:   MD5 digest of file contents",
            "        mode:  file permissions (as integer)",
            "        mtime: last modification time (as time_t)",
            "        name:  file basename",
            "        path:  file absolute path",
            "        size:  file size in bytes",
            "        type:  file type",
            "        user:  user name",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.find / type=f name=\\\\*.bak size=+10m",
            "        salt '*' file.find /var mtime=+30d size=+10m print=path,size,mtime",
            "        salt '*' file.find /var/log name=\\\\*.[0-9] mtime=+30d size=+10m delete",
            "    '''",
            "    if 'delete' in args:",
            "        kwargs['delete'] = 'f'",
            "    elif 'print' in args:",
            "        kwargs['print'] = 'path'",
            "",
            "    try:",
            "        finder = salt.utils.find.Finder(kwargs)",
            "    except ValueError as ex:",
            "        return 'error: {0}'.format(ex)",
            "",
            "    ret = [item for i in [finder.find(p) for p in glob.glob(os.path.expanduser(path))] for item in i]",
            "    ret.sort()",
            "    return ret",
            "",
            "",
            "def _sed_esc(string, escape_all=False):",
            "    '''",
            "    Escape single quotes and forward slashes",
            "    '''",
            "    special_chars = \"^.[$()|*+?{\"",
            "    string = string.replace(\"'\", \"'\\\"'\\\"'\").replace(\"/\", \"\\\\/\")",
            "    if escape_all is True:",
            "        for char in special_chars:",
            "            string = string.replace(char, \"\\\\\" + char)",
            "    return string",
            "",
            "",
            "def sed(path,",
            "        before,",
            "        after,",
            "        limit='',",
            "        backup='.bak',",
            "        options='-r -e',",
            "        flags='g',",
            "        escape_all=False,",
            "        negate_match=False):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Make a simple edit to a file",
            "",
            "    Equivalent to:",
            "",
            "    .. code-block:: bash",
            "",
            "        sed <backup> <options> \"/<limit>/ s/<before>/<after>/<flags> <file>\"",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    before",
            "        A pattern to find in order to replace with ``after``",
            "    after",
            "        Text that will replace ``before``",
            "    limit : ``''``",
            "        An initial pattern to search for before searching for ``before``",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "        **WARNING:** each time ``sed``/``comment``/``uncomment`` is called will",
            "        overwrite this backup",
            "    options : ``-r -e``",
            "        Options to pass to sed",
            "    flags : ``g``",
            "        Flags to modify the sed search; e.g., ``i`` for case-insensitive pattern",
            "        matching",
            "    negate_match : False",
            "        Negate the search command (``!``)",
            "",
            "        .. versionadded:: 0.17.0",
            "",
            "    Forward slashes and single quotes will be escaped automatically in the",
            "    ``before`` and ``after`` patterns.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.sed /etc/httpd/httpd.conf 'LogLevel warn' 'LogLevel info'",
            "    '''",
            "    # Largely inspired by Fabric's contrib.files.sed()",
            "    # XXX:dc: Do we really want to always force escaping?",
            "    #",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    # Mandate that before and after are strings",
            "    before = str(before)",
            "    after = str(after)",
            "    before = _sed_esc(before, escape_all)",
            "    after = _sed_esc(after, escape_all)",
            "    limit = _sed_esc(limit, escape_all)",
            "    if sys.platform == 'darwin':",
            "        options = options.replace('-r', '-E')",
            "",
            "    cmd = ['sed']",
            "    cmd.append('-i{0}'.format(backup) if backup else '-i')",
            "    cmd.extend(salt.utils.shlex_split(options))",
            "    cmd.append(",
            "        r'{limit}{negate_match}s/{before}/{after}/{flags}'.format(",
            "            limit='/{0}/ '.format(limit) if limit else '',",
            "            negate_match='!' if negate_match else '',",
            "            before=before,",
            "            after=after,",
            "            flags=flags",
            "        )",
            "    )",
            "    cmd.append(path)",
            "",
            "    return __salt__['cmd.run_all'](cmd, python_shell=False)",
            "",
            "",
            "def sed_contains(path,",
            "                 text,",
            "                 limit='',",
            "                 flags='g'):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return True if the file at ``path`` contains ``text``. Utilizes sed to",
            "    perform the search (line-wise search).",
            "",
            "    Note: the ``p`` flag will be added to any flags you pass in.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains /etc/crontab 'mymaintenance.sh'",
            "    '''",
            "    # Largely inspired by Fabric's contrib.files.contains()",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    before = _sed_esc(str(text), False)",
            "    limit = _sed_esc(str(limit), False)",
            "    options = '-n -r -e'",
            "    if sys.platform == 'darwin':",
            "        options = options.replace('-r', '-E')",
            "",
            "    cmd = ['sed']",
            "    cmd.extend(salt.utils.shlex_split(options))",
            "    cmd.append(",
            "        r'{limit}s/{before}/$/{flags}'.format(",
            "            limit='/{0}/ '.format(limit) if limit else '',",
            "            before=before,",
            "            flags='p{0}'.format(flags)",
            "        )",
            "    )",
            "    cmd.append(path)",
            "",
            "    result = __salt__['cmd.run'](cmd, python_shell=False)",
            "",
            "    return bool(result)",
            "",
            "",
            "def psed(path,",
            "         before,",
            "         after,",
            "         limit='',",
            "         backup='.bak',",
            "         flags='gMS',",
            "         escape_all=False,",
            "         multi=False):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Make a simple edit to a file (pure Python version)",
            "",
            "    Equivalent to:",
            "",
            "    .. code-block:: bash",
            "",
            "        sed <backup> <options> \"/<limit>/ s/<before>/<after>/<flags> <file>\"",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    before",
            "        A pattern to find in order to replace with ``after``",
            "    after",
            "        Text that will replace ``before``",
            "    limit : ``''``",
            "        An initial pattern to search for before searching for ``before``",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "        **WARNING:** each time ``sed``/``comment``/``uncomment`` is called will",
            "        overwrite this backup",
            "    flags : ``gMS``",
            "        Flags to modify the search. Valid values are:",
            "          - ``g``: Replace all occurrences of the pattern, not just the first.",
            "          - ``I``: Ignore case.",
            "          - ``L``: Make ``\\\\w``, ``\\\\W``, ``\\\\b``, ``\\\\B``, ``\\\\s`` and ``\\\\S``",
            "            dependent on the locale.",
            "          - ``M``: Treat multiple lines as a single line.",
            "          - ``S``: Make `.` match all characters, including newlines.",
            "          - ``U``: Make ``\\\\w``, ``\\\\W``, ``\\\\b``, ``\\\\B``, ``\\\\d``, ``\\\\D``,",
            "            ``\\\\s`` and ``\\\\S`` dependent on Unicode.",
            "          - ``X``: Verbose (whitespace is ignored).",
            "    multi: ``False``",
            "        If True, treat the entire file as a single line",
            "",
            "    Forward slashes and single quotes will be escaped automatically in the",
            "    ``before`` and ``after`` patterns.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.sed /etc/httpd/httpd.conf 'LogLevel warn' 'LogLevel info'",
            "    '''",
            "    # Largely inspired by Fabric's contrib.files.sed()",
            "    # XXX:dc: Do we really want to always force escaping?",
            "    #",
            "    # Mandate that before and after are strings",
            "    path = os.path.expanduser(path)",
            "",
            "    multi = bool(multi)",
            "",
            "    before = str(before)",
            "    after = str(after)",
            "    before = _sed_esc(before, escape_all)",
            "    # The pattern to replace with does not need to be escaped!!!",
            "    #after = _sed_esc(after, escape_all)",
            "    limit = _sed_esc(limit, escape_all)",
            "",
            "    shutil.copy2(path, '{0}{1}'.format(path, backup))",
            "",
            "    with salt.utils.fopen(path, 'w') as ofile:",
            "        with salt.utils.fopen('{0}{1}'.format(path, backup), 'r') as ifile:",
            "            if multi is True:",
            "                for line in ifile.readline():",
            "                    ofile.write(_psed(line, before, after, limit, flags))",
            "            else:",
            "                ofile.write(_psed(ifile.read(), before, after, limit, flags))",
            "",
            "",
            "RE_FLAG_TABLE = {'I': re.I,",
            "                 'L': re.L,",
            "                 'M': re.M,",
            "                 'S': re.S,",
            "                 'U': re.U,",
            "                 'X': re.X}",
            "",
            "",
            "def _psed(text,",
            "          before,",
            "          after,",
            "          limit,",
            "          flags):",
            "    '''",
            "    Does the actual work for file.psed, so that single lines can be passed in",
            "    '''",
            "    atext = text",
            "    if limit:",
            "        limit = re.compile(limit)",
            "        comps = text.split(limit)",
            "        atext = ''.join(comps[1:])",
            "",
            "    count = 1",
            "    if 'g' in flags:",
            "        count = 0",
            "        flags = flags.replace('g', '')",
            "",
            "    aflags = 0",
            "    for flag in flags:",
            "        aflags |= RE_FLAG_TABLE[flag]",
            "",
            "    before = re.compile(before, flags=aflags)",
            "    text = re.sub(before, after, atext, count=count)",
            "",
            "    return text",
            "",
            "",
            "def uncomment(path,",
            "              regex,",
            "              char='#',",
            "              backup='.bak'):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Uncomment specified commented lines in a file",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be uncommented.",
            "        This regex should not include the comment character. A leading ``^``",
            "        character will be stripped for convenience (for easily switching",
            "        between comment() and uncomment()).",
            "    char : ``#``",
            "        The character to remove in order to uncomment a line",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "        **WARNING:** each time ``sed``/``comment``/``uncomment`` is called will",
            "        overwrite this backup",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.uncomment /etc/hosts.deny 'ALL: PARANOID'",
            "    '''",
            "    return comment_line(path=path,",
            "                        regex=regex,",
            "                        char=char,",
            "                        cmnt=False,",
            "                        backup=backup)",
            "",
            "",
            "def comment(path,",
            "            regex,",
            "            char='#',",
            "            backup='.bak'):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :py:func:`~salt.modules.file.replace` instead.",
            "",
            "    Comment out specified lines in a file",
            "",
            "    path",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be commented;",
            "        this pattern will be wrapped in parenthesis and will move any",
            "        preceding/trailing ``^`` or ``$`` characters outside the parenthesis",
            "        (e.g., the pattern ``^foo$`` will be rewritten as ``^(foo)$``)",
            "    char : ``#``",
            "        The character to be inserted at the beginning of a line in order to",
            "        comment it out",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension",
            "",
            "        .. warning::",
            "",
            "            This backup will be overwritten each time ``sed`` / ``comment`` /",
            "            ``uncomment`` is called. Meaning the backup will only be useful",
            "            after the first invocation.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.comment /etc/modules pcspkr",
            "    '''",
            "    return comment_line(path=path,",
            "                        regex=regex,",
            "                        char=char,",
            "                        cmnt=True,",
            "                        backup=backup)",
            "",
            "",
            "def comment_line(path,",
            "                 regex,",
            "                 char='#',",
            "                 cmnt=True,",
            "                 backup='.bak'):",
            "    r'''",
            "    Comment or Uncomment a line in a text file.",
            "",
            "    :param path: string",
            "        The full path to the text file.",
            "",
            "    :param regex: string",
            "        A regex expression that begins with ``^`` that will find the line you wish",
            "        to comment. Can be as simple as ``^color =``",
            "",
            "    :param char: string",
            "        The character used to comment a line in the type of file you're referencing.",
            "        Default is ``#``",
            "",
            "    :param cmnt: boolean",
            "        True to comment the line. False to uncomment the line. Default is True.",
            "",
            "    :param backup: string",
            "        The file extension to give the backup file. Default is ``.bak``",
            "        Set to False/None to not keep a backup.",
            "",
            "    :return: boolean",
            "        Returns True if successful, False if not",
            "",
            "    CLI Example:",
            "",
            "    The following example will comment out the ``pcspkr`` line in the",
            "    ``/etc/modules`` file using the default ``#`` character and create a backup",
            "    file named ``modules.bak``",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.comment_line '/etc/modules' '^pcspkr'",
            "",
            "",
            "    CLI Example:",
            "",
            "    The following example will uncomment the ``log_level`` setting in ``minion``",
            "    config file if it is set to either ``warning``, ``info``, or ``debug`` using",
            "    the ``#`` character and create a backup file named ``minion.bk``",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.comment_line 'C:\\salt\\conf\\minion' '^log_level: (warning|info|debug)' '#' False '.bk'",
            "    '''",
            "    # Get the regex for comment or uncomment",
            "    if cmnt:",
            "        regex = '{0}({1}){2}'.format(",
            "                '^' if regex.startswith('^') else '',",
            "                regex.lstrip('^').rstrip('$'),",
            "                '$' if regex.endswith('$') else '')",
            "    else:",
            "        regex = r'^{0}\\s*({1}){2}'.format(",
            "                char,",
            "                regex.lstrip('^').rstrip('$'),",
            "                '$' if regex.endswith('$') else '')",
            "",
            "    # Load the real path to the file",
            "    path = os.path.realpath(os.path.expanduser(path))",
            "",
            "    # Make sure the file exists",
            "    if not os.path.isfile(path):",
            "        raise SaltInvocationError('File not found: {0}'.format(path))",
            "",
            "    # Make sure it is a text file",
            "    if not salt.utils.istextfile(path):",
            "        raise SaltInvocationError(",
            "            'Cannot perform string replacements on a binary file: {0}'.format(path))",
            "",
            "    # First check the whole file, determine whether to make the replacement",
            "    # Searching first avoids modifying the time stamp if there are no changes",
            "    found = False",
            "    # Dictionaries for comparing changes",
            "    orig_file = []",
            "    new_file = []",
            "    # Buffer size for fopen",
            "    bufsize = os.path.getsize(path)",
            "    try:",
            "        # Use a read-only handle to open the file",
            "        with salt.utils.fopen(path,",
            "                              mode='rb',",
            "                              buffering=bufsize) as r_file:",
            "            # Loop through each line of the file and look for a match",
            "            for line in r_file:",
            "                # Is it in this line",
            "                if re.match(regex, line):",
            "                    # Load lines into dictionaries, set found to True",
            "                    orig_file.append(line)",
            "                    if cmnt:",
            "                        new_file.append('{0}{1}'.format(char, line))",
            "                    else:",
            "                        new_file.append(line.lstrip(char))",
            "                    found = True",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to open file '{0}'. \"",
            "            \"Exception: {1}\".format(path, exc)",
            "        )",
            "",
            "    # We've searched the whole file. If we didn't find anything, return False",
            "    if not found:",
            "        return False",
            "",
            "    if not salt.utils.is_windows():",
            "        pre_user = get_user(path)",
            "        pre_group = get_group(path)",
            "        pre_mode = salt.utils.normalize_mode(get_mode(path))",
            "",
            "    # Create a copy to read from and to use as a backup later",
            "    try:",
            "        temp_file = _mkstemp_copy(path=path, preserve_inode=False)",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "    try:",
            "        # Open the file in write mode",
            "        with salt.utils.fopen(path,",
            "                              mode='wb',",
            "                              buffering=bufsize) as w_file:",
            "            try:",
            "                # Open the temp file in read mode",
            "                with salt.utils.fopen(temp_file,",
            "                                      mode='rb',",
            "                                      buffering=bufsize) as r_file:",
            "                    # Loop through each line of the file and look for a match",
            "                    for line in r_file:",
            "                        try:",
            "                            # Is it in this line",
            "                            if re.match(regex, line):",
            "                                # Write the new line",
            "                                if cmnt:",
            "                                    w_file.write('{0}{1}'.format(char, line))",
            "                                else:",
            "                                    w_file.write(line.lstrip(char))",
            "                            else:",
            "                                # Write the existing line (no change)",
            "                                w_file.write(line)",
            "                        except (OSError, IOError) as exc:",
            "                            raise CommandExecutionError(",
            "                                \"Unable to write file '{0}'. Contents may \"",
            "                                \"be truncated. Temporary file contains copy \"",
            "                                \"at '{1}'. \"",
            "                                \"Exception: {2}\".format(path, temp_file, exc)",
            "                            )",
            "            except (OSError, IOError) as exc:",
            "                raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "    if backup:",
            "        # Move the backup file to the original directory",
            "        backup_name = '{0}{1}'.format(path, backup)",
            "        try:",
            "            shutil.move(temp_file, backup_name)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to move the temp file '{0}' to the \"",
            "                \"backup file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "            )",
            "    else:",
            "        os.remove(temp_file)",
            "",
            "    if not salt.utils.is_windows():",
            "        check_perms(path, None, pre_user, pre_group, pre_mode)",
            "",
            "    # Return a diff using the two dictionaries",
            "    return ''.join(difflib.unified_diff(orig_file, new_file))",
            "",
            "",
            "def _get_flags(flags):",
            "    '''",
            "    Return an integer appropriate for use as a flag for the re module from a",
            "    list of human-readable strings",
            "",
            "    .. code-block:: python",
            "",
            "        >>> _get_flags(['MULTILINE', 'IGNORECASE'])",
            "        10",
            "        >>> _get_flags('MULTILINE')",
            "        8",
            "        >>> _get_flags(2)",
            "        2",
            "    '''",
            "    if isinstance(flags, six.string_types):",
            "        flags = [flags]",
            "",
            "    if isinstance(flags, Iterable) and not isinstance(flags, Mapping):",
            "        _flags_acc = []",
            "        for flag in flags:",
            "            _flag = getattr(re, str(flag).upper())",
            "",
            "            if not isinstance(_flag, six.integer_types):",
            "                raise SaltInvocationError(",
            "                    'Invalid re flag given: {0}'.format(flag)",
            "                )",
            "",
            "            _flags_acc.append(_flag)",
            "",
            "        return reduce(operator.__or__, _flags_acc)",
            "    elif isinstance(flags, six.integer_types):",
            "        return flags",
            "    else:",
            "        raise SaltInvocationError(",
            "            'Invalid re flags: \"{0}\", must be given either as a single flag '",
            "            'string, a list of strings, or as an integer'.format(flags)",
            "        )",
            "",
            "",
            "def _add_flags(flags, new_flags):",
            "    '''",
            "    Combine ``flags`` and ``new_flags``",
            "    '''",
            "    flags = _get_flags(flags)",
            "    new_flags = _get_flags(new_flags)",
            "    return flags | new_flags",
            "",
            "",
            "def _mkstemp_copy(path,",
            "                  preserve_inode=True):",
            "    '''",
            "    Create a temp file and move/copy the contents of ``path`` to the temp file.",
            "    Return the path to the temp file.",
            "",
            "    path",
            "        The full path to the file whose contents will be moved/copied to a temp file.",
            "        Whether it's moved or copied depends on the value of ``preserve_inode``.",
            "    preserve_inode",
            "        Preserve the inode of the file, so that any hard links continue to share the",
            "        inode with the original filename. This works by *copying* the file, reading",
            "        from the copy, and writing to the file at the original inode. If ``False``, the",
            "        file will be *moved* rather than copied, and a new file will be written to a",
            "        new inode, but using the original filename. Hard links will then share an inode",
            "        with the backup, instead (if using ``backup`` to create a backup copy).",
            "        Default is ``True``.",
            "    '''",
            "    temp_file = None",
            "    # Create the temp file",
            "    try:",
            "        temp_file = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX)",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to create temp file. \"",
            "            \"Exception: {0}\".format(exc)",
            "            )",
            "    # use `copy` to preserve the inode of the",
            "    # original file, and thus preserve hardlinks",
            "    # to the inode. otherwise, use `move` to",
            "    # preserve prior behavior, which results in",
            "    # writing the file to a new inode.",
            "    if preserve_inode:",
            "        try:",
            "            shutil.copy2(path, temp_file)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to copy file '{0}' to the \"",
            "                \"temp file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "                )",
            "    else:",
            "        try:",
            "            shutil.move(path, temp_file)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to move file '{0}' to the \"",
            "                \"temp file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "                )",
            "",
            "    return temp_file",
            "",
            "",
            "def _starts_till(src, probe, strip_comments=True):",
            "    '''",
            "    Returns True if src and probe at least begins till some point.",
            "    '''",
            "    def _strip_comments(txt):",
            "        '''",
            "        Strip possible comments.",
            "        Usually commends are one or two symbols",
            "        '''",
            "        buff = txt.split(\" \", 1)",
            "        return len(buff) == 2 and len(buff[0]) < 2 and buff[1] or txt",
            "",
            "    def _to_words(txt):",
            "        '''",
            "        Split by words",
            "        '''",
            "        return txt and [w for w in txt.strip().split(\" \") if w.strip()] or txt",
            "",
            "    no_match = -1",
            "    equal = 0",
            "    if not src or not probe:",
            "        return no_match",
            "",
            "    if src == probe:",
            "        return equal",
            "",
            "    src = _to_words(strip_comments and _strip_comments(src) or src)",
            "    probe = _to_words(strip_comments and _strip_comments(probe) or probe)",
            "",
            "    a_buff, b_buff = len(src) < len(probe) and (src, probe) or (probe, src)",
            "    b_buff = ' '.join(b_buff)",
            "    for idx in range(len(a_buff)):",
            "        prb = ' '.join(a_buff[:-(idx + 1)])",
            "        if prb and b_buff.startswith(prb):",
            "            return idx",
            "",
            "    return no_match",
            "",
            "",
            "def _regex_to_static(src, regex):",
            "    '''",
            "    Expand regular expression to static match.",
            "    '''",
            "    if not src or not regex:",
            "        return None",
            "",
            "    try:",
            "        src = re.search(regex, src)",
            "    except Exception as ex:",
            "        raise CommandExecutionError(\"{0}: '{1}'\".format(_get_error_message(ex), regex))",
            "",
            "    return src and src.group() or regex",
            "",
            "",
            "def _assert_occurrence(src, probe, target, amount=1):",
            "    '''",
            "    Raise an exception, if there are different amount of specified occurrences in src.",
            "    '''",
            "    occ = src.count(probe)",
            "    if occ > amount:",
            "        msg = 'more than'",
            "    elif occ < amount:",
            "        msg = 'less than'",
            "    elif not occ:",
            "        msg = 'no'",
            "    else:",
            "        msg = None",
            "",
            "    if msg:",
            "        raise CommandExecutionError('Found {0} expected occurrences in \"{1}\" expression'.format(msg, target))",
            "",
            "",
            "def _get_line_indent(src, line, indent):",
            "    '''",
            "    Indent the line with the source line.",
            "    '''",
            "    if not indent:",
            "        return line",
            "",
            "    idt = []",
            "    for c in src:",
            "        if c not in ['\\t', ' ']:",
            "            break",
            "        idt.append(c)",
            "",
            "    return ''.join(idt) + line.strip()",
            "",
            "",
            "def line(path, content, match=None, mode=None, location=None,",
            "         before=None, after=None, show_changes=True, backup=False,",
            "         quiet=False, indent=True):",
            "    '''",
            "    .. versionadded:: 2015.8.0",
            "",
            "    Edit a line in the configuration file. The ``path`` and ``content``",
            "    arguments are required, as well as passing in one of the ``mode``",
            "    options.",
            "",
            "    path",
            "        Filesystem path to the file to be edited.",
            "",
            "    content",
            "        Content of the line.",
            "",
            "    match",
            "        Match the target line for an action by",
            "        a fragment of a string or regular expression.",
            "",
            "        If neither ``before`` nor ``after`` are provided, and ``match``",
            "        is also ``None``, match becomes the ``content`` value.",
            "",
            "    mode",
            "        Defines how to edit a line. One of the following options is",
            "        required:",
            "",
            "        - ensure",
            "            If line does not exist, it will be added. This is based on the",
            "            ``content`` argument.",
            "        - replace",
            "            If line already exists, it will be replaced.",
            "        - delete",
            "            Delete the line, once found.",
            "        - insert",
            "            Insert a line.",
            "",
            "        .. note::",
            "",
            "            If ``mode=insert`` is used, at least one of the following",
            "            options must also be defined: ``location``, ``before``, or",
            "            ``after``. If ``location`` is used, it takes precedence",
            "            over the other two options.",
            "",
            "    location",
            "        Defines where to place content in the line. Note this option is only",
            "        used when ``mode=insert`` is specified. If a location is passed in, it",
            "        takes precedence over both the ``before`` and ``after`` kwargs. Valid",
            "        locations are:",
            "",
            "        - start",
            "            Place the content at the beginning of the file.",
            "        - end",
            "            Place the content at the end of the file.",
            "",
            "    before",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    after",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file.",
            "        If ``False`` return a boolean if any changes were made.",
            "        Default is ``True``",
            "",
            "        .. note::",
            "            Using this option will store two copies of the file in-memory",
            "            (the original version and the edited version) in order to generate the diff.",
            "",
            "    backup",
            "        Create a backup of the original file with the extension:",
            "        \"Year-Month-Day-Hour-Minutes-Seconds\".",
            "",
            "    quiet",
            "        Do not raise any exceptions. E.g. ignore the fact that the file that is",
            "        tried to be edited does not exist and nothing really happened.",
            "",
            "    indent",
            "        Keep indentation with the previous line. This option is not considered when",
            "        the ``delete`` mode is specified.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.line /etc/nsswitch.conf \"networks:\\tfiles dns\" after=\"hosts:.*?\" mode='ensure'",
            "",
            "    .. note::",
            "",
            "        If an equal sign (``=``) appears in an argument to a Salt command, it is",
            "        interpreted as a keyword argument in the format of ``key=val``. That",
            "        processing can be bypassed in order to pass an equal sign through to the",
            "        remote shell command by manually specifying the kwarg:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.line /path/to/file content=\"CREATEMAIL_SPOOL=no\" match=\"CREATE_MAIL_SPOOL=yes\" mode=\"replace\"",
            "    '''",
            "    path = os.path.realpath(os.path.expanduser(path))",
            "    if not os.path.isfile(path):",
            "        if not quiet:",
            "            raise CommandExecutionError('File \"{0}\" does not exists or is not a file.'.format(path))",
            "        return False  # No changes had happened",
            "",
            "    mode = mode and mode.lower() or mode",
            "    if mode not in ['insert', 'ensure', 'delete', 'replace']:",
            "        if mode is None:",
            "            raise CommandExecutionError('Mode was not defined. How to process the file?')",
            "        else:",
            "            raise CommandExecutionError('Unknown mode: \"{0}\"'.format(mode))",
            "",
            "    # Before/after has privilege. If nothing defined, match is used by content.",
            "    if before is None and after is None and not match:",
            "        match = content",
            "",
            "    with salt.utils.fopen(path, mode='r') as fp_:",
            "        body = fp_.read()",
            "    body_before = hashlib.sha256(salt.utils.to_bytes(body)).hexdigest()",
            "    after = _regex_to_static(body, after)",
            "    before = _regex_to_static(body, before)",
            "    match = _regex_to_static(body, match)",
            "",
            "    if os.stat(path).st_size == 0 and mode in ('delete', 'replace'):",
            "        log.warning('Cannot find text to {0}. File \\'{1}\\' is empty.'.format(mode, path))",
            "        body = ''",
            "    elif mode == 'delete':",
            "        body = os.linesep.join([line for line in body.split(os.linesep) if line.find(match) < 0])",
            "    elif mode == 'replace':",
            "        body = os.linesep.join([(_get_line_indent(file_line, content, indent)",
            "                                if (file_line.find(match) > -1 and not file_line == content) else file_line)",
            "                                for file_line in body.split(os.linesep)])",
            "    elif mode == 'insert':",
            "        if not location and not before and not after:",
            "            raise CommandExecutionError('On insert must be defined either \"location\" or \"before/after\" conditions.')",
            "",
            "        if not location:",
            "            if before and after:",
            "                _assert_occurrence(body, before, 'before')",
            "                _assert_occurrence(body, after, 'after')",
            "                out = []",
            "                lines = body.split(os.linesep)",
            "                for idx in range(len(lines)):",
            "                    _line = lines[idx]",
            "                    if _line.find(before) > -1 and idx <= len(lines) and lines[idx - 1].find(after) > -1:",
            "                        out.append(_get_line_indent(_line, content, indent))",
            "                        out.append(_line)",
            "                    else:",
            "                        out.append(_line)",
            "                body = os.linesep.join(out)",
            "",
            "            if before and not after:",
            "                _assert_occurrence(body, before, 'before')",
            "                out = []",
            "                lines = body.split(os.linesep)",
            "                for idx in range(len(lines)):",
            "                    _line = lines[idx]",
            "                    if _line.find(before) > -1:",
            "                        cnd = _get_line_indent(_line, content, indent)",
            "                        if not idx or (idx and _starts_till(lines[idx - 1], cnd) < 0):  # Job for replace instead",
            "                            out.append(cnd)",
            "                    out.append(_line)",
            "                body = os.linesep.join(out)",
            "",
            "            elif after and not before:",
            "                _assert_occurrence(body, after, 'after')",
            "                out = []",
            "                lines = body.split(os.linesep)",
            "                for idx in range(len(lines)):",
            "                    _line = lines[idx]",
            "                    out.append(_line)",
            "                    cnd = _get_line_indent(_line, content, indent)",
            "                    if _line.find(after) > -1:",
            "                        # No dupes or append, if \"after\" is the last line",
            "                        if (idx < len(lines) and _starts_till(lines[idx + 1], cnd) < 0) or idx + 1 == len(lines):",
            "                            out.append(cnd)",
            "                body = os.linesep.join(out)",
            "",
            "        else:",
            "            if location == 'start':",
            "                body = ''.join([content, body])",
            "            elif location == 'end':",
            "                body = ''.join([body, _get_line_indent(body[-1], content, indent) if body else content])",
            "",
            "    elif mode == 'ensure':",
            "        after = after and after.strip()",
            "        before = before and before.strip()",
            "",
            "        if before and after:",
            "            _assert_occurrence(body, before, 'before')",
            "            _assert_occurrence(body, after, 'after')",
            "",
            "            a_idx = b_idx = -1",
            "            idx = 0",
            "            body = body.split(os.linesep)",
            "            for _line in body:",
            "                idx += 1",
            "                if _line.find(before) > -1 and b_idx < 0:",
            "                    b_idx = idx",
            "                if _line.find(after) > -1 and a_idx < 0:",
            "                    a_idx = idx",
            "",
            "            # Add",
            "            if not b_idx - a_idx - 1:",
            "                body = body[:a_idx] + [content] + body[b_idx - 1:]",
            "            elif b_idx - a_idx - 1 == 1:",
            "                if _starts_till(body[a_idx:b_idx - 1][0], content) > -1:",
            "                    body[a_idx] = _get_line_indent(body[a_idx - 1], content, indent)",
            "            else:",
            "                raise CommandExecutionError('Found more than one line between boundaries \"before\" and \"after\".')",
            "            body = os.linesep.join(body)",
            "",
            "        elif before and not after:",
            "            _assert_occurrence(body, before, 'before')",
            "            body = body.split(os.linesep)",
            "            out = []",
            "            for idx in range(len(body)):",
            "                if body[idx].find(before) > -1:",
            "                    prev = (idx > 0 and idx or 1) - 1",
            "                    out.append(_get_line_indent(body[prev], content, indent))",
            "                    if _starts_till(out[prev], content) > -1:",
            "                        del out[prev]",
            "                out.append(body[idx])",
            "            body = os.linesep.join(out)",
            "",
            "        elif not before and after:",
            "            _assert_occurrence(body, after, 'after')",
            "            body = body.split(os.linesep)",
            "            skip = None",
            "            out = []",
            "            for idx in range(len(body)):",
            "                if skip != body[idx]:",
            "                    out.append(body[idx])",
            "",
            "                if body[idx].find(after) > -1:",
            "                    next_line = idx + 1 < len(body) and body[idx + 1] or None",
            "                    if next_line is not None and _starts_till(next_line, content) > -1:",
            "                        skip = next_line",
            "                    out.append(_get_line_indent(body[idx], content, indent))",
            "            body = os.linesep.join(out)",
            "",
            "        else:",
            "            raise CommandExecutionError(\"Wrong conditions? \"",
            "                                        \"Unable to ensure line without knowing \"",
            "                                        \"where to put it before and/or after.\")",
            "",
            "    changed = body_before != hashlib.sha256(salt.utils.to_bytes(body)).hexdigest()",
            "",
            "    if backup and changed and __opts__['test'] is False:",
            "        try:",
            "            temp_file = _mkstemp_copy(path=path, preserve_inode=True)",
            "            shutil.move(temp_file, '{0}.{1}'.format(path, time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime())))",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(\"Unable to create the backup file of {0}. Exception: {1}\".format(path, exc))",
            "",
            "    changes_diff = None",
            "",
            "    if changed:",
            "        if show_changes:",
            "            with salt.utils.fopen(path, 'r') as fp_:",
            "                path_content = _splitlines_preserving_trailing_newline(",
            "                    fp_.read())",
            "            changes_diff = ''.join(difflib.unified_diff(",
            "                path_content, _splitlines_preserving_trailing_newline(body)))",
            "        if __opts__['test'] is False:",
            "            fh_ = None",
            "            try:",
            "                fh_ = salt.utils.atomicfile.atomic_open(path, 'w')",
            "                fh_.write(body)",
            "            finally:",
            "                if fh_:",
            "                    fh_.close()",
            "",
            "    return show_changes and changes_diff or changed",
            "",
            "",
            "def replace(path,",
            "            pattern,",
            "            repl,",
            "            count=0,",
            "            flags=8,",
            "            bufsize=1,",
            "            append_if_not_found=False,",
            "            prepend_if_not_found=False,",
            "            not_found_content=None,",
            "            backup='.bak',",
            "            dry_run=False,",
            "            search_only=False,",
            "            show_changes=True,",
            "            ignore_if_missing=False,",
            "            preserve_inode=True,",
            "        ):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Replace occurrences of a pattern in a file. If ``show_changes`` is",
            "    ``True``, then a diff of what changed will be returned, otherwise a",
            "    ``True`` will be returned when changes are made, and ``False`` when",
            "    no changes are made.",
            "",
            "    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.",
            "",
            "    path",
            "        Filesystem path to the file to be edited. If a symlink is specified, it",
            "        will be resolved to its target.",
            "",
            "    pattern",
            "        A regular expression, to be matched using Python's",
            "        :py:func:`~re.search`.",
            "",
            "    repl",
            "        The replacement text",
            "",
            "    count : 0",
            "        Maximum number of pattern occurrences to be replaced. If count is a",
            "        positive integer ``n``, only ``n`` occurrences will be replaced,",
            "        otherwise all occurrences will be replaced.",
            "",
            "    flags (list or int)",
            "        A list of flags defined in the :ref:`re module documentation",
            "        <contents-of-module-re>`. Each list item should be a string that will",
            "        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',",
            "        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value",
            "        corresponding to the XOR (``|``) of all the desired flags. Defaults to",
            "        8 (which supports 'MULTILINE').",
            "",
            "    bufsize (int or str)",
            "        How much of the file to buffer into memory at once. The",
            "        default value ``1`` processes one line at a time. The special value",
            "        ``file`` may be specified which will read the entire file into memory",
            "        before processing.",
            "",
            "    append_if_not_found : False",
            "        .. versionadded:: 2014.7.0",
            "",
            "        If set to ``True``, and pattern is not found, then the content will be",
            "        appended to the file.",
            "",
            "    prepend_if_not_found : False",
            "        .. versionadded:: 2014.7.0",
            "",
            "        If set to ``True`` and pattern is not found, then the content will be",
            "        prepended to the file.",
            "",
            "    not_found_content",
            "        .. versionadded:: 2014.7.0",
            "",
            "        Content to use for append/prepend if not found. If None (default), uses",
            "        ``repl``. Useful when ``repl`` uses references to group in pattern.",
            "",
            "    backup : .bak",
            "        The file extension to use for a backup of the file before editing. Set",
            "        to ``False`` to skip making a backup.",
            "",
            "    dry_run : False",
            "        If set to ``True``, no changes will be made to the file, the function",
            "        will just return the changes that would have been made (or a",
            "        ``True``/``False`` value if ``show_changes`` is set to ``False``).",
            "",
            "    search_only : False",
            "        If set to true, this no changes will be performed on the file, and this",
            "        function will simply return ``True`` if the pattern was matched, and",
            "        ``False`` if not.",
            "",
            "    show_changes : True",
            "        If ``True``, return a diff of changes made. Otherwise, return ``True``",
            "        if changes were made, and ``False`` if not.",
            "",
            "        .. note::",
            "            Using this option will store two copies of the file in memory (the",
            "            original version and the edited version) in order to generate the",
            "            diff. This may not normally be a concern, but could impact",
            "            performance if used with large files.",
            "",
            "    ignore_if_missing : False",
            "        .. versionadded:: 2015.8.0",
            "",
            "        If set to ``True``, this function will simply return ``False``",
            "        if the file doesn't exist. Otherwise, an error will be thrown.",
            "",
            "    preserve_inode : True",
            "        .. versionadded:: 2015.8.0",
            "",
            "        Preserve the inode of the file, so that any hard links continue to",
            "        share the inode with the original filename. This works by *copying* the",
            "        file, reading from the copy, and writing to the file at the original",
            "        inode. If ``False``, the file will be *moved* rather than copied, and a",
            "        new file will be written to a new inode, but using the original",
            "        filename. Hard links will then share an inode with the backup, instead",
            "        (if using ``backup`` to create a backup copy).",
            "",
            "    If an equal sign (``=``) appears in an argument to a Salt command it is",
            "    interpreted as a keyword argument in the format ``key=val``. That",
            "    processing can be bypassed in order to pass an equal sign through to the",
            "    remote shell command by manually specifying the kwarg:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.replace /path/to/file pattern='=' repl=':'",
            "        salt '*' file.replace /path/to/file pattern=\"bind-address\\\\s*=\" repl='bind-address:'",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.replace /etc/httpd/httpd.conf pattern='LogLevel warn' repl='LogLevel info'",
            "        salt '*' file.replace /some/file pattern='before' repl='after' flags='[MULTILINE, IGNORECASE]'",
            "    '''",
            "    symlink = False",
            "    if is_link(path):",
            "        symlink = True",
            "        target_path = os.readlink(path)",
            "        given_path = os.path.expanduser(path)",
            "",
            "    path = os.path.realpath(os.path.expanduser(path))",
            "",
            "    if not os.path.exists(path):",
            "        if ignore_if_missing:",
            "            return False",
            "        else:",
            "            raise SaltInvocationError('File not found: {0}'.format(path))",
            "",
            "    if not salt.utils.istextfile(path):",
            "        raise SaltInvocationError(",
            "            'Cannot perform string replacements on a binary file: {0}'",
            "            .format(path)",
            "        )",
            "",
            "    if search_only and (append_if_not_found or prepend_if_not_found):",
            "        raise SaltInvocationError(",
            "            'search_only cannot be used with append/prepend_if_not_found'",
            "        )",
            "",
            "    if append_if_not_found and prepend_if_not_found:",
            "        raise SaltInvocationError(",
            "            'Only one of append and prepend_if_not_found is permitted'",
            "        )",
            "",
            "    flags_num = _get_flags(flags)",
            "    cpattern = re.compile(salt.utils.to_bytes(pattern), flags_num)",
            "    filesize = os.path.getsize(path)",
            "    if bufsize == 'file':",
            "        bufsize = filesize",
            "",
            "    # Search the file; track if any changes have been made for the return val",
            "    has_changes = False",
            "    orig_file = []  # used if show_changes",
            "    new_file = []  # used if show_changes",
            "    if not salt.utils.is_windows():",
            "        pre_user = get_user(path)",
            "        pre_group = get_group(path)",
            "        pre_mode = salt.utils.normalize_mode(get_mode(path))",
            "",
            "    # Avoid TypeErrors by forcing repl to be bytearray related to mmap",
            "    # Replacement text may contains integer: 123 for example",
            "    repl = salt.utils.to_bytes(str(repl))",
            "    if not_found_content:",
            "        not_found_content = salt.utils.to_bytes(not_found_content)",
            "",
            "    found = False",
            "    temp_file = None",
            "    content = salt.utils.to_str(not_found_content) if not_found_content and \\",
            "                                       (prepend_if_not_found or",
            "                                        append_if_not_found) \\",
            "                                     else salt.utils.to_str(repl)",
            "",
            "    try:",
            "        # First check the whole file, determine whether to make the replacement",
            "        # Searching first avoids modifying the time stamp if there are no changes",
            "        r_data = None",
            "        # Use a read-only handle to open the file",
            "        with salt.utils.fopen(path,",
            "                              mode='rb',",
            "                              buffering=bufsize) as r_file:",
            "            try:",
            "                # mmap throws a ValueError if the file is empty.",
            "                r_data = mmap.mmap(r_file.fileno(),",
            "                                   0,",
            "                                   access=mmap.ACCESS_READ)",
            "            except (ValueError, mmap.error):",
            "                # size of file in /proc is 0, but contains data",
            "                r_data = salt.utils.to_bytes(\"\".join(r_file))",
            "            if search_only:",
            "                # Just search; bail as early as a match is found",
            "                if re.search(cpattern, r_data):",
            "                    return True  # `with` block handles file closure",
            "            else:",
            "                result, nrepl = re.subn(cpattern, repl, r_data, count)",
            "",
            "                # found anything? (even if no change)",
            "                if nrepl > 0:",
            "                    found = True",
            "                    # Identity check the potential change",
            "                    has_changes = True if pattern != repl else has_changes",
            "",
            "                if prepend_if_not_found or append_if_not_found:",
            "                    # Search for content, to avoid pre/appending the",
            "                    # content if it was pre/appended in a previous run.",
            "                    if re.search(salt.utils.to_bytes('^{0}$'.format(re.escape(content))),",
            "                                 r_data,",
            "                                 flags=flags_num):",
            "                        # Content was found, so set found.",
            "                        found = True",
            "",
            "                # Keep track of show_changes here, in case the file isn't",
            "                # modified",
            "                if show_changes or append_if_not_found or \\",
            "                   prepend_if_not_found:",
            "                    orig_file = r_data.read(filesize).splitlines(True) \\",
            "                        if isinstance(r_data, mmap.mmap) \\",
            "                        else r_data.splitlines(True)",
            "                    new_file = result.splitlines(True)",
            "",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to open file '{0}'. \"",
            "            \"Exception: {1}\".format(path, exc)",
            "            )",
            "    finally:",
            "        if r_data and isinstance(r_data, mmap.mmap):",
            "            r_data.close()",
            "",
            "    if has_changes and not dry_run:",
            "        # Write the replacement text in this block.",
            "        try:",
            "            # Create a copy to read from and to use as a backup later",
            "            temp_file = _mkstemp_copy(path=path,",
            "                                      preserve_inode=preserve_inode)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "        r_data = None",
            "        try:",
            "            # Open the file in write mode",
            "            with salt.utils.fopen(path,",
            "                        mode='w',",
            "                        buffering=bufsize) as w_file:",
            "                try:",
            "                    # Open the temp file in read mode",
            "                    with salt.utils.fopen(temp_file,",
            "                                          mode='r',",
            "                                          buffering=bufsize) as r_file:",
            "                        r_data = mmap.mmap(r_file.fileno(),",
            "                                           0,",
            "                                           access=mmap.ACCESS_READ)",
            "                        result, nrepl = re.subn(cpattern, repl,",
            "                                                r_data, count)",
            "                        try:",
            "                            w_file.write(salt.utils.to_str(result))",
            "                        except (OSError, IOError) as exc:",
            "                            raise CommandExecutionError(",
            "                                \"Unable to write file '{0}'. Contents may \"",
            "                                \"be truncated. Temporary file contains copy \"",
            "                                \"at '{1}'. \"",
            "                                \"Exception: {2}\".format(path, temp_file, exc)",
            "                                )",
            "                except (OSError, IOError) as exc:",
            "                    raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "                finally:",
            "                    if r_data and isinstance(r_data, mmap.mmap):",
            "                        r_data.close()",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "",
            "    if not found and (append_if_not_found or prepend_if_not_found):",
            "        if not_found_content is None:",
            "            not_found_content = repl",
            "        if prepend_if_not_found:",
            "            new_file.insert(0, not_found_content + b'\\n')",
            "        else:",
            "            # append_if_not_found",
            "            # Make sure we have a newline at the end of the file",
            "            if 0 != len(new_file):",
            "                if not new_file[-1].endswith(b'\\n'):",
            "                    new_file[-1] += b'\\n'",
            "            new_file.append(not_found_content + b'\\n')",
            "        has_changes = True",
            "        if not dry_run:",
            "            try:",
            "                # Create a copy to read from and for later use as a backup",
            "                temp_file = _mkstemp_copy(path=path,",
            "                                          preserve_inode=preserve_inode)",
            "            except (OSError, IOError) as exc:",
            "                raise CommandExecutionError(\"Exception: {0}\".format(exc))",
            "            # write new content in the file while avoiding partial reads",
            "            try:",
            "                fh_ = salt.utils.atomicfile.atomic_open(path, 'w')",
            "                for line in new_file:",
            "                    fh_.write(salt.utils.to_str(line))",
            "            finally:",
            "                fh_.close()",
            "",
            "    if backup and has_changes and not dry_run:",
            "        # keep the backup only if it was requested",
            "        # and only if there were any changes",
            "        backup_name = '{0}{1}'.format(path, backup)",
            "        try:",
            "            shutil.move(temp_file, backup_name)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to move the temp file '{0}' to the \"",
            "                \"backup file '{1}'. \"",
            "                \"Exception: {2}\".format(path, temp_file, exc)",
            "                )",
            "        if symlink:",
            "            symlink_backup = '{0}{1}'.format(given_path, backup)",
            "            target_backup = '{0}{1}'.format(target_path, backup)",
            "            # Always clobber any existing symlink backup",
            "            # to match the behaviour of the 'backup' option",
            "            try:",
            "                os.symlink(target_backup, symlink_backup)",
            "            except OSError:",
            "                os.remove(symlink_backup)",
            "                os.symlink(target_backup, symlink_backup)",
            "            except:",
            "                raise CommandExecutionError(",
            "                    \"Unable create backup symlink '{0}'. \"",
            "                    \"Target was '{1}'. \"",
            "                    \"Exception: {2}\".format(symlink_backup, target_backup,",
            "                                            exc)",
            "                    )",
            "    elif temp_file:",
            "        try:",
            "            os.remove(temp_file)",
            "        except (OSError, IOError) as exc:",
            "            raise CommandExecutionError(",
            "                \"Unable to delete temp file '{0}'. \"",
            "                \"Exception: {1}\".format(temp_file, exc)",
            "                )",
            "",
            "    if not dry_run and not salt.utils.is_windows():",
            "        check_perms(path, None, pre_user, pre_group, pre_mode)",
            "",
            "    if show_changes:",
            "        orig_file_as_str = ''.join([salt.utils.to_str(x) for x in orig_file])",
            "        new_file_as_str = ''.join([salt.utils.to_str(x) for x in new_file])",
            "        return ''.join(difflib.unified_diff(orig_file_as_str, new_file_as_str))",
            "",
            "    return has_changes",
            "",
            "",
            "def blockreplace(path,",
            "        marker_start='#-- start managed zone --',",
            "        marker_end='#-- end managed zone --',",
            "        content='',",
            "        append_if_not_found=False,",
            "        prepend_if_not_found=False,",
            "        backup='.bak',",
            "        dry_run=False,",
            "        show_changes=True,",
            "        append_newline=False,",
            "        ):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Replace content of a text block in a file, delimited by line markers",
            "",
            "    A block of content delimited by comments can help you manage several lines",
            "    entries without worrying about old entries removal.",
            "",
            "    .. note::",
            "",
            "        This function will store two copies of the file in-memory (the original",
            "        version and the edited version) in order to detect changes and only",
            "        edit the targeted file if necessary.",
            "",
            "    path",
            "        Filesystem path to the file to be edited",
            "",
            "    marker_start",
            "        The line content identifying a line as the start of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output",
            "",
            "    marker_end",
            "        The line content identifying a line as the end of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output",
            "",
            "    content",
            "        The content to be used between the two lines identified by marker_start",
            "        and marker_stop.",
            "",
            "    append_if_not_found : False",
            "        If markers are not found and set to ``True`` then, the markers and",
            "        content will be appended to the file.",
            "",
            "    prepend_if_not_found : False",
            "        If markers are not found and set to ``True`` then, the markers and",
            "        content will be prepended to the file.",
            "",
            "",
            "    backup",
            "        The file extension to use for a backup of the file if any edit is made.",
            "        Set to ``False`` to skip making a backup.",
            "",
            "    dry_run",
            "        Don't make any edits to the file.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``,",
            "        return a boolean if any changes were made.",
            "",
            "    append_newline:",
            "        Append a newline to the content block. For more information see:",
            "        https://github.com/saltstack/salt/issues/33686",
            "",
            "        .. versionadded:: 2016.3.4",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.blockreplace /etc/hosts '#-- start managed zone foobar : DO NOT EDIT --' \\\\",
            "        '#-- end managed zone foobar --' $'10.0.1.1 foo.foobar\\\\n10.0.1.2 bar.foobar' True",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        raise SaltInvocationError('File not found: {0}'.format(path))",
            "",
            "    if append_if_not_found and prepend_if_not_found:",
            "        raise SaltInvocationError(",
            "            'Only one of append and prepend_if_not_found is permitted'",
            "        )",
            "",
            "    if not salt.utils.istextfile(path):",
            "        raise SaltInvocationError(",
            "            'Cannot perform string replacements on a binary file: {0}'",
            "            .format(path)",
            "        )",
            "",
            "    # Search the file; track if any changes have been made for the return val",
            "    has_changes = False",
            "    orig_file = []",
            "    new_file = []",
            "    in_block = False",
            "    old_content = ''",
            "    done = False",
            "    # we do not use in_place editing to avoid file attrs modifications when",
            "    # no changes are required and to avoid any file access on a partially",
            "    # written file.",
            "    # we could also use salt.utils.filebuffer.BufferedReader",
            "    try:",
            "        fi_file = fileinput.input(path,",
            "                    inplace=False, backup=False,",
            "                    bufsize=1, mode='r')",
            "        for line in fi_file:",
            "",
            "            result = line",
            "",
            "            if marker_start in line:",
            "                # managed block start found, start recording",
            "                in_block = True",
            "",
            "            else:",
            "                if in_block:",
            "                    if marker_end in line:",
            "                        # end of block detected",
            "                        in_block = False",
            "",
            "                        # Check for multi-line '\\n' terminated content as split will",
            "                        # introduce an unwanted additional new line.",
            "                        if content and content[-1] == '\\n':",
            "                            content = content[:-1]",
            "",
            "                        # push new block content in file",
            "                        for cline in content.split('\\n'):",
            "                            new_file.append(cline + '\\n')",
            "",
            "                        done = True",
            "",
            "                    else:",
            "                        # remove old content, but keep a trace",
            "                        old_content += line",
            "                        result = None",
            "            # else: we are not in the marked block, keep saving things",
            "",
            "            orig_file.append(line)",
            "            if result is not None:",
            "                new_file.append(result)",
            "        # end for. If we are here without block management we maybe have some problems,",
            "        # or we need to initialise the marked block",
            "",
            "    finally:",
            "        fi_file.close()",
            "",
            "    if in_block:",
            "        # unterminated block => bad, always fail",
            "        raise CommandExecutionError(",
            "            'Unterminated marked block. End of file reached before marker_end.'",
            "        )",
            "",
            "    if not done:",
            "        if prepend_if_not_found:",
            "            # add the markers and content at the beginning of file",
            "            new_file.insert(0, marker_end + '\\n')",
            "            if append_newline is True:",
            "                new_file.insert(0, content + '\\n')",
            "            else:",
            "                new_file.insert(0, content)",
            "            new_file.insert(0, marker_start + '\\n')",
            "            done = True",
            "        elif append_if_not_found:",
            "            # Make sure we have a newline at the end of the file",
            "            if 0 != len(new_file):",
            "                if not new_file[-1].endswith('\\n'):",
            "                    new_file[-1] += '\\n'",
            "            # add the markers and content at the end of file",
            "            new_file.append(marker_start + '\\n')",
            "            if append_newline is True:",
            "                new_file.append(content + '\\n')",
            "            else:",
            "                new_file.append(content)",
            "            new_file.append(marker_end + '\\n')",
            "            done = True",
            "        else:",
            "            raise CommandExecutionError(",
            "                'Cannot edit marked block. Markers were not found in file.'",
            "            )",
            "",
            "    if done:",
            "        diff = ''.join(difflib.unified_diff(orig_file, new_file))",
            "        has_changes = diff is not ''",
            "        if has_changes and not dry_run:",
            "            # changes detected",
            "            # backup file attrs",
            "            perms = {}",
            "            perms['user'] = get_user(path)",
            "            perms['group'] = get_group(path)",
            "            perms['mode'] = salt.utils.normalize_mode(get_mode(path))",
            "",
            "            # backup old content",
            "            if backup is not False:",
            "                backup_path = '{0}{1}'.format(path, backup)",
            "                shutil.copy2(path, backup_path)",
            "                # copy2 does not preserve ownership",
            "                check_perms(backup_path,",
            "                        None,",
            "                        perms['user'],",
            "                        perms['group'],",
            "                        perms['mode'])",
            "",
            "            # write new content in the file while avoiding partial reads",
            "            try:",
            "                fh_ = salt.utils.atomicfile.atomic_open(path, 'w')",
            "                for line in new_file:",
            "                    fh_.write(line)",
            "            finally:",
            "                fh_.close()",
            "",
            "            # this may have overwritten file attrs",
            "            check_perms(path,",
            "                    None,",
            "                    perms['user'],",
            "                    perms['group'],",
            "                    perms['mode'])",
            "",
            "        if show_changes:",
            "            return diff",
            "",
            "    return has_changes",
            "",
            "",
            "def search(path,",
            "        pattern,",
            "        flags=8,",
            "        bufsize=1,",
            "        ignore_if_missing=False,",
            "        multiline=False",
            "        ):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Search for occurrences of a pattern in a file",
            "",
            "    Except for multiline, params are identical to",
            "    :py:func:`~salt.modules.file.replace`.",
            "",
            "    multiline",
            "        If true, inserts 'MULTILINE' into ``flags`` and sets ``bufsize`` to",
            "        'file'.",
            "",
            "        .. versionadded:: 2015.8.0",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.search /etc/crontab 'mymaintenance.sh'",
            "    '''",
            "    if multiline:",
            "        flags = _add_flags(flags, 'MULTILINE')",
            "        bufsize = 'file'",
            "",
            "    # This function wraps file.replace on purpose in order to enforce",
            "    # consistent usage, compatible regex's, expected behavior, *and* bugs. :)",
            "    # Any enhancements or fixes to one should affect the other.",
            "    return replace(path,",
            "            pattern,",
            "            '',",
            "            flags=flags,",
            "            bufsize=bufsize,",
            "            dry_run=True,",
            "            search_only=True,",
            "            show_changes=False,",
            "            ignore_if_missing=ignore_if_missing)",
            "",
            "",
            "def patch(originalfile, patchfile, options='', dry_run=False):",
            "    '''",
            "    .. versionadded:: 0.10.4",
            "",
            "    Apply a patch to a file or directory.",
            "",
            "    Equivalent to:",
            "",
            "    .. code-block:: bash",
            "",
            "        patch <options> -i <patchfile> <originalfile>",
            "",
            "    Or, when a directory is patched:",
            "",
            "    .. code-block:: bash",
            "",
            "        patch <options> -i <patchfile> -d <originalfile> -p0",
            "",
            "    originalfile",
            "        The full path to the file or directory to be patched",
            "    patchfile",
            "        A patch file to apply to ``originalfile``",
            "    options",
            "        Options to pass to patch.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.patch /opt/file.txt /tmp/file.txt.patch",
            "    '''",
            "    patchpath = salt.utils.which('patch')",
            "    if not patchpath:",
            "        raise CommandExecutionError(",
            "            'patch executable not found. Is the distribution\\'s patch '",
            "            'package installed?'",
            "        )",
            "",
            "    cmd = [patchpath]",
            "    cmd.extend(salt.utils.shlex_split(options))",
            "    if dry_run:",
            "        if __grains__['kernel'] in ('FreeBSD', 'OpenBSD'):",
            "            cmd.append('-C')",
            "        else:",
            "            cmd.append('--dry-run')",
            "",
            "    # this argument prevents interactive prompts when the patch fails to apply.",
            "    # the exit code will still be greater than 0 if that is the case.",
            "    if '-N' not in cmd and '--forward' not in cmd:",
            "        cmd.append('--forward')",
            "",
            "    has_rejectfile_option = False",
            "    for option in cmd:",
            "        if option == '-r' or option.startswith('-r ') \\",
            "                or option.startswith('--reject-file'):",
            "            has_rejectfile_option = True",
            "            break",
            "",
            "    # by default, patch will write rejected patch files to <filename>.rej.",
            "    # this option prevents that.",
            "    if not has_rejectfile_option:",
            "        cmd.append('--reject-file=-')",
            "",
            "    cmd.extend(['-i', patchfile])",
            "",
            "    if os.path.isdir(originalfile):",
            "        cmd.extend(['-d', originalfile])",
            "",
            "        has_strip_option = False",
            "        for option in cmd:",
            "            if option.startswith('-p') or option.startswith('--strip='):",
            "                has_strip_option = True",
            "                break",
            "",
            "        if not has_strip_option:",
            "            cmd.append('--strip=0')",
            "    else:",
            "        cmd.append(originalfile)",
            "",
            "    return __salt__['cmd.run_all'](cmd, python_shell=False)",
            "",
            "",
            "def contains(path, text):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return ``True`` if the file at ``path`` contains ``text``",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains /etc/crontab 'mymaintenance.sh'",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    stripped_text = str(text).strip()",
            "    try:",
            "        with salt.utils.filebuffer.BufferedReader(path) as breader:",
            "            for chunk in breader:",
            "                if stripped_text in chunk:",
            "                    return True",
            "        return False",
            "    except (IOError, OSError):",
            "        return False",
            "",
            "",
            "def contains_regex(path, regex, lchar=''):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return True if the given regular expression matches on any line in the text",
            "    of a given file.",
            "",
            "    If the lchar argument (leading char) is specified, it",
            "    will strip `lchar` from the left side of each line before trying to match",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains_regex /etc/crontab",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    try:",
            "        with salt.utils.fopen(path, 'r') as target:",
            "            for line in target:",
            "                if lchar:",
            "                    line = line.lstrip(lchar)",
            "                if re.search(regex, line):",
            "                    return True",
            "            return False",
            "    except (IOError, OSError):",
            "        return False",
            "",
            "",
            "def contains_glob(path, glob_expr):",
            "    '''",
            "    .. deprecated:: 0.17.0",
            "       Use :func:`search` instead.",
            "",
            "    Return ``True`` if the given glob matches a string in the named file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.contains_glob /etc/foobar '*cheese*'",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.exists(path):",
            "        return False",
            "",
            "    try:",
            "        with salt.utils.filebuffer.BufferedReader(path) as breader:",
            "            for chunk in breader:",
            "                if fnmatch.fnmatch(chunk, glob_expr):",
            "                    return True",
            "            return False",
            "    except (IOError, OSError):",
            "        return False",
            "",
            "",
            "def append(path, *args, **kwargs):",
            "    '''",
            "    .. versionadded:: 0.9.5",
            "",
            "    Append text to the end of a file",
            "",
            "    path",
            "        path to file",
            "",
            "    `*args`",
            "        strings to append to file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.append /etc/motd \\\\",
            "                \"With all thine offerings thou shalt offer salt.\" \\\\",
            "                \"Salt is what makes things taste bad when it isn't in them.\"",
            "",
            "    .. admonition:: Attention",
            "",
            "        If you need to pass a string to append and that string contains",
            "        an equal sign, you **must** include the argument name, args.",
            "        For example:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.append /etc/motd args='cheese=spam'",
            "",
            "            salt '*' file.append /etc/motd args=\"['cheese=spam','spam=cheese']\"",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    # Largely inspired by Fabric's contrib.files.append()",
            "",
            "    if 'args' in kwargs:",
            "        if isinstance(kwargs['args'], list):",
            "            args = kwargs['args']",
            "        else:",
            "            args = [kwargs['args']]",
            "",
            "    # Make sure we have a newline at the end of the file. Do this in binary",
            "    # mode so SEEK_END with nonzero offset will work.",
            "    with salt.utils.fopen(path, 'rb+') as ofile:",
            "        linesep = salt.utils.to_bytes(os.linesep)",
            "        try:",
            "            ofile.seek(-len(linesep), os.SEEK_END)",
            "        except IOError as exc:",
            "            if exc.errno in (errno.EINVAL, errno.ESPIPE):",
            "                # Empty file, simply append lines at the beginning of the file",
            "                pass",
            "            else:",
            "                raise",
            "        else:",
            "            if ofile.read(len(linesep)) != linesep:",
            "                ofile.seek(0, os.SEEK_END)",
            "                ofile.write(linesep)",
            "",
            "    # Append lines in text mode",
            "    with salt.utils.fopen(path, 'a') as ofile:",
            "        for new_line in args:",
            "            ofile.write('{0}{1}'.format(new_line, os.linesep))",
            "",
            "    return 'Wrote {0} lines to \"{1}\"'.format(len(args), path)",
            "",
            "",
            "def prepend(path, *args, **kwargs):",
            "    '''",
            "    .. versionadded:: 2014.7.0",
            "",
            "    Prepend text to the beginning of a file",
            "",
            "    path",
            "        path to file",
            "",
            "    `*args`",
            "        strings to prepend to the file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.prepend /etc/motd \\\\",
            "                \"With all thine offerings thou shalt offer salt.\" \\\\",
            "                \"Salt is what makes things taste bad when it isn't in them.\"",
            "",
            "    .. admonition:: Attention",
            "",
            "        If you need to pass a string to append and that string contains",
            "        an equal sign, you **must** include the argument name, args.",
            "        For example:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.prepend /etc/motd args='cheese=spam'",
            "",
            "            salt '*' file.prepend /etc/motd args=\"['cheese=spam','spam=cheese']\"",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if 'args' in kwargs:",
            "        if isinstance(kwargs['args'], list):",
            "            args = kwargs['args']",
            "        else:",
            "            args = [kwargs['args']]",
            "",
            "    try:",
            "        with salt.utils.fopen(path) as fhr:",
            "            contents = fhr.readlines()",
            "    except IOError:",
            "        contents = []",
            "",
            "    preface = []",
            "    for line in args:",
            "        preface.append('{0}\\n'.format(line))",
            "",
            "    with salt.utils.fopen(path, \"w\") as ofile:",
            "        contents = preface + contents",
            "        ofile.write(''.join(contents))",
            "    return 'Prepended {0} lines to \"{1}\"'.format(len(args), path)",
            "",
            "",
            "def write(path, *args, **kwargs):",
            "    '''",
            "    .. versionadded:: 2014.7.0",
            "",
            "    Write text to a file, overwriting any existing contents.",
            "",
            "    path",
            "        path to file",
            "",
            "    `*args`",
            "        strings to write to the file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.write /etc/motd \\\\",
            "                \"With all thine offerings thou shalt offer salt.\"",
            "",
            "    .. admonition:: Attention",
            "",
            "        If you need to pass a string to append and that string contains",
            "        an equal sign, you **must** include the argument name, args.",
            "        For example:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' file.write /etc/motd args='cheese=spam'",
            "",
            "            salt '*' file.write /etc/motd args=\"['cheese=spam','spam=cheese']\"",
            "",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if 'args' in kwargs:",
            "        if isinstance(kwargs['args'], list):",
            "            args = kwargs['args']",
            "        else:",
            "            args = [kwargs['args']]",
            "",
            "    contents = []",
            "    for line in args:",
            "        contents.append('{0}\\n'.format(line))",
            "    with salt.utils.fopen(path, \"w\") as ofile:",
            "        ofile.write(''.join(contents))",
            "    return 'Wrote {0} lines to \"{1}\"'.format(len(contents), path)",
            "",
            "",
            "def touch(name, atime=None, mtime=None):",
            "    '''",
            "    .. versionadded:: 0.9.5",
            "",
            "    Just like the ``touch`` command, create a file if it doesn't exist or",
            "    simply update the atime and mtime if it already does.",
            "",
            "    atime:",
            "        Access time in Unix epoch time",
            "    mtime:",
            "        Last modification in Unix epoch time",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.touch /var/log/emptyfile",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if atime and atime.isdigit():",
            "        atime = int(atime)",
            "    if mtime and mtime.isdigit():",
            "        mtime = int(mtime)",
            "    try:",
            "        if not os.path.exists(name):",
            "            with salt.utils.fopen(name, 'a') as fhw:",
            "                fhw.write('')",
            "",
            "        if not atime and not mtime:",
            "            times = None",
            "        elif not mtime and atime:",
            "            times = (atime, time.time())",
            "        elif not atime and mtime:",
            "            times = (time.time(), mtime)",
            "        else:",
            "            times = (atime, mtime)",
            "        os.utime(name, times)",
            "",
            "    except TypeError:",
            "        raise SaltInvocationError('atime and mtime must be integers')",
            "    except (IOError, OSError) as exc:",
            "        raise CommandExecutionError(exc.strerror)",
            "",
            "    return os.path.exists(name)",
            "",
            "",
            "def seek_read(path, size, offset):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Seek to a position on a file and read it",
            "",
            "    path",
            "        path to file",
            "",
            "    seek",
            "        amount to read at once",
            "",
            "    offset",
            "        offset to start into the file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.seek_read /path/to/file 4096 0",
            "    '''",
            "    path = os.path.expanduser(path)",
            "    try:",
            "        seek_fh = os.open(path, os.O_RDONLY)",
            "        os.lseek(seek_fh, int(offset), 0)",
            "        data = os.read(seek_fh, int(size))",
            "    finally:",
            "        os.close(seek_fh)",
            "    return data",
            "",
            "",
            "def seek_write(path, data, offset):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Seek to a position on a file and write to it",
            "",
            "    path",
            "        path to file",
            "",
            "    data",
            "        data to write to file",
            "",
            "    offset",
            "        position in file to start writing",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.seek_write /path/to/file 'some data' 4096",
            "    '''",
            "    path = os.path.expanduser(path)",
            "    try:",
            "        seek_fh = os.open(path, os.O_WRONLY)",
            "        os.lseek(seek_fh, int(offset), 0)",
            "        ret = os.write(seek_fh, data)",
            "        os.fsync(seek_fh)",
            "    finally:",
            "        os.close(seek_fh)",
            "    return ret",
            "",
            "",
            "def truncate(path, length):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Seek to a position on a file and delete everything after that point",
            "",
            "    path",
            "        path to file",
            "",
            "    length",
            "        offset into file to truncate",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.truncate /path/to/file 512",
            "    '''",
            "    path = os.path.expanduser(path)",
            "    with salt.utils.fopen(path, 'rb+') as seek_fh:",
            "        seek_fh.truncate(int(length))",
            "",
            "",
            "def link(src, path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Create a hard link to a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.link /path/to/file /path/to/link",
            "    '''",
            "    src = os.path.expanduser(src)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        os.link(src, path)",
            "        return True",
            "    except (OSError, IOError):",
            "        raise CommandExecutionError('Could not create \\'{0}\\''.format(path))",
            "    return False",
            "",
            "",
            "def is_link(path):",
            "    '''",
            "    Check if the path is a symbolic link",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_link /path/to/link",
            "    '''",
            "    # This function exists because os.path.islink does not support Windows,",
            "    # therefore a custom function will need to be called. This function",
            "    # therefore helps API consistency by providing a single function to call for",
            "    # both operating systems.",
            "",
            "    return os.path.islink(os.path.expanduser(path))",
            "",
            "",
            "def symlink(src, path):",
            "    '''",
            "    Create a symbolic link (symlink, soft link) to a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.symlink /path/to/file /path/to/link",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        os.symlink(src, path)",
            "        return True",
            "    except (OSError, IOError):",
            "        raise CommandExecutionError('Could not create \\'{0}\\''.format(path))",
            "    return False",
            "",
            "",
            "def rename(src, dst):",
            "    '''",
            "    Rename a file or directory",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.rename /path/to/src /path/to/dst",
            "    '''",
            "    src = os.path.expanduser(src)",
            "    dst = os.path.expanduser(dst)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        os.rename(src, dst)",
            "        return True",
            "    except OSError:",
            "        raise CommandExecutionError(",
            "            'Could not rename \\'{0}\\' to \\'{1}\\''.format(src, dst)",
            "        )",
            "    return False",
            "",
            "",
            "def copy(src, dst, recurse=False, remove_existing=False):",
            "    '''",
            "    Copy a file or directory from source to dst",
            "",
            "    In order to copy a directory, the recurse flag is required, and",
            "    will by default overwrite files in the destination with the same path,",
            "    and retain all other existing files. (similar to cp -r on unix)",
            "",
            "    remove_existing will remove all files in the target directory,",
            "    and then copy files from the source.",
            "",
            "    .. note::",
            "        The copy function accepts paths that are local to the Salt minion.",
            "        This function does not support salt://, http://, or the other",
            "        additional file paths that are supported by :mod:`states.file.managed",
            "        <salt.states.file.managed>` and :mod:`states.file.recurse",
            "        <salt.states.file.recurse>`.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.copy /path/to/src /path/to/dst",
            "        salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True",
            "        salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True remove_existing=True",
            "",
            "    '''",
            "    src = os.path.expanduser(src)",
            "    dst = os.path.expanduser(dst)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    if not os.path.exists(src):",
            "        raise CommandExecutionError('No such file or directory \\'{0}\\''.format(src))",
            "",
            "    if not salt.utils.is_windows():",
            "        pre_user = get_user(src)",
            "        pre_group = get_group(src)",
            "        pre_mode = salt.utils.normalize_mode(get_mode(src))",
            "",
            "    try:",
            "        if (os.path.exists(dst) and os.path.isdir(dst)) or os.path.isdir(src):",
            "            if not recurse:",
            "                raise SaltInvocationError(",
            "                    \"Cannot copy overwriting a directory without recurse flag set to true!\")",
            "            if remove_existing:",
            "                if os.path.exists(dst):",
            "                    shutil.rmtree(dst)",
            "                shutil.copytree(src, dst)",
            "            else:",
            "                salt.utils.files.recursive_copy(src, dst)",
            "        else:",
            "            shutil.copyfile(src, dst)",
            "    except OSError:",
            "        raise CommandExecutionError(",
            "            'Could not copy \\'{0}\\' to \\'{1}\\''.format(src, dst)",
            "        )",
            "",
            "    if not salt.utils.is_windows():",
            "        check_perms(dst, None, pre_user, pre_group, pre_mode)",
            "    return True",
            "",
            "",
            "def lstat(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Returns the lstat attributes for the given file or dir. Does not support",
            "    symbolic links.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.lstat /path/to/file",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Path to file must be absolute.')",
            "",
            "    try:",
            "        lst = os.lstat(path)",
            "        return dict((key, getattr(lst, key)) for key in ('st_atime', 'st_ctime',",
            "            'st_gid', 'st_mode', 'st_mtime', 'st_nlink', 'st_size', 'st_uid'))",
            "    except Exception:",
            "        return {}",
            "",
            "",
            "def access(path, mode):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Test whether the Salt process has the specified access to the file. One of",
            "    the following modes must be specified:",
            "",
            "    .. code-block::text",
            "",
            "        f: Test the existence of the path",
            "        r: Test the readability of the path",
            "        w: Test the writability of the path",
            "        x: Test whether the path can be executed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.access /path/to/file f",
            "        salt '*' file.access /path/to/file x",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Path to link must be absolute.')",
            "",
            "    modes = {'f': os.F_OK,",
            "             'r': os.R_OK,",
            "             'w': os.W_OK,",
            "             'x': os.X_OK}",
            "",
            "    if mode in modes:",
            "        return os.access(path, modes[mode])",
            "    elif mode in six.itervalues(modes):",
            "        return os.access(path, mode)",
            "    else:",
            "        raise SaltInvocationError('Invalid mode specified.')",
            "",
            "",
            "def readlink(path, canonicalize=False):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Return the path that a symlink points to",
            "    If canonicalize is set to True, then it return the final target",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.readlink /path/to/link",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Path to link must be absolute.')",
            "",
            "    if not os.path.islink(path):",
            "        raise SaltInvocationError('A valid link was not specified.')",
            "",
            "    if canonicalize:",
            "        return os.path.realpath(path)",
            "    else:",
            "        return os.readlink(path)",
            "",
            "",
            "def readdir(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Return a list containing the contents of a directory",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.readdir /path/to/dir/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('Dir path must be absolute.')",
            "",
            "    if not os.path.isdir(path):",
            "        raise SaltInvocationError('A valid directory was not specified.')",
            "",
            "    dirents = ['.', '..']",
            "    dirents.extend(os.listdir(path))",
            "    return dirents",
            "",
            "",
            "def statvfs(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Perform a statvfs call against the filesystem that the file resides on",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.statvfs /path/to/file",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    try:",
            "        stv = os.statvfs(path)",
            "        return dict((key, getattr(stv, key)) for key in ('f_bavail', 'f_bfree',",
            "            'f_blocks', 'f_bsize', 'f_favail', 'f_ffree', 'f_files', 'f_flag',",
            "            'f_frsize', 'f_namemax'))",
            "    except (OSError, IOError):",
            "        raise CommandExecutionError('Could not statvfs \\'{0}\\''.format(path))",
            "    return False",
            "",
            "",
            "def stats(path, hash_type=None, follow_symlinks=True):",
            "    '''",
            "    Return a dict containing the stats for a given file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.stats /etc/passwd",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    ret = {}",
            "    if not os.path.exists(path):",
            "        try:",
            "            # Broken symlinks will return False for os.path.exists(), but still",
            "            # have a uid and gid",
            "            pstat = os.lstat(path)",
            "        except OSError:",
            "            # Not a broken symlink, just a nonexistent path",
            "            return ret",
            "    else:",
            "        if follow_symlinks:",
            "            pstat = os.stat(path)",
            "        else:",
            "            pstat = os.lstat(path)",
            "    ret['inode'] = pstat.st_ino",
            "    ret['uid'] = pstat.st_uid",
            "    ret['gid'] = pstat.st_gid",
            "    ret['group'] = gid_to_group(pstat.st_gid)",
            "    ret['user'] = uid_to_user(pstat.st_uid)",
            "    ret['atime'] = pstat.st_atime",
            "    ret['mtime'] = pstat.st_mtime",
            "    ret['ctime'] = pstat.st_ctime",
            "    ret['size'] = pstat.st_size",
            "    ret['mode'] = str(oct(stat.S_IMODE(pstat.st_mode)))",
            "    if hash_type:",
            "        ret['sum'] = get_hash(path, hash_type)",
            "    ret['type'] = 'file'",
            "    if stat.S_ISDIR(pstat.st_mode):",
            "        ret['type'] = 'dir'",
            "    if stat.S_ISCHR(pstat.st_mode):",
            "        ret['type'] = 'char'",
            "    if stat.S_ISBLK(pstat.st_mode):",
            "        ret['type'] = 'block'",
            "    if stat.S_ISREG(pstat.st_mode):",
            "        ret['type'] = 'file'",
            "    if stat.S_ISLNK(pstat.st_mode):",
            "        ret['type'] = 'link'",
            "    if stat.S_ISFIFO(pstat.st_mode):",
            "        ret['type'] = 'pipe'",
            "    if stat.S_ISSOCK(pstat.st_mode):",
            "        ret['type'] = 'socket'",
            "    ret['target'] = os.path.realpath(path)",
            "    return ret",
            "",
            "",
            "def rmdir(path):",
            "    '''",
            "    .. versionadded:: 2014.1.0",
            "",
            "    Remove the specified directory. Fails if a directory is not empty.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.rmdir /tmp/foo/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute.')",
            "",
            "    if not os.path.isdir(path):",
            "        raise SaltInvocationError('A valid directory was not specified.')",
            "",
            "    try:",
            "        os.rmdir(path)",
            "        return True",
            "    except OSError as exc:",
            "        return exc.strerror",
            "",
            "",
            "def remove(path):",
            "    '''",
            "    Remove the named file. If a directory is supplied, it will be recursively",
            "    deleted.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.remove /tmp/foo",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    if not os.path.isabs(path):",
            "        raise SaltInvocationError('File path must be absolute: {0}'.format(path))",
            "",
            "    try:",
            "        if os.path.isfile(path) or os.path.islink(path):",
            "            os.remove(path)",
            "            return True",
            "        elif os.path.isdir(path):",
            "            shutil.rmtree(path)",
            "            return True",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            'Could not remove \\'{0}\\': {1}'.format(path, exc)",
            "        )",
            "    return False",
            "",
            "",
            "def directory_exists(path):",
            "    '''",
            "    Tests to see if path is a valid directory.  Returns True/False.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.directory_exists /etc",
            "",
            "    '''",
            "    return os.path.isdir(os.path.expanduser(path))",
            "",
            "",
            "def file_exists(path):",
            "    '''",
            "    Tests to see if path is a valid file.  Returns True/False.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.file_exists /etc/passwd",
            "",
            "    '''",
            "    return os.path.isfile(os.path.expanduser(path))",
            "",
            "",
            "def path_exists_glob(path):",
            "    '''",
            "    Tests to see if path after expansion is a valid path (file or directory).",
            "    Expansion allows usage of ? * and character ranges []. Tilde expansion",
            "    is not supported. Returns True/False.",
            "",
            "    .. versionadded:: Hellium",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.path_exists_glob /etc/pam*/pass*",
            "",
            "    '''",
            "    return True if glob.glob(os.path.expanduser(path)) else False",
            "",
            "",
            "def restorecon(path, recursive=False):",
            "    '''",
            "    Reset the SELinux context on a given path",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "         salt '*' file.restorecon /home/user/.ssh/authorized_keys",
            "    '''",
            "    if recursive:",
            "        cmd = ['restorecon', '-FR', path]",
            "    else:",
            "        cmd = ['restorecon', '-F', path]",
            "    return not __salt__['cmd.retcode'](cmd, python_shell=False)",
            "",
            "",
            "def get_selinux_context(path):",
            "    '''",
            "    Get an SELinux context from a given path",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_selinux_context /etc/hosts",
            "    '''",
            "    out = __salt__['cmd.run'](['ls', '-Z', path], python_shell=False)",
            "",
            "    try:",
            "        ret = re.search(r'\\w+:\\w+:\\w+:\\w+', out).group(0)",
            "    except AttributeError:",
            "        ret = (",
            "            'No selinux context information is available for {0}'.format(path)",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def set_selinux_context(path,",
            "                        user=None,",
            "                        role=None,",
            "                        type=None,    # pylint: disable=W0622",
            "                        range=None):  # pylint: disable=W0622",
            "    '''",
            "    Set a specific SELinux label on a given path",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.set_selinux_context path <role> <type> <range>",
            "    '''",
            "    if not any((user, role, type, range)):",
            "        return False",
            "",
            "    cmd = ['chcon']",
            "    if user:",
            "        cmd.extend(['-u', user])",
            "    if role:",
            "        cmd.extend(['-r', role])",
            "    if type:",
            "        cmd.extend(['-t', type])",
            "    if range:",
            "        cmd.extend(['-l', range])",
            "    cmd.append(path)",
            "",
            "    ret = not __salt__['cmd.retcode'](cmd, python_shell=False)",
            "    if ret:",
            "        return get_selinux_context(path)",
            "    else:",
            "        return ret",
            "",
            "",
            "def source_list(source, source_hash, saltenv):",
            "    '''",
            "    Check the source list and return the source to use",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.source_list salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' base",
            "    '''",
            "    contextkey = '{0}_|-{1}_|-{2}'.format(source, source_hash, saltenv)",
            "    if contextkey in __context__:",
            "        return __context__[contextkey]",
            "",
            "    # get the master file list",
            "    if isinstance(source, list):",
            "        mfiles = [(f, saltenv) for f in __salt__['cp.list_master'](saltenv)]",
            "        mdirs = [(d, saltenv) for d in __salt__['cp.list_master_dirs'](saltenv)]",
            "        for single in source:",
            "            if isinstance(single, dict):",
            "                single = next(iter(single))",
            "",
            "            path, senv = salt.utils.url.parse(single)",
            "            if senv:",
            "                mfiles += [(f, senv) for f in __salt__['cp.list_master'](senv)]",
            "                mdirs += [(d, senv) for d in __salt__['cp.list_master_dirs'](senv)]",
            "",
            "        ret = None",
            "        for single in source:",
            "            if isinstance(single, dict):",
            "                # check the proto, if it is http or ftp then download the file",
            "                # to check, if it is salt then check the master list",
            "                # if it is a local file, check if the file exists",
            "                if len(single) != 1:",
            "                    continue",
            "                single_src = next(iter(single))",
            "                single_hash = single[single_src] if single[single_src] else source_hash",
            "                urlparsed_single_src = _urlparse(single_src)",
            "                proto = urlparsed_single_src.scheme",
            "                if proto == 'salt':",
            "                    path, senv = salt.utils.url.parse(single_src)",
            "                    if not senv:",
            "                        senv = saltenv",
            "                    if (path, saltenv) in mfiles or (path, saltenv) in mdirs:",
            "                        ret = (single_src, single_hash)",
            "                        break",
            "                elif proto.startswith('http') or proto == 'ftp':",
            "                    try:",
            "                        if __salt__['cp.cache_file'](single_src):",
            "                            ret = (single_src, single_hash)",
            "                            break",
            "                    except MinionError as exc:",
            "                        # Error downloading file. Log the caught exception and",
            "                        # continue on to the next source.",
            "                        log.exception(exc)",
            "                elif proto == 'file' and os.path.exists(urlparsed_single_src.path):",
            "                    ret = (single_src, single_hash)",
            "                    break",
            "                elif single_src.startswith('/') and os.path.exists(single_src):",
            "                    ret = (single_src, single_hash)",
            "                    break",
            "            elif isinstance(single, six.string_types):",
            "                path, senv = salt.utils.url.parse(single)",
            "                if not senv:",
            "                    senv = saltenv",
            "                if (path, senv) in mfiles or (path, senv) in mdirs:",
            "                    ret = (single, source_hash)",
            "                    break",
            "                urlparsed_src = _urlparse(single)",
            "                proto = urlparsed_src.scheme",
            "                if proto == 'file' and os.path.exists(urlparsed_src.path):",
            "                    ret = (single, source_hash)",
            "                    break",
            "                elif proto.startswith('http') or proto == 'ftp':",
            "                    if __salt__['cp.cache_file'](single):",
            "                        ret = (single, source_hash)",
            "                        break",
            "                elif single.startswith('/') and os.path.exists(single):",
            "                    ret = (single, source_hash)",
            "                    break",
            "        if ret is None:",
            "            # None of the list items matched",
            "            raise CommandExecutionError(",
            "                'none of the specified sources were found'",
            "            )",
            "    else:",
            "        ret = (source, source_hash)",
            "",
            "    __context__[contextkey] = ret",
            "    return ret",
            "",
            "",
            "def apply_template_on_contents(",
            "        contents,",
            "        template,",
            "        context,",
            "        defaults,",
            "        saltenv):",
            "    '''",
            "    Return the contents after applying the templating engine",
            "",
            "    contents",
            "        template string",
            "",
            "    template",
            "        template format",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.apply_template_on_contents \\\\",
            "            contents='This is a {{ template }} string.' \\\\",
            "            template=jinja \\\\",
            "            \"context={}\" \"defaults={'template': 'cool'}\" \\\\",
            "            saltenv=base",
            "    '''",
            "    if template in salt.utils.templates.TEMPLATE_REGISTRY:",
            "        context_dict = defaults if defaults else {}",
            "        if context:",
            "            context_dict.update(context)",
            "        # Apply templating",
            "        contents = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "            contents,",
            "            from_str=True,",
            "            to_str=True,",
            "            context=context_dict,",
            "            saltenv=saltenv,",
            "            grains=__opts__['grains'],",
            "            pillar=__pillar__,",
            "            salt=__salt__,",
            "            opts=__opts__)['data']",
            "        if six.PY2:",
            "            contents = contents.encode('utf-8')",
            "    else:",
            "        ret = {}",
            "        ret['result'] = False",
            "        ret['comment'] = ('Specified template format {0} is not supported'",
            "                          ).format(template)",
            "        return ret",
            "    return contents",
            "",
            "",
            "def get_managed(",
            "        name,",
            "        template,",
            "        source,",
            "        source_hash,",
            "        source_hash_name,",
            "        user,",
            "        group,",
            "        mode,",
            "        saltenv,",
            "        context,",
            "        defaults,",
            "        skip_verify=False,",
            "        **kwargs):",
            "    '''",
            "    Return the managed file data for file.managed",
            "",
            "    name",
            "        location where the file lives on the server",
            "",
            "    template",
            "        template format",
            "",
            "    source",
            "        managed source file",
            "",
            "    source_hash",
            "        hash of the source file",
            "",
            "    source_hash_name",
            "        When ``source_hash`` refers to a remote file, this specifies the",
            "        filename to look for in that file.",
            "",
            "        .. versionadded:: 2016.3.5",
            "",
            "    user",
            "        Owner of file",
            "",
            "    group",
            "        Group owner of file",
            "",
            "    mode",
            "        Permissions of file",
            "",
            "    context",
            "        Variables to add to the template context",
            "",
            "    defaults",
            "        Default values of for context_dict",
            "",
            "    skip_verify",
            "        If ``True``, hash verification of remote file sources (``http://``,",
            "        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``",
            "        argument will be ignored.",
            "",
            "        .. versionadded:: 2016.3.0",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_managed /etc/httpd/conf.d/httpd.conf jinja salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' None root root '755' base None None",
            "    '''",
            "    # Copy the file to the minion and templatize it",
            "    sfn = ''",
            "    source_sum = {}",
            "",
            "    def _get_local_file_source_sum(path):",
            "        '''",
            "        DRY helper for getting the source_sum value from a locally cached",
            "        path.",
            "        '''",
            "        return {'hsum': get_hash(path, form='sha256'), 'hash_type': 'sha256'}",
            "",
            "    # If we have a source defined, let's figure out what the hash is",
            "    if source:",
            "        urlparsed_source = _urlparse(source)",
            "        parsed_scheme = urlparsed_source.scheme",
            "        parsed_path = os.path.join(",
            "                urlparsed_source.netloc, urlparsed_source.path).rstrip(os.sep)",
            "",
            "        if parsed_scheme and parsed_scheme.lower() in 'abcdefghijklmnopqrstuvwxyz':",
            "            parsed_path = ':'.join([parsed_scheme, parsed_path])",
            "            parsed_scheme = 'file'",
            "",
            "        if parsed_scheme == 'salt':",
            "            source_sum = __salt__['cp.hash_file'](source, saltenv)",
            "            if not source_sum:",
            "                return '', {}, 'Source file {0} not found'.format(source)",
            "        elif not source_hash and parsed_scheme == 'file':",
            "            source_sum = _get_local_file_source_sum(parsed_path)",
            "        elif not source_hash and source.startswith(os.sep):",
            "            source_sum = _get_local_file_source_sum(source)",
            "        else:",
            "            if not skip_verify:",
            "                if source_hash:",
            "                    try:",
            "                        source_sum = get_source_sum(name,",
            "                                                    source,",
            "                                                    source_hash,",
            "                                                    source_hash_name,",
            "                                                    saltenv)",
            "                    except CommandExecutionError as exc:",
            "                        return '', {}, exc.strerror",
            "                else:",
            "                    msg = (",
            "                        'Unable to verify upstream hash of source file {0}, '",
            "                        'please set source_hash or set skip_verify to True'",
            "                        .format(source)",
            "                    )",
            "                    return '', {}, msg",
            "",
            "    if source and (template or parsed_scheme in salt.utils.files.REMOTE_PROTOS):",
            "        # Check if we have the template or remote file cached",
            "        cache_refetch = False",
            "        cached_dest = __salt__['cp.is_cached'](source, saltenv)",
            "        if cached_dest and (source_hash or skip_verify):",
            "            htype = source_sum.get('hash_type', 'sha256')",
            "            cached_sum = get_hash(cached_dest, form=htype)",
            "            if skip_verify:",
            "                # prev: if skip_verify or cached_sum == source_sum['hsum']:",
            "                # but `cached_sum == source_sum['hsum']` is elliptical as prev if",
            "                sfn = cached_dest",
            "                source_sum = {'hsum': cached_sum, 'hash_type': htype}",
            "            elif cached_sum != source_sum.get('hsum', __opts__['hash_type']):",
            "                cache_refetch = True",
            "",
            "        # If we didn't have the template or remote file, let's get it",
            "        # Similarly when the file has been updated and the cache has to be refreshed",
            "        if not sfn or cache_refetch:",
            "            try:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            except Exception as exc:",
            "                # A 404 or other error code may raise an exception, catch it",
            "                # and return a comment that will fail the calling state.",
            "                return '', {}, 'Failed to cache {0}: {1}'.format(source, exc)",
            "",
            "        # If cache failed, sfn will be False, so do a truth check on sfn first",
            "        # as invoking os.path.exists() on a bool raises a TypeError.",
            "        if not sfn or not os.path.exists(sfn):",
            "            return sfn, {}, 'Source file \\'{0}\\' not found'.format(source)",
            "        if sfn == name:",
            "            raise SaltInvocationError(",
            "                'Source file cannot be the same as destination'",
            "            )",
            "",
            "        if template:",
            "            if template in salt.utils.templates.TEMPLATE_REGISTRY:",
            "                context_dict = defaults if defaults else {}",
            "                if context:",
            "                    context_dict.update(context)",
            "                data = salt.utils.templates.TEMPLATE_REGISTRY[template](",
            "                    sfn,",
            "                    name=name,",
            "                    source=source,",
            "                    user=user,",
            "                    group=group,",
            "                    mode=mode,",
            "                    saltenv=saltenv,",
            "                    context=context_dict,",
            "                    salt=__salt__,",
            "                    pillar=__pillar__,",
            "                    grains=__opts__['grains'],",
            "                    opts=__opts__,",
            "                    **kwargs)",
            "            else:",
            "                return sfn, {}, ('Specified template format {0} is not supported'",
            "                                 ).format(template)",
            "",
            "            if data['result']:",
            "                sfn = data['data']",
            "                hsum = get_hash(sfn, form='sha256')",
            "                source_sum = {'hash_type': 'sha256',",
            "                              'hsum': hsum}",
            "            else:",
            "                __clean_tmp(sfn)",
            "                return sfn, {}, data['data']",
            "",
            "    return sfn, source_sum, ''",
            "",
            "",
            "def extract_hash(hash_fn,",
            "                 hash_type='sha256',",
            "                 file_name='',",
            "                 source='',",
            "                 source_hash_name=None):",
            "    '''",
            "    .. versionchanged:: 2016.3.5",
            "        Prior to this version, only the ``file_name`` argument was considered",
            "        for filename matches in the hash file. This would be problematic for",
            "        cases in which the user was relying on a remote checksum file that they",
            "        do not control, and they wished to use a different name for that file",
            "        on the minion from the filename on the remote server (and in the",
            "        checksum file). For example, managing ``/tmp/myfile.tar.gz`` when the",
            "        remote file was at ``https://mydomain.tld/different_name.tar.gz``. The",
            "        :py:func:`file.managed <salt.states.file.managed>` state now also",
            "        passes this function the source URI as well as the ``source_hash_name``",
            "        (if specified). In cases where ``source_hash_name`` is specified, it",
            "        takes precedence over both the ``file_name`` and ``source``. When it is",
            "        not specified, ``file_name`` takes precedence over ``source``. This",
            "        allows for better capability for matching hashes.",
            "    .. versionchanged:: 2016.11.0",
            "        File name and source URI matches are no longer disregarded when",
            "        ``source_hash_name`` is specified. They will be used as fallback",
            "        matches if there is no match to the ``source_hash_name`` value.",
            "",
            "    This routine is called from the :mod:`file.managed",
            "    <salt.states.file.managed>` state to pull a hash from a remote file.",
            "    Regular expressions are used line by line on the ``source_hash`` file, to",
            "    find a potential candidate of the indicated hash type. This avoids many",
            "    problems of arbitrary file layout rules. It specifically permits pulling",
            "    hash codes from debian ``*.dsc`` files.",
            "",
            "    If no exact match of a hash and filename are found, then the first hash",
            "    found (if any) will be returned. If no hashes at all are found, then",
            "    ``None`` will be returned.",
            "",
            "    For example:",
            "",
            "    .. code-block:: yaml",
            "",
            "        openerp_7.0-latest-1.tar.gz:",
            "          file.managed:",
            "            - name: /tmp/openerp_7.0-20121227-075624-1_all.deb",
            "            - source: http://nightly.openerp.com/7.0/nightly/deb/openerp_7.0-20121227-075624-1.tar.gz",
            "            - source_hash: http://nightly.openerp.com/7.0/nightly/deb/openerp_7.0-20121227-075624-1.dsc",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.extract_hash /path/to/hash/file sha512 /etc/foo",
            "    '''",
            "    hash_len = HASHES.get(hash_type)",
            "    if hash_len is None:",
            "        if hash_type:",
            "            log.warning(",
            "                'file.extract_hash: Unsupported hash_type \\'%s\\', falling '",
            "                'back to matching any supported hash_type', hash_type",
            "            )",
            "            hash_type = ''",
            "        hash_len_expr = '{0},{1}'.format(min(HASHES_REVMAP), max(HASHES_REVMAP))",
            "    else:",
            "        hash_len_expr = str(hash_len)",
            "",
            "    filename_separators = string.whitespace + r'\\/'",
            "",
            "    if source_hash_name:",
            "        if not isinstance(source_hash_name, six.string_types):",
            "            source_hash_name = str(source_hash_name)",
            "        source_hash_name_idx = (len(source_hash_name) + 1) * -1",
            "        log.debug(",
            "            'file.extract_hash: Extracting %s hash for file matching '",
            "            'source_hash_name \\'%s\\'',",
            "            'any supported' if not hash_type else hash_type,",
            "            source_hash_name",
            "        )",
            "    if file_name:",
            "        if not isinstance(file_name, six.string_types):",
            "            file_name = str(file_name)",
            "        file_name_basename = os.path.basename(file_name)",
            "        file_name_idx = (len(file_name_basename) + 1) * -1",
            "    if source:",
            "        if not isinstance(source, six.string_types):",
            "            source = str(source)",
            "        urlparsed_source = _urlparse(source)",
            "        source_basename = os.path.basename(",
            "            urlparsed_source.path or urlparsed_source.netloc",
            "        )",
            "        source_idx = (len(source_basename) + 1) * -1",
            "",
            "    basename_searches = [x for x in (file_name, source) if x]",
            "    if basename_searches:",
            "        log.debug(",
            "            'file.extract_hash: %s %s hash for file matching%s: %s',",
            "            'If no source_hash_name match found, will extract'",
            "                if source_hash_name",
            "                else 'Extracting',",
            "            'any supported' if not hash_type else hash_type,",
            "            '' if len(basename_searches) == 1 else ' either of the following',",
            "            ', '.join(basename_searches)",
            "        )",
            "",
            "    partial = None",
            "    found = {}",
            "",
            "    with salt.utils.fopen(hash_fn, 'r') as fp_:",
            "        for line in fp_:",
            "            line = line.strip()",
            "            hash_re = r'(?i)(?<![a-z0-9])([a-f0-9]{' + hash_len_expr + '})(?![a-z0-9])'",
            "            hash_match = re.search(hash_re, line)",
            "            matched = None",
            "            if hash_match:",
            "                matched_hsum = hash_match.group(1)",
            "                if matched_hsum is not None:",
            "                    matched_type = HASHES_REVMAP.get(len(matched_hsum))",
            "                    if matched_type is None:",
            "                        # There was a match, but it's not of the correct length",
            "                        # to match one of the supported hash types.",
            "                        matched = None",
            "                    else:",
            "                        matched = {'hsum': matched_hsum,",
            "                                   'hash_type': matched_type}",
            "",
            "            if matched is None:",
            "                log.debug(",
            "                    'file.extract_hash: In line \\'%s\\', no %shash found',",
            "                    line,",
            "                    '' if not hash_type else hash_type + ' '",
            "                )",
            "                continue",
            "",
            "            if partial is None:",
            "                partial = matched",
            "",
            "            def _add_to_matches(found, line, match_type, value, matched):",
            "                log.debug(",
            "                    'file.extract_hash: Line \\'%s\\' matches %s \\'%s\\'',",
            "                    line, match_type, value",
            "                )",
            "                found.setdefault(match_type, []).append(matched)",
            "",
            "            hash_matched = False",
            "            if source_hash_name:",
            "                if line.endswith(source_hash_name):",
            "                    # Checking the character before where the basename",
            "                    # should start for either whitespace or a path",
            "                    # separator. We can't just rsplit on spaces/whitespace,",
            "                    # because the filename may contain spaces.",
            "                    try:",
            "                        if line[source_hash_name_idx] in string.whitespace:",
            "                            _add_to_matches(found, line, 'source_hash_name',",
            "                                            source_hash_name, matched)",
            "                            hash_matched = True",
            "                    except IndexError:",
            "                        pass",
            "                elif re.match(source_hash_name.replace('.', r'\\.') + r'\\s+',",
            "                              line):",
            "                    _add_to_matches(found, line, 'source_hash_name',",
            "                                    source_hash_name, matched)",
            "                    hash_matched = True",
            "            if file_name:",
            "                if line.endswith(file_name_basename):",
            "                    # Checking the character before where the basename",
            "                    # should start for either whitespace or a path",
            "                    # separator. We can't just rsplit on spaces/whitespace,",
            "                    # because the filename may contain spaces.",
            "                    try:",
            "                        if line[file_name_idx] in filename_separators:",
            "                            _add_to_matches(found, line, 'file_name',",
            "                                            file_name, matched)",
            "                            hash_matched = True",
            "                    except IndexError:",
            "                        pass",
            "                elif re.match(file_name.replace('.', r'\\.') + r'\\s+', line):",
            "                    _add_to_matches(found, line, 'file_name',",
            "                                    file_name, matched)",
            "                    hash_matched = True",
            "            if source:",
            "                if line.endswith(source_basename):",
            "                    # Same as above, we can't just do an rsplit here.",
            "                    try:",
            "                        if line[source_idx] in filename_separators:",
            "                            _add_to_matches(found, line, 'source',",
            "                                            source, matched)",
            "                            hash_matched = True",
            "                    except IndexError:",
            "                        pass",
            "                elif re.match(source.replace('.', r'\\.') + r'\\s+', line):",
            "                    _add_to_matches(found, line, 'source', source, matched)",
            "                    hash_matched = True",
            "",
            "            if not hash_matched:",
            "                log.debug(",
            "                    'file.extract_hash: Line \\'%s\\' contains %s hash '",
            "                    '\\'%s\\', but line did not meet the search criteria',",
            "                    line, matched['hash_type'], matched['hsum']",
            "                )",
            "",
            "    for found_type, found_str in (('source_hash_name', source_hash_name),",
            "                                  ('file_name', file_name),",
            "                                  ('source', source)):",
            "        if found_type in found:",
            "            if len(found[found_type]) > 1:",
            "                log.debug(",
            "                    'file.extract_hash: Multiple %s matches for %s: %s',",
            "                    found_type,",
            "                    found_str,",
            "                    ', '.join(",
            "                        ['{0} ({1})'.format(x['hsum'], x['hash_type'])",
            "                         for x in found[found_type]]",
            "                    )",
            "                )",
            "            ret = found[found_type][0]",
            "            log.debug(",
            "                'file.extract_hash: Returning %s hash \\'%s\\' as a match of %s',",
            "                ret['hash_type'], ret['hsum'], found_str",
            "            )",
            "            return ret",
            "",
            "    if partial:",
            "        log.debug(",
            "            'file.extract_hash: Returning the partially identified %s hash '",
            "            '\\'%s\\'', partial['hash_type'], partial['hsum']",
            "        )",
            "        return partial",
            "",
            "    log.debug('file.extract_hash: No matches, returning None')",
            "    return None",
            "",
            "",
            "def check_perms(name, ret, user, group, mode, follow_symlinks=False):",
            "    '''",
            "    Check the permissions on files and chown if needed",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_perms /etc/sudoers '{}' root root 400",
            "",
            "    .. versionchanged:: 2014.1.3",
            "        ``follow_symlinks`` option added",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if not ret:",
            "        ret = {'name': name,",
            "               'changes': {},",
            "               'comment': [],",
            "               'result': True}",
            "        orig_comment = ''",
            "    else:",
            "        orig_comment = ret['comment']",
            "        ret['comment'] = []",
            "",
            "    # Check permissions",
            "    perms = {}",
            "    cur = stats(name, follow_symlinks=follow_symlinks)",
            "    if not cur:",
            "        # NOTE: The file.directory state checks the content of the error",
            "        # message in this exception. Any changes made to the message for this",
            "        # exception will reflect the file.directory state as well, and will",
            "        # likely require changes there.",
            "        raise CommandExecutionError('{0} does not exist'.format(name))",
            "    perms['luser'] = cur['user']",
            "    perms['lgroup'] = cur['group']",
            "    perms['lmode'] = salt.utils.normalize_mode(cur['mode'])",
            "",
            "    # Mode changes if needed",
            "    if mode is not None:",
            "        # File is a symlink, ignore the mode setting",
            "        # if follow_symlinks is False",
            "        if os.path.islink(name) and not follow_symlinks:",
            "            pass",
            "        else:",
            "            mode = salt.utils.normalize_mode(mode)",
            "            if mode != perms['lmode']:",
            "                if __opts__['test'] is True:",
            "                    ret['changes']['mode'] = mode",
            "                else:",
            "                    set_mode(name, mode)",
            "                    if mode != salt.utils.normalize_mode(get_mode(name)):",
            "                        ret['result'] = False",
            "                        ret['comment'].append(",
            "                            'Failed to change mode to {0}'.format(mode)",
            "                        )",
            "                    else:",
            "                        ret['changes']['mode'] = mode",
            "    # user/group changes if needed, then check if it worked",
            "    if user:",
            "        if isinstance(user, int):",
            "            user = uid_to_user(user)",
            "        if (salt.utils.is_windows() and",
            "                user_to_uid(user) != user_to_uid(perms['luser'])",
            "            ) or (",
            "            not salt.utils.is_windows() and user != perms['luser']",
            "        ):",
            "            perms['cuser'] = user",
            "",
            "    if group:",
            "        if isinstance(group, int):",
            "            group = gid_to_group(group)",
            "        if (salt.utils.is_windows() and",
            "                group_to_gid(group) != group_to_gid(perms['lgroup'])",
            "            ) or (",
            "                not salt.utils.is_windows() and group != perms['lgroup']",
            "        ):",
            "            perms['cgroup'] = group",
            "",
            "    if 'cuser' in perms or 'cgroup' in perms:",
            "        if not __opts__['test']:",
            "            if os.path.islink(name) and not follow_symlinks:",
            "                chown_func = lchown",
            "            else:",
            "                chown_func = chown",
            "            if user is None:",
            "                user = perms['luser']",
            "            if group is None:",
            "                group = perms['lgroup']",
            "            try:",
            "                chown_func(name, user, group)",
            "            except OSError:",
            "                ret['result'] = False",
            "",
            "    if user:",
            "        if isinstance(user, int):",
            "            user = uid_to_user(user)",
            "        if (salt.utils.is_windows() and",
            "                user_to_uid(user) != user_to_uid(",
            "                    get_user(name, follow_symlinks=follow_symlinks)) and",
            "                user != ''",
            "            ) or (",
            "            not salt.utils.is_windows() and",
            "                user != get_user(name, follow_symlinks=follow_symlinks) and",
            "                user != ''",
            "        ):",
            "            if __opts__['test'] is True:",
            "                ret['changes']['user'] = user",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'].append('Failed to change user to {0}'",
            "                                          .format(user))",
            "        elif 'cuser' in perms and user != '':",
            "            ret['changes']['user'] = user",
            "    if group:",
            "        if isinstance(group, int):",
            "            group = gid_to_group(group)",
            "        if (salt.utils.is_windows() and",
            "                group_to_gid(group) != group_to_gid(",
            "                    get_group(name, follow_symlinks=follow_symlinks)) and",
            "                user != '') or (",
            "            not salt.utils.is_windows() and",
            "                group != get_group(name, follow_symlinks=follow_symlinks) and",
            "                user != ''",
            "        ):",
            "            if __opts__['test'] is True:",
            "                ret['changes']['group'] = group",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'].append('Failed to change group to {0}'",
            "                                      .format(group))",
            "        elif 'cgroup' in perms and user != '':",
            "            ret['changes']['group'] = group",
            "",
            "    if isinstance(orig_comment, six.string_types):",
            "        if orig_comment:",
            "            ret['comment'].insert(0, orig_comment)",
            "        ret['comment'] = '; '.join(ret['comment'])",
            "    if __opts__['test'] is True and ret['changes']:",
            "        ret['result'] = None",
            "    return ret, perms",
            "",
            "",
            "def check_managed(",
            "        name,",
            "        source,",
            "        source_hash,",
            "        source_hash_name,",
            "        user,",
            "        group,",
            "        mode,",
            "        template,",
            "        context,",
            "        defaults,",
            "        saltenv,",
            "        contents=None,",
            "        skip_verify=False,",
            "        **kwargs):",
            "    '''",
            "    Check to see what changes need to be made for a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_managed /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root, root, '755' jinja True None None base",
            "    '''",
            "    # If the source is a list then find which file exists",
            "    source, source_hash = source_list(source,           # pylint: disable=W0633",
            "                                      source_hash,",
            "                                      saltenv)",
            "",
            "    sfn = ''",
            "    source_sum = None",
            "",
            "    if contents is None:",
            "        # Gather the source file from the server",
            "        sfn, source_sum, comments = get_managed(",
            "            name,",
            "            template,",
            "            source,",
            "            source_hash,",
            "            source_hash_name,",
            "            user,",
            "            group,",
            "            mode,",
            "            saltenv,",
            "            context,",
            "            defaults,",
            "            skip_verify,",
            "            **kwargs)",
            "        if comments:",
            "            __clean_tmp(sfn)",
            "            return False, comments",
            "    changes = check_file_meta(name, sfn, source, source_sum, user,",
            "                              group, mode, saltenv, contents)",
            "    # Ignore permission for files written temporary directories",
            "    # Files in any path will still be set correctly using get_managed()",
            "    if name.startswith(tempfile.gettempdir()):",
            "        for key in ['user', 'group', 'mode']:",
            "            changes.pop(key, None)",
            "    __clean_tmp(sfn)",
            "    if changes:",
            "        log.info(changes)",
            "        comments = ['The following values are set to be changed:\\n']",
            "        comments.extend('{0}: {1}\\n'.format(key, val)",
            "                        for key, val in six.iteritems(changes))",
            "        return None, ''.join(comments)",
            "    return True, 'The file {0} is in the correct state'.format(name)",
            "",
            "",
            "def check_managed_changes(",
            "        name,",
            "        source,",
            "        source_hash,",
            "        source_hash_name,",
            "        user,",
            "        group,",
            "        mode,",
            "        template,",
            "        context,",
            "        defaults,",
            "        saltenv,",
            "        contents=None,",
            "        skip_verify=False,",
            "        keep_mode=False,",
            "        **kwargs):",
            "    '''",
            "    Return a dictionary of what changes need to be made for a file",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_managed_changes /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root, root, '755' jinja True None None base",
            "    '''",
            "    # If the source is a list then find which file exists",
            "    source, source_hash = source_list(source,           # pylint: disable=W0633",
            "                                      source_hash,",
            "                                      saltenv)",
            "",
            "    sfn = ''",
            "    source_sum = None",
            "",
            "    if contents is None:",
            "        # Gather the source file from the server",
            "        sfn, source_sum, comments = get_managed(",
            "            name,",
            "            template,",
            "            source,",
            "            source_hash,",
            "            source_hash_name,",
            "            user,",
            "            group,",
            "            mode,",
            "            saltenv,",
            "            context,",
            "            defaults,",
            "            skip_verify,",
            "            **kwargs)",
            "        if comments:",
            "            __clean_tmp(sfn)",
            "            return False, comments",
            "        if sfn and source and keep_mode:",
            "            if _urlparse(source).scheme in ('salt', 'file') \\",
            "                    or source.startswith('/'):",
            "                try:",
            "                    mode = __salt__['cp.stat_file'](source, saltenv=saltenv, octal=True)",
            "                except Exception as exc:",
            "                    log.warning('Unable to stat %s: %s', sfn, exc)",
            "    changes = check_file_meta(name, sfn, source, source_sum, user,",
            "                              group, mode, saltenv, contents)",
            "    __clean_tmp(sfn)",
            "    return changes",
            "",
            "",
            "def check_file_meta(",
            "        name,",
            "        sfn,",
            "        source,",
            "        source_sum,",
            "        user,",
            "        group,",
            "        mode,",
            "        saltenv,",
            "        contents=None):",
            "    '''",
            "    Check for the changes in the file metadata.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.check_file_meta /etc/httpd/conf.d/httpd.conf salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root, root, '755' base",
            "",
            "    .. note::",
            "",
            "        Supported hash types include sha512, sha384, sha256, sha224, sha1, and",
            "        md5.",
            "",
            "    name",
            "        Path to file destination",
            "",
            "    sfn",
            "        Template-processed source file contents",
            "",
            "    source",
            "        URL to file source",
            "",
            "    source_sum",
            "        File checksum information as a dictionary",
            "",
            "        .. code-block:: yaml",
            "",
            "            {hash_type: md5, hsum: <md5sum>}",
            "",
            "    user",
            "        Destination file user owner",
            "",
            "    group",
            "        Destination file group owner",
            "",
            "    mode",
            "        Destination file permissions mode",
            "",
            "    saltenv",
            "        Salt environment used to resolve source files",
            "",
            "    contents",
            "        File contents",
            "    '''",
            "    changes = {}",
            "    if not source_sum:",
            "        source_sum = dict()",
            "    lstats = stats(name, hash_type=source_sum.get('hash_type', None), follow_symlinks=False)",
            "    if not lstats:",
            "        changes['newfile'] = name",
            "        return changes",
            "    if 'hsum' in source_sum:",
            "        if source_sum['hsum'] != lstats['sum']:",
            "            if not sfn and source:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if sfn:",
            "                if __salt__['config.option']('obfuscate_templates'):",
            "                    changes['diff'] = '<Obfuscated Template>'",
            "                else:",
            "                    # Check to see if the files are bins",
            "                    bdiff = _binary_replace(name, sfn)",
            "                    if bdiff:",
            "                        changes['diff'] = bdiff",
            "                    else:",
            "                        with salt.utils.fopen(sfn, 'r') as src:",
            "                            slines = src.readlines()",
            "                        with salt.utils.fopen(name, 'r') as name_:",
            "                            nlines = name_.readlines()",
            "                        changes['diff'] = \\",
            "                            ''.join(difflib.unified_diff(nlines, slines))",
            "            else:",
            "                changes['sum'] = 'Checksum differs'",
            "",
            "    if contents is not None:",
            "        # Write a tempfile with the static contents",
            "        tmp = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX,",
            "                                 text=True)",
            "        if salt.utils.is_windows():",
            "            contents = os.linesep.join(",
            "                _splitlines_preserving_trailing_newline(contents))",
            "        with salt.utils.fopen(tmp, 'w') as tmp_:",
            "            tmp_.write(str(contents))",
            "        # Compare the static contents with the named file",
            "        with salt.utils.fopen(tmp, 'r') as src:",
            "            slines = src.readlines()",
            "        with salt.utils.fopen(name, 'r') as name_:",
            "            nlines = name_.readlines()",
            "        __clean_tmp(tmp)",
            "        if ''.join(nlines) != ''.join(slines):",
            "            if __salt__['config.option']('obfuscate_templates'):",
            "                changes['diff'] = '<Obfuscated Template>'",
            "            else:",
            "                if salt.utils.istextfile(name):",
            "                    changes['diff'] = \\",
            "                        ''.join(difflib.unified_diff(nlines, slines))",
            "                else:",
            "                    changes['diff'] = 'Replace binary file with text file'",
            "",
            "    if (user is not None",
            "            and user != lstats['user']",
            "            and user != lstats['uid']):",
            "        changes['user'] = user",
            "    if (group is not None",
            "            and group != lstats['group']",
            "            and group != lstats['gid']):",
            "        changes['group'] = group",
            "    # Normalize the file mode",
            "    smode = salt.utils.normalize_mode(lstats['mode'])",
            "    mode = salt.utils.normalize_mode(mode)",
            "    if mode is not None and mode != smode:",
            "        changes['mode'] = mode",
            "    return changes",
            "",
            "",
            "def get_diff(",
            "        minionfile,",
            "        masterfile,",
            "        saltenv='base'):",
            "    '''",
            "    Return unified diff of file compared to file on master",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.get_diff /home/fred/.vimrc salt://users/fred/.vimrc",
            "    '''",
            "    minionfile = os.path.expanduser(minionfile)",
            "",
            "    ret = ''",
            "",
            "    if not os.path.exists(minionfile):",
            "        ret = 'File {0} does not exist on the minion'.format(minionfile)",
            "        return ret",
            "",
            "    sfn = __salt__['cp.cache_file'](masterfile, saltenv)",
            "    if sfn:",
            "        with salt.utils.fopen(sfn, 'r') as src:",
            "            slines = src.readlines()",
            "        with salt.utils.fopen(minionfile, 'r') as name_:",
            "            nlines = name_.readlines()",
            "        if ''.join(nlines) != ''.join(slines):",
            "            bdiff = _binary_replace(minionfile, sfn)",
            "            if bdiff:",
            "                ret += bdiff",
            "            else:",
            "                ret += ''.join(difflib.unified_diff(nlines, slines,",
            "                                                    minionfile, masterfile))",
            "    else:",
            "        ret = 'Failed to copy file from master'",
            "",
            "    return ret",
            "",
            "",
            "def manage_file(name,",
            "                sfn,",
            "                ret,",
            "                source,",
            "                source_sum,",
            "                user,",
            "                group,",
            "                mode,",
            "                saltenv,",
            "                backup,",
            "                makedirs=False,",
            "                template=None,   # pylint: disable=W0613",
            "                show_changes=True,",
            "                contents=None,",
            "                dir_mode=None,",
            "                follow_symlinks=True,",
            "                skip_verify=False,",
            "                keep_mode=False,",
            "                **kwargs):",
            "    '''",
            "    Checks the destination against what was retrieved with get_managed and",
            "    makes the appropriate modifications (if necessary).",
            "",
            "    name",
            "        location to place the file",
            "",
            "    sfn",
            "        location of cached file on the minion",
            "",
            "        This is the path to the file stored on the minion. This file is placed",
            "        on the minion using cp.cache_file.  If the hash sum of that file",
            "        matches the source_sum, we do not transfer the file to the minion",
            "        again.",
            "",
            "        This file is then grabbed and if it has template set, it renders the",
            "        file to be placed into the correct place on the system using",
            "        salt.files.utils.copyfile()",
            "",
            "    ret",
            "        The initial state return data structure. Pass in ``None`` to use the",
            "        default structure.",
            "",
            "    source",
            "        file reference on the master",
            "",
            "    source_hash",
            "        sum hash for source",
            "",
            "    user",
            "        user owner",
            "",
            "    group",
            "        group owner",
            "",
            "    backup",
            "        backup_mode",
            "",
            "    makedirs",
            "        make directories if they do not exist",
            "",
            "    template",
            "        format of templating",
            "",
            "    show_changes",
            "        Include diff in state return",
            "",
            "    contents:",
            "        contents to be placed in the file",
            "",
            "    dir_mode",
            "        mode for directories created with makedirs",
            "",
            "    skip_verify : False",
            "        If ``True``, hash verification of remote file sources (``http://``,",
            "        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``",
            "        argument will be ignored.",
            "",
            "        .. versionadded:: 2016.3.0",
            "",
            "    keep_mode : False",
            "        If ``True``, and the ``source`` is a file from the Salt fileserver (or",
            "        a local file on the minion), the mode of the destination file will be",
            "        set to the mode of the source file.",
            "",
            "        .. note:: keep_mode does not work with salt-ssh.",
            "",
            "            As a consequence of how the files are transfered to the minion, and",
            "            the inability to connect back to the master with salt-ssh, salt is",
            "            unable to stat the file as it exists on the fileserver and thus",
            "            cannot mirror the mode on the salt-ssh minion",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.manage_file /etc/httpd/conf.d/httpd.conf '' '{}' salt://http/httpd.conf '{hash_type: 'md5', 'hsum': <md5sum>}' root root '755' base ''",
            "",
            "    .. versionchanged:: 2014.7.0",
            "        ``follow_symlinks`` option added",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if not ret:",
            "        ret = {'name': name,",
            "               'changes': {},",
            "               'comment': '',",
            "               'result': True}",
            "",
            "    if source and not sfn:",
            "        # File is not present, cache it",
            "        sfn = __salt__['cp.cache_file'](source, saltenv)",
            "        if not sfn:",
            "            return _error(",
            "                ret, 'Source file \\'{0}\\' not found'.format(source))",
            "        htype = source_sum.get('hash_type', __opts__['hash_type'])",
            "        # Recalculate source sum now that file has been cached",
            "        source_sum = {",
            "            'hash_type': htype,",
            "            'hsum': get_hash(sfn, form=htype)",
            "        }",
            "        if keep_mode:",
            "            if _urlparse(source).scheme in ('salt', 'file') \\",
            "                    or source.startswith('/'):",
            "                try:",
            "                    mode = __salt__['cp.stat_file'](source, saltenv=saltenv, octal=True)",
            "                except Exception as exc:",
            "                    log.warning('Unable to stat %s: %s', sfn, exc)",
            "",
            "    # Check changes if the target file exists",
            "    if os.path.isfile(name) or os.path.islink(name):",
            "        if os.path.islink(name) and follow_symlinks:",
            "            real_name = os.path.realpath(name)",
            "        else:",
            "            real_name = name",
            "",
            "        # Only test the checksums on files with managed contents",
            "        if source and not (not follow_symlinks and os.path.islink(real_name)):",
            "            name_sum = get_hash(real_name, source_sum.get('hash_type', __opts__['hash_type']))",
            "        else:",
            "            name_sum = None",
            "",
            "        # Check if file needs to be replaced",
            "        if source and (name_sum is None or source_sum.get('hsum', __opts__['hash_type']) != name_sum):",
            "            if not sfn:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if not sfn:",
            "                return _error(",
            "                    ret, 'Source file \\'{0}\\' not found'.format(source))",
            "            # If the downloaded file came from a non salt server or local",
            "            # source, and we are not skipping checksum verification, then",
            "            # verify that it matches the specified checksum.",
            "            if not skip_verify \\",
            "                    and _urlparse(source).scheme not in ('salt', ''):",
            "                dl_sum = get_hash(sfn, source_sum['hash_type'])",
            "                if dl_sum != source_sum['hsum']:",
            "                    ret['comment'] = (",
            "                        'Specified {0} checksum for {1} ({2}) does not match '",
            "                        'actual checksum ({3}). If the \\'source_hash\\' value '",
            "                        'refers to a remote file with multiple possible '",
            "                        'matches, then it may be necessary to set '",
            "                        '\\'source_hash_name\\'.'.format(",
            "                            source_sum['hash_type'],",
            "                            source,",
            "                            source_sum['hsum'],",
            "                            dl_sum",
            "                        )",
            "                    )",
            "                    ret['result'] = False",
            "                    return ret",
            "",
            "            # Print a diff equivalent to diff -u old new",
            "            if __salt__['config.option']('obfuscate_templates'):",
            "                ret['changes']['diff'] = '<Obfuscated Template>'",
            "            elif not show_changes:",
            "                ret['changes']['diff'] = '<show_changes=False>'",
            "            else:",
            "                # Check to see if the files are bins",
            "                bdiff = _binary_replace(real_name, sfn)",
            "                if bdiff:",
            "                    ret['changes']['diff'] = bdiff",
            "                else:",
            "                    with salt.utils.fopen(sfn, 'r') as src:",
            "                        slines = src.readlines()",
            "                    with salt.utils.fopen(real_name, 'r') as name_:",
            "                        nlines = name_.readlines()",
            "",
            "                    sndiff = ''.join(difflib.unified_diff(nlines, slines))",
            "                    if sndiff:",
            "                        ret['changes']['diff'] = sndiff",
            "",
            "            # Pre requisites are met, and the file needs to be replaced, do it",
            "            try:",
            "                salt.utils.files.copyfile(sfn,",
            "                                    real_name,",
            "                                    __salt__['config.backup_mode'](backup),",
            "                                    __opts__['cachedir'])",
            "            except IOError as io_error:",
            "                __clean_tmp(sfn)",
            "                return _error(",
            "                    ret, 'Failed to commit change: {0}'.format(io_error))",
            "",
            "        if contents is not None:",
            "            # Write the static contents to a temporary file",
            "            tmp = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX,",
            "                                     text=True)",
            "            if salt.utils.is_windows():",
            "                contents = os.linesep.join(",
            "                    _splitlines_preserving_trailing_newline(contents))",
            "            with salt.utils.fopen(tmp, 'w') as tmp_:",
            "                tmp_.write(str(contents))",
            "",
            "            # Compare contents of files to know if we need to replace",
            "            with salt.utils.fopen(tmp, 'r') as src:",
            "                slines = src.readlines()",
            "            with salt.utils.fopen(real_name, 'r') as name_:",
            "                nlines = name_.readlines()",
            "                different = ''.join(slines) != ''.join(nlines)",
            "",
            "            if different:",
            "                if __salt__['config.option']('obfuscate_templates'):",
            "                    ret['changes']['diff'] = '<Obfuscated Template>'",
            "                elif not show_changes:",
            "                    ret['changes']['diff'] = '<show_changes=False>'",
            "                else:",
            "                    if salt.utils.istextfile(real_name):",
            "                        ret['changes']['diff'] = \\",
            "                            ''.join(difflib.unified_diff(nlines, slines))",
            "                    else:",
            "                        ret['changes']['diff'] = \\",
            "                            'Replace binary file with text file'",
            "",
            "                # Pre requisites are met, the file needs to be replaced, do it",
            "                try:",
            "                    salt.utils.files.copyfile(tmp,",
            "                                        real_name,",
            "                                        __salt__['config.backup_mode'](backup),",
            "                                        __opts__['cachedir'])",
            "                except IOError as io_error:",
            "                    __clean_tmp(tmp)",
            "                    return _error(",
            "                        ret, 'Failed to commit change: {0}'.format(io_error))",
            "            __clean_tmp(tmp)",
            "",
            "        # Check for changing symlink to regular file here",
            "        if os.path.islink(name) and not follow_symlinks:",
            "            if not sfn:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if not sfn:",
            "                return _error(",
            "                    ret, 'Source file \\'{0}\\' not found'.format(source))",
            "            # If the downloaded file came from a non salt server source verify",
            "            # that it matches the intended sum value",
            "            if not skip_verify and _urlparse(source).scheme != 'salt':",
            "                dl_sum = get_hash(sfn, source_sum['hash_type'])",
            "                if dl_sum != source_sum['hsum']:",
            "                    ret['comment'] = (",
            "                        'Specified {0} checksum for {1} ({2}) does not match '",
            "                        'actual checksum ({3})'.format(",
            "                            source_sum['hash_type'],",
            "                            name,",
            "                            source_sum['hsum'],",
            "                            dl_sum",
            "                        )",
            "                    )",
            "                    ret['result'] = False",
            "                    return ret",
            "",
            "            try:",
            "                salt.utils.files.copyfile(sfn,",
            "                                    name,",
            "                                    __salt__['config.backup_mode'](backup),",
            "                                    __opts__['cachedir'])",
            "            except IOError as io_error:",
            "                __clean_tmp(sfn)",
            "                return _error(",
            "                    ret, 'Failed to commit change: {0}'.format(io_error))",
            "",
            "            ret['changes']['diff'] = \\",
            "                'Replace symbolic link with regular file'",
            "",
            "        ret, _ = check_perms(name, ret, user, group, mode, follow_symlinks)",
            "",
            "        if ret['changes']:",
            "            ret['comment'] = 'File {0} updated'.format(name)",
            "",
            "        elif not ret['changes'] and ret['result']:",
            "            ret['comment'] = u'File {0} is in the correct state'.format(",
            "                salt.utils.locales.sdecode(name)",
            "            )",
            "        if sfn:",
            "            __clean_tmp(sfn)",
            "        return ret",
            "    else:  # target file does not exist",
            "        contain_dir = os.path.dirname(name)",
            "",
            "        def _set_mode_and_make_dirs(name, dir_mode, mode, user, group):",
            "            # check for existence of windows drive letter",
            "            if salt.utils.is_windows():",
            "                drive, _ = os.path.splitdrive(name)",
            "                if drive and not os.path.exists(drive):",
            "                    __clean_tmp(sfn)",
            "                    return _error(ret,",
            "                                  '{0} drive not present'.format(drive))",
            "            if dir_mode is None and mode is not None:",
            "                # Add execute bit to each nonzero digit in the mode, if",
            "                # dir_mode was not specified. Otherwise, any",
            "                # directories created with makedirs_() below can't be",
            "                # listed via a shell.",
            "                mode_list = [x for x in str(mode)][-3:]",
            "                for idx in range(len(mode_list)):",
            "                    if mode_list[idx] != '0':",
            "                        mode_list[idx] = str(int(mode_list[idx]) | 1)",
            "                dir_mode = ''.join(mode_list)",
            "            makedirs_(name, user=user,",
            "                      group=group, mode=dir_mode)",
            "",
            "        if source:",
            "            # It is a new file, set the diff accordingly",
            "            ret['changes']['diff'] = 'New file'",
            "            # Apply the new file",
            "            if not sfn:",
            "                sfn = __salt__['cp.cache_file'](source, saltenv)",
            "            if not sfn:",
            "                return _error(",
            "                    ret, 'Source file \\'{0}\\' not found'.format(source))",
            "            # If the downloaded file came from a non salt server source verify",
            "            # that it matches the intended sum value",
            "            if not skip_verify \\",
            "                    and _urlparse(source).scheme != 'salt':",
            "                dl_sum = get_hash(sfn, source_sum['hash_type'])",
            "                if dl_sum != source_sum['hsum']:",
            "                    ret['comment'] = (",
            "                        'Specified {0} checksum for {1} ({2}) does not match '",
            "                        'actual checksum ({3})'.format(",
            "                            source_sum['hash_type'],",
            "                            name,",
            "                            source_sum['hsum'],",
            "                            dl_sum",
            "                        )",
            "                    )",
            "                    ret['result'] = False",
            "                    return ret",
            "            if not os.path.isdir(contain_dir):",
            "                if makedirs:",
            "                    _set_mode_and_make_dirs(name, dir_mode, mode, user, group)",
            "                else:",
            "                    __clean_tmp(sfn)",
            "                    # No changes actually made",
            "                    ret['changes'].pop('diff', None)",
            "                    return _error(ret, 'Parent directory not present')",
            "        else:  # source != True",
            "            if not os.path.isdir(contain_dir):",
            "                if makedirs:",
            "                    _set_mode_and_make_dirs(name, dir_mode, mode, user, group)",
            "                else:",
            "                    __clean_tmp(sfn)",
            "                    # No changes actually made",
            "                    ret['changes'].pop('diff', None)",
            "                    return _error(ret, 'Parent directory not present')",
            "",
            "            # Create the file, user rw-only if mode will be set to prevent",
            "            # a small security race problem before the permissions are set",
            "            if mode:",
            "                current_umask = os.umask(0o77)",
            "",
            "            # Create a new file when test is False and source is None",
            "            if contents is None:",
            "                if not __opts__['test']:",
            "                    if touch(name):",
            "                        ret['changes']['new'] = 'file {0} created'.format(name)",
            "                        ret['comment'] = 'Empty file'",
            "                    else:",
            "                        return _error(",
            "                            ret, 'Empty file {0} not created'.format(name)",
            "                        )",
            "            else:",
            "                if not __opts__['test']:",
            "                    if touch(name):",
            "                        ret['changes']['diff'] = 'New file'",
            "                    else:",
            "                        return _error(",
            "                            ret, 'File {0} not created'.format(name)",
            "                        )",
            "",
            "            if mode:",
            "                os.umask(current_umask)",
            "",
            "        if contents is not None:",
            "            # Write the static contents to a temporary file",
            "            tmp = salt.utils.mkstemp(prefix=salt.utils.files.TEMPFILE_PREFIX,",
            "                                     text=True)",
            "            if salt.utils.is_windows():",
            "                contents = os.linesep.join(",
            "                    _splitlines_preserving_trailing_newline(contents))",
            "            with salt.utils.fopen(tmp, 'w') as tmp_:",
            "                tmp_.write(str(contents))",
            "            # Copy into place",
            "            salt.utils.files.copyfile(tmp,",
            "                                name,",
            "                                __salt__['config.backup_mode'](backup),",
            "                                __opts__['cachedir'])",
            "            __clean_tmp(tmp)",
            "        # Now copy the file contents if there is a source file",
            "        elif sfn:",
            "            salt.utils.files.copyfile(sfn,",
            "                                name,",
            "                                __salt__['config.backup_mode'](backup),",
            "                                __opts__['cachedir'])",
            "            __clean_tmp(sfn)",
            "",
            "        # This is a new file, if no mode specified, use the umask to figure",
            "        # out what mode to use for the new file.",
            "        if mode is None and not salt.utils.is_windows():",
            "            # Get current umask",
            "            mask = os.umask(0)",
            "            os.umask(mask)",
            "            # Calculate the mode value that results from the umask",
            "            mode = oct((0o777 ^ mask) & 0o666)",
            "        ret, _ = check_perms(name, ret, user, group, mode)",
            "",
            "        if not ret['comment']:",
            "            ret['comment'] = 'File ' + name + ' updated'",
            "",
            "        if __opts__['test']:",
            "            ret['comment'] = 'File ' + name + ' not updated'",
            "        elif not ret['changes'] and ret['result']:",
            "            ret['comment'] = 'File ' + name + ' is in the correct state'",
            "        if sfn:",
            "            __clean_tmp(sfn)",
            "        return ret",
            "",
            "",
            "def mkdir(dir_path,",
            "          user=None,",
            "          group=None,",
            "          mode=None):",
            "    '''",
            "    Ensure that a directory is available.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.mkdir /opt/jetty/context",
            "    '''",
            "    dir_path = os.path.expanduser(dir_path)",
            "",
            "    directory = os.path.normpath(dir_path)",
            "",
            "    if not os.path.isdir(directory):",
            "        # If a caller such as managed() is invoked  with makedirs=True, make",
            "        # sure that any created dirs are created with the same user and group",
            "        # to follow the principal of least surprise method.",
            "        makedirs_perms(directory, user, group, mode)",
            "",
            "    return True",
            "",
            "",
            "def makedirs_(path,",
            "              user=None,",
            "              group=None,",
            "              mode=None):",
            "    '''",
            "    Ensure that the directory containing this path is available.",
            "",
            "    .. note::",
            "",
            "        The path must end with a trailing slash otherwise the directory/directories",
            "        will be created up to the parent directory. For example if path is",
            "        ``/opt/code``, then it would be treated as ``/opt/`` but if the path",
            "        ends with a trailing slash like ``/opt/code/``, then it would be",
            "        treated as ``/opt/code/``.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.makedirs /opt/code/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    # walk up the directory structure until we find the first existing",
            "    # directory",
            "    dirname = os.path.normpath(os.path.dirname(path))",
            "",
            "    if os.path.isdir(dirname):",
            "        # There's nothing for us to do",
            "        msg = 'Directory \\'{0}\\' already exists'.format(dirname)",
            "        log.debug(msg)",
            "        return msg",
            "",
            "    if os.path.exists(dirname):",
            "        msg = 'The path \\'{0}\\' already exists and is not a directory'.format(",
            "            dirname",
            "        )",
            "        log.debug(msg)",
            "        return msg",
            "",
            "    directories_to_create = []",
            "    while True:",
            "        if os.path.isdir(dirname):",
            "            break",
            "",
            "        directories_to_create.append(dirname)",
            "        current_dirname = dirname",
            "        dirname = os.path.dirname(dirname)",
            "",
            "        if current_dirname == dirname:",
            "            raise SaltInvocationError(",
            "                'Recursive creation for path \\'{0}\\' would result in an '",
            "                'infinite loop. Please use an absolute path.'.format(dirname)",
            "            )",
            "",
            "    # create parent directories from the topmost to the most deeply nested one",
            "    directories_to_create.reverse()",
            "    for directory_to_create in directories_to_create:",
            "        # all directories have the user, group and mode set!!",
            "        log.debug('Creating directory: %s', directory_to_create)",
            "        mkdir(directory_to_create, user=user, group=group, mode=mode)",
            "",
            "",
            "def makedirs_perms(name,",
            "                   user=None,",
            "                   group=None,",
            "                   mode='0755'):",
            "    '''",
            "    Taken and modified from os.makedirs to set user, group and mode for each",
            "    directory created.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.makedirs_perms /opt/code",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    path = os.path",
            "    head, tail = path.split(name)",
            "    if not tail:",
            "        head, tail = path.split(head)",
            "    if head and tail and not path.exists(head):",
            "        try:",
            "            makedirs_perms(head, user, group, mode)",
            "        except OSError as exc:",
            "            # be happy if someone already created the path",
            "            if exc.errno != errno.EEXIST:",
            "                raise",
            "        if tail == os.curdir:  # xxx/newdir/. exists if xxx/newdir exists",
            "            return",
            "    os.mkdir(name)",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "",
            "",
            "def get_devmm(name):",
            "    '''",
            "    Get major/minor info from a device",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.get_devmm /dev/chr",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    if is_chrdev(name) or is_blkdev(name):",
            "        stat_structure = os.stat(name)",
            "        return (",
            "                os.major(stat_structure.st_rdev),",
            "                os.minor(stat_structure.st_rdev))",
            "    else:",
            "        return (0, 0)",
            "",
            "",
            "def is_chrdev(name):",
            "    '''",
            "    Check if a file exists and is a character device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_chrdev /dev/chr",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    stat_structure = None",
            "    try:",
            "        stat_structure = os.stat(name)",
            "    except OSError as exc:",
            "        if exc.errno == errno.ENOENT:",
            "            # If the character device does not exist in the first place",
            "            return False",
            "        else:",
            "            raise",
            "    return stat.S_ISCHR(stat_structure.st_mode)",
            "",
            "",
            "def mknod_chrdev(name,",
            "                 major,",
            "                 minor,",
            "                 user=None,",
            "                 group=None,",
            "                 mode='0660'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a character device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.mknod_chrdev /dev/chr 180 31",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    log.debug('Creating character device name:{0} major:{1} minor:{2} mode:{3}'",
            "              .format(name, major, minor, mode))",
            "    try:",
            "        if __opts__['test']:",
            "            ret['changes'] = {'new': 'Character device {0} created.'.format(name)}",
            "            ret['result'] = None",
            "        else:",
            "            if os.mknod(name,",
            "                        int(str(mode).lstrip('0Oo'), 8) | stat.S_IFCHR,",
            "                        os.makedev(major, minor)) is None:",
            "                ret['changes'] = {'new': 'Character device {0} created.'.format(name)}",
            "                ret['result'] = True",
            "    except OSError as exc:",
            "        # be happy it is already there....however, if you are trying to change the",
            "        # major/minor, you will need to unlink it first as os.mknod will not overwrite",
            "        if exc.errno != errno.EEXIST:",
            "            raise",
            "        else:",
            "            ret['comment'] = 'File {0} exists and cannot be overwritten'.format(name)",
            "    # quick pass at verifying the permissions of the newly created character device",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "    return ret",
            "",
            "",
            "def is_blkdev(name):",
            "    '''",
            "    Check if a file exists and is a block device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_blkdev /dev/blk",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    stat_structure = None",
            "    try:",
            "        stat_structure = os.stat(name)",
            "    except OSError as exc:",
            "        if exc.errno == errno.ENOENT:",
            "            # If the block device does not exist in the first place",
            "            return False",
            "        else:",
            "            raise",
            "    return stat.S_ISBLK(stat_structure.st_mode)",
            "",
            "",
            "def mknod_blkdev(name,",
            "                 major,",
            "                 minor,",
            "                 user=None,",
            "                 group=None,",
            "                 mode='0660'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a block device.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.mknod_blkdev /dev/blk 8 999",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    log.debug('Creating block device name:{0} major:{1} minor:{2} mode:{3}'",
            "              .format(name, major, minor, mode))",
            "    try:",
            "        if __opts__['test']:",
            "            ret['changes'] = {'new': 'Block device {0} created.'.format(name)}",
            "            ret['result'] = None",
            "        else:",
            "            if os.mknod(name,",
            "                        int(str(mode).lstrip('0Oo'), 8) | stat.S_IFBLK,",
            "                        os.makedev(major, minor)) is None:",
            "                ret['changes'] = {'new': 'Block device {0} created.'.format(name)}",
            "                ret['result'] = True",
            "    except OSError as exc:",
            "        # be happy it is already there....however, if you are trying to change the",
            "        # major/minor, you will need to unlink it first as os.mknod will not overwrite",
            "        if exc.errno != errno.EEXIST:",
            "            raise",
            "        else:",
            "            ret['comment'] = 'File {0} exists and cannot be overwritten'.format(name)",
            "    # quick pass at verifying the permissions of the newly created block device",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "    return ret",
            "",
            "",
            "def is_fifo(name):",
            "    '''",
            "    Check if a file exists and is a FIFO.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.is_fifo /dev/fifo",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    stat_structure = None",
            "    try:",
            "        stat_structure = os.stat(name)",
            "    except OSError as exc:",
            "        if exc.errno == errno.ENOENT:",
            "            # If the fifo does not exist in the first place",
            "            return False",
            "        else:",
            "            raise",
            "    return stat.S_ISFIFO(stat_structure.st_mode)",
            "",
            "",
            "def mknod_fifo(name,",
            "               user=None,",
            "               group=None,",
            "               mode='0660'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a FIFO pipe.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "       salt '*' file.mknod_fifo /dev/fifo",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    log.debug('Creating FIFO name: {0}'.format(name))",
            "    try:",
            "        if __opts__['test']:",
            "            ret['changes'] = {'new': 'Fifo pipe {0} created.'.format(name)}",
            "            ret['result'] = None",
            "        else:",
            "            if os.mkfifo(name, int(str(mode).lstrip('0Oo'), 8)) is None:",
            "                ret['changes'] = {'new': 'Fifo pipe {0} created.'.format(name)}",
            "                ret['result'] = True",
            "    except OSError as exc:",
            "        # be happy it is already there",
            "        if exc.errno != errno.EEXIST:",
            "            raise",
            "        else:",
            "            ret['comment'] = 'File {0} exists and cannot be overwritten'.format(name)",
            "    # quick pass at verifying the permissions of the newly created fifo",
            "    check_perms(name,",
            "                None,",
            "                user,",
            "                group,",
            "                int('{0}'.format(mode)) if mode else None)",
            "    return ret",
            "",
            "",
            "def mknod(name,",
            "          ntype,",
            "          major=0,",
            "          minor=0,",
            "          user=None,",
            "          group=None,",
            "          mode='0600'):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Create a block device, character device, or fifo pipe.",
            "    Identical to the gnu mknod.",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.mknod /dev/chr c 180 31",
            "        salt '*' file.mknod /dev/blk b 8 999",
            "        salt '*' file.nknod /dev/fifo p",
            "    '''",
            "    ret = False",
            "    makedirs_(name, user, group)",
            "    if ntype == 'c':",
            "        ret = mknod_chrdev(name, major, minor, user, group, mode)",
            "    elif ntype == 'b':",
            "        ret = mknod_blkdev(name, major, minor, user, group, mode)",
            "    elif ntype == 'p':",
            "        ret = mknod_fifo(name, user, group, mode)",
            "    else:",
            "        raise SaltInvocationError(",
            "            'Node type unavailable: \\'{0}\\'. Available node types are '",
            "            'character (\\'c\\'), block (\\'b\\'), and pipe (\\'p\\').'.format(ntype)",
            "        )",
            "    return ret",
            "",
            "",
            "def list_backups(path, limit=None):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Lists the previous versions of a file backed up using Salt's :ref:`file",
            "    state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The path on the minion to check for backups",
            "    limit",
            "        Limit the number of results to the most recent N backups",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.list_backups /foo/bar/baz.txt",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    try:",
            "        limit = int(limit)",
            "    except TypeError:",
            "        pass",
            "    except ValueError:",
            "        log.error('file.list_backups: \\'limit\\' value must be numeric')",
            "        limit = None",
            "",
            "    bkroot = _get_bkroot()",
            "    parent_dir, basename = os.path.split(path)",
            "    if salt.utils.is_windows():",
            "        # ':' is an illegal filesystem path character on Windows",
            "        src_dir = parent_dir.replace(':', '_')",
            "    else:",
            "        src_dir = parent_dir[1:]",
            "    # Figure out full path of location of backup file in minion cache",
            "    bkdir = os.path.join(bkroot, src_dir)",
            "",
            "    if not os.path.isdir(bkdir):",
            "        return {}",
            "",
            "    files = {}",
            "    for fname in [x for x in os.listdir(bkdir)",
            "                  if os.path.isfile(os.path.join(bkdir, x))]:",
            "        if salt.utils.is_windows():",
            "            # ':' is an illegal filesystem path character on Windows",
            "            strpfmt = '{0}_%a_%b_%d_%H-%M-%S_%f_%Y'.format(basename)",
            "        else:",
            "            strpfmt = '{0}_%a_%b_%d_%H:%M:%S_%f_%Y'.format(basename)",
            "        try:",
            "            timestamp = datetime.datetime.strptime(fname, strpfmt)",
            "        except ValueError:",
            "            # File didn't match the strp format string, so it's not a backup",
            "            # for this file. Move on to the next one.",
            "            continue",
            "        if salt.utils.is_windows():",
            "            str_format = '%a %b %d %Y %H-%M-%S.%f'",
            "        else:",
            "            str_format = '%a %b %d %Y %H:%M:%S.%f'",
            "        files.setdefault(timestamp, {})['Backup Time'] = \\",
            "            timestamp.strftime(str_format)",
            "        location = os.path.join(bkdir, fname)",
            "        files[timestamp]['Size'] = os.stat(location).st_size",
            "        files[timestamp]['Location'] = location",
            "",
            "    return dict(list(zip(",
            "        list(range(len(files))),",
            "        [files[x] for x in sorted(files, reverse=True)[:limit]]",
            "    )))",
            "",
            "list_backup = salt.utils.alias_function(list_backups, 'list_backup')",
            "",
            "",
            "def list_backups_dir(path, limit=None):",
            "    '''",
            "    Lists the previous versions of a directory backed up using Salt's :ref:`file",
            "    state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The directory on the minion to check for backups",
            "    limit",
            "        Limit the number of results to the most recent N backups",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.list_backups_dir /foo/bar/baz/",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    try:",
            "        limit = int(limit)",
            "    except TypeError:",
            "        pass",
            "    except ValueError:",
            "        log.error('file.list_backups_dir: \\'limit\\' value must be numeric')",
            "        limit = None",
            "",
            "    bkroot = _get_bkroot()",
            "    parent_dir, basename = os.path.split(path)",
            "    # Figure out full path of location of backup folder in minion cache",
            "    bkdir = os.path.join(bkroot, parent_dir[1:])",
            "",
            "    if not os.path.isdir(bkdir):",
            "        return {}",
            "",
            "    files = {}",
            "    f = dict([(i, len(list(n))) for i, n in itertools.groupby([x.split(\"_\")[0] for x in sorted(os.listdir(bkdir))])])",
            "    ff = os.listdir(bkdir)",
            "    for i, n in six.iteritems(f):",
            "        ssfile = {}",
            "        for x in sorted(ff):",
            "            basename = x.split('_')[0]",
            "            if i == basename:",
            "                strpfmt = '{0}_%a_%b_%d_%H:%M:%S_%f_%Y'.format(basename)",
            "                try:",
            "                    timestamp = datetime.datetime.strptime(x, strpfmt)",
            "                except ValueError:",
            "                    # Folder didn't match the strp format string, so it's not a backup",
            "                    # for this folder. Move on to the next one.",
            "                    continue",
            "                ssfile.setdefault(timestamp, {})['Backup Time'] = \\",
            "                    timestamp.strftime('%a %b %d %Y %H:%M:%S.%f')",
            "                location = os.path.join(bkdir, x)",
            "                ssfile[timestamp]['Size'] = os.stat(location).st_size",
            "                ssfile[timestamp]['Location'] = location",
            "",
            "        sfiles = dict(list(zip(list(range(n)), [ssfile[x] for x in sorted(ssfile, reverse=True)[:limit]])))",
            "        sefiles = {i: sfiles}",
            "        files.update(sefiles)",
            "    return files",
            "",
            "",
            "def restore_backup(path, backup_id):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Restore a previous version of a file that was backed up using Salt's",
            "    :ref:`file state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The path on the minion to check for backups",
            "    backup_id",
            "        The numeric id for the backup you wish to restore, as found using",
            "        :mod:`file.list_backups <salt.modules.file.list_backups>`",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.restore_backup /foo/bar/baz.txt 0",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    # Note: This only supports minion backups, so this function will need to be",
            "    # modified if/when master backups are implemented.",
            "    ret = {'result': False,",
            "           'comment': 'Invalid backup_id \\'{0}\\''.format(backup_id)}",
            "    try:",
            "        if len(str(backup_id)) == len(str(int(backup_id))):",
            "            backup = list_backups(path)[int(backup_id)]",
            "        else:",
            "            return ret",
            "    except ValueError:",
            "        return ret",
            "    except KeyError:",
            "        ret['comment'] = 'backup_id \\'{0}\\' does not exist for ' \\",
            "                         '{1}'.format(backup_id, path)",
            "        return ret",
            "",
            "    salt.utils.backup_minion(path, _get_bkroot())",
            "    try:",
            "        shutil.copyfile(backup['Location'], path)",
            "    except IOError as exc:",
            "        ret['comment'] = \\",
            "            'Unable to restore {0} to {1}: ' \\",
            "            '{2}'.format(backup['Location'], path, exc)",
            "        return ret",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'Successfully restored {0} to ' \\",
            "                         '{1}'.format(backup['Location'], path)",
            "",
            "    # Try to set proper ownership",
            "    if not salt.utils.is_windows():",
            "        try:",
            "            fstat = os.stat(path)",
            "        except (OSError, IOError):",
            "            ret['comment'] += ', but was unable to set ownership'",
            "        else:",
            "            os.chown(path, fstat.st_uid, fstat.st_gid)",
            "",
            "    return ret",
            "",
            "",
            "def delete_backup(path, backup_id):",
            "    '''",
            "    .. versionadded:: 0.17.0",
            "",
            "    Delete a previous version of a file that was backed up using Salt's",
            "    :ref:`file state backup <file-state-backups>` system.",
            "",
            "    path",
            "        The path on the minion to check for backups",
            "    backup_id",
            "        The numeric id for the backup you wish to delete, as found using",
            "        :mod:`file.list_backups <salt.modules.file.list_backups>`",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.delete_backup /var/cache/salt/minion/file_backup/home/foo/bar/baz.txt 0",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    ret = {'result': False,",
            "           'comment': 'Invalid backup_id \\'{0}\\''.format(backup_id)}",
            "    try:",
            "        if len(str(backup_id)) == len(str(int(backup_id))):",
            "            backup = list_backups(path)[int(backup_id)]",
            "        else:",
            "            return ret",
            "    except ValueError:",
            "        return ret",
            "    except KeyError:",
            "        ret['comment'] = 'backup_id \\'{0}\\' does not exist for ' \\",
            "                         '{1}'.format(backup_id, path)",
            "        return ret",
            "",
            "    try:",
            "        os.remove(backup['Location'])",
            "    except IOError as exc:",
            "        ret['comment'] = 'Unable to remove {0}: {1}'.format(backup['Location'],",
            "                                                            exc)",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'Successfully removed {0}'.format(backup['Location'])",
            "",
            "    return ret",
            "",
            "remove_backup = salt.utils.alias_function(delete_backup, 'remove_backup')",
            "",
            "",
            "def grep(path,",
            "         pattern,",
            "         *opts):",
            "    '''",
            "    Grep for a string in the specified file",
            "",
            "    .. note::",
            "        This function's return value is slated for refinement in future",
            "        versions of Salt",
            "",
            "    path",
            "        Path to the file to be searched",
            "",
            "        .. note::",
            "            Globbing is supported (i.e. ``/var/log/foo/*.log``, but if globbing",
            "            is being used then the path should be quoted to keep the shell from",
            "            attempting to expand the glob expression.",
            "",
            "    pattern",
            "        Pattern to match. For example: ``test``, or ``a[0-5]``",
            "",
            "    opts",
            "        Additional command-line flags to pass to the grep command. For example:",
            "        ``-v``, or ``-i -B2``",
            "",
            "        .. note::",
            "            The options should come after a double-dash (as shown in the",
            "            examples below) to keep Salt's own argument parser from",
            "            interpreting them.",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.grep /etc/passwd nobody",
            "        salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr -- -i",
            "        salt '*' file.grep /etc/sysconfig/network-scripts/ifcfg-eth0 ipaddr -- -i -B2",
            "        salt '*' file.grep \"/etc/sysconfig/network-scripts/*\" ipaddr -- -i -l",
            "    '''",
            "    path = os.path.expanduser(path)",
            "",
            "    split_opts = []",
            "    for opt in opts:",
            "        try:",
            "            split = salt.utils.shlex_split(opt)",
            "        except AttributeError:",
            "            split = salt.utils.shlex_split(str(opt))",
            "        if len(split) > 1:",
            "            raise SaltInvocationError(",
            "                'Passing multiple command line arguments in a single string '",
            "                'is not supported, please pass the following arguments '",
            "                'separately: {0}'.format(opt)",
            "            )",
            "        split_opts.extend(split)",
            "",
            "    cmd = ['grep'] + split_opts + [pattern, path]",
            "    try:",
            "        ret = __salt__['cmd.run_all'](cmd, python_shell=False)",
            "    except (IOError, OSError) as exc:",
            "        raise CommandExecutionError(exc.strerror)",
            "",
            "    return ret",
            "",
            "",
            "def open_files(by_pid=False):",
            "    '''",
            "    Return a list of all physical open files on the system.",
            "",
            "    CLI Examples:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.open_files",
            "        salt '*' file.open_files by_pid=True",
            "    '''",
            "    # First we collect valid PIDs",
            "    pids = {}",
            "    procfs = os.listdir('/proc/')",
            "    for pfile in procfs:",
            "        try:",
            "            pids[int(pfile)] = []",
            "        except ValueError:",
            "            # Not a valid PID, move on",
            "            pass",
            "",
            "    # Then we look at the open files for each PID",
            "    files = {}",
            "    for pid in pids:",
            "        ppath = '/proc/{0}'.format(pid)",
            "        try:",
            "            tids = os.listdir('{0}/task'.format(ppath))",
            "        except OSError:",
            "            continue",
            "",
            "        # Collect the names of all of the file descriptors",
            "        fd_ = []",
            "",
            "        #try:",
            "        #    fd_.append(os.path.realpath('{0}/task/{1}exe'.format(ppath, tid)))",
            "        #except:",
            "        #    pass",
            "",
            "        for fpath in os.listdir('{0}/fd'.format(ppath)):",
            "            fd_.append('{0}/fd/{1}'.format(ppath, fpath))",
            "",
            "        for tid in tids:",
            "            try:",
            "                fd_.append(",
            "                    os.path.realpath('{0}/task/{1}/exe'.format(ppath, tid))",
            "                )",
            "            except OSError:",
            "                continue",
            "",
            "            for tpath in os.listdir('{0}/task/{1}/fd'.format(ppath, tid)):",
            "                fd_.append('{0}/task/{1}/fd/{2}'.format(ppath, tid, tpath))",
            "",
            "        fd_ = sorted(set(fd_))",
            "",
            "        # Loop through file descriptors and return useful data for each file",
            "        for fdpath in fd_:",
            "            # Sometimes PIDs and TIDs disappear before we can query them",
            "            try:",
            "                name = os.path.realpath(fdpath)",
            "                # Running stat on the file cuts out all of the sockets and",
            "                # deleted files from the list",
            "                os.stat(name)",
            "            except OSError:",
            "                continue",
            "",
            "            if name not in files:",
            "                files[name] = [pid]",
            "            else:",
            "                # We still want to know which PIDs are using each file",
            "                files[name].append(pid)",
            "                files[name] = sorted(set(files[name]))",
            "",
            "            pids[pid].append(name)",
            "            pids[pid] = sorted(set(pids[pid]))",
            "",
            "    if by_pid:",
            "        return pids",
            "    return files",
            "",
            "",
            "def pardir():",
            "    '''",
            "    Return the relative parent directory path symbol for underlying OS",
            "",
            "    .. versionadded:: 2014.7.0",
            "",
            "    This can be useful when constructing Salt Formulas.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {% set pardir = salt['file.pardir']() %}",
            "        {% set final_path = salt['file.join']('subdir', pardir, 'confdir') %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.pardir",
            "    '''",
            "    return os.path.pardir",
            "",
            "",
            "def normpath(path):",
            "    '''",
            "    Returns Normalize path, eliminating double slashes, etc.",
            "",
            "    .. versionadded:: 2015.5.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {%- from salt['file.normpath'](tpldir + '/../vars.jinja') import parent_vars %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.normpath 'a/b/c/..'",
            "    '''",
            "    return os.path.normpath(path)",
            "",
            "",
            "def basename(path):",
            "    '''",
            "    Returns the final component of a pathname",
            "",
            "    .. versionadded:: 2015.5.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {%- set filename = salt['file.basename'](source_file) %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.basename 'test/test.config'",
            "    '''",
            "    return os.path.basename(path)",
            "",
            "",
            "def dirname(path):",
            "    '''",
            "    Returns the directory component of a pathname",
            "",
            "    .. versionadded:: 2015.5.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting.",
            "",
            "    .. code-block:: jinja",
            "",
            "        {%- from salt['file.dirname'](tpldir) + '/vars.jinja' import parent_vars %}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.dirname 'test/path/filename.config'",
            "    '''",
            "    return os.path.dirname(path)",
            "",
            "",
            "def join(*args):",
            "    '''",
            "    Return a normalized file system path for the underlying OS",
            "",
            "    .. versionadded:: 2014.7.0",
            "",
            "    This can be useful at the CLI but is frequently useful when scripting",
            "    combining path variables:",
            "",
            "    .. code-block:: jinja",
            "",
            "        {% set www_root = '/var' %}",
            "        {% set app_dir = 'myapp' %}",
            "",
            "        myapp_config:",
            "          file:",
            "            - managed",
            "            - name: {{ salt['file.join'](www_root, app_dir, 'config.yaml') }}",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.join '/' 'usr' 'local' 'bin'",
            "    '''",
            "    return os.path.join(*args)",
            "",
            "",
            "def move(src, dst):",
            "    '''",
            "    Move a file or directory",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.move /path/to/src /path/to/dst",
            "    '''",
            "    src = os.path.expanduser(src)",
            "    dst = os.path.expanduser(dst)",
            "",
            "    if not os.path.isabs(src):",
            "        raise SaltInvocationError('Source path must be absolute.')",
            "",
            "    if not os.path.isabs(dst):",
            "        raise SaltInvocationError('Destination path must be absolute.')",
            "",
            "    ret = {",
            "        'result': True,",
            "        'comment': \"'{0}' moved to '{1}'\".format(src, dst),",
            "    }",
            "",
            "    try:",
            "        shutil.move(src, dst)",
            "    except (OSError, IOError) as exc:",
            "        raise CommandExecutionError(",
            "            \"Unable to move '{0}' to '{1}': {2}\".format(src, dst, exc)",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def diskusage(path):",
            "    '''",
            "    Recursively calculate disk usage of path and return it",
            "    in bytes",
            "",
            "    CLI Example:",
            "",
            "    .. code-block:: bash",
            "",
            "        salt '*' file.diskusage /path/to/check",
            "    '''",
            "",
            "    total_size = 0",
            "    seen = set()",
            "    if os.path.isfile(path):",
            "        stat_structure = os.stat(path)",
            "        ret = stat_structure.st_size",
            "        return ret",
            "",
            "    for dirpath, dirnames, filenames in os.walk(path):",
            "        for f in filenames:",
            "            fp = os.path.join(dirpath, f)",
            "",
            "            try:",
            "                stat_structure = os.stat(fp)",
            "            except OSError:",
            "                continue",
            "",
            "            if stat_structure.st_ino in seen:",
            "                continue",
            "",
            "            seen.add(stat_structure.st_ino)",
            "",
            "            total_size += stat_structure.st_size",
            "",
            "    ret = total_size",
            "    return ret"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4352": [
                "check_managed_changes"
            ],
            "4644": [
                "manage_file"
            ]
        },
        "addLocation": []
    },
    "salt/states/file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1336,
                "afterPatchRowNumber": 1336,
                "PatchRowcode": "             the ``contents`` options, setting the ``mode`` to ``keep`` is also"
            },
            "1": {
                "beforePatchRowNumber": 1337,
                "afterPatchRowNumber": 1337,
                "PatchRowcode": "             incompatible with the ``contents`` options."
            },
            "2": {
                "beforePatchRowNumber": 1338,
                "afterPatchRowNumber": 1338,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1339,
                "PatchRowcode": "+        .. note:: keep does not work with salt-ssh."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1340,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1341,
                "PatchRowcode": "+            As a consequence of how the files are transfered to the minion, and"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1342,
                "PatchRowcode": "+            the inability to connect back to the master with salt-ssh, salt is"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1343,
                "PatchRowcode": "+            unable to stat the file as it exists on the fileserver and thus"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1344,
                "PatchRowcode": "+            cannot mirror the mode on the salt-ssh minion"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1345,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 1339,
                "afterPatchRowNumber": 1346,
                "PatchRowcode": "     template"
            },
            "11": {
                "beforePatchRowNumber": 1340,
                "afterPatchRowNumber": 1347,
                "PatchRowcode": "         If this setting is applied, the named templating engine will be used to"
            },
            "12": {
                "beforePatchRowNumber": 1341,
                "afterPatchRowNumber": 1348,
                "PatchRowcode": "         render the downloaded file. The following templates are supported:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Operations on regular files, special files, directories, and symlinks",
            "=====================================================================",
            "",
            "Salt States can aggressively manipulate files on a system. There are a number",
            "of ways in which files can be managed.",
            "",
            "Regular files can be enforced with the :mod:`file.managed",
            "<salt.states.file.managed>` state. This state downloads files from the salt",
            "master and places them on the target system. Managed files can be rendered as a",
            "jinja, mako, or wempy template, adding a dynamic component to file management.",
            "An example of :mod:`file.managed <salt.states.file.managed>` which makes use of",
            "the jinja templating system would look like this:",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/http/conf/http.conf:",
            "      file.managed:",
            "        - source: salt://apache/http.conf",
            "        - user: root",
            "        - group: root",
            "        - mode: 644",
            "        - template: jinja",
            "        - defaults:",
            "            custom_var: \"default value\"",
            "            other_var: 123",
            "    {% if grains['os'] == 'Ubuntu' %}",
            "        - context:",
            "            custom_var: \"override\"",
            "    {% endif %}",
            "",
            "It is also possible to use the :mod:`py renderer <salt.renderers.py>` as a",
            "templating option. The template would be a Python script which would need to",
            "contain a function called ``run()``, which returns a string. All arguments",
            "to the state will be made available to the Python script as globals. The",
            "returned string will be the contents of the managed file. For example:",
            "",
            ".. code-block:: python",
            "",
            "    def run():",
            "        lines = ['foo', 'bar', 'baz']",
            "        lines.extend([source, name, user, context])  # Arguments as globals",
            "        return '\\\\n\\\\n'.join(lines)",
            "",
            ".. note::",
            "",
            "    The ``defaults`` and ``context`` arguments require extra indentation (four",
            "    spaces instead of the normal two) in order to create a nested dictionary.",
            "    :ref:`More information <nested-dict-indentation>`.",
            "",
            "If using a template, any user-defined template variables in the file defined in",
            "``source`` must be passed in using the ``defaults`` and/or ``context``",
            "arguments. The general best practice is to place default values in",
            "``defaults``, with conditional overrides going into ``context``, as seen above.",
            "",
            "The template will receive a variable ``custom_var``, which would be accessed in",
            "the template using ``{{ custom_var }}``. If the operating system is Ubuntu, the",
            "value of the variable ``custom_var`` would be *override*, otherwise it is the",
            "default *default value*",
            "",
            "The ``source`` parameter can be specified as a list. If this is done, then the",
            "first file to be matched will be the one that is used. This allows you to have",
            "a default file on which to fall back if the desired file does not exist on the",
            "salt fileserver. Here's an example:",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/foo.conf:",
            "      file.managed:",
            "        - source:",
            "          - salt://foo.conf.{{ grains['fqdn'] }}",
            "          - salt://foo.conf.fallback",
            "        - user: foo",
            "        - group: users",
            "        - mode: 644",
            "        - backup: minion",
            "",
            ".. note::",
            "",
            "    Salt supports backing up managed files via the backup option. For more",
            "    details on this functionality please review the",
            "    :ref:`backup_mode documentation <file-state-backups>`.",
            "",
            "The ``source`` parameter can also specify a file in another Salt environment.",
            "In this example ``foo.conf`` in the ``dev`` environment will be used instead.",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/foo.conf:",
            "      file.managed:",
            "        - source:",
            "          - salt://foo.conf?saltenv=dev",
            "        - user: foo",
            "        - group: users",
            "        - mode: '0644'",
            "",
            ".. warning::",
            "",
            "    When using a mode that includes a leading zero you must wrap the",
            "    value in single quotes. If the value is not wrapped in quotes it",
            "    will be read by YAML as an integer and evaluated as an octal.",
            "",
            "The ``names`` parameter, which is part of the state compiler, can be used to",
            "expand the contents of a single state declaration into multiple, single state",
            "declarations. Each item in the ``names`` list receives its own individual state",
            "``name`` and is converted into its own low-data structure. This is a convenient",
            "way to manage several files with similar attributes.",
            "",
            "There is more documentation about this feature in the",
            ":ref:`Names declaration<names-declaration>` section of the",
            " :ref:`Highstate docs<states-highstate>`.",
            "",
            "Special files can be managed via the ``mknod`` function. This function will",
            "create and enforce the permissions on a special file. The function supports the",
            "creation of character devices, block devices, and FIFO pipes. The function will",
            "create the directory structure up to the special file if it is needed on the",
            "minion. The function will not overwrite or operate on (change major/minor",
            "numbers) existing special files with the exception of user, group, and",
            "permissions. In most cases the creation of some special files require root",
            "permissions on the minion. This would require that the minion to be run as the",
            "root user. Here is an example of a character device:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/named/chroot/dev/random:",
            "      file.mknod:",
            "        - ntype: c",
            "        - major: 1",
            "        - minor: 8",
            "        - user: named",
            "        - group: named",
            "        - mode: 660",
            "",
            "Here is an example of a block device:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/named/chroot/dev/loop0:",
            "      file.mknod:",
            "        - ntype: b",
            "        - major: 7",
            "        - minor: 0",
            "        - user: named",
            "        - group: named",
            "        - mode: 660",
            "",
            "Here is an example of a fifo pipe:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/named/chroot/var/log/logfifo:",
            "      file.mknod:",
            "        - ntype: p",
            "        - user: named",
            "        - group: named",
            "        - mode: 660",
            "",
            "Directories can be managed via the ``directory`` function. This function can",
            "create and enforce the permissions on a directory. A directory statement will",
            "look like this:",
            "",
            ".. code-block:: yaml",
            "",
            "    /srv/stuff/substuf:",
            "      file.directory:",
            "        - user: fred",
            "        - group: users",
            "        - mode: 755",
            "        - makedirs: True",
            "",
            "If you need to enforce user and/or group ownership or permissions recursively",
            "on the directory's contents, you can do so by adding a ``recurse`` directive:",
            "",
            ".. code-block:: yaml",
            "",
            "    /srv/stuff/substuf:",
            "      file.directory:",
            "        - user: fred",
            "        - group: users",
            "        - mode: 755",
            "        - makedirs: True",
            "        - recurse:",
            "          - user",
            "          - group",
            "          - mode",
            "",
            "As a default, ``mode`` will resolve to ``dir_mode`` and ``file_mode``, to",
            "specify both directory and file permissions, use this form:",
            "",
            ".. code-block:: yaml",
            "",
            "    /srv/stuff/substuf:",
            "      file.directory:",
            "        - user: fred",
            "        - group: users",
            "        - file_mode: 744",
            "        - dir_mode: 755",
            "        - makedirs: True",
            "        - recurse:",
            "          - user",
            "          - group",
            "          - mode",
            "",
            "Symlinks can be easily created; the symlink function is very simple and only",
            "takes a few arguments:",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/grub.conf:",
            "      file.symlink:",
            "        - target: /boot/grub/grub.conf",
            "",
            "Recursive directory management can also be set via the ``recurse``",
            "function. Recursive directory management allows for a directory on the salt",
            "master to be recursively copied down to the minion. This is a great tool for",
            "deploying large code and configuration systems. A state using ``recurse``",
            "would look something like this:",
            "",
            ".. code-block:: yaml",
            "",
            "    /opt/code/flask:",
            "      file.recurse:",
            "        - source: salt://code/flask",
            "        - include_empty: True",
            "",
            "A more complex ``recurse`` example:",
            "",
            ".. code-block:: yaml",
            "",
            "    {% set site_user = 'testuser' %}",
            "    {% set site_name = 'test_site' %}",
            "    {% set project_name = 'test_proj' %}",
            "    {% set sites_dir = 'test_dir' %}",
            "",
            "    django-project:",
            "      file.recurse:",
            "        - name: {{ sites_dir }}/{{ site_name }}/{{ project_name }}",
            "        - user: {{ site_user }}",
            "        - dir_mode: 2775",
            "        - file_mode: '0644'",
            "        - template: jinja",
            "        - source: salt://project/templates_dir",
            "        - include_empty: True",
            "",
            "Retention scheduling can be applied to manage contents of backup directories.",
            "For example:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/backups/example_directory:",
            "      file.retention_schedule:",
            "        - strptime_format: example_name_%Y%m%dT%H%M%S.tar.bz2",
            "        - retain:",
            "            most_recent: 5",
            "            first_of_hour: 4",
            "            first_of_day: 14",
            "            first_of_week: 6",
            "            first_of_month: 6",
            "            first_of_year: all",
            "",
            "'''",
            "",
            "# Import python libs",
            "from __future__ import absolute_import",
            "import difflib",
            "import itertools",
            "import logging",
            "import os",
            "import shutil",
            "import sys",
            "import traceback",
            "from collections import Iterable, Mapping, defaultdict",
            "from datetime import datetime   # python3 problem in the making?",
            "",
            "# Import salt libs",
            "import salt.loader",
            "import salt.payload",
            "import salt.utils",
            "import salt.utils.dictupdate",
            "import salt.utils.templates",
            "import salt.utils.url",
            "from salt.utils.locales import sdecode",
            "from salt.exceptions import CommandExecutionError, SaltInvocationError",
            "",
            "# Import 3rd-party libs",
            "import salt.ext.six as six",
            "from salt.ext.six.moves import zip_longest",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "COMMENT_REGEX = r'^([[:space:]]*){0}[[:space:]]?'",
            "__NOT_FOUND = object()",
            "",
            "",
            "def _get_accumulator_filepath():",
            "    '''",
            "    Return accumulator data path.",
            "    '''",
            "    return os.path.join(salt.utils.get_accumulator_dir(__opts__['cachedir']),",
            "                        __instance_id__)",
            "",
            "",
            "def _load_accumulators():",
            "    def _deserialize(path):",
            "        serial = salt.payload.Serial(__opts__)",
            "        ret = {'accumulators': {}, 'accumulators_deps': {}}",
            "        try:",
            "            with salt.utils.fopen(path, 'rb') as f:",
            "                loaded = serial.load(f)",
            "                return loaded if loaded else ret",
            "        except (IOError, NameError):",
            "            # NameError is a msgpack error from salt-ssh",
            "            return ret",
            "",
            "    loaded = _deserialize(_get_accumulator_filepath())",
            "",
            "    return loaded['accumulators'], loaded['accumulators_deps']",
            "",
            "",
            "def _persist_accummulators(accumulators, accumulators_deps):",
            "    accumm_data = {'accumulators': accumulators,",
            "                   'accumulators_deps': accumulators_deps}",
            "",
            "    serial = salt.payload.Serial(__opts__)",
            "    try:",
            "        with salt.utils.fopen(_get_accumulator_filepath(), 'w+b') as f:",
            "            serial.dump(accumm_data, f)",
            "    except NameError:",
            "        # msgpack error from salt-ssh",
            "        pass",
            "",
            "",
            "def _check_user(user, group):",
            "    '''",
            "    Checks if the named user and group are present on the minion",
            "    '''",
            "    err = ''",
            "    if user:",
            "        uid = __salt__['file.user_to_uid'](user)",
            "        if uid == '':",
            "            err += 'User {0} is not available '.format(user)",
            "    if group:",
            "        gid = __salt__['file.group_to_gid'](group)",
            "        if gid == '':",
            "            err += 'Group {0} is not available'.format(group)",
            "    return err",
            "",
            "",
            "def _gen_keep_files(name, require, walk_d=None):",
            "    '''",
            "    Generate the list of files that need to be kept when a dir based function",
            "    like directory or recurse has a clean.",
            "    '''",
            "    def _is_child(path, directory):",
            "        '''",
            "        Check whether ``path`` is child of ``directory``",
            "        '''",
            "        path = os.path.abspath(path)",
            "        directory = os.path.abspath(directory)",
            "",
            "        relative = os.path.relpath(path, directory)",
            "",
            "        return not relative.startswith(os.pardir)",
            "",
            "    def _add_current_path(path):",
            "        _ret = set()",
            "        if os.path.isdir(path):",
            "            dirs, files = walk_d.get(path, ((), ()))",
            "            _ret.add(path)",
            "            for _name in files:",
            "                _ret.add(os.path.join(path, _name))",
            "            for _name in dirs:",
            "                _ret.add(os.path.join(path, _name))",
            "        return _ret",
            "",
            "    def _process_by_walk_d(name, ret):",
            "        if os.path.isdir(name):",
            "            walk_ret.update(_add_current_path(name))",
            "            dirs, _ = walk_d.get(name, ((), ()))",
            "            for _d in dirs:",
            "                p = os.path.join(name, _d)",
            "                walk_ret.update(_add_current_path(p))",
            "                _process_by_walk_d(p, ret)",
            "",
            "    def _process(name):",
            "        ret = set()",
            "        if os.path.isdir(name):",
            "            for root, dirs, files in os.walk(name):",
            "                ret.add(name)",
            "                for name in files:",
            "                    ret.add(os.path.join(root, name))",
            "                for name in dirs:",
            "                    ret.add(os.path.join(root, name))",
            "        return ret",
            "",
            "    keep = set()",
            "    if isinstance(require, list):",
            "        required_files = [comp for comp in require if 'file' in comp]",
            "        for comp in required_files:",
            "            for low in __lowstate__:",
            "                # A requirement should match either the ID and the name of",
            "                # another state.",
            "                if low['name'] == comp['file'] or low['__id__'] == comp['file']:",
            "                    fn = low['name']",
            "                    if os.path.isdir(fn):",
            "                        if _is_child(fn, name):",
            "                            if walk_d:",
            "                                walk_ret = set()",
            "                                _process_by_walk_d(fn, walk_ret)",
            "                                keep.update(walk_ret)",
            "                            else:",
            "                                keep.update(_process(fn))",
            "                    else:",
            "                        keep.add(fn)",
            "    return list(keep)",
            "",
            "",
            "def _check_file(name):",
            "    ret = True",
            "    msg = ''",
            "",
            "    if not os.path.isabs(name):",
            "        ret = False",
            "        msg = 'Specified file {0} is not an absolute path'.format(name)",
            "    elif not os.path.exists(name):",
            "        ret = False",
            "        msg = '{0}: file not found'.format(name)",
            "",
            "    return ret, msg",
            "",
            "",
            "def _clean_dir(root, keep, exclude_pat):",
            "    '''",
            "    Clean out all of the files and directories in a directory (root) while",
            "    preserving the files in a list (keep) and part of exclude_pat",
            "    '''",
            "    removed = set()",
            "    real_keep = set()",
            "    real_keep.add(root)",
            "    if isinstance(keep, list):",
            "        for fn_ in keep:",
            "            if not os.path.isabs(fn_):",
            "                continue",
            "            real_keep.add(fn_)",
            "            while True:",
            "                fn_ = os.path.dirname(fn_)",
            "                real_keep.add(fn_)",
            "                if fn_ in ['/', ''.join([os.path.splitdrive(fn_)[0], '\\\\\\\\'])]:",
            "                    break",
            "",
            "    def _delete_not_kept(nfn):",
            "        if nfn not in real_keep:",
            "            # -- check if this is a part of exclude_pat(only). No need to",
            "            # check include_pat",
            "            if not salt.utils.check_include_exclude(",
            "                    os.path.relpath(nfn, root), None, exclude_pat):",
            "                return",
            "            removed.add(nfn)",
            "            if not __opts__['test']:",
            "                try:",
            "                    os.remove(nfn)",
            "                except OSError:",
            "                    __salt__['file.remove'](nfn)",
            "",
            "    for roots, dirs, files in os.walk(root):",
            "        for name in itertools.chain(dirs, files):",
            "            _delete_not_kept(os.path.join(roots, name))",
            "    return list(removed)",
            "",
            "",
            "def _error(ret, err_msg):",
            "    ret['result'] = False",
            "    ret['comment'] = err_msg",
            "    return ret",
            "",
            "",
            "def _check_directory(name,",
            "                     user,",
            "                     group,",
            "                     recurse,",
            "                     mode,",
            "                     clean,",
            "                     require,",
            "                     exclude_pat,",
            "                     max_depth=None):",
            "    '''",
            "    Check what changes need to be made on a directory",
            "    '''",
            "    changes = {}",
            "    if recurse or clean:",
            "        assert max_depth is None or not clean",
            "        # walk path only once and store the result",
            "        walk_l = list(_depth_limited_walk(name, max_depth))",
            "        # root: (dirs, files) structure, compatible for python2.6",
            "        walk_d = {}",
            "        for i in walk_l:",
            "            walk_d[i[0]] = (i[1], i[2])",
            "",
            "    if recurse:",
            "        try:",
            "            recurse_set = _get_recurse_set(recurse)",
            "        except (TypeError, ValueError) as exc:",
            "            return False, '{0}'.format(exc), changes",
            "        if 'user' not in recurse_set:",
            "            user = None",
            "        if 'group' not in recurse_set:",
            "            group = None",
            "        if 'mode' not in recurse_set:",
            "            mode = None",
            "        check_files = 'ignore_files' not in recurse_set",
            "        check_dirs = 'ignore_dirs' not in recurse_set",
            "        for root, dirs, files in walk_l:",
            "            if check_files:",
            "                for fname in files:",
            "                    fchange = {}",
            "                    path = os.path.join(root, fname)",
            "                    stats = __salt__['file.stats'](",
            "                        path, None, follow_symlinks=False",
            "                    )",
            "                    if user is not None and user != stats.get('user'):",
            "                        fchange['user'] = user",
            "                    if group is not None and group != stats.get('group'):",
            "                        fchange['group'] = group",
            "                    if fchange:",
            "                        changes[path] = fchange",
            "            if check_dirs:",
            "                for name_ in dirs:",
            "                    path = os.path.join(root, name_)",
            "                    fchange = _check_dir_meta(path, user, group, mode)",
            "                    if fchange:",
            "                        changes[path] = fchange",
            "    # Recurse skips root (we always do dirs, not root), so always check root:",
            "    fchange = _check_dir_meta(name, user, group, mode)",
            "    if fchange:",
            "        changes[name] = fchange",
            "    if clean:",
            "        keep = _gen_keep_files(name, require, walk_d)",
            "",
            "        def _check_changes(fname):",
            "            path = os.path.join(root, fname)",
            "            if path in keep:",
            "                return {}",
            "            else:",
            "                if not salt.utils.check_include_exclude(",
            "                        os.path.relpath(path, name), None, exclude_pat):",
            "                    return {}",
            "                else:",
            "                    return {path: {'removed': 'Removed due to clean'}}",
            "",
            "        for root, dirs, files in walk_l:",
            "            for fname in files:",
            "                changes.update(_check_changes(fname))",
            "            for name_ in dirs:",
            "                changes.update(_check_changes(name_))",
            "",
            "    if not os.path.isdir(name):",
            "        changes[name] = {'directory': 'new'}",
            "    if changes:",
            "        comments = ['The following files will be changed:\\n']",
            "        for fn_ in changes:",
            "            for key, val in six.iteritems(changes[fn_]):",
            "                comments.append('{0}: {1} - {2}\\n'.format(fn_, key, val))",
            "        return None, ''.join(comments), changes",
            "    return True, 'The directory {0} is in the correct state'.format(name), changes",
            "",
            "",
            "def _check_dir_meta(name,",
            "                    user,",
            "                    group,",
            "                    mode):",
            "    '''",
            "    Check the changes in directory metadata",
            "    '''",
            "    stats = __salt__['file.stats'](name, follow_symlinks=False)",
            "    changes = {}",
            "    if not stats:",
            "        changes['directory'] = 'new'",
            "        return changes",
            "    if (user is not None",
            "            and user != stats['user']",
            "            and user != stats.get('uid')):",
            "        changes['user'] = user",
            "    if (group is not None",
            "            and group != stats['group']",
            "            and group != stats.get('gid')):",
            "        changes['group'] = group",
            "    # Normalize the dir mode",
            "    smode = salt.utils.normalize_mode(stats['mode'])",
            "    mode = salt.utils.normalize_mode(mode)",
            "    if mode is not None and mode != smode:",
            "        changes['mode'] = mode",
            "    return changes",
            "",
            "",
            "def _check_touch(name, atime, mtime):",
            "    '''",
            "    Check to see if a file needs to be updated or created",
            "    '''",
            "    if not os.path.exists(name):",
            "        return None, 'File {0} is set to be created'.format(name)",
            "    stats = __salt__['file.stats'](name, follow_symlinks=False)",
            "    if atime is not None:",
            "        if str(atime) != str(stats['atime']):",
            "            return None, 'Times set to be updated on file {0}'.format(name)",
            "    if mtime is not None:",
            "        if str(mtime) != str(stats['mtime']):",
            "            return None, 'Times set to be updated on file {0}'.format(name)",
            "    return True, 'File {0} exists and has the correct times'.format(name)",
            "",
            "",
            "def _get_symlink_ownership(path):",
            "    return (",
            "        __salt__['file.get_user'](path, follow_symlinks=False),",
            "        __salt__['file.get_group'](path, follow_symlinks=False)",
            "    )",
            "",
            "",
            "def _check_symlink_ownership(path, user, group):",
            "    '''",
            "    Check if the symlink ownership matches the specified user and group",
            "    '''",
            "    cur_user, cur_group = _get_symlink_ownership(path)",
            "    return (cur_user == user) and (cur_group == group)",
            "",
            "",
            "def _set_symlink_ownership(path, user, group):",
            "    '''",
            "    Set the ownership of a symlink and return a boolean indicating",
            "    success/failure",
            "    '''",
            "    try:",
            "        __salt__['file.lchown'](path, user, group)",
            "    except OSError:",
            "        pass",
            "    return _check_symlink_ownership(path, user, group)",
            "",
            "",
            "def _symlink_check(name, target, force, user, group):",
            "    '''",
            "    Check the symlink function",
            "    '''",
            "    pchanges = {}",
            "    if not os.path.exists(name) and not __salt__['file.is_link'](name):",
            "        pchanges['new'] = name",
            "        return None, 'Symlink {0} to {1} is set for creation'.format(",
            "            name, target",
            "        ), pchanges",
            "    if __salt__['file.is_link'](name):",
            "        if __salt__['file.readlink'](name) != target:",
            "            pchanges['change'] = name",
            "            return None, 'Link {0} target is set to be changed to {1}'.format(",
            "                name, target",
            "            ), pchanges",
            "        else:",
            "            result = True",
            "            msg = 'The symlink {0} is present'.format(name)",
            "            if not _check_symlink_ownership(name, user, group):",
            "                result = None",
            "                pchanges['ownership'] = '{0}:{1}'.format(*_get_symlink_ownership(name))",
            "                msg += (",
            "                    ', but the ownership of the symlink would be changed '",
            "                    'from {2}:{3} to {0}:{1}'",
            "                ).format(user, group, *_get_symlink_ownership(name))",
            "            return result, msg, pchanges",
            "    else:",
            "        if force:",
            "            return None, ('The file or directory {0} is set for removal to '",
            "                          'make way for a new symlink targeting {1}'",
            "                          .format(name, target)), pchanges",
            "        return False, ('File or directory exists where the symlink {0} '",
            "                       'should be. Did you mean to use force?'.format(name)), pchanges",
            "",
            "",
            "def _test_owner(kwargs, user=None):",
            "    '''",
            "    Convert owner to user, since other config management tools use owner,",
            "    no need to punish people coming from other systems.",
            "    PLEASE DO NOT DOCUMENT THIS! WE USE USER, NOT OWNER!!!!",
            "    '''",
            "    if user:",
            "        return user",
            "    if 'owner' in kwargs:",
            "        log.warning(",
            "            'Use of argument owner found, \"owner\" is invalid, please '",
            "            'use \"user\"'",
            "        )",
            "        return kwargs['owner']",
            "",
            "    return user",
            "",
            "",
            "def _unify_sources_and_hashes(source=None, source_hash=None,",
            "                              sources=None, source_hashes=None):",
            "    '''",
            "    Silly little function to give us a standard tuple list for sources and",
            "    source_hashes",
            "    '''",
            "    if sources is None:",
            "        sources = []",
            "",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    if source and sources:",
            "        return (False,",
            "                \"source and sources are mutually exclusive\", [])",
            "",
            "    if source_hash and source_hashes:",
            "        return (False,",
            "                \"source_hash and source_hashes are mutually exclusive\", [])",
            "",
            "    if source:",
            "        return (True, '', [(source, source_hash)])",
            "",
            "    # Make a nice neat list of tuples exactly len(sources) long..",
            "    return True, '', list(zip_longest(sources, source_hashes[:len(sources)]))",
            "",
            "",
            "def _get_template_texts(source_list=None,",
            "                        template='jinja',",
            "                        defaults=None,",
            "                        context=None,",
            "                        **kwargs):",
            "    '''",
            "    Iterate a list of sources and process them as templates.",
            "    Returns a list of 'chunks' containing the rendered templates.",
            "    '''",
            "",
            "    ret = {'name': '_get_template_texts',",
            "           'changes': {},",
            "           'result': True,",
            "           'comment': '',",
            "           'data': []}",
            "",
            "    if source_list is None:",
            "        return _error(ret,",
            "                      '_get_template_texts called with empty source_list')",
            "",
            "    txtl = []",
            "",
            "    for (source, source_hash) in source_list:",
            "",
            "        tmpctx = defaults if defaults else {}",
            "        if context:",
            "            tmpctx.update(context)",
            "        rndrd_templ_fn = __salt__['cp.get_template'](",
            "            source,",
            "            '',",
            "            template=template,",
            "            saltenv=__env__,",
            "            context=tmpctx,",
            "            **kwargs",
            "        )",
            "        msg = 'cp.get_template returned {0} (Called with: {1})'",
            "        log.debug(msg.format(rndrd_templ_fn, source))",
            "        if rndrd_templ_fn:",
            "            tmplines = None",
            "            with salt.utils.fopen(rndrd_templ_fn, 'rb') as fp_:",
            "                tmplines = fp_.readlines()",
            "            if not tmplines:",
            "                msg = 'Failed to read rendered template file {0} ({1})'",
            "                log.debug(msg.format(rndrd_templ_fn, source))",
            "                ret['name'] = source",
            "                return _error(ret, msg.format(rndrd_templ_fn, source))",
            "            txtl.append(''.join(tmplines))",
            "        else:",
            "            msg = 'Failed to load template file {0}'.format(source)",
            "            log.debug(msg)",
            "            ret['name'] = source",
            "            return _error(ret, msg)",
            "",
            "    ret['data'] = txtl",
            "    return ret",
            "",
            "",
            "def _validate_str_list(arg):",
            "    '''",
            "    ensure ``arg`` is a list of strings",
            "    '''",
            "    if isinstance(arg, six.string_types):",
            "        ret = [arg]",
            "    elif isinstance(arg, Iterable) and not isinstance(arg, Mapping):",
            "        ret = []",
            "        for item in arg:",
            "            if isinstance(item, six.string_types):",
            "                ret.append(item)",
            "            else:",
            "                ret.append(str(item))",
            "    else:",
            "        ret = [str(arg)]",
            "    return ret",
            "",
            "",
            "def symlink(",
            "        name,",
            "        target,",
            "        force=False,",
            "        backupname=None,",
            "        makedirs=False,",
            "        user=None,",
            "        group=None,",
            "        mode=None,",
            "        **kwargs):",
            "    '''",
            "    Create a symbolic link (symlink, soft link)",
            "",
            "    If the file already exists and is a symlink pointing to any location other",
            "    than the specified target, the symlink will be replaced. If the symlink is",
            "    a regular file or directory then the state will return False. If the",
            "    regular file or directory is desired to be replaced with a symlink pass",
            "    force: True, if it is to be renamed, pass a backupname.",
            "",
            "    name",
            "        The location of the symlink to create",
            "",
            "    target",
            "        The location that the symlink points to",
            "",
            "    force",
            "        If the name of the symlink exists and is not a symlink and",
            "        force is set to False, the state will fail. If force is set to",
            "        True, the file or directory in the way of the symlink file",
            "        will be deleted to make room for the symlink, unless",
            "        backupname is set, when it will be renamed",
            "",
            "    backupname",
            "        If the name of the symlink exists and is not a symlink, it will be",
            "        renamed to the backupname. If the backupname already",
            "        exists and force is False, the state will fail. Otherwise, the",
            "        backupname will be removed first.",
            "",
            "    makedirs",
            "        If the location of the symlink does not already have a parent directory",
            "        then the state will fail, setting makedirs to True will allow Salt to",
            "        create the parent directory",
            "",
            "    user",
            "        The user to own the file, this defaults to the user salt is running as",
            "        on the minion",
            "",
            "    group",
            "        The group ownership set for the file, this defaults to the group salt",
            "        is running as on the minion. On Windows, this is ignored",
            "",
            "    mode",
            "        The permissions to set on this file, aka 644, 0775, 4664. Not supported",
            "        on Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    # Make sure that leading zeros stripped by YAML loader are added back",
            "    mode = salt.utils.normalize_mode(mode)",
            "",
            "    user = _test_owner(kwargs, user=user)",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.symlink')",
            "",
            "    if user is None:",
            "        user = __opts__['user']",
            "",
            "    if salt.utils.is_windows():",
            "",
            "        # Make sure the user exists in Windows",
            "        # Salt default is 'root'",
            "        if not __salt__['user.info'](user):",
            "            # User not found, use the account salt is running under",
            "            # If username not found, use System",
            "            user = __salt__['user.current']()",
            "            if not user:",
            "                user = 'SYSTEM'",
            "",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "",
            "    if group is None:",
            "        group = __salt__['file.gid_to_group'](",
            "            __salt__['user.info'](user).get('gid', 0)",
            "        )",
            "",
            "    preflight_errors = []",
            "    uid = __salt__['file.user_to_uid'](user)",
            "    gid = __salt__['file.group_to_gid'](group)",
            "",
            "    if uid == '':",
            "        preflight_errors.append('User {0} does not exist'.format(user))",
            "",
            "    if gid == '':",
            "        preflight_errors.append('Group {0} does not exist'.format(group))",
            "",
            "    if not os.path.isabs(name):",
            "        preflight_errors.append(",
            "            'Specified file {0} is not an absolute path'.format(name)",
            "        )",
            "",
            "    if preflight_errors:",
            "        msg = '. '.join(preflight_errors)",
            "        if len(preflight_errors) > 1:",
            "            msg += '.'",
            "        return _error(ret, msg)",
            "",
            "    presult, pcomment, ret['pchanges'] = _symlink_check(name,",
            "                                                        target,",
            "                                                        force,",
            "                                                        user,",
            "                                                        group)",
            "    if __opts__['test']:",
            "        ret['result'] = presult",
            "        ret['comment'] = pcomment",
            "        return ret",
            "",
            "    if not os.path.isdir(os.path.dirname(name)):",
            "        if makedirs:",
            "            __salt__['file.makedirs'](",
            "                name,",
            "                user=user,",
            "                group=group,",
            "                mode=mode)",
            "        else:",
            "            return _error(",
            "                ret,",
            "                'Directory {0} for symlink is not present'.format(",
            "                    os.path.dirname(name)",
            "                )",
            "            )",
            "    if __salt__['file.is_link'](name):",
            "        # The link exists, verify that it matches the target",
            "        if os.path.normpath(__salt__['file.readlink'](name)) != os.path.normpath(target):",
            "            # The target is wrong, delete the link",
            "            os.remove(name)",
            "        else:",
            "            if _check_symlink_ownership(name, user, group):",
            "                # The link looks good!",
            "                ret['comment'] = ('Symlink {0} is present and owned by '",
            "                                  '{1}:{2}'.format(name, user, group))",
            "            else:",
            "                if _set_symlink_ownership(name, user, group):",
            "                    ret['comment'] = ('Set ownership of symlink {0} to '",
            "                                      '{1}:{2}'.format(name, user, group))",
            "                    ret['changes']['ownership'] = '{0}:{1}'.format(user, group)",
            "                else:",
            "                    ret['result'] = False",
            "                    ret['comment'] += (",
            "                        'Failed to set ownership of symlink {0} to '",
            "                        '{1}:{2}'.format(name, user, group)",
            "                    )",
            "            return ret",
            "",
            "    elif os.path.isfile(name) or os.path.isdir(name):",
            "        # It is not a link, but a file or dir",
            "        if backupname is not None:",
            "            # Make a backup first",
            "            if os.path.lexists(backupname):",
            "                if not force:",
            "                    return _error(ret, ((",
            "                                            'File exists where the backup target {0} should go'",
            "                                        ).format(backupname)))",
            "                else:",
            "                    __salt__['file.remove'](backupname)",
            "            os.rename(name, backupname)",
            "        elif force:",
            "            # Remove whatever is in the way",
            "            if __salt__['file.is_link'](name):",
            "                __salt__['file.remove'](name)",
            "                ret['changes']['forced'] = 'Symlink was forcibly replaced'",
            "            else:",
            "                __salt__['file.remove'](name)",
            "        else:",
            "            # Otherwise throw an error",
            "            if os.path.isfile(name):",
            "                return _error(ret,",
            "                              ('File exists where the symlink {0} should be'",
            "                               .format(name)))",
            "            else:",
            "                return _error(ret, ((",
            "                                        'Directory exists where the symlink {0} should be'",
            "                                    ).format(name)))",
            "",
            "    if not os.path.exists(name):",
            "        # The link is not present, make it",
            "        try:",
            "            __salt__['file.symlink'](target, name)",
            "        except OSError as exc:",
            "            ret['result'] = False",
            "            ret['comment'] = ('Unable to create new symlink {0} -> '",
            "                              '{1}: {2}'.format(name, target, exc))",
            "            return ret",
            "        else:",
            "            ret['comment'] = ('Created new symlink {0} -> '",
            "                              '{1}'.format(name, target))",
            "            ret['changes']['new'] = name",
            "",
            "        if not _check_symlink_ownership(name, user, group):",
            "            if not _set_symlink_ownership(name, user, group):",
            "                ret['result'] = False",
            "                ret['comment'] += (', but was unable to set ownership to '",
            "                                   '{0}:{1}'.format(user, group))",
            "    return ret",
            "",
            "",
            "def absent(name):",
            "    '''",
            "    Make sure that the named file or directory is absent. If it exists, it will",
            "    be deleted. This will work to reverse any of the functions in the file",
            "    state module. If a directory is supplied, it will be recursively deleted.",
            "",
            "    name",
            "        The path which should be deleted",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.absent')",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name)",
            "        )",
            "    if name == '/':",
            "        return _error(ret, 'Refusing to make \"/\" absent')",
            "    if os.path.isfile(name) or os.path.islink(name):",
            "        ret['pchanges']['removed'] = name",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'File {0} is set for removal'.format(name)",
            "            return ret",
            "        try:",
            "            __salt__['file.remove'](name)",
            "            ret['comment'] = 'Removed file {0}'.format(name)",
            "            ret['changes']['removed'] = name",
            "            return ret",
            "        except CommandExecutionError as exc:",
            "            return _error(ret, '{0}'.format(exc))",
            "",
            "    elif os.path.isdir(name):",
            "        ret['pchanges']['removed'] = name",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Directory {0} is set for removal'.format(name)",
            "            return ret",
            "        try:",
            "            __salt__['file.remove'](name)",
            "            ret['comment'] = 'Removed directory {0}'.format(name)",
            "            ret['changes']['removed'] = name",
            "            return ret",
            "        except (OSError, IOError):",
            "            return _error(ret, 'Failed to remove directory {0}'.format(name))",
            "",
            "    ret['comment'] = 'File {0} is not present'.format(name)",
            "    return ret",
            "",
            "",
            "def exists(name):",
            "    '''",
            "    Verify that the named file or directory is present or exists.",
            "    Ensures pre-requisites outside of Salt's purview",
            "    (e.g., keytabs, private keys, etc.) have been previously satisfied before",
            "    deployment.",
            "",
            "    name",
            "        Absolute path which must exist",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.exists')",
            "    if not os.path.exists(name):",
            "        return _error(ret, 'Specified path {0} does not exist'.format(name))",
            "",
            "    ret['comment'] = 'Path {0} exists'.format(name)",
            "    return ret",
            "",
            "",
            "def missing(name):",
            "    '''",
            "    Verify that the named file or directory is missing, this returns True only",
            "    if the named file is missing but does not remove the file if it is present.",
            "",
            "    name",
            "        Absolute path which must NOT exist",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.missing')",
            "    if os.path.exists(name):",
            "        return _error(ret, 'Specified path {0} exists'.format(name))",
            "",
            "    ret['comment'] = 'Path {0} is missing'.format(name)",
            "    return ret",
            "",
            "",
            "def managed(name,",
            "            source=None,",
            "            source_hash='',",
            "            source_hash_name=None,",
            "            user=None,",
            "            group=None,",
            "            mode=None,",
            "            template=None,",
            "            makedirs=False,",
            "            dir_mode=None,",
            "            context=None,",
            "            replace=True,",
            "            defaults=None,",
            "            backup='',",
            "            show_changes=True,",
            "            create=True,",
            "            contents=None,",
            "            tmp_ext='',",
            "            contents_pillar=None,",
            "            contents_grains=None,",
            "            contents_newline=True,",
            "            contents_delimiter=':',",
            "            allow_empty=True,",
            "            follow_symlinks=True,",
            "            check_cmd=None,",
            "            skip_verify=False,",
            "            **kwargs):",
            "    '''",
            "    Manage a given file, this function allows for a file to be downloaded from",
            "    the salt master and potentially run through a templating system.",
            "",
            "    name",
            "        The location of the file to manage",
            "",
            "    source",
            "        The source file to download to the minion, this source file can be",
            "        hosted on either the salt master server (``salt://``), the salt minion",
            "        local file system (``/``), or on an HTTP or FTP server (``http(s)://``,",
            "        ``ftp://``).",
            "",
            "        Both HTTPS and HTTP are supported as well as downloading directly",
            "        from Amazon S3 compatible URLs with both pre-configured and automatic",
            "        IAM credentials. (see s3.get state documentation)",
            "        File retrieval from Openstack Swift object storage is supported via",
            "        swift://container/object_path URLs, see swift.get documentation.",
            "        For files hosted on the salt file server, if the file is located on",
            "        the master in the directory named spam, and is called eggs, the source",
            "        string is salt://spam/eggs. If source is left blank or None",
            "        (use ~ in YAML), the file will be created as an empty file and",
            "        the content will not be managed. This is also the case when a file",
            "        already exists and the source is undefined; the contents of the file",
            "        will not be changed or managed.",
            "",
            "        If the file is hosted on a HTTP or FTP server then the source_hash",
            "        argument is also required.",
            "",
            "        A list of sources can also be passed in to provide a default source and",
            "        a set of fallbacks. The first source in the list that is found to exist",
            "        will be used and subsequent entries in the list will be ignored. Source",
            "        list functionality only supports local files and remote files hosted on",
            "        the salt master server or retrievable via HTTP, HTTPS, or FTP.",
            "",
            "        .. code-block:: yaml",
            "",
            "            file_override_example:",
            "              file.managed:",
            "                - source:",
            "                  - salt://file_that_does_not_exist",
            "                  - salt://file_that_exists",
            "",
            "    source_hash",
            "        This can be one of the following:",
            "            1. a source hash string",
            "            2. the URI of a file that contains source hash strings",
            "",
            "        The function accepts the first encountered long unbroken alphanumeric",
            "        string of correct length as a valid hash, in order from most secure to",
            "        least secure:",
            "",
            "        .. code-block:: text",
            "",
            "            Type    Length",
            "            ======  ======",
            "            sha512     128",
            "            sha384      96",
            "            sha256      64",
            "            sha224      56",
            "            sha1        40",
            "            md5         32",
            "",
            "        **Using a Source Hash File**",
            "            The file can contain several checksums for several files. Each line",
            "            must contain both the file name and the hash.  If no file name is",
            "            matched, the first hash encountered will be used, otherwise the most",
            "            secure hash with the correct source file name will be used.",
            "",
            "            When using a source hash file the source_hash argument needs to be a",
            "            url, the standard download urls are supported, ftp, http, salt etc:",
            "",
            "            Example:",
            "",
            "            .. code-block:: yaml",
            "",
            "                tomdroid-src-0.7.3.tar.gz:",
            "                  file.managed:",
            "                    - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                    - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.hash",
            "",
            "            The following lines are all supported formats:",
            "",
            "            .. code-block:: text",
            "",
            "                /etc/rc.conf ef6e82e4006dee563d98ada2a2a80a27",
            "                sha254c8525aee419eb649f0233be91c151178b30f0dff8ebbdcc8de71b1d5c8bcc06a  /etc/resolv.conf",
            "                ead48423703509d37c4a90e6a0d53e143b6fc268",
            "",
            "            Debian file type ``*.dsc`` files are also supported.",
            "",
            "        **Inserting the Source Hash in the SLS Data**",
            "",
            "        The source_hash can be specified as a simple checksum, like so:",
            "",
            "        .. code-block:: yaml",
            "",
            "            tomdroid-src-0.7.3.tar.gz:",
            "              file.managed:",
            "                - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                - source_hash: 79eef25f9b0b2c642c62b7f737d4f53f",
            "",
            "        .. note::",
            "            Releases prior to 2016.11.0 must also include the hash type, like",
            "            in the below example:",
            "",
            "            .. code-block:: yaml",
            "",
            "                tomdroid-src-0.7.3.tar.gz:",
            "                  file.managed:",
            "                    - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                    - source_hash: md5=79eef25f9b0b2c642c62b7f737d4f53f",
            "",
            "        Known issues:",
            "            If the remote server URL has the hash file as an apparent",
            "            sub-directory of the source file, the module will discover that it",
            "            has already cached a directory where a file should be cached. For",
            "            example:",
            "",
            "            .. code-block:: yaml",
            "",
            "                tomdroid-src-0.7.3.tar.gz:",
            "                  file.managed:",
            "                    - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                    - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz/+md5",
            "",
            "    source_hash_name",
            "        When ``source_hash`` refers to a hash file, Salt will try to find the",
            "        correct hash by matching the filename/URI associated with that hash. By",
            "        default, Salt will look for the filename being managed. When managing a",
            "        file at path ``/tmp/foo.txt``, then the following line in a hash file",
            "        would match:",
            "",
            "        .. code-block:: text",
            "",
            "            acbd18db4cc2f85cedef654fccc4a4d8    foo.txt",
            "",
            "        However, sometimes a hash file will include multiple similar paths:",
            "",
            "        .. code-block:: text",
            "",
            "            37b51d194a7513e45b56f6524f2d51f2    ./dir1/foo.txt",
            "            acbd18db4cc2f85cedef654fccc4a4d8    ./dir2/foo.txt",
            "            73feffa4b7f6bb68e44cf984c85f6e88    ./dir3/foo.txt",
            "",
            "        In cases like this, Salt may match the incorrect hash. This argument",
            "        can be used to tell Salt which filename to match, to ensure that the",
            "        correct hash is identified. For example:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /tmp/foo.txt:",
            "              file.managed:",
            "                - source: https://mydomain.tld/dir2/foo.txt",
            "                - source_hash: https://mydomain.tld/hashes",
            "                - source_hash_name: ./dir2/foo.txt",
            "",
            "        .. note::",
            "            This argument must contain the full filename entry from the",
            "            checksum file, as this argument is meant to disambiguate matches",
            "            for multiple files that have the same basename. So, in the",
            "            example above, simply using ``foo.txt`` would not match.",
            "",
            "        .. versionadded:: 2016.3.5",
            "",
            "    user",
            "        The user to own the file, this defaults to the user salt is running as",
            "        on the minion",
            "",
            "    group",
            "        The group ownership set for the file, this defaults to the group salt",
            "        is running as on the minion On Windows, this is ignored",
            "",
            "    mode",
            "        The permissions to set on this file, e.g. ``644``, ``0775``, or ``4664``.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "        .. versionchanged:: 2016.11.0",
            "            This option can be set to ``keep``, and Salt will keep the mode",
            "            from the Salt fileserver. This is only supported when the",
            "            ``source`` URL begins with ``salt://``, or for files local to the",
            "            minion. Because the ``source`` option cannot be used with any of",
            "            the ``contents`` options, setting the ``mode`` to ``keep`` is also",
            "            incompatible with the ``contents`` options.",
            "",
            "    template",
            "        If this setting is applied, the named templating engine will be used to",
            "        render the downloaded file. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "    makedirs : False",
            "        If set to ``True``, then the parent directories will be created to",
            "        facilitate the creation of the named file. If ``False``, and the parent",
            "        directory of the destination file doesn't exist, the state will fail.",
            "",
            "    dir_mode",
            "        If directories are to be created, passing this option specifies the",
            "        permissions for those directories. If this is not set, directories",
            "        will be assigned permissions by adding the execute bit to the mode of",
            "        the files.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    replace : True",
            "        If set to ``False`` and the file already exists, the file will not be",
            "        modified even if changes would otherwise be made. Permissions and",
            "        ownership will still be enforced, however.",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    backup",
            "        Overrides the default backup mode for this specific file. See",
            "        :ref:`backup_mode documentation <file-state-backups>` for more details.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made.",
            "",
            "    create : True",
            "        If set to ``False``, then the file will only be managed if the file",
            "        already exists on the system.",
            "",
            "    contents",
            "        Specify the contents of the file. Cannot be used in combination with",
            "        ``source``. Ignores hashes and does not use a templating engine.",
            "",
            "        This value can be either a single string, a multiline YAML string or a",
            "        list of strings.  If a list of strings, then the strings will be joined",
            "        together with newlines in the resulting file. For example, the below",
            "        two example states would result in identical file contents:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /path/to/file1:",
            "              file.managed:",
            "                - contents:",
            "                  - This is line 1",
            "                  - This is line 2",
            "",
            "            /path/to/file2:",
            "              file.managed:",
            "                - contents: |",
            "                    This is line 1",
            "                    This is line 2",
            "",
            "",
            "    contents_pillar",
            "        .. versionadded:: 0.17.0",
            "        .. versionchanged: 2016.11.0",
            "            contents_pillar can also be a list, and the pillars will be",
            "            concatinated together to form one file.",
            "",
            "",
            "        Operates like ``contents``, but draws from a value stored in pillar,",
            "        using the pillar path syntax used in :mod:`pillar.get",
            "        <salt.modules.pillar.get>`. This is useful when the pillar value",
            "        contains newlines, as referencing a pillar variable using a jinja/mako",
            "        template can result in YAML formatting issues due to the newlines",
            "        causing indentation mismatches.",
            "",
            "        For example, the following could be used to deploy an SSH private key:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /home/deployer/.ssh/id_rsa:",
            "              file.managed:",
            "                - user: deployer",
            "                - group: deployer",
            "                - mode: 600",
            "                - contents_pillar: userdata:deployer:id_rsa",
            "",
            "        This would populate ``/home/deployer/.ssh/id_rsa`` with the contents of",
            "        ``pillar['userdata']['deployer']['id_rsa']``. An example of this pillar",
            "        setup would be like so:",
            "",
            "        .. code-block:: yaml",
            "",
            "            userdata:",
            "              deployer:",
            "                id_rsa: |",
            "                    -----BEGIN RSA PRIVATE KEY-----",
            "                    MIIEowIBAAKCAQEAoQiwO3JhBquPAalQF9qP1lLZNXVjYMIswrMe2HcWUVBgh+vY",
            "                    U7sCwx/dH6+VvNwmCoqmNnP+8gTPKGl1vgAObJAnMT623dMXjVKwnEagZPRJIxDy",
            "                    B/HaAre9euNiY3LvIzBTWRSeMfT+rWvIKVBpvwlgGrfgz70m0pqxu+UyFbAGLin+",
            "                    GpxzZAMaFpZw4sSbIlRuissXZj/sHpQb8p9M5IeO4Z3rjkCP1cxI",
            "                    -----END RSA PRIVATE KEY-----",
            "",
            "        .. note::",
            "",
            "            The private key above is shortened to keep the example brief, but",
            "            shows how to do multiline string in YAML. The key is followed by a",
            "            pipe character, and the mutliline string is indented two more",
            "            spaces.",
            "",
            "            To avoid the hassle of creating an indented multiline YAML string,",
            "            the :mod:`file_tree external pillar <salt.pillar.file_tree>` can",
            "            be used instead. However, this will not work for binary files in",
            "            Salt releases before 2015.8.4.",
            "",
            "    contents_grains",
            "        .. versionadded:: 2014.7.0",
            "",
            "        Operates like ``contents``, but draws from a value stored in grains,",
            "        using the grains path syntax used in :mod:`grains.get",
            "        <salt.modules.grains.get>`. This functionality works similarly to",
            "        ``contents_pillar``, but with grains.",
            "",
            "        For example, the following could be used to deploy a \"message of the day\"",
            "        file:",
            "",
            "        .. code-block:: yaml",
            "",
            "            write_motd:",
            "              file.managed:",
            "                - name: /etc/motd",
            "                - contents_grains: motd",
            "",
            "        This would populate ``/etc/motd`` file with the contents of the ``motd``",
            "        grain. The ``motd`` grain is not a default grain, and would need to be",
            "        set prior to running the state:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' grains.set motd 'Welcome! This system is managed by Salt.'",
            "",
            "    contents_newline : True",
            "        .. versionadded:: 2014.7.0",
            "        .. versionchanged:: 2015.8.4",
            "            This option is now ignored if the contents being deployed contain",
            "            binary data.",
            "",
            "        If ``True``, files managed using ``contents``, ``contents_pillar``, or",
            "        ``contents_grains`` will have a newline added to the end of the file if",
            "        one is not present. Setting this option to ``False`` will omit this",
            "        final newline.",
            "",
            "    contents_delimiter",
            "        .. versionadded:: 2015.8.4",
            "",
            "        Can be used to specify an alternate delimiter for ``contents_pillar``",
            "        or ``contents_grains``. This delimiter will be passed through to",
            "        :py:func:`pillar.get <salt.modules.pillar.get>` or :py:func:`grains.get",
            "        <salt.modules.grains.get>` when retrieving the contents.",
            "",
            "    allow_empty : True",
            "        .. versionadded:: 2015.8.4",
            "",
            "        If set to ``False``, then the state will fail if the contents specified",
            "        by ``contents_pillar`` or ``contents_grains`` are empty.",
            "",
            "    follow_symlinks : True",
            "        .. versionadded:: 2014.7.0",
            "",
            "        If the desired path is a symlink follow it and make changes to the",
            "        file to which the symlink points.",
            "",
            "    check_cmd",
            "        .. versionadded:: 2014.7.0",
            "",
            "        The specified command will be run with an appended argument of a",
            "        *temporary* file containing the new managed contents.  If the command",
            "        exits with a zero status the new managed contents will be written to",
            "        the managed destination. If the command exits with a nonzero exit",
            "        code, the state will fail and no changes will be made to the file.",
            "",
            "        For example, the following could be used to verify sudoers before making",
            "        changes:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /etc/sudoers:",
            "              file.managed:",
            "                - user: root",
            "                - group: root",
            "                - mode: 0440",
            "                - source: salt://sudoers/files/sudoers.jinja",
            "                - template: jinja",
            "                - check_cmd: /usr/sbin/visudo -c -f",
            "",
            "        **NOTE**: This ``check_cmd`` functions differently than the requisite",
            "        ``check_cmd``.",
            "",
            "    tmp_ext",
            "        Suffix for temp file created by ``check_cmd``. Useful for checkers",
            "        dependant on config file extension (e.g. the init-checkconf upstart",
            "        config checker).",
            "",
            "        .. code-block:: yaml",
            "",
            "            /etc/init/test.conf:",
            "              file.managed:",
            "                - user: root",
            "                - group: root",
            "                - mode: 0440",
            "                - tmp_ext: '.conf'",
            "                - contents:",
            "                  - 'description \"Salt Minion\"''",
            "                  - 'start on started mountall'",
            "                  - 'stop on shutdown'",
            "                  - 'respawn'",
            "                  - 'exec salt-minion'",
            "                - check_cmd: init-checkconf -f",
            "",
            "    skip_verify : False",
            "        If ``True``, hash verification of remote file sources (``http://``,",
            "        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``",
            "        argument will be ignored.",
            "",
            "        .. versionadded:: 2016.3.0",
            "    '''",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'changes': {},",
            "           'pchanges': {},",
            "           'comment': '',",
            "           'name': name,",
            "           'result': True}",
            "",
            "    if mode is not None and salt.utils.is_windows():",
            "        return _error(ret, 'The \\'mode\\' option is not supported on Windows')",
            "",
            "    try:",
            "        keep_mode = mode.lower() == 'keep'",
            "        if keep_mode:",
            "            # We're not hard-coding the mode, so set it to None",
            "            mode = None",
            "    except AttributeError:",
            "        keep_mode = False",
            "",
            "    # Make sure that any leading zeros stripped by YAML loader are added back",
            "    mode = salt.utils.normalize_mode(mode)",
            "",
            "    contents_count = len(",
            "        [x for x in (contents, contents_pillar, contents_grains)",
            "         if x is not None]",
            "    )",
            "",
            "    if source and contents_count > 0:",
            "        return _error(",
            "            ret,",
            "            '\\'source\\' cannot be used in combination with \\'contents\\', '",
            "            '\\'contents_pillar\\', or \\'contents_grains\\''",
            "        )",
            "    elif keep_mode and contents_count > 0:",
            "        return _error(",
            "            ret,",
            "            'Mode preservation cannot be used in combination with \\'contents\\', '",
            "            '\\'contents_pillar\\', or \\'contents_grains\\''",
            "        )",
            "    elif contents_count > 1:",
            "        return _error(",
            "            ret,",
            "            'Only one of \\'contents\\', \\'contents_pillar\\', and '",
            "            '\\'contents_grains\\' is permitted'",
            "        )",
            "",
            "    # If no source is specified, set replace to False, as there is nothing",
            "    # with which to replace the file.",
            "    if not source and contents_count == 0 and replace:",
            "        replace = False",
            "        log.warning(",
            "            'State for file: {0} - Neither \\'source\\' nor \\'contents\\' nor '",
            "            '\\'contents_pillar\\' nor \\'contents_grains\\' was defined, yet '",
            "            '\\'replace\\' was set to \\'True\\'. As there is no source to '",
            "            'replace the file with, \\'replace\\' has been set to \\'False\\' to '",
            "            'avoid reading the file unnecessarily.'.format(name)",
            "        )",
            "",
            "    # Use this below to avoid multiple '\\0' checks and save some CPU cycles",
            "    if contents_pillar is not None:",
            "        if isinstance(contents_pillar, list):",
            "            list_contents = []",
            "            for nextp in contents_pillar:",
            "                nextc = __salt__['pillar.get'](nextp, __NOT_FOUND,",
            "                                               delimiter=contents_delimiter)",
            "                if nextc is __NOT_FOUND:",
            "                    return _error(",
            "                        ret,",
            "                        'Pillar {0} does not exist'.format(nextp)",
            "                    )",
            "                list_contents.append(nextc)",
            "            use_contents = os.linesep.join(list_contents)",
            "        else:",
            "            use_contents = __salt__['pillar.get'](contents_pillar, __NOT_FOUND,",
            "                                                  delimiter=contents_delimiter)",
            "            if use_contents is __NOT_FOUND:",
            "                return _error(",
            "                    ret,",
            "                    'Pillar {0} does not exist'.format(contents_pillar)",
            "                )",
            "",
            "    elif contents_grains is not None:",
            "        if isinstance(contents_grains, list):",
            "            list_contents = []",
            "            for nextg in contents_grains:",
            "                nextc = __salt__['grains.get'](nextg, __NOT_FOUND,",
            "                                               delimiter=contents_delimiter)",
            "                if nextc is __NOT_FOUND:",
            "                    return _error(",
            "                        ret,",
            "                        'Grain {0} does not exist'.format(nextc)",
            "                    )",
            "                list_contents.append(nextc)",
            "            use_contents = os.linesep.join(list_contents)",
            "        else:",
            "            use_contents = __salt__['grains.get'](contents_grains, __NOT_FOUND,",
            "                                                  delimiter=contents_delimiter)",
            "            if use_contents is __NOT_FOUND:",
            "                return _error(",
            "                    ret,",
            "                    'Grain {0} does not exist'.format(contents_grains)",
            "                )",
            "",
            "    elif contents is not None:",
            "        use_contents = contents",
            "",
            "    else:",
            "        use_contents = None",
            "",
            "    if use_contents is not None:",
            "        if not allow_empty and not use_contents:",
            "            if contents_pillar:",
            "                contents_id = 'contents_pillar {0}'.format(contents_pillar)",
            "            elif contents_grains:",
            "                contents_id = 'contents_grains {0}'.format(contents_grains)",
            "            else:",
            "                contents_id = '\\'contents\\''",
            "            return _error(",
            "                ret,",
            "                '{0} value would result in empty contents. Set allow_empty '",
            "                'to True to allow the managed file to be empty.'",
            "                .format(contents_id)",
            "            )",
            "",
            "        contents_are_binary = \\",
            "            isinstance(use_contents, six.string_types) and '\\0' in use_contents",
            "        if contents_are_binary:",
            "            contents = use_contents",
            "        else:",
            "            validated_contents = _validate_str_list(use_contents)",
            "            if not validated_contents:",
            "                return _error(",
            "                    ret,",
            "                    'Contents specified by contents/contents_pillar/'",
            "                    'contents_grains is not a string or list of strings, and '",
            "                    'is not binary data. SLS is likely malformed.'",
            "                )",
            "            contents = os.linesep.join(validated_contents)",
            "            if contents_newline and not contents.endswith(os.linesep):",
            "                contents += os.linesep",
            "        if template:",
            "            contents = __salt__['file.apply_template_on_contents'](",
            "                contents,",
            "                template=template,",
            "                context=context,",
            "                defaults=defaults,",
            "                saltenv=__env__)",
            "            if not isinstance(contents, six.string_types):",
            "                if 'result' in contents:",
            "                    ret['result'] = contents['result']",
            "                else:",
            "                    ret['result'] = False",
            "                if 'comment' in contents:",
            "                    ret['comment'] = contents['comment']",
            "                else:",
            "                    ret['comment'] = 'Error while applying template on contents'",
            "                return ret",
            "",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.exists')",
            "    user = _test_owner(kwargs, user=user)",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "    if not create:",
            "        if not os.path.isfile(name):",
            "            # Don't create a file that is not already present",
            "            ret['comment'] = ('File {0} is not present and is not set for '",
            "                              'creation').format(name)",
            "            return ret",
            "    u_check = _check_user(user, group)",
            "    if u_check:",
            "        # The specified user or group do not exist",
            "        return _error(ret, u_check)",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    if os.path.isdir(name):",
            "        ret['comment'] = 'Specified target {0} is a directory'.format(name)",
            "        ret['result'] = False",
            "        return ret",
            "",
            "    if context is None:",
            "        context = {}",
            "    elif not isinstance(context, dict):",
            "        return _error(",
            "            ret, 'Context must be formed as a dict')",
            "    if defaults and not isinstance(defaults, dict):",
            "        return _error(",
            "            ret, 'Defaults must be formed as a dict')",
            "",
            "    if not replace and os.path.exists(name):",
            "        # Check and set the permissions if necessary",
            "        ret, _ = __salt__['file.check_perms'](name, ret, user, group, mode,",
            "                                              follow_symlinks)",
            "        if __opts__['test']:",
            "            ret['comment'] = 'File {0} not updated'.format(name)",
            "        elif not ret['changes'] and ret['result']:",
            "            ret['comment'] = ('File {0} exists with proper permissions. '",
            "                              'No changes made.'.format(name))",
            "        return ret",
            "",
            "    accum_data, _ = _load_accumulators()",
            "    if name in accum_data:",
            "        if not context:",
            "            context = {}",
            "        context['accumulator'] = accum_data[name]",
            "",
            "    try:",
            "        if __opts__['test']:",
            "            if 'file.check_managed_changes' in __salt__:",
            "                ret['pchanges'] = __salt__['file.check_managed_changes'](",
            "                    name,",
            "                    source,",
            "                    source_hash,",
            "                    source_hash_name,",
            "                    user,",
            "                    group,",
            "                    mode,",
            "                    template,",
            "                    context,",
            "                    defaults,",
            "                    __env__,",
            "                    contents,",
            "                    skip_verify,",
            "                    **kwargs",
            "                )",
            "            if isinstance(ret['pchanges'], tuple):",
            "                ret['result'], ret['comment'] = ret['pchanges']",
            "            elif ret['pchanges']:",
            "                ret['result'] = None",
            "                ret['comment'] = 'The file {0} is set to be changed'.format(name)",
            "                if show_changes and 'diff' in ret['pchanges']:",
            "                    ret['changes']['diff'] = ret['pchanges']['diff']",
            "                if not show_changes:",
            "                    ret['changes']['diff'] = '<show_changes=False>'",
            "            else:",
            "                ret['result'] = True",
            "                ret['comment'] = 'The file {0} is in the correct state'.format(name)",
            "",
            "            return ret",
            "",
            "        # If the source is a list then find which file exists",
            "        source, source_hash = __salt__['file.source_list'](",
            "            source,",
            "            source_hash,",
            "            __env__",
            "        )",
            "    except CommandExecutionError as exc:",
            "        ret['result'] = False",
            "        ret['comment'] = 'Unable to manage file: {0}'.format(exc)",
            "        return ret",
            "",
            "    # Gather the source file from the server",
            "    try:",
            "        sfn, source_sum, comment_ = __salt__['file.get_managed'](",
            "            name,",
            "            template,",
            "            source,",
            "            source_hash,",
            "            source_hash_name,",
            "            user,",
            "            group,",
            "            mode,",
            "            __env__,",
            "            context,",
            "            defaults,",
            "            skip_verify,",
            "            **kwargs",
            "        )",
            "    except Exception as exc:",
            "        ret['changes'] = {}",
            "        log.debug(traceback.format_exc())",
            "        return _error(ret, 'Unable to manage file: {0}'.format(exc))",
            "",
            "    tmp_filename = None",
            "",
            "    if check_cmd:",
            "        tmp_filename = salt.utils.mkstemp(suffix=tmp_ext)",
            "",
            "        # if exists copy existing file to tmp to compare",
            "        if __salt__['file.file_exists'](name):",
            "            try:",
            "                __salt__['file.copy'](name, tmp_filename)",
            "            except Exception as exc:",
            "                return _error(",
            "                    ret,",
            "                    'Unable to copy file {0} to {1}: {2}'.format(",
            "                        name, tmp_filename, exc",
            "                    )",
            "                )",
            "",
            "        try:",
            "            ret = __salt__['file.manage_file'](",
            "                tmp_filename,",
            "                sfn,",
            "                ret,",
            "                source,",
            "                source_sum,",
            "                user,",
            "                group,",
            "                mode,",
            "                __env__,",
            "                backup,",
            "                makedirs,",
            "                template,",
            "                show_changes,",
            "                contents,",
            "                dir_mode,",
            "                follow_symlinks,",
            "                skip_verify,",
            "                keep_mode,",
            "                **kwargs)",
            "        except Exception as exc:",
            "            ret['changes'] = {}",
            "            log.debug(traceback.format_exc())",
            "            if os.path.isfile(tmp_filename):",
            "                os.remove(tmp_filename)",
            "            return _error(ret, 'Unable to check_cmd file: {0}'.format(exc))",
            "",
            "        # file being updated to verify using check_cmd",
            "        if ret['changes']:",
            "            # Reset ret",
            "            ret = {'changes': {},",
            "                   'comment': '',",
            "                   'name': name,",
            "                   'result': True}",
            "",
            "            check_cmd_opts = {}",
            "            if 'shell' in __grains__:",
            "                check_cmd_opts['shell'] = __grains__['shell']",
            "",
            "            cret = mod_run_check_cmd(check_cmd, tmp_filename, **check_cmd_opts)",
            "            if isinstance(cret, dict):",
            "                ret.update(cret)",
            "                if os.path.isfile(tmp_filename):",
            "                    os.remove(tmp_filename)",
            "                return ret",
            "            # Since we generated a new tempfile and we are not returning here",
            "            # lets change the original sfn to the new tempfile or else we will",
            "            # get file not found",
            "            sfn = tmp_filename",
            "        else:",
            "            ret = {'changes': {},",
            "                   'comment': '',",
            "                   'name': name,",
            "                   'result': True}",
            "",
            "    if comment_ and contents is None:",
            "        return _error(ret, comment_)",
            "    else:",
            "        try:",
            "            return __salt__['file.manage_file'](",
            "                name,",
            "                sfn,",
            "                ret,",
            "                source,",
            "                source_sum,",
            "                user,",
            "                group,",
            "                mode,",
            "                __env__,",
            "                backup,",
            "                makedirs,",
            "                template,",
            "                show_changes,",
            "                contents,",
            "                dir_mode,",
            "                follow_symlinks,",
            "                skip_verify,",
            "                keep_mode,",
            "                **kwargs)",
            "        except Exception as exc:",
            "            ret['changes'] = {}",
            "            log.debug(traceback.format_exc())",
            "            return _error(ret, 'Unable to manage file: {0}'.format(exc))",
            "        finally:",
            "            if tmp_filename and os.path.isfile(tmp_filename):",
            "                os.remove(tmp_filename)",
            "",
            "",
            "_RECURSE_TYPES = ['user', 'group', 'mode', 'ignore_files', 'ignore_dirs']",
            "",
            "",
            "def _get_recurse_set(recurse):",
            "    '''",
            "    Converse *recurse* definition to a set of strings.",
            "",
            "    Raises TypeError or ValueError when *recurse* has wrong structure.",
            "    '''",
            "    if not recurse:",
            "        return set()",
            "    if not isinstance(recurse, list):",
            "        raise TypeError('\"recurse\" must be formed as a list of strings')",
            "    try:",
            "        recurse_set = set(recurse)",
            "    except TypeError:  # non-hashable elements",
            "        recurse_set = None",
            "    if recurse_set is None or not set(_RECURSE_TYPES) >= recurse_set:",
            "        raise ValueError('Types for \"recurse\" limited to {0}.'.format(",
            "            ', '.join('\"{0}\"'.format(rtype) for rtype in _RECURSE_TYPES)))",
            "    if 'ignore_files' in recurse_set and 'ignore_dirs' in recurse_set:",
            "        raise ValueError('Must not specify \"recurse\" options \"ignore_files\"'",
            "                         ' and \"ignore_dirs\" at the same time.')",
            "    return recurse_set",
            "",
            "",
            "def _depth_limited_walk(top, max_depth=None):",
            "    '''",
            "    Walk the directory tree under root up till reaching max_depth.",
            "    With max_depth=None (default), do not limit depth.",
            "    '''",
            "    for root, dirs, files in os.walk(top):",
            "        if max_depth is not None:",
            "            rel_depth = root.count(os.sep) - top.count(os.sep)",
            "            if rel_depth >= max_depth:",
            "                del dirs[:]",
            "        yield (str(root), list(dirs), list(files))",
            "",
            "",
            "def directory(name,",
            "              user=None,",
            "              group=None,",
            "              recurse=None,",
            "              max_depth=None,",
            "              dir_mode=None,",
            "              file_mode=None,",
            "              makedirs=False,",
            "              clean=False,",
            "              require=None,",
            "              exclude_pat=None,",
            "              follow_symlinks=False,",
            "              force=False,",
            "              backupname=None,",
            "              allow_symlink=True,",
            "              children_only=False,",
            "              **kwargs):",
            "    '''",
            "    Ensure that a named directory is present and has the right perms",
            "",
            "    name",
            "        The location to create or manage a directory",
            "",
            "    user",
            "        The user to own the directory; this defaults to the user salt is",
            "        running as on the minion",
            "",
            "    group",
            "        The group ownership set for the directory; this defaults to the group",
            "        salt is running as on the minion. On Windows, this is ignored",
            "",
            "    recurse",
            "        Enforce user/group ownership and mode of directory recursively. Accepts",
            "        a list of strings representing what you would like to recurse.  If",
            "        ``mode`` is defined, will recurse on both ``file_mode`` and ``dir_mode`` if",
            "        they are defined.  If ``ignore_files`` or ``ignore_dirs`` is included, files or",
            "        directories will be left unchanged respectively.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /var/log/httpd:",
            "              file.directory:",
            "                - user: root",
            "                - group: root",
            "                - dir_mode: 755",
            "                - file_mode: 644",
            "                - recurse:",
            "                  - user",
            "                  - group",
            "                  - mode",
            "",
            "        Leave files or directories unchanged:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /var/log/httpd:",
            "              file.directory:",
            "                - user: root",
            "                - group: root",
            "                - dir_mode: 755",
            "                - file_mode: 644",
            "                - recurse:",
            "                  - user",
            "                  - group",
            "                  - mode",
            "                  - ignore_dirs",
            "",
            "        .. versionadded:: 2015.5.0",
            "",
            "    max_depth",
            "        Limit the recursion depth. The default is no limit=None.",
            "        'max_depth' and 'clean' are mutually exclusive.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    dir_mode / mode",
            "        The permissions mode to set any directories created. Not supported on",
            "        Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    file_mode",
            "        The permissions mode to set any files created if 'mode' is run in",
            "        'recurse'. This defaults to dir_mode. Not supported on Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    makedirs",
            "        If the directory is located in a path without a parent directory, then",
            "        the state will fail. If makedirs is set to True, then the parent",
            "        directories will be created to facilitate the creation of the named",
            "        file.",
            "",
            "    clean",
            "        Make sure that only files that are set up by salt and required by this",
            "        function are kept. If this option is set then everything in this",
            "        directory will be deleted unless it is required.",
            "        'clean' and 'max_depth' are mutually exclusive.",
            "",
            "    require",
            "        Require other resources such as packages or files",
            "",
            "    exclude_pat",
            "        When 'clean' is set to True, exclude this pattern from removal list",
            "        and preserve in the destination.",
            "",
            "    follow_symlinks : False",
            "        If the desired path is a symlink (or ``recurse`` is defined and a",
            "        symlink is encountered while recursing), follow it and check the",
            "        permissions of the directory/file to which the symlink points.",
            "",
            "        .. versionadded:: 2014.1.4",
            "",
            "    force",
            "        If the name of the directory exists and is not a directory and",
            "        force is set to False, the state will fail. If force is set to",
            "        True, the file in the way of the directory will be deleted to",
            "        make room for the directory, unless backupname is set,",
            "        then it will be renamed.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    backupname",
            "        If the name of the directory exists and is not a directory, it will be",
            "        renamed to the backupname. If the backupname already",
            "        exists and force is False, the state will fail. Otherwise, the",
            "        backupname will be removed first.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    allow_symlink : True",
            "        If allow_symlink is True and the specified path is a symlink, it will be",
            "        allowed to remain if it points to a directory. If allow_symlink is False",
            "        then the state will fail, unless force is also set to True, in which case",
            "        it will be removed or renamed, depending on the value of the backupname",
            "        argument.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    children_only : False",
            "        If children_only is True the base of a path is excluded when performing",
            "        a recursive operation. In case of /path/to/base, base will be ignored",
            "        while all of /path/to/base/* are still operated on.",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.directory')",
            "    # Remove trailing slash, if present and we're not working on \"/\" itself",
            "    if name[-1] == '/' and name != '/':",
            "        name = name[:-1]",
            "",
            "    if max_depth is not None and clean:",
            "        return _error(ret, 'Cannot specify both max_depth and clean')",
            "",
            "    user = _test_owner(kwargs, user=user)",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this is '",
            "                'a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "",
            "    if 'mode' in kwargs and not dir_mode:",
            "        dir_mode = kwargs.get('mode', [])",
            "",
            "    if not file_mode:",
            "        file_mode = dir_mode",
            "",
            "    # Make sure that leading zeros stripped by YAML loader are added back",
            "    dir_mode = salt.utils.normalize_mode(dir_mode)",
            "    file_mode = salt.utils.normalize_mode(file_mode)",
            "",
            "    u_check = _check_user(user, group)",
            "    if u_check:",
            "        # The specified user or group do not exist",
            "        return _error(ret, u_check)",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    # Check for existing file or symlink",
            "    if os.path.isfile(name) or (not allow_symlink and os.path.islink(name)) \\",
            "       or (force and os.path.islink(name)):",
            "        # Was a backupname specified",
            "        if backupname is not None:",
            "            # Make a backup first",
            "            if os.path.lexists(backupname):",
            "                if not force:",
            "                    return _error(ret, ((",
            "                                            'File exists where the backup target {0} should go'",
            "                                        ).format(backupname)))",
            "                else:",
            "                    __salt__['file.remove'](backupname)",
            "            os.rename(name, backupname)",
            "        elif force:",
            "            # Remove whatever is in the way",
            "            if os.path.isfile(name):",
            "                os.remove(name)",
            "                ret['changes']['forced'] = 'File was forcibly replaced'",
            "            elif __salt__['file.is_link'](name):",
            "                __salt__['file.remove'](name)",
            "                ret['changes']['forced'] = 'Symlink was forcibly replaced'",
            "            else:",
            "                __salt__['file.remove'](name)",
            "        else:",
            "            if os.path.isfile(name):",
            "                return _error(",
            "                    ret,",
            "                    'Specified location {0} exists and is a file'.format(name))",
            "            elif os.path.islink(name):",
            "                return _error(",
            "                    ret,",
            "                    'Specified location {0} exists and is a symlink'.format(name))",
            "    presult, pcomment, ret['pchanges'] = _check_directory(",
            "        name,",
            "        user,",
            "        group,",
            "        recurse or [],",
            "        dir_mode,",
            "        clean,",
            "        require,",
            "        exclude_pat,",
            "        max_depth)",
            "",
            "    if __opts__['test']:",
            "        ret['result'] = presult",
            "        ret['comment'] = pcomment",
            "        return ret",
            "",
            "    if not os.path.isdir(name):",
            "        # The dir does not exist, make it",
            "        if not os.path.isdir(os.path.dirname(name)):",
            "            # The parent directory does not exist, create them",
            "            if makedirs:",
            "                # Make sure the drive is mapped before trying to create the",
            "                # path in windows",
            "                if salt.utils.is_windows():",
            "                    drive, path = os.path.splitdrive(name)",
            "                    if not os.path.isdir(drive):",
            "                        return _error(",
            "                            ret, 'Drive {0} is not mapped'.format(drive))",
            "                # Everything's good, create the path",
            "                __salt__['file.makedirs'](",
            "                    name, user=user, group=group, mode=dir_mode",
            "                )",
            "            else:",
            "                return _error(",
            "                    ret, 'No directory to create {0} in'.format(name))",
            "",
            "        __salt__['file.mkdir'](",
            "            name, user=user, group=group, mode=dir_mode",
            "        )",
            "        ret['changes'][name] = 'New Dir'",
            "",
            "    if not os.path.isdir(name):",
            "        return _error(ret, 'Failed to create directory {0}'.format(name))",
            "",
            "    # issue 32707: skip this __salt__['file.check_perms'] call if children_only == True",
            "    # Check permissions",
            "    if not children_only:",
            "        ret, perms = __salt__['file.check_perms'](name,",
            "                                                  ret,",
            "                                                  user,",
            "                                                  group,",
            "                                                  dir_mode,",
            "                                                  follow_symlinks)",
            "",
            "    errors = []",
            "    if recurse or clean:",
            "        # walk path only once and store the result",
            "        walk_l = list(_depth_limited_walk(name, max_depth))",
            "        # root: (dirs, files) structure, compatible for python2.6",
            "        walk_d = {}",
            "        for i in walk_l:",
            "            walk_d[i[0]] = (i[1], i[2])",
            "",
            "    recurse_set = None",
            "    if recurse:",
            "        try:",
            "            recurse_set = _get_recurse_set(recurse)",
            "        except (TypeError, ValueError) as exc:",
            "            ret['result'] = False",
            "            ret['comment'] = '{0}'.format(exc)",
            "            # NOTE: Should this be enough to stop the whole check altogether?",
            "    if recurse_set:",
            "        if 'user' in recurse_set:",
            "            if user:",
            "                uid = __salt__['file.user_to_uid'](user)",
            "                # file.user_to_uid returns '' if user does not exist. Above",
            "                # check for user is not fatal, so we need to be sure user",
            "                # exists.",
            "                if isinstance(uid, six.string_types):",
            "                    ret['result'] = False",
            "                    ret['comment'] = 'Failed to enforce ownership for ' \\",
            "                                     'user {0} (user does not ' \\",
            "                                     'exist)'.format(user)",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'] = 'user not specified, but configured as ' \\",
            "                                 'a target for recursive ownership ' \\",
            "                                 'management'",
            "        else:",
            "            user = None",
            "        if 'group' in recurse_set:",
            "            if group:",
            "                gid = __salt__['file.group_to_gid'](group)",
            "                # As above with user, we need to make sure group exists.",
            "                if isinstance(gid, six.string_types):",
            "                    ret['result'] = False",
            "                    ret['comment'] = 'Failed to enforce group ownership ' \\",
            "                                     'for group {0}'.format(group)",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'] = 'group not specified, but configured ' \\",
            "                                 'as a target for recursive ownership ' \\",
            "                                 'management'",
            "        else:",
            "            group = None",
            "",
            "        if 'mode' not in recurse_set:",
            "            file_mode = None",
            "            dir_mode = None",
            "",
            "        check_files = 'ignore_files' not in recurse_set",
            "        check_dirs = 'ignore_dirs' not in recurse_set",
            "",
            "        for root, dirs, files in walk_l:",
            "            if check_files:",
            "                for fn_ in files:",
            "                    full = os.path.join(root, fn_)",
            "                    try:",
            "                        ret, _ = __salt__['file.check_perms'](",
            "                            full,",
            "                            ret,",
            "                            user,",
            "                            group,",
            "                            file_mode,",
            "                            follow_symlinks)",
            "                    except CommandExecutionError as exc:",
            "                        if not exc.strerror.endswith('does not exist'):",
            "                            errors.append(exc.strerror)",
            "            if check_dirs:",
            "                for dir_ in dirs:",
            "                    full = os.path.join(root, dir_)",
            "                    try:",
            "                        ret, _ = __salt__['file.check_perms'](",
            "                            full,",
            "                            ret,",
            "                            user,",
            "                            group,",
            "                            dir_mode,",
            "                            follow_symlinks)",
            "                    except CommandExecutionError as exc:",
            "                        if not exc.strerror.endswith('does not exist'):",
            "                            errors.append(exc.strerror)",
            "",
            "    if clean:",
            "        keep = _gen_keep_files(name, require, walk_d)",
            "        log.debug('List of kept files when use file.directory with clean: %s',",
            "                  keep)",
            "        removed = _clean_dir(name, list(keep), exclude_pat)",
            "        if removed:",
            "            ret['changes']['removed'] = removed",
            "            ret['comment'] = 'Files cleaned from directory {0}'.format(name)",
            "",
            "    # issue 32707: reflect children_only selection in comments",
            "    if not ret['comment']:",
            "        if children_only:",
            "            ret['comment'] = 'Directory {0}/* updated'.format(name)",
            "        else:",
            "            ret['comment'] = 'Directory {0} updated'.format(name)",
            "",
            "    if __opts__['test']:",
            "        ret['comment'] = 'Directory {0} not updated'.format(name)",
            "    elif not ret['changes'] and ret['result']:",
            "        ret['comment'] = 'Directory {0} is in the correct state'.format(name)",
            "",
            "    if errors:",
            "        ret['result'] = False",
            "        ret['comment'] += '\\n\\nThe following errors were encountered:\\n'",
            "        for error in errors:",
            "            ret['comment'] += '\\n- {0}'.format(error)",
            "    return ret",
            "",
            "",
            "def recurse(name,",
            "            source,",
            "            clean=False,",
            "            require=None,",
            "            user=None,",
            "            group=None,",
            "            dir_mode=None,",
            "            file_mode=None,",
            "            sym_mode=None,",
            "            template=None,",
            "            context=None,",
            "            defaults=None,",
            "            include_empty=False,",
            "            backup='',",
            "            include_pat=None,",
            "            exclude_pat=None,",
            "            maxdepth=None,",
            "            keep_symlinks=False,",
            "            force_symlinks=False,",
            "            **kwargs):",
            "    '''",
            "    Recurse through a subdirectory on the master and copy said subdirectory",
            "    over to the specified path.",
            "",
            "    name",
            "        The directory to set the recursion in",
            "",
            "    source",
            "        The source directory, this directory is located on the salt master file",
            "        server and is specified with the salt:// protocol. If the directory is",
            "        located on the master in the directory named spam, and is called eggs,",
            "        the source string is salt://spam/eggs",
            "",
            "    clean",
            "        Make sure that only files that are set up by salt and required by this",
            "        function are kept. If this option is set then everything in this",
            "        directory will be deleted unless it is required.",
            "",
            "    require",
            "        Require other resources such as packages or files",
            "",
            "    user",
            "        The user to own the directory. This defaults to the user salt is",
            "        running as on the minion",
            "",
            "    group",
            "        The group ownership set for the directory. This defaults to the group",
            "        salt is running as on the minion. On Windows, this is ignored",
            "",
            "    dir_mode",
            "        The permissions mode to set on any directories created.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "    file_mode",
            "        The permissions mode to set on any files created.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "        .. versionchanged:: 2016.11.0",
            "            This option can be set to ``keep``, and Salt will keep the mode",
            "            from the Salt fileserver. This is only supported when the",
            "            ``source`` URL begins with ``salt://``, or for files local to the",
            "            minion. Because the ``source`` option cannot be used with any of",
            "            the ``contents`` options, setting the ``mode`` to ``keep`` is also",
            "            incompatible with the ``contents`` options.",
            "",
            "    sym_mode",
            "        The permissions mode to set on any symlink created.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "    template",
            "        If this setting is applied, the named templating engine will be used to",
            "        render the downloaded file. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "        .. note::",
            "",
            "            The template option is required when recursively applying templates.",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    include_empty",
            "        Set this to True if empty directories should also be created",
            "        (default is False)",
            "",
            "    backup",
            "        Overrides the default backup mode for all replaced files. See",
            "        :ref:`backup_mode documentation <file-state-backups>` for more details.",
            "",
            "    include_pat",
            "        When copying, include only this pattern from the source. Default",
            "        is glob match; if prefixed with 'E@', then regexp match.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "          - include_pat: hello*       :: glob matches 'hello01', 'hello02'",
            "                                         ... but not 'otherhello'",
            "          - include_pat: E@hello      :: regexp matches 'otherhello',",
            "                                         'hello01' ...",
            "",
            "    exclude_pat",
            "        Exclude this pattern from the source when copying. If both",
            "        `include_pat` and `exclude_pat` are supplied, then it will apply",
            "        conditions cumulatively. i.e. first select based on include_pat, and",
            "        then within that result apply exclude_pat.",
            "",
            "        Also, when 'clean=True', exclude this pattern from the removal",
            "        list and preserve in the destination.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "          - exclude_pat: APPDATA*               :: glob matches APPDATA.01,",
            "                                                   APPDATA.02,.. for exclusion",
            "          - exclude_pat: E@(APPDATA)|(TEMPDATA) :: regexp matches APPDATA",
            "                                                   or TEMPDATA for exclusion",
            "",
            "    maxdepth",
            "        When copying, only copy paths which are of depth `maxdepth` from the",
            "        source path.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "          - maxdepth: 0      :: Only include files located in the source",
            "                                directory",
            "          - maxdepth: 1      :: Only include files located in the source",
            "                                or immediate subdirectories",
            "",
            "    keep_symlinks",
            "        Keep symlinks when copying from the source. This option will cause",
            "        the copy operation to terminate at the symlink. If desire behavior",
            "        similar to rsync, then set this to True.",
            "",
            "    force_symlinks",
            "        Force symlink creation. This option will force the symlink creation.",
            "        If a file or directory is obstructing symlink creation it will be",
            "        recursively removed so that symlink creation can proceed. This",
            "        option is usually not needed except in special circumstances.",
            "    '''",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(sdecode(name))",
            "",
            "    user = _test_owner(kwargs, user=user)",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'pchanges': {},",
            "        'result': True,",
            "        'comment': {}  # { path: [comment, ...] }",
            "    }",
            "",
            "    if 'mode' in kwargs:",
            "        ret['result'] = False",
            "        ret['comment'] = (",
            "            '\\'mode\\' is not allowed in \\'file.recurse\\'. Please use '",
            "            '\\'file_mode\\' and \\'dir_mode\\'.'",
            "        )",
            "        return ret",
            "",
            "    if any([x is not None for x in (dir_mode, file_mode, sym_mode)]) \\",
            "            and salt.utils.is_windows():",
            "        return _error(ret, 'mode management is not supported on Windows')",
            "",
            "    # Make sure that leading zeros stripped by YAML loader are added back",
            "    dir_mode = salt.utils.normalize_mode(dir_mode)",
            "",
            "    try:",
            "        keep_mode = file_mode.lower() == 'keep'",
            "        if keep_mode:",
            "            # We're not hard-coding the mode, so set it to None",
            "            file_mode = None",
            "    except AttributeError:",
            "        keep_mode = False",
            "",
            "    file_mode = salt.utils.normalize_mode(file_mode)",
            "",
            "    u_check = _check_user(user, group)",
            "    if u_check:",
            "        # The specified user or group do not exist",
            "        return _error(ret, u_check)",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    # expand source into source_list",
            "    source_list = _validate_str_list(source)",
            "",
            "    for idx, val in enumerate(source_list):",
            "        source_list[idx] = val.rstrip('/')",
            "",
            "    for precheck in source_list:",
            "        if not precheck.startswith('salt://'):",
            "            return _error(ret, ('Invalid source \\'{0}\\' '",
            "                                '(must be a salt:// URI)'.format(precheck)))",
            "",
            "    # Select the first source in source_list that exists",
            "    try:",
            "        source, source_hash = __salt__['file.source_list'](source_list, '', __env__)",
            "    except CommandExecutionError as exc:",
            "        ret['result'] = False",
            "        ret['comment'] = 'Recurse failed: {0}'.format(exc)",
            "        return ret",
            "",
            "    # Check source path relative to fileserver root, make sure it is a",
            "    # directory",
            "    srcpath, senv = salt.utils.url.parse(source)",
            "    if senv is None:",
            "        senv = __env__",
            "    master_dirs = __salt__['cp.list_master_dirs'](saltenv=senv)",
            "    if srcpath not in master_dirs \\",
            "            and not any((x for x in master_dirs",
            "                         if x.startswith(srcpath + '/'))):",
            "        ret['result'] = False",
            "        ret['comment'] = (",
            "            'The directory \\'{0}\\' does not exist on the salt fileserver '",
            "            'in saltenv \\'{1}\\''.format(srcpath, senv)",
            "        )",
            "        return ret",
            "",
            "    # Verify the target directory",
            "    if not os.path.isdir(name):",
            "        if os.path.exists(name):",
            "            # it is not a dir, but it exists - fail out",
            "            return _error(",
            "                ret, 'The path {0} exists and is not a directory'.format(name))",
            "        if not __opts__['test']:",
            "            __salt__['file.makedirs_perms'](name, user, group, dir_mode)",
            "",
            "    def add_comment(path, comment):",
            "        comments = ret['comment'].setdefault(path, [])",
            "        if isinstance(comment, six.string_types):",
            "            comments.append(comment)",
            "        else:",
            "            comments.extend(comment)",
            "",
            "    def merge_ret(path, _ret):",
            "        # Use the most \"negative\" result code (out of True, None, False)",
            "        if _ret['result'] is False or ret['result'] is True:",
            "            ret['result'] = _ret['result']",
            "",
            "        # Only include comments about files that changed",
            "        if _ret['result'] is not True and _ret['comment']:",
            "            add_comment(path, _ret['comment'])",
            "",
            "        if _ret['changes']:",
            "            ret['changes'][path] = _ret['changes']",
            "",
            "    def manage_file(path, source):",
            "        if clean and os.path.exists(path) and os.path.isdir(path):",
            "            _ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}",
            "            if __opts__['test']:",
            "                _ret['comment'] = 'Replacing directory {0} with a ' \\",
            "                                  'file'.format(path)",
            "                _ret['result'] = None",
            "                merge_ret(path, _ret)",
            "                return",
            "            else:",
            "                __salt__['file.remove'](path)",
            "                _ret['changes'] = {'diff': 'Replaced directory with a '",
            "                                           'new file'}",
            "                merge_ret(path, _ret)",
            "",
            "        # Conflicts can occur if some kwargs are passed in here",
            "        pass_kwargs = {}",
            "        faults = ['mode', 'makedirs']",
            "        for key in kwargs:",
            "            if key not in faults:",
            "                pass_kwargs[key] = kwargs[key]",
            "",
            "        _ret = managed(",
            "            path,",
            "            source=source,",
            "            user=user,",
            "            group=group,",
            "            mode='keep' if keep_mode else file_mode,",
            "            template=template,",
            "            makedirs=True,",
            "            context=context,",
            "            defaults=defaults,",
            "            backup=backup,",
            "            **pass_kwargs)",
            "        merge_ret(path, _ret)",
            "",
            "    def manage_directory(path):",
            "        if os.path.basename(path) == '..':",
            "            return",
            "        if clean and os.path.exists(path) and not os.path.isdir(path):",
            "            _ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}",
            "            if __opts__['test']:",
            "                _ret['comment'] = 'Replacing {0} with a directory'.format(path)",
            "                _ret['result'] = None",
            "                merge_ret(path, _ret)",
            "                return",
            "            else:",
            "                __salt__['file.remove'](path)",
            "                _ret['changes'] = {'diff': 'Replaced file with a directory'}",
            "                merge_ret(path, _ret)",
            "",
            "        _ret = directory(",
            "            path,",
            "            user=user,",
            "            group=group,",
            "            recurse=[],",
            "            dir_mode=dir_mode,",
            "            file_mode=None,",
            "            makedirs=True,",
            "            clean=False,",
            "            require=None)",
            "        merge_ret(path, _ret)",
            "",
            "    # Process symlinks and return the updated filenames list",
            "    def process_symlinks(filenames, symlinks):",
            "        for lname, ltarget in six.iteritems(symlinks):",
            "            if not salt.utils.check_include_exclude(",
            "                    os.path.relpath(lname, srcpath), include_pat, exclude_pat):",
            "                continue",
            "            srelpath = os.path.relpath(lname, srcpath)",
            "            # Check for max depth",
            "            if maxdepth is not None:",
            "                srelpieces = srelpath.split('/')",
            "                if not srelpieces[-1]:",
            "                    srelpieces = srelpieces[:-1]",
            "                if len(srelpieces) > maxdepth + 1:",
            "                    continue",
            "            # Check for all paths that begin with the symlink",
            "            # and axe it leaving only the dirs/files below it.",
            "            # This needs to use list() otherwise they reference",
            "            # the same list.",
            "            _filenames = list(filenames)",
            "            for filename in _filenames:",
            "                if filename.startswith(lname):",
            "                    log.debug('** skipping file ** {0}, it intersects a '",
            "                              'symlink'.format(filename))",
            "                    filenames.remove(filename)",
            "            # Create the symlink along with the necessary dirs.",
            "            # The dir perms/ownership will be adjusted later",
            "            # if needed",
            "            _ret = symlink(os.path.join(name, srelpath),",
            "                           ltarget,",
            "                           makedirs=True,",
            "                           force=force_symlinks,",
            "                           user=user,",
            "                           group=group,",
            "                           mode=sym_mode)",
            "            if not _ret:",
            "                continue",
            "            merge_ret(os.path.join(name, srelpath), _ret)",
            "            # Add the path to the keep set in case clean is set to True",
            "            keep.add(os.path.join(name, srelpath))",
            "        vdir.update(keep)",
            "        return filenames",
            "",
            "    keep = set()",
            "    vdir = set()",
            "    if not srcpath.endswith('/'):",
            "        # we're searching for things that start with this *directory*.",
            "        # use '/' since #master only runs on POSIX",
            "        srcpath = srcpath + '/'",
            "    fns_ = __salt__['cp.list_master'](senv, srcpath)",
            "    # If we are instructed to keep symlinks, then process them.",
            "    if keep_symlinks:",
            "        # Make this global so that emptydirs can use it if needed.",
            "        symlinks = __salt__['cp.list_master_symlinks'](senv, srcpath)",
            "        fns_ = process_symlinks(fns_, symlinks)",
            "    for fn_ in fns_:",
            "        if not fn_.strip():",
            "            continue",
            "",
            "        # fn_ here is the absolute (from file_roots) source path of",
            "        # the file to copy from; it is either a normal file or an",
            "        # empty dir(if include_empty==true).",
            "",
            "        relname = sdecode(os.path.relpath(fn_, srcpath))",
            "        if relname.startswith('..'):",
            "            continue",
            "",
            "        # Check for maxdepth of the relative path",
            "        if maxdepth is not None:",
            "            # Since paths are all master, just use POSIX separator",
            "            relpieces = relname.split('/')",
            "            # Handle empty directories (include_empty==true) by removing the",
            "            # the last piece if it is an empty string",
            "            if not relpieces[-1]:",
            "                relpieces = relpieces[:-1]",
            "            if len(relpieces) > maxdepth + 1:",
            "                continue",
            "",
            "        # Check if it is to be excluded. Match only part of the path",
            "        # relative to the target directory",
            "        if not salt.utils.check_include_exclude(",
            "                relname, include_pat, exclude_pat):",
            "            continue",
            "        dest = os.path.join(name, relname)",
            "        dirname = os.path.dirname(dest)",
            "        keep.add(dest)",
            "",
            "        if dirname not in vdir:",
            "            # verify the directory perms if they are set",
            "            manage_directory(dirname)",
            "            vdir.add(dirname)",
            "",
            "        src = salt.utils.url.create(fn_, saltenv=senv)",
            "        manage_file(dest, src)",
            "",
            "    if include_empty:",
            "        mdirs = __salt__['cp.list_master_dirs'](senv, srcpath)",
            "        for mdir in mdirs:",
            "            if not salt.utils.check_include_exclude(",
            "                    os.path.relpath(mdir, srcpath), include_pat, exclude_pat):",
            "                continue",
            "            mdest = os.path.join(name, os.path.relpath(mdir, srcpath))",
            "            # Check for symlinks that happen to point to an empty dir.",
            "            if keep_symlinks:",
            "                islink = False",
            "                for link in symlinks:",
            "                    if mdir.startswith(link, 0):",
            "                        log.debug('** skipping empty dir ** {0}, it intersects'",
            "                                  ' a symlink'.format(mdir))",
            "                        islink = True",
            "                        break",
            "                if islink:",
            "                    continue",
            "",
            "            manage_directory(mdest)",
            "            keep.add(mdest)",
            "",
            "    keep = list(keep)",
            "    if clean:",
            "        # TODO: Use directory(clean=True) instead",
            "        keep += _gen_keep_files(name, require)",
            "        removed = _clean_dir(name, list(keep), exclude_pat)",
            "        if removed:",
            "            if __opts__['test']:",
            "                if ret['result']:",
            "                    ret['result'] = None",
            "                add_comment('removed', removed)",
            "            else:",
            "                ret['changes']['removed'] = removed",
            "",
            "    # Flatten comments until salt command line client learns",
            "    # to display structured comments in a readable fashion",
            "    ret['comment'] = '\\n'.join(u'\\n#### {0} ####\\n{1}'.format(",
            "        k, v if isinstance(v, six.string_types) else '\\n'.join(v)",
            "    ) for (k, v) in six.iteritems(ret['comment'])).strip()",
            "",
            "    if not ret['comment']:",
            "        ret['comment'] = 'Recursively updated {0}'.format(name)",
            "",
            "    if not ret['changes'] and ret['result']:",
            "        ret['comment'] = 'The directory {0} is in the correct state'.format(",
            "            name",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def retention_schedule(name, retain, strptime_format=None, timezone=None):",
            "    '''",
            "    Apply retention scheduling to backup storage directory.",
            "",
            "    .. versionadded:: 2016.11.0",
            "",
            "    :param name:",
            "        The filesystem path to the directory containing backups to be managed.",
            "",
            "    :param retain:",
            "        Delete the backups, except for the ones we want to keep.",
            "        The N below should be an integer but may also be the special value of ``all``,",
            "        which keeps all files matching the criteria.",
            "        All of the retain options default to None,",
            "        which means to not keep files based on this criteria.",
            "",
            "        :most_recent N:",
            "            Keep the most recent N files.",
            "",
            "        :first_of_hour N:",
            "            For the last N hours from now, keep the first file after the hour.",
            "",
            "        :first_of_day N:",
            "            For the last N days from now, keep the first file after midnight.",
            "            See also ``timezone``.",
            "",
            "        :first_of_week N:",
            "            For the last N weeks from now, keep the first file after Sunday midnight.",
            "",
            "        :first_of_month N:",
            "            For the last N months from now, keep the first file after the start of the month.",
            "",
            "        :first_of_year N:",
            "            For the last N years from now, keep the first file after the start of the year.",
            "",
            "    :param strptime_format:",
            "        A python strptime format string used to first match the filenames of backups",
            "        and then parse the filename to determine the datetime of the file.",
            "        https://docs.python.org/2/library/datetime.html#datetime.datetime.strptime",
            "        Defaults to None, which considers all files in the directory to be backups eligible for deletion",
            "        and uses ``os.path.getmtime()`` to determine the datetime.",
            "",
            "    :param timezone:",
            "        The timezone to use when determining midnight.",
            "        This is only used when datetime is pulled from ``os.path.getmtime()``.",
            "        Defaults to ``None`` which uses the timezone from the locale.",
            "",
            "    .. code-block: yaml",
            "",
            "        /var/backups/example_directory:",
            "          file.retention_schedule:",
            "            - retain:",
            "                most_recent: 5",
            "                first_of_hour: 4",
            "                first_of_day: 7",
            "                first_of_week: 6    # NotImplemented yet.",
            "                first_of_month: 6",
            "                first_of_year: all",
            "            - strptime_format: example_name_%Y%m%dT%H%M%S.tar.bz2",
            "            - timezone: None",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    ret = {'name': name,",
            "           'changes': {'retained': [], 'deleted': [], 'ignored': []},",
            "           'pchanges': {'retained': [], 'deleted': [], 'ignored': []},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.retention_schedule')",
            "    if not os.path.isdir(name):",
            "        return _error(ret, 'Name provided to file.retention must be a directory')",
            "",
            "    # get list of files in directory",
            "    all_files = __salt__['file.readdir'](name)",
            "",
            "    # if strptime_format is set, filter through the list to find names which parse and get their datetimes.",
            "    beginning_of_unix_time = datetime(1970, 1, 1)",
            "",
            "    def get_file_time_from_strptime(f):",
            "        try:",
            "            ts = datetime.strptime(f, strptime_format)",
            "            ts_epoch = salt.utils.total_seconds(ts - beginning_of_unix_time)",
            "            return (ts, ts_epoch)",
            "        except ValueError:",
            "            # Files which don't match the pattern are not relevant files.",
            "            return (None, None)",
            "",
            "    def get_file_time_from_mtime(f):",
            "        lstat = __salt__['file.lstat'](os.path.join(name, f))",
            "        if lstat:",
            "            mtime = lstat['st_mtime']",
            "            return (datetime.fromtimestamp(mtime, timezone), mtime)",
            "        else:   # maybe it was deleted since we did the readdir?",
            "            return (None, None)",
            "",
            "    get_file_time = get_file_time_from_strptime if strptime_format else get_file_time_from_mtime",
            "",
            "    # data structures are nested dicts:",
            "    # files_by_ymd = year.month.day.hour.unixtime: filename",
            "    # files_by_y_week_dow = year.week_of_year.day_of_week.unixtime: filename",
            "    # http://the.randomengineer.com/2015/04/28/python-recursive-defaultdict/",
            "    # TODO: move to an ordered dict model and reduce the number of sorts in the rest of the code?",
            "    def dict_maker():",
            "        return defaultdict(dict_maker)",
            "    files_by_ymd = dict_maker()",
            "    files_by_y_week_dow = dict_maker()",
            "    relevant_files = set()",
            "    ignored_files = set()",
            "    for f in all_files:",
            "        ts, ts_epoch = get_file_time(f)",
            "        if ts:",
            "            files_by_ymd[ts.year][ts.month][ts.day][ts.hour][ts_epoch] = f",
            "            week_of_year = ts.isocalendar()[1]",
            "            files_by_y_week_dow[ts.year][week_of_year][ts.weekday()][ts_epoch] = f",
            "            relevant_files.add(f)",
            "        else:",
            "            ignored_files.add(f)",
            "",
            "    # This is tightly coupled with the file_with_times data-structure above.",
            "    RETAIN_TO_DEPTH = {",
            "        'first_of_year': 1,",
            "        'first_of_month': 2,",
            "        'first_of_day': 3,",
            "        'first_of_hour': 4,",
            "        'most_recent': 5,",
            "    }",
            "",
            "    def get_first(fwt):",
            "        if isinstance(fwt, dict):",
            "            first_sub_key = sorted(fwt.keys())[0]",
            "            return get_first(fwt[first_sub_key])",
            "        else:",
            "            return set([fwt, ])",
            "",
            "    def get_first_n_at_depth(fwt, depth, n):",
            "        if depth <= 0:",
            "            return get_first(fwt)",
            "        else:",
            "            result_set = set()",
            "            for k in sorted(fwt.keys(), reverse=True):",
            "                needed = n - len(result_set)",
            "                if needed < 1:",
            "                    break",
            "                result_set |= get_first_n_at_depth(fwt[k], depth - 1, needed)",
            "            return result_set",
            "",
            "    # for each retain criteria, add filenames which match the criteria to the retain set.",
            "    retained_files = set()",
            "    for retention_rule, keep_count in retain.items():",
            "        # This is kind of a hack, since 'all' should really mean all,",
            "        # but I think it's a large enough number that even modern filesystems would",
            "        # choke if they had this many files in a single directory.",
            "        keep_count = sys.maxsize if 'all' == keep_count else int(keep_count)",
            "        if 'first_of_week' == retention_rule:",
            "            first_of_week_depth = 2   # year + week_of_year = 2",
            "            # I'm adding 1 to keep_count below because it fixed an off-by one",
            "            # issue in the tests. I don't understand why, and that bothers me.",
            "            retained_files |= get_first_n_at_depth(files_by_y_week_dow,",
            "                                                   first_of_week_depth,",
            "                                                   keep_count + 1)",
            "        else:",
            "            retained_files |= get_first_n_at_depth(files_by_ymd,",
            "                                                   RETAIN_TO_DEPTH[retention_rule],",
            "                                                   keep_count)",
            "",
            "    deletable_files = list(relevant_files - retained_files)",
            "    deletable_files.sort(reverse=True)",
            "    changes = {",
            "            'retained': sorted(list(retained_files), reverse=True),",
            "            'deleted': deletable_files,",
            "            'ignored': sorted(list(ignored_files), reverse=True),",
            "        }",
            "    ret['pchanges'] = changes",
            "",
            "    # TODO: track and report how much space was / would be reclaimed",
            "    if __opts__['test']:",
            "        ret['comment'] = '{0} backups would have been removed from {1}.\\n'.format(len(deletable_files), name)",
            "        if deletable_files:",
            "            ret['result'] = None",
            "    else:",
            "        for f in deletable_files:",
            "            __salt__['file.remove'](os.path.join(name, f))",
            "        ret['comment'] = '{0} backups were removed from {1}.\\n'.format(len(deletable_files), name)",
            "        ret['changes'] = changes",
            "",
            "    return ret",
            "",
            "",
            "def line(name, content, match=None, mode=None, location=None,",
            "         before=None, after=None, show_changes=True, backup=False,",
            "         quiet=False, indent=True, create=False, user=None,",
            "         group=None, file_mode=None):",
            "    '''",
            "    Line-based editing of a file.",
            "",
            "    .. versionadded:: 2015.8.0",
            "",
            "    name",
            "        Filesystem path to the file to be edited.",
            "",
            "    content",
            "        Content of the line.",
            "",
            "    match",
            "        Match the target line for an action by",
            "        a fragment of a string or regular expression.",
            "",
            "        If neither ``before`` nor ``after`` are provided, and ``match``",
            "        is also ``None``, match becomes the ``content`` value.",
            "",
            "    mode",
            "        Defines how to edit a line. One of the following options is",
            "        required:",
            "",
            "        - ensure",
            "            If line does not exist, it will be added.",
            "        - replace",
            "            If line already exists, it will be replaced.",
            "        - delete",
            "            Delete the line, once found.",
            "        - insert",
            "            Insert a line.",
            "",
            "        .. note::",
            "",
            "            If ``mode=insert`` is used, at least one of the following",
            "            options must also be defined: ``location``, ``before``, or",
            "            ``after``. If ``location`` is used, it takes precedence",
            "            over the other two options.",
            "",
            "    location",
            "        Defines where to place content in the line. Note this option is only",
            "        used when ``mode=insert`` is specified. If a location is passed in, it",
            "        takes precedence over both the ``before`` and ``after`` kwargs. Valid",
            "        locations are:",
            "",
            "        - start",
            "            Place the content at the beginning of the file.",
            "        - end",
            "            Place the content at the end of the file.",
            "",
            "    before",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    after",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file.",
            "        If ``False`` return a boolean if any changes were made.",
            "        Default is ``True``",
            "",
            "        .. note::",
            "            Using this option will store two copies of the file in-memory",
            "            (the original version and the edited version) in order to generate the diff.",
            "",
            "    backup",
            "        Create a backup of the original file with the extension:",
            "        \"Year-Month-Day-Hour-Minutes-Seconds\".",
            "",
            "    quiet",
            "        Do not raise any exceptions. E.g. ignore the fact that the file that is",
            "        tried to be edited does not exist and nothing really happened.",
            "",
            "    indent",
            "        Keep indentation with the previous line. This option is not considered when",
            "        the ``delete`` mode is specified.",
            "",
            "    :param create:",
            "        Create an empty file if doesn't exists.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    :param user:",
            "        The user to own the file, this defaults to the user salt is running as",
            "        on the minion.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    :param group:",
            "        The group ownership set for the file, this defaults to the group salt",
            "        is running as on the minion On Windows, this is ignored.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    :param file_mode:",
            "        The permissions to set on this file, aka 644, 0775, 4664. Not supported",
            "        on Windows.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    If an equal sign (``=``) appears in an argument to a Salt command, it is",
            "    interpreted as a keyword argument in the format of ``key=val``. That",
            "    processing can be bypassed in order to pass an equal sign through to the",
            "    remote shell command by manually specifying the kwarg:",
            "",
            "    .. code-block: yaml",
            "",
            "       update_config:",
            "         file.line:",
            "           - name: /etc/myconfig.conf",
            "           - mode: ensure",
            "           - content: my key = my value",
            "           - before: somekey.*?",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.line')",
            "",
            "    managed(name, create=create, user=user, group=group, mode=file_mode)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    changes = __salt__['file.line'](",
            "        name, content, match=match, mode=mode, location=location,",
            "        before=before, after=after, show_changes=show_changes,",
            "        backup=backup, quiet=quiet, indent=indent)",
            "    if changes:",
            "        ret['pchanges']['diff'] = changes",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Changes would be made:\\ndiff:\\n{0}'.format(changes)",
            "        else:",
            "            ret['result'] = True",
            "            ret['comment'] = 'Changes were made'",
            "            ret['changes'] = {'diff': changes}",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'No changes needed to be made'",
            "",
            "    return ret",
            "",
            "",
            "def replace(name,",
            "            pattern,",
            "            repl,",
            "            count=0,",
            "            flags=8,",
            "            bufsize=1,",
            "            append_if_not_found=False,",
            "            prepend_if_not_found=False,",
            "            not_found_content=None,",
            "            backup='.bak',",
            "            show_changes=True,",
            "            ignore_if_missing=False):",
            "    r'''",
            "    Maintain an edit in a file.",
            "",
            "    .. versionadded:: 0.17.0",
            "",
            "    name",
            "        Filesystem path to the file to be edited. If a symlink is specified, it",
            "        will be resolved to its target.",
            "",
            "    pattern",
            "        A regular expression, to be matched using Python's",
            "        :py:func:`~re.search`.",
            "",
            "    repl",
            "        The replacement text",
            "",
            "    count",
            "        Maximum number of pattern occurrences to be replaced.  Defaults to 0.",
            "        If count is a positive integer n, no more than n occurrences will be",
            "        replaced, otherwise all occurrences will be replaced.",
            "",
            "    flags",
            "        A list of flags defined in the :ref:`re module documentation",
            "        <contents-of-module-re>`. Each list item should be a string that will",
            "        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',",
            "        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value",
            "        corresponding to the XOR (``|``) of all the desired flags. Defaults to",
            "        ``8`` (which equates to ``['MULTILINE']``).",
            "",
            "        .. note::",
            "",
            "            ``file.replace`` reads the entire file as a string to support",
            "            multiline regex patterns. Therefore, when using anchors such as",
            "            ``^`` or ``$`` in the pattern, those anchors may be relative to",
            "            the line OR relative to the file. The default for ``file.replace``",
            "            is to treat anchors as relative to the line, which is implemented",
            "            by setting the default value of ``flags`` to ``['MULTILINE']``.",
            "            When overriding the default value for ``flags``, if",
            "            ``'MULTILINE'`` is not present then anchors will be relative to",
            "            the file. If the desired behavior is for anchors to be relative to",
            "            the line, then simply add ``'MULTILINE'`` to the list of flags.",
            "",
            "    bufsize",
            "        How much of the file to buffer into memory at once. The default value",
            "        ``1`` processes one line at a time. The special value ``file`` may be",
            "        specified which will read the entire file into memory before",
            "        processing.",
            "",
            "    append_if_not_found : False",
            "        If set to ``True``, and pattern is not found, then the content will be",
            "        appended to the file.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    prepend_if_not_found : False",
            "        If set to ``True`` and pattern is not found, then the content will be",
            "        prepended to the file.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    not_found_content",
            "        Content to use for append/prepend if not found. If ``None`` (default),",
            "        uses ``repl``. Useful when ``repl`` uses references to group in",
            "        pattern.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    backup",
            "        The file extension to use for a backup of the file before editing. Set",
            "        to ``False`` to skip making a backup.",
            "",
            "    show_changes : True",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made. Returns a boolean or a",
            "        string.",
            "",
            "        .. note:",
            "            Using this option will store two copies of the file in memory (the",
            "            original version and the edited version) in order to generate the",
            "            diff. This may not normally be a concern, but could impact",
            "            performance if used with large files.",
            "",
            "    ignore_if_missing : False",
            "        .. versionadded:: 2016.3.4",
            "",
            "        Controls what to do if the file is missing. If set to ``False``, the",
            "        state will display an error raised by the execution module. If set to",
            "        ``True``, the state will simply report no changes.",
            "",
            "    For complex regex patterns, it can be useful to avoid the need for complex",
            "    quoting and escape sequences by making use of YAML's multiline string",
            "    syntax.",
            "",
            "    .. code-block:: yaml",
            "",
            "        complex_search_and_replace:",
            "          file.replace:",
            "            # <...snip...>",
            "            - pattern: |",
            "                CentOS \\(2.6.32[^\\n]+\\n\\s+root[^\\n]+\\n\\)+",
            "",
            "    .. note::",
            "",
            "       When using YAML multiline string syntax in ``pattern:``, make sure to",
            "       also use that syntax in the ``repl:`` part, or you might loose line",
            "       feeds.",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.replace')",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        if ignore_if_missing and 'file not found' in check_msg:",
            "            ret['comment'] = 'No changes needed to be made'",
            "            return ret",
            "        else:",
            "            return _error(ret, check_msg)",
            "",
            "    changes = __salt__['file.replace'](name,",
            "                                       pattern,",
            "                                       repl,",
            "                                       count=count,",
            "                                       flags=flags,",
            "                                       bufsize=bufsize,",
            "                                       append_if_not_found=append_if_not_found,",
            "                                       prepend_if_not_found=prepend_if_not_found,",
            "                                       not_found_content=not_found_content,",
            "                                       backup=backup,",
            "                                       dry_run=__opts__['test'],",
            "                                       show_changes=show_changes,",
            "                                       ignore_if_missing=ignore_if_missing)",
            "",
            "    if changes:",
            "        ret['pchanges']['diff'] = changes",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Changes would have been made:\\ndiff:\\n{0}'.format(changes)",
            "        else:",
            "            ret['result'] = True",
            "            ret['comment'] = 'Changes were made'",
            "            ret['changes'] = {'diff': changes}",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'No changes needed to be made'",
            "",
            "    return ret",
            "",
            "",
            "def blockreplace(",
            "        name,",
            "        marker_start='#-- start managed zone --',",
            "        marker_end='#-- end managed zone --',",
            "        source=None,",
            "        source_hash=None,",
            "        template='jinja',",
            "        sources=None,",
            "        source_hashes=None,",
            "        defaults=None,",
            "        context=None,",
            "        content='',",
            "        append_if_not_found=False,",
            "        prepend_if_not_found=False,",
            "        backup='.bak',",
            "        show_changes=True):",
            "    '''",
            "    Maintain an edit in a file in a zone delimited by two line markers",
            "",
            "    .. versionadded:: 2014.1.0",
            "",
            "    A block of content delimited by comments can help you manage several lines",
            "    entries without worrying about old entries removal. This can help you",
            "    maintaining an un-managed file containing manual edits.",
            "    Note: this function will store two copies of the file in-memory",
            "    (the original version and the edited version) in order to detect changes",
            "    and only edit the targeted file if necessary.",
            "",
            "    name",
            "        Filesystem path to the file to be edited",
            "",
            "    marker_start",
            "        The line content identifying a line as the start of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output",
            "",
            "    marker_end",
            "        The line content identifying a line as the end of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output. Note: you can use file.accumulated and target this state.",
            "        All accumulated data dictionaries content will be added as new lines in",
            "        the content",
            "",
            "    content",
            "        The content to be used between the two lines identified by",
            "        ``marker_start`` and ``marker_end``",
            "",
            "    source",
            "        The source file to download to the minion, this source file can be",
            "        hosted on either the salt master server, or on an HTTP or FTP server.",
            "        Both HTTPS and HTTP are supported as well as downloading directly",
            "        from Amazon S3 compatible URLs with both pre-configured and automatic",
            "        IAM credentials. (see s3.get state documentation)",
            "        File retrieval from Openstack Swift object storage is supported via",
            "        swift://container/object_path URLs, see swift.get documentation.",
            "        For files hosted on the salt file server, if the file is located on",
            "        the master in the directory named spam, and is called eggs, the source",
            "        string is salt://spam/eggs. If source is left blank or None",
            "        (use ~ in YAML), the file will be created as an empty file and",
            "        the content will not be managed. This is also the case when a file",
            "        already exists and the source is undefined; the contents of the file",
            "        will not be changed or managed.",
            "",
            "        If the file is hosted on a HTTP or FTP server then the source_hash",
            "        argument is also required.",
            "",
            "        A list of sources can also be passed in to provide a default source and",
            "        a set of fallbacks. The first source in the list that is found to exist",
            "        will be used and subsequent entries in the list will be ignored.",
            "",
            "        .. code-block:: yaml",
            "",
            "            file_override_example:",
            "              file.blockreplace:",
            "                - name: /etc/example.conf",
            "                - source:",
            "                  - salt://file_that_does_not_exist",
            "                  - salt://file_that_exists",
            "",
            "    source_hash",
            "        This can be one of the following:",
            "            1. a source hash string",
            "            2. the URI of a file that contains source hash strings",
            "",
            "        The function accepts the first encountered long unbroken alphanumeric",
            "        string of correct length as a valid hash, in order from most secure to",
            "        least secure:",
            "",
            "        .. code-block:: text",
            "",
            "            Type    Length",
            "            ======  ======",
            "            sha512     128",
            "            sha384      96",
            "            sha256      64",
            "            sha224      56",
            "            sha1        40",
            "            md5         32",
            "",
            "        See the ``source_hash`` parameter description for :mod:`file.managed",
            "        <salt.states.file.managed>` function for more details and examples.",
            "",
            "    template",
            "        The named templating engine will be used to render the downloaded file.",
            "        Defaults to ``jinja``. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    append_if_not_found",
            "        If markers are not found and set to True then the markers and content",
            "        will be appended to the file. Default is ``False``",
            "",
            "    prepend_if_not_found",
            "        If markers are not found and set to True then the markers and content",
            "        will be prepended to the file. Default is ``False``",
            "",
            "    backup",
            "        The file extension to use for a backup of the file if any edit is made.",
            "        Set this to ``False`` to skip making a backup.",
            "",
            "    dry_run",
            "        Don't make any edits to the file",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made",
            "",
            "    Example of usage with an accumulator and with a variable:",
            "",
            "    .. code-block:: yaml",
            "",
            "        {% set myvar = 42 %}",
            "        hosts-config-block-{{ myvar }}:",
            "          file.blockreplace:",
            "            - name: /etc/hosts",
            "            - marker_start: \"# START managed zone {{ myvar }} -DO-NOT-EDIT-\"",
            "            - marker_end: \"# END managed zone {{ myvar }} --\"",
            "            - content: 'First line of content'",
            "            - append_if_not_found: True",
            "            - backup: '.bak'",
            "            - show_changes: True",
            "",
            "        hosts-config-block-{{ myvar }}-accumulated1:",
            "          file.accumulated:",
            "            - filename: /etc/hosts",
            "            - name: my-accumulator-{{ myvar }}",
            "            - text: \"text 2\"",
            "            - require_in:",
            "              - file: hosts-config-block-{{ myvar }}",
            "",
            "        hosts-config-block-{{ myvar }}-accumulated2:",
            "          file.accumulated:",
            "            - filename: /etc/hosts",
            "            - name: my-accumulator-{{ myvar }}",
            "            - text: |",
            "                 text 3",
            "                 text 4",
            "            - require_in:",
            "              - file: hosts-config-block-{{ myvar }}",
            "",
            "    will generate and maintain a block of content in ``/etc/hosts``:",
            "",
            "    .. code-block:: text",
            "",
            "        # START managed zone 42 -DO-NOT-EDIT-",
            "        First line of content",
            "        text 2",
            "        text 3",
            "        text 4",
            "        # END managed zone 42 --",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.blockreplace')",
            "",
            "    if sources is None:",
            "        sources = []",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    (ok_, err, sl_) = _unify_sources_and_hashes(source=source,",
            "                                                source_hash=source_hash,",
            "                                                sources=sources,",
            "                                                source_hashes=source_hashes)",
            "    if not ok_:",
            "        return _error(ret, err)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    accum_data, accum_deps = _load_accumulators()",
            "    if name in accum_data:",
            "        accumulator = accum_data[name]",
            "        # if we have multiple accumulators for a file, only apply the one",
            "        # required at a time",
            "        deps = accum_deps.get(name, [])",
            "        filtered = [a for a in deps if",
            "                    __low__['__id__'] in deps[a] and a in accumulator]",
            "        if not filtered:",
            "            filtered = [a for a in accumulator]",
            "        for acc in filtered:",
            "            acc_content = accumulator[acc]",
            "            for line in acc_content:",
            "                if content == '':",
            "                    content = line",
            "                else:",
            "                    content += \"\\n\" + line",
            "",
            "    if sl_:",
            "        tmpret = _get_template_texts(source_list=sl_,",
            "                                     template=template,",
            "                                     defaults=defaults,",
            "                                     context=context)",
            "        if not tmpret['result']:",
            "            return tmpret",
            "        text = tmpret['data']",
            "",
            "        for index, item in enumerate(text):",
            "            content += str(item)",
            "",
            "    changes = __salt__['file.blockreplace'](",
            "        name,",
            "        marker_start,",
            "        marker_end,",
            "        content=content,",
            "        append_if_not_found=append_if_not_found,",
            "        prepend_if_not_found=prepend_if_not_found,",
            "        backup=backup,",
            "        dry_run=__opts__['test'],",
            "        show_changes=show_changes",
            "    )",
            "",
            "    if changes:",
            "        ret['pchanges'] = {'diff': changes}",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Changes would be made'",
            "        else:",
            "            ret['changes'] = {'diff': changes}",
            "            ret['result'] = True",
            "            ret['comment'] = 'Changes were made'",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'No changes needed to be made'",
            "",
            "    return ret",
            "",
            "",
            "def comment(name, regex, char='#', backup='.bak'):",
            "    '''",
            "    Comment out specified lines in a file.",
            "",
            "    name",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be commented;",
            "        this pattern will be wrapped in parenthesis and will move any",
            "        preceding/trailing ``^`` or ``$`` characters outside the parenthesis",
            "        (e.g., the pattern ``^foo$`` will be rewritten as ``^(foo)$``)",
            "        Note that you _need_ the leading ^, otherwise each time you run",
            "        highstate, another comment char will be inserted.",
            "    char : ``#``",
            "        The character to be inserted at the beginning of a line in order to",
            "        comment it out",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension",
            "",
            "        .. warning::",
            "",
            "            This backup will be overwritten each time ``sed`` / ``comment`` /",
            "            ``uncomment`` is called. Meaning the backup will only be useful",
            "            after the first invocation.",
            "",
            "        Set to False/None to not keep a backup.",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/fstab:",
            "          file.comment:",
            "            - regex: ^bind 127.0.0.1",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.comment')",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    unanchor_regex = regex.lstrip('^').rstrip('$')",
            "    comment_regex = char + unanchor_regex",
            "",
            "    # Check if the line is already commented",
            "    if __salt__['file.search'](name, comment_regex, multiline=True):",
            "        commented = True",
            "    else:",
            "        commented = False",
            "",
            "    # Make sure the pattern appears in the file before continuing",
            "    if commented or not __salt__['file.search'](name, regex, multiline=True):",
            "        if __salt__['file.search'](name, unanchor_regex, multiline=True):",
            "            ret['comment'] = 'Pattern already commented'",
            "            ret['result'] = True",
            "            return ret",
            "        else:",
            "            return _error(ret, '{0}: Pattern not found'.format(unanchor_regex))",
            "",
            "    ret['pchanges'][name] = 'updated'",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "        ret['result'] = None",
            "        return ret",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.readlines()",
            "",
            "    # Perform the edit",
            "    __salt__['file.comment_line'](name, regex, char, True, backup)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.readlines()",
            "",
            "    # Check the result",
            "    ret['result'] = __salt__['file.search'](name, unanchor_regex, multiline=True)",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                ''.join(difflib.unified_diff(slines, nlines))",
            "            )",
            "",
            "    if ret['result']:",
            "        ret['comment'] = 'Commented lines successfully'",
            "    else:",
            "        ret['comment'] = 'Expected commented lines not found'",
            "",
            "    return ret",
            "",
            "",
            "def uncomment(name, regex, char='#', backup='.bak'):",
            "    '''",
            "    Uncomment specified commented lines in a file",
            "",
            "    name",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be uncommented.",
            "        This regex should not include the comment character. A leading ``^``",
            "        character will be stripped for convenience (for easily switching",
            "        between comment() and uncomment()).  The regex will be searched for",
            "        from the beginning of the line, ignoring leading spaces (we prepend",
            "        '^[ \\\\t]*')",
            "    char : ``#``",
            "        The character to remove in order to uncomment a line",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "",
            "        .. warning::",
            "",
            "            This backup will be overwritten each time ``sed`` / ``comment`` /",
            "            ``uncomment`` is called. Meaning the backup will only be useful",
            "            after the first invocation.",
            "",
            "        Set to False/None to not keep a backup.",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/adduser.conf:",
            "          file.uncomment:",
            "            - regex: EXTRA_GROUPS",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.uncomment')",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    # Make sure the pattern appears in the file",
            "    if __salt__['file.search'](",
            "            name,",
            "            '^[ \\t]*{0}'.format(regex.lstrip('^')),",
            "            multiline=True):",
            "        ret['comment'] = 'Pattern already uncommented'",
            "        ret['result'] = True",
            "        return ret",
            "    elif __salt__['file.search'](",
            "            name,",
            "            '{0}[ \\t]*{1}'.format(char, regex.lstrip('^')),",
            "            multiline=True):",
            "        # Line exists and is commented",
            "        pass",
            "    else:",
            "        return _error(ret, '{0}: Pattern not found'.format(regex))",
            "",
            "    ret['pchanges'][name] = 'updated'",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "        ret['result'] = None",
            "        return ret",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.readlines()",
            "",
            "    # Perform the edit",
            "    __salt__['file.comment_line'](name, regex, char, False, backup)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.readlines()",
            "",
            "    # Check the result",
            "    ret['result'] = __salt__['file.search'](",
            "        name,",
            "        '^[ \\t]*{0}'.format(regex.lstrip('^')),",
            "        multiline=True",
            "    )",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                ''.join(difflib.unified_diff(slines, nlines))",
            "            )",
            "",
            "    if ret['result']:",
            "        ret['comment'] = 'Uncommented lines successfully'",
            "    else:",
            "        ret['comment'] = 'Expected uncommented lines not found'",
            "",
            "    return ret",
            "",
            "",
            "def append(name,",
            "           text=None,",
            "           makedirs=False,",
            "           source=None,",
            "           source_hash=None,",
            "           template='jinja',",
            "           sources=None,",
            "           source_hashes=None,",
            "           defaults=None,",
            "           context=None,",
            "           ignore_whitespace=True):",
            "    '''",
            "    Ensure that some text appears at the end of a file.",
            "",
            "    The text will not be appended if it already exists in the file.",
            "    A single string of text or a list of strings may be appended.",
            "",
            "    name",
            "        The location of the file to append to.",
            "",
            "    text",
            "        The text to be appended, which can be a single string or a list",
            "        of strings.",
            "",
            "    makedirs",
            "        If the file is located in a path without a parent directory,",
            "        then the state will fail. If makedirs is set to True, then",
            "        the parent directories will be created to facilitate the",
            "        creation of the named file. Defaults to False.",
            "",
            "    source",
            "        A single source file to append. This source file can be hosted on either",
            "        the salt master server, or on an HTTP or FTP server. Both HTTPS and",
            "        HTTP are supported as well as downloading directly from Amazon S3",
            "        compatible URLs with both pre-configured and automatic IAM credentials",
            "        (see s3.get state documentation). File retrieval from Openstack Swift",
            "        object storage is supported via swift://container/object_path URLs",
            "        (see swift.get documentation).",
            "",
            "        For files hosted on the salt file server, if the file is located on",
            "        the master in the directory named spam, and is called eggs, the source",
            "        string is salt://spam/eggs.",
            "",
            "        If the file is hosted on an HTTP or FTP server, the source_hash argument",
            "        is also required.",
            "",
            "    source_hash",
            "        This can be one of the following:",
            "            1. a source hash string",
            "            2. the URI of a file that contains source hash strings",
            "",
            "        The function accepts the first encountered long unbroken alphanumeric",
            "        string of correct length as a valid hash, in order from most secure to",
            "        least secure:",
            "",
            "        .. code-block:: text",
            "",
            "            Type    Length",
            "            ======  ======",
            "            sha512     128",
            "            sha384      96",
            "            sha256      64",
            "            sha224      56",
            "            sha1        40",
            "            md5         32",
            "",
            "        See the ``source_hash`` parameter description for :mod:`file.managed",
            "        <salt.states.file.managed>` function for more details and examples.",
            "",
            "    template",
            "        The named templating engine will be used to render the appended-to file.",
            "        Defaults to ``jinja``. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "    sources",
            "        A list of source files to append. If the files are hosted on an HTTP or",
            "        FTP server, the source_hashes argument is also required.",
            "",
            "    source_hashes",
            "        A list of source_hashes corresponding to the sources list specified in",
            "        the sources argument.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    ignore_whitespace",
            "        .. versionadded:: 2015.8.4",
            "",
            "        Spaces and Tabs in text are ignored by default, when searching for the",
            "        appending content, one space or multiple tabs are the same for salt.",
            "        Set this option to ``False`` if you want to change this behavior.",
            "",
            "    Multi-line example:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.append:",
            "            - text: |",
            "                Thou hadst better eat salt with the Philosophers of Greece,",
            "                than sugar with the Courtiers of Italy.",
            "                - Benjamin Franklin",
            "",
            "    Multiple lines of text:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.append:",
            "            - text:",
            "              - Trust no one unless you have eaten much salt with him.",
            "              - \"Salt is born of the purest of parents: the sun and the sea.\"",
            "",
            "    Gather text from multiple template files:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file:",
            "              - append",
            "              - template: jinja",
            "              - sources:",
            "                - salt://motd/devops-messages.tmpl",
            "                - salt://motd/hr-messages.tmpl",
            "                - salt://motd/general-messages.tmpl",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    ret = {'name': name,",
            "            'changes': {},",
            "            'pchanges': {},",
            "            'result': False,",
            "            'comment': ''}",
            "",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.append')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    if sources is None:",
            "        sources = []",
            "",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    # Add sources and source_hashes with template support",
            "    # NOTE: FIX 'text' and any 'source' are mutually exclusive as 'text'",
            "    #       is re-assigned in the original code.",
            "    (ok_, err, sl_) = _unify_sources_and_hashes(source=source,",
            "                                                source_hash=source_hash,",
            "                                                sources=sources,",
            "                                                source_hashes=source_hashes)",
            "    if not ok_:",
            "        return _error(ret, err)",
            "",
            "    if makedirs is True:",
            "        dirname = os.path.dirname(name)",
            "        if not __salt__['file.directory_exists'](dirname):",
            "            __salt__['file.makedirs'](name)",
            "            check_res, check_msg, ret['pchanges'] = _check_directory(",
            "                dirname, None, None, False, None, False, False, None",
            "            )",
            "            if not check_res:",
            "                return _error(ret, check_msg)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        # Try to create the file",
            "        touch(name, makedirs=makedirs)",
            "        retry_res, retry_msg = _check_file(name)",
            "        if not retry_res:",
            "            return _error(ret, check_msg)",
            "",
            "    # Follow the original logic and re-assign 'text' if using source(s)...",
            "    if sl_:",
            "        tmpret = _get_template_texts(source_list=sl_,",
            "                                     template=template,",
            "                                     defaults=defaults,",
            "                                     context=context)",
            "        if not tmpret['result']:",
            "            return tmpret",
            "        text = tmpret['data']",
            "",
            "    text = _validate_str_list(text)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.read().splitlines()",
            "",
            "    append_lines = []",
            "    try:",
            "        for chunk in text:",
            "            if ignore_whitespace:",
            "                if __salt__['file.search'](",
            "                        name,",
            "                        salt.utils.build_whitespace_split_regex(chunk),",
            "                        multiline=True):",
            "                    continue",
            "            elif __salt__['file.search'](",
            "                    name,",
            "                    chunk,",
            "                    multiline=True):",
            "                continue",
            "",
            "            for line_item in chunk.splitlines():",
            "                append_lines.append('{0}'.format(line_item))",
            "",
            "    except TypeError:",
            "        return _error(ret, 'No text found to append. Nothing appended')",
            "",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "        ret['result'] = None",
            "        nlines = list(slines)",
            "        nlines.extend(append_lines)",
            "        if slines != nlines:",
            "            if not salt.utils.istextfile(name):",
            "                ret['changes']['diff'] = 'Replace binary file'",
            "            else:",
            "                # Changes happened, add them",
            "                ret['changes']['diff'] = (",
            "                    '\\n'.join(difflib.unified_diff(slines, nlines))",
            "                )",
            "        else:",
            "            ret['comment'] = 'File {0} is in correct state'.format(name)",
            "            ret['result'] = True",
            "        return ret",
            "",
            "    if append_lines:",
            "        __salt__['file.append'](name, args=append_lines)",
            "        ret['comment'] = 'Appended {0} lines'.format(len(append_lines))",
            "    else:",
            "        ret['comment'] = 'File {0} is in correct state'.format(name)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.read().splitlines()",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                '\\n'.join(difflib.unified_diff(slines, nlines)))",
            "",
            "    ret['result'] = True",
            "",
            "    return ret",
            "",
            "",
            "def prepend(name,",
            "            text=None,",
            "            makedirs=False,",
            "            source=None,",
            "            source_hash=None,",
            "            template='jinja',",
            "            sources=None,",
            "            source_hashes=None,",
            "            defaults=None,",
            "            context=None,",
            "            header=None):",
            "    '''",
            "    Ensure that some text appears at the beginning of a file",
            "",
            "    The text will not be prepended again if it already exists in the file. You",
            "    may specify a single line of text or a list of lines to append.",
            "",
            "    Multi-line example:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.prepend:",
            "            - text: |",
            "                Thou hadst better eat salt with the Philosophers of Greece,",
            "                than sugar with the Courtiers of Italy.",
            "                - Benjamin Franklin",
            "",
            "    Multiple lines of text:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.prepend:",
            "            - text:",
            "              - Trust no one unless you have eaten much salt with him.",
            "              - \"Salt is born of the purest of parents: the sun and the sea.\"",
            "",
            "    Optionally, require the text to appear exactly as specified",
            "    (order and position). Combine with multi-line or multiple lines of input.",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.prepend:",
            "            - header: True",
            "            - text:",
            "              - This will be the very first line in the file.",
            "              - The 2nd line, regardless of duplicates elsewhere in the file.",
            "              - These will be written anew if they do not appear verbatim.",
            "",
            "    Gather text from multiple template files:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file:",
            "              - prepend",
            "              - template: jinja",
            "              - sources:",
            "                - salt://motd/devops-messages.tmpl",
            "                - salt://motd/hr-messages.tmpl",
            "                - salt://motd/general-messages.tmpl",
            "",
            "    .. versionadded:: 2014.7.0",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.prepend')",
            "",
            "    if sources is None:",
            "        sources = []",
            "",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    # Add sources and source_hashes with template support",
            "    # NOTE: FIX 'text' and any 'source' are mutually exclusive as 'text'",
            "    #       is re-assigned in the original code.",
            "    (ok_, err, sl_) = _unify_sources_and_hashes(source=source,",
            "                                                source_hash=source_hash,",
            "                                                sources=sources,",
            "                                                source_hashes=source_hashes)",
            "    if not ok_:",
            "        return _error(ret, err)",
            "",
            "    if makedirs is True:",
            "        dirname = os.path.dirname(name)",
            "        if not __salt__['file.directory_exists'](dirname):",
            "            __salt__['file.makedirs'](name)",
            "            check_res, check_msg, ret['pchanges'] = _check_directory(",
            "                dirname, None, None, False, None, False, False, None",
            "            )",
            "            if not check_res:",
            "                return _error(ret, check_msg)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        # Try to create the file",
            "        touch(name, makedirs=makedirs)",
            "        retry_res, retry_msg = _check_file(name)",
            "        if not retry_res:",
            "            return _error(ret, check_msg)",
            "",
            "    # Follow the original logic and re-assign 'text' if using source(s)...",
            "    if sl_:",
            "        tmpret = _get_template_texts(source_list=sl_,",
            "                                     template=template,",
            "                                     defaults=defaults,",
            "                                     context=context)",
            "        if not tmpret['result']:",
            "            return tmpret",
            "        text = tmpret['data']",
            "",
            "    text = _validate_str_list(text)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.readlines()",
            "",
            "    count = 0",
            "    test_lines = []",
            "",
            "    preface = []",
            "    for chunk in text:",
            "",
            "        # if header kwarg is unset of False, use regex search",
            "        if not header:",
            "            if __salt__['file.search'](",
            "                    name,",
            "                    salt.utils.build_whitespace_split_regex(chunk),",
            "                    multiline=True):",
            "                continue",
            "",
            "        lines = chunk.splitlines()",
            "",
            "        for line in lines:",
            "            if __opts__['test']:",
            "                ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "                ret['result'] = None",
            "                test_lines.append('{0}\\n'.format(line))",
            "            else:",
            "                preface.append(line)",
            "            count += 1",
            "",
            "    if __opts__['test']:",
            "        nlines = test_lines + slines",
            "        if slines != nlines:",
            "            if not salt.utils.istextfile(name):",
            "                ret['changes']['diff'] = 'Replace binary file'",
            "            else:",
            "                # Changes happened, add them",
            "                ret['changes']['diff'] = (",
            "                    ''.join(difflib.unified_diff(slines, nlines))",
            "                )",
            "            ret['result'] = None",
            "        else:",
            "            ret['comment'] = 'File {0} is in correct state'.format(name)",
            "            ret['result'] = True",
            "        return ret",
            "",
            "    # if header kwarg is True, use verbatim compare",
            "    if header:",
            "        with salt.utils.fopen(name, 'rb') as fp_:",
            "            # read as many lines of target file as length of user input",
            "            target_head = fp_.readlines()[0:len(preface)]",
            "            target_lines = []",
            "            # strip newline chars from list entries",
            "            for chunk in target_head:",
            "                target_lines += chunk.splitlines()",
            "            # compare current top lines in target file with user input",
            "            # and write user input if they differ",
            "            if target_lines != preface:",
            "                __salt__['file.prepend'](name, *preface)",
            "            else:",
            "                # clear changed lines counter if target file not modified",
            "                count = 0",
            "    else:",
            "        __salt__['file.prepend'](name, *preface)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.readlines()",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                ''.join(difflib.unified_diff(slines, nlines))",
            "            )",
            "",
            "    if count:",
            "        ret['comment'] = 'Prepended {0} lines'.format(count)",
            "    else:",
            "        ret['comment'] = 'File {0} is in correct state'.format(name)",
            "    ret['result'] = True",
            "    return ret",
            "",
            "",
            "def patch(name,",
            "          source=None,",
            "          options='',",
            "          dry_run_first=True,",
            "          **kwargs):",
            "    '''",
            "    Apply a patch to a file or directory.",
            "",
            "    .. note::",
            "",
            "        A suitable ``patch`` executable must be available on the minion when",
            "        using this state function.",
            "",
            "    name",
            "        The file or directory to which the patch will be applied.",
            "",
            "    source",
            "        The source patch to download to the minion, this source file must be",
            "        hosted on the salt master server. If the file is located in the",
            "        directory named spam, and is called eggs, the source string is",
            "        salt://spam/eggs. A source is required.",
            "",
            "    hash",
            "        The hash of the patched file. If the hash of the target file matches",
            "        this value then the patch is assumed to have been applied. For versions",
            "        2016.11.4 and newer, the hash can be specified without an accompanying",
            "        hash type (e.g. ``e138491e9d5b97023cea823fe17bac22``), but for earlier",
            "        releases it is necessary to also specify the hash type in the format",
            "        ``<hash_type>:<hash_value>`` (e.g.",
            "        ``md5:e138491e9d5b97023cea823fe17bac22``).",
            "",
            "    options",
            "        Extra options to pass to patch.",
            "",
            "    dry_run_first : ``True``",
            "        Run patch with ``--dry-run`` first to check if it will apply cleanly.",
            "",
            "    saltenv",
            "        Specify the environment from which to retrieve the patch file indicated",
            "        by the ``source`` parameter. If not provided, this defaults to the",
            "        environment from which the state is being executed.",
            "",
            "    **Usage:**",
            "",
            "    .. code-block:: yaml",
            "",
            "        # Equivalent to ``patch --forward /opt/file.txt file.patch``",
            "        /opt/file.txt:",
            "          file.patch:",
            "            - source: salt://file.patch",
            "            - hash: e138491e9d5b97023cea823fe17bac22",
            "",
            "    .. note::",
            "        For minions running version 2016.11.3 or older, the hash in the example",
            "        above would need to be specified with the hash type (i.e.",
            "        ``md5:e138491e9d5b97023cea823fe17bac22``).",
            "    '''",
            "    hash_ = kwargs.pop('hash', None)",
            "",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.patch')",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "    if not source:",
            "        return _error(ret, 'Source is required')",
            "    if hash_ is None:",
            "        return _error(ret, 'Hash is required')",
            "",
            "    try:",
            "        if hash_ and __salt__['file.check_hash'](name, hash_):",
            "            ret['result'] = True",
            "            ret['comment'] = 'Patch is already applied'",
            "            return ret",
            "    except (SaltInvocationError, ValueError) as exc:",
            "        ret['comment'] = exc.__str__()",
            "        return ret",
            "",
            "    # get cached file or copy it to cache",
            "    cached_source_path = __salt__['cp.cache_file'](source, __env__)",
            "    if not cached_source_path:",
            "        ret['comment'] = ('Unable to cache {0} from saltenv \\'{1}\\''",
            "                          .format(source, __env__))",
            "        return ret",
            "",
            "    log.debug(",
            "        'State patch.applied cached source %s -> %s',",
            "        source, cached_source_path",
            "    )",
            "",
            "    if dry_run_first or __opts__['test']:",
            "        ret['changes'] = __salt__['file.patch'](",
            "            name, cached_source_path, options=options, dry_run=True",
            "        )",
            "        if __opts__['test']:",
            "            ret['comment'] = 'File {0} will be patched'.format(name)",
            "            ret['result'] = None",
            "            return ret",
            "        if ret['changes']['retcode'] != 0:",
            "            return ret",
            "",
            "    ret['changes'] = __salt__['file.patch'](",
            "        name, cached_source_path, options=options",
            "    )",
            "    ret['result'] = ret['changes']['retcode'] == 0",
            "    # No need to check for SaltInvocationError or ValueError this time, since",
            "    # these exceptions would have been caught above.",
            "    if ret['result'] and hash_ and not __salt__['file.check_hash'](name, hash_):",
            "        ret['result'] = False",
            "        ret['comment'] = 'Hash mismatch after patch was applied'",
            "    return ret",
            "",
            "",
            "def touch(name, atime=None, mtime=None, makedirs=False):",
            "    '''",
            "    Replicate the 'nix \"touch\" command to create a new empty",
            "    file or update the atime and mtime of an existing file.",
            "",
            "    Note that if you just want to create a file and don't care about atime or",
            "    mtime, you should use ``file.managed`` instead, as it is more",
            "    feature-complete.  (Just leave out the ``source``/``template``/``contents``",
            "    arguments, and it will just create the file and/or check its permissions,",
            "    without messing with contents)",
            "",
            "    name",
            "        name of the file",
            "",
            "    atime",
            "        atime of the file",
            "",
            "    mtime",
            "        mtime of the file",
            "",
            "    makedirs",
            "        whether we should create the parent directory/directories in order to",
            "        touch the file",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /var/log/httpd/logrotate.empty:",
            "          file.touch",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "    }",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.touch')",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name)",
            "        )",
            "",
            "    if __opts__['test']:",
            "        ret['result'], ret['comment'] = _check_touch(name, atime, mtime)",
            "        return ret",
            "",
            "    if makedirs:",
            "        __salt__['file.makedirs'](name)",
            "    if not os.path.isdir(os.path.dirname(name)):",
            "        return _error(",
            "            ret, 'Directory not present to touch file {0}'.format(name)",
            "        )",
            "",
            "    extant = os.path.exists(name)",
            "",
            "    ret['result'] = __salt__['file.touch'](name, atime, mtime)",
            "    if not extant and ret['result']:",
            "        ret['comment'] = 'Created empty file {0}'.format(name)",
            "        ret['changes']['new'] = name",
            "    elif extant and ret['result']:",
            "        ret['comment'] = 'Updated times on {0} {1}'.format(",
            "            'directory' if os.path.isdir(name) else 'file', name",
            "        )",
            "        ret['changes']['touched'] = name",
            "",
            "    return ret",
            "",
            "",
            "def copy(",
            "        name,",
            "        source,",
            "        force=False,",
            "        makedirs=False,",
            "        preserve=False,",
            "        user=None,",
            "        group=None,",
            "        mode=None,",
            "        subdir=False,",
            "        **kwargs):",
            "    '''",
            "    If the source file exists on the system, copy it to the named file. The",
            "    named file will not be overwritten if it already exists unless the force",
            "    option is set to True.",
            "",
            "    name",
            "        The location of the file to copy to",
            "",
            "    source",
            "        The location of the file to copy to the location specified with name",
            "",
            "    force",
            "        If the target location is present then the file will not be moved,",
            "        specify \"force: True\" to overwrite the target file",
            "",
            "    makedirs",
            "        If the target subdirectories don't exist create them",
            "",
            "    preserve",
            "        .. versionadded:: 2015.5.0",
            "",
            "        Set ``preserve: True`` to preserve user/group ownership and mode",
            "        after copying. Default is ``False``. If ``preserve`` is set to ``True``,",
            "        then user/group/mode attributes will be ignored.",
            "",
            "    user",
            "        .. versionadded:: 2015.5.0",
            "",
            "        The user to own the copied file, this defaults to the user salt is",
            "        running as on the minion. If ``preserve`` is set to ``True``, then",
            "        this will be ignored",
            "",
            "    group",
            "        .. versionadded:: 2015.5.0",
            "",
            "        The group to own the copied file, this defaults to the group salt is",
            "        running as on the minion. If ``preserve`` is set to ``True`` or on",
            "        Windows this will be ignored",
            "",
            "    mode",
            "        .. versionadded:: 2015.5.0",
            "",
            "        The permissions to set on the copied file, aka 644, '0775', '4664'.",
            "        If ``preserve`` is set to ``True``, then this will be ignored.",
            "        Not supported on Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    subdir",
            "        .. versionadded:: 2015.5.0",
            "",
            "        If the name is a directory then place the file inside the named",
            "        directory",
            "",
            "    .. note::",
            "        The copy function accepts paths that are local to the Salt minion.",
            "        This function does not support salt://, http://, or the other",
            "        additional file paths that are supported by :mod:`states.file.managed",
            "        <salt.states.file.managed>` and :mod:`states.file.recurse",
            "        <salt.states.file.recurse>`.",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    source = os.path.expanduser(source)",
            "",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'comment': 'Copied \"{0}\" to \"{1}\"'.format(source, name),",
            "        'result': True}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.copy')",
            "",
            "    changed = True",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    if not os.path.exists(source):",
            "        return _error(ret, 'Source file \"{0}\" is not present'.format(source))",
            "",
            "    if preserve:",
            "        user = __salt__['file.get_user'](source)",
            "        group = __salt__['file.get_group'](source)",
            "        mode = __salt__['file.get_mode'](source)",
            "    else:",
            "        user = _test_owner(kwargs, user=user)",
            "        if user is None:",
            "            user = __opts__['user']",
            "",
            "        if salt.utils.is_windows():",
            "            if group is not None:",
            "                log.warning(",
            "                    'The group argument for {0} has been ignored as this is '",
            "                    'a Windows system.'.format(name)",
            "                )",
            "            group = user",
            "",
            "        if group is None:",
            "            group = __salt__['file.gid_to_group'](",
            "                __salt__['user.info'](user).get('gid', 0)",
            "            )",
            "",
            "        u_check = _check_user(user, group)",
            "        if u_check:",
            "            # The specified user or group do not exist",
            "            return _error(ret, u_check)",
            "",
            "        if mode is None:",
            "            mode = __salt__['file.get_mode'](source)",
            "",
            "    if os.path.isdir(name) and subdir:",
            "        # If the target is a dir, and overwrite_dir is False, copy into the dir",
            "        name = os.path.join(name, os.path.basename(source))",
            "",
            "    if os.path.lexists(source) and os.path.lexists(name):",
            "        # if this is a file which did not change, do not update",
            "        if force and os.path.isfile(name):",
            "            hash1 = salt.utils.get_hash(name)",
            "            hash2 = salt.utils.get_hash(source)",
            "            if hash1 == hash2:",
            "                changed = True",
            "                ret['comment'] = ' '.join([ret['comment'], '- files are identical but force flag is set'])",
            "        if not force:",
            "            changed = False",
            "        elif not __opts__['test'] and changed:",
            "            # Remove the destination to prevent problems later",
            "            try:",
            "                __salt__['file.remove'](name)",
            "            except (IOError, OSError):",
            "                return _error(",
            "                    ret,",
            "                    'Failed to delete \"{0}\" in preparation for '",
            "                    'forced move'.format(name)",
            "                )",
            "",
            "    if __opts__['test']:",
            "        if changed:",
            "            ret['comment'] = 'File \"{0}\" is set to be copied to \"{1}\"'.format(",
            "                source,",
            "                name",
            "            )",
            "            ret['result'] = None",
            "        else:",
            "            ret['comment'] = ('The target file \"{0}\" exists and will not be '",
            "                              'overwritten'.format(name))",
            "            ret['result'] = True",
            "        return ret",
            "",
            "    if not changed:",
            "        ret['comment'] = ('The target file \"{0}\" exists and will not be '",
            "                          'overwritten'.format(name))",
            "        ret['result'] = True",
            "        return ret",
            "",
            "    # Run makedirs",
            "    dname = os.path.dirname(name)",
            "    if not os.path.isdir(dname):",
            "        if makedirs:",
            "            __salt__['file.makedirs'](name)",
            "        else:",
            "            return _error(",
            "                ret,",
            "                'The target directory {0} is not present'.format(dname))",
            "    # All tests pass, move the file into place",
            "    try:",
            "        if os.path.isdir(source):",
            "            shutil.copytree(source, name, symlinks=True)",
            "            for root, dirs, files in os.walk(name):",
            "                for dir_ in dirs:",
            "                    __salt__['file.lchown'](os.path.join(root, dir_), user, group)",
            "                for file_ in files:",
            "                    __salt__['file.lchown'](os.path.join(root, file_), user, group)",
            "        else:",
            "            shutil.copy(source, name)",
            "        ret['changes'] = {name: source}",
            "        # Preserve really means just keep the behavior of the cp command. If",
            "        # the filesystem we're copying to is squashed or doesn't support chown",
            "        # then we shouldn't be checking anything.",
            "        if not preserve:",
            "            __salt__['file.check_perms'](name, ret, user, group, mode)",
            "    except (IOError, OSError):",
            "        return _error(",
            "            ret, 'Failed to copy \"{0}\" to \"{1}\"'.format(source, name))",
            "    return ret",
            "",
            "",
            "def rename(name, source, force=False, makedirs=False):",
            "    '''",
            "    If the source file exists on the system, rename it to the named file. The",
            "    named file will not be overwritten if it already exists unless the force",
            "    option is set to True.",
            "",
            "    name",
            "        The location of the file to rename to",
            "",
            "    source",
            "        The location of the file to move to the location specified with name",
            "",
            "    force",
            "        If the target location is present then the file will not be moved,",
            "        specify \"force: True\" to overwrite the target file",
            "",
            "    makedirs",
            "        If the target subdirectories don't exist create them",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    source = os.path.expanduser(source)",
            "",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'comment': '',",
            "        'result': True}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.rename')",
            "",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    if not os.path.lexists(source):",
            "        ret['comment'] = ('Source file \"{0}\" has already been moved out of '",
            "                          'place').format(source)",
            "        return ret",
            "",
            "    if os.path.lexists(source) and os.path.lexists(name):",
            "        if not force:",
            "            ret['comment'] = ('The target file \"{0}\" exists and will not be '",
            "                              'overwritten'.format(name))",
            "            ret['result'] = False",
            "            return ret",
            "        elif not __opts__['test']:",
            "            # Remove the destination to prevent problems later",
            "            try:",
            "                __salt__['file.remove'](name)",
            "            except (IOError, OSError):",
            "                return _error(",
            "                    ret,",
            "                    'Failed to delete \"{0}\" in preparation for '",
            "                    'forced move'.format(name)",
            "                )",
            "",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File \"{0}\" is set to be moved to \"{1}\"'.format(",
            "            source,",
            "            name",
            "        )",
            "        ret['result'] = None",
            "        return ret",
            "",
            "    # Run makedirs",
            "    dname = os.path.dirname(name)",
            "    if not os.path.isdir(dname):",
            "        if makedirs:",
            "            __salt__['file.makedirs'](name)",
            "        else:",
            "            return _error(",
            "                ret,",
            "                'The target directory {0} is not present'.format(dname))",
            "    # All tests pass, move the file into place",
            "    try:",
            "        if os.path.islink(source):",
            "            linkto = os.readlink(source)",
            "            os.symlink(linkto, name)",
            "            os.unlink(source)",
            "        else:",
            "            shutil.move(source, name)",
            "    except (IOError, OSError):",
            "        return _error(",
            "            ret, 'Failed to move \"{0}\" to \"{1}\"'.format(source, name))",
            "",
            "    ret['comment'] = 'Moved \"{0}\" to \"{1}\"'.format(source, name)",
            "    ret['changes'] = {name: source}",
            "    return ret",
            "",
            "",
            "def accumulated(name, filename, text, **kwargs):",
            "    '''",
            "    Prepare accumulator which can be used in template in file.managed state.",
            "    Accumulator dictionary becomes available in template. It can also be used",
            "    in file.blockreplace.",
            "",
            "    name",
            "        Accumulator name",
            "",
            "    filename",
            "        Filename which would receive this accumulator (see file.managed state",
            "        documentation about ``name``)",
            "",
            "    text",
            "        String or list for adding in accumulator",
            "",
            "    require_in / watch_in",
            "        One of them required for sure we fill up accumulator before we manage",
            "        the file. Probably the same as filename",
            "",
            "    Example:",
            "",
            "    Given the following:",
            "",
            "    .. code-block:: yaml",
            "",
            "        animals_doing_things:",
            "          file.accumulated:",
            "            - filename: /tmp/animal_file.txt",
            "            - text: ' jumps over the lazy dog.'",
            "            - require_in:",
            "              - file: animal_file",
            "",
            "        animal_file:",
            "          file.managed:",
            "            - name: /tmp/animal_file.txt",
            "            - source: salt://animal_file.txt",
            "            - template: jinja",
            "",
            "    One might write a template for ``animal_file.txt`` like the following:",
            "",
            "    .. code-block:: jinja",
            "",
            "        The quick brown fox{% for animal in accumulator['animals_doing_things'] %}{{ animal }}{% endfor %}",
            "",
            "    Collectively, the above states and template file will produce:",
            "",
            "    .. code-block:: text",
            "",
            "        The quick brown fox jumps over the lazy dog.",
            "",
            "    Multiple accumulators can be \"chained\" together.",
            "",
            "    .. note::",
            "        The 'accumulator' data structure is a Python dictionary.",
            "        Do not expect any loop over the keys in a deterministic order!",
            "    '''",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'result': True,",
            "        'comment': ''",
            "    }",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.accumulated')",
            "    if text is None:",
            "        ret['result'] = False",
            "        ret['comment'] = 'No text supplied for accumulator'",
            "        return ret",
            "    require_in = __low__.get('require_in', [])",
            "    watch_in = __low__.get('watch_in', [])",
            "    deps = require_in + watch_in",
            "    if not [x for x in deps if 'file' in x]:",
            "        ret['result'] = False",
            "        ret['comment'] = 'Orphaned accumulator {0} in {1}:{2}'.format(",
            "            name,",
            "            __low__['__sls__'],",
            "            __low__['__id__']",
            "        )",
            "        return ret",
            "    if isinstance(text, six.string_types):",
            "        text = (text,)",
            "    elif isinstance(text, dict):",
            "        text = (text,)",
            "    accum_data, accum_deps = _load_accumulators()",
            "    if filename not in accum_data:",
            "        accum_data[filename] = {}",
            "    if filename not in accum_deps:",
            "        accum_deps[filename] = {}",
            "    if name not in accum_deps[filename]:",
            "        accum_deps[filename][name] = []",
            "    for accumulator in deps:",
            "        accum_deps[filename][name].extend(six.itervalues(accumulator))",
            "    if name not in accum_data[filename]:",
            "        accum_data[filename][name] = []",
            "    for chunk in text:",
            "        if chunk not in accum_data[filename][name]:",
            "            accum_data[filename][name].append(chunk)",
            "            ret['comment'] = ('Accumulator {0} for file {1} '",
            "                              'was charged by text'.format(name, filename))",
            "    _persist_accummulators(accum_data, accum_deps)",
            "    return ret",
            "",
            "",
            "def serialize(name,",
            "              dataset=None,",
            "              dataset_pillar=None,",
            "              user=None,",
            "              group=None,",
            "              mode=None,",
            "              backup='',",
            "              makedirs=False,",
            "              show_diff=None,",
            "              show_changes=True,",
            "              create=True,",
            "              merge_if_exists=False,",
            "              **kwargs):",
            "    '''",
            "    Serializes dataset and store it into managed file. Useful for sharing",
            "    simple configuration files.",
            "",
            "    name",
            "        The location of the file to create",
            "",
            "    dataset",
            "        The dataset that will be serialized",
            "",
            "    dataset_pillar",
            "        Operates like ``dataset``, but draws from a value stored in pillar,",
            "        using the pillar path syntax used in :mod:`pillar.get",
            "        <salt.modules.pillar.get>`. This is useful when the pillar value",
            "        contains newlines, as referencing a pillar variable using a jinja/mako",
            "        template can result in YAML formatting issues due to the newlines",
            "        causing indentation mismatches.",
            "",
            "        .. versionadded:: 2015.8.0",
            "",
            "    formatter",
            "        Write the data as this format. Supported output formats:",
            "",
            "        * JSON",
            "        * YAML",
            "        * Python (via pprint.pformat)",
            "",
            "    user",
            "        The user to own the directory, this defaults to the user salt is",
            "        running as on the minion",
            "",
            "    group",
            "        The group ownership set for the directory, this defaults to the group",
            "        salt is running as on the minion",
            "",
            "    mode",
            "        The permissions to set on this file, e.g. ``644``, ``0775``, or",
            "        ``4664``.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "    backup",
            "        Overrides the default backup mode for this specific file.",
            "",
            "    makedirs",
            "        Create parent directories for destination file.",
            "",
            "        .. versionadded:: 2014.1.3",
            "",
            "    show_diff",
            "        DEPRECATED: Please use show_changes.",
            "",
            "        If set to ``False``, the diff will not be shown in the return data if",
            "        changes are made.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made.",
            "",
            "    create",
            "        Default is True, if create is set to False then the file will only be",
            "        managed if the file already exists on the system.",
            "",
            "    merge_if_exists",
            "        Default is False, if merge_if_exists is True then the existing file will",
            "        be parsed and the dataset passed in will be merged with the existing",
            "        content",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    For example, this state:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/dummy/package.json:",
            "          file.serialize:",
            "            - dataset:",
            "                name: naive",
            "                description: A package using naive versioning",
            "                author: A confused individual <iam@confused.com>",
            "                dependencies:",
            "                    express: >= 1.2.0",
            "                    optimist: >= 0.1.0",
            "                engine: node 0.4.1",
            "            - formatter: json",
            "",
            "    will manage the file ``/etc/dummy/package.json``:",
            "",
            "    .. code-block:: json",
            "",
            "        {",
            "          \"author\": \"A confused individual <iam@confused.com>\",",
            "          \"dependencies\": {",
            "            \"express\": \">= 1.2.0\",",
            "            \"optimist\": \">= 0.1.0\"",
            "          },",
            "          \"description\": \"A package using naive versioning\",",
            "          \"engine\": \"node 0.4.1\",",
            "          \"name\": \"naive\"",
            "        }",
            "    '''",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    default_serializer_opts = {'yaml.serialize': {'default_flow_style': False},",
            "                              'json.serialize': {'indent': 2,",
            "                                       'separators': (',', ': '),",
            "                                       'sort_keys': True}",
            "                              }",
            "    ret = {'changes': {},",
            "           'comment': '',",
            "           'name': name,",
            "           'result': True}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.serialize')",
            "",
            "    if not create:",
            "        if not os.path.isfile(name):",
            "            # Don't create a file that is not already present",
            "            ret['comment'] = ('File {0} is not present and is not set for '",
            "                              'creation').format(name)",
            "            return ret",
            "",
            "    formatter = kwargs.pop('formatter', 'yaml').lower()",
            "",
            "    if len([x for x in (dataset, dataset_pillar) if x]) > 1:",
            "        return _error(",
            "            ret, 'Only one of \\'dataset\\' and \\'dataset_pillar\\' is permitted')",
            "",
            "    if dataset_pillar:",
            "        dataset = __salt__['pillar.get'](dataset_pillar)",
            "",
            "    if dataset is None:",
            "        return _error(",
            "            ret, 'Neither \\'dataset\\' nor \\'dataset_pillar\\' was defined')",
            "",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "",
            "    serializer_name = '{0}.serialize'.format(formatter)",
            "    deserializer_name = '{0}.deserialize'.format(formatter)",
            "",
            "    if serializer_name not in __serializers__:",
            "        return {'changes': {},",
            "                'comment': '{0} format is not supported'.format(",
            "                    formatter.capitalize()),",
            "                'name': name,",
            "                'result': False",
            "                }",
            "",
            "    if merge_if_exists:",
            "        if os.path.isfile(name):",
            "            if '{0}.deserialize'.format(formatter) not in __serializers__:",
            "                return {'changes': {},",
            "                        'comment': ('{0} format is not supported for merging'",
            "                                    .format(formatter.capitalize())),",
            "                        'name': name,",
            "                        'result': False}",
            "",
            "            with salt.utils.fopen(name, 'r') as fhr:",
            "                existing_data = __serializers__[deserializer_name](fhr)",
            "",
            "            if existing_data is not None:",
            "                merged_data = salt.utils.dictupdate.merge_recurse(existing_data, dataset)",
            "                if existing_data == merged_data:",
            "                    ret['result'] = True",
            "                    ret['comment'] = 'The file {0} is in the correct state'.format(name)",
            "                    return ret",
            "                dataset = merged_data",
            "    contents = __serializers__[serializer_name](dataset, **default_serializer_opts.get(serializer_name, {}))",
            "",
            "    contents += '\\n'",
            "",
            "    # Make sure that any leading zeros stripped by YAML loader are added back",
            "    mode = salt.utils.normalize_mode(mode)",
            "",
            "    if show_diff is not None:",
            "        show_changes = show_diff",
            "        msg = (",
            "            'The \\'show_diff\\' argument to the file.serialized state has been '",
            "            'deprecated, please use \\'show_changes\\' instead.'",
            "        )",
            "        salt.utils.warn_until('Oxygen', msg)",
            "",
            "    if __opts__['test']:",
            "        ret['changes'] = __salt__['file.check_managed_changes'](",
            "            name=name,",
            "            source=None,",
            "            source_hash={},",
            "            source_hash_name=None,",
            "            user=user,",
            "            group=group,",
            "            mode=mode,",
            "            template=None,",
            "            context=None,",
            "            defaults=None,",
            "            saltenv=__env__,",
            "            contents=contents,",
            "            skip_verify=False,",
            "            **kwargs",
            "        )",
            "",
            "        if ret['changes']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Dataset will be serialized and stored into {0}'.format(",
            "                name)",
            "",
            "            if not show_changes:",
            "                ret['changes']['diff'] = '<show_changes=False>'",
            "        else:",
            "            ret['result'] = True",
            "            ret['comment'] = 'The file {0} is in the correct state'.format(name)",
            "        return ret",
            "",
            "    return __salt__['file.manage_file'](name=name,",
            "                                        sfn='',",
            "                                        ret=ret,",
            "                                        source=None,",
            "                                        source_sum={},",
            "                                        user=user,",
            "                                        group=group,",
            "                                        mode=mode,",
            "                                        saltenv=__env__,",
            "                                        backup=backup,",
            "                                        makedirs=makedirs,",
            "                                        template=None,",
            "                                        show_changes=show_changes,",
            "                                        contents=contents)",
            "",
            "",
            "def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode='0600'):",
            "    '''",
            "    Create a special file similar to the 'nix mknod command. The supported",
            "    device types are ``p`` (fifo pipe), ``c`` (character device), and ``b``",
            "    (block device). Provide the major and minor numbers when specifying a",
            "    character device or block device. A fifo pipe does not require this",
            "    information. The command will create the necessary dirs if needed. If a",
            "    file of the same name not of the same type/major/minor exists, it will not",
            "    be overwritten or unlinked (deleted). This is logically in place as a",
            "    safety measure because you can really shoot yourself in the foot here and",
            "    it is the behavior of 'nix ``mknod``. It is also important to note that not",
            "    just anyone can create special devices. Usually this is only done as root.",
            "    If the state is executed as none other than root on a minion, you may",
            "    receive a permission error.",
            "",
            "    name",
            "        name of the file",
            "",
            "    ntype",
            "        node type 'p' (fifo pipe), 'c' (character device), or 'b'",
            "        (block device)",
            "",
            "    major",
            "        major number of the device",
            "        does not apply to a fifo pipe",
            "",
            "    minor",
            "        minor number of the device",
            "        does not apply to a fifo pipe",
            "",
            "    user",
            "        owning user of the device/pipe",
            "",
            "    group",
            "        owning group of the device/pipe",
            "",
            "    mode",
            "        permissions on the device/pipe",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /dev/chr:",
            "          file.mknod:",
            "            - ntype: c",
            "            - major: 180",
            "            - minor: 31",
            "            - user: root",
            "            - group: root",
            "            - mode: 660",
            "",
            "        /dev/blk:",
            "          file.mknod:",
            "            - ntype: b",
            "            - major: 8",
            "            - minor: 999",
            "            - user: root",
            "            - group: root",
            "            - mode: 660",
            "",
            "        /dev/fifo:",
            "          file.mknod:",
            "            - ntype: p",
            "            - user: root",
            "            - group: root",
            "            - mode: 660",
            "",
            "    .. versionadded:: 0.17.0",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.mknod')",
            "",
            "    if ntype == 'c':",
            "        # Check for file existence",
            "        if __salt__['file.file_exists'](name):",
            "            ret['comment'] = (",
            "                'File exists and is not a character device {0}. Cowardly '",
            "                'refusing to continue'.format(name)",
            "            )",
            "",
            "        # Check if it is a character device",
            "        elif not __salt__['file.is_chrdev'](name):",
            "            if __opts__['test']:",
            "                ret['comment'] = (",
            "                    'Character device {0} is set to be created'",
            "                ).format(name)",
            "                ret['result'] = None",
            "            else:",
            "                ret = __salt__['file.mknod'](name,",
            "                                             ntype,",
            "                                             major,",
            "                                             minor,",
            "                                             user,",
            "                                             group,",
            "                                             mode)",
            "",
            "        # Check the major/minor",
            "        else:",
            "            devmaj, devmin = __salt__['file.get_devmm'](name)",
            "            if (major, minor) != (devmaj, devmin):",
            "                ret['comment'] = (",
            "                    'Character device {0} exists and has a different '",
            "                    'major/minor {1}/{2}. Cowardly refusing to continue'",
            "                        .format(name, devmaj, devmin)",
            "                )",
            "            # Check the perms",
            "            else:",
            "                ret = __salt__['file.check_perms'](name,",
            "                                                   None,",
            "                                                   user,",
            "                                                   group,",
            "                                                   mode)[0]",
            "                if not ret['changes']:",
            "                    ret['comment'] = (",
            "                        'Character device {0} is in the correct state'.format(",
            "                            name",
            "                        )",
            "                    )",
            "",
            "    elif ntype == 'b':",
            "        # Check for file existence",
            "        if __salt__['file.file_exists'](name):",
            "            ret['comment'] = (",
            "                'File exists and is not a block device {0}. Cowardly '",
            "                'refusing to continue'.format(name)",
            "            )",
            "",
            "        # Check if it is a block device",
            "        elif not __salt__['file.is_blkdev'](name):",
            "            if __opts__['test']:",
            "                ret['comment'] = (",
            "                    'Block device {0} is set to be created'",
            "                ).format(name)",
            "                ret['result'] = None",
            "            else:",
            "                ret = __salt__['file.mknod'](name,",
            "                                             ntype,",
            "                                             major,",
            "                                             minor,",
            "                                             user,",
            "                                             group,",
            "                                             mode)",
            "",
            "        # Check the major/minor",
            "        else:",
            "            devmaj, devmin = __salt__['file.get_devmm'](name)",
            "            if (major, minor) != (devmaj, devmin):",
            "                ret['comment'] = (",
            "                    'Block device {0} exists and has a different major/minor '",
            "                    '{1}/{2}. Cowardly refusing to continue'.format(",
            "                        name, devmaj, devmin",
            "                    )",
            "                )",
            "            # Check the perms",
            "            else:",
            "                ret = __salt__['file.check_perms'](name,",
            "                                                   None,",
            "                                                   user,",
            "                                                   group,",
            "                                                   mode)[0]",
            "                if not ret['changes']:",
            "                    ret['comment'] = (",
            "                        'Block device {0} is in the correct state'.format(name)",
            "                    )",
            "",
            "    elif ntype == 'p':",
            "        # Check for file existence",
            "        if __salt__['file.file_exists'](name):",
            "            ret['comment'] = (",
            "                'File exists and is not a fifo pipe {0}. Cowardly refusing '",
            "                'to continue'.format(name)",
            "            )",
            "",
            "        # Check if it is a fifo",
            "        elif not __salt__['file.is_fifo'](name):",
            "            if __opts__['test']:",
            "                ret['comment'] = 'Fifo pipe {0} is set to be created'.format(",
            "                    name",
            "                )",
            "                ret['result'] = None",
            "            else:",
            "                ret = __salt__['file.mknod'](name,",
            "                                             ntype,",
            "                                             major,",
            "                                             minor,",
            "                                             user,",
            "                                             group,",
            "                                             mode)",
            "",
            "        # Check the perms",
            "        else:",
            "            ret = __salt__['file.check_perms'](name,",
            "                                               None,",
            "                                               user,",
            "                                               group,",
            "                                               mode)[0]",
            "            if not ret['changes']:",
            "                ret['comment'] = (",
            "                    'Fifo pipe {0} is in the correct state'.format(name)",
            "                )",
            "",
            "    else:",
            "        ret['comment'] = (",
            "            'Node type unavailable: \\'{0}\\'. Available node types are '",
            "            'character (\\'c\\'), block (\\'b\\'), and pipe (\\'p\\')'.format(ntype)",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def mod_run_check_cmd(cmd, filename, **check_cmd_opts):",
            "    '''",
            "    Execute the check_cmd logic.",
            "",
            "    Return a result dict if ``check_cmd`` succeeds (check_cmd == 0)",
            "    otherwise return True",
            "    '''",
            "",
            "    log.debug('running our check_cmd')",
            "    _cmd = '{0} {1}'.format(cmd, filename)",
            "    cret = __salt__['cmd.run_all'](_cmd, **check_cmd_opts)",
            "    if cret['retcode'] != 0:",
            "        ret = {'comment': 'check_cmd execution failed',",
            "               'skip_watch': True,",
            "               'result': False}",
            "",
            "        if cret.get('stdout'):",
            "            ret['comment'] += '\\n' + cret['stdout']",
            "        if cret.get('stderr'):",
            "            ret['comment'] += '\\n' + cret['stderr']",
            "",
            "        return ret",
            "",
            "    # No reason to stop, return True",
            "    return True",
            "",
            "",
            "def decode(name,",
            "        encoded_data=None,",
            "        contents_pillar=None,",
            "        encoding_type='base64',",
            "        checksum='md5'):",
            "    '''",
            "    Decode an encoded file and write it to disk",
            "",
            "    .. versionadded:: 2016.3.0",
            "",
            "    name",
            "        Path of the file to be written.",
            "    encoded_data",
            "        The encoded file. Either this option or ``contents_pillar`` must be",
            "        specified.",
            "    contents_pillar",
            "        A Pillar path to the encoded file. Uses the same path syntax as",
            "        :py:func:`pillar.get <salt.modules.pillar.get>`. The",
            "        :py:func:`hashutil.base64_encodefile",
            "        <salt.modules.hashutil.base64_encodefile>` function can load encoded",
            "        content into Pillar. Either this option or ``encoded_data`` must be",
            "        specified.",
            "    encoding_type : ``base64``",
            "        The type of encoding.",
            "    checksum : ``md5``",
            "        The hashing algorithm to use to generate checksums. Wraps the",
            "        :py:func:`hashutil.digest <salt.modules.hashutil.digest>` execution",
            "        function.",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        write_base64_encoded_string_to_a_file:",
            "          file.decode:",
            "            - name: /tmp/new_file",
            "            - encoding_type: base64",
            "            - contents_pillar: mypillar:thefile",
            "",
            "        # or",
            "",
            "        write_base64_encoded_string_to_a_file:",
            "          file.decode:",
            "            - name: /tmp/new_file",
            "            - encoding_type: base64",
            "            - encoded_data: |",
            "                Z2V0IHNhbHRlZAo=",
            "",
            "    Be careful with multi-line strings that the YAML indentation is correct.",
            "    E.g.,",
            "",
            "    .. code-block:: yaml",
            "",
            "        write_base64_encoded_string_to_a_file:",
            "          file.decode:",
            "            - name: /tmp/new_file",
            "            - encoding_type: base64",
            "            - encoded_data: |",
            "                {{ salt.pillar.get('path:to:data') | indent(8) }}",
            "    '''",
            "    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}",
            "",
            "    if not (encoded_data or contents_pillar):",
            "        raise CommandExecutionError(\"Specify either the 'encoded_data' or \"",
            "            \"'contents_pillar' argument.\")",
            "    elif encoded_data and contents_pillar:",
            "        raise CommandExecutionError(\"Specify only one 'encoded_data' or \"",
            "            \"'contents_pillar' argument.\")",
            "    elif encoded_data:",
            "        content = encoded_data",
            "    elif contents_pillar:",
            "        content = __salt__['pillar.get'](contents_pillar, False)",
            "        if content is False:",
            "            raise CommandExecutionError('Pillar data not found.')",
            "    else:",
            "        raise CommandExecutionError('No contents given.')",
            "",
            "    dest_exists = __salt__['file.file_exists'](name)",
            "    if dest_exists:",
            "        instr = __salt__['hashutil.base64_decodestring'](content)",
            "        insum = __salt__['hashutil.digest'](instr, checksum)",
            "        del instr  # no need to keep in-memory after we have the hash",
            "        outsum = __salt__['hashutil.digest_file'](name, checksum)",
            "",
            "        if insum != outsum:",
            "            ret['changes'] = {",
            "                'old': outsum,",
            "                'new': insum,",
            "            }",
            "",
            "        if not ret['changes']:",
            "            ret['comment'] = 'File is in the correct state.'",
            "            ret['result'] = True",
            "",
            "            return ret",
            "",
            "    if __opts__['test'] is True:",
            "        ret['comment'] = 'File is set to be updated.'",
            "        ret['result'] = None",
            "        return ret",
            "",
            "    ret['result'] = __salt__['hashutil.base64_decodefile'](content, name)",
            "    ret['comment'] = 'File was updated.'",
            "",
            "    if not ret['changes']:",
            "        ret['changes'] = {",
            "            'old': None,",
            "            'new': __salt__['hashutil.digest_file'](name, checksum),",
            "        }",
            "",
            "    return ret"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Operations on regular files, special files, directories, and symlinks",
            "=====================================================================",
            "",
            "Salt States can aggressively manipulate files on a system. There are a number",
            "of ways in which files can be managed.",
            "",
            "Regular files can be enforced with the :mod:`file.managed",
            "<salt.states.file.managed>` state. This state downloads files from the salt",
            "master and places them on the target system. Managed files can be rendered as a",
            "jinja, mako, or wempy template, adding a dynamic component to file management.",
            "An example of :mod:`file.managed <salt.states.file.managed>` which makes use of",
            "the jinja templating system would look like this:",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/http/conf/http.conf:",
            "      file.managed:",
            "        - source: salt://apache/http.conf",
            "        - user: root",
            "        - group: root",
            "        - mode: 644",
            "        - template: jinja",
            "        - defaults:",
            "            custom_var: \"default value\"",
            "            other_var: 123",
            "    {% if grains['os'] == 'Ubuntu' %}",
            "        - context:",
            "            custom_var: \"override\"",
            "    {% endif %}",
            "",
            "It is also possible to use the :mod:`py renderer <salt.renderers.py>` as a",
            "templating option. The template would be a Python script which would need to",
            "contain a function called ``run()``, which returns a string. All arguments",
            "to the state will be made available to the Python script as globals. The",
            "returned string will be the contents of the managed file. For example:",
            "",
            ".. code-block:: python",
            "",
            "    def run():",
            "        lines = ['foo', 'bar', 'baz']",
            "        lines.extend([source, name, user, context])  # Arguments as globals",
            "        return '\\\\n\\\\n'.join(lines)",
            "",
            ".. note::",
            "",
            "    The ``defaults`` and ``context`` arguments require extra indentation (four",
            "    spaces instead of the normal two) in order to create a nested dictionary.",
            "    :ref:`More information <nested-dict-indentation>`.",
            "",
            "If using a template, any user-defined template variables in the file defined in",
            "``source`` must be passed in using the ``defaults`` and/or ``context``",
            "arguments. The general best practice is to place default values in",
            "``defaults``, with conditional overrides going into ``context``, as seen above.",
            "",
            "The template will receive a variable ``custom_var``, which would be accessed in",
            "the template using ``{{ custom_var }}``. If the operating system is Ubuntu, the",
            "value of the variable ``custom_var`` would be *override*, otherwise it is the",
            "default *default value*",
            "",
            "The ``source`` parameter can be specified as a list. If this is done, then the",
            "first file to be matched will be the one that is used. This allows you to have",
            "a default file on which to fall back if the desired file does not exist on the",
            "salt fileserver. Here's an example:",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/foo.conf:",
            "      file.managed:",
            "        - source:",
            "          - salt://foo.conf.{{ grains['fqdn'] }}",
            "          - salt://foo.conf.fallback",
            "        - user: foo",
            "        - group: users",
            "        - mode: 644",
            "        - backup: minion",
            "",
            ".. note::",
            "",
            "    Salt supports backing up managed files via the backup option. For more",
            "    details on this functionality please review the",
            "    :ref:`backup_mode documentation <file-state-backups>`.",
            "",
            "The ``source`` parameter can also specify a file in another Salt environment.",
            "In this example ``foo.conf`` in the ``dev`` environment will be used instead.",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/foo.conf:",
            "      file.managed:",
            "        - source:",
            "          - salt://foo.conf?saltenv=dev",
            "        - user: foo",
            "        - group: users",
            "        - mode: '0644'",
            "",
            ".. warning::",
            "",
            "    When using a mode that includes a leading zero you must wrap the",
            "    value in single quotes. If the value is not wrapped in quotes it",
            "    will be read by YAML as an integer and evaluated as an octal.",
            "",
            "The ``names`` parameter, which is part of the state compiler, can be used to",
            "expand the contents of a single state declaration into multiple, single state",
            "declarations. Each item in the ``names`` list receives its own individual state",
            "``name`` and is converted into its own low-data structure. This is a convenient",
            "way to manage several files with similar attributes.",
            "",
            "There is more documentation about this feature in the",
            ":ref:`Names declaration<names-declaration>` section of the",
            " :ref:`Highstate docs<states-highstate>`.",
            "",
            "Special files can be managed via the ``mknod`` function. This function will",
            "create and enforce the permissions on a special file. The function supports the",
            "creation of character devices, block devices, and FIFO pipes. The function will",
            "create the directory structure up to the special file if it is needed on the",
            "minion. The function will not overwrite or operate on (change major/minor",
            "numbers) existing special files with the exception of user, group, and",
            "permissions. In most cases the creation of some special files require root",
            "permissions on the minion. This would require that the minion to be run as the",
            "root user. Here is an example of a character device:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/named/chroot/dev/random:",
            "      file.mknod:",
            "        - ntype: c",
            "        - major: 1",
            "        - minor: 8",
            "        - user: named",
            "        - group: named",
            "        - mode: 660",
            "",
            "Here is an example of a block device:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/named/chroot/dev/loop0:",
            "      file.mknod:",
            "        - ntype: b",
            "        - major: 7",
            "        - minor: 0",
            "        - user: named",
            "        - group: named",
            "        - mode: 660",
            "",
            "Here is an example of a fifo pipe:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/named/chroot/var/log/logfifo:",
            "      file.mknod:",
            "        - ntype: p",
            "        - user: named",
            "        - group: named",
            "        - mode: 660",
            "",
            "Directories can be managed via the ``directory`` function. This function can",
            "create and enforce the permissions on a directory. A directory statement will",
            "look like this:",
            "",
            ".. code-block:: yaml",
            "",
            "    /srv/stuff/substuf:",
            "      file.directory:",
            "        - user: fred",
            "        - group: users",
            "        - mode: 755",
            "        - makedirs: True",
            "",
            "If you need to enforce user and/or group ownership or permissions recursively",
            "on the directory's contents, you can do so by adding a ``recurse`` directive:",
            "",
            ".. code-block:: yaml",
            "",
            "    /srv/stuff/substuf:",
            "      file.directory:",
            "        - user: fred",
            "        - group: users",
            "        - mode: 755",
            "        - makedirs: True",
            "        - recurse:",
            "          - user",
            "          - group",
            "          - mode",
            "",
            "As a default, ``mode`` will resolve to ``dir_mode`` and ``file_mode``, to",
            "specify both directory and file permissions, use this form:",
            "",
            ".. code-block:: yaml",
            "",
            "    /srv/stuff/substuf:",
            "      file.directory:",
            "        - user: fred",
            "        - group: users",
            "        - file_mode: 744",
            "        - dir_mode: 755",
            "        - makedirs: True",
            "        - recurse:",
            "          - user",
            "          - group",
            "          - mode",
            "",
            "Symlinks can be easily created; the symlink function is very simple and only",
            "takes a few arguments:",
            "",
            ".. code-block:: yaml",
            "",
            "    /etc/grub.conf:",
            "      file.symlink:",
            "        - target: /boot/grub/grub.conf",
            "",
            "Recursive directory management can also be set via the ``recurse``",
            "function. Recursive directory management allows for a directory on the salt",
            "master to be recursively copied down to the minion. This is a great tool for",
            "deploying large code and configuration systems. A state using ``recurse``",
            "would look something like this:",
            "",
            ".. code-block:: yaml",
            "",
            "    /opt/code/flask:",
            "      file.recurse:",
            "        - source: salt://code/flask",
            "        - include_empty: True",
            "",
            "A more complex ``recurse`` example:",
            "",
            ".. code-block:: yaml",
            "",
            "    {% set site_user = 'testuser' %}",
            "    {% set site_name = 'test_site' %}",
            "    {% set project_name = 'test_proj' %}",
            "    {% set sites_dir = 'test_dir' %}",
            "",
            "    django-project:",
            "      file.recurse:",
            "        - name: {{ sites_dir }}/{{ site_name }}/{{ project_name }}",
            "        - user: {{ site_user }}",
            "        - dir_mode: 2775",
            "        - file_mode: '0644'",
            "        - template: jinja",
            "        - source: salt://project/templates_dir",
            "        - include_empty: True",
            "",
            "Retention scheduling can be applied to manage contents of backup directories.",
            "For example:",
            "",
            ".. code-block:: yaml",
            "",
            "    /var/backups/example_directory:",
            "      file.retention_schedule:",
            "        - strptime_format: example_name_%Y%m%dT%H%M%S.tar.bz2",
            "        - retain:",
            "            most_recent: 5",
            "            first_of_hour: 4",
            "            first_of_day: 14",
            "            first_of_week: 6",
            "            first_of_month: 6",
            "            first_of_year: all",
            "",
            "'''",
            "",
            "# Import python libs",
            "from __future__ import absolute_import",
            "import difflib",
            "import itertools",
            "import logging",
            "import os",
            "import shutil",
            "import sys",
            "import traceback",
            "from collections import Iterable, Mapping, defaultdict",
            "from datetime import datetime   # python3 problem in the making?",
            "",
            "# Import salt libs",
            "import salt.loader",
            "import salt.payload",
            "import salt.utils",
            "import salt.utils.dictupdate",
            "import salt.utils.templates",
            "import salt.utils.url",
            "from salt.utils.locales import sdecode",
            "from salt.exceptions import CommandExecutionError, SaltInvocationError",
            "",
            "# Import 3rd-party libs",
            "import salt.ext.six as six",
            "from salt.ext.six.moves import zip_longest",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "COMMENT_REGEX = r'^([[:space:]]*){0}[[:space:]]?'",
            "__NOT_FOUND = object()",
            "",
            "",
            "def _get_accumulator_filepath():",
            "    '''",
            "    Return accumulator data path.",
            "    '''",
            "    return os.path.join(salt.utils.get_accumulator_dir(__opts__['cachedir']),",
            "                        __instance_id__)",
            "",
            "",
            "def _load_accumulators():",
            "    def _deserialize(path):",
            "        serial = salt.payload.Serial(__opts__)",
            "        ret = {'accumulators': {}, 'accumulators_deps': {}}",
            "        try:",
            "            with salt.utils.fopen(path, 'rb') as f:",
            "                loaded = serial.load(f)",
            "                return loaded if loaded else ret",
            "        except (IOError, NameError):",
            "            # NameError is a msgpack error from salt-ssh",
            "            return ret",
            "",
            "    loaded = _deserialize(_get_accumulator_filepath())",
            "",
            "    return loaded['accumulators'], loaded['accumulators_deps']",
            "",
            "",
            "def _persist_accummulators(accumulators, accumulators_deps):",
            "    accumm_data = {'accumulators': accumulators,",
            "                   'accumulators_deps': accumulators_deps}",
            "",
            "    serial = salt.payload.Serial(__opts__)",
            "    try:",
            "        with salt.utils.fopen(_get_accumulator_filepath(), 'w+b') as f:",
            "            serial.dump(accumm_data, f)",
            "    except NameError:",
            "        # msgpack error from salt-ssh",
            "        pass",
            "",
            "",
            "def _check_user(user, group):",
            "    '''",
            "    Checks if the named user and group are present on the minion",
            "    '''",
            "    err = ''",
            "    if user:",
            "        uid = __salt__['file.user_to_uid'](user)",
            "        if uid == '':",
            "            err += 'User {0} is not available '.format(user)",
            "    if group:",
            "        gid = __salt__['file.group_to_gid'](group)",
            "        if gid == '':",
            "            err += 'Group {0} is not available'.format(group)",
            "    return err",
            "",
            "",
            "def _gen_keep_files(name, require, walk_d=None):",
            "    '''",
            "    Generate the list of files that need to be kept when a dir based function",
            "    like directory or recurse has a clean.",
            "    '''",
            "    def _is_child(path, directory):",
            "        '''",
            "        Check whether ``path`` is child of ``directory``",
            "        '''",
            "        path = os.path.abspath(path)",
            "        directory = os.path.abspath(directory)",
            "",
            "        relative = os.path.relpath(path, directory)",
            "",
            "        return not relative.startswith(os.pardir)",
            "",
            "    def _add_current_path(path):",
            "        _ret = set()",
            "        if os.path.isdir(path):",
            "            dirs, files = walk_d.get(path, ((), ()))",
            "            _ret.add(path)",
            "            for _name in files:",
            "                _ret.add(os.path.join(path, _name))",
            "            for _name in dirs:",
            "                _ret.add(os.path.join(path, _name))",
            "        return _ret",
            "",
            "    def _process_by_walk_d(name, ret):",
            "        if os.path.isdir(name):",
            "            walk_ret.update(_add_current_path(name))",
            "            dirs, _ = walk_d.get(name, ((), ()))",
            "            for _d in dirs:",
            "                p = os.path.join(name, _d)",
            "                walk_ret.update(_add_current_path(p))",
            "                _process_by_walk_d(p, ret)",
            "",
            "    def _process(name):",
            "        ret = set()",
            "        if os.path.isdir(name):",
            "            for root, dirs, files in os.walk(name):",
            "                ret.add(name)",
            "                for name in files:",
            "                    ret.add(os.path.join(root, name))",
            "                for name in dirs:",
            "                    ret.add(os.path.join(root, name))",
            "        return ret",
            "",
            "    keep = set()",
            "    if isinstance(require, list):",
            "        required_files = [comp for comp in require if 'file' in comp]",
            "        for comp in required_files:",
            "            for low in __lowstate__:",
            "                # A requirement should match either the ID and the name of",
            "                # another state.",
            "                if low['name'] == comp['file'] or low['__id__'] == comp['file']:",
            "                    fn = low['name']",
            "                    if os.path.isdir(fn):",
            "                        if _is_child(fn, name):",
            "                            if walk_d:",
            "                                walk_ret = set()",
            "                                _process_by_walk_d(fn, walk_ret)",
            "                                keep.update(walk_ret)",
            "                            else:",
            "                                keep.update(_process(fn))",
            "                    else:",
            "                        keep.add(fn)",
            "    return list(keep)",
            "",
            "",
            "def _check_file(name):",
            "    ret = True",
            "    msg = ''",
            "",
            "    if not os.path.isabs(name):",
            "        ret = False",
            "        msg = 'Specified file {0} is not an absolute path'.format(name)",
            "    elif not os.path.exists(name):",
            "        ret = False",
            "        msg = '{0}: file not found'.format(name)",
            "",
            "    return ret, msg",
            "",
            "",
            "def _clean_dir(root, keep, exclude_pat):",
            "    '''",
            "    Clean out all of the files and directories in a directory (root) while",
            "    preserving the files in a list (keep) and part of exclude_pat",
            "    '''",
            "    removed = set()",
            "    real_keep = set()",
            "    real_keep.add(root)",
            "    if isinstance(keep, list):",
            "        for fn_ in keep:",
            "            if not os.path.isabs(fn_):",
            "                continue",
            "            real_keep.add(fn_)",
            "            while True:",
            "                fn_ = os.path.dirname(fn_)",
            "                real_keep.add(fn_)",
            "                if fn_ in ['/', ''.join([os.path.splitdrive(fn_)[0], '\\\\\\\\'])]:",
            "                    break",
            "",
            "    def _delete_not_kept(nfn):",
            "        if nfn not in real_keep:",
            "            # -- check if this is a part of exclude_pat(only). No need to",
            "            # check include_pat",
            "            if not salt.utils.check_include_exclude(",
            "                    os.path.relpath(nfn, root), None, exclude_pat):",
            "                return",
            "            removed.add(nfn)",
            "            if not __opts__['test']:",
            "                try:",
            "                    os.remove(nfn)",
            "                except OSError:",
            "                    __salt__['file.remove'](nfn)",
            "",
            "    for roots, dirs, files in os.walk(root):",
            "        for name in itertools.chain(dirs, files):",
            "            _delete_not_kept(os.path.join(roots, name))",
            "    return list(removed)",
            "",
            "",
            "def _error(ret, err_msg):",
            "    ret['result'] = False",
            "    ret['comment'] = err_msg",
            "    return ret",
            "",
            "",
            "def _check_directory(name,",
            "                     user,",
            "                     group,",
            "                     recurse,",
            "                     mode,",
            "                     clean,",
            "                     require,",
            "                     exclude_pat,",
            "                     max_depth=None):",
            "    '''",
            "    Check what changes need to be made on a directory",
            "    '''",
            "    changes = {}",
            "    if recurse or clean:",
            "        assert max_depth is None or not clean",
            "        # walk path only once and store the result",
            "        walk_l = list(_depth_limited_walk(name, max_depth))",
            "        # root: (dirs, files) structure, compatible for python2.6",
            "        walk_d = {}",
            "        for i in walk_l:",
            "            walk_d[i[0]] = (i[1], i[2])",
            "",
            "    if recurse:",
            "        try:",
            "            recurse_set = _get_recurse_set(recurse)",
            "        except (TypeError, ValueError) as exc:",
            "            return False, '{0}'.format(exc), changes",
            "        if 'user' not in recurse_set:",
            "            user = None",
            "        if 'group' not in recurse_set:",
            "            group = None",
            "        if 'mode' not in recurse_set:",
            "            mode = None",
            "        check_files = 'ignore_files' not in recurse_set",
            "        check_dirs = 'ignore_dirs' not in recurse_set",
            "        for root, dirs, files in walk_l:",
            "            if check_files:",
            "                for fname in files:",
            "                    fchange = {}",
            "                    path = os.path.join(root, fname)",
            "                    stats = __salt__['file.stats'](",
            "                        path, None, follow_symlinks=False",
            "                    )",
            "                    if user is not None and user != stats.get('user'):",
            "                        fchange['user'] = user",
            "                    if group is not None and group != stats.get('group'):",
            "                        fchange['group'] = group",
            "                    if fchange:",
            "                        changes[path] = fchange",
            "            if check_dirs:",
            "                for name_ in dirs:",
            "                    path = os.path.join(root, name_)",
            "                    fchange = _check_dir_meta(path, user, group, mode)",
            "                    if fchange:",
            "                        changes[path] = fchange",
            "    # Recurse skips root (we always do dirs, not root), so always check root:",
            "    fchange = _check_dir_meta(name, user, group, mode)",
            "    if fchange:",
            "        changes[name] = fchange",
            "    if clean:",
            "        keep = _gen_keep_files(name, require, walk_d)",
            "",
            "        def _check_changes(fname):",
            "            path = os.path.join(root, fname)",
            "            if path in keep:",
            "                return {}",
            "            else:",
            "                if not salt.utils.check_include_exclude(",
            "                        os.path.relpath(path, name), None, exclude_pat):",
            "                    return {}",
            "                else:",
            "                    return {path: {'removed': 'Removed due to clean'}}",
            "",
            "        for root, dirs, files in walk_l:",
            "            for fname in files:",
            "                changes.update(_check_changes(fname))",
            "            for name_ in dirs:",
            "                changes.update(_check_changes(name_))",
            "",
            "    if not os.path.isdir(name):",
            "        changes[name] = {'directory': 'new'}",
            "    if changes:",
            "        comments = ['The following files will be changed:\\n']",
            "        for fn_ in changes:",
            "            for key, val in six.iteritems(changes[fn_]):",
            "                comments.append('{0}: {1} - {2}\\n'.format(fn_, key, val))",
            "        return None, ''.join(comments), changes",
            "    return True, 'The directory {0} is in the correct state'.format(name), changes",
            "",
            "",
            "def _check_dir_meta(name,",
            "                    user,",
            "                    group,",
            "                    mode):",
            "    '''",
            "    Check the changes in directory metadata",
            "    '''",
            "    stats = __salt__['file.stats'](name, follow_symlinks=False)",
            "    changes = {}",
            "    if not stats:",
            "        changes['directory'] = 'new'",
            "        return changes",
            "    if (user is not None",
            "            and user != stats['user']",
            "            and user != stats.get('uid')):",
            "        changes['user'] = user",
            "    if (group is not None",
            "            and group != stats['group']",
            "            and group != stats.get('gid')):",
            "        changes['group'] = group",
            "    # Normalize the dir mode",
            "    smode = salt.utils.normalize_mode(stats['mode'])",
            "    mode = salt.utils.normalize_mode(mode)",
            "    if mode is not None and mode != smode:",
            "        changes['mode'] = mode",
            "    return changes",
            "",
            "",
            "def _check_touch(name, atime, mtime):",
            "    '''",
            "    Check to see if a file needs to be updated or created",
            "    '''",
            "    if not os.path.exists(name):",
            "        return None, 'File {0} is set to be created'.format(name)",
            "    stats = __salt__['file.stats'](name, follow_symlinks=False)",
            "    if atime is not None:",
            "        if str(atime) != str(stats['atime']):",
            "            return None, 'Times set to be updated on file {0}'.format(name)",
            "    if mtime is not None:",
            "        if str(mtime) != str(stats['mtime']):",
            "            return None, 'Times set to be updated on file {0}'.format(name)",
            "    return True, 'File {0} exists and has the correct times'.format(name)",
            "",
            "",
            "def _get_symlink_ownership(path):",
            "    return (",
            "        __salt__['file.get_user'](path, follow_symlinks=False),",
            "        __salt__['file.get_group'](path, follow_symlinks=False)",
            "    )",
            "",
            "",
            "def _check_symlink_ownership(path, user, group):",
            "    '''",
            "    Check if the symlink ownership matches the specified user and group",
            "    '''",
            "    cur_user, cur_group = _get_symlink_ownership(path)",
            "    return (cur_user == user) and (cur_group == group)",
            "",
            "",
            "def _set_symlink_ownership(path, user, group):",
            "    '''",
            "    Set the ownership of a symlink and return a boolean indicating",
            "    success/failure",
            "    '''",
            "    try:",
            "        __salt__['file.lchown'](path, user, group)",
            "    except OSError:",
            "        pass",
            "    return _check_symlink_ownership(path, user, group)",
            "",
            "",
            "def _symlink_check(name, target, force, user, group):",
            "    '''",
            "    Check the symlink function",
            "    '''",
            "    pchanges = {}",
            "    if not os.path.exists(name) and not __salt__['file.is_link'](name):",
            "        pchanges['new'] = name",
            "        return None, 'Symlink {0} to {1} is set for creation'.format(",
            "            name, target",
            "        ), pchanges",
            "    if __salt__['file.is_link'](name):",
            "        if __salt__['file.readlink'](name) != target:",
            "            pchanges['change'] = name",
            "            return None, 'Link {0} target is set to be changed to {1}'.format(",
            "                name, target",
            "            ), pchanges",
            "        else:",
            "            result = True",
            "            msg = 'The symlink {0} is present'.format(name)",
            "            if not _check_symlink_ownership(name, user, group):",
            "                result = None",
            "                pchanges['ownership'] = '{0}:{1}'.format(*_get_symlink_ownership(name))",
            "                msg += (",
            "                    ', but the ownership of the symlink would be changed '",
            "                    'from {2}:{3} to {0}:{1}'",
            "                ).format(user, group, *_get_symlink_ownership(name))",
            "            return result, msg, pchanges",
            "    else:",
            "        if force:",
            "            return None, ('The file or directory {0} is set for removal to '",
            "                          'make way for a new symlink targeting {1}'",
            "                          .format(name, target)), pchanges",
            "        return False, ('File or directory exists where the symlink {0} '",
            "                       'should be. Did you mean to use force?'.format(name)), pchanges",
            "",
            "",
            "def _test_owner(kwargs, user=None):",
            "    '''",
            "    Convert owner to user, since other config management tools use owner,",
            "    no need to punish people coming from other systems.",
            "    PLEASE DO NOT DOCUMENT THIS! WE USE USER, NOT OWNER!!!!",
            "    '''",
            "    if user:",
            "        return user",
            "    if 'owner' in kwargs:",
            "        log.warning(",
            "            'Use of argument owner found, \"owner\" is invalid, please '",
            "            'use \"user\"'",
            "        )",
            "        return kwargs['owner']",
            "",
            "    return user",
            "",
            "",
            "def _unify_sources_and_hashes(source=None, source_hash=None,",
            "                              sources=None, source_hashes=None):",
            "    '''",
            "    Silly little function to give us a standard tuple list for sources and",
            "    source_hashes",
            "    '''",
            "    if sources is None:",
            "        sources = []",
            "",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    if source and sources:",
            "        return (False,",
            "                \"source and sources are mutually exclusive\", [])",
            "",
            "    if source_hash and source_hashes:",
            "        return (False,",
            "                \"source_hash and source_hashes are mutually exclusive\", [])",
            "",
            "    if source:",
            "        return (True, '', [(source, source_hash)])",
            "",
            "    # Make a nice neat list of tuples exactly len(sources) long..",
            "    return True, '', list(zip_longest(sources, source_hashes[:len(sources)]))",
            "",
            "",
            "def _get_template_texts(source_list=None,",
            "                        template='jinja',",
            "                        defaults=None,",
            "                        context=None,",
            "                        **kwargs):",
            "    '''",
            "    Iterate a list of sources and process them as templates.",
            "    Returns a list of 'chunks' containing the rendered templates.",
            "    '''",
            "",
            "    ret = {'name': '_get_template_texts',",
            "           'changes': {},",
            "           'result': True,",
            "           'comment': '',",
            "           'data': []}",
            "",
            "    if source_list is None:",
            "        return _error(ret,",
            "                      '_get_template_texts called with empty source_list')",
            "",
            "    txtl = []",
            "",
            "    for (source, source_hash) in source_list:",
            "",
            "        tmpctx = defaults if defaults else {}",
            "        if context:",
            "            tmpctx.update(context)",
            "        rndrd_templ_fn = __salt__['cp.get_template'](",
            "            source,",
            "            '',",
            "            template=template,",
            "            saltenv=__env__,",
            "            context=tmpctx,",
            "            **kwargs",
            "        )",
            "        msg = 'cp.get_template returned {0} (Called with: {1})'",
            "        log.debug(msg.format(rndrd_templ_fn, source))",
            "        if rndrd_templ_fn:",
            "            tmplines = None",
            "            with salt.utils.fopen(rndrd_templ_fn, 'rb') as fp_:",
            "                tmplines = fp_.readlines()",
            "            if not tmplines:",
            "                msg = 'Failed to read rendered template file {0} ({1})'",
            "                log.debug(msg.format(rndrd_templ_fn, source))",
            "                ret['name'] = source",
            "                return _error(ret, msg.format(rndrd_templ_fn, source))",
            "            txtl.append(''.join(tmplines))",
            "        else:",
            "            msg = 'Failed to load template file {0}'.format(source)",
            "            log.debug(msg)",
            "            ret['name'] = source",
            "            return _error(ret, msg)",
            "",
            "    ret['data'] = txtl",
            "    return ret",
            "",
            "",
            "def _validate_str_list(arg):",
            "    '''",
            "    ensure ``arg`` is a list of strings",
            "    '''",
            "    if isinstance(arg, six.string_types):",
            "        ret = [arg]",
            "    elif isinstance(arg, Iterable) and not isinstance(arg, Mapping):",
            "        ret = []",
            "        for item in arg:",
            "            if isinstance(item, six.string_types):",
            "                ret.append(item)",
            "            else:",
            "                ret.append(str(item))",
            "    else:",
            "        ret = [str(arg)]",
            "    return ret",
            "",
            "",
            "def symlink(",
            "        name,",
            "        target,",
            "        force=False,",
            "        backupname=None,",
            "        makedirs=False,",
            "        user=None,",
            "        group=None,",
            "        mode=None,",
            "        **kwargs):",
            "    '''",
            "    Create a symbolic link (symlink, soft link)",
            "",
            "    If the file already exists and is a symlink pointing to any location other",
            "    than the specified target, the symlink will be replaced. If the symlink is",
            "    a regular file or directory then the state will return False. If the",
            "    regular file or directory is desired to be replaced with a symlink pass",
            "    force: True, if it is to be renamed, pass a backupname.",
            "",
            "    name",
            "        The location of the symlink to create",
            "",
            "    target",
            "        The location that the symlink points to",
            "",
            "    force",
            "        If the name of the symlink exists and is not a symlink and",
            "        force is set to False, the state will fail. If force is set to",
            "        True, the file or directory in the way of the symlink file",
            "        will be deleted to make room for the symlink, unless",
            "        backupname is set, when it will be renamed",
            "",
            "    backupname",
            "        If the name of the symlink exists and is not a symlink, it will be",
            "        renamed to the backupname. If the backupname already",
            "        exists and force is False, the state will fail. Otherwise, the",
            "        backupname will be removed first.",
            "",
            "    makedirs",
            "        If the location of the symlink does not already have a parent directory",
            "        then the state will fail, setting makedirs to True will allow Salt to",
            "        create the parent directory",
            "",
            "    user",
            "        The user to own the file, this defaults to the user salt is running as",
            "        on the minion",
            "",
            "    group",
            "        The group ownership set for the file, this defaults to the group salt",
            "        is running as on the minion. On Windows, this is ignored",
            "",
            "    mode",
            "        The permissions to set on this file, aka 644, 0775, 4664. Not supported",
            "        on Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    # Make sure that leading zeros stripped by YAML loader are added back",
            "    mode = salt.utils.normalize_mode(mode)",
            "",
            "    user = _test_owner(kwargs, user=user)",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.symlink')",
            "",
            "    if user is None:",
            "        user = __opts__['user']",
            "",
            "    if salt.utils.is_windows():",
            "",
            "        # Make sure the user exists in Windows",
            "        # Salt default is 'root'",
            "        if not __salt__['user.info'](user):",
            "            # User not found, use the account salt is running under",
            "            # If username not found, use System",
            "            user = __salt__['user.current']()",
            "            if not user:",
            "                user = 'SYSTEM'",
            "",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "",
            "    if group is None:",
            "        group = __salt__['file.gid_to_group'](",
            "            __salt__['user.info'](user).get('gid', 0)",
            "        )",
            "",
            "    preflight_errors = []",
            "    uid = __salt__['file.user_to_uid'](user)",
            "    gid = __salt__['file.group_to_gid'](group)",
            "",
            "    if uid == '':",
            "        preflight_errors.append('User {0} does not exist'.format(user))",
            "",
            "    if gid == '':",
            "        preflight_errors.append('Group {0} does not exist'.format(group))",
            "",
            "    if not os.path.isabs(name):",
            "        preflight_errors.append(",
            "            'Specified file {0} is not an absolute path'.format(name)",
            "        )",
            "",
            "    if preflight_errors:",
            "        msg = '. '.join(preflight_errors)",
            "        if len(preflight_errors) > 1:",
            "            msg += '.'",
            "        return _error(ret, msg)",
            "",
            "    presult, pcomment, ret['pchanges'] = _symlink_check(name,",
            "                                                        target,",
            "                                                        force,",
            "                                                        user,",
            "                                                        group)",
            "    if __opts__['test']:",
            "        ret['result'] = presult",
            "        ret['comment'] = pcomment",
            "        return ret",
            "",
            "    if not os.path.isdir(os.path.dirname(name)):",
            "        if makedirs:",
            "            __salt__['file.makedirs'](",
            "                name,",
            "                user=user,",
            "                group=group,",
            "                mode=mode)",
            "        else:",
            "            return _error(",
            "                ret,",
            "                'Directory {0} for symlink is not present'.format(",
            "                    os.path.dirname(name)",
            "                )",
            "            )",
            "    if __salt__['file.is_link'](name):",
            "        # The link exists, verify that it matches the target",
            "        if os.path.normpath(__salt__['file.readlink'](name)) != os.path.normpath(target):",
            "            # The target is wrong, delete the link",
            "            os.remove(name)",
            "        else:",
            "            if _check_symlink_ownership(name, user, group):",
            "                # The link looks good!",
            "                ret['comment'] = ('Symlink {0} is present and owned by '",
            "                                  '{1}:{2}'.format(name, user, group))",
            "            else:",
            "                if _set_symlink_ownership(name, user, group):",
            "                    ret['comment'] = ('Set ownership of symlink {0} to '",
            "                                      '{1}:{2}'.format(name, user, group))",
            "                    ret['changes']['ownership'] = '{0}:{1}'.format(user, group)",
            "                else:",
            "                    ret['result'] = False",
            "                    ret['comment'] += (",
            "                        'Failed to set ownership of symlink {0} to '",
            "                        '{1}:{2}'.format(name, user, group)",
            "                    )",
            "            return ret",
            "",
            "    elif os.path.isfile(name) or os.path.isdir(name):",
            "        # It is not a link, but a file or dir",
            "        if backupname is not None:",
            "            # Make a backup first",
            "            if os.path.lexists(backupname):",
            "                if not force:",
            "                    return _error(ret, ((",
            "                                            'File exists where the backup target {0} should go'",
            "                                        ).format(backupname)))",
            "                else:",
            "                    __salt__['file.remove'](backupname)",
            "            os.rename(name, backupname)",
            "        elif force:",
            "            # Remove whatever is in the way",
            "            if __salt__['file.is_link'](name):",
            "                __salt__['file.remove'](name)",
            "                ret['changes']['forced'] = 'Symlink was forcibly replaced'",
            "            else:",
            "                __salt__['file.remove'](name)",
            "        else:",
            "            # Otherwise throw an error",
            "            if os.path.isfile(name):",
            "                return _error(ret,",
            "                              ('File exists where the symlink {0} should be'",
            "                               .format(name)))",
            "            else:",
            "                return _error(ret, ((",
            "                                        'Directory exists where the symlink {0} should be'",
            "                                    ).format(name)))",
            "",
            "    if not os.path.exists(name):",
            "        # The link is not present, make it",
            "        try:",
            "            __salt__['file.symlink'](target, name)",
            "        except OSError as exc:",
            "            ret['result'] = False",
            "            ret['comment'] = ('Unable to create new symlink {0} -> '",
            "                              '{1}: {2}'.format(name, target, exc))",
            "            return ret",
            "        else:",
            "            ret['comment'] = ('Created new symlink {0} -> '",
            "                              '{1}'.format(name, target))",
            "            ret['changes']['new'] = name",
            "",
            "        if not _check_symlink_ownership(name, user, group):",
            "            if not _set_symlink_ownership(name, user, group):",
            "                ret['result'] = False",
            "                ret['comment'] += (', but was unable to set ownership to '",
            "                                   '{0}:{1}'.format(user, group))",
            "    return ret",
            "",
            "",
            "def absent(name):",
            "    '''",
            "    Make sure that the named file or directory is absent. If it exists, it will",
            "    be deleted. This will work to reverse any of the functions in the file",
            "    state module. If a directory is supplied, it will be recursively deleted.",
            "",
            "    name",
            "        The path which should be deleted",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.absent')",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name)",
            "        )",
            "    if name == '/':",
            "        return _error(ret, 'Refusing to make \"/\" absent')",
            "    if os.path.isfile(name) or os.path.islink(name):",
            "        ret['pchanges']['removed'] = name",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'File {0} is set for removal'.format(name)",
            "            return ret",
            "        try:",
            "            __salt__['file.remove'](name)",
            "            ret['comment'] = 'Removed file {0}'.format(name)",
            "            ret['changes']['removed'] = name",
            "            return ret",
            "        except CommandExecutionError as exc:",
            "            return _error(ret, '{0}'.format(exc))",
            "",
            "    elif os.path.isdir(name):",
            "        ret['pchanges']['removed'] = name",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Directory {0} is set for removal'.format(name)",
            "            return ret",
            "        try:",
            "            __salt__['file.remove'](name)",
            "            ret['comment'] = 'Removed directory {0}'.format(name)",
            "            ret['changes']['removed'] = name",
            "            return ret",
            "        except (OSError, IOError):",
            "            return _error(ret, 'Failed to remove directory {0}'.format(name))",
            "",
            "    ret['comment'] = 'File {0} is not present'.format(name)",
            "    return ret",
            "",
            "",
            "def exists(name):",
            "    '''",
            "    Verify that the named file or directory is present or exists.",
            "    Ensures pre-requisites outside of Salt's purview",
            "    (e.g., keytabs, private keys, etc.) have been previously satisfied before",
            "    deployment.",
            "",
            "    name",
            "        Absolute path which must exist",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.exists')",
            "    if not os.path.exists(name):",
            "        return _error(ret, 'Specified path {0} does not exist'.format(name))",
            "",
            "    ret['comment'] = 'Path {0} exists'.format(name)",
            "    return ret",
            "",
            "",
            "def missing(name):",
            "    '''",
            "    Verify that the named file or directory is missing, this returns True only",
            "    if the named file is missing but does not remove the file if it is present.",
            "",
            "    name",
            "        Absolute path which must NOT exist",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.missing')",
            "    if os.path.exists(name):",
            "        return _error(ret, 'Specified path {0} exists'.format(name))",
            "",
            "    ret['comment'] = 'Path {0} is missing'.format(name)",
            "    return ret",
            "",
            "",
            "def managed(name,",
            "            source=None,",
            "            source_hash='',",
            "            source_hash_name=None,",
            "            user=None,",
            "            group=None,",
            "            mode=None,",
            "            template=None,",
            "            makedirs=False,",
            "            dir_mode=None,",
            "            context=None,",
            "            replace=True,",
            "            defaults=None,",
            "            backup='',",
            "            show_changes=True,",
            "            create=True,",
            "            contents=None,",
            "            tmp_ext='',",
            "            contents_pillar=None,",
            "            contents_grains=None,",
            "            contents_newline=True,",
            "            contents_delimiter=':',",
            "            allow_empty=True,",
            "            follow_symlinks=True,",
            "            check_cmd=None,",
            "            skip_verify=False,",
            "            **kwargs):",
            "    '''",
            "    Manage a given file, this function allows for a file to be downloaded from",
            "    the salt master and potentially run through a templating system.",
            "",
            "    name",
            "        The location of the file to manage",
            "",
            "    source",
            "        The source file to download to the minion, this source file can be",
            "        hosted on either the salt master server (``salt://``), the salt minion",
            "        local file system (``/``), or on an HTTP or FTP server (``http(s)://``,",
            "        ``ftp://``).",
            "",
            "        Both HTTPS and HTTP are supported as well as downloading directly",
            "        from Amazon S3 compatible URLs with both pre-configured and automatic",
            "        IAM credentials. (see s3.get state documentation)",
            "        File retrieval from Openstack Swift object storage is supported via",
            "        swift://container/object_path URLs, see swift.get documentation.",
            "        For files hosted on the salt file server, if the file is located on",
            "        the master in the directory named spam, and is called eggs, the source",
            "        string is salt://spam/eggs. If source is left blank or None",
            "        (use ~ in YAML), the file will be created as an empty file and",
            "        the content will not be managed. This is also the case when a file",
            "        already exists and the source is undefined; the contents of the file",
            "        will not be changed or managed.",
            "",
            "        If the file is hosted on a HTTP or FTP server then the source_hash",
            "        argument is also required.",
            "",
            "        A list of sources can also be passed in to provide a default source and",
            "        a set of fallbacks. The first source in the list that is found to exist",
            "        will be used and subsequent entries in the list will be ignored. Source",
            "        list functionality only supports local files and remote files hosted on",
            "        the salt master server or retrievable via HTTP, HTTPS, or FTP.",
            "",
            "        .. code-block:: yaml",
            "",
            "            file_override_example:",
            "              file.managed:",
            "                - source:",
            "                  - salt://file_that_does_not_exist",
            "                  - salt://file_that_exists",
            "",
            "    source_hash",
            "        This can be one of the following:",
            "            1. a source hash string",
            "            2. the URI of a file that contains source hash strings",
            "",
            "        The function accepts the first encountered long unbroken alphanumeric",
            "        string of correct length as a valid hash, in order from most secure to",
            "        least secure:",
            "",
            "        .. code-block:: text",
            "",
            "            Type    Length",
            "            ======  ======",
            "            sha512     128",
            "            sha384      96",
            "            sha256      64",
            "            sha224      56",
            "            sha1        40",
            "            md5         32",
            "",
            "        **Using a Source Hash File**",
            "            The file can contain several checksums for several files. Each line",
            "            must contain both the file name and the hash.  If no file name is",
            "            matched, the first hash encountered will be used, otherwise the most",
            "            secure hash with the correct source file name will be used.",
            "",
            "            When using a source hash file the source_hash argument needs to be a",
            "            url, the standard download urls are supported, ftp, http, salt etc:",
            "",
            "            Example:",
            "",
            "            .. code-block:: yaml",
            "",
            "                tomdroid-src-0.7.3.tar.gz:",
            "                  file.managed:",
            "                    - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                    - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.hash",
            "",
            "            The following lines are all supported formats:",
            "",
            "            .. code-block:: text",
            "",
            "                /etc/rc.conf ef6e82e4006dee563d98ada2a2a80a27",
            "                sha254c8525aee419eb649f0233be91c151178b30f0dff8ebbdcc8de71b1d5c8bcc06a  /etc/resolv.conf",
            "                ead48423703509d37c4a90e6a0d53e143b6fc268",
            "",
            "            Debian file type ``*.dsc`` files are also supported.",
            "",
            "        **Inserting the Source Hash in the SLS Data**",
            "",
            "        The source_hash can be specified as a simple checksum, like so:",
            "",
            "        .. code-block:: yaml",
            "",
            "            tomdroid-src-0.7.3.tar.gz:",
            "              file.managed:",
            "                - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                - source_hash: 79eef25f9b0b2c642c62b7f737d4f53f",
            "",
            "        .. note::",
            "            Releases prior to 2016.11.0 must also include the hash type, like",
            "            in the below example:",
            "",
            "            .. code-block:: yaml",
            "",
            "                tomdroid-src-0.7.3.tar.gz:",
            "                  file.managed:",
            "                    - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                    - source_hash: md5=79eef25f9b0b2c642c62b7f737d4f53f",
            "",
            "        Known issues:",
            "            If the remote server URL has the hash file as an apparent",
            "            sub-directory of the source file, the module will discover that it",
            "            has already cached a directory where a file should be cached. For",
            "            example:",
            "",
            "            .. code-block:: yaml",
            "",
            "                tomdroid-src-0.7.3.tar.gz:",
            "                  file.managed:",
            "                    - name: /tmp/tomdroid-src-0.7.3.tar.gz",
            "                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz",
            "                    - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz/+md5",
            "",
            "    source_hash_name",
            "        When ``source_hash`` refers to a hash file, Salt will try to find the",
            "        correct hash by matching the filename/URI associated with that hash. By",
            "        default, Salt will look for the filename being managed. When managing a",
            "        file at path ``/tmp/foo.txt``, then the following line in a hash file",
            "        would match:",
            "",
            "        .. code-block:: text",
            "",
            "            acbd18db4cc2f85cedef654fccc4a4d8    foo.txt",
            "",
            "        However, sometimes a hash file will include multiple similar paths:",
            "",
            "        .. code-block:: text",
            "",
            "            37b51d194a7513e45b56f6524f2d51f2    ./dir1/foo.txt",
            "            acbd18db4cc2f85cedef654fccc4a4d8    ./dir2/foo.txt",
            "            73feffa4b7f6bb68e44cf984c85f6e88    ./dir3/foo.txt",
            "",
            "        In cases like this, Salt may match the incorrect hash. This argument",
            "        can be used to tell Salt which filename to match, to ensure that the",
            "        correct hash is identified. For example:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /tmp/foo.txt:",
            "              file.managed:",
            "                - source: https://mydomain.tld/dir2/foo.txt",
            "                - source_hash: https://mydomain.tld/hashes",
            "                - source_hash_name: ./dir2/foo.txt",
            "",
            "        .. note::",
            "            This argument must contain the full filename entry from the",
            "            checksum file, as this argument is meant to disambiguate matches",
            "            for multiple files that have the same basename. So, in the",
            "            example above, simply using ``foo.txt`` would not match.",
            "",
            "        .. versionadded:: 2016.3.5",
            "",
            "    user",
            "        The user to own the file, this defaults to the user salt is running as",
            "        on the minion",
            "",
            "    group",
            "        The group ownership set for the file, this defaults to the group salt",
            "        is running as on the minion On Windows, this is ignored",
            "",
            "    mode",
            "        The permissions to set on this file, e.g. ``644``, ``0775``, or ``4664``.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "        .. versionchanged:: 2016.11.0",
            "            This option can be set to ``keep``, and Salt will keep the mode",
            "            from the Salt fileserver. This is only supported when the",
            "            ``source`` URL begins with ``salt://``, or for files local to the",
            "            minion. Because the ``source`` option cannot be used with any of",
            "            the ``contents`` options, setting the ``mode`` to ``keep`` is also",
            "            incompatible with the ``contents`` options.",
            "",
            "        .. note:: keep does not work with salt-ssh.",
            "",
            "            As a consequence of how the files are transfered to the minion, and",
            "            the inability to connect back to the master with salt-ssh, salt is",
            "            unable to stat the file as it exists on the fileserver and thus",
            "            cannot mirror the mode on the salt-ssh minion",
            "",
            "    template",
            "        If this setting is applied, the named templating engine will be used to",
            "        render the downloaded file. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "    makedirs : False",
            "        If set to ``True``, then the parent directories will be created to",
            "        facilitate the creation of the named file. If ``False``, and the parent",
            "        directory of the destination file doesn't exist, the state will fail.",
            "",
            "    dir_mode",
            "        If directories are to be created, passing this option specifies the",
            "        permissions for those directories. If this is not set, directories",
            "        will be assigned permissions by adding the execute bit to the mode of",
            "        the files.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    replace : True",
            "        If set to ``False`` and the file already exists, the file will not be",
            "        modified even if changes would otherwise be made. Permissions and",
            "        ownership will still be enforced, however.",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    backup",
            "        Overrides the default backup mode for this specific file. See",
            "        :ref:`backup_mode documentation <file-state-backups>` for more details.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made.",
            "",
            "    create : True",
            "        If set to ``False``, then the file will only be managed if the file",
            "        already exists on the system.",
            "",
            "    contents",
            "        Specify the contents of the file. Cannot be used in combination with",
            "        ``source``. Ignores hashes and does not use a templating engine.",
            "",
            "        This value can be either a single string, a multiline YAML string or a",
            "        list of strings.  If a list of strings, then the strings will be joined",
            "        together with newlines in the resulting file. For example, the below",
            "        two example states would result in identical file contents:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /path/to/file1:",
            "              file.managed:",
            "                - contents:",
            "                  - This is line 1",
            "                  - This is line 2",
            "",
            "            /path/to/file2:",
            "              file.managed:",
            "                - contents: |",
            "                    This is line 1",
            "                    This is line 2",
            "",
            "",
            "    contents_pillar",
            "        .. versionadded:: 0.17.0",
            "        .. versionchanged: 2016.11.0",
            "            contents_pillar can also be a list, and the pillars will be",
            "            concatinated together to form one file.",
            "",
            "",
            "        Operates like ``contents``, but draws from a value stored in pillar,",
            "        using the pillar path syntax used in :mod:`pillar.get",
            "        <salt.modules.pillar.get>`. This is useful when the pillar value",
            "        contains newlines, as referencing a pillar variable using a jinja/mako",
            "        template can result in YAML formatting issues due to the newlines",
            "        causing indentation mismatches.",
            "",
            "        For example, the following could be used to deploy an SSH private key:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /home/deployer/.ssh/id_rsa:",
            "              file.managed:",
            "                - user: deployer",
            "                - group: deployer",
            "                - mode: 600",
            "                - contents_pillar: userdata:deployer:id_rsa",
            "",
            "        This would populate ``/home/deployer/.ssh/id_rsa`` with the contents of",
            "        ``pillar['userdata']['deployer']['id_rsa']``. An example of this pillar",
            "        setup would be like so:",
            "",
            "        .. code-block:: yaml",
            "",
            "            userdata:",
            "              deployer:",
            "                id_rsa: |",
            "                    -----BEGIN RSA PRIVATE KEY-----",
            "                    MIIEowIBAAKCAQEAoQiwO3JhBquPAalQF9qP1lLZNXVjYMIswrMe2HcWUVBgh+vY",
            "                    U7sCwx/dH6+VvNwmCoqmNnP+8gTPKGl1vgAObJAnMT623dMXjVKwnEagZPRJIxDy",
            "                    B/HaAre9euNiY3LvIzBTWRSeMfT+rWvIKVBpvwlgGrfgz70m0pqxu+UyFbAGLin+",
            "                    GpxzZAMaFpZw4sSbIlRuissXZj/sHpQb8p9M5IeO4Z3rjkCP1cxI",
            "                    -----END RSA PRIVATE KEY-----",
            "",
            "        .. note::",
            "",
            "            The private key above is shortened to keep the example brief, but",
            "            shows how to do multiline string in YAML. The key is followed by a",
            "            pipe character, and the mutliline string is indented two more",
            "            spaces.",
            "",
            "            To avoid the hassle of creating an indented multiline YAML string,",
            "            the :mod:`file_tree external pillar <salt.pillar.file_tree>` can",
            "            be used instead. However, this will not work for binary files in",
            "            Salt releases before 2015.8.4.",
            "",
            "    contents_grains",
            "        .. versionadded:: 2014.7.0",
            "",
            "        Operates like ``contents``, but draws from a value stored in grains,",
            "        using the grains path syntax used in :mod:`grains.get",
            "        <salt.modules.grains.get>`. This functionality works similarly to",
            "        ``contents_pillar``, but with grains.",
            "",
            "        For example, the following could be used to deploy a \"message of the day\"",
            "        file:",
            "",
            "        .. code-block:: yaml",
            "",
            "            write_motd:",
            "              file.managed:",
            "                - name: /etc/motd",
            "                - contents_grains: motd",
            "",
            "        This would populate ``/etc/motd`` file with the contents of the ``motd``",
            "        grain. The ``motd`` grain is not a default grain, and would need to be",
            "        set prior to running the state:",
            "",
            "        .. code-block:: bash",
            "",
            "            salt '*' grains.set motd 'Welcome! This system is managed by Salt.'",
            "",
            "    contents_newline : True",
            "        .. versionadded:: 2014.7.0",
            "        .. versionchanged:: 2015.8.4",
            "            This option is now ignored if the contents being deployed contain",
            "            binary data.",
            "",
            "        If ``True``, files managed using ``contents``, ``contents_pillar``, or",
            "        ``contents_grains`` will have a newline added to the end of the file if",
            "        one is not present. Setting this option to ``False`` will omit this",
            "        final newline.",
            "",
            "    contents_delimiter",
            "        .. versionadded:: 2015.8.4",
            "",
            "        Can be used to specify an alternate delimiter for ``contents_pillar``",
            "        or ``contents_grains``. This delimiter will be passed through to",
            "        :py:func:`pillar.get <salt.modules.pillar.get>` or :py:func:`grains.get",
            "        <salt.modules.grains.get>` when retrieving the contents.",
            "",
            "    allow_empty : True",
            "        .. versionadded:: 2015.8.4",
            "",
            "        If set to ``False``, then the state will fail if the contents specified",
            "        by ``contents_pillar`` or ``contents_grains`` are empty.",
            "",
            "    follow_symlinks : True",
            "        .. versionadded:: 2014.7.0",
            "",
            "        If the desired path is a symlink follow it and make changes to the",
            "        file to which the symlink points.",
            "",
            "    check_cmd",
            "        .. versionadded:: 2014.7.0",
            "",
            "        The specified command will be run with an appended argument of a",
            "        *temporary* file containing the new managed contents.  If the command",
            "        exits with a zero status the new managed contents will be written to",
            "        the managed destination. If the command exits with a nonzero exit",
            "        code, the state will fail and no changes will be made to the file.",
            "",
            "        For example, the following could be used to verify sudoers before making",
            "        changes:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /etc/sudoers:",
            "              file.managed:",
            "                - user: root",
            "                - group: root",
            "                - mode: 0440",
            "                - source: salt://sudoers/files/sudoers.jinja",
            "                - template: jinja",
            "                - check_cmd: /usr/sbin/visudo -c -f",
            "",
            "        **NOTE**: This ``check_cmd`` functions differently than the requisite",
            "        ``check_cmd``.",
            "",
            "    tmp_ext",
            "        Suffix for temp file created by ``check_cmd``. Useful for checkers",
            "        dependant on config file extension (e.g. the init-checkconf upstart",
            "        config checker).",
            "",
            "        .. code-block:: yaml",
            "",
            "            /etc/init/test.conf:",
            "              file.managed:",
            "                - user: root",
            "                - group: root",
            "                - mode: 0440",
            "                - tmp_ext: '.conf'",
            "                - contents:",
            "                  - 'description \"Salt Minion\"''",
            "                  - 'start on started mountall'",
            "                  - 'stop on shutdown'",
            "                  - 'respawn'",
            "                  - 'exec salt-minion'",
            "                - check_cmd: init-checkconf -f",
            "",
            "    skip_verify : False",
            "        If ``True``, hash verification of remote file sources (``http://``,",
            "        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``",
            "        argument will be ignored.",
            "",
            "        .. versionadded:: 2016.3.0",
            "    '''",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'changes': {},",
            "           'pchanges': {},",
            "           'comment': '',",
            "           'name': name,",
            "           'result': True}",
            "",
            "    if mode is not None and salt.utils.is_windows():",
            "        return _error(ret, 'The \\'mode\\' option is not supported on Windows')",
            "",
            "    try:",
            "        keep_mode = mode.lower() == 'keep'",
            "        if keep_mode:",
            "            # We're not hard-coding the mode, so set it to None",
            "            mode = None",
            "    except AttributeError:",
            "        keep_mode = False",
            "",
            "    # Make sure that any leading zeros stripped by YAML loader are added back",
            "    mode = salt.utils.normalize_mode(mode)",
            "",
            "    contents_count = len(",
            "        [x for x in (contents, contents_pillar, contents_grains)",
            "         if x is not None]",
            "    )",
            "",
            "    if source and contents_count > 0:",
            "        return _error(",
            "            ret,",
            "            '\\'source\\' cannot be used in combination with \\'contents\\', '",
            "            '\\'contents_pillar\\', or \\'contents_grains\\''",
            "        )",
            "    elif keep_mode and contents_count > 0:",
            "        return _error(",
            "            ret,",
            "            'Mode preservation cannot be used in combination with \\'contents\\', '",
            "            '\\'contents_pillar\\', or \\'contents_grains\\''",
            "        )",
            "    elif contents_count > 1:",
            "        return _error(",
            "            ret,",
            "            'Only one of \\'contents\\', \\'contents_pillar\\', and '",
            "            '\\'contents_grains\\' is permitted'",
            "        )",
            "",
            "    # If no source is specified, set replace to False, as there is nothing",
            "    # with which to replace the file.",
            "    if not source and contents_count == 0 and replace:",
            "        replace = False",
            "        log.warning(",
            "            'State for file: {0} - Neither \\'source\\' nor \\'contents\\' nor '",
            "            '\\'contents_pillar\\' nor \\'contents_grains\\' was defined, yet '",
            "            '\\'replace\\' was set to \\'True\\'. As there is no source to '",
            "            'replace the file with, \\'replace\\' has been set to \\'False\\' to '",
            "            'avoid reading the file unnecessarily.'.format(name)",
            "        )",
            "",
            "    # Use this below to avoid multiple '\\0' checks and save some CPU cycles",
            "    if contents_pillar is not None:",
            "        if isinstance(contents_pillar, list):",
            "            list_contents = []",
            "            for nextp in contents_pillar:",
            "                nextc = __salt__['pillar.get'](nextp, __NOT_FOUND,",
            "                                               delimiter=contents_delimiter)",
            "                if nextc is __NOT_FOUND:",
            "                    return _error(",
            "                        ret,",
            "                        'Pillar {0} does not exist'.format(nextp)",
            "                    )",
            "                list_contents.append(nextc)",
            "            use_contents = os.linesep.join(list_contents)",
            "        else:",
            "            use_contents = __salt__['pillar.get'](contents_pillar, __NOT_FOUND,",
            "                                                  delimiter=contents_delimiter)",
            "            if use_contents is __NOT_FOUND:",
            "                return _error(",
            "                    ret,",
            "                    'Pillar {0} does not exist'.format(contents_pillar)",
            "                )",
            "",
            "    elif contents_grains is not None:",
            "        if isinstance(contents_grains, list):",
            "            list_contents = []",
            "            for nextg in contents_grains:",
            "                nextc = __salt__['grains.get'](nextg, __NOT_FOUND,",
            "                                               delimiter=contents_delimiter)",
            "                if nextc is __NOT_FOUND:",
            "                    return _error(",
            "                        ret,",
            "                        'Grain {0} does not exist'.format(nextc)",
            "                    )",
            "                list_contents.append(nextc)",
            "            use_contents = os.linesep.join(list_contents)",
            "        else:",
            "            use_contents = __salt__['grains.get'](contents_grains, __NOT_FOUND,",
            "                                                  delimiter=contents_delimiter)",
            "            if use_contents is __NOT_FOUND:",
            "                return _error(",
            "                    ret,",
            "                    'Grain {0} does not exist'.format(contents_grains)",
            "                )",
            "",
            "    elif contents is not None:",
            "        use_contents = contents",
            "",
            "    else:",
            "        use_contents = None",
            "",
            "    if use_contents is not None:",
            "        if not allow_empty and not use_contents:",
            "            if contents_pillar:",
            "                contents_id = 'contents_pillar {0}'.format(contents_pillar)",
            "            elif contents_grains:",
            "                contents_id = 'contents_grains {0}'.format(contents_grains)",
            "            else:",
            "                contents_id = '\\'contents\\''",
            "            return _error(",
            "                ret,",
            "                '{0} value would result in empty contents. Set allow_empty '",
            "                'to True to allow the managed file to be empty.'",
            "                .format(contents_id)",
            "            )",
            "",
            "        contents_are_binary = \\",
            "            isinstance(use_contents, six.string_types) and '\\0' in use_contents",
            "        if contents_are_binary:",
            "            contents = use_contents",
            "        else:",
            "            validated_contents = _validate_str_list(use_contents)",
            "            if not validated_contents:",
            "                return _error(",
            "                    ret,",
            "                    'Contents specified by contents/contents_pillar/'",
            "                    'contents_grains is not a string or list of strings, and '",
            "                    'is not binary data. SLS is likely malformed.'",
            "                )",
            "            contents = os.linesep.join(validated_contents)",
            "            if contents_newline and not contents.endswith(os.linesep):",
            "                contents += os.linesep",
            "        if template:",
            "            contents = __salt__['file.apply_template_on_contents'](",
            "                contents,",
            "                template=template,",
            "                context=context,",
            "                defaults=defaults,",
            "                saltenv=__env__)",
            "            if not isinstance(contents, six.string_types):",
            "                if 'result' in contents:",
            "                    ret['result'] = contents['result']",
            "                else:",
            "                    ret['result'] = False",
            "                if 'comment' in contents:",
            "                    ret['comment'] = contents['comment']",
            "                else:",
            "                    ret['comment'] = 'Error while applying template on contents'",
            "                return ret",
            "",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.exists')",
            "    user = _test_owner(kwargs, user=user)",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "    if not create:",
            "        if not os.path.isfile(name):",
            "            # Don't create a file that is not already present",
            "            ret['comment'] = ('File {0} is not present and is not set for '",
            "                              'creation').format(name)",
            "            return ret",
            "    u_check = _check_user(user, group)",
            "    if u_check:",
            "        # The specified user or group do not exist",
            "        return _error(ret, u_check)",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    if os.path.isdir(name):",
            "        ret['comment'] = 'Specified target {0} is a directory'.format(name)",
            "        ret['result'] = False",
            "        return ret",
            "",
            "    if context is None:",
            "        context = {}",
            "    elif not isinstance(context, dict):",
            "        return _error(",
            "            ret, 'Context must be formed as a dict')",
            "    if defaults and not isinstance(defaults, dict):",
            "        return _error(",
            "            ret, 'Defaults must be formed as a dict')",
            "",
            "    if not replace and os.path.exists(name):",
            "        # Check and set the permissions if necessary",
            "        ret, _ = __salt__['file.check_perms'](name, ret, user, group, mode,",
            "                                              follow_symlinks)",
            "        if __opts__['test']:",
            "            ret['comment'] = 'File {0} not updated'.format(name)",
            "        elif not ret['changes'] and ret['result']:",
            "            ret['comment'] = ('File {0} exists with proper permissions. '",
            "                              'No changes made.'.format(name))",
            "        return ret",
            "",
            "    accum_data, _ = _load_accumulators()",
            "    if name in accum_data:",
            "        if not context:",
            "            context = {}",
            "        context['accumulator'] = accum_data[name]",
            "",
            "    try:",
            "        if __opts__['test']:",
            "            if 'file.check_managed_changes' in __salt__:",
            "                ret['pchanges'] = __salt__['file.check_managed_changes'](",
            "                    name,",
            "                    source,",
            "                    source_hash,",
            "                    source_hash_name,",
            "                    user,",
            "                    group,",
            "                    mode,",
            "                    template,",
            "                    context,",
            "                    defaults,",
            "                    __env__,",
            "                    contents,",
            "                    skip_verify,",
            "                    **kwargs",
            "                )",
            "            if isinstance(ret['pchanges'], tuple):",
            "                ret['result'], ret['comment'] = ret['pchanges']",
            "            elif ret['pchanges']:",
            "                ret['result'] = None",
            "                ret['comment'] = 'The file {0} is set to be changed'.format(name)",
            "                if show_changes and 'diff' in ret['pchanges']:",
            "                    ret['changes']['diff'] = ret['pchanges']['diff']",
            "                if not show_changes:",
            "                    ret['changes']['diff'] = '<show_changes=False>'",
            "            else:",
            "                ret['result'] = True",
            "                ret['comment'] = 'The file {0} is in the correct state'.format(name)",
            "",
            "            return ret",
            "",
            "        # If the source is a list then find which file exists",
            "        source, source_hash = __salt__['file.source_list'](",
            "            source,",
            "            source_hash,",
            "            __env__",
            "        )",
            "    except CommandExecutionError as exc:",
            "        ret['result'] = False",
            "        ret['comment'] = 'Unable to manage file: {0}'.format(exc)",
            "        return ret",
            "",
            "    # Gather the source file from the server",
            "    try:",
            "        sfn, source_sum, comment_ = __salt__['file.get_managed'](",
            "            name,",
            "            template,",
            "            source,",
            "            source_hash,",
            "            source_hash_name,",
            "            user,",
            "            group,",
            "            mode,",
            "            __env__,",
            "            context,",
            "            defaults,",
            "            skip_verify,",
            "            **kwargs",
            "        )",
            "    except Exception as exc:",
            "        ret['changes'] = {}",
            "        log.debug(traceback.format_exc())",
            "        return _error(ret, 'Unable to manage file: {0}'.format(exc))",
            "",
            "    tmp_filename = None",
            "",
            "    if check_cmd:",
            "        tmp_filename = salt.utils.mkstemp(suffix=tmp_ext)",
            "",
            "        # if exists copy existing file to tmp to compare",
            "        if __salt__['file.file_exists'](name):",
            "            try:",
            "                __salt__['file.copy'](name, tmp_filename)",
            "            except Exception as exc:",
            "                return _error(",
            "                    ret,",
            "                    'Unable to copy file {0} to {1}: {2}'.format(",
            "                        name, tmp_filename, exc",
            "                    )",
            "                )",
            "",
            "        try:",
            "            ret = __salt__['file.manage_file'](",
            "                tmp_filename,",
            "                sfn,",
            "                ret,",
            "                source,",
            "                source_sum,",
            "                user,",
            "                group,",
            "                mode,",
            "                __env__,",
            "                backup,",
            "                makedirs,",
            "                template,",
            "                show_changes,",
            "                contents,",
            "                dir_mode,",
            "                follow_symlinks,",
            "                skip_verify,",
            "                keep_mode,",
            "                **kwargs)",
            "        except Exception as exc:",
            "            ret['changes'] = {}",
            "            log.debug(traceback.format_exc())",
            "            if os.path.isfile(tmp_filename):",
            "                os.remove(tmp_filename)",
            "            return _error(ret, 'Unable to check_cmd file: {0}'.format(exc))",
            "",
            "        # file being updated to verify using check_cmd",
            "        if ret['changes']:",
            "            # Reset ret",
            "            ret = {'changes': {},",
            "                   'comment': '',",
            "                   'name': name,",
            "                   'result': True}",
            "",
            "            check_cmd_opts = {}",
            "            if 'shell' in __grains__:",
            "                check_cmd_opts['shell'] = __grains__['shell']",
            "",
            "            cret = mod_run_check_cmd(check_cmd, tmp_filename, **check_cmd_opts)",
            "            if isinstance(cret, dict):",
            "                ret.update(cret)",
            "                if os.path.isfile(tmp_filename):",
            "                    os.remove(tmp_filename)",
            "                return ret",
            "            # Since we generated a new tempfile and we are not returning here",
            "            # lets change the original sfn to the new tempfile or else we will",
            "            # get file not found",
            "            sfn = tmp_filename",
            "        else:",
            "            ret = {'changes': {},",
            "                   'comment': '',",
            "                   'name': name,",
            "                   'result': True}",
            "",
            "    if comment_ and contents is None:",
            "        return _error(ret, comment_)",
            "    else:",
            "        try:",
            "            return __salt__['file.manage_file'](",
            "                name,",
            "                sfn,",
            "                ret,",
            "                source,",
            "                source_sum,",
            "                user,",
            "                group,",
            "                mode,",
            "                __env__,",
            "                backup,",
            "                makedirs,",
            "                template,",
            "                show_changes,",
            "                contents,",
            "                dir_mode,",
            "                follow_symlinks,",
            "                skip_verify,",
            "                keep_mode,",
            "                **kwargs)",
            "        except Exception as exc:",
            "            ret['changes'] = {}",
            "            log.debug(traceback.format_exc())",
            "            return _error(ret, 'Unable to manage file: {0}'.format(exc))",
            "        finally:",
            "            if tmp_filename and os.path.isfile(tmp_filename):",
            "                os.remove(tmp_filename)",
            "",
            "",
            "_RECURSE_TYPES = ['user', 'group', 'mode', 'ignore_files', 'ignore_dirs']",
            "",
            "",
            "def _get_recurse_set(recurse):",
            "    '''",
            "    Converse *recurse* definition to a set of strings.",
            "",
            "    Raises TypeError or ValueError when *recurse* has wrong structure.",
            "    '''",
            "    if not recurse:",
            "        return set()",
            "    if not isinstance(recurse, list):",
            "        raise TypeError('\"recurse\" must be formed as a list of strings')",
            "    try:",
            "        recurse_set = set(recurse)",
            "    except TypeError:  # non-hashable elements",
            "        recurse_set = None",
            "    if recurse_set is None or not set(_RECURSE_TYPES) >= recurse_set:",
            "        raise ValueError('Types for \"recurse\" limited to {0}.'.format(",
            "            ', '.join('\"{0}\"'.format(rtype) for rtype in _RECURSE_TYPES)))",
            "    if 'ignore_files' in recurse_set and 'ignore_dirs' in recurse_set:",
            "        raise ValueError('Must not specify \"recurse\" options \"ignore_files\"'",
            "                         ' and \"ignore_dirs\" at the same time.')",
            "    return recurse_set",
            "",
            "",
            "def _depth_limited_walk(top, max_depth=None):",
            "    '''",
            "    Walk the directory tree under root up till reaching max_depth.",
            "    With max_depth=None (default), do not limit depth.",
            "    '''",
            "    for root, dirs, files in os.walk(top):",
            "        if max_depth is not None:",
            "            rel_depth = root.count(os.sep) - top.count(os.sep)",
            "            if rel_depth >= max_depth:",
            "                del dirs[:]",
            "        yield (str(root), list(dirs), list(files))",
            "",
            "",
            "def directory(name,",
            "              user=None,",
            "              group=None,",
            "              recurse=None,",
            "              max_depth=None,",
            "              dir_mode=None,",
            "              file_mode=None,",
            "              makedirs=False,",
            "              clean=False,",
            "              require=None,",
            "              exclude_pat=None,",
            "              follow_symlinks=False,",
            "              force=False,",
            "              backupname=None,",
            "              allow_symlink=True,",
            "              children_only=False,",
            "              **kwargs):",
            "    '''",
            "    Ensure that a named directory is present and has the right perms",
            "",
            "    name",
            "        The location to create or manage a directory",
            "",
            "    user",
            "        The user to own the directory; this defaults to the user salt is",
            "        running as on the minion",
            "",
            "    group",
            "        The group ownership set for the directory; this defaults to the group",
            "        salt is running as on the minion. On Windows, this is ignored",
            "",
            "    recurse",
            "        Enforce user/group ownership and mode of directory recursively. Accepts",
            "        a list of strings representing what you would like to recurse.  If",
            "        ``mode`` is defined, will recurse on both ``file_mode`` and ``dir_mode`` if",
            "        they are defined.  If ``ignore_files`` or ``ignore_dirs`` is included, files or",
            "        directories will be left unchanged respectively.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /var/log/httpd:",
            "              file.directory:",
            "                - user: root",
            "                - group: root",
            "                - dir_mode: 755",
            "                - file_mode: 644",
            "                - recurse:",
            "                  - user",
            "                  - group",
            "                  - mode",
            "",
            "        Leave files or directories unchanged:",
            "",
            "        .. code-block:: yaml",
            "",
            "            /var/log/httpd:",
            "              file.directory:",
            "                - user: root",
            "                - group: root",
            "                - dir_mode: 755",
            "                - file_mode: 644",
            "                - recurse:",
            "                  - user",
            "                  - group",
            "                  - mode",
            "                  - ignore_dirs",
            "",
            "        .. versionadded:: 2015.5.0",
            "",
            "    max_depth",
            "        Limit the recursion depth. The default is no limit=None.",
            "        'max_depth' and 'clean' are mutually exclusive.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    dir_mode / mode",
            "        The permissions mode to set any directories created. Not supported on",
            "        Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    file_mode",
            "        The permissions mode to set any files created if 'mode' is run in",
            "        'recurse'. This defaults to dir_mode. Not supported on Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    makedirs",
            "        If the directory is located in a path without a parent directory, then",
            "        the state will fail. If makedirs is set to True, then the parent",
            "        directories will be created to facilitate the creation of the named",
            "        file.",
            "",
            "    clean",
            "        Make sure that only files that are set up by salt and required by this",
            "        function are kept. If this option is set then everything in this",
            "        directory will be deleted unless it is required.",
            "        'clean' and 'max_depth' are mutually exclusive.",
            "",
            "    require",
            "        Require other resources such as packages or files",
            "",
            "    exclude_pat",
            "        When 'clean' is set to True, exclude this pattern from removal list",
            "        and preserve in the destination.",
            "",
            "    follow_symlinks : False",
            "        If the desired path is a symlink (or ``recurse`` is defined and a",
            "        symlink is encountered while recursing), follow it and check the",
            "        permissions of the directory/file to which the symlink points.",
            "",
            "        .. versionadded:: 2014.1.4",
            "",
            "    force",
            "        If the name of the directory exists and is not a directory and",
            "        force is set to False, the state will fail. If force is set to",
            "        True, the file in the way of the directory will be deleted to",
            "        make room for the directory, unless backupname is set,",
            "        then it will be renamed.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    backupname",
            "        If the name of the directory exists and is not a directory, it will be",
            "        renamed to the backupname. If the backupname already",
            "        exists and force is False, the state will fail. Otherwise, the",
            "        backupname will be removed first.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    allow_symlink : True",
            "        If allow_symlink is True and the specified path is a symlink, it will be",
            "        allowed to remain if it points to a directory. If allow_symlink is False",
            "        then the state will fail, unless force is also set to True, in which case",
            "        it will be removed or renamed, depending on the value of the backupname",
            "        argument.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    children_only : False",
            "        If children_only is True the base of a path is excluded when performing",
            "        a recursive operation. In case of /path/to/base, base will be ignored",
            "        while all of /path/to/base/* are still operated on.",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.directory')",
            "    # Remove trailing slash, if present and we're not working on \"/\" itself",
            "    if name[-1] == '/' and name != '/':",
            "        name = name[:-1]",
            "",
            "    if max_depth is not None and clean:",
            "        return _error(ret, 'Cannot specify both max_depth and clean')",
            "",
            "    user = _test_owner(kwargs, user=user)",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this is '",
            "                'a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "",
            "    if 'mode' in kwargs and not dir_mode:",
            "        dir_mode = kwargs.get('mode', [])",
            "",
            "    if not file_mode:",
            "        file_mode = dir_mode",
            "",
            "    # Make sure that leading zeros stripped by YAML loader are added back",
            "    dir_mode = salt.utils.normalize_mode(dir_mode)",
            "    file_mode = salt.utils.normalize_mode(file_mode)",
            "",
            "    u_check = _check_user(user, group)",
            "    if u_check:",
            "        # The specified user or group do not exist",
            "        return _error(ret, u_check)",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    # Check for existing file or symlink",
            "    if os.path.isfile(name) or (not allow_symlink and os.path.islink(name)) \\",
            "       or (force and os.path.islink(name)):",
            "        # Was a backupname specified",
            "        if backupname is not None:",
            "            # Make a backup first",
            "            if os.path.lexists(backupname):",
            "                if not force:",
            "                    return _error(ret, ((",
            "                                            'File exists where the backup target {0} should go'",
            "                                        ).format(backupname)))",
            "                else:",
            "                    __salt__['file.remove'](backupname)",
            "            os.rename(name, backupname)",
            "        elif force:",
            "            # Remove whatever is in the way",
            "            if os.path.isfile(name):",
            "                os.remove(name)",
            "                ret['changes']['forced'] = 'File was forcibly replaced'",
            "            elif __salt__['file.is_link'](name):",
            "                __salt__['file.remove'](name)",
            "                ret['changes']['forced'] = 'Symlink was forcibly replaced'",
            "            else:",
            "                __salt__['file.remove'](name)",
            "        else:",
            "            if os.path.isfile(name):",
            "                return _error(",
            "                    ret,",
            "                    'Specified location {0} exists and is a file'.format(name))",
            "            elif os.path.islink(name):",
            "                return _error(",
            "                    ret,",
            "                    'Specified location {0} exists and is a symlink'.format(name))",
            "    presult, pcomment, ret['pchanges'] = _check_directory(",
            "        name,",
            "        user,",
            "        group,",
            "        recurse or [],",
            "        dir_mode,",
            "        clean,",
            "        require,",
            "        exclude_pat,",
            "        max_depth)",
            "",
            "    if __opts__['test']:",
            "        ret['result'] = presult",
            "        ret['comment'] = pcomment",
            "        return ret",
            "",
            "    if not os.path.isdir(name):",
            "        # The dir does not exist, make it",
            "        if not os.path.isdir(os.path.dirname(name)):",
            "            # The parent directory does not exist, create them",
            "            if makedirs:",
            "                # Make sure the drive is mapped before trying to create the",
            "                # path in windows",
            "                if salt.utils.is_windows():",
            "                    drive, path = os.path.splitdrive(name)",
            "                    if not os.path.isdir(drive):",
            "                        return _error(",
            "                            ret, 'Drive {0} is not mapped'.format(drive))",
            "                # Everything's good, create the path",
            "                __salt__['file.makedirs'](",
            "                    name, user=user, group=group, mode=dir_mode",
            "                )",
            "            else:",
            "                return _error(",
            "                    ret, 'No directory to create {0} in'.format(name))",
            "",
            "        __salt__['file.mkdir'](",
            "            name, user=user, group=group, mode=dir_mode",
            "        )",
            "        ret['changes'][name] = 'New Dir'",
            "",
            "    if not os.path.isdir(name):",
            "        return _error(ret, 'Failed to create directory {0}'.format(name))",
            "",
            "    # issue 32707: skip this __salt__['file.check_perms'] call if children_only == True",
            "    # Check permissions",
            "    if not children_only:",
            "        ret, perms = __salt__['file.check_perms'](name,",
            "                                                  ret,",
            "                                                  user,",
            "                                                  group,",
            "                                                  dir_mode,",
            "                                                  follow_symlinks)",
            "",
            "    errors = []",
            "    if recurse or clean:",
            "        # walk path only once and store the result",
            "        walk_l = list(_depth_limited_walk(name, max_depth))",
            "        # root: (dirs, files) structure, compatible for python2.6",
            "        walk_d = {}",
            "        for i in walk_l:",
            "            walk_d[i[0]] = (i[1], i[2])",
            "",
            "    recurse_set = None",
            "    if recurse:",
            "        try:",
            "            recurse_set = _get_recurse_set(recurse)",
            "        except (TypeError, ValueError) as exc:",
            "            ret['result'] = False",
            "            ret['comment'] = '{0}'.format(exc)",
            "            # NOTE: Should this be enough to stop the whole check altogether?",
            "    if recurse_set:",
            "        if 'user' in recurse_set:",
            "            if user:",
            "                uid = __salt__['file.user_to_uid'](user)",
            "                # file.user_to_uid returns '' if user does not exist. Above",
            "                # check for user is not fatal, so we need to be sure user",
            "                # exists.",
            "                if isinstance(uid, six.string_types):",
            "                    ret['result'] = False",
            "                    ret['comment'] = 'Failed to enforce ownership for ' \\",
            "                                     'user {0} (user does not ' \\",
            "                                     'exist)'.format(user)",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'] = 'user not specified, but configured as ' \\",
            "                                 'a target for recursive ownership ' \\",
            "                                 'management'",
            "        else:",
            "            user = None",
            "        if 'group' in recurse_set:",
            "            if group:",
            "                gid = __salt__['file.group_to_gid'](group)",
            "                # As above with user, we need to make sure group exists.",
            "                if isinstance(gid, six.string_types):",
            "                    ret['result'] = False",
            "                    ret['comment'] = 'Failed to enforce group ownership ' \\",
            "                                     'for group {0}'.format(group)",
            "            else:",
            "                ret['result'] = False",
            "                ret['comment'] = 'group not specified, but configured ' \\",
            "                                 'as a target for recursive ownership ' \\",
            "                                 'management'",
            "        else:",
            "            group = None",
            "",
            "        if 'mode' not in recurse_set:",
            "            file_mode = None",
            "            dir_mode = None",
            "",
            "        check_files = 'ignore_files' not in recurse_set",
            "        check_dirs = 'ignore_dirs' not in recurse_set",
            "",
            "        for root, dirs, files in walk_l:",
            "            if check_files:",
            "                for fn_ in files:",
            "                    full = os.path.join(root, fn_)",
            "                    try:",
            "                        ret, _ = __salt__['file.check_perms'](",
            "                            full,",
            "                            ret,",
            "                            user,",
            "                            group,",
            "                            file_mode,",
            "                            follow_symlinks)",
            "                    except CommandExecutionError as exc:",
            "                        if not exc.strerror.endswith('does not exist'):",
            "                            errors.append(exc.strerror)",
            "            if check_dirs:",
            "                for dir_ in dirs:",
            "                    full = os.path.join(root, dir_)",
            "                    try:",
            "                        ret, _ = __salt__['file.check_perms'](",
            "                            full,",
            "                            ret,",
            "                            user,",
            "                            group,",
            "                            dir_mode,",
            "                            follow_symlinks)",
            "                    except CommandExecutionError as exc:",
            "                        if not exc.strerror.endswith('does not exist'):",
            "                            errors.append(exc.strerror)",
            "",
            "    if clean:",
            "        keep = _gen_keep_files(name, require, walk_d)",
            "        log.debug('List of kept files when use file.directory with clean: %s',",
            "                  keep)",
            "        removed = _clean_dir(name, list(keep), exclude_pat)",
            "        if removed:",
            "            ret['changes']['removed'] = removed",
            "            ret['comment'] = 'Files cleaned from directory {0}'.format(name)",
            "",
            "    # issue 32707: reflect children_only selection in comments",
            "    if not ret['comment']:",
            "        if children_only:",
            "            ret['comment'] = 'Directory {0}/* updated'.format(name)",
            "        else:",
            "            ret['comment'] = 'Directory {0} updated'.format(name)",
            "",
            "    if __opts__['test']:",
            "        ret['comment'] = 'Directory {0} not updated'.format(name)",
            "    elif not ret['changes'] and ret['result']:",
            "        ret['comment'] = 'Directory {0} is in the correct state'.format(name)",
            "",
            "    if errors:",
            "        ret['result'] = False",
            "        ret['comment'] += '\\n\\nThe following errors were encountered:\\n'",
            "        for error in errors:",
            "            ret['comment'] += '\\n- {0}'.format(error)",
            "    return ret",
            "",
            "",
            "def recurse(name,",
            "            source,",
            "            clean=False,",
            "            require=None,",
            "            user=None,",
            "            group=None,",
            "            dir_mode=None,",
            "            file_mode=None,",
            "            sym_mode=None,",
            "            template=None,",
            "            context=None,",
            "            defaults=None,",
            "            include_empty=False,",
            "            backup='',",
            "            include_pat=None,",
            "            exclude_pat=None,",
            "            maxdepth=None,",
            "            keep_symlinks=False,",
            "            force_symlinks=False,",
            "            **kwargs):",
            "    '''",
            "    Recurse through a subdirectory on the master and copy said subdirectory",
            "    over to the specified path.",
            "",
            "    name",
            "        The directory to set the recursion in",
            "",
            "    source",
            "        The source directory, this directory is located on the salt master file",
            "        server and is specified with the salt:// protocol. If the directory is",
            "        located on the master in the directory named spam, and is called eggs,",
            "        the source string is salt://spam/eggs",
            "",
            "    clean",
            "        Make sure that only files that are set up by salt and required by this",
            "        function are kept. If this option is set then everything in this",
            "        directory will be deleted unless it is required.",
            "",
            "    require",
            "        Require other resources such as packages or files",
            "",
            "    user",
            "        The user to own the directory. This defaults to the user salt is",
            "        running as on the minion",
            "",
            "    group",
            "        The group ownership set for the directory. This defaults to the group",
            "        salt is running as on the minion. On Windows, this is ignored",
            "",
            "    dir_mode",
            "        The permissions mode to set on any directories created.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "    file_mode",
            "        The permissions mode to set on any files created.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "        .. versionchanged:: 2016.11.0",
            "            This option can be set to ``keep``, and Salt will keep the mode",
            "            from the Salt fileserver. This is only supported when the",
            "            ``source`` URL begins with ``salt://``, or for files local to the",
            "            minion. Because the ``source`` option cannot be used with any of",
            "            the ``contents`` options, setting the ``mode`` to ``keep`` is also",
            "            incompatible with the ``contents`` options.",
            "",
            "    sym_mode",
            "        The permissions mode to set on any symlink created.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "    template",
            "        If this setting is applied, the named templating engine will be used to",
            "        render the downloaded file. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "        .. note::",
            "",
            "            The template option is required when recursively applying templates.",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    include_empty",
            "        Set this to True if empty directories should also be created",
            "        (default is False)",
            "",
            "    backup",
            "        Overrides the default backup mode for all replaced files. See",
            "        :ref:`backup_mode documentation <file-state-backups>` for more details.",
            "",
            "    include_pat",
            "        When copying, include only this pattern from the source. Default",
            "        is glob match; if prefixed with 'E@', then regexp match.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "          - include_pat: hello*       :: glob matches 'hello01', 'hello02'",
            "                                         ... but not 'otherhello'",
            "          - include_pat: E@hello      :: regexp matches 'otherhello',",
            "                                         'hello01' ...",
            "",
            "    exclude_pat",
            "        Exclude this pattern from the source when copying. If both",
            "        `include_pat` and `exclude_pat` are supplied, then it will apply",
            "        conditions cumulatively. i.e. first select based on include_pat, and",
            "        then within that result apply exclude_pat.",
            "",
            "        Also, when 'clean=True', exclude this pattern from the removal",
            "        list and preserve in the destination.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "          - exclude_pat: APPDATA*               :: glob matches APPDATA.01,",
            "                                                   APPDATA.02,.. for exclusion",
            "          - exclude_pat: E@(APPDATA)|(TEMPDATA) :: regexp matches APPDATA",
            "                                                   or TEMPDATA for exclusion",
            "",
            "    maxdepth",
            "        When copying, only copy paths which are of depth `maxdepth` from the",
            "        source path.",
            "        Example:",
            "",
            "        .. code-block:: yaml",
            "",
            "          - maxdepth: 0      :: Only include files located in the source",
            "                                directory",
            "          - maxdepth: 1      :: Only include files located in the source",
            "                                or immediate subdirectories",
            "",
            "    keep_symlinks",
            "        Keep symlinks when copying from the source. This option will cause",
            "        the copy operation to terminate at the symlink. If desire behavior",
            "        similar to rsync, then set this to True.",
            "",
            "    force_symlinks",
            "        Force symlink creation. This option will force the symlink creation.",
            "        If a file or directory is obstructing symlink creation it will be",
            "        recursively removed so that symlink creation can proceed. This",
            "        option is usually not needed except in special circumstances.",
            "    '''",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(sdecode(name))",
            "",
            "    user = _test_owner(kwargs, user=user)",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'pchanges': {},",
            "        'result': True,",
            "        'comment': {}  # { path: [comment, ...] }",
            "    }",
            "",
            "    if 'mode' in kwargs:",
            "        ret['result'] = False",
            "        ret['comment'] = (",
            "            '\\'mode\\' is not allowed in \\'file.recurse\\'. Please use '",
            "            '\\'file_mode\\' and \\'dir_mode\\'.'",
            "        )",
            "        return ret",
            "",
            "    if any([x is not None for x in (dir_mode, file_mode, sym_mode)]) \\",
            "            and salt.utils.is_windows():",
            "        return _error(ret, 'mode management is not supported on Windows')",
            "",
            "    # Make sure that leading zeros stripped by YAML loader are added back",
            "    dir_mode = salt.utils.normalize_mode(dir_mode)",
            "",
            "    try:",
            "        keep_mode = file_mode.lower() == 'keep'",
            "        if keep_mode:",
            "            # We're not hard-coding the mode, so set it to None",
            "            file_mode = None",
            "    except AttributeError:",
            "        keep_mode = False",
            "",
            "    file_mode = salt.utils.normalize_mode(file_mode)",
            "",
            "    u_check = _check_user(user, group)",
            "    if u_check:",
            "        # The specified user or group do not exist",
            "        return _error(ret, u_check)",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    # expand source into source_list",
            "    source_list = _validate_str_list(source)",
            "",
            "    for idx, val in enumerate(source_list):",
            "        source_list[idx] = val.rstrip('/')",
            "",
            "    for precheck in source_list:",
            "        if not precheck.startswith('salt://'):",
            "            return _error(ret, ('Invalid source \\'{0}\\' '",
            "                                '(must be a salt:// URI)'.format(precheck)))",
            "",
            "    # Select the first source in source_list that exists",
            "    try:",
            "        source, source_hash = __salt__['file.source_list'](source_list, '', __env__)",
            "    except CommandExecutionError as exc:",
            "        ret['result'] = False",
            "        ret['comment'] = 'Recurse failed: {0}'.format(exc)",
            "        return ret",
            "",
            "    # Check source path relative to fileserver root, make sure it is a",
            "    # directory",
            "    srcpath, senv = salt.utils.url.parse(source)",
            "    if senv is None:",
            "        senv = __env__",
            "    master_dirs = __salt__['cp.list_master_dirs'](saltenv=senv)",
            "    if srcpath not in master_dirs \\",
            "            and not any((x for x in master_dirs",
            "                         if x.startswith(srcpath + '/'))):",
            "        ret['result'] = False",
            "        ret['comment'] = (",
            "            'The directory \\'{0}\\' does not exist on the salt fileserver '",
            "            'in saltenv \\'{1}\\''.format(srcpath, senv)",
            "        )",
            "        return ret",
            "",
            "    # Verify the target directory",
            "    if not os.path.isdir(name):",
            "        if os.path.exists(name):",
            "            # it is not a dir, but it exists - fail out",
            "            return _error(",
            "                ret, 'The path {0} exists and is not a directory'.format(name))",
            "        if not __opts__['test']:",
            "            __salt__['file.makedirs_perms'](name, user, group, dir_mode)",
            "",
            "    def add_comment(path, comment):",
            "        comments = ret['comment'].setdefault(path, [])",
            "        if isinstance(comment, six.string_types):",
            "            comments.append(comment)",
            "        else:",
            "            comments.extend(comment)",
            "",
            "    def merge_ret(path, _ret):",
            "        # Use the most \"negative\" result code (out of True, None, False)",
            "        if _ret['result'] is False or ret['result'] is True:",
            "            ret['result'] = _ret['result']",
            "",
            "        # Only include comments about files that changed",
            "        if _ret['result'] is not True and _ret['comment']:",
            "            add_comment(path, _ret['comment'])",
            "",
            "        if _ret['changes']:",
            "            ret['changes'][path] = _ret['changes']",
            "",
            "    def manage_file(path, source):",
            "        if clean and os.path.exists(path) and os.path.isdir(path):",
            "            _ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}",
            "            if __opts__['test']:",
            "                _ret['comment'] = 'Replacing directory {0} with a ' \\",
            "                                  'file'.format(path)",
            "                _ret['result'] = None",
            "                merge_ret(path, _ret)",
            "                return",
            "            else:",
            "                __salt__['file.remove'](path)",
            "                _ret['changes'] = {'diff': 'Replaced directory with a '",
            "                                           'new file'}",
            "                merge_ret(path, _ret)",
            "",
            "        # Conflicts can occur if some kwargs are passed in here",
            "        pass_kwargs = {}",
            "        faults = ['mode', 'makedirs']",
            "        for key in kwargs:",
            "            if key not in faults:",
            "                pass_kwargs[key] = kwargs[key]",
            "",
            "        _ret = managed(",
            "            path,",
            "            source=source,",
            "            user=user,",
            "            group=group,",
            "            mode='keep' if keep_mode else file_mode,",
            "            template=template,",
            "            makedirs=True,",
            "            context=context,",
            "            defaults=defaults,",
            "            backup=backup,",
            "            **pass_kwargs)",
            "        merge_ret(path, _ret)",
            "",
            "    def manage_directory(path):",
            "        if os.path.basename(path) == '..':",
            "            return",
            "        if clean and os.path.exists(path) and not os.path.isdir(path):",
            "            _ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}",
            "            if __opts__['test']:",
            "                _ret['comment'] = 'Replacing {0} with a directory'.format(path)",
            "                _ret['result'] = None",
            "                merge_ret(path, _ret)",
            "                return",
            "            else:",
            "                __salt__['file.remove'](path)",
            "                _ret['changes'] = {'diff': 'Replaced file with a directory'}",
            "                merge_ret(path, _ret)",
            "",
            "        _ret = directory(",
            "            path,",
            "            user=user,",
            "            group=group,",
            "            recurse=[],",
            "            dir_mode=dir_mode,",
            "            file_mode=None,",
            "            makedirs=True,",
            "            clean=False,",
            "            require=None)",
            "        merge_ret(path, _ret)",
            "",
            "    # Process symlinks and return the updated filenames list",
            "    def process_symlinks(filenames, symlinks):",
            "        for lname, ltarget in six.iteritems(symlinks):",
            "            if not salt.utils.check_include_exclude(",
            "                    os.path.relpath(lname, srcpath), include_pat, exclude_pat):",
            "                continue",
            "            srelpath = os.path.relpath(lname, srcpath)",
            "            # Check for max depth",
            "            if maxdepth is not None:",
            "                srelpieces = srelpath.split('/')",
            "                if not srelpieces[-1]:",
            "                    srelpieces = srelpieces[:-1]",
            "                if len(srelpieces) > maxdepth + 1:",
            "                    continue",
            "            # Check for all paths that begin with the symlink",
            "            # and axe it leaving only the dirs/files below it.",
            "            # This needs to use list() otherwise they reference",
            "            # the same list.",
            "            _filenames = list(filenames)",
            "            for filename in _filenames:",
            "                if filename.startswith(lname):",
            "                    log.debug('** skipping file ** {0}, it intersects a '",
            "                              'symlink'.format(filename))",
            "                    filenames.remove(filename)",
            "            # Create the symlink along with the necessary dirs.",
            "            # The dir perms/ownership will be adjusted later",
            "            # if needed",
            "            _ret = symlink(os.path.join(name, srelpath),",
            "                           ltarget,",
            "                           makedirs=True,",
            "                           force=force_symlinks,",
            "                           user=user,",
            "                           group=group,",
            "                           mode=sym_mode)",
            "            if not _ret:",
            "                continue",
            "            merge_ret(os.path.join(name, srelpath), _ret)",
            "            # Add the path to the keep set in case clean is set to True",
            "            keep.add(os.path.join(name, srelpath))",
            "        vdir.update(keep)",
            "        return filenames",
            "",
            "    keep = set()",
            "    vdir = set()",
            "    if not srcpath.endswith('/'):",
            "        # we're searching for things that start with this *directory*.",
            "        # use '/' since #master only runs on POSIX",
            "        srcpath = srcpath + '/'",
            "    fns_ = __salt__['cp.list_master'](senv, srcpath)",
            "    # If we are instructed to keep symlinks, then process them.",
            "    if keep_symlinks:",
            "        # Make this global so that emptydirs can use it if needed.",
            "        symlinks = __salt__['cp.list_master_symlinks'](senv, srcpath)",
            "        fns_ = process_symlinks(fns_, symlinks)",
            "    for fn_ in fns_:",
            "        if not fn_.strip():",
            "            continue",
            "",
            "        # fn_ here is the absolute (from file_roots) source path of",
            "        # the file to copy from; it is either a normal file or an",
            "        # empty dir(if include_empty==true).",
            "",
            "        relname = sdecode(os.path.relpath(fn_, srcpath))",
            "        if relname.startswith('..'):",
            "            continue",
            "",
            "        # Check for maxdepth of the relative path",
            "        if maxdepth is not None:",
            "            # Since paths are all master, just use POSIX separator",
            "            relpieces = relname.split('/')",
            "            # Handle empty directories (include_empty==true) by removing the",
            "            # the last piece if it is an empty string",
            "            if not relpieces[-1]:",
            "                relpieces = relpieces[:-1]",
            "            if len(relpieces) > maxdepth + 1:",
            "                continue",
            "",
            "        # Check if it is to be excluded. Match only part of the path",
            "        # relative to the target directory",
            "        if not salt.utils.check_include_exclude(",
            "                relname, include_pat, exclude_pat):",
            "            continue",
            "        dest = os.path.join(name, relname)",
            "        dirname = os.path.dirname(dest)",
            "        keep.add(dest)",
            "",
            "        if dirname not in vdir:",
            "            # verify the directory perms if they are set",
            "            manage_directory(dirname)",
            "            vdir.add(dirname)",
            "",
            "        src = salt.utils.url.create(fn_, saltenv=senv)",
            "        manage_file(dest, src)",
            "",
            "    if include_empty:",
            "        mdirs = __salt__['cp.list_master_dirs'](senv, srcpath)",
            "        for mdir in mdirs:",
            "            if not salt.utils.check_include_exclude(",
            "                    os.path.relpath(mdir, srcpath), include_pat, exclude_pat):",
            "                continue",
            "            mdest = os.path.join(name, os.path.relpath(mdir, srcpath))",
            "            # Check for symlinks that happen to point to an empty dir.",
            "            if keep_symlinks:",
            "                islink = False",
            "                for link in symlinks:",
            "                    if mdir.startswith(link, 0):",
            "                        log.debug('** skipping empty dir ** {0}, it intersects'",
            "                                  ' a symlink'.format(mdir))",
            "                        islink = True",
            "                        break",
            "                if islink:",
            "                    continue",
            "",
            "            manage_directory(mdest)",
            "            keep.add(mdest)",
            "",
            "    keep = list(keep)",
            "    if clean:",
            "        # TODO: Use directory(clean=True) instead",
            "        keep += _gen_keep_files(name, require)",
            "        removed = _clean_dir(name, list(keep), exclude_pat)",
            "        if removed:",
            "            if __opts__['test']:",
            "                if ret['result']:",
            "                    ret['result'] = None",
            "                add_comment('removed', removed)",
            "            else:",
            "                ret['changes']['removed'] = removed",
            "",
            "    # Flatten comments until salt command line client learns",
            "    # to display structured comments in a readable fashion",
            "    ret['comment'] = '\\n'.join(u'\\n#### {0} ####\\n{1}'.format(",
            "        k, v if isinstance(v, six.string_types) else '\\n'.join(v)",
            "    ) for (k, v) in six.iteritems(ret['comment'])).strip()",
            "",
            "    if not ret['comment']:",
            "        ret['comment'] = 'Recursively updated {0}'.format(name)",
            "",
            "    if not ret['changes'] and ret['result']:",
            "        ret['comment'] = 'The directory {0} is in the correct state'.format(",
            "            name",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def retention_schedule(name, retain, strptime_format=None, timezone=None):",
            "    '''",
            "    Apply retention scheduling to backup storage directory.",
            "",
            "    .. versionadded:: 2016.11.0",
            "",
            "    :param name:",
            "        The filesystem path to the directory containing backups to be managed.",
            "",
            "    :param retain:",
            "        Delete the backups, except for the ones we want to keep.",
            "        The N below should be an integer but may also be the special value of ``all``,",
            "        which keeps all files matching the criteria.",
            "        All of the retain options default to None,",
            "        which means to not keep files based on this criteria.",
            "",
            "        :most_recent N:",
            "            Keep the most recent N files.",
            "",
            "        :first_of_hour N:",
            "            For the last N hours from now, keep the first file after the hour.",
            "",
            "        :first_of_day N:",
            "            For the last N days from now, keep the first file after midnight.",
            "            See also ``timezone``.",
            "",
            "        :first_of_week N:",
            "            For the last N weeks from now, keep the first file after Sunday midnight.",
            "",
            "        :first_of_month N:",
            "            For the last N months from now, keep the first file after the start of the month.",
            "",
            "        :first_of_year N:",
            "            For the last N years from now, keep the first file after the start of the year.",
            "",
            "    :param strptime_format:",
            "        A python strptime format string used to first match the filenames of backups",
            "        and then parse the filename to determine the datetime of the file.",
            "        https://docs.python.org/2/library/datetime.html#datetime.datetime.strptime",
            "        Defaults to None, which considers all files in the directory to be backups eligible for deletion",
            "        and uses ``os.path.getmtime()`` to determine the datetime.",
            "",
            "    :param timezone:",
            "        The timezone to use when determining midnight.",
            "        This is only used when datetime is pulled from ``os.path.getmtime()``.",
            "        Defaults to ``None`` which uses the timezone from the locale.",
            "",
            "    .. code-block: yaml",
            "",
            "        /var/backups/example_directory:",
            "          file.retention_schedule:",
            "            - retain:",
            "                most_recent: 5",
            "                first_of_hour: 4",
            "                first_of_day: 7",
            "                first_of_week: 6    # NotImplemented yet.",
            "                first_of_month: 6",
            "                first_of_year: all",
            "            - strptime_format: example_name_%Y%m%dT%H%M%S.tar.bz2",
            "            - timezone: None",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    ret = {'name': name,",
            "           'changes': {'retained': [], 'deleted': [], 'ignored': []},",
            "           'pchanges': {'retained': [], 'deleted': [], 'ignored': []},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.retention_schedule')",
            "    if not os.path.isdir(name):",
            "        return _error(ret, 'Name provided to file.retention must be a directory')",
            "",
            "    # get list of files in directory",
            "    all_files = __salt__['file.readdir'](name)",
            "",
            "    # if strptime_format is set, filter through the list to find names which parse and get their datetimes.",
            "    beginning_of_unix_time = datetime(1970, 1, 1)",
            "",
            "    def get_file_time_from_strptime(f):",
            "        try:",
            "            ts = datetime.strptime(f, strptime_format)",
            "            ts_epoch = salt.utils.total_seconds(ts - beginning_of_unix_time)",
            "            return (ts, ts_epoch)",
            "        except ValueError:",
            "            # Files which don't match the pattern are not relevant files.",
            "            return (None, None)",
            "",
            "    def get_file_time_from_mtime(f):",
            "        lstat = __salt__['file.lstat'](os.path.join(name, f))",
            "        if lstat:",
            "            mtime = lstat['st_mtime']",
            "            return (datetime.fromtimestamp(mtime, timezone), mtime)",
            "        else:   # maybe it was deleted since we did the readdir?",
            "            return (None, None)",
            "",
            "    get_file_time = get_file_time_from_strptime if strptime_format else get_file_time_from_mtime",
            "",
            "    # data structures are nested dicts:",
            "    # files_by_ymd = year.month.day.hour.unixtime: filename",
            "    # files_by_y_week_dow = year.week_of_year.day_of_week.unixtime: filename",
            "    # http://the.randomengineer.com/2015/04/28/python-recursive-defaultdict/",
            "    # TODO: move to an ordered dict model and reduce the number of sorts in the rest of the code?",
            "    def dict_maker():",
            "        return defaultdict(dict_maker)",
            "    files_by_ymd = dict_maker()",
            "    files_by_y_week_dow = dict_maker()",
            "    relevant_files = set()",
            "    ignored_files = set()",
            "    for f in all_files:",
            "        ts, ts_epoch = get_file_time(f)",
            "        if ts:",
            "            files_by_ymd[ts.year][ts.month][ts.day][ts.hour][ts_epoch] = f",
            "            week_of_year = ts.isocalendar()[1]",
            "            files_by_y_week_dow[ts.year][week_of_year][ts.weekday()][ts_epoch] = f",
            "            relevant_files.add(f)",
            "        else:",
            "            ignored_files.add(f)",
            "",
            "    # This is tightly coupled with the file_with_times data-structure above.",
            "    RETAIN_TO_DEPTH = {",
            "        'first_of_year': 1,",
            "        'first_of_month': 2,",
            "        'first_of_day': 3,",
            "        'first_of_hour': 4,",
            "        'most_recent': 5,",
            "    }",
            "",
            "    def get_first(fwt):",
            "        if isinstance(fwt, dict):",
            "            first_sub_key = sorted(fwt.keys())[0]",
            "            return get_first(fwt[first_sub_key])",
            "        else:",
            "            return set([fwt, ])",
            "",
            "    def get_first_n_at_depth(fwt, depth, n):",
            "        if depth <= 0:",
            "            return get_first(fwt)",
            "        else:",
            "            result_set = set()",
            "            for k in sorted(fwt.keys(), reverse=True):",
            "                needed = n - len(result_set)",
            "                if needed < 1:",
            "                    break",
            "                result_set |= get_first_n_at_depth(fwt[k], depth - 1, needed)",
            "            return result_set",
            "",
            "    # for each retain criteria, add filenames which match the criteria to the retain set.",
            "    retained_files = set()",
            "    for retention_rule, keep_count in retain.items():",
            "        # This is kind of a hack, since 'all' should really mean all,",
            "        # but I think it's a large enough number that even modern filesystems would",
            "        # choke if they had this many files in a single directory.",
            "        keep_count = sys.maxsize if 'all' == keep_count else int(keep_count)",
            "        if 'first_of_week' == retention_rule:",
            "            first_of_week_depth = 2   # year + week_of_year = 2",
            "            # I'm adding 1 to keep_count below because it fixed an off-by one",
            "            # issue in the tests. I don't understand why, and that bothers me.",
            "            retained_files |= get_first_n_at_depth(files_by_y_week_dow,",
            "                                                   first_of_week_depth,",
            "                                                   keep_count + 1)",
            "        else:",
            "            retained_files |= get_first_n_at_depth(files_by_ymd,",
            "                                                   RETAIN_TO_DEPTH[retention_rule],",
            "                                                   keep_count)",
            "",
            "    deletable_files = list(relevant_files - retained_files)",
            "    deletable_files.sort(reverse=True)",
            "    changes = {",
            "            'retained': sorted(list(retained_files), reverse=True),",
            "            'deleted': deletable_files,",
            "            'ignored': sorted(list(ignored_files), reverse=True),",
            "        }",
            "    ret['pchanges'] = changes",
            "",
            "    # TODO: track and report how much space was / would be reclaimed",
            "    if __opts__['test']:",
            "        ret['comment'] = '{0} backups would have been removed from {1}.\\n'.format(len(deletable_files), name)",
            "        if deletable_files:",
            "            ret['result'] = None",
            "    else:",
            "        for f in deletable_files:",
            "            __salt__['file.remove'](os.path.join(name, f))",
            "        ret['comment'] = '{0} backups were removed from {1}.\\n'.format(len(deletable_files), name)",
            "        ret['changes'] = changes",
            "",
            "    return ret",
            "",
            "",
            "def line(name, content, match=None, mode=None, location=None,",
            "         before=None, after=None, show_changes=True, backup=False,",
            "         quiet=False, indent=True, create=False, user=None,",
            "         group=None, file_mode=None):",
            "    '''",
            "    Line-based editing of a file.",
            "",
            "    .. versionadded:: 2015.8.0",
            "",
            "    name",
            "        Filesystem path to the file to be edited.",
            "",
            "    content",
            "        Content of the line.",
            "",
            "    match",
            "        Match the target line for an action by",
            "        a fragment of a string or regular expression.",
            "",
            "        If neither ``before`` nor ``after`` are provided, and ``match``",
            "        is also ``None``, match becomes the ``content`` value.",
            "",
            "    mode",
            "        Defines how to edit a line. One of the following options is",
            "        required:",
            "",
            "        - ensure",
            "            If line does not exist, it will be added.",
            "        - replace",
            "            If line already exists, it will be replaced.",
            "        - delete",
            "            Delete the line, once found.",
            "        - insert",
            "            Insert a line.",
            "",
            "        .. note::",
            "",
            "            If ``mode=insert`` is used, at least one of the following",
            "            options must also be defined: ``location``, ``before``, or",
            "            ``after``. If ``location`` is used, it takes precedence",
            "            over the other two options.",
            "",
            "    location",
            "        Defines where to place content in the line. Note this option is only",
            "        used when ``mode=insert`` is specified. If a location is passed in, it",
            "        takes precedence over both the ``before`` and ``after`` kwargs. Valid",
            "        locations are:",
            "",
            "        - start",
            "            Place the content at the beginning of the file.",
            "        - end",
            "            Place the content at the end of the file.",
            "",
            "    before",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    after",
            "        Regular expression or an exact case-sensitive fragment of the string.",
            "        This option is only used when either the ``ensure`` or ``insert`` mode",
            "        is defined.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file.",
            "        If ``False`` return a boolean if any changes were made.",
            "        Default is ``True``",
            "",
            "        .. note::",
            "            Using this option will store two copies of the file in-memory",
            "            (the original version and the edited version) in order to generate the diff.",
            "",
            "    backup",
            "        Create a backup of the original file with the extension:",
            "        \"Year-Month-Day-Hour-Minutes-Seconds\".",
            "",
            "    quiet",
            "        Do not raise any exceptions. E.g. ignore the fact that the file that is",
            "        tried to be edited does not exist and nothing really happened.",
            "",
            "    indent",
            "        Keep indentation with the previous line. This option is not considered when",
            "        the ``delete`` mode is specified.",
            "",
            "    :param create:",
            "        Create an empty file if doesn't exists.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    :param user:",
            "        The user to own the file, this defaults to the user salt is running as",
            "        on the minion.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    :param group:",
            "        The group ownership set for the file, this defaults to the group salt",
            "        is running as on the minion On Windows, this is ignored.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    :param file_mode:",
            "        The permissions to set on this file, aka 644, 0775, 4664. Not supported",
            "        on Windows.",
            "",
            "        .. versionadded:: 2016.11.0",
            "",
            "    If an equal sign (``=``) appears in an argument to a Salt command, it is",
            "    interpreted as a keyword argument in the format of ``key=val``. That",
            "    processing can be bypassed in order to pass an equal sign through to the",
            "    remote shell command by manually specifying the kwarg:",
            "",
            "    .. code-block: yaml",
            "",
            "       update_config:",
            "         file.line:",
            "           - name: /etc/myconfig.conf",
            "           - mode: ensure",
            "           - content: my key = my value",
            "           - before: somekey.*?",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.line')",
            "",
            "    managed(name, create=create, user=user, group=group, mode=file_mode)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    changes = __salt__['file.line'](",
            "        name, content, match=match, mode=mode, location=location,",
            "        before=before, after=after, show_changes=show_changes,",
            "        backup=backup, quiet=quiet, indent=indent)",
            "    if changes:",
            "        ret['pchanges']['diff'] = changes",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Changes would be made:\\ndiff:\\n{0}'.format(changes)",
            "        else:",
            "            ret['result'] = True",
            "            ret['comment'] = 'Changes were made'",
            "            ret['changes'] = {'diff': changes}",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'No changes needed to be made'",
            "",
            "    return ret",
            "",
            "",
            "def replace(name,",
            "            pattern,",
            "            repl,",
            "            count=0,",
            "            flags=8,",
            "            bufsize=1,",
            "            append_if_not_found=False,",
            "            prepend_if_not_found=False,",
            "            not_found_content=None,",
            "            backup='.bak',",
            "            show_changes=True,",
            "            ignore_if_missing=False):",
            "    r'''",
            "    Maintain an edit in a file.",
            "",
            "    .. versionadded:: 0.17.0",
            "",
            "    name",
            "        Filesystem path to the file to be edited. If a symlink is specified, it",
            "        will be resolved to its target.",
            "",
            "    pattern",
            "        A regular expression, to be matched using Python's",
            "        :py:func:`~re.search`.",
            "",
            "    repl",
            "        The replacement text",
            "",
            "    count",
            "        Maximum number of pattern occurrences to be replaced.  Defaults to 0.",
            "        If count is a positive integer n, no more than n occurrences will be",
            "        replaced, otherwise all occurrences will be replaced.",
            "",
            "    flags",
            "        A list of flags defined in the :ref:`re module documentation",
            "        <contents-of-module-re>`. Each list item should be a string that will",
            "        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',",
            "        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value",
            "        corresponding to the XOR (``|``) of all the desired flags. Defaults to",
            "        ``8`` (which equates to ``['MULTILINE']``).",
            "",
            "        .. note::",
            "",
            "            ``file.replace`` reads the entire file as a string to support",
            "            multiline regex patterns. Therefore, when using anchors such as",
            "            ``^`` or ``$`` in the pattern, those anchors may be relative to",
            "            the line OR relative to the file. The default for ``file.replace``",
            "            is to treat anchors as relative to the line, which is implemented",
            "            by setting the default value of ``flags`` to ``['MULTILINE']``.",
            "            When overriding the default value for ``flags``, if",
            "            ``'MULTILINE'`` is not present then anchors will be relative to",
            "            the file. If the desired behavior is for anchors to be relative to",
            "            the line, then simply add ``'MULTILINE'`` to the list of flags.",
            "",
            "    bufsize",
            "        How much of the file to buffer into memory at once. The default value",
            "        ``1`` processes one line at a time. The special value ``file`` may be",
            "        specified which will read the entire file into memory before",
            "        processing.",
            "",
            "    append_if_not_found : False",
            "        If set to ``True``, and pattern is not found, then the content will be",
            "        appended to the file.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    prepend_if_not_found : False",
            "        If set to ``True`` and pattern is not found, then the content will be",
            "        prepended to the file.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    not_found_content",
            "        Content to use for append/prepend if not found. If ``None`` (default),",
            "        uses ``repl``. Useful when ``repl`` uses references to group in",
            "        pattern.",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    backup",
            "        The file extension to use for a backup of the file before editing. Set",
            "        to ``False`` to skip making a backup.",
            "",
            "    show_changes : True",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made. Returns a boolean or a",
            "        string.",
            "",
            "        .. note:",
            "            Using this option will store two copies of the file in memory (the",
            "            original version and the edited version) in order to generate the",
            "            diff. This may not normally be a concern, but could impact",
            "            performance if used with large files.",
            "",
            "    ignore_if_missing : False",
            "        .. versionadded:: 2016.3.4",
            "",
            "        Controls what to do if the file is missing. If set to ``False``, the",
            "        state will display an error raised by the execution module. If set to",
            "        ``True``, the state will simply report no changes.",
            "",
            "    For complex regex patterns, it can be useful to avoid the need for complex",
            "    quoting and escape sequences by making use of YAML's multiline string",
            "    syntax.",
            "",
            "    .. code-block:: yaml",
            "",
            "        complex_search_and_replace:",
            "          file.replace:",
            "            # <...snip...>",
            "            - pattern: |",
            "                CentOS \\(2.6.32[^\\n]+\\n\\s+root[^\\n]+\\n\\)+",
            "",
            "    .. note::",
            "",
            "       When using YAML multiline string syntax in ``pattern:``, make sure to",
            "       also use that syntax in the ``repl:`` part, or you might loose line",
            "       feeds.",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': True,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.replace')",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        if ignore_if_missing and 'file not found' in check_msg:",
            "            ret['comment'] = 'No changes needed to be made'",
            "            return ret",
            "        else:",
            "            return _error(ret, check_msg)",
            "",
            "    changes = __salt__['file.replace'](name,",
            "                                       pattern,",
            "                                       repl,",
            "                                       count=count,",
            "                                       flags=flags,",
            "                                       bufsize=bufsize,",
            "                                       append_if_not_found=append_if_not_found,",
            "                                       prepend_if_not_found=prepend_if_not_found,",
            "                                       not_found_content=not_found_content,",
            "                                       backup=backup,",
            "                                       dry_run=__opts__['test'],",
            "                                       show_changes=show_changes,",
            "                                       ignore_if_missing=ignore_if_missing)",
            "",
            "    if changes:",
            "        ret['pchanges']['diff'] = changes",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Changes would have been made:\\ndiff:\\n{0}'.format(changes)",
            "        else:",
            "            ret['result'] = True",
            "            ret['comment'] = 'Changes were made'",
            "            ret['changes'] = {'diff': changes}",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'No changes needed to be made'",
            "",
            "    return ret",
            "",
            "",
            "def blockreplace(",
            "        name,",
            "        marker_start='#-- start managed zone --',",
            "        marker_end='#-- end managed zone --',",
            "        source=None,",
            "        source_hash=None,",
            "        template='jinja',",
            "        sources=None,",
            "        source_hashes=None,",
            "        defaults=None,",
            "        context=None,",
            "        content='',",
            "        append_if_not_found=False,",
            "        prepend_if_not_found=False,",
            "        backup='.bak',",
            "        show_changes=True):",
            "    '''",
            "    Maintain an edit in a file in a zone delimited by two line markers",
            "",
            "    .. versionadded:: 2014.1.0",
            "",
            "    A block of content delimited by comments can help you manage several lines",
            "    entries without worrying about old entries removal. This can help you",
            "    maintaining an un-managed file containing manual edits.",
            "    Note: this function will store two copies of the file in-memory",
            "    (the original version and the edited version) in order to detect changes",
            "    and only edit the targeted file if necessary.",
            "",
            "    name",
            "        Filesystem path to the file to be edited",
            "",
            "    marker_start",
            "        The line content identifying a line as the start of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output",
            "",
            "    marker_end",
            "        The line content identifying a line as the end of the content block.",
            "        Note that the whole line containing this marker will be considered, so",
            "        whitespace or extra content before or after the marker is included in",
            "        final output. Note: you can use file.accumulated and target this state.",
            "        All accumulated data dictionaries content will be added as new lines in",
            "        the content",
            "",
            "    content",
            "        The content to be used between the two lines identified by",
            "        ``marker_start`` and ``marker_end``",
            "",
            "    source",
            "        The source file to download to the minion, this source file can be",
            "        hosted on either the salt master server, or on an HTTP or FTP server.",
            "        Both HTTPS and HTTP are supported as well as downloading directly",
            "        from Amazon S3 compatible URLs with both pre-configured and automatic",
            "        IAM credentials. (see s3.get state documentation)",
            "        File retrieval from Openstack Swift object storage is supported via",
            "        swift://container/object_path URLs, see swift.get documentation.",
            "        For files hosted on the salt file server, if the file is located on",
            "        the master in the directory named spam, and is called eggs, the source",
            "        string is salt://spam/eggs. If source is left blank or None",
            "        (use ~ in YAML), the file will be created as an empty file and",
            "        the content will not be managed. This is also the case when a file",
            "        already exists and the source is undefined; the contents of the file",
            "        will not be changed or managed.",
            "",
            "        If the file is hosted on a HTTP or FTP server then the source_hash",
            "        argument is also required.",
            "",
            "        A list of sources can also be passed in to provide a default source and",
            "        a set of fallbacks. The first source in the list that is found to exist",
            "        will be used and subsequent entries in the list will be ignored.",
            "",
            "        .. code-block:: yaml",
            "",
            "            file_override_example:",
            "              file.blockreplace:",
            "                - name: /etc/example.conf",
            "                - source:",
            "                  - salt://file_that_does_not_exist",
            "                  - salt://file_that_exists",
            "",
            "    source_hash",
            "        This can be one of the following:",
            "            1. a source hash string",
            "            2. the URI of a file that contains source hash strings",
            "",
            "        The function accepts the first encountered long unbroken alphanumeric",
            "        string of correct length as a valid hash, in order from most secure to",
            "        least secure:",
            "",
            "        .. code-block:: text",
            "",
            "            Type    Length",
            "            ======  ======",
            "            sha512     128",
            "            sha384      96",
            "            sha256      64",
            "            sha224      56",
            "            sha1        40",
            "            md5         32",
            "",
            "        See the ``source_hash`` parameter description for :mod:`file.managed",
            "        <salt.states.file.managed>` function for more details and examples.",
            "",
            "    template",
            "        The named templating engine will be used to render the downloaded file.",
            "        Defaults to ``jinja``. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    append_if_not_found",
            "        If markers are not found and set to True then the markers and content",
            "        will be appended to the file. Default is ``False``",
            "",
            "    prepend_if_not_found",
            "        If markers are not found and set to True then the markers and content",
            "        will be prepended to the file. Default is ``False``",
            "",
            "    backup",
            "        The file extension to use for a backup of the file if any edit is made.",
            "        Set this to ``False`` to skip making a backup.",
            "",
            "    dry_run",
            "        Don't make any edits to the file",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made",
            "",
            "    Example of usage with an accumulator and with a variable:",
            "",
            "    .. code-block:: yaml",
            "",
            "        {% set myvar = 42 %}",
            "        hosts-config-block-{{ myvar }}:",
            "          file.blockreplace:",
            "            - name: /etc/hosts",
            "            - marker_start: \"# START managed zone {{ myvar }} -DO-NOT-EDIT-\"",
            "            - marker_end: \"# END managed zone {{ myvar }} --\"",
            "            - content: 'First line of content'",
            "            - append_if_not_found: True",
            "            - backup: '.bak'",
            "            - show_changes: True",
            "",
            "        hosts-config-block-{{ myvar }}-accumulated1:",
            "          file.accumulated:",
            "            - filename: /etc/hosts",
            "            - name: my-accumulator-{{ myvar }}",
            "            - text: \"text 2\"",
            "            - require_in:",
            "              - file: hosts-config-block-{{ myvar }}",
            "",
            "        hosts-config-block-{{ myvar }}-accumulated2:",
            "          file.accumulated:",
            "            - filename: /etc/hosts",
            "            - name: my-accumulator-{{ myvar }}",
            "            - text: |",
            "                 text 3",
            "                 text 4",
            "            - require_in:",
            "              - file: hosts-config-block-{{ myvar }}",
            "",
            "    will generate and maintain a block of content in ``/etc/hosts``:",
            "",
            "    .. code-block:: text",
            "",
            "        # START managed zone 42 -DO-NOT-EDIT-",
            "        First line of content",
            "        text 2",
            "        text 3",
            "        text 4",
            "        # END managed zone 42 --",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.blockreplace')",
            "",
            "    if sources is None:",
            "        sources = []",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    (ok_, err, sl_) = _unify_sources_and_hashes(source=source,",
            "                                                source_hash=source_hash,",
            "                                                sources=sources,",
            "                                                source_hashes=source_hashes)",
            "    if not ok_:",
            "        return _error(ret, err)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    accum_data, accum_deps = _load_accumulators()",
            "    if name in accum_data:",
            "        accumulator = accum_data[name]",
            "        # if we have multiple accumulators for a file, only apply the one",
            "        # required at a time",
            "        deps = accum_deps.get(name, [])",
            "        filtered = [a for a in deps if",
            "                    __low__['__id__'] in deps[a] and a in accumulator]",
            "        if not filtered:",
            "            filtered = [a for a in accumulator]",
            "        for acc in filtered:",
            "            acc_content = accumulator[acc]",
            "            for line in acc_content:",
            "                if content == '':",
            "                    content = line",
            "                else:",
            "                    content += \"\\n\" + line",
            "",
            "    if sl_:",
            "        tmpret = _get_template_texts(source_list=sl_,",
            "                                     template=template,",
            "                                     defaults=defaults,",
            "                                     context=context)",
            "        if not tmpret['result']:",
            "            return tmpret",
            "        text = tmpret['data']",
            "",
            "        for index, item in enumerate(text):",
            "            content += str(item)",
            "",
            "    changes = __salt__['file.blockreplace'](",
            "        name,",
            "        marker_start,",
            "        marker_end,",
            "        content=content,",
            "        append_if_not_found=append_if_not_found,",
            "        prepend_if_not_found=prepend_if_not_found,",
            "        backup=backup,",
            "        dry_run=__opts__['test'],",
            "        show_changes=show_changes",
            "    )",
            "",
            "    if changes:",
            "        ret['pchanges'] = {'diff': changes}",
            "        if __opts__['test']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Changes would be made'",
            "        else:",
            "            ret['changes'] = {'diff': changes}",
            "            ret['result'] = True",
            "            ret['comment'] = 'Changes were made'",
            "    else:",
            "        ret['result'] = True",
            "        ret['comment'] = 'No changes needed to be made'",
            "",
            "    return ret",
            "",
            "",
            "def comment(name, regex, char='#', backup='.bak'):",
            "    '''",
            "    Comment out specified lines in a file.",
            "",
            "    name",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be commented;",
            "        this pattern will be wrapped in parenthesis and will move any",
            "        preceding/trailing ``^`` or ``$`` characters outside the parenthesis",
            "        (e.g., the pattern ``^foo$`` will be rewritten as ``^(foo)$``)",
            "        Note that you _need_ the leading ^, otherwise each time you run",
            "        highstate, another comment char will be inserted.",
            "    char : ``#``",
            "        The character to be inserted at the beginning of a line in order to",
            "        comment it out",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension",
            "",
            "        .. warning::",
            "",
            "            This backup will be overwritten each time ``sed`` / ``comment`` /",
            "            ``uncomment`` is called. Meaning the backup will only be useful",
            "            after the first invocation.",
            "",
            "        Set to False/None to not keep a backup.",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/fstab:",
            "          file.comment:",
            "            - regex: ^bind 127.0.0.1",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.comment')",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    unanchor_regex = regex.lstrip('^').rstrip('$')",
            "    comment_regex = char + unanchor_regex",
            "",
            "    # Check if the line is already commented",
            "    if __salt__['file.search'](name, comment_regex, multiline=True):",
            "        commented = True",
            "    else:",
            "        commented = False",
            "",
            "    # Make sure the pattern appears in the file before continuing",
            "    if commented or not __salt__['file.search'](name, regex, multiline=True):",
            "        if __salt__['file.search'](name, unanchor_regex, multiline=True):",
            "            ret['comment'] = 'Pattern already commented'",
            "            ret['result'] = True",
            "            return ret",
            "        else:",
            "            return _error(ret, '{0}: Pattern not found'.format(unanchor_regex))",
            "",
            "    ret['pchanges'][name] = 'updated'",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "        ret['result'] = None",
            "        return ret",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.readlines()",
            "",
            "    # Perform the edit",
            "    __salt__['file.comment_line'](name, regex, char, True, backup)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.readlines()",
            "",
            "    # Check the result",
            "    ret['result'] = __salt__['file.search'](name, unanchor_regex, multiline=True)",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                ''.join(difflib.unified_diff(slines, nlines))",
            "            )",
            "",
            "    if ret['result']:",
            "        ret['comment'] = 'Commented lines successfully'",
            "    else:",
            "        ret['comment'] = 'Expected commented lines not found'",
            "",
            "    return ret",
            "",
            "",
            "def uncomment(name, regex, char='#', backup='.bak'):",
            "    '''",
            "    Uncomment specified commented lines in a file",
            "",
            "    name",
            "        The full path to the file to be edited",
            "    regex",
            "        A regular expression used to find the lines that are to be uncommented.",
            "        This regex should not include the comment character. A leading ``^``",
            "        character will be stripped for convenience (for easily switching",
            "        between comment() and uncomment()).  The regex will be searched for",
            "        from the beginning of the line, ignoring leading spaces (we prepend",
            "        '^[ \\\\t]*')",
            "    char : ``#``",
            "        The character to remove in order to uncomment a line",
            "    backup : ``.bak``",
            "        The file will be backed up before edit with this file extension;",
            "",
            "        .. warning::",
            "",
            "            This backup will be overwritten each time ``sed`` / ``comment`` /",
            "            ``uncomment`` is called. Meaning the backup will only be useful",
            "            after the first invocation.",
            "",
            "        Set to False/None to not keep a backup.",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/adduser.conf:",
            "          file.uncomment:",
            "            - regex: EXTRA_GROUPS",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.uncomment')",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "",
            "    # Make sure the pattern appears in the file",
            "    if __salt__['file.search'](",
            "            name,",
            "            '^[ \\t]*{0}'.format(regex.lstrip('^')),",
            "            multiline=True):",
            "        ret['comment'] = 'Pattern already uncommented'",
            "        ret['result'] = True",
            "        return ret",
            "    elif __salt__['file.search'](",
            "            name,",
            "            '{0}[ \\t]*{1}'.format(char, regex.lstrip('^')),",
            "            multiline=True):",
            "        # Line exists and is commented",
            "        pass",
            "    else:",
            "        return _error(ret, '{0}: Pattern not found'.format(regex))",
            "",
            "    ret['pchanges'][name] = 'updated'",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "        ret['result'] = None",
            "        return ret",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.readlines()",
            "",
            "    # Perform the edit",
            "    __salt__['file.comment_line'](name, regex, char, False, backup)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.readlines()",
            "",
            "    # Check the result",
            "    ret['result'] = __salt__['file.search'](",
            "        name,",
            "        '^[ \\t]*{0}'.format(regex.lstrip('^')),",
            "        multiline=True",
            "    )",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                ''.join(difflib.unified_diff(slines, nlines))",
            "            )",
            "",
            "    if ret['result']:",
            "        ret['comment'] = 'Uncommented lines successfully'",
            "    else:",
            "        ret['comment'] = 'Expected uncommented lines not found'",
            "",
            "    return ret",
            "",
            "",
            "def append(name,",
            "           text=None,",
            "           makedirs=False,",
            "           source=None,",
            "           source_hash=None,",
            "           template='jinja',",
            "           sources=None,",
            "           source_hashes=None,",
            "           defaults=None,",
            "           context=None,",
            "           ignore_whitespace=True):",
            "    '''",
            "    Ensure that some text appears at the end of a file.",
            "",
            "    The text will not be appended if it already exists in the file.",
            "    A single string of text or a list of strings may be appended.",
            "",
            "    name",
            "        The location of the file to append to.",
            "",
            "    text",
            "        The text to be appended, which can be a single string or a list",
            "        of strings.",
            "",
            "    makedirs",
            "        If the file is located in a path without a parent directory,",
            "        then the state will fail. If makedirs is set to True, then",
            "        the parent directories will be created to facilitate the",
            "        creation of the named file. Defaults to False.",
            "",
            "    source",
            "        A single source file to append. This source file can be hosted on either",
            "        the salt master server, or on an HTTP or FTP server. Both HTTPS and",
            "        HTTP are supported as well as downloading directly from Amazon S3",
            "        compatible URLs with both pre-configured and automatic IAM credentials",
            "        (see s3.get state documentation). File retrieval from Openstack Swift",
            "        object storage is supported via swift://container/object_path URLs",
            "        (see swift.get documentation).",
            "",
            "        For files hosted on the salt file server, if the file is located on",
            "        the master in the directory named spam, and is called eggs, the source",
            "        string is salt://spam/eggs.",
            "",
            "        If the file is hosted on an HTTP or FTP server, the source_hash argument",
            "        is also required.",
            "",
            "    source_hash",
            "        This can be one of the following:",
            "            1. a source hash string",
            "            2. the URI of a file that contains source hash strings",
            "",
            "        The function accepts the first encountered long unbroken alphanumeric",
            "        string of correct length as a valid hash, in order from most secure to",
            "        least secure:",
            "",
            "        .. code-block:: text",
            "",
            "            Type    Length",
            "            ======  ======",
            "            sha512     128",
            "            sha384      96",
            "            sha256      64",
            "            sha224      56",
            "            sha1        40",
            "            md5         32",
            "",
            "        See the ``source_hash`` parameter description for :mod:`file.managed",
            "        <salt.states.file.managed>` function for more details and examples.",
            "",
            "    template",
            "        The named templating engine will be used to render the appended-to file.",
            "        Defaults to ``jinja``. The following templates are supported:",
            "",
            "        - :mod:`cheetah<salt.renderers.cheetah>`",
            "        - :mod:`genshi<salt.renderers.genshi>`",
            "        - :mod:`jinja<salt.renderers.jinja>`",
            "        - :mod:`mako<salt.renderers.mako>`",
            "        - :mod:`py<salt.renderers.py>`",
            "        - :mod:`wempy<salt.renderers.wempy>`",
            "",
            "    sources",
            "        A list of source files to append. If the files are hosted on an HTTP or",
            "        FTP server, the source_hashes argument is also required.",
            "",
            "    source_hashes",
            "        A list of source_hashes corresponding to the sources list specified in",
            "        the sources argument.",
            "",
            "    defaults",
            "        Default context passed to the template.",
            "",
            "    context",
            "        Overrides default context variables passed to the template.",
            "",
            "    ignore_whitespace",
            "        .. versionadded:: 2015.8.4",
            "",
            "        Spaces and Tabs in text are ignored by default, when searching for the",
            "        appending content, one space or multiple tabs are the same for salt.",
            "        Set this option to ``False`` if you want to change this behavior.",
            "",
            "    Multi-line example:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.append:",
            "            - text: |",
            "                Thou hadst better eat salt with the Philosophers of Greece,",
            "                than sugar with the Courtiers of Italy.",
            "                - Benjamin Franklin",
            "",
            "    Multiple lines of text:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.append:",
            "            - text:",
            "              - Trust no one unless you have eaten much salt with him.",
            "              - \"Salt is born of the purest of parents: the sun and the sea.\"",
            "",
            "    Gather text from multiple template files:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file:",
            "              - append",
            "              - template: jinja",
            "              - sources:",
            "                - salt://motd/devops-messages.tmpl",
            "                - salt://motd/hr-messages.tmpl",
            "                - salt://motd/general-messages.tmpl",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    ret = {'name': name,",
            "            'changes': {},",
            "            'pchanges': {},",
            "            'result': False,",
            "            'comment': ''}",
            "",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.append')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    if sources is None:",
            "        sources = []",
            "",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    # Add sources and source_hashes with template support",
            "    # NOTE: FIX 'text' and any 'source' are mutually exclusive as 'text'",
            "    #       is re-assigned in the original code.",
            "    (ok_, err, sl_) = _unify_sources_and_hashes(source=source,",
            "                                                source_hash=source_hash,",
            "                                                sources=sources,",
            "                                                source_hashes=source_hashes)",
            "    if not ok_:",
            "        return _error(ret, err)",
            "",
            "    if makedirs is True:",
            "        dirname = os.path.dirname(name)",
            "        if not __salt__['file.directory_exists'](dirname):",
            "            __salt__['file.makedirs'](name)",
            "            check_res, check_msg, ret['pchanges'] = _check_directory(",
            "                dirname, None, None, False, None, False, False, None",
            "            )",
            "            if not check_res:",
            "                return _error(ret, check_msg)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        # Try to create the file",
            "        touch(name, makedirs=makedirs)",
            "        retry_res, retry_msg = _check_file(name)",
            "        if not retry_res:",
            "            return _error(ret, check_msg)",
            "",
            "    # Follow the original logic and re-assign 'text' if using source(s)...",
            "    if sl_:",
            "        tmpret = _get_template_texts(source_list=sl_,",
            "                                     template=template,",
            "                                     defaults=defaults,",
            "                                     context=context)",
            "        if not tmpret['result']:",
            "            return tmpret",
            "        text = tmpret['data']",
            "",
            "    text = _validate_str_list(text)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.read().splitlines()",
            "",
            "    append_lines = []",
            "    try:",
            "        for chunk in text:",
            "            if ignore_whitespace:",
            "                if __salt__['file.search'](",
            "                        name,",
            "                        salt.utils.build_whitespace_split_regex(chunk),",
            "                        multiline=True):",
            "                    continue",
            "            elif __salt__['file.search'](",
            "                    name,",
            "                    chunk,",
            "                    multiline=True):",
            "                continue",
            "",
            "            for line_item in chunk.splitlines():",
            "                append_lines.append('{0}'.format(line_item))",
            "",
            "    except TypeError:",
            "        return _error(ret, 'No text found to append. Nothing appended')",
            "",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "        ret['result'] = None",
            "        nlines = list(slines)",
            "        nlines.extend(append_lines)",
            "        if slines != nlines:",
            "            if not salt.utils.istextfile(name):",
            "                ret['changes']['diff'] = 'Replace binary file'",
            "            else:",
            "                # Changes happened, add them",
            "                ret['changes']['diff'] = (",
            "                    '\\n'.join(difflib.unified_diff(slines, nlines))",
            "                )",
            "        else:",
            "            ret['comment'] = 'File {0} is in correct state'.format(name)",
            "            ret['result'] = True",
            "        return ret",
            "",
            "    if append_lines:",
            "        __salt__['file.append'](name, args=append_lines)",
            "        ret['comment'] = 'Appended {0} lines'.format(len(append_lines))",
            "    else:",
            "        ret['comment'] = 'File {0} is in correct state'.format(name)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.read().splitlines()",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                '\\n'.join(difflib.unified_diff(slines, nlines)))",
            "",
            "    ret['result'] = True",
            "",
            "    return ret",
            "",
            "",
            "def prepend(name,",
            "            text=None,",
            "            makedirs=False,",
            "            source=None,",
            "            source_hash=None,",
            "            template='jinja',",
            "            sources=None,",
            "            source_hashes=None,",
            "            defaults=None,",
            "            context=None,",
            "            header=None):",
            "    '''",
            "    Ensure that some text appears at the beginning of a file",
            "",
            "    The text will not be prepended again if it already exists in the file. You",
            "    may specify a single line of text or a list of lines to append.",
            "",
            "    Multi-line example:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.prepend:",
            "            - text: |",
            "                Thou hadst better eat salt with the Philosophers of Greece,",
            "                than sugar with the Courtiers of Italy.",
            "                - Benjamin Franklin",
            "",
            "    Multiple lines of text:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.prepend:",
            "            - text:",
            "              - Trust no one unless you have eaten much salt with him.",
            "              - \"Salt is born of the purest of parents: the sun and the sea.\"",
            "",
            "    Optionally, require the text to appear exactly as specified",
            "    (order and position). Combine with multi-line or multiple lines of input.",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file.prepend:",
            "            - header: True",
            "            - text:",
            "              - This will be the very first line in the file.",
            "              - The 2nd line, regardless of duplicates elsewhere in the file.",
            "              - These will be written anew if they do not appear verbatim.",
            "",
            "    Gather text from multiple template files:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/motd:",
            "          file:",
            "              - prepend",
            "              - template: jinja",
            "              - sources:",
            "                - salt://motd/devops-messages.tmpl",
            "                - salt://motd/hr-messages.tmpl",
            "                - salt://motd/general-messages.tmpl",
            "",
            "    .. versionadded:: 2014.7.0",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'pchanges': {},",
            "           'result': False,",
            "           'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.prepend')",
            "",
            "    if sources is None:",
            "        sources = []",
            "",
            "    if source_hashes is None:",
            "        source_hashes = []",
            "",
            "    # Add sources and source_hashes with template support",
            "    # NOTE: FIX 'text' and any 'source' are mutually exclusive as 'text'",
            "    #       is re-assigned in the original code.",
            "    (ok_, err, sl_) = _unify_sources_and_hashes(source=source,",
            "                                                source_hash=source_hash,",
            "                                                sources=sources,",
            "                                                source_hashes=source_hashes)",
            "    if not ok_:",
            "        return _error(ret, err)",
            "",
            "    if makedirs is True:",
            "        dirname = os.path.dirname(name)",
            "        if not __salt__['file.directory_exists'](dirname):",
            "            __salt__['file.makedirs'](name)",
            "            check_res, check_msg, ret['pchanges'] = _check_directory(",
            "                dirname, None, None, False, None, False, False, None",
            "            )",
            "            if not check_res:",
            "                return _error(ret, check_msg)",
            "",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        # Try to create the file",
            "        touch(name, makedirs=makedirs)",
            "        retry_res, retry_msg = _check_file(name)",
            "        if not retry_res:",
            "            return _error(ret, check_msg)",
            "",
            "    # Follow the original logic and re-assign 'text' if using source(s)...",
            "    if sl_:",
            "        tmpret = _get_template_texts(source_list=sl_,",
            "                                     template=template,",
            "                                     defaults=defaults,",
            "                                     context=context)",
            "        if not tmpret['result']:",
            "            return tmpret",
            "        text = tmpret['data']",
            "",
            "    text = _validate_str_list(text)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        slines = fp_.readlines()",
            "",
            "    count = 0",
            "    test_lines = []",
            "",
            "    preface = []",
            "    for chunk in text:",
            "",
            "        # if header kwarg is unset of False, use regex search",
            "        if not header:",
            "            if __salt__['file.search'](",
            "                    name,",
            "                    salt.utils.build_whitespace_split_regex(chunk),",
            "                    multiline=True):",
            "                continue",
            "",
            "        lines = chunk.splitlines()",
            "",
            "        for line in lines:",
            "            if __opts__['test']:",
            "                ret['comment'] = 'File {0} is set to be updated'.format(name)",
            "                ret['result'] = None",
            "                test_lines.append('{0}\\n'.format(line))",
            "            else:",
            "                preface.append(line)",
            "            count += 1",
            "",
            "    if __opts__['test']:",
            "        nlines = test_lines + slines",
            "        if slines != nlines:",
            "            if not salt.utils.istextfile(name):",
            "                ret['changes']['diff'] = 'Replace binary file'",
            "            else:",
            "                # Changes happened, add them",
            "                ret['changes']['diff'] = (",
            "                    ''.join(difflib.unified_diff(slines, nlines))",
            "                )",
            "            ret['result'] = None",
            "        else:",
            "            ret['comment'] = 'File {0} is in correct state'.format(name)",
            "            ret['result'] = True",
            "        return ret",
            "",
            "    # if header kwarg is True, use verbatim compare",
            "    if header:",
            "        with salt.utils.fopen(name, 'rb') as fp_:",
            "            # read as many lines of target file as length of user input",
            "            target_head = fp_.readlines()[0:len(preface)]",
            "            target_lines = []",
            "            # strip newline chars from list entries",
            "            for chunk in target_head:",
            "                target_lines += chunk.splitlines()",
            "            # compare current top lines in target file with user input",
            "            # and write user input if they differ",
            "            if target_lines != preface:",
            "                __salt__['file.prepend'](name, *preface)",
            "            else:",
            "                # clear changed lines counter if target file not modified",
            "                count = 0",
            "    else:",
            "        __salt__['file.prepend'](name, *preface)",
            "",
            "    with salt.utils.fopen(name, 'rb') as fp_:",
            "        nlines = fp_.readlines()",
            "",
            "    if slines != nlines:",
            "        if not salt.utils.istextfile(name):",
            "            ret['changes']['diff'] = 'Replace binary file'",
            "        else:",
            "            # Changes happened, add them",
            "            ret['changes']['diff'] = (",
            "                ''.join(difflib.unified_diff(slines, nlines))",
            "            )",
            "",
            "    if count:",
            "        ret['comment'] = 'Prepended {0} lines'.format(count)",
            "    else:",
            "        ret['comment'] = 'File {0} is in correct state'.format(name)",
            "    ret['result'] = True",
            "    return ret",
            "",
            "",
            "def patch(name,",
            "          source=None,",
            "          options='',",
            "          dry_run_first=True,",
            "          **kwargs):",
            "    '''",
            "    Apply a patch to a file or directory.",
            "",
            "    .. note::",
            "",
            "        A suitable ``patch`` executable must be available on the minion when",
            "        using this state function.",
            "",
            "    name",
            "        The file or directory to which the patch will be applied.",
            "",
            "    source",
            "        The source patch to download to the minion, this source file must be",
            "        hosted on the salt master server. If the file is located in the",
            "        directory named spam, and is called eggs, the source string is",
            "        salt://spam/eggs. A source is required.",
            "",
            "    hash",
            "        The hash of the patched file. If the hash of the target file matches",
            "        this value then the patch is assumed to have been applied. For versions",
            "        2016.11.4 and newer, the hash can be specified without an accompanying",
            "        hash type (e.g. ``e138491e9d5b97023cea823fe17bac22``), but for earlier",
            "        releases it is necessary to also specify the hash type in the format",
            "        ``<hash_type>:<hash_value>`` (e.g.",
            "        ``md5:e138491e9d5b97023cea823fe17bac22``).",
            "",
            "    options",
            "        Extra options to pass to patch.",
            "",
            "    dry_run_first : ``True``",
            "        Run patch with ``--dry-run`` first to check if it will apply cleanly.",
            "",
            "    saltenv",
            "        Specify the environment from which to retrieve the patch file indicated",
            "        by the ``source`` parameter. If not provided, this defaults to the",
            "        environment from which the state is being executed.",
            "",
            "    **Usage:**",
            "",
            "    .. code-block:: yaml",
            "",
            "        # Equivalent to ``patch --forward /opt/file.txt file.patch``",
            "        /opt/file.txt:",
            "          file.patch:",
            "            - source: salt://file.patch",
            "            - hash: e138491e9d5b97023cea823fe17bac22",
            "",
            "    .. note::",
            "        For minions running version 2016.11.3 or older, the hash in the example",
            "        above would need to be specified with the hash type (i.e.",
            "        ``md5:e138491e9d5b97023cea823fe17bac22``).",
            "    '''",
            "    hash_ = kwargs.pop('hash', None)",
            "",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.patch')",
            "    check_res, check_msg = _check_file(name)",
            "    if not check_res:",
            "        return _error(ret, check_msg)",
            "    if not source:",
            "        return _error(ret, 'Source is required')",
            "    if hash_ is None:",
            "        return _error(ret, 'Hash is required')",
            "",
            "    try:",
            "        if hash_ and __salt__['file.check_hash'](name, hash_):",
            "            ret['result'] = True",
            "            ret['comment'] = 'Patch is already applied'",
            "            return ret",
            "    except (SaltInvocationError, ValueError) as exc:",
            "        ret['comment'] = exc.__str__()",
            "        return ret",
            "",
            "    # get cached file or copy it to cache",
            "    cached_source_path = __salt__['cp.cache_file'](source, __env__)",
            "    if not cached_source_path:",
            "        ret['comment'] = ('Unable to cache {0} from saltenv \\'{1}\\''",
            "                          .format(source, __env__))",
            "        return ret",
            "",
            "    log.debug(",
            "        'State patch.applied cached source %s -> %s',",
            "        source, cached_source_path",
            "    )",
            "",
            "    if dry_run_first or __opts__['test']:",
            "        ret['changes'] = __salt__['file.patch'](",
            "            name, cached_source_path, options=options, dry_run=True",
            "        )",
            "        if __opts__['test']:",
            "            ret['comment'] = 'File {0} will be patched'.format(name)",
            "            ret['result'] = None",
            "            return ret",
            "        if ret['changes']['retcode'] != 0:",
            "            return ret",
            "",
            "    ret['changes'] = __salt__['file.patch'](",
            "        name, cached_source_path, options=options",
            "    )",
            "    ret['result'] = ret['changes']['retcode'] == 0",
            "    # No need to check for SaltInvocationError or ValueError this time, since",
            "    # these exceptions would have been caught above.",
            "    if ret['result'] and hash_ and not __salt__['file.check_hash'](name, hash_):",
            "        ret['result'] = False",
            "        ret['comment'] = 'Hash mismatch after patch was applied'",
            "    return ret",
            "",
            "",
            "def touch(name, atime=None, mtime=None, makedirs=False):",
            "    '''",
            "    Replicate the 'nix \"touch\" command to create a new empty",
            "    file or update the atime and mtime of an existing file.",
            "",
            "    Note that if you just want to create a file and don't care about atime or",
            "    mtime, you should use ``file.managed`` instead, as it is more",
            "    feature-complete.  (Just leave out the ``source``/``template``/``contents``",
            "    arguments, and it will just create the file and/or check its permissions,",
            "    without messing with contents)",
            "",
            "    name",
            "        name of the file",
            "",
            "    atime",
            "        atime of the file",
            "",
            "    mtime",
            "        mtime of the file",
            "",
            "    makedirs",
            "        whether we should create the parent directory/directories in order to",
            "        touch the file",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /var/log/httpd/logrotate.empty:",
            "          file.touch",
            "",
            "    .. versionadded:: 0.9.5",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "    }",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.touch')",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name)",
            "        )",
            "",
            "    if __opts__['test']:",
            "        ret['result'], ret['comment'] = _check_touch(name, atime, mtime)",
            "        return ret",
            "",
            "    if makedirs:",
            "        __salt__['file.makedirs'](name)",
            "    if not os.path.isdir(os.path.dirname(name)):",
            "        return _error(",
            "            ret, 'Directory not present to touch file {0}'.format(name)",
            "        )",
            "",
            "    extant = os.path.exists(name)",
            "",
            "    ret['result'] = __salt__['file.touch'](name, atime, mtime)",
            "    if not extant and ret['result']:",
            "        ret['comment'] = 'Created empty file {0}'.format(name)",
            "        ret['changes']['new'] = name",
            "    elif extant and ret['result']:",
            "        ret['comment'] = 'Updated times on {0} {1}'.format(",
            "            'directory' if os.path.isdir(name) else 'file', name",
            "        )",
            "        ret['changes']['touched'] = name",
            "",
            "    return ret",
            "",
            "",
            "def copy(",
            "        name,",
            "        source,",
            "        force=False,",
            "        makedirs=False,",
            "        preserve=False,",
            "        user=None,",
            "        group=None,",
            "        mode=None,",
            "        subdir=False,",
            "        **kwargs):",
            "    '''",
            "    If the source file exists on the system, copy it to the named file. The",
            "    named file will not be overwritten if it already exists unless the force",
            "    option is set to True.",
            "",
            "    name",
            "        The location of the file to copy to",
            "",
            "    source",
            "        The location of the file to copy to the location specified with name",
            "",
            "    force",
            "        If the target location is present then the file will not be moved,",
            "        specify \"force: True\" to overwrite the target file",
            "",
            "    makedirs",
            "        If the target subdirectories don't exist create them",
            "",
            "    preserve",
            "        .. versionadded:: 2015.5.0",
            "",
            "        Set ``preserve: True`` to preserve user/group ownership and mode",
            "        after copying. Default is ``False``. If ``preserve`` is set to ``True``,",
            "        then user/group/mode attributes will be ignored.",
            "",
            "    user",
            "        .. versionadded:: 2015.5.0",
            "",
            "        The user to own the copied file, this defaults to the user salt is",
            "        running as on the minion. If ``preserve`` is set to ``True``, then",
            "        this will be ignored",
            "",
            "    group",
            "        .. versionadded:: 2015.5.0",
            "",
            "        The group to own the copied file, this defaults to the group salt is",
            "        running as on the minion. If ``preserve`` is set to ``True`` or on",
            "        Windows this will be ignored",
            "",
            "    mode",
            "        .. versionadded:: 2015.5.0",
            "",
            "        The permissions to set on the copied file, aka 644, '0775', '4664'.",
            "        If ``preserve`` is set to ``True``, then this will be ignored.",
            "        Not supported on Windows.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "    subdir",
            "        .. versionadded:: 2015.5.0",
            "",
            "        If the name is a directory then place the file inside the named",
            "        directory",
            "",
            "    .. note::",
            "        The copy function accepts paths that are local to the Salt minion.",
            "        This function does not support salt://, http://, or the other",
            "        additional file paths that are supported by :mod:`states.file.managed",
            "        <salt.states.file.managed>` and :mod:`states.file.recurse",
            "        <salt.states.file.recurse>`.",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    source = os.path.expanduser(source)",
            "",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'comment': 'Copied \"{0}\" to \"{1}\"'.format(source, name),",
            "        'result': True}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.copy')",
            "",
            "    changed = True",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    if not os.path.exists(source):",
            "        return _error(ret, 'Source file \"{0}\" is not present'.format(source))",
            "",
            "    if preserve:",
            "        user = __salt__['file.get_user'](source)",
            "        group = __salt__['file.get_group'](source)",
            "        mode = __salt__['file.get_mode'](source)",
            "    else:",
            "        user = _test_owner(kwargs, user=user)",
            "        if user is None:",
            "            user = __opts__['user']",
            "",
            "        if salt.utils.is_windows():",
            "            if group is not None:",
            "                log.warning(",
            "                    'The group argument for {0} has been ignored as this is '",
            "                    'a Windows system.'.format(name)",
            "                )",
            "            group = user",
            "",
            "        if group is None:",
            "            group = __salt__['file.gid_to_group'](",
            "                __salt__['user.info'](user).get('gid', 0)",
            "            )",
            "",
            "        u_check = _check_user(user, group)",
            "        if u_check:",
            "            # The specified user or group do not exist",
            "            return _error(ret, u_check)",
            "",
            "        if mode is None:",
            "            mode = __salt__['file.get_mode'](source)",
            "",
            "    if os.path.isdir(name) and subdir:",
            "        # If the target is a dir, and overwrite_dir is False, copy into the dir",
            "        name = os.path.join(name, os.path.basename(source))",
            "",
            "    if os.path.lexists(source) and os.path.lexists(name):",
            "        # if this is a file which did not change, do not update",
            "        if force and os.path.isfile(name):",
            "            hash1 = salt.utils.get_hash(name)",
            "            hash2 = salt.utils.get_hash(source)",
            "            if hash1 == hash2:",
            "                changed = True",
            "                ret['comment'] = ' '.join([ret['comment'], '- files are identical but force flag is set'])",
            "        if not force:",
            "            changed = False",
            "        elif not __opts__['test'] and changed:",
            "            # Remove the destination to prevent problems later",
            "            try:",
            "                __salt__['file.remove'](name)",
            "            except (IOError, OSError):",
            "                return _error(",
            "                    ret,",
            "                    'Failed to delete \"{0}\" in preparation for '",
            "                    'forced move'.format(name)",
            "                )",
            "",
            "    if __opts__['test']:",
            "        if changed:",
            "            ret['comment'] = 'File \"{0}\" is set to be copied to \"{1}\"'.format(",
            "                source,",
            "                name",
            "            )",
            "            ret['result'] = None",
            "        else:",
            "            ret['comment'] = ('The target file \"{0}\" exists and will not be '",
            "                              'overwritten'.format(name))",
            "            ret['result'] = True",
            "        return ret",
            "",
            "    if not changed:",
            "        ret['comment'] = ('The target file \"{0}\" exists and will not be '",
            "                          'overwritten'.format(name))",
            "        ret['result'] = True",
            "        return ret",
            "",
            "    # Run makedirs",
            "    dname = os.path.dirname(name)",
            "    if not os.path.isdir(dname):",
            "        if makedirs:",
            "            __salt__['file.makedirs'](name)",
            "        else:",
            "            return _error(",
            "                ret,",
            "                'The target directory {0} is not present'.format(dname))",
            "    # All tests pass, move the file into place",
            "    try:",
            "        if os.path.isdir(source):",
            "            shutil.copytree(source, name, symlinks=True)",
            "            for root, dirs, files in os.walk(name):",
            "                for dir_ in dirs:",
            "                    __salt__['file.lchown'](os.path.join(root, dir_), user, group)",
            "                for file_ in files:",
            "                    __salt__['file.lchown'](os.path.join(root, file_), user, group)",
            "        else:",
            "            shutil.copy(source, name)",
            "        ret['changes'] = {name: source}",
            "        # Preserve really means just keep the behavior of the cp command. If",
            "        # the filesystem we're copying to is squashed or doesn't support chown",
            "        # then we shouldn't be checking anything.",
            "        if not preserve:",
            "            __salt__['file.check_perms'](name, ret, user, group, mode)",
            "    except (IOError, OSError):",
            "        return _error(",
            "            ret, 'Failed to copy \"{0}\" to \"{1}\"'.format(source, name))",
            "    return ret",
            "",
            "",
            "def rename(name, source, force=False, makedirs=False):",
            "    '''",
            "    If the source file exists on the system, rename it to the named file. The",
            "    named file will not be overwritten if it already exists unless the force",
            "    option is set to True.",
            "",
            "    name",
            "        The location of the file to rename to",
            "",
            "    source",
            "        The location of the file to move to the location specified with name",
            "",
            "    force",
            "        If the target location is present then the file will not be moved,",
            "        specify \"force: True\" to overwrite the target file",
            "",
            "    makedirs",
            "        If the target subdirectories don't exist create them",
            "",
            "    '''",
            "    name = os.path.expanduser(name)",
            "    source = os.path.expanduser(source)",
            "",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'comment': '',",
            "        'result': True}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.rename')",
            "",
            "    if not os.path.isabs(name):",
            "        return _error(",
            "            ret, 'Specified file {0} is not an absolute path'.format(name))",
            "",
            "    if not os.path.lexists(source):",
            "        ret['comment'] = ('Source file \"{0}\" has already been moved out of '",
            "                          'place').format(source)",
            "        return ret",
            "",
            "    if os.path.lexists(source) and os.path.lexists(name):",
            "        if not force:",
            "            ret['comment'] = ('The target file \"{0}\" exists and will not be '",
            "                              'overwritten'.format(name))",
            "            ret['result'] = False",
            "            return ret",
            "        elif not __opts__['test']:",
            "            # Remove the destination to prevent problems later",
            "            try:",
            "                __salt__['file.remove'](name)",
            "            except (IOError, OSError):",
            "                return _error(",
            "                    ret,",
            "                    'Failed to delete \"{0}\" in preparation for '",
            "                    'forced move'.format(name)",
            "                )",
            "",
            "    if __opts__['test']:",
            "        ret['comment'] = 'File \"{0}\" is set to be moved to \"{1}\"'.format(",
            "            source,",
            "            name",
            "        )",
            "        ret['result'] = None",
            "        return ret",
            "",
            "    # Run makedirs",
            "    dname = os.path.dirname(name)",
            "    if not os.path.isdir(dname):",
            "        if makedirs:",
            "            __salt__['file.makedirs'](name)",
            "        else:",
            "            return _error(",
            "                ret,",
            "                'The target directory {0} is not present'.format(dname))",
            "    # All tests pass, move the file into place",
            "    try:",
            "        if os.path.islink(source):",
            "            linkto = os.readlink(source)",
            "            os.symlink(linkto, name)",
            "            os.unlink(source)",
            "        else:",
            "            shutil.move(source, name)",
            "    except (IOError, OSError):",
            "        return _error(",
            "            ret, 'Failed to move \"{0}\" to \"{1}\"'.format(source, name))",
            "",
            "    ret['comment'] = 'Moved \"{0}\" to \"{1}\"'.format(source, name)",
            "    ret['changes'] = {name: source}",
            "    return ret",
            "",
            "",
            "def accumulated(name, filename, text, **kwargs):",
            "    '''",
            "    Prepare accumulator which can be used in template in file.managed state.",
            "    Accumulator dictionary becomes available in template. It can also be used",
            "    in file.blockreplace.",
            "",
            "    name",
            "        Accumulator name",
            "",
            "    filename",
            "        Filename which would receive this accumulator (see file.managed state",
            "        documentation about ``name``)",
            "",
            "    text",
            "        String or list for adding in accumulator",
            "",
            "    require_in / watch_in",
            "        One of them required for sure we fill up accumulator before we manage",
            "        the file. Probably the same as filename",
            "",
            "    Example:",
            "",
            "    Given the following:",
            "",
            "    .. code-block:: yaml",
            "",
            "        animals_doing_things:",
            "          file.accumulated:",
            "            - filename: /tmp/animal_file.txt",
            "            - text: ' jumps over the lazy dog.'",
            "            - require_in:",
            "              - file: animal_file",
            "",
            "        animal_file:",
            "          file.managed:",
            "            - name: /tmp/animal_file.txt",
            "            - source: salt://animal_file.txt",
            "            - template: jinja",
            "",
            "    One might write a template for ``animal_file.txt`` like the following:",
            "",
            "    .. code-block:: jinja",
            "",
            "        The quick brown fox{% for animal in accumulator['animals_doing_things'] %}{{ animal }}{% endfor %}",
            "",
            "    Collectively, the above states and template file will produce:",
            "",
            "    .. code-block:: text",
            "",
            "        The quick brown fox jumps over the lazy dog.",
            "",
            "    Multiple accumulators can be \"chained\" together.",
            "",
            "    .. note::",
            "        The 'accumulator' data structure is a Python dictionary.",
            "        Do not expect any loop over the keys in a deterministic order!",
            "    '''",
            "    ret = {",
            "        'name': name,",
            "        'changes': {},",
            "        'result': True,",
            "        'comment': ''",
            "    }",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.accumulated')",
            "    if text is None:",
            "        ret['result'] = False",
            "        ret['comment'] = 'No text supplied for accumulator'",
            "        return ret",
            "    require_in = __low__.get('require_in', [])",
            "    watch_in = __low__.get('watch_in', [])",
            "    deps = require_in + watch_in",
            "    if not [x for x in deps if 'file' in x]:",
            "        ret['result'] = False",
            "        ret['comment'] = 'Orphaned accumulator {0} in {1}:{2}'.format(",
            "            name,",
            "            __low__['__sls__'],",
            "            __low__['__id__']",
            "        )",
            "        return ret",
            "    if isinstance(text, six.string_types):",
            "        text = (text,)",
            "    elif isinstance(text, dict):",
            "        text = (text,)",
            "    accum_data, accum_deps = _load_accumulators()",
            "    if filename not in accum_data:",
            "        accum_data[filename] = {}",
            "    if filename not in accum_deps:",
            "        accum_deps[filename] = {}",
            "    if name not in accum_deps[filename]:",
            "        accum_deps[filename][name] = []",
            "    for accumulator in deps:",
            "        accum_deps[filename][name].extend(six.itervalues(accumulator))",
            "    if name not in accum_data[filename]:",
            "        accum_data[filename][name] = []",
            "    for chunk in text:",
            "        if chunk not in accum_data[filename][name]:",
            "            accum_data[filename][name].append(chunk)",
            "            ret['comment'] = ('Accumulator {0} for file {1} '",
            "                              'was charged by text'.format(name, filename))",
            "    _persist_accummulators(accum_data, accum_deps)",
            "    return ret",
            "",
            "",
            "def serialize(name,",
            "              dataset=None,",
            "              dataset_pillar=None,",
            "              user=None,",
            "              group=None,",
            "              mode=None,",
            "              backup='',",
            "              makedirs=False,",
            "              show_diff=None,",
            "              show_changes=True,",
            "              create=True,",
            "              merge_if_exists=False,",
            "              **kwargs):",
            "    '''",
            "    Serializes dataset and store it into managed file. Useful for sharing",
            "    simple configuration files.",
            "",
            "    name",
            "        The location of the file to create",
            "",
            "    dataset",
            "        The dataset that will be serialized",
            "",
            "    dataset_pillar",
            "        Operates like ``dataset``, but draws from a value stored in pillar,",
            "        using the pillar path syntax used in :mod:`pillar.get",
            "        <salt.modules.pillar.get>`. This is useful when the pillar value",
            "        contains newlines, as referencing a pillar variable using a jinja/mako",
            "        template can result in YAML formatting issues due to the newlines",
            "        causing indentation mismatches.",
            "",
            "        .. versionadded:: 2015.8.0",
            "",
            "    formatter",
            "        Write the data as this format. Supported output formats:",
            "",
            "        * JSON",
            "        * YAML",
            "        * Python (via pprint.pformat)",
            "",
            "    user",
            "        The user to own the directory, this defaults to the user salt is",
            "        running as on the minion",
            "",
            "    group",
            "        The group ownership set for the directory, this defaults to the group",
            "        salt is running as on the minion",
            "",
            "    mode",
            "        The permissions to set on this file, e.g. ``644``, ``0775``, or",
            "        ``4664``.",
            "",
            "        The default mode for new files and directories corresponds umask of salt",
            "        process. For existing files and directories it's not enforced.",
            "",
            "        .. note::",
            "            This option is **not** supported on Windows.",
            "",
            "    backup",
            "        Overrides the default backup mode for this specific file.",
            "",
            "    makedirs",
            "        Create parent directories for destination file.",
            "",
            "        .. versionadded:: 2014.1.3",
            "",
            "    show_diff",
            "        DEPRECATED: Please use show_changes.",
            "",
            "        If set to ``False``, the diff will not be shown in the return data if",
            "        changes are made.",
            "",
            "    show_changes",
            "        Output a unified diff of the old file and the new file. If ``False``",
            "        return a boolean if any changes were made.",
            "",
            "    create",
            "        Default is True, if create is set to False then the file will only be",
            "        managed if the file already exists on the system.",
            "",
            "    merge_if_exists",
            "        Default is False, if merge_if_exists is True then the existing file will",
            "        be parsed and the dataset passed in will be merged with the existing",
            "        content",
            "",
            "        .. versionadded:: 2014.7.0",
            "",
            "    For example, this state:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /etc/dummy/package.json:",
            "          file.serialize:",
            "            - dataset:",
            "                name: naive",
            "                description: A package using naive versioning",
            "                author: A confused individual <iam@confused.com>",
            "                dependencies:",
            "                    express: >= 1.2.0",
            "                    optimist: >= 0.1.0",
            "                engine: node 0.4.1",
            "            - formatter: json",
            "",
            "    will manage the file ``/etc/dummy/package.json``:",
            "",
            "    .. code-block:: json",
            "",
            "        {",
            "          \"author\": \"A confused individual <iam@confused.com>\",",
            "          \"dependencies\": {",
            "            \"express\": \">= 1.2.0\",",
            "            \"optimist\": \">= 0.1.0\"",
            "          },",
            "          \"description\": \"A package using naive versioning\",",
            "          \"engine\": \"node 0.4.1\",",
            "          \"name\": \"naive\"",
            "        }",
            "    '''",
            "    if 'env' in kwargs:",
            "        salt.utils.warn_until(",
            "            'Oxygen',",
            "            'Parameter \\'env\\' has been detected in the argument list.  This '",
            "            'parameter is no longer used and has been replaced by \\'saltenv\\' '",
            "            'as of Salt 2016.11.0.  This warning will be removed in Salt Oxygen.'",
            "            )",
            "        kwargs.pop('env')",
            "",
            "    name = os.path.expanduser(name)",
            "",
            "    default_serializer_opts = {'yaml.serialize': {'default_flow_style': False},",
            "                              'json.serialize': {'indent': 2,",
            "                                       'separators': (',', ': '),",
            "                                       'sort_keys': True}",
            "                              }",
            "    ret = {'changes': {},",
            "           'comment': '',",
            "           'name': name,",
            "           'result': True}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.serialize')",
            "",
            "    if not create:",
            "        if not os.path.isfile(name):",
            "            # Don't create a file that is not already present",
            "            ret['comment'] = ('File {0} is not present and is not set for '",
            "                              'creation').format(name)",
            "            return ret",
            "",
            "    formatter = kwargs.pop('formatter', 'yaml').lower()",
            "",
            "    if len([x for x in (dataset, dataset_pillar) if x]) > 1:",
            "        return _error(",
            "            ret, 'Only one of \\'dataset\\' and \\'dataset_pillar\\' is permitted')",
            "",
            "    if dataset_pillar:",
            "        dataset = __salt__['pillar.get'](dataset_pillar)",
            "",
            "    if dataset is None:",
            "        return _error(",
            "            ret, 'Neither \\'dataset\\' nor \\'dataset_pillar\\' was defined')",
            "",
            "    if salt.utils.is_windows():",
            "        if group is not None:",
            "            log.warning(",
            "                'The group argument for {0} has been ignored as this '",
            "                'is a Windows system.'.format(name)",
            "            )",
            "        group = user",
            "",
            "    serializer_name = '{0}.serialize'.format(formatter)",
            "    deserializer_name = '{0}.deserialize'.format(formatter)",
            "",
            "    if serializer_name not in __serializers__:",
            "        return {'changes': {},",
            "                'comment': '{0} format is not supported'.format(",
            "                    formatter.capitalize()),",
            "                'name': name,",
            "                'result': False",
            "                }",
            "",
            "    if merge_if_exists:",
            "        if os.path.isfile(name):",
            "            if '{0}.deserialize'.format(formatter) not in __serializers__:",
            "                return {'changes': {},",
            "                        'comment': ('{0} format is not supported for merging'",
            "                                    .format(formatter.capitalize())),",
            "                        'name': name,",
            "                        'result': False}",
            "",
            "            with salt.utils.fopen(name, 'r') as fhr:",
            "                existing_data = __serializers__[deserializer_name](fhr)",
            "",
            "            if existing_data is not None:",
            "                merged_data = salt.utils.dictupdate.merge_recurse(existing_data, dataset)",
            "                if existing_data == merged_data:",
            "                    ret['result'] = True",
            "                    ret['comment'] = 'The file {0} is in the correct state'.format(name)",
            "                    return ret",
            "                dataset = merged_data",
            "    contents = __serializers__[serializer_name](dataset, **default_serializer_opts.get(serializer_name, {}))",
            "",
            "    contents += '\\n'",
            "",
            "    # Make sure that any leading zeros stripped by YAML loader are added back",
            "    mode = salt.utils.normalize_mode(mode)",
            "",
            "    if show_diff is not None:",
            "        show_changes = show_diff",
            "        msg = (",
            "            'The \\'show_diff\\' argument to the file.serialized state has been '",
            "            'deprecated, please use \\'show_changes\\' instead.'",
            "        )",
            "        salt.utils.warn_until('Oxygen', msg)",
            "",
            "    if __opts__['test']:",
            "        ret['changes'] = __salt__['file.check_managed_changes'](",
            "            name=name,",
            "            source=None,",
            "            source_hash={},",
            "            source_hash_name=None,",
            "            user=user,",
            "            group=group,",
            "            mode=mode,",
            "            template=None,",
            "            context=None,",
            "            defaults=None,",
            "            saltenv=__env__,",
            "            contents=contents,",
            "            skip_verify=False,",
            "            **kwargs",
            "        )",
            "",
            "        if ret['changes']:",
            "            ret['result'] = None",
            "            ret['comment'] = 'Dataset will be serialized and stored into {0}'.format(",
            "                name)",
            "",
            "            if not show_changes:",
            "                ret['changes']['diff'] = '<show_changes=False>'",
            "        else:",
            "            ret['result'] = True",
            "            ret['comment'] = 'The file {0} is in the correct state'.format(name)",
            "        return ret",
            "",
            "    return __salt__['file.manage_file'](name=name,",
            "                                        sfn='',",
            "                                        ret=ret,",
            "                                        source=None,",
            "                                        source_sum={},",
            "                                        user=user,",
            "                                        group=group,",
            "                                        mode=mode,",
            "                                        saltenv=__env__,",
            "                                        backup=backup,",
            "                                        makedirs=makedirs,",
            "                                        template=None,",
            "                                        show_changes=show_changes,",
            "                                        contents=contents)",
            "",
            "",
            "def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode='0600'):",
            "    '''",
            "    Create a special file similar to the 'nix mknod command. The supported",
            "    device types are ``p`` (fifo pipe), ``c`` (character device), and ``b``",
            "    (block device). Provide the major and minor numbers when specifying a",
            "    character device or block device. A fifo pipe does not require this",
            "    information. The command will create the necessary dirs if needed. If a",
            "    file of the same name not of the same type/major/minor exists, it will not",
            "    be overwritten or unlinked (deleted). This is logically in place as a",
            "    safety measure because you can really shoot yourself in the foot here and",
            "    it is the behavior of 'nix ``mknod``. It is also important to note that not",
            "    just anyone can create special devices. Usually this is only done as root.",
            "    If the state is executed as none other than root on a minion, you may",
            "    receive a permission error.",
            "",
            "    name",
            "        name of the file",
            "",
            "    ntype",
            "        node type 'p' (fifo pipe), 'c' (character device), or 'b'",
            "        (block device)",
            "",
            "    major",
            "        major number of the device",
            "        does not apply to a fifo pipe",
            "",
            "    minor",
            "        minor number of the device",
            "        does not apply to a fifo pipe",
            "",
            "    user",
            "        owning user of the device/pipe",
            "",
            "    group",
            "        owning group of the device/pipe",
            "",
            "    mode",
            "        permissions on the device/pipe",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        /dev/chr:",
            "          file.mknod:",
            "            - ntype: c",
            "            - major: 180",
            "            - minor: 31",
            "            - user: root",
            "            - group: root",
            "            - mode: 660",
            "",
            "        /dev/blk:",
            "          file.mknod:",
            "            - ntype: b",
            "            - major: 8",
            "            - minor: 999",
            "            - user: root",
            "            - group: root",
            "            - mode: 660",
            "",
            "        /dev/fifo:",
            "          file.mknod:",
            "            - ntype: p",
            "            - user: root",
            "            - group: root",
            "            - mode: 660",
            "",
            "    .. versionadded:: 0.17.0",
            "    '''",
            "    name = os.path.expanduser(name)",
            "",
            "    ret = {'name': name,",
            "           'changes': {},",
            "           'comment': '',",
            "           'result': False}",
            "    if not name:",
            "        return _error(ret, 'Must provide name to file.mknod')",
            "",
            "    if ntype == 'c':",
            "        # Check for file existence",
            "        if __salt__['file.file_exists'](name):",
            "            ret['comment'] = (",
            "                'File exists and is not a character device {0}. Cowardly '",
            "                'refusing to continue'.format(name)",
            "            )",
            "",
            "        # Check if it is a character device",
            "        elif not __salt__['file.is_chrdev'](name):",
            "            if __opts__['test']:",
            "                ret['comment'] = (",
            "                    'Character device {0} is set to be created'",
            "                ).format(name)",
            "                ret['result'] = None",
            "            else:",
            "                ret = __salt__['file.mknod'](name,",
            "                                             ntype,",
            "                                             major,",
            "                                             minor,",
            "                                             user,",
            "                                             group,",
            "                                             mode)",
            "",
            "        # Check the major/minor",
            "        else:",
            "            devmaj, devmin = __salt__['file.get_devmm'](name)",
            "            if (major, minor) != (devmaj, devmin):",
            "                ret['comment'] = (",
            "                    'Character device {0} exists and has a different '",
            "                    'major/minor {1}/{2}. Cowardly refusing to continue'",
            "                        .format(name, devmaj, devmin)",
            "                )",
            "            # Check the perms",
            "            else:",
            "                ret = __salt__['file.check_perms'](name,",
            "                                                   None,",
            "                                                   user,",
            "                                                   group,",
            "                                                   mode)[0]",
            "                if not ret['changes']:",
            "                    ret['comment'] = (",
            "                        'Character device {0} is in the correct state'.format(",
            "                            name",
            "                        )",
            "                    )",
            "",
            "    elif ntype == 'b':",
            "        # Check for file existence",
            "        if __salt__['file.file_exists'](name):",
            "            ret['comment'] = (",
            "                'File exists and is not a block device {0}. Cowardly '",
            "                'refusing to continue'.format(name)",
            "            )",
            "",
            "        # Check if it is a block device",
            "        elif not __salt__['file.is_blkdev'](name):",
            "            if __opts__['test']:",
            "                ret['comment'] = (",
            "                    'Block device {0} is set to be created'",
            "                ).format(name)",
            "                ret['result'] = None",
            "            else:",
            "                ret = __salt__['file.mknod'](name,",
            "                                             ntype,",
            "                                             major,",
            "                                             minor,",
            "                                             user,",
            "                                             group,",
            "                                             mode)",
            "",
            "        # Check the major/minor",
            "        else:",
            "            devmaj, devmin = __salt__['file.get_devmm'](name)",
            "            if (major, minor) != (devmaj, devmin):",
            "                ret['comment'] = (",
            "                    'Block device {0} exists and has a different major/minor '",
            "                    '{1}/{2}. Cowardly refusing to continue'.format(",
            "                        name, devmaj, devmin",
            "                    )",
            "                )",
            "            # Check the perms",
            "            else:",
            "                ret = __salt__['file.check_perms'](name,",
            "                                                   None,",
            "                                                   user,",
            "                                                   group,",
            "                                                   mode)[0]",
            "                if not ret['changes']:",
            "                    ret['comment'] = (",
            "                        'Block device {0} is in the correct state'.format(name)",
            "                    )",
            "",
            "    elif ntype == 'p':",
            "        # Check for file existence",
            "        if __salt__['file.file_exists'](name):",
            "            ret['comment'] = (",
            "                'File exists and is not a fifo pipe {0}. Cowardly refusing '",
            "                'to continue'.format(name)",
            "            )",
            "",
            "        # Check if it is a fifo",
            "        elif not __salt__['file.is_fifo'](name):",
            "            if __opts__['test']:",
            "                ret['comment'] = 'Fifo pipe {0} is set to be created'.format(",
            "                    name",
            "                )",
            "                ret['result'] = None",
            "            else:",
            "                ret = __salt__['file.mknod'](name,",
            "                                             ntype,",
            "                                             major,",
            "                                             minor,",
            "                                             user,",
            "                                             group,",
            "                                             mode)",
            "",
            "        # Check the perms",
            "        else:",
            "            ret = __salt__['file.check_perms'](name,",
            "                                               None,",
            "                                               user,",
            "                                               group,",
            "                                               mode)[0]",
            "            if not ret['changes']:",
            "                ret['comment'] = (",
            "                    'Fifo pipe {0} is in the correct state'.format(name)",
            "                )",
            "",
            "    else:",
            "        ret['comment'] = (",
            "            'Node type unavailable: \\'{0}\\'. Available node types are '",
            "            'character (\\'c\\'), block (\\'b\\'), and pipe (\\'p\\')'.format(ntype)",
            "        )",
            "",
            "    return ret",
            "",
            "",
            "def mod_run_check_cmd(cmd, filename, **check_cmd_opts):",
            "    '''",
            "    Execute the check_cmd logic.",
            "",
            "    Return a result dict if ``check_cmd`` succeeds (check_cmd == 0)",
            "    otherwise return True",
            "    '''",
            "",
            "    log.debug('running our check_cmd')",
            "    _cmd = '{0} {1}'.format(cmd, filename)",
            "    cret = __salt__['cmd.run_all'](_cmd, **check_cmd_opts)",
            "    if cret['retcode'] != 0:",
            "        ret = {'comment': 'check_cmd execution failed',",
            "               'skip_watch': True,",
            "               'result': False}",
            "",
            "        if cret.get('stdout'):",
            "            ret['comment'] += '\\n' + cret['stdout']",
            "        if cret.get('stderr'):",
            "            ret['comment'] += '\\n' + cret['stderr']",
            "",
            "        return ret",
            "",
            "    # No reason to stop, return True",
            "    return True",
            "",
            "",
            "def decode(name,",
            "        encoded_data=None,",
            "        contents_pillar=None,",
            "        encoding_type='base64',",
            "        checksum='md5'):",
            "    '''",
            "    Decode an encoded file and write it to disk",
            "",
            "    .. versionadded:: 2016.3.0",
            "",
            "    name",
            "        Path of the file to be written.",
            "    encoded_data",
            "        The encoded file. Either this option or ``contents_pillar`` must be",
            "        specified.",
            "    contents_pillar",
            "        A Pillar path to the encoded file. Uses the same path syntax as",
            "        :py:func:`pillar.get <salt.modules.pillar.get>`. The",
            "        :py:func:`hashutil.base64_encodefile",
            "        <salt.modules.hashutil.base64_encodefile>` function can load encoded",
            "        content into Pillar. Either this option or ``encoded_data`` must be",
            "        specified.",
            "    encoding_type : ``base64``",
            "        The type of encoding.",
            "    checksum : ``md5``",
            "        The hashing algorithm to use to generate checksums. Wraps the",
            "        :py:func:`hashutil.digest <salt.modules.hashutil.digest>` execution",
            "        function.",
            "",
            "    Usage:",
            "",
            "    .. code-block:: yaml",
            "",
            "        write_base64_encoded_string_to_a_file:",
            "          file.decode:",
            "            - name: /tmp/new_file",
            "            - encoding_type: base64",
            "            - contents_pillar: mypillar:thefile",
            "",
            "        # or",
            "",
            "        write_base64_encoded_string_to_a_file:",
            "          file.decode:",
            "            - name: /tmp/new_file",
            "            - encoding_type: base64",
            "            - encoded_data: |",
            "                Z2V0IHNhbHRlZAo=",
            "",
            "    Be careful with multi-line strings that the YAML indentation is correct.",
            "    E.g.,",
            "",
            "    .. code-block:: yaml",
            "",
            "        write_base64_encoded_string_to_a_file:",
            "          file.decode:",
            "            - name: /tmp/new_file",
            "            - encoding_type: base64",
            "            - encoded_data: |",
            "                {{ salt.pillar.get('path:to:data') | indent(8) }}",
            "    '''",
            "    ret = {'name': name, 'changes': {}, 'result': False, 'comment': ''}",
            "",
            "    if not (encoded_data or contents_pillar):",
            "        raise CommandExecutionError(\"Specify either the 'encoded_data' or \"",
            "            \"'contents_pillar' argument.\")",
            "    elif encoded_data and contents_pillar:",
            "        raise CommandExecutionError(\"Specify only one 'encoded_data' or \"",
            "            \"'contents_pillar' argument.\")",
            "    elif encoded_data:",
            "        content = encoded_data",
            "    elif contents_pillar:",
            "        content = __salt__['pillar.get'](contents_pillar, False)",
            "        if content is False:",
            "            raise CommandExecutionError('Pillar data not found.')",
            "    else:",
            "        raise CommandExecutionError('No contents given.')",
            "",
            "    dest_exists = __salt__['file.file_exists'](name)",
            "    if dest_exists:",
            "        instr = __salt__['hashutil.base64_decodestring'](content)",
            "        insum = __salt__['hashutil.digest'](instr, checksum)",
            "        del instr  # no need to keep in-memory after we have the hash",
            "        outsum = __salt__['hashutil.digest_file'](name, checksum)",
            "",
            "        if insum != outsum:",
            "            ret['changes'] = {",
            "                'old': outsum,",
            "                'new': insum,",
            "            }",
            "",
            "        if not ret['changes']:",
            "            ret['comment'] = 'File is in the correct state.'",
            "            ret['result'] = True",
            "",
            "            return ret",
            "",
            "    if __opts__['test'] is True:",
            "        ret['comment'] = 'File is set to be updated.'",
            "        ret['result'] = None",
            "        return ret",
            "",
            "    ret['result'] = __salt__['hashutil.base64_decodefile'](content, name)",
            "    ret['comment'] = 'File was updated.'",
            "",
            "    if not ret['changes']:",
            "        ret['changes'] = {",
            "            'old': None,",
            "            'new': __salt__['hashutil.digest_file'](name, checksum),",
            "        }",
            "",
            "    return ret"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "salt.states.file.managed.check_cmd_opts",
            "salt.states.file.managed.list_contents",
            "salt.states.file.managed.ret",
            "salt.states.file._error.ret",
            "salt.states.file.managed.context",
            "knowledge_repo.app.routes.comment",
            "salt.states.file.line"
        ]
    }
}