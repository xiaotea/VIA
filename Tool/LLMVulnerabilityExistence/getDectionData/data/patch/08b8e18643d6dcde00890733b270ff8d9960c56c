{
    "tensorflow/python/kernel_tests/array_ops/edit_distance_op_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " \"\"\"Tests for tensorflow.kernels.edit_distance_op.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import numpy as np"
            },
            "3": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from tensorflow.python.eager import def_function"
            },
            "5": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from tensorflow.python.framework import constant_op"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from tensorflow.python.framework import errors"
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from tensorflow.python.framework import ops"
            },
            "8": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from tensorflow.python.framework import sparse_tensor"
            },
            "9": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from tensorflow.python.ops import array_ops"
            },
            "10": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "                          \"to outside of the buffer for the output tensor|\""
            },
            "11": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "                          r\"Dimension -\\d+ must be >= 0\"))"
            },
            "12": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+  def testEmptyShapeWithEditDistanceRaisesError(self):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+    para = {"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        \"hypothesis_indices\": [[]],"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        \"hypothesis_values\": [\"tmp/\"],"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        \"hypothesis_shape\": [],"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        \"truth_indices\": [[]],"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        \"truth_values\": [\"\"],"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        \"truth_shape\": [],"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        \"normalize\": False,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    }"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    # Check edit distance raw op with empty shape in eager mode."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+        (errors.InvalidArgumentError, ValueError),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+        ("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+            r\"Input Hypothesis SparseTensors must have rank at least 2, but\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+            \" hypothesis_shape rank is: 0|Input SparseTensors must have rank \""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+            \"at least 2, but truth_shape rank is: 0\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+        ),"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+    ):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+      array_ops.gen_array_ops.EditDistance(**para)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+    # Check raw op with tf.function"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    @def_function.function"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    def TestFunction():"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+      \"\"\"Wrapper function for edit distance call.\"\"\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+      array_ops.gen_array_ops.EditDistance(**para)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+        ValueError,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        ("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+            \"Input Hypothesis SparseTensors must have rank at least 2, but\""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+            \" hypothesis_shape rank is: 0\""
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+        ),"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    ):"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+      TestFunction()"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+    # Check with python wrapper API"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+    hypothesis_indices = [[]]"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+    hypothesis_values = [0]"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+    hypothesis_shape = []"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+    truth_indices = [[]]"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+    truth_values = [1]"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+    truth_shape = []"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    expected_output = []  # dummy ignored"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+        ValueError,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+        ("
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+            \"Input Hypothesis SparseTensors must have rank at least 2, but\""
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+            \" hypothesis_shape rank is: 0\""
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        ),"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    ):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+      self._testEditDistance("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+          hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+          truth=(truth_indices, truth_values, truth_shape),"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+          normalize=False,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+          expected_output=expected_output,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+      )"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 290,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "75": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "   test.main()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for tensorflow.kernels.edit_distance_op.\"\"\"",
            "",
            "import numpy as np",
            "",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.ops import array_ops",
            "from tensorflow.python.platform import test",
            "",
            "",
            "def ConstantOf(x):",
            "  x = np.asarray(x)",
            "  # Convert to int64 if it's not a string or unicode",
            "  if x.dtype.char not in \"SU\":",
            "    x = np.asarray(x, dtype=np.int64)",
            "  return constant_op.constant(x)",
            "",
            "",
            "class EditDistanceTest(test.TestCase):",
            "",
            "  def _testEditDistanceST(self,",
            "                          hypothesis_st,",
            "                          truth_st,",
            "                          normalize,",
            "                          expected_output,",
            "                          expected_shape,",
            "                          expected_err_re=None):",
            "    edit_distance = array_ops.edit_distance(",
            "        hypothesis=hypothesis_st, truth=truth_st, normalize=normalize)",
            "",
            "    if expected_err_re is None:",
            "      self.assertEqual(edit_distance.get_shape(), expected_shape)",
            "      output = self.evaluate(edit_distance)",
            "      self.assertAllClose(output, expected_output)",
            "    else:",
            "      with self.assertRaisesOpError(expected_err_re):",
            "        self.evaluate(edit_distance)",
            "",
            "  def _testEditDistance(self,",
            "                        hypothesis,",
            "                        truth,",
            "                        normalize,",
            "                        expected_output,",
            "                        expected_err_re=None):",
            "    # Shape inference figures out the shape from the shape variables",
            "    # Explicit tuple() needed since zip returns an iterator in Python 3.",
            "    expected_shape = [",
            "        max(h, t) for h, t in tuple(zip(hypothesis[2], truth[2]))[:-1]",
            "    ]",
            "",
            "    # SparseTensorValue inputs.",
            "    with ops.Graph().as_default() as g, self.session(g):",
            "      # hypothesis and truth are (index, value, shape) tuples",
            "      self._testEditDistanceST(",
            "          hypothesis_st=sparse_tensor.SparseTensorValue(",
            "              *[ConstantOf(x) for x in hypothesis]),",
            "          truth_st=sparse_tensor.SparseTensorValue(",
            "              *[ConstantOf(x) for x in truth]),",
            "          normalize=normalize,",
            "          expected_output=expected_output,",
            "          expected_shape=expected_shape,",
            "          expected_err_re=expected_err_re)",
            "",
            "    # SparseTensor inputs.",
            "    with ops.Graph().as_default() as g, self.session(g):",
            "      # hypothesis and truth are (index, value, shape) tuples",
            "      self._testEditDistanceST(",
            "          hypothesis_st=sparse_tensor.SparseTensor(",
            "              *[ConstantOf(x) for x in hypothesis]),",
            "          truth_st=sparse_tensor.SparseTensor(*[ConstantOf(x) for x in truth]),",
            "          normalize=normalize,",
            "          expected_output=expected_output,",
            "          expected_shape=expected_shape,",
            "          expected_err_re=expected_err_re)",
            "",
            "  def testEditDistanceNormalized(self):",
            "    hypothesis_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]",
            "    hypothesis_values = [0, 1, 1, -1]",
            "    hypothesis_shape = [2, 2]",
            "    truth_indices = [[0, 0], [1, 0], [1, 1]]",
            "    truth_values = [0, 1, 1]",
            "    truth_shape = [2, 2]",
            "    expected_output = [1.0, 0.5]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceUnnormalized(self):",
            "    hypothesis_indices = [[0, 0], [1, 0], [1, 1]]",
            "    hypothesis_values = [10, 10, 11]",
            "    hypothesis_shape = [2, 2]",
            "    truth_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]",
            "    truth_values = [1, 2, 1, -1]",
            "    truth_shape = [2, 3]",
            "    expected_output = [2.0, 2.0]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=False,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceProperDistance(self):",
            "    # In this case, the values are individual characters stored in the",
            "    # SparseTensor (type DT_STRING)",
            "    hypothesis_indices = ([[0, i] for i, _ in enumerate(\"algorithm\")] +",
            "                          [[1, i] for i, _ in enumerate(\"altruistic\")])",
            "    hypothesis_values = [x for x in \"algorithm\"] + [x for x in \"altruistic\"]",
            "    hypothesis_shape = [2, 11]",
            "    truth_indices = ([[0, i] for i, _ in enumerate(\"altruistic\")] +",
            "                     [[1, i] for i, _ in enumerate(\"algorithm\")])",
            "    truth_values = [x for x in \"altruistic\"] + [x for x in \"algorithm\"]",
            "    truth_shape = [2, 11]",
            "    expected_unnormalized = [6.0, 6.0]",
            "    expected_normalized = [6.0 / len(\"altruistic\"), 6.0 / len(\"algorithm\")]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=False,",
            "        expected_output=expected_unnormalized)",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_normalized)",
            "",
            "  def testEditDistance3D(self):",
            "    hypothesis_indices = [[0, 0, 0], [1, 0, 0]]",
            "    hypothesis_values = [0, 1]",
            "    hypothesis_shape = [2, 1, 1]",
            "    truth_indices = [[0, 1, 0], [1, 0, 0], [1, 1, 0]]",
            "    truth_values = [0, 1, 1]",
            "    truth_shape = [2, 2, 1]",
            "    expected_output = [",
            "        [np.inf, 1.0],  # (0,0): no truth, (0,1): no hypothesis",
            "        [0.0, 1.0]",
            "    ]  # (1,0): match,    (1,1): no hypothesis",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceZeroLengthHypothesis(self):",
            "    hypothesis_indices = np.empty((0, 2), dtype=np.int64)",
            "    hypothesis_values = []",
            "    hypothesis_shape = [1, 0]",
            "    truth_indices = [[0, 0]]",
            "    truth_values = [0]",
            "    truth_shape = [1, 1]",
            "    expected_output = [1.0]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceZeroLengthTruth(self):",
            "    hypothesis_indices = [[0, 0]]",
            "    hypothesis_values = [0]",
            "    hypothesis_shape = [1, 1]",
            "    truth_indices = np.empty((0, 2), dtype=np.int64)",
            "    truth_values = []",
            "    truth_shape = [1, 0]",
            "    expected_output = [np.inf]  # Normalized, loss is 1/0 = inf",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceZeroLengthHypothesisAndTruth(self):",
            "    hypothesis_indices = np.empty((0, 2), dtype=np.int64)",
            "    hypothesis_values = []",
            "    hypothesis_shape = [1, 0]",
            "    truth_indices = np.empty((0, 2), dtype=np.int64)",
            "    truth_values = []",
            "    truth_shape = [1, 0]",
            "    expected_output = [0]  # Normalized is 0 because of exact match",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceBadIndices(self):",
            "    hypothesis_indices = np.full((3, 3), -1250999896764, dtype=np.int64)",
            "    hypothesis_values = np.zeros(3, dtype=np.int64)",
            "    hypothesis_shape = np.zeros(3, dtype=np.int64)",
            "    truth_indices = np.full((3, 3), -1250999896764, dtype=np.int64)",
            "    truth_values = np.full([3], 2, dtype=np.int64)",
            "    truth_shape = np.full([3], 2, dtype=np.int64)",
            "    expected_output = []  # dummy; ignored",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=False,",
            "        expected_output=expected_output,",
            "        expected_err_re=(r\"inner product -\\d+ which would require writing \"",
            "                         \"to outside of the buffer for the output tensor|\"",
            "                         r\"Dimension -\\d+ must be >= 0\"))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for tensorflow.kernels.edit_distance_op.\"\"\"",
            "",
            "import numpy as np",
            "from tensorflow.python.eager import def_function",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.ops import array_ops",
            "from tensorflow.python.platform import test",
            "",
            "",
            "def ConstantOf(x):",
            "  x = np.asarray(x)",
            "  # Convert to int64 if it's not a string or unicode",
            "  if x.dtype.char not in \"SU\":",
            "    x = np.asarray(x, dtype=np.int64)",
            "  return constant_op.constant(x)",
            "",
            "",
            "class EditDistanceTest(test.TestCase):",
            "",
            "  def _testEditDistanceST(self,",
            "                          hypothesis_st,",
            "                          truth_st,",
            "                          normalize,",
            "                          expected_output,",
            "                          expected_shape,",
            "                          expected_err_re=None):",
            "    edit_distance = array_ops.edit_distance(",
            "        hypothesis=hypothesis_st, truth=truth_st, normalize=normalize)",
            "",
            "    if expected_err_re is None:",
            "      self.assertEqual(edit_distance.get_shape(), expected_shape)",
            "      output = self.evaluate(edit_distance)",
            "      self.assertAllClose(output, expected_output)",
            "    else:",
            "      with self.assertRaisesOpError(expected_err_re):",
            "        self.evaluate(edit_distance)",
            "",
            "  def _testEditDistance(self,",
            "                        hypothesis,",
            "                        truth,",
            "                        normalize,",
            "                        expected_output,",
            "                        expected_err_re=None):",
            "    # Shape inference figures out the shape from the shape variables",
            "    # Explicit tuple() needed since zip returns an iterator in Python 3.",
            "    expected_shape = [",
            "        max(h, t) for h, t in tuple(zip(hypothesis[2], truth[2]))[:-1]",
            "    ]",
            "",
            "    # SparseTensorValue inputs.",
            "    with ops.Graph().as_default() as g, self.session(g):",
            "      # hypothesis and truth are (index, value, shape) tuples",
            "      self._testEditDistanceST(",
            "          hypothesis_st=sparse_tensor.SparseTensorValue(",
            "              *[ConstantOf(x) for x in hypothesis]),",
            "          truth_st=sparse_tensor.SparseTensorValue(",
            "              *[ConstantOf(x) for x in truth]),",
            "          normalize=normalize,",
            "          expected_output=expected_output,",
            "          expected_shape=expected_shape,",
            "          expected_err_re=expected_err_re)",
            "",
            "    # SparseTensor inputs.",
            "    with ops.Graph().as_default() as g, self.session(g):",
            "      # hypothesis and truth are (index, value, shape) tuples",
            "      self._testEditDistanceST(",
            "          hypothesis_st=sparse_tensor.SparseTensor(",
            "              *[ConstantOf(x) for x in hypothesis]),",
            "          truth_st=sparse_tensor.SparseTensor(*[ConstantOf(x) for x in truth]),",
            "          normalize=normalize,",
            "          expected_output=expected_output,",
            "          expected_shape=expected_shape,",
            "          expected_err_re=expected_err_re)",
            "",
            "  def testEditDistanceNormalized(self):",
            "    hypothesis_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]",
            "    hypothesis_values = [0, 1, 1, -1]",
            "    hypothesis_shape = [2, 2]",
            "    truth_indices = [[0, 0], [1, 0], [1, 1]]",
            "    truth_values = [0, 1, 1]",
            "    truth_shape = [2, 2]",
            "    expected_output = [1.0, 0.5]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceUnnormalized(self):",
            "    hypothesis_indices = [[0, 0], [1, 0], [1, 1]]",
            "    hypothesis_values = [10, 10, 11]",
            "    hypothesis_shape = [2, 2]",
            "    truth_indices = [[0, 0], [0, 1], [1, 0], [1, 1]]",
            "    truth_values = [1, 2, 1, -1]",
            "    truth_shape = [2, 3]",
            "    expected_output = [2.0, 2.0]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=False,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceProperDistance(self):",
            "    # In this case, the values are individual characters stored in the",
            "    # SparseTensor (type DT_STRING)",
            "    hypothesis_indices = ([[0, i] for i, _ in enumerate(\"algorithm\")] +",
            "                          [[1, i] for i, _ in enumerate(\"altruistic\")])",
            "    hypothesis_values = [x for x in \"algorithm\"] + [x for x in \"altruistic\"]",
            "    hypothesis_shape = [2, 11]",
            "    truth_indices = ([[0, i] for i, _ in enumerate(\"altruistic\")] +",
            "                     [[1, i] for i, _ in enumerate(\"algorithm\")])",
            "    truth_values = [x for x in \"altruistic\"] + [x for x in \"algorithm\"]",
            "    truth_shape = [2, 11]",
            "    expected_unnormalized = [6.0, 6.0]",
            "    expected_normalized = [6.0 / len(\"altruistic\"), 6.0 / len(\"algorithm\")]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=False,",
            "        expected_output=expected_unnormalized)",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_normalized)",
            "",
            "  def testEditDistance3D(self):",
            "    hypothesis_indices = [[0, 0, 0], [1, 0, 0]]",
            "    hypothesis_values = [0, 1]",
            "    hypothesis_shape = [2, 1, 1]",
            "    truth_indices = [[0, 1, 0], [1, 0, 0], [1, 1, 0]]",
            "    truth_values = [0, 1, 1]",
            "    truth_shape = [2, 2, 1]",
            "    expected_output = [",
            "        [np.inf, 1.0],  # (0,0): no truth, (0,1): no hypothesis",
            "        [0.0, 1.0]",
            "    ]  # (1,0): match,    (1,1): no hypothesis",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceZeroLengthHypothesis(self):",
            "    hypothesis_indices = np.empty((0, 2), dtype=np.int64)",
            "    hypothesis_values = []",
            "    hypothesis_shape = [1, 0]",
            "    truth_indices = [[0, 0]]",
            "    truth_values = [0]",
            "    truth_shape = [1, 1]",
            "    expected_output = [1.0]",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceZeroLengthTruth(self):",
            "    hypothesis_indices = [[0, 0]]",
            "    hypothesis_values = [0]",
            "    hypothesis_shape = [1, 1]",
            "    truth_indices = np.empty((0, 2), dtype=np.int64)",
            "    truth_values = []",
            "    truth_shape = [1, 0]",
            "    expected_output = [np.inf]  # Normalized, loss is 1/0 = inf",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceZeroLengthHypothesisAndTruth(self):",
            "    hypothesis_indices = np.empty((0, 2), dtype=np.int64)",
            "    hypothesis_values = []",
            "    hypothesis_shape = [1, 0]",
            "    truth_indices = np.empty((0, 2), dtype=np.int64)",
            "    truth_values = []",
            "    truth_shape = [1, 0]",
            "    expected_output = [0]  # Normalized is 0 because of exact match",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=True,",
            "        expected_output=expected_output)",
            "",
            "  def testEditDistanceBadIndices(self):",
            "    hypothesis_indices = np.full((3, 3), -1250999896764, dtype=np.int64)",
            "    hypothesis_values = np.zeros(3, dtype=np.int64)",
            "    hypothesis_shape = np.zeros(3, dtype=np.int64)",
            "    truth_indices = np.full((3, 3), -1250999896764, dtype=np.int64)",
            "    truth_values = np.full([3], 2, dtype=np.int64)",
            "    truth_shape = np.full([3], 2, dtype=np.int64)",
            "    expected_output = []  # dummy; ignored",
            "",
            "    self._testEditDistance(",
            "        hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "        truth=(truth_indices, truth_values, truth_shape),",
            "        normalize=False,",
            "        expected_output=expected_output,",
            "        expected_err_re=(r\"inner product -\\d+ which would require writing \"",
            "                         \"to outside of the buffer for the output tensor|\"",
            "                         r\"Dimension -\\d+ must be >= 0\"))",
            "",
            "  def testEmptyShapeWithEditDistanceRaisesError(self):",
            "    para = {",
            "        \"hypothesis_indices\": [[]],",
            "        \"hypothesis_values\": [\"tmp/\"],",
            "        \"hypothesis_shape\": [],",
            "        \"truth_indices\": [[]],",
            "        \"truth_values\": [\"\"],",
            "        \"truth_shape\": [],",
            "        \"normalize\": False,",
            "    }",
            "",
            "    # Check edit distance raw op with empty shape in eager mode.",
            "    with self.assertRaisesRegex(",
            "        (errors.InvalidArgumentError, ValueError),",
            "        (",
            "            r\"Input Hypothesis SparseTensors must have rank at least 2, but\"",
            "            \" hypothesis_shape rank is: 0|Input SparseTensors must have rank \"",
            "            \"at least 2, but truth_shape rank is: 0\"",
            "        ),",
            "    ):",
            "      array_ops.gen_array_ops.EditDistance(**para)",
            "",
            "    # Check raw op with tf.function",
            "    @def_function.function",
            "    def TestFunction():",
            "      \"\"\"Wrapper function for edit distance call.\"\"\"",
            "      array_ops.gen_array_ops.EditDistance(**para)",
            "",
            "    with self.assertRaisesRegex(",
            "        ValueError,",
            "        (",
            "            \"Input Hypothesis SparseTensors must have rank at least 2, but\"",
            "            \" hypothesis_shape rank is: 0\"",
            "        ),",
            "    ):",
            "      TestFunction()",
            "",
            "    # Check with python wrapper API",
            "    hypothesis_indices = [[]]",
            "    hypothesis_values = [0]",
            "    hypothesis_shape = []",
            "    truth_indices = [[]]",
            "    truth_values = [1]",
            "    truth_shape = []",
            "    expected_output = []  # dummy ignored",
            "",
            "    with self.assertRaisesRegex(",
            "        ValueError,",
            "        (",
            "            \"Input Hypothesis SparseTensors must have rank at least 2, but\"",
            "            \" hypothesis_shape rank is: 0\"",
            "        ),",
            "    ):",
            "      self._testEditDistance(",
            "          hypothesis=(hypothesis_indices, hypothesis_values, hypothesis_shape),",
            "          truth=(truth_indices, truth_values, truth_shape),",
            "          normalize=False,",
            "          expected_output=expected_output,",
            "      )",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "18": []
        },
        "addLocation": []
    }
}