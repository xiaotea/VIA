{
    "django/db/backends/mysql/operations.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             return f\"EXTRACT({lookup_type} FROM {sql})\", params"
            },
            "1": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     def date_trunc_sql(self, lookup_type, sql, params, tzname=None):"
            },
            "3": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "5": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         fields = {"
            },
            "6": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             \"year\": \"%Y-01-01\","
            },
            "7": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "             \"month\": \"%Y-%m-01\","
            },
            "8": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         tzname, sign, offset = split_tzname_delta(tzname)"
            },
            "9": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         return f\"{sign}{offset}\" if offset else tzname"
            },
            "10": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _convert_field_to_tz(self, sql, params, tzname):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+    def _convert_sql_to_tz(self, sql, params, tzname):"
            },
            "13": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         if tzname and settings.USE_TZ and self.connection.timezone_name != tzname:"
            },
            "14": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "             return f\"CONVERT_TZ({sql}, %s, %s)\", ("
            },
            "15": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                 *params,"
            },
            "16": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         return sql, params"
            },
            "17": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     def datetime_cast_date_sql(self, sql, params, tzname):"
            },
            "19": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "21": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         return f\"DATE({sql})\", params"
            },
            "22": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     def datetime_cast_time_sql(self, sql, params, tzname):"
            },
            "24": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "26": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         return f\"TIME({sql})\", params"
            },
            "27": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "     def datetime_extract_sql(self, lookup_type, sql, params, tzname):"
            },
            "29": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "31": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         return self.date_extract_sql(lookup_type, sql, params)"
            },
            "32": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "     def datetime_trunc_sql(self, lookup_type, sql, params, tzname):"
            },
            "34": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "36": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         fields = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"]"
            },
            "37": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         format = (\"%Y-\", \"%m\", \"-%d\", \" %H:\", \"%i\", \":%s\")"
            },
            "38": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         format_def = (\"0000-\", \"01\", \"-01\", \" 00:\", \"00\", \":00\")"
            },
            "39": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         return sql, params"
            },
            "40": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     def time_trunc_sql(self, lookup_type, sql, params, tzname=None):"
            },
            "42": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "44": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         fields = {"
            },
            "45": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "             \"hour\": \"%H:00:00\","
            },
            "46": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             \"minute\": \"%H:%i:00\","
            }
        },
        "frontPatchFile": [
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.db.backends.base.operations import BaseDatabaseOperations",
            "from django.db.backends.utils import split_tzname_delta",
            "from django.db.models import Exists, ExpressionWrapper, Lookup",
            "from django.db.models.constants import OnConflict",
            "from django.utils import timezone",
            "from django.utils.encoding import force_str",
            "from django.utils.regex_helper import _lazy_re_compile",
            "",
            "",
            "class DatabaseOperations(BaseDatabaseOperations):",
            "    compiler_module = \"django.db.backends.mysql.compiler\"",
            "",
            "    # MySQL stores positive fields as UNSIGNED ints.",
            "    integer_field_ranges = {",
            "        **BaseDatabaseOperations.integer_field_ranges,",
            "        \"PositiveSmallIntegerField\": (0, 65535),",
            "        \"PositiveIntegerField\": (0, 4294967295),",
            "        \"PositiveBigIntegerField\": (0, 18446744073709551615),",
            "    }",
            "    cast_data_types = {",
            "        \"AutoField\": \"signed integer\",",
            "        \"BigAutoField\": \"signed integer\",",
            "        \"SmallAutoField\": \"signed integer\",",
            "        \"CharField\": \"char(%(max_length)s)\",",
            "        \"DecimalField\": \"decimal(%(max_digits)s, %(decimal_places)s)\",",
            "        \"TextField\": \"char\",",
            "        \"IntegerField\": \"signed integer\",",
            "        \"BigIntegerField\": \"signed integer\",",
            "        \"SmallIntegerField\": \"signed integer\",",
            "        \"PositiveBigIntegerField\": \"unsigned integer\",",
            "        \"PositiveIntegerField\": \"unsigned integer\",",
            "        \"PositiveSmallIntegerField\": \"unsigned integer\",",
            "        \"DurationField\": \"signed integer\",",
            "    }",
            "    cast_char_field_without_max_length = \"char\"",
            "    explain_prefix = \"EXPLAIN\"",
            "",
            "    # EXTRACT format cannot be passed in parameters.",
            "    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")",
            "",
            "    def date_extract_sql(self, lookup_type, sql, params):",
            "        # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html",
            "        if lookup_type == \"week_day\":",
            "            # DAYOFWEEK() returns an integer, 1-7, Sunday=1.",
            "            return f\"DAYOFWEEK({sql})\", params",
            "        elif lookup_type == \"iso_week_day\":",
            "            # WEEKDAY() returns an integer, 0-6, Monday=0.",
            "            return f\"WEEKDAY({sql}) + 1\", params",
            "        elif lookup_type == \"week\":",
            "            # Override the value of default_week_format for consistency with",
            "            # other database backends.",
            "            # Mode 3: Monday, 1-53, with 4 or more days this year.",
            "            return f\"WEEK({sql}, 3)\", params",
            "        elif lookup_type == \"iso_year\":",
            "            # Get the year part from the YEARWEEK function, which returns a",
            "            # number as year * 100 + week.",
            "            return f\"TRUNCATE(YEARWEEK({sql}, 3), -2) / 100\", params",
            "        else:",
            "            # EXTRACT returns 1-53 based on ISO-8601 for the week number.",
            "            lookup_type = lookup_type.upper()",
            "            if not self._extract_format_re.fullmatch(lookup_type):",
            "                raise ValueError(f\"Invalid loookup type: {lookup_type!r}\")",
            "            return f\"EXTRACT({lookup_type} FROM {sql})\", params",
            "",
            "    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        fields = {",
            "            \"year\": \"%Y-01-01\",",
            "            \"month\": \"%Y-%m-01\",",
            "        }",
            "        if lookup_type in fields:",
            "            format_str = fields[lookup_type]",
            "            return f\"CAST(DATE_FORMAT({sql}, %s) AS DATE)\", (*params, format_str)",
            "        elif lookup_type == \"quarter\":",
            "            return (",
            "                f\"MAKEDATE(YEAR({sql}), 1) + \"",
            "                f\"INTERVAL QUARTER({sql}) QUARTER - INTERVAL 1 QUARTER\",",
            "                (*params, *params),",
            "            )",
            "        elif lookup_type == \"week\":",
            "            return f\"DATE_SUB({sql}, INTERVAL WEEKDAY({sql}) DAY)\", (*params, *params)",
            "        else:",
            "            return f\"DATE({sql})\", params",
            "",
            "    def _prepare_tzname_delta(self, tzname):",
            "        tzname, sign, offset = split_tzname_delta(tzname)",
            "        return f\"{sign}{offset}\" if offset else tzname",
            "",
            "    def _convert_field_to_tz(self, sql, params, tzname):",
            "        if tzname and settings.USE_TZ and self.connection.timezone_name != tzname:",
            "            return f\"CONVERT_TZ({sql}, %s, %s)\", (",
            "                *params,",
            "                self.connection.timezone_name,",
            "                self._prepare_tzname_delta(tzname),",
            "            )",
            "        return sql, params",
            "",
            "    def datetime_cast_date_sql(self, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        return f\"DATE({sql})\", params",
            "",
            "    def datetime_cast_time_sql(self, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        return f\"TIME({sql})\", params",
            "",
            "    def datetime_extract_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        return self.date_extract_sql(lookup_type, sql, params)",
            "",
            "    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        fields = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"]",
            "        format = (\"%Y-\", \"%m\", \"-%d\", \" %H:\", \"%i\", \":%s\")",
            "        format_def = (\"0000-\", \"01\", \"-01\", \" 00:\", \"00\", \":00\")",
            "        if lookup_type == \"quarter\":",
            "            return (",
            "                f\"CAST(DATE_FORMAT(MAKEDATE(YEAR({sql}), 1) + \"",
            "                f\"INTERVAL QUARTER({sql}) QUARTER - \"",
            "                f\"INTERVAL 1 QUARTER, %s) AS DATETIME)\"",
            "            ), (*params, *params, \"%Y-%m-01 00:00:00\")",
            "        if lookup_type == \"week\":",
            "            return (",
            "                f\"CAST(DATE_FORMAT(\"",
            "                f\"DATE_SUB({sql}, INTERVAL WEEKDAY({sql}) DAY), %s) AS DATETIME)\"",
            "            ), (*params, *params, \"%Y-%m-%d 00:00:00\")",
            "        try:",
            "            i = fields.index(lookup_type) + 1",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            format_str = \"\".join(format[:i] + format_def[i:])",
            "            return f\"CAST(DATE_FORMAT({sql}, %s) AS DATETIME)\", (*params, format_str)",
            "        return sql, params",
            "",
            "    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        fields = {",
            "            \"hour\": \"%H:00:00\",",
            "            \"minute\": \"%H:%i:00\",",
            "            \"second\": \"%H:%i:%s\",",
            "        }",
            "        if lookup_type in fields:",
            "            format_str = fields[lookup_type]",
            "            return f\"CAST(DATE_FORMAT({sql}, %s) AS TIME)\", (*params, format_str)",
            "        else:",
            "            return f\"TIME({sql})\", params",
            "",
            "    def fetch_returned_insert_rows(self, cursor):",
            "        \"\"\"",
            "        Given a cursor object that has just performed an INSERT...RETURNING",
            "        statement into a table, return the tuple of returned data.",
            "        \"\"\"",
            "        return cursor.fetchall()",
            "",
            "    def format_for_duration_arithmetic(self, sql):",
            "        return \"INTERVAL %s MICROSECOND\" % sql",
            "",
            "    def force_no_ordering(self):",
            "        \"\"\"",
            "        \"ORDER BY NULL\" prevents MySQL from implicitly ordering by grouped",
            "        columns. If no ordering would otherwise be applied, we don't want any",
            "        implicit sorting going on.",
            "        \"\"\"",
            "        return [(None, (\"NULL\", [], False))]",
            "",
            "    def adapt_decimalfield_value(self, value, max_digits=None, decimal_places=None):",
            "        return value",
            "",
            "    def last_executed_query(self, cursor, sql, params):",
            "        # With MySQLdb, cursor objects have an (undocumented) \"_executed\"",
            "        # attribute where the exact query sent to the database is saved.",
            "        # See MySQLdb/cursors.py in the source distribution.",
            "        # MySQLdb returns string, PyMySQL bytes.",
            "        return force_str(getattr(cursor, \"_executed\", None), errors=\"replace\")",
            "",
            "    def no_limit_value(self):",
            "        # 2**64 - 1, as recommended by the MySQL documentation",
            "        return 18446744073709551615",
            "",
            "    def quote_name(self, name):",
            "        if name.startswith(\"`\") and name.endswith(\"`\"):",
            "            return name  # Quoting once is enough.",
            "        return \"`%s`\" % name",
            "",
            "    def return_insert_columns(self, fields):",
            "        # MySQL and MariaDB < 10.5.0 don't support an INSERT...RETURNING",
            "        # statement.",
            "        if not fields:",
            "            return \"\", ()",
            "        columns = [",
            "            \"%s.%s\"",
            "            % (",
            "                self.quote_name(field.model._meta.db_table),",
            "                self.quote_name(field.column),",
            "            )",
            "            for field in fields",
            "        ]",
            "        return \"RETURNING %s\" % \", \".join(columns), ()",
            "",
            "    def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):",
            "        if not tables:",
            "            return []",
            "",
            "        sql = [\"SET FOREIGN_KEY_CHECKS = 0;\"]",
            "        if reset_sequences:",
            "            # It's faster to TRUNCATE tables that require a sequence reset",
            "            # since ALTER TABLE AUTO_INCREMENT is slower than TRUNCATE.",
            "            sql.extend(",
            "                \"%s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"TRUNCATE\"),",
            "                    style.SQL_FIELD(self.quote_name(table_name)),",
            "                )",
            "                for table_name in tables",
            "            )",
            "        else:",
            "            # Otherwise issue a simple DELETE since it's faster than TRUNCATE",
            "            # and preserves sequences.",
            "            sql.extend(",
            "                \"%s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"DELETE\"),",
            "                    style.SQL_KEYWORD(\"FROM\"),",
            "                    style.SQL_FIELD(self.quote_name(table_name)),",
            "                )",
            "                for table_name in tables",
            "            )",
            "        sql.append(\"SET FOREIGN_KEY_CHECKS = 1;\")",
            "        return sql",
            "",
            "    def sequence_reset_by_name_sql(self, style, sequences):",
            "        return [",
            "            \"%s %s %s %s = 1;\"",
            "            % (",
            "                style.SQL_KEYWORD(\"ALTER\"),",
            "                style.SQL_KEYWORD(\"TABLE\"),",
            "                style.SQL_FIELD(self.quote_name(sequence_info[\"table\"])),",
            "                style.SQL_FIELD(\"AUTO_INCREMENT\"),",
            "            )",
            "            for sequence_info in sequences",
            "        ]",
            "",
            "    def validate_autopk_value(self, value):",
            "        # Zero in AUTO_INCREMENT field does not work without the",
            "        # NO_AUTO_VALUE_ON_ZERO SQL mode.",
            "        if value == 0 and not self.connection.features.allows_auto_pk_0:",
            "            raise ValueError(",
            "                \"The database backend does not accept 0 as a value for AutoField.\"",
            "            )",
            "        return value",
            "",
            "    def adapt_datetimefield_value(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        # MySQL doesn't support tz-aware datetimes",
            "        if timezone.is_aware(value):",
            "            if settings.USE_TZ:",
            "                value = timezone.make_naive(value, self.connection.timezone)",
            "            else:",
            "                raise ValueError(",
            "                    \"MySQL backend does not support timezone-aware datetimes when \"",
            "                    \"USE_TZ is False.\"",
            "                )",
            "        return str(value)",
            "",
            "    def adapt_timefield_value(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        # MySQL doesn't support tz-aware times",
            "        if timezone.is_aware(value):",
            "            raise ValueError(\"MySQL backend does not support timezone-aware times.\")",
            "",
            "        return value.isoformat(timespec=\"microseconds\")",
            "",
            "    def max_name_length(self):",
            "        return 64",
            "",
            "    def pk_default_value(self):",
            "        return \"NULL\"",
            "",
            "    def bulk_insert_sql(self, fields, placeholder_rows):",
            "        placeholder_rows_sql = (\", \".join(row) for row in placeholder_rows)",
            "        values_sql = \", \".join(\"(%s)\" % sql for sql in placeholder_rows_sql)",
            "        return \"VALUES \" + values_sql",
            "",
            "    def combine_expression(self, connector, sub_expressions):",
            "        if connector == \"^\":",
            "            return \"POW(%s)\" % \",\".join(sub_expressions)",
            "        # Convert the result to a signed integer since MySQL's binary operators",
            "        # return an unsigned integer.",
            "        elif connector in (\"&\", \"|\", \"<<\", \"#\"):",
            "            connector = \"^\" if connector == \"#\" else connector",
            "            return \"CONVERT(%s, SIGNED)\" % connector.join(sub_expressions)",
            "        elif connector == \">>\":",
            "            lhs, rhs = sub_expressions",
            "            return \"FLOOR(%(lhs)s / POW(2, %(rhs)s))\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        return super().combine_expression(connector, sub_expressions)",
            "",
            "    def get_db_converters(self, expression):",
            "        converters = super().get_db_converters(expression)",
            "        internal_type = expression.output_field.get_internal_type()",
            "        if internal_type == \"BooleanField\":",
            "            converters.append(self.convert_booleanfield_value)",
            "        elif internal_type == \"DateTimeField\":",
            "            if settings.USE_TZ:",
            "                converters.append(self.convert_datetimefield_value)",
            "        elif internal_type == \"UUIDField\":",
            "            converters.append(self.convert_uuidfield_value)",
            "        return converters",
            "",
            "    def convert_booleanfield_value(self, value, expression, connection):",
            "        if value in (0, 1):",
            "            value = bool(value)",
            "        return value",
            "",
            "    def convert_datetimefield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = timezone.make_aware(value, self.connection.timezone)",
            "        return value",
            "",
            "    def convert_uuidfield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = uuid.UUID(value)",
            "        return value",
            "",
            "    def binary_placeholder_sql(self, value):",
            "        return (",
            "            \"_binary %s\" if value is not None and not hasattr(value, \"as_sql\") else \"%s\"",
            "        )",
            "",
            "    def subtract_temporals(self, internal_type, lhs, rhs):",
            "        lhs_sql, lhs_params = lhs",
            "        rhs_sql, rhs_params = rhs",
            "        if internal_type == \"TimeField\":",
            "            if self.connection.mysql_is_mariadb:",
            "                # MariaDB includes the microsecond component in TIME_TO_SEC as",
            "                # a decimal. MySQL returns an integer without microseconds.",
            "                return (",
            "                    \"CAST((TIME_TO_SEC(%(lhs)s) - TIME_TO_SEC(%(rhs)s)) \"",
            "                    \"* 1000000 AS SIGNED)\"",
            "                ) % {",
            "                    \"lhs\": lhs_sql,",
            "                    \"rhs\": rhs_sql,",
            "                }, (",
            "                    *lhs_params,",
            "                    *rhs_params,",
            "                )",
            "            return (",
            "                \"((TIME_TO_SEC(%(lhs)s) * 1000000 + MICROSECOND(%(lhs)s)) -\"",
            "                \" (TIME_TO_SEC(%(rhs)s) * 1000000 + MICROSECOND(%(rhs)s)))\"",
            "            ) % {\"lhs\": lhs_sql, \"rhs\": rhs_sql}, tuple(lhs_params) * 2 + tuple(",
            "                rhs_params",
            "            ) * 2",
            "        params = (*rhs_params, *lhs_params)",
            "        return \"TIMESTAMPDIFF(MICROSECOND, %s, %s)\" % (rhs_sql, lhs_sql), params",
            "",
            "    def explain_query_prefix(self, format=None, **options):",
            "        # Alias MySQL's TRADITIONAL to TEXT for consistency with other backends.",
            "        if format and format.upper() == \"TEXT\":",
            "            format = \"TRADITIONAL\"",
            "        elif (",
            "            not format and \"TREE\" in self.connection.features.supported_explain_formats",
            "        ):",
            "            # Use TREE by default (if supported) as it's more informative.",
            "            format = \"TREE\"",
            "        analyze = options.pop(\"analyze\", False)",
            "        prefix = super().explain_query_prefix(format, **options)",
            "        if analyze and self.connection.features.supports_explain_analyze:",
            "            # MariaDB uses ANALYZE instead of EXPLAIN ANALYZE.",
            "            prefix = (",
            "                \"ANALYZE\" if self.connection.mysql_is_mariadb else prefix + \" ANALYZE\"",
            "            )",
            "        if format and not (analyze and not self.connection.mysql_is_mariadb):",
            "            # Only MariaDB supports the analyze option with formats.",
            "            prefix += \" FORMAT=%s\" % format",
            "        return prefix",
            "",
            "    def regex_lookup(self, lookup_type):",
            "        # REGEXP_LIKE doesn't exist in MariaDB.",
            "        if self.connection.mysql_is_mariadb:",
            "            if lookup_type == \"regex\":",
            "                return \"%s REGEXP BINARY %s\"",
            "            return \"%s REGEXP %s\"",
            "",
            "        match_option = \"c\" if lookup_type == \"regex\" else \"i\"",
            "        return \"REGEXP_LIKE(%%s, %%s, '%s')\" % match_option",
            "",
            "    def insert_statement(self, on_conflict=None):",
            "        if on_conflict == OnConflict.IGNORE:",
            "            return \"INSERT IGNORE INTO\"",
            "        return super().insert_statement(on_conflict=on_conflict)",
            "",
            "    def lookup_cast(self, lookup_type, internal_type=None):",
            "        lookup = \"%s\"",
            "        if internal_type == \"JSONField\":",
            "            if self.connection.mysql_is_mariadb or lookup_type in (",
            "                \"iexact\",",
            "                \"contains\",",
            "                \"icontains\",",
            "                \"startswith\",",
            "                \"istartswith\",",
            "                \"endswith\",",
            "                \"iendswith\",",
            "                \"regex\",",
            "                \"iregex\",",
            "            ):",
            "                lookup = \"JSON_UNQUOTE(%s)\"",
            "        return lookup",
            "",
            "    def conditional_expression_supported_in_where_clause(self, expression):",
            "        # MySQL ignores indexes with boolean fields unless they're compared",
            "        # directly to a boolean value.",
            "        if isinstance(expression, (Exists, Lookup)):",
            "            return True",
            "        if isinstance(expression, ExpressionWrapper) and expression.conditional:",
            "            return self.conditional_expression_supported_in_where_clause(",
            "                expression.expression",
            "            )",
            "        if getattr(expression, \"conditional\", False):",
            "            return False",
            "        return super().conditional_expression_supported_in_where_clause(expression)",
            "",
            "    def on_conflict_suffix_sql(self, fields, on_conflict, update_fields, unique_fields):",
            "        if on_conflict == OnConflict.UPDATE:",
            "            conflict_suffix_sql = \"ON DUPLICATE KEY UPDATE %(fields)s\"",
            "            # The use of VALUES() is deprecated in MySQL 8.0.20+. Instead, use",
            "            # aliases for the new row and its columns available in MySQL",
            "            # 8.0.19+.",
            "            if not self.connection.mysql_is_mariadb:",
            "                if self.connection.mysql_version >= (8, 0, 19):",
            "                    conflict_suffix_sql = f\"AS new {conflict_suffix_sql}\"",
            "                    field_sql = \"%(field)s = new.%(field)s\"",
            "                else:",
            "                    field_sql = \"%(field)s = VALUES(%(field)s)\"",
            "            # Use VALUE() on MariaDB.",
            "            else:",
            "                field_sql = \"%(field)s = VALUE(%(field)s)\"",
            "",
            "            fields = \", \".join(",
            "                [",
            "                    field_sql % {\"field\": field}",
            "                    for field in map(self.quote_name, update_fields)",
            "                ]",
            "            )",
            "            return conflict_suffix_sql % {\"fields\": fields}",
            "        return super().on_conflict_suffix_sql(",
            "            fields,",
            "            on_conflict,",
            "            update_fields,",
            "            unique_fields,",
            "        )"
        ],
        "afterPatchFile": [
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.db.backends.base.operations import BaseDatabaseOperations",
            "from django.db.backends.utils import split_tzname_delta",
            "from django.db.models import Exists, ExpressionWrapper, Lookup",
            "from django.db.models.constants import OnConflict",
            "from django.utils import timezone",
            "from django.utils.encoding import force_str",
            "from django.utils.regex_helper import _lazy_re_compile",
            "",
            "",
            "class DatabaseOperations(BaseDatabaseOperations):",
            "    compiler_module = \"django.db.backends.mysql.compiler\"",
            "",
            "    # MySQL stores positive fields as UNSIGNED ints.",
            "    integer_field_ranges = {",
            "        **BaseDatabaseOperations.integer_field_ranges,",
            "        \"PositiveSmallIntegerField\": (0, 65535),",
            "        \"PositiveIntegerField\": (0, 4294967295),",
            "        \"PositiveBigIntegerField\": (0, 18446744073709551615),",
            "    }",
            "    cast_data_types = {",
            "        \"AutoField\": \"signed integer\",",
            "        \"BigAutoField\": \"signed integer\",",
            "        \"SmallAutoField\": \"signed integer\",",
            "        \"CharField\": \"char(%(max_length)s)\",",
            "        \"DecimalField\": \"decimal(%(max_digits)s, %(decimal_places)s)\",",
            "        \"TextField\": \"char\",",
            "        \"IntegerField\": \"signed integer\",",
            "        \"BigIntegerField\": \"signed integer\",",
            "        \"SmallIntegerField\": \"signed integer\",",
            "        \"PositiveBigIntegerField\": \"unsigned integer\",",
            "        \"PositiveIntegerField\": \"unsigned integer\",",
            "        \"PositiveSmallIntegerField\": \"unsigned integer\",",
            "        \"DurationField\": \"signed integer\",",
            "    }",
            "    cast_char_field_without_max_length = \"char\"",
            "    explain_prefix = \"EXPLAIN\"",
            "",
            "    # EXTRACT format cannot be passed in parameters.",
            "    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")",
            "",
            "    def date_extract_sql(self, lookup_type, sql, params):",
            "        # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html",
            "        if lookup_type == \"week_day\":",
            "            # DAYOFWEEK() returns an integer, 1-7, Sunday=1.",
            "            return f\"DAYOFWEEK({sql})\", params",
            "        elif lookup_type == \"iso_week_day\":",
            "            # WEEKDAY() returns an integer, 0-6, Monday=0.",
            "            return f\"WEEKDAY({sql}) + 1\", params",
            "        elif lookup_type == \"week\":",
            "            # Override the value of default_week_format for consistency with",
            "            # other database backends.",
            "            # Mode 3: Monday, 1-53, with 4 or more days this year.",
            "            return f\"WEEK({sql}, 3)\", params",
            "        elif lookup_type == \"iso_year\":",
            "            # Get the year part from the YEARWEEK function, which returns a",
            "            # number as year * 100 + week.",
            "            return f\"TRUNCATE(YEARWEEK({sql}, 3), -2) / 100\", params",
            "        else:",
            "            # EXTRACT returns 1-53 based on ISO-8601 for the week number.",
            "            lookup_type = lookup_type.upper()",
            "            if not self._extract_format_re.fullmatch(lookup_type):",
            "                raise ValueError(f\"Invalid loookup type: {lookup_type!r}\")",
            "            return f\"EXTRACT({lookup_type} FROM {sql})\", params",
            "",
            "    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        fields = {",
            "            \"year\": \"%Y-01-01\",",
            "            \"month\": \"%Y-%m-01\",",
            "        }",
            "        if lookup_type in fields:",
            "            format_str = fields[lookup_type]",
            "            return f\"CAST(DATE_FORMAT({sql}, %s) AS DATE)\", (*params, format_str)",
            "        elif lookup_type == \"quarter\":",
            "            return (",
            "                f\"MAKEDATE(YEAR({sql}), 1) + \"",
            "                f\"INTERVAL QUARTER({sql}) QUARTER - INTERVAL 1 QUARTER\",",
            "                (*params, *params),",
            "            )",
            "        elif lookup_type == \"week\":",
            "            return f\"DATE_SUB({sql}, INTERVAL WEEKDAY({sql}) DAY)\", (*params, *params)",
            "        else:",
            "            return f\"DATE({sql})\", params",
            "",
            "    def _prepare_tzname_delta(self, tzname):",
            "        tzname, sign, offset = split_tzname_delta(tzname)",
            "        return f\"{sign}{offset}\" if offset else tzname",
            "",
            "    def _convert_sql_to_tz(self, sql, params, tzname):",
            "        if tzname and settings.USE_TZ and self.connection.timezone_name != tzname:",
            "            return f\"CONVERT_TZ({sql}, %s, %s)\", (",
            "                *params,",
            "                self.connection.timezone_name,",
            "                self._prepare_tzname_delta(tzname),",
            "            )",
            "        return sql, params",
            "",
            "    def datetime_cast_date_sql(self, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        return f\"DATE({sql})\", params",
            "",
            "    def datetime_cast_time_sql(self, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        return f\"TIME({sql})\", params",
            "",
            "    def datetime_extract_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        return self.date_extract_sql(lookup_type, sql, params)",
            "",
            "    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        fields = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"]",
            "        format = (\"%Y-\", \"%m\", \"-%d\", \" %H:\", \"%i\", \":%s\")",
            "        format_def = (\"0000-\", \"01\", \"-01\", \" 00:\", \"00\", \":00\")",
            "        if lookup_type == \"quarter\":",
            "            return (",
            "                f\"CAST(DATE_FORMAT(MAKEDATE(YEAR({sql}), 1) + \"",
            "                f\"INTERVAL QUARTER({sql}) QUARTER - \"",
            "                f\"INTERVAL 1 QUARTER, %s) AS DATETIME)\"",
            "            ), (*params, *params, \"%Y-%m-01 00:00:00\")",
            "        if lookup_type == \"week\":",
            "            return (",
            "                f\"CAST(DATE_FORMAT(\"",
            "                f\"DATE_SUB({sql}, INTERVAL WEEKDAY({sql}) DAY), %s) AS DATETIME)\"",
            "            ), (*params, *params, \"%Y-%m-%d 00:00:00\")",
            "        try:",
            "            i = fields.index(lookup_type) + 1",
            "        except ValueError:",
            "            pass",
            "        else:",
            "            format_str = \"\".join(format[:i] + format_def[i:])",
            "            return f\"CAST(DATE_FORMAT({sql}, %s) AS DATETIME)\", (*params, format_str)",
            "        return sql, params",
            "",
            "    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        fields = {",
            "            \"hour\": \"%H:00:00\",",
            "            \"minute\": \"%H:%i:00\",",
            "            \"second\": \"%H:%i:%s\",",
            "        }",
            "        if lookup_type in fields:",
            "            format_str = fields[lookup_type]",
            "            return f\"CAST(DATE_FORMAT({sql}, %s) AS TIME)\", (*params, format_str)",
            "        else:",
            "            return f\"TIME({sql})\", params",
            "",
            "    def fetch_returned_insert_rows(self, cursor):",
            "        \"\"\"",
            "        Given a cursor object that has just performed an INSERT...RETURNING",
            "        statement into a table, return the tuple of returned data.",
            "        \"\"\"",
            "        return cursor.fetchall()",
            "",
            "    def format_for_duration_arithmetic(self, sql):",
            "        return \"INTERVAL %s MICROSECOND\" % sql",
            "",
            "    def force_no_ordering(self):",
            "        \"\"\"",
            "        \"ORDER BY NULL\" prevents MySQL from implicitly ordering by grouped",
            "        columns. If no ordering would otherwise be applied, we don't want any",
            "        implicit sorting going on.",
            "        \"\"\"",
            "        return [(None, (\"NULL\", [], False))]",
            "",
            "    def adapt_decimalfield_value(self, value, max_digits=None, decimal_places=None):",
            "        return value",
            "",
            "    def last_executed_query(self, cursor, sql, params):",
            "        # With MySQLdb, cursor objects have an (undocumented) \"_executed\"",
            "        # attribute where the exact query sent to the database is saved.",
            "        # See MySQLdb/cursors.py in the source distribution.",
            "        # MySQLdb returns string, PyMySQL bytes.",
            "        return force_str(getattr(cursor, \"_executed\", None), errors=\"replace\")",
            "",
            "    def no_limit_value(self):",
            "        # 2**64 - 1, as recommended by the MySQL documentation",
            "        return 18446744073709551615",
            "",
            "    def quote_name(self, name):",
            "        if name.startswith(\"`\") and name.endswith(\"`\"):",
            "            return name  # Quoting once is enough.",
            "        return \"`%s`\" % name",
            "",
            "    def return_insert_columns(self, fields):",
            "        # MySQL and MariaDB < 10.5.0 don't support an INSERT...RETURNING",
            "        # statement.",
            "        if not fields:",
            "            return \"\", ()",
            "        columns = [",
            "            \"%s.%s\"",
            "            % (",
            "                self.quote_name(field.model._meta.db_table),",
            "                self.quote_name(field.column),",
            "            )",
            "            for field in fields",
            "        ]",
            "        return \"RETURNING %s\" % \", \".join(columns), ()",
            "",
            "    def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):",
            "        if not tables:",
            "            return []",
            "",
            "        sql = [\"SET FOREIGN_KEY_CHECKS = 0;\"]",
            "        if reset_sequences:",
            "            # It's faster to TRUNCATE tables that require a sequence reset",
            "            # since ALTER TABLE AUTO_INCREMENT is slower than TRUNCATE.",
            "            sql.extend(",
            "                \"%s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"TRUNCATE\"),",
            "                    style.SQL_FIELD(self.quote_name(table_name)),",
            "                )",
            "                for table_name in tables",
            "            )",
            "        else:",
            "            # Otherwise issue a simple DELETE since it's faster than TRUNCATE",
            "            # and preserves sequences.",
            "            sql.extend(",
            "                \"%s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"DELETE\"),",
            "                    style.SQL_KEYWORD(\"FROM\"),",
            "                    style.SQL_FIELD(self.quote_name(table_name)),",
            "                )",
            "                for table_name in tables",
            "            )",
            "        sql.append(\"SET FOREIGN_KEY_CHECKS = 1;\")",
            "        return sql",
            "",
            "    def sequence_reset_by_name_sql(self, style, sequences):",
            "        return [",
            "            \"%s %s %s %s = 1;\"",
            "            % (",
            "                style.SQL_KEYWORD(\"ALTER\"),",
            "                style.SQL_KEYWORD(\"TABLE\"),",
            "                style.SQL_FIELD(self.quote_name(sequence_info[\"table\"])),",
            "                style.SQL_FIELD(\"AUTO_INCREMENT\"),",
            "            )",
            "            for sequence_info in sequences",
            "        ]",
            "",
            "    def validate_autopk_value(self, value):",
            "        # Zero in AUTO_INCREMENT field does not work without the",
            "        # NO_AUTO_VALUE_ON_ZERO SQL mode.",
            "        if value == 0 and not self.connection.features.allows_auto_pk_0:",
            "            raise ValueError(",
            "                \"The database backend does not accept 0 as a value for AutoField.\"",
            "            )",
            "        return value",
            "",
            "    def adapt_datetimefield_value(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        # MySQL doesn't support tz-aware datetimes",
            "        if timezone.is_aware(value):",
            "            if settings.USE_TZ:",
            "                value = timezone.make_naive(value, self.connection.timezone)",
            "            else:",
            "                raise ValueError(",
            "                    \"MySQL backend does not support timezone-aware datetimes when \"",
            "                    \"USE_TZ is False.\"",
            "                )",
            "        return str(value)",
            "",
            "    def adapt_timefield_value(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        # MySQL doesn't support tz-aware times",
            "        if timezone.is_aware(value):",
            "            raise ValueError(\"MySQL backend does not support timezone-aware times.\")",
            "",
            "        return value.isoformat(timespec=\"microseconds\")",
            "",
            "    def max_name_length(self):",
            "        return 64",
            "",
            "    def pk_default_value(self):",
            "        return \"NULL\"",
            "",
            "    def bulk_insert_sql(self, fields, placeholder_rows):",
            "        placeholder_rows_sql = (\", \".join(row) for row in placeholder_rows)",
            "        values_sql = \", \".join(\"(%s)\" % sql for sql in placeholder_rows_sql)",
            "        return \"VALUES \" + values_sql",
            "",
            "    def combine_expression(self, connector, sub_expressions):",
            "        if connector == \"^\":",
            "            return \"POW(%s)\" % \",\".join(sub_expressions)",
            "        # Convert the result to a signed integer since MySQL's binary operators",
            "        # return an unsigned integer.",
            "        elif connector in (\"&\", \"|\", \"<<\", \"#\"):",
            "            connector = \"^\" if connector == \"#\" else connector",
            "            return \"CONVERT(%s, SIGNED)\" % connector.join(sub_expressions)",
            "        elif connector == \">>\":",
            "            lhs, rhs = sub_expressions",
            "            return \"FLOOR(%(lhs)s / POW(2, %(rhs)s))\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        return super().combine_expression(connector, sub_expressions)",
            "",
            "    def get_db_converters(self, expression):",
            "        converters = super().get_db_converters(expression)",
            "        internal_type = expression.output_field.get_internal_type()",
            "        if internal_type == \"BooleanField\":",
            "            converters.append(self.convert_booleanfield_value)",
            "        elif internal_type == \"DateTimeField\":",
            "            if settings.USE_TZ:",
            "                converters.append(self.convert_datetimefield_value)",
            "        elif internal_type == \"UUIDField\":",
            "            converters.append(self.convert_uuidfield_value)",
            "        return converters",
            "",
            "    def convert_booleanfield_value(self, value, expression, connection):",
            "        if value in (0, 1):",
            "            value = bool(value)",
            "        return value",
            "",
            "    def convert_datetimefield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = timezone.make_aware(value, self.connection.timezone)",
            "        return value",
            "",
            "    def convert_uuidfield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = uuid.UUID(value)",
            "        return value",
            "",
            "    def binary_placeholder_sql(self, value):",
            "        return (",
            "            \"_binary %s\" if value is not None and not hasattr(value, \"as_sql\") else \"%s\"",
            "        )",
            "",
            "    def subtract_temporals(self, internal_type, lhs, rhs):",
            "        lhs_sql, lhs_params = lhs",
            "        rhs_sql, rhs_params = rhs",
            "        if internal_type == \"TimeField\":",
            "            if self.connection.mysql_is_mariadb:",
            "                # MariaDB includes the microsecond component in TIME_TO_SEC as",
            "                # a decimal. MySQL returns an integer without microseconds.",
            "                return (",
            "                    \"CAST((TIME_TO_SEC(%(lhs)s) - TIME_TO_SEC(%(rhs)s)) \"",
            "                    \"* 1000000 AS SIGNED)\"",
            "                ) % {",
            "                    \"lhs\": lhs_sql,",
            "                    \"rhs\": rhs_sql,",
            "                }, (",
            "                    *lhs_params,",
            "                    *rhs_params,",
            "                )",
            "            return (",
            "                \"((TIME_TO_SEC(%(lhs)s) * 1000000 + MICROSECOND(%(lhs)s)) -\"",
            "                \" (TIME_TO_SEC(%(rhs)s) * 1000000 + MICROSECOND(%(rhs)s)))\"",
            "            ) % {\"lhs\": lhs_sql, \"rhs\": rhs_sql}, tuple(lhs_params) * 2 + tuple(",
            "                rhs_params",
            "            ) * 2",
            "        params = (*rhs_params, *lhs_params)",
            "        return \"TIMESTAMPDIFF(MICROSECOND, %s, %s)\" % (rhs_sql, lhs_sql), params",
            "",
            "    def explain_query_prefix(self, format=None, **options):",
            "        # Alias MySQL's TRADITIONAL to TEXT for consistency with other backends.",
            "        if format and format.upper() == \"TEXT\":",
            "            format = \"TRADITIONAL\"",
            "        elif (",
            "            not format and \"TREE\" in self.connection.features.supported_explain_formats",
            "        ):",
            "            # Use TREE by default (if supported) as it's more informative.",
            "            format = \"TREE\"",
            "        analyze = options.pop(\"analyze\", False)",
            "        prefix = super().explain_query_prefix(format, **options)",
            "        if analyze and self.connection.features.supports_explain_analyze:",
            "            # MariaDB uses ANALYZE instead of EXPLAIN ANALYZE.",
            "            prefix = (",
            "                \"ANALYZE\" if self.connection.mysql_is_mariadb else prefix + \" ANALYZE\"",
            "            )",
            "        if format and not (analyze and not self.connection.mysql_is_mariadb):",
            "            # Only MariaDB supports the analyze option with formats.",
            "            prefix += \" FORMAT=%s\" % format",
            "        return prefix",
            "",
            "    def regex_lookup(self, lookup_type):",
            "        # REGEXP_LIKE doesn't exist in MariaDB.",
            "        if self.connection.mysql_is_mariadb:",
            "            if lookup_type == \"regex\":",
            "                return \"%s REGEXP BINARY %s\"",
            "            return \"%s REGEXP %s\"",
            "",
            "        match_option = \"c\" if lookup_type == \"regex\" else \"i\"",
            "        return \"REGEXP_LIKE(%%s, %%s, '%s')\" % match_option",
            "",
            "    def insert_statement(self, on_conflict=None):",
            "        if on_conflict == OnConflict.IGNORE:",
            "            return \"INSERT IGNORE INTO\"",
            "        return super().insert_statement(on_conflict=on_conflict)",
            "",
            "    def lookup_cast(self, lookup_type, internal_type=None):",
            "        lookup = \"%s\"",
            "        if internal_type == \"JSONField\":",
            "            if self.connection.mysql_is_mariadb or lookup_type in (",
            "                \"iexact\",",
            "                \"contains\",",
            "                \"icontains\",",
            "                \"startswith\",",
            "                \"istartswith\",",
            "                \"endswith\",",
            "                \"iendswith\",",
            "                \"regex\",",
            "                \"iregex\",",
            "            ):",
            "                lookup = \"JSON_UNQUOTE(%s)\"",
            "        return lookup",
            "",
            "    def conditional_expression_supported_in_where_clause(self, expression):",
            "        # MySQL ignores indexes with boolean fields unless they're compared",
            "        # directly to a boolean value.",
            "        if isinstance(expression, (Exists, Lookup)):",
            "            return True",
            "        if isinstance(expression, ExpressionWrapper) and expression.conditional:",
            "            return self.conditional_expression_supported_in_where_clause(",
            "                expression.expression",
            "            )",
            "        if getattr(expression, \"conditional\", False):",
            "            return False",
            "        return super().conditional_expression_supported_in_where_clause(expression)",
            "",
            "    def on_conflict_suffix_sql(self, fields, on_conflict, update_fields, unique_fields):",
            "        if on_conflict == OnConflict.UPDATE:",
            "            conflict_suffix_sql = \"ON DUPLICATE KEY UPDATE %(fields)s\"",
            "            # The use of VALUES() is deprecated in MySQL 8.0.20+. Instead, use",
            "            # aliases for the new row and its columns available in MySQL",
            "            # 8.0.19+.",
            "            if not self.connection.mysql_is_mariadb:",
            "                if self.connection.mysql_version >= (8, 0, 19):",
            "                    conflict_suffix_sql = f\"AS new {conflict_suffix_sql}\"",
            "                    field_sql = \"%(field)s = new.%(field)s\"",
            "                else:",
            "                    field_sql = \"%(field)s = VALUES(%(field)s)\"",
            "            # Use VALUE() on MariaDB.",
            "            else:",
            "                field_sql = \"%(field)s = VALUE(%(field)s)\"",
            "",
            "            fields = \", \".join(",
            "                [",
            "                    field_sql % {\"field\": field}",
            "                    for field in map(self.quote_name, update_fields)",
            "                ]",
            "            )",
            "            return conflict_suffix_sql % {\"fields\": fields}",
            "        return super().on_conflict_suffix_sql(",
            "            fields,",
            "            on_conflict,",
            "            update_fields,",
            "            unique_fields,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "DatabaseOperations",
                "date_trunc_sql"
            ],
            "92": [
                "DatabaseOperations",
                "_convert_field_to_tz"
            ],
            "102": [
                "DatabaseOperations",
                "datetime_cast_date_sql"
            ],
            "106": [
                "DatabaseOperations",
                "datetime_cast_time_sql"
            ],
            "110": [
                "DatabaseOperations",
                "datetime_extract_sql"
            ],
            "114": [
                "DatabaseOperations",
                "datetime_trunc_sql"
            ],
            "139": [
                "DatabaseOperations",
                "time_trunc_sql"
            ]
        },
        "addLocation": []
    },
    "django/db/backends/oracle/operations.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         return extract_sql, (*params, extract_param)"
            },
            "1": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "     def date_trunc_sql(self, lookup_type, sql, params, tzname=None):"
            },
            "3": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "5": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html"
            },
            "6": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         trunc_param = None"
            },
            "7": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         if lookup_type in (\"year\", \"month\"):"
            },
            "8": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         tzname, sign, offset = split_tzname_delta(tzname)"
            },
            "9": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         return f\"{sign}{offset}\" if offset else tzname"
            },
            "10": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _convert_field_to_tz(self, sql, params, tzname):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+    def _convert_sql_to_tz(self, sql, params, tzname):"
            },
            "13": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         if not (settings.USE_TZ and tzname):"
            },
            "14": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "             return sql, params"
            },
            "15": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         if not self._tzname_re.match(tzname):"
            },
            "16": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         return sql, params"
            },
            "17": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "     def datetime_cast_date_sql(self, sql, params, tzname):"
            },
            "19": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "21": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         return f\"TRUNC({sql})\", params"
            },
            "22": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "     def datetime_cast_time_sql(self, sql, params, tzname):"
            },
            "24": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         # Since `TimeField` values are stored as TIMESTAMP change to the"
            },
            "25": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         # default date and convert the field to the specified timezone."
            },
            "26": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "28": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         convert_datetime_sql = ("
            },
            "29": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             f\"TO_TIMESTAMP(CONCAT('1900-01-01 ', TO_CHAR({sql}, 'HH24:MI:SS.FF')), \""
            },
            "30": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "             f\"'YYYY-MM-DD HH24:MI:SS.FF')\""
            },
            "31": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         )"
            },
            "32": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     def datetime_extract_sql(self, lookup_type, sql, params, tzname):"
            },
            "34": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "36": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         return self.date_extract_sql(lookup_type, sql, params)"
            },
            "37": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     def datetime_trunc_sql(self, lookup_type, sql, params, tzname):"
            },
            "39": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "41": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html"
            },
            "42": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         trunc_param = None"
            },
            "43": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         if lookup_type in (\"year\", \"month\"):"
            },
            "44": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         # The implementation is similar to `datetime_trunc_sql` as both"
            },
            "45": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where"
            },
            "46": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         # the date part of the later is ignored."
            },
            "47": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sql, params = self._convert_field_to_tz(sql, params, tzname)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        sql, params = self._convert_sql_to_tz(sql, params, tzname)"
            },
            "49": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         trunc_param = None"
            },
            "50": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         if lookup_type == \"hour\":"
            },
            "51": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "             trunc_param = \"HH24\""
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import uuid",
            "from functools import lru_cache",
            "",
            "from django.conf import settings",
            "from django.db import DatabaseError, NotSupportedError",
            "from django.db.backends.base.operations import BaseDatabaseOperations",
            "from django.db.backends.utils import split_tzname_delta, strip_quotes, truncate_name",
            "from django.db.models import AutoField, Exists, ExpressionWrapper, Lookup",
            "from django.db.models.expressions import RawSQL",
            "from django.db.models.sql.where import WhereNode",
            "from django.utils import timezone",
            "from django.utils.encoding import force_bytes, force_str",
            "from django.utils.functional import cached_property",
            "from django.utils.regex_helper import _lazy_re_compile",
            "",
            "from .base import Database",
            "from .utils import BulkInsertMapper, InsertVar, Oracle_datetime",
            "",
            "",
            "class DatabaseOperations(BaseDatabaseOperations):",
            "    # Oracle uses NUMBER(5), NUMBER(11), and NUMBER(19) for integer fields.",
            "    # SmallIntegerField uses NUMBER(11) instead of NUMBER(5), which is used by",
            "    # SmallAutoField, to preserve backward compatibility.",
            "    integer_field_ranges = {",
            "        \"SmallIntegerField\": (-99999999999, 99999999999),",
            "        \"IntegerField\": (-99999999999, 99999999999),",
            "        \"BigIntegerField\": (-9999999999999999999, 9999999999999999999),",
            "        \"PositiveBigIntegerField\": (0, 9999999999999999999),",
            "        \"PositiveSmallIntegerField\": (0, 99999999999),",
            "        \"PositiveIntegerField\": (0, 99999999999),",
            "        \"SmallAutoField\": (-99999, 99999),",
            "        \"AutoField\": (-99999999999, 99999999999),",
            "        \"BigAutoField\": (-9999999999999999999, 9999999999999999999),",
            "    }",
            "    set_operators = {**BaseDatabaseOperations.set_operators, \"difference\": \"MINUS\"}",
            "",
            "    # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.",
            "    _sequence_reset_sql = \"\"\"",
            "DECLARE",
            "    table_value integer;",
            "    seq_value integer;",
            "    seq_name user_tab_identity_cols.sequence_name%%TYPE;",
            "BEGIN",
            "    BEGIN",
            "        SELECT sequence_name INTO seq_name FROM user_tab_identity_cols",
            "        WHERE  table_name = '%(table_name)s' AND",
            "               column_name = '%(column_name)s';",
            "        EXCEPTION WHEN NO_DATA_FOUND THEN",
            "            seq_name := '%(no_autofield_sequence_name)s';",
            "    END;",
            "",
            "    SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;",
            "    SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences",
            "           WHERE sequence_name = seq_name;",
            "    WHILE table_value > seq_value LOOP",
            "        EXECUTE IMMEDIATE 'SELECT \"'||seq_name||'\".nextval FROM DUAL'",
            "        INTO seq_value;",
            "    END LOOP;",
            "END;",
            "/\"\"\"",
            "",
            "    # Oracle doesn't support string without precision; use the max string size.",
            "    cast_char_field_without_max_length = \"NVARCHAR2(2000)\"",
            "    cast_data_types = {",
            "        \"AutoField\": \"NUMBER(11)\",",
            "        \"BigAutoField\": \"NUMBER(19)\",",
            "        \"SmallAutoField\": \"NUMBER(5)\",",
            "        \"TextField\": cast_char_field_without_max_length,",
            "    }",
            "",
            "    def cache_key_culling_sql(self):",
            "        cache_key = self.quote_name(\"cache_key\")",
            "        return (",
            "            f\"SELECT {cache_key} \"",
            "            f\"FROM %s \"",
            "            f\"ORDER BY {cache_key} OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY\"",
            "        )",
            "",
            "    # EXTRACT format cannot be passed in parameters.",
            "    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")",
            "",
            "    def date_extract_sql(self, lookup_type, sql, params):",
            "        extract_sql = f\"TO_CHAR({sql}, %s)\"",
            "        extract_param = None",
            "        if lookup_type == \"week_day\":",
            "            # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.",
            "            extract_param = \"D\"",
            "        elif lookup_type == \"iso_week_day\":",
            "            extract_sql = f\"TO_CHAR({sql} - 1, %s)\"",
            "            extract_param = \"D\"",
            "        elif lookup_type == \"week\":",
            "            # IW = ISO week number",
            "            extract_param = \"IW\"",
            "        elif lookup_type == \"quarter\":",
            "            extract_param = \"Q\"",
            "        elif lookup_type == \"iso_year\":",
            "            extract_param = \"IYYY\"",
            "        else:",
            "            lookup_type = lookup_type.upper()",
            "            if not self._extract_format_re.fullmatch(lookup_type):",
            "                raise ValueError(f\"Invalid loookup type: {lookup_type!r}\")",
            "            # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/EXTRACT-datetime.html",
            "            return f\"EXTRACT({lookup_type} FROM {sql})\", params",
            "        return extract_sql, (*params, extract_param)",
            "",
            "    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html",
            "        trunc_param = None",
            "        if lookup_type in (\"year\", \"month\"):",
            "            trunc_param = lookup_type.upper()",
            "        elif lookup_type == \"quarter\":",
            "            trunc_param = \"Q\"",
            "        elif lookup_type == \"week\":",
            "            trunc_param = \"IW\"",
            "        else:",
            "            return f\"TRUNC({sql})\", params",
            "        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)",
            "",
            "    # Oracle crashes with \"ORA-03113: end-of-file on communication channel\"",
            "    # if the time zone name is passed in parameter. Use interpolation instead.",
            "    # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ",
            "    # This regexp matches all time zone names from the zoneinfo database.",
            "    _tzname_re = _lazy_re_compile(r\"^[\\w/:+-]+$\")",
            "",
            "    def _prepare_tzname_delta(self, tzname):",
            "        tzname, sign, offset = split_tzname_delta(tzname)",
            "        return f\"{sign}{offset}\" if offset else tzname",
            "",
            "    def _convert_field_to_tz(self, sql, params, tzname):",
            "        if not (settings.USE_TZ and tzname):",
            "            return sql, params",
            "        if not self._tzname_re.match(tzname):",
            "            raise ValueError(\"Invalid time zone name: %s\" % tzname)",
            "        # Convert from connection timezone to the local time, returning",
            "        # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the",
            "        # TIME ZONE details.",
            "        if self.connection.timezone_name != tzname:",
            "            from_timezone_name = self.connection.timezone_name",
            "            to_timezone_name = self._prepare_tzname_delta(tzname)",
            "            return (",
            "                f\"CAST((FROM_TZ({sql}, '{from_timezone_name}') AT TIME ZONE \"",
            "                f\"'{to_timezone_name}') AS TIMESTAMP)\",",
            "                params,",
            "            )",
            "        return sql, params",
            "",
            "    def datetime_cast_date_sql(self, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        return f\"TRUNC({sql})\", params",
            "",
            "    def datetime_cast_time_sql(self, sql, params, tzname):",
            "        # Since `TimeField` values are stored as TIMESTAMP change to the",
            "        # default date and convert the field to the specified timezone.",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        convert_datetime_sql = (",
            "            f\"TO_TIMESTAMP(CONCAT('1900-01-01 ', TO_CHAR({sql}, 'HH24:MI:SS.FF')), \"",
            "            f\"'YYYY-MM-DD HH24:MI:SS.FF')\"",
            "        )",
            "        return (",
            "            f\"CASE WHEN {sql} IS NOT NULL THEN {convert_datetime_sql} ELSE NULL END\",",
            "            (*params, *params),",
            "        )",
            "",
            "    def datetime_extract_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        return self.date_extract_sql(lookup_type, sql, params)",
            "",
            "    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html",
            "        trunc_param = None",
            "        if lookup_type in (\"year\", \"month\"):",
            "            trunc_param = lookup_type.upper()",
            "        elif lookup_type == \"quarter\":",
            "            trunc_param = \"Q\"",
            "        elif lookup_type == \"week\":",
            "            trunc_param = \"IW\"",
            "        elif lookup_type == \"hour\":",
            "            trunc_param = \"HH24\"",
            "        elif lookup_type == \"minute\":",
            "            trunc_param = \"MI\"",
            "        elif lookup_type == \"day\":",
            "            return f\"TRUNC({sql})\", params",
            "        else:",
            "            # Cast to DATE removes sub-second precision.",
            "            return f\"CAST({sql} AS DATE)\", params",
            "        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)",
            "",
            "    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        # The implementation is similar to `datetime_trunc_sql` as both",
            "        # `DateTimeField` and `TimeField` are stored as TIMESTAMP where",
            "        # the date part of the later is ignored.",
            "        sql, params = self._convert_field_to_tz(sql, params, tzname)",
            "        trunc_param = None",
            "        if lookup_type == \"hour\":",
            "            trunc_param = \"HH24\"",
            "        elif lookup_type == \"minute\":",
            "            trunc_param = \"MI\"",
            "        elif lookup_type == \"second\":",
            "            # Cast to DATE removes sub-second precision.",
            "            return f\"CAST({sql} AS DATE)\", params",
            "        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)",
            "",
            "    def get_db_converters(self, expression):",
            "        converters = super().get_db_converters(expression)",
            "        internal_type = expression.output_field.get_internal_type()",
            "        if internal_type in [\"JSONField\", \"TextField\"]:",
            "            converters.append(self.convert_textfield_value)",
            "        elif internal_type == \"BinaryField\":",
            "            converters.append(self.convert_binaryfield_value)",
            "        elif internal_type == \"BooleanField\":",
            "            converters.append(self.convert_booleanfield_value)",
            "        elif internal_type == \"DateTimeField\":",
            "            if settings.USE_TZ:",
            "                converters.append(self.convert_datetimefield_value)",
            "        elif internal_type == \"DateField\":",
            "            converters.append(self.convert_datefield_value)",
            "        elif internal_type == \"TimeField\":",
            "            converters.append(self.convert_timefield_value)",
            "        elif internal_type == \"UUIDField\":",
            "            converters.append(self.convert_uuidfield_value)",
            "        # Oracle stores empty strings as null. If the field accepts the empty",
            "        # string, undo this to adhere to the Django convention of using",
            "        # the empty string instead of null.",
            "        if expression.output_field.empty_strings_allowed:",
            "            converters.append(",
            "                self.convert_empty_bytes",
            "                if internal_type == \"BinaryField\"",
            "                else self.convert_empty_string",
            "            )",
            "        return converters",
            "",
            "    def convert_textfield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.LOB):",
            "            value = value.read()",
            "        return value",
            "",
            "    def convert_binaryfield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.LOB):",
            "            value = force_bytes(value.read())",
            "        return value",
            "",
            "    def convert_booleanfield_value(self, value, expression, connection):",
            "        if value in (0, 1):",
            "            value = bool(value)",
            "        return value",
            "",
            "    # cx_Oracle always returns datetime.datetime objects for",
            "    # DATE and TIMESTAMP columns, but Django wants to see a",
            "    # python datetime.date, .time, or .datetime.",
            "",
            "    def convert_datetimefield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = timezone.make_aware(value, self.connection.timezone)",
            "        return value",
            "",
            "    def convert_datefield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.Timestamp):",
            "            value = value.date()",
            "        return value",
            "",
            "    def convert_timefield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.Timestamp):",
            "            value = value.time()",
            "        return value",
            "",
            "    def convert_uuidfield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = uuid.UUID(value)",
            "        return value",
            "",
            "    @staticmethod",
            "    def convert_empty_string(value, expression, connection):",
            "        return \"\" if value is None else value",
            "",
            "    @staticmethod",
            "    def convert_empty_bytes(value, expression, connection):",
            "        return b\"\" if value is None else value",
            "",
            "    def deferrable_sql(self):",
            "        return \" DEFERRABLE INITIALLY DEFERRED\"",
            "",
            "    def fetch_returned_insert_columns(self, cursor, returning_params):",
            "        columns = []",
            "        for param in returning_params:",
            "            value = param.get_value()",
            "            if value == []:",
            "                raise DatabaseError(",
            "                    \"The database did not return a new row id. Probably \"",
            "                    '\"ORA-1403: no data found\" was raised internally but was '",
            "                    \"hidden by the Oracle OCI library (see \"",
            "                    \"https://code.djangoproject.com/ticket/28859).\"",
            "                )",
            "            columns.append(value[0])",
            "        return tuple(columns)",
            "",
            "    def field_cast_sql(self, db_type, internal_type):",
            "        if db_type and db_type.endswith(\"LOB\") and internal_type != \"JSONField\":",
            "            return \"DBMS_LOB.SUBSTR(%s)\"",
            "        else:",
            "            return \"%s\"",
            "",
            "    def no_limit_value(self):",
            "        return None",
            "",
            "    def limit_offset_sql(self, low_mark, high_mark):",
            "        fetch, offset = self._get_limit_offset_params(low_mark, high_mark)",
            "        return \" \".join(",
            "            sql",
            "            for sql in (",
            "                (\"OFFSET %d ROWS\" % offset) if offset else None,",
            "                (\"FETCH FIRST %d ROWS ONLY\" % fetch) if fetch else None,",
            "            )",
            "            if sql",
            "        )",
            "",
            "    def last_executed_query(self, cursor, sql, params):",
            "        # https://cx-oracle.readthedocs.io/en/latest/api_manual/cursor.html#Cursor.statement",
            "        # The DB API definition does not define this attribute.",
            "        statement = cursor.statement",
            "        # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's",
            "        # `statement` doesn't contain the query parameters. Substitute",
            "        # parameters manually.",
            "        if isinstance(params, (tuple, list)):",
            "            for i, param in enumerate(reversed(params), start=1):",
            "                param_num = len(params) - i",
            "                statement = statement.replace(",
            "                    \":arg%d\" % param_num, force_str(param, errors=\"replace\")",
            "                )",
            "        elif isinstance(params, dict):",
            "            for key in sorted(params, key=len, reverse=True):",
            "                statement = statement.replace(",
            "                    \":%s\" % key, force_str(params[key], errors=\"replace\")",
            "                )",
            "        return statement",
            "",
            "    def last_insert_id(self, cursor, table_name, pk_name):",
            "        sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)",
            "        cursor.execute('\"%s\".currval' % sq_name)",
            "        return cursor.fetchone()[0]",
            "",
            "    def lookup_cast(self, lookup_type, internal_type=None):",
            "        if lookup_type in (\"iexact\", \"icontains\", \"istartswith\", \"iendswith\"):",
            "            return \"UPPER(%s)\"",
            "        if internal_type == \"JSONField\" and lookup_type == \"exact\":",
            "            return \"DBMS_LOB.SUBSTR(%s)\"",
            "        return \"%s\"",
            "",
            "    def max_in_list_size(self):",
            "        return 1000",
            "",
            "    def max_name_length(self):",
            "        return 30",
            "",
            "    def pk_default_value(self):",
            "        return \"NULL\"",
            "",
            "    def prep_for_iexact_query(self, x):",
            "        return x",
            "",
            "    def process_clob(self, value):",
            "        if value is None:",
            "            return \"\"",
            "        return value.read()",
            "",
            "    def quote_name(self, name):",
            "        # SQL92 requires delimited (quoted) names to be case-sensitive.  When",
            "        # not quoted, Oracle has case-insensitive behavior for identifiers, but",
            "        # always defaults to uppercase.",
            "        # We simplify things by making Oracle identifiers always uppercase.",
            "        if not name.startswith('\"') and not name.endswith('\"'):",
            "            name = '\"%s\"' % truncate_name(name, self.max_name_length())",
            "        # Oracle puts the query text into a (query % args) construct, so % signs",
            "        # in names need to be escaped. The '%%' will be collapsed back to '%' at",
            "        # that stage so we aren't really making the name longer here.",
            "        name = name.replace(\"%\", \"%%\")",
            "        return name.upper()",
            "",
            "    def regex_lookup(self, lookup_type):",
            "        if lookup_type == \"regex\":",
            "            match_option = \"'c'\"",
            "        else:",
            "            match_option = \"'i'\"",
            "        return \"REGEXP_LIKE(%%s, %%s, %s)\" % match_option",
            "",
            "    def return_insert_columns(self, fields):",
            "        if not fields:",
            "            return \"\", ()",
            "        field_names = []",
            "        params = []",
            "        for field in fields:",
            "            field_names.append(",
            "                \"%s.%s\"",
            "                % (",
            "                    self.quote_name(field.model._meta.db_table),",
            "                    self.quote_name(field.column),",
            "                )",
            "            )",
            "            params.append(InsertVar(field))",
            "        return \"RETURNING %s INTO %s\" % (",
            "            \", \".join(field_names),",
            "            \", \".join([\"%s\"] * len(params)),",
            "        ), tuple(params)",
            "",
            "    def __foreign_key_constraints(self, table_name, recursive):",
            "        with self.connection.cursor() as cursor:",
            "            if recursive:",
            "                cursor.execute(",
            "                    \"\"\"",
            "                    SELECT",
            "                        user_tables.table_name, rcons.constraint_name",
            "                    FROM",
            "                        user_tables",
            "                    JOIN",
            "                        user_constraints cons",
            "                        ON (user_tables.table_name = cons.table_name",
            "                        AND cons.constraint_type = ANY('P', 'U'))",
            "                    LEFT JOIN",
            "                        user_constraints rcons",
            "                        ON (user_tables.table_name = rcons.table_name",
            "                        AND rcons.constraint_type = 'R')",
            "                    START WITH user_tables.table_name = UPPER(%s)",
            "                    CONNECT BY",
            "                        NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name",
            "                    GROUP BY",
            "                        user_tables.table_name, rcons.constraint_name",
            "                    HAVING user_tables.table_name != UPPER(%s)",
            "                    ORDER BY MAX(level) DESC",
            "                    \"\"\",",
            "                    (table_name, table_name),",
            "                )",
            "            else:",
            "                cursor.execute(",
            "                    \"\"\"",
            "                    SELECT",
            "                        cons.table_name, cons.constraint_name",
            "                    FROM",
            "                        user_constraints cons",
            "                    WHERE",
            "                        cons.constraint_type = 'R'",
            "                        AND cons.table_name = UPPER(%s)",
            "                    \"\"\",",
            "                    (table_name,),",
            "                )",
            "            return cursor.fetchall()",
            "",
            "    @cached_property",
            "    def _foreign_key_constraints(self):",
            "        # 512 is large enough to fit the ~330 tables (as of this writing) in",
            "        # Django's test suite.",
            "        return lru_cache(maxsize=512)(self.__foreign_key_constraints)",
            "",
            "    def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):",
            "        if not tables:",
            "            return []",
            "",
            "        truncated_tables = {table.upper() for table in tables}",
            "        constraints = set()",
            "        # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign",
            "        # keys which Django doesn't define. Emulate the PostgreSQL behavior",
            "        # which truncates all dependent tables by manually retrieving all",
            "        # foreign key constraints and resolving dependencies.",
            "        for table in tables:",
            "            for foreign_table, constraint in self._foreign_key_constraints(",
            "                table, recursive=allow_cascade",
            "            ):",
            "                if allow_cascade:",
            "                    truncated_tables.add(foreign_table)",
            "                constraints.add((foreign_table, constraint))",
            "        sql = (",
            "            [",
            "                \"%s %s %s %s %s %s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"ALTER\"),",
            "                    style.SQL_KEYWORD(\"TABLE\"),",
            "                    style.SQL_FIELD(self.quote_name(table)),",
            "                    style.SQL_KEYWORD(\"DISABLE\"),",
            "                    style.SQL_KEYWORD(\"CONSTRAINT\"),",
            "                    style.SQL_FIELD(self.quote_name(constraint)),",
            "                    style.SQL_KEYWORD(\"KEEP\"),",
            "                    style.SQL_KEYWORD(\"INDEX\"),",
            "                )",
            "                for table, constraint in constraints",
            "            ]",
            "            + [",
            "                \"%s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"TRUNCATE\"),",
            "                    style.SQL_KEYWORD(\"TABLE\"),",
            "                    style.SQL_FIELD(self.quote_name(table)),",
            "                )",
            "                for table in truncated_tables",
            "            ]",
            "            + [",
            "                \"%s %s %s %s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"ALTER\"),",
            "                    style.SQL_KEYWORD(\"TABLE\"),",
            "                    style.SQL_FIELD(self.quote_name(table)),",
            "                    style.SQL_KEYWORD(\"ENABLE\"),",
            "                    style.SQL_KEYWORD(\"CONSTRAINT\"),",
            "                    style.SQL_FIELD(self.quote_name(constraint)),",
            "                )",
            "                for table, constraint in constraints",
            "            ]",
            "        )",
            "        if reset_sequences:",
            "            sequences = [",
            "                sequence",
            "                for sequence in self.connection.introspection.sequence_list()",
            "                if sequence[\"table\"].upper() in truncated_tables",
            "            ]",
            "            # Since we've just deleted all the rows, running our sequence ALTER",
            "            # code will reset the sequence to 0.",
            "            sql.extend(self.sequence_reset_by_name_sql(style, sequences))",
            "        return sql",
            "",
            "    def sequence_reset_by_name_sql(self, style, sequences):",
            "        sql = []",
            "        for sequence_info in sequences:",
            "            no_autofield_sequence_name = self._get_no_autofield_sequence_name(",
            "                sequence_info[\"table\"]",
            "            )",
            "            table = self.quote_name(sequence_info[\"table\"])",
            "            column = self.quote_name(sequence_info[\"column\"] or \"id\")",
            "            query = self._sequence_reset_sql % {",
            "                \"no_autofield_sequence_name\": no_autofield_sequence_name,",
            "                \"table\": table,",
            "                \"column\": column,",
            "                \"table_name\": strip_quotes(table),",
            "                \"column_name\": strip_quotes(column),",
            "            }",
            "            sql.append(query)",
            "        return sql",
            "",
            "    def sequence_reset_sql(self, style, model_list):",
            "        output = []",
            "        query = self._sequence_reset_sql",
            "        for model in model_list:",
            "            for f in model._meta.local_fields:",
            "                if isinstance(f, AutoField):",
            "                    no_autofield_sequence_name = self._get_no_autofield_sequence_name(",
            "                        model._meta.db_table",
            "                    )",
            "                    table = self.quote_name(model._meta.db_table)",
            "                    column = self.quote_name(f.column)",
            "                    output.append(",
            "                        query",
            "                        % {",
            "                            \"no_autofield_sequence_name\": no_autofield_sequence_name,",
            "                            \"table\": table,",
            "                            \"column\": column,",
            "                            \"table_name\": strip_quotes(table),",
            "                            \"column_name\": strip_quotes(column),",
            "                        }",
            "                    )",
            "                    # Only one AutoField is allowed per model, so don't",
            "                    # continue to loop",
            "                    break",
            "        return output",
            "",
            "    def start_transaction_sql(self):",
            "        return \"\"",
            "",
            "    def tablespace_sql(self, tablespace, inline=False):",
            "        if inline:",
            "            return \"USING INDEX TABLESPACE %s\" % self.quote_name(tablespace)",
            "        else:",
            "            return \"TABLESPACE %s\" % self.quote_name(tablespace)",
            "",
            "    def adapt_datefield_value(self, value):",
            "        \"\"\"",
            "        Transform a date value to an object compatible with what is expected",
            "        by the backend driver for date columns.",
            "        The default implementation transforms the date to text, but that is not",
            "        necessary for Oracle.",
            "        \"\"\"",
            "        return value",
            "",
            "    def adapt_datetimefield_value(self, value):",
            "        \"\"\"",
            "        Transform a datetime value to an object compatible with what is expected",
            "        by the backend driver for datetime columns.",
            "",
            "        If naive datetime is passed assumes that is in UTC. Normally Django",
            "        models.DateTimeField makes sure that if USE_TZ is True passed datetime",
            "        is timezone aware.",
            "        \"\"\"",
            "",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        # cx_Oracle doesn't support tz-aware datetimes",
            "        if timezone.is_aware(value):",
            "            if settings.USE_TZ:",
            "                value = timezone.make_naive(value, self.connection.timezone)",
            "            else:",
            "                raise ValueError(",
            "                    \"Oracle backend does not support timezone-aware datetimes when \"",
            "                    \"USE_TZ is False.\"",
            "                )",
            "",
            "        return Oracle_datetime.from_datetime(value)",
            "",
            "    def adapt_timefield_value(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        if isinstance(value, str):",
            "            return datetime.datetime.strptime(value, \"%H:%M:%S\")",
            "",
            "        # Oracle doesn't support tz-aware times",
            "        if timezone.is_aware(value):",
            "            raise ValueError(\"Oracle backend does not support timezone-aware times.\")",
            "",
            "        return Oracle_datetime(",
            "            1900, 1, 1, value.hour, value.minute, value.second, value.microsecond",
            "        )",
            "",
            "    def adapt_decimalfield_value(self, value, max_digits=None, decimal_places=None):",
            "        return value",
            "",
            "    def combine_expression(self, connector, sub_expressions):",
            "        lhs, rhs = sub_expressions",
            "        if connector == \"%%\":",
            "            return \"MOD(%s)\" % \",\".join(sub_expressions)",
            "        elif connector == \"&\":",
            "            return \"BITAND(%s)\" % \",\".join(sub_expressions)",
            "        elif connector == \"|\":",
            "            return \"BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        elif connector == \"<<\":",
            "            return \"(%(lhs)s * POWER(2, %(rhs)s))\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        elif connector == \">>\":",
            "            return \"FLOOR(%(lhs)s / POWER(2, %(rhs)s))\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        elif connector == \"^\":",
            "            return \"POWER(%s)\" % \",\".join(sub_expressions)",
            "        elif connector == \"#\":",
            "            raise NotSupportedError(\"Bitwise XOR is not supported in Oracle.\")",
            "        return super().combine_expression(connector, sub_expressions)",
            "",
            "    def _get_no_autofield_sequence_name(self, table):",
            "        \"\"\"",
            "        Manually created sequence name to keep backward compatibility for",
            "        AutoFields that aren't Oracle identity columns.",
            "        \"\"\"",
            "        name_length = self.max_name_length() - 3",
            "        return \"%s_SQ\" % truncate_name(strip_quotes(table), name_length).upper()",
            "",
            "    def _get_sequence_name(self, cursor, table, pk_name):",
            "        cursor.execute(",
            "            \"\"\"",
            "            SELECT sequence_name",
            "            FROM user_tab_identity_cols",
            "            WHERE table_name = UPPER(%s)",
            "            AND column_name = UPPER(%s)\"\"\",",
            "            [table, pk_name],",
            "        )",
            "        row = cursor.fetchone()",
            "        return self._get_no_autofield_sequence_name(table) if row is None else row[0]",
            "",
            "    def bulk_insert_sql(self, fields, placeholder_rows):",
            "        query = []",
            "        for row in placeholder_rows:",
            "            select = []",
            "            for i, placeholder in enumerate(row):",
            "                # A model without any fields has fields=[None].",
            "                if fields[i]:",
            "                    internal_type = getattr(",
            "                        fields[i], \"target_field\", fields[i]",
            "                    ).get_internal_type()",
            "                    placeholder = (",
            "                        BulkInsertMapper.types.get(internal_type, \"%s\") % placeholder",
            "                    )",
            "                # Add columns aliases to the first select to avoid \"ORA-00918:",
            "                # column ambiguously defined\" when two or more columns in the",
            "                # first select have the same value.",
            "                if not query:",
            "                    placeholder = \"%s col_%s\" % (placeholder, i)",
            "                select.append(placeholder)",
            "            query.append(\"SELECT %s FROM DUAL\" % \", \".join(select))",
            "        # Bulk insert to tables with Oracle identity columns causes Oracle to",
            "        # add sequence.nextval to it. Sequence.nextval cannot be used with the",
            "        # UNION operator. To prevent incorrect SQL, move UNION to a subquery.",
            "        return \"SELECT * FROM (%s)\" % \" UNION ALL \".join(query)",
            "",
            "    def subtract_temporals(self, internal_type, lhs, rhs):",
            "        if internal_type == \"DateField\":",
            "            lhs_sql, lhs_params = lhs",
            "            rhs_sql, rhs_params = rhs",
            "            params = (*lhs_params, *rhs_params)",
            "            return (",
            "                \"NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')\" % (lhs_sql, rhs_sql),",
            "                params,",
            "            )",
            "        return super().subtract_temporals(internal_type, lhs, rhs)",
            "",
            "    def bulk_batch_size(self, fields, objs):",
            "        \"\"\"Oracle restricts the number of parameters in a query.\"\"\"",
            "        if fields:",
            "            return self.connection.features.max_query_params // len(fields)",
            "        return len(objs)",
            "",
            "    def conditional_expression_supported_in_where_clause(self, expression):",
            "        \"\"\"",
            "        Oracle supports only EXISTS(...) or filters in the WHERE clause, others",
            "        must be compared with True.",
            "        \"\"\"",
            "        if isinstance(expression, (Exists, Lookup, WhereNode)):",
            "            return True",
            "        if isinstance(expression, ExpressionWrapper) and expression.conditional:",
            "            return self.conditional_expression_supported_in_where_clause(",
            "                expression.expression",
            "            )",
            "        if isinstance(expression, RawSQL) and expression.conditional:",
            "            return True",
            "        return False"
        ],
        "afterPatchFile": [
            "import datetime",
            "import uuid",
            "from functools import lru_cache",
            "",
            "from django.conf import settings",
            "from django.db import DatabaseError, NotSupportedError",
            "from django.db.backends.base.operations import BaseDatabaseOperations",
            "from django.db.backends.utils import split_tzname_delta, strip_quotes, truncate_name",
            "from django.db.models import AutoField, Exists, ExpressionWrapper, Lookup",
            "from django.db.models.expressions import RawSQL",
            "from django.db.models.sql.where import WhereNode",
            "from django.utils import timezone",
            "from django.utils.encoding import force_bytes, force_str",
            "from django.utils.functional import cached_property",
            "from django.utils.regex_helper import _lazy_re_compile",
            "",
            "from .base import Database",
            "from .utils import BulkInsertMapper, InsertVar, Oracle_datetime",
            "",
            "",
            "class DatabaseOperations(BaseDatabaseOperations):",
            "    # Oracle uses NUMBER(5), NUMBER(11), and NUMBER(19) for integer fields.",
            "    # SmallIntegerField uses NUMBER(11) instead of NUMBER(5), which is used by",
            "    # SmallAutoField, to preserve backward compatibility.",
            "    integer_field_ranges = {",
            "        \"SmallIntegerField\": (-99999999999, 99999999999),",
            "        \"IntegerField\": (-99999999999, 99999999999),",
            "        \"BigIntegerField\": (-9999999999999999999, 9999999999999999999),",
            "        \"PositiveBigIntegerField\": (0, 9999999999999999999),",
            "        \"PositiveSmallIntegerField\": (0, 99999999999),",
            "        \"PositiveIntegerField\": (0, 99999999999),",
            "        \"SmallAutoField\": (-99999, 99999),",
            "        \"AutoField\": (-99999999999, 99999999999),",
            "        \"BigAutoField\": (-9999999999999999999, 9999999999999999999),",
            "    }",
            "    set_operators = {**BaseDatabaseOperations.set_operators, \"difference\": \"MINUS\"}",
            "",
            "    # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.",
            "    _sequence_reset_sql = \"\"\"",
            "DECLARE",
            "    table_value integer;",
            "    seq_value integer;",
            "    seq_name user_tab_identity_cols.sequence_name%%TYPE;",
            "BEGIN",
            "    BEGIN",
            "        SELECT sequence_name INTO seq_name FROM user_tab_identity_cols",
            "        WHERE  table_name = '%(table_name)s' AND",
            "               column_name = '%(column_name)s';",
            "        EXCEPTION WHEN NO_DATA_FOUND THEN",
            "            seq_name := '%(no_autofield_sequence_name)s';",
            "    END;",
            "",
            "    SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;",
            "    SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences",
            "           WHERE sequence_name = seq_name;",
            "    WHILE table_value > seq_value LOOP",
            "        EXECUTE IMMEDIATE 'SELECT \"'||seq_name||'\".nextval FROM DUAL'",
            "        INTO seq_value;",
            "    END LOOP;",
            "END;",
            "/\"\"\"",
            "",
            "    # Oracle doesn't support string without precision; use the max string size.",
            "    cast_char_field_without_max_length = \"NVARCHAR2(2000)\"",
            "    cast_data_types = {",
            "        \"AutoField\": \"NUMBER(11)\",",
            "        \"BigAutoField\": \"NUMBER(19)\",",
            "        \"SmallAutoField\": \"NUMBER(5)\",",
            "        \"TextField\": cast_char_field_without_max_length,",
            "    }",
            "",
            "    def cache_key_culling_sql(self):",
            "        cache_key = self.quote_name(\"cache_key\")",
            "        return (",
            "            f\"SELECT {cache_key} \"",
            "            f\"FROM %s \"",
            "            f\"ORDER BY {cache_key} OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY\"",
            "        )",
            "",
            "    # EXTRACT format cannot be passed in parameters.",
            "    _extract_format_re = _lazy_re_compile(r\"[A-Z_]+\")",
            "",
            "    def date_extract_sql(self, lookup_type, sql, params):",
            "        extract_sql = f\"TO_CHAR({sql}, %s)\"",
            "        extract_param = None",
            "        if lookup_type == \"week_day\":",
            "            # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.",
            "            extract_param = \"D\"",
            "        elif lookup_type == \"iso_week_day\":",
            "            extract_sql = f\"TO_CHAR({sql} - 1, %s)\"",
            "            extract_param = \"D\"",
            "        elif lookup_type == \"week\":",
            "            # IW = ISO week number",
            "            extract_param = \"IW\"",
            "        elif lookup_type == \"quarter\":",
            "            extract_param = \"Q\"",
            "        elif lookup_type == \"iso_year\":",
            "            extract_param = \"IYYY\"",
            "        else:",
            "            lookup_type = lookup_type.upper()",
            "            if not self._extract_format_re.fullmatch(lookup_type):",
            "                raise ValueError(f\"Invalid loookup type: {lookup_type!r}\")",
            "            # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/EXTRACT-datetime.html",
            "            return f\"EXTRACT({lookup_type} FROM {sql})\", params",
            "        return extract_sql, (*params, extract_param)",
            "",
            "    def date_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html",
            "        trunc_param = None",
            "        if lookup_type in (\"year\", \"month\"):",
            "            trunc_param = lookup_type.upper()",
            "        elif lookup_type == \"quarter\":",
            "            trunc_param = \"Q\"",
            "        elif lookup_type == \"week\":",
            "            trunc_param = \"IW\"",
            "        else:",
            "            return f\"TRUNC({sql})\", params",
            "        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)",
            "",
            "    # Oracle crashes with \"ORA-03113: end-of-file on communication channel\"",
            "    # if the time zone name is passed in parameter. Use interpolation instead.",
            "    # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ",
            "    # This regexp matches all time zone names from the zoneinfo database.",
            "    _tzname_re = _lazy_re_compile(r\"^[\\w/:+-]+$\")",
            "",
            "    def _prepare_tzname_delta(self, tzname):",
            "        tzname, sign, offset = split_tzname_delta(tzname)",
            "        return f\"{sign}{offset}\" if offset else tzname",
            "",
            "    def _convert_sql_to_tz(self, sql, params, tzname):",
            "        if not (settings.USE_TZ and tzname):",
            "            return sql, params",
            "        if not self._tzname_re.match(tzname):",
            "            raise ValueError(\"Invalid time zone name: %s\" % tzname)",
            "        # Convert from connection timezone to the local time, returning",
            "        # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the",
            "        # TIME ZONE details.",
            "        if self.connection.timezone_name != tzname:",
            "            from_timezone_name = self.connection.timezone_name",
            "            to_timezone_name = self._prepare_tzname_delta(tzname)",
            "            return (",
            "                f\"CAST((FROM_TZ({sql}, '{from_timezone_name}') AT TIME ZONE \"",
            "                f\"'{to_timezone_name}') AS TIMESTAMP)\",",
            "                params,",
            "            )",
            "        return sql, params",
            "",
            "    def datetime_cast_date_sql(self, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        return f\"TRUNC({sql})\", params",
            "",
            "    def datetime_cast_time_sql(self, sql, params, tzname):",
            "        # Since `TimeField` values are stored as TIMESTAMP change to the",
            "        # default date and convert the field to the specified timezone.",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        convert_datetime_sql = (",
            "            f\"TO_TIMESTAMP(CONCAT('1900-01-01 ', TO_CHAR({sql}, 'HH24:MI:SS.FF')), \"",
            "            f\"'YYYY-MM-DD HH24:MI:SS.FF')\"",
            "        )",
            "        return (",
            "            f\"CASE WHEN {sql} IS NOT NULL THEN {convert_datetime_sql} ELSE NULL END\",",
            "            (*params, *params),",
            "        )",
            "",
            "    def datetime_extract_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        return self.date_extract_sql(lookup_type, sql, params)",
            "",
            "    def datetime_trunc_sql(self, lookup_type, sql, params, tzname):",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        # https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/ROUND-and-TRUNC-Date-Functions.html",
            "        trunc_param = None",
            "        if lookup_type in (\"year\", \"month\"):",
            "            trunc_param = lookup_type.upper()",
            "        elif lookup_type == \"quarter\":",
            "            trunc_param = \"Q\"",
            "        elif lookup_type == \"week\":",
            "            trunc_param = \"IW\"",
            "        elif lookup_type == \"hour\":",
            "            trunc_param = \"HH24\"",
            "        elif lookup_type == \"minute\":",
            "            trunc_param = \"MI\"",
            "        elif lookup_type == \"day\":",
            "            return f\"TRUNC({sql})\", params",
            "        else:",
            "            # Cast to DATE removes sub-second precision.",
            "            return f\"CAST({sql} AS DATE)\", params",
            "        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)",
            "",
            "    def time_trunc_sql(self, lookup_type, sql, params, tzname=None):",
            "        # The implementation is similar to `datetime_trunc_sql` as both",
            "        # `DateTimeField` and `TimeField` are stored as TIMESTAMP where",
            "        # the date part of the later is ignored.",
            "        sql, params = self._convert_sql_to_tz(sql, params, tzname)",
            "        trunc_param = None",
            "        if lookup_type == \"hour\":",
            "            trunc_param = \"HH24\"",
            "        elif lookup_type == \"minute\":",
            "            trunc_param = \"MI\"",
            "        elif lookup_type == \"second\":",
            "            # Cast to DATE removes sub-second precision.",
            "            return f\"CAST({sql} AS DATE)\", params",
            "        return f\"TRUNC({sql}, %s)\", (*params, trunc_param)",
            "",
            "    def get_db_converters(self, expression):",
            "        converters = super().get_db_converters(expression)",
            "        internal_type = expression.output_field.get_internal_type()",
            "        if internal_type in [\"JSONField\", \"TextField\"]:",
            "            converters.append(self.convert_textfield_value)",
            "        elif internal_type == \"BinaryField\":",
            "            converters.append(self.convert_binaryfield_value)",
            "        elif internal_type == \"BooleanField\":",
            "            converters.append(self.convert_booleanfield_value)",
            "        elif internal_type == \"DateTimeField\":",
            "            if settings.USE_TZ:",
            "                converters.append(self.convert_datetimefield_value)",
            "        elif internal_type == \"DateField\":",
            "            converters.append(self.convert_datefield_value)",
            "        elif internal_type == \"TimeField\":",
            "            converters.append(self.convert_timefield_value)",
            "        elif internal_type == \"UUIDField\":",
            "            converters.append(self.convert_uuidfield_value)",
            "        # Oracle stores empty strings as null. If the field accepts the empty",
            "        # string, undo this to adhere to the Django convention of using",
            "        # the empty string instead of null.",
            "        if expression.output_field.empty_strings_allowed:",
            "            converters.append(",
            "                self.convert_empty_bytes",
            "                if internal_type == \"BinaryField\"",
            "                else self.convert_empty_string",
            "            )",
            "        return converters",
            "",
            "    def convert_textfield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.LOB):",
            "            value = value.read()",
            "        return value",
            "",
            "    def convert_binaryfield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.LOB):",
            "            value = force_bytes(value.read())",
            "        return value",
            "",
            "    def convert_booleanfield_value(self, value, expression, connection):",
            "        if value in (0, 1):",
            "            value = bool(value)",
            "        return value",
            "",
            "    # cx_Oracle always returns datetime.datetime objects for",
            "    # DATE and TIMESTAMP columns, but Django wants to see a",
            "    # python datetime.date, .time, or .datetime.",
            "",
            "    def convert_datetimefield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = timezone.make_aware(value, self.connection.timezone)",
            "        return value",
            "",
            "    def convert_datefield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.Timestamp):",
            "            value = value.date()",
            "        return value",
            "",
            "    def convert_timefield_value(self, value, expression, connection):",
            "        if isinstance(value, Database.Timestamp):",
            "            value = value.time()",
            "        return value",
            "",
            "    def convert_uuidfield_value(self, value, expression, connection):",
            "        if value is not None:",
            "            value = uuid.UUID(value)",
            "        return value",
            "",
            "    @staticmethod",
            "    def convert_empty_string(value, expression, connection):",
            "        return \"\" if value is None else value",
            "",
            "    @staticmethod",
            "    def convert_empty_bytes(value, expression, connection):",
            "        return b\"\" if value is None else value",
            "",
            "    def deferrable_sql(self):",
            "        return \" DEFERRABLE INITIALLY DEFERRED\"",
            "",
            "    def fetch_returned_insert_columns(self, cursor, returning_params):",
            "        columns = []",
            "        for param in returning_params:",
            "            value = param.get_value()",
            "            if value == []:",
            "                raise DatabaseError(",
            "                    \"The database did not return a new row id. Probably \"",
            "                    '\"ORA-1403: no data found\" was raised internally but was '",
            "                    \"hidden by the Oracle OCI library (see \"",
            "                    \"https://code.djangoproject.com/ticket/28859).\"",
            "                )",
            "            columns.append(value[0])",
            "        return tuple(columns)",
            "",
            "    def field_cast_sql(self, db_type, internal_type):",
            "        if db_type and db_type.endswith(\"LOB\") and internal_type != \"JSONField\":",
            "            return \"DBMS_LOB.SUBSTR(%s)\"",
            "        else:",
            "            return \"%s\"",
            "",
            "    def no_limit_value(self):",
            "        return None",
            "",
            "    def limit_offset_sql(self, low_mark, high_mark):",
            "        fetch, offset = self._get_limit_offset_params(low_mark, high_mark)",
            "        return \" \".join(",
            "            sql",
            "            for sql in (",
            "                (\"OFFSET %d ROWS\" % offset) if offset else None,",
            "                (\"FETCH FIRST %d ROWS ONLY\" % fetch) if fetch else None,",
            "            )",
            "            if sql",
            "        )",
            "",
            "    def last_executed_query(self, cursor, sql, params):",
            "        # https://cx-oracle.readthedocs.io/en/latest/api_manual/cursor.html#Cursor.statement",
            "        # The DB API definition does not define this attribute.",
            "        statement = cursor.statement",
            "        # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's",
            "        # `statement` doesn't contain the query parameters. Substitute",
            "        # parameters manually.",
            "        if isinstance(params, (tuple, list)):",
            "            for i, param in enumerate(reversed(params), start=1):",
            "                param_num = len(params) - i",
            "                statement = statement.replace(",
            "                    \":arg%d\" % param_num, force_str(param, errors=\"replace\")",
            "                )",
            "        elif isinstance(params, dict):",
            "            for key in sorted(params, key=len, reverse=True):",
            "                statement = statement.replace(",
            "                    \":%s\" % key, force_str(params[key], errors=\"replace\")",
            "                )",
            "        return statement",
            "",
            "    def last_insert_id(self, cursor, table_name, pk_name):",
            "        sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)",
            "        cursor.execute('\"%s\".currval' % sq_name)",
            "        return cursor.fetchone()[0]",
            "",
            "    def lookup_cast(self, lookup_type, internal_type=None):",
            "        if lookup_type in (\"iexact\", \"icontains\", \"istartswith\", \"iendswith\"):",
            "            return \"UPPER(%s)\"",
            "        if internal_type == \"JSONField\" and lookup_type == \"exact\":",
            "            return \"DBMS_LOB.SUBSTR(%s)\"",
            "        return \"%s\"",
            "",
            "    def max_in_list_size(self):",
            "        return 1000",
            "",
            "    def max_name_length(self):",
            "        return 30",
            "",
            "    def pk_default_value(self):",
            "        return \"NULL\"",
            "",
            "    def prep_for_iexact_query(self, x):",
            "        return x",
            "",
            "    def process_clob(self, value):",
            "        if value is None:",
            "            return \"\"",
            "        return value.read()",
            "",
            "    def quote_name(self, name):",
            "        # SQL92 requires delimited (quoted) names to be case-sensitive.  When",
            "        # not quoted, Oracle has case-insensitive behavior for identifiers, but",
            "        # always defaults to uppercase.",
            "        # We simplify things by making Oracle identifiers always uppercase.",
            "        if not name.startswith('\"') and not name.endswith('\"'):",
            "            name = '\"%s\"' % truncate_name(name, self.max_name_length())",
            "        # Oracle puts the query text into a (query % args) construct, so % signs",
            "        # in names need to be escaped. The '%%' will be collapsed back to '%' at",
            "        # that stage so we aren't really making the name longer here.",
            "        name = name.replace(\"%\", \"%%\")",
            "        return name.upper()",
            "",
            "    def regex_lookup(self, lookup_type):",
            "        if lookup_type == \"regex\":",
            "            match_option = \"'c'\"",
            "        else:",
            "            match_option = \"'i'\"",
            "        return \"REGEXP_LIKE(%%s, %%s, %s)\" % match_option",
            "",
            "    def return_insert_columns(self, fields):",
            "        if not fields:",
            "            return \"\", ()",
            "        field_names = []",
            "        params = []",
            "        for field in fields:",
            "            field_names.append(",
            "                \"%s.%s\"",
            "                % (",
            "                    self.quote_name(field.model._meta.db_table),",
            "                    self.quote_name(field.column),",
            "                )",
            "            )",
            "            params.append(InsertVar(field))",
            "        return \"RETURNING %s INTO %s\" % (",
            "            \", \".join(field_names),",
            "            \", \".join([\"%s\"] * len(params)),",
            "        ), tuple(params)",
            "",
            "    def __foreign_key_constraints(self, table_name, recursive):",
            "        with self.connection.cursor() as cursor:",
            "            if recursive:",
            "                cursor.execute(",
            "                    \"\"\"",
            "                    SELECT",
            "                        user_tables.table_name, rcons.constraint_name",
            "                    FROM",
            "                        user_tables",
            "                    JOIN",
            "                        user_constraints cons",
            "                        ON (user_tables.table_name = cons.table_name",
            "                        AND cons.constraint_type = ANY('P', 'U'))",
            "                    LEFT JOIN",
            "                        user_constraints rcons",
            "                        ON (user_tables.table_name = rcons.table_name",
            "                        AND rcons.constraint_type = 'R')",
            "                    START WITH user_tables.table_name = UPPER(%s)",
            "                    CONNECT BY",
            "                        NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name",
            "                    GROUP BY",
            "                        user_tables.table_name, rcons.constraint_name",
            "                    HAVING user_tables.table_name != UPPER(%s)",
            "                    ORDER BY MAX(level) DESC",
            "                    \"\"\",",
            "                    (table_name, table_name),",
            "                )",
            "            else:",
            "                cursor.execute(",
            "                    \"\"\"",
            "                    SELECT",
            "                        cons.table_name, cons.constraint_name",
            "                    FROM",
            "                        user_constraints cons",
            "                    WHERE",
            "                        cons.constraint_type = 'R'",
            "                        AND cons.table_name = UPPER(%s)",
            "                    \"\"\",",
            "                    (table_name,),",
            "                )",
            "            return cursor.fetchall()",
            "",
            "    @cached_property",
            "    def _foreign_key_constraints(self):",
            "        # 512 is large enough to fit the ~330 tables (as of this writing) in",
            "        # Django's test suite.",
            "        return lru_cache(maxsize=512)(self.__foreign_key_constraints)",
            "",
            "    def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):",
            "        if not tables:",
            "            return []",
            "",
            "        truncated_tables = {table.upper() for table in tables}",
            "        constraints = set()",
            "        # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign",
            "        # keys which Django doesn't define. Emulate the PostgreSQL behavior",
            "        # which truncates all dependent tables by manually retrieving all",
            "        # foreign key constraints and resolving dependencies.",
            "        for table in tables:",
            "            for foreign_table, constraint in self._foreign_key_constraints(",
            "                table, recursive=allow_cascade",
            "            ):",
            "                if allow_cascade:",
            "                    truncated_tables.add(foreign_table)",
            "                constraints.add((foreign_table, constraint))",
            "        sql = (",
            "            [",
            "                \"%s %s %s %s %s %s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"ALTER\"),",
            "                    style.SQL_KEYWORD(\"TABLE\"),",
            "                    style.SQL_FIELD(self.quote_name(table)),",
            "                    style.SQL_KEYWORD(\"DISABLE\"),",
            "                    style.SQL_KEYWORD(\"CONSTRAINT\"),",
            "                    style.SQL_FIELD(self.quote_name(constraint)),",
            "                    style.SQL_KEYWORD(\"KEEP\"),",
            "                    style.SQL_KEYWORD(\"INDEX\"),",
            "                )",
            "                for table, constraint in constraints",
            "            ]",
            "            + [",
            "                \"%s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"TRUNCATE\"),",
            "                    style.SQL_KEYWORD(\"TABLE\"),",
            "                    style.SQL_FIELD(self.quote_name(table)),",
            "                )",
            "                for table in truncated_tables",
            "            ]",
            "            + [",
            "                \"%s %s %s %s %s %s;\"",
            "                % (",
            "                    style.SQL_KEYWORD(\"ALTER\"),",
            "                    style.SQL_KEYWORD(\"TABLE\"),",
            "                    style.SQL_FIELD(self.quote_name(table)),",
            "                    style.SQL_KEYWORD(\"ENABLE\"),",
            "                    style.SQL_KEYWORD(\"CONSTRAINT\"),",
            "                    style.SQL_FIELD(self.quote_name(constraint)),",
            "                )",
            "                for table, constraint in constraints",
            "            ]",
            "        )",
            "        if reset_sequences:",
            "            sequences = [",
            "                sequence",
            "                for sequence in self.connection.introspection.sequence_list()",
            "                if sequence[\"table\"].upper() in truncated_tables",
            "            ]",
            "            # Since we've just deleted all the rows, running our sequence ALTER",
            "            # code will reset the sequence to 0.",
            "            sql.extend(self.sequence_reset_by_name_sql(style, sequences))",
            "        return sql",
            "",
            "    def sequence_reset_by_name_sql(self, style, sequences):",
            "        sql = []",
            "        for sequence_info in sequences:",
            "            no_autofield_sequence_name = self._get_no_autofield_sequence_name(",
            "                sequence_info[\"table\"]",
            "            )",
            "            table = self.quote_name(sequence_info[\"table\"])",
            "            column = self.quote_name(sequence_info[\"column\"] or \"id\")",
            "            query = self._sequence_reset_sql % {",
            "                \"no_autofield_sequence_name\": no_autofield_sequence_name,",
            "                \"table\": table,",
            "                \"column\": column,",
            "                \"table_name\": strip_quotes(table),",
            "                \"column_name\": strip_quotes(column),",
            "            }",
            "            sql.append(query)",
            "        return sql",
            "",
            "    def sequence_reset_sql(self, style, model_list):",
            "        output = []",
            "        query = self._sequence_reset_sql",
            "        for model in model_list:",
            "            for f in model._meta.local_fields:",
            "                if isinstance(f, AutoField):",
            "                    no_autofield_sequence_name = self._get_no_autofield_sequence_name(",
            "                        model._meta.db_table",
            "                    )",
            "                    table = self.quote_name(model._meta.db_table)",
            "                    column = self.quote_name(f.column)",
            "                    output.append(",
            "                        query",
            "                        % {",
            "                            \"no_autofield_sequence_name\": no_autofield_sequence_name,",
            "                            \"table\": table,",
            "                            \"column\": column,",
            "                            \"table_name\": strip_quotes(table),",
            "                            \"column_name\": strip_quotes(column),",
            "                        }",
            "                    )",
            "                    # Only one AutoField is allowed per model, so don't",
            "                    # continue to loop",
            "                    break",
            "        return output",
            "",
            "    def start_transaction_sql(self):",
            "        return \"\"",
            "",
            "    def tablespace_sql(self, tablespace, inline=False):",
            "        if inline:",
            "            return \"USING INDEX TABLESPACE %s\" % self.quote_name(tablespace)",
            "        else:",
            "            return \"TABLESPACE %s\" % self.quote_name(tablespace)",
            "",
            "    def adapt_datefield_value(self, value):",
            "        \"\"\"",
            "        Transform a date value to an object compatible with what is expected",
            "        by the backend driver for date columns.",
            "        The default implementation transforms the date to text, but that is not",
            "        necessary for Oracle.",
            "        \"\"\"",
            "        return value",
            "",
            "    def adapt_datetimefield_value(self, value):",
            "        \"\"\"",
            "        Transform a datetime value to an object compatible with what is expected",
            "        by the backend driver for datetime columns.",
            "",
            "        If naive datetime is passed assumes that is in UTC. Normally Django",
            "        models.DateTimeField makes sure that if USE_TZ is True passed datetime",
            "        is timezone aware.",
            "        \"\"\"",
            "",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        # cx_Oracle doesn't support tz-aware datetimes",
            "        if timezone.is_aware(value):",
            "            if settings.USE_TZ:",
            "                value = timezone.make_naive(value, self.connection.timezone)",
            "            else:",
            "                raise ValueError(",
            "                    \"Oracle backend does not support timezone-aware datetimes when \"",
            "                    \"USE_TZ is False.\"",
            "                )",
            "",
            "        return Oracle_datetime.from_datetime(value)",
            "",
            "    def adapt_timefield_value(self, value):",
            "        if value is None:",
            "            return None",
            "",
            "        # Expression values are adapted by the database.",
            "        if hasattr(value, \"resolve_expression\"):",
            "            return value",
            "",
            "        if isinstance(value, str):",
            "            return datetime.datetime.strptime(value, \"%H:%M:%S\")",
            "",
            "        # Oracle doesn't support tz-aware times",
            "        if timezone.is_aware(value):",
            "            raise ValueError(\"Oracle backend does not support timezone-aware times.\")",
            "",
            "        return Oracle_datetime(",
            "            1900, 1, 1, value.hour, value.minute, value.second, value.microsecond",
            "        )",
            "",
            "    def adapt_decimalfield_value(self, value, max_digits=None, decimal_places=None):",
            "        return value",
            "",
            "    def combine_expression(self, connector, sub_expressions):",
            "        lhs, rhs = sub_expressions",
            "        if connector == \"%%\":",
            "            return \"MOD(%s)\" % \",\".join(sub_expressions)",
            "        elif connector == \"&\":",
            "            return \"BITAND(%s)\" % \",\".join(sub_expressions)",
            "        elif connector == \"|\":",
            "            return \"BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        elif connector == \"<<\":",
            "            return \"(%(lhs)s * POWER(2, %(rhs)s))\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        elif connector == \">>\":",
            "            return \"FLOOR(%(lhs)s / POWER(2, %(rhs)s))\" % {\"lhs\": lhs, \"rhs\": rhs}",
            "        elif connector == \"^\":",
            "            return \"POWER(%s)\" % \",\".join(sub_expressions)",
            "        elif connector == \"#\":",
            "            raise NotSupportedError(\"Bitwise XOR is not supported in Oracle.\")",
            "        return super().combine_expression(connector, sub_expressions)",
            "",
            "    def _get_no_autofield_sequence_name(self, table):",
            "        \"\"\"",
            "        Manually created sequence name to keep backward compatibility for",
            "        AutoFields that aren't Oracle identity columns.",
            "        \"\"\"",
            "        name_length = self.max_name_length() - 3",
            "        return \"%s_SQ\" % truncate_name(strip_quotes(table), name_length).upper()",
            "",
            "    def _get_sequence_name(self, cursor, table, pk_name):",
            "        cursor.execute(",
            "            \"\"\"",
            "            SELECT sequence_name",
            "            FROM user_tab_identity_cols",
            "            WHERE table_name = UPPER(%s)",
            "            AND column_name = UPPER(%s)\"\"\",",
            "            [table, pk_name],",
            "        )",
            "        row = cursor.fetchone()",
            "        return self._get_no_autofield_sequence_name(table) if row is None else row[0]",
            "",
            "    def bulk_insert_sql(self, fields, placeholder_rows):",
            "        query = []",
            "        for row in placeholder_rows:",
            "            select = []",
            "            for i, placeholder in enumerate(row):",
            "                # A model without any fields has fields=[None].",
            "                if fields[i]:",
            "                    internal_type = getattr(",
            "                        fields[i], \"target_field\", fields[i]",
            "                    ).get_internal_type()",
            "                    placeholder = (",
            "                        BulkInsertMapper.types.get(internal_type, \"%s\") % placeholder",
            "                    )",
            "                # Add columns aliases to the first select to avoid \"ORA-00918:",
            "                # column ambiguously defined\" when two or more columns in the",
            "                # first select have the same value.",
            "                if not query:",
            "                    placeholder = \"%s col_%s\" % (placeholder, i)",
            "                select.append(placeholder)",
            "            query.append(\"SELECT %s FROM DUAL\" % \", \".join(select))",
            "        # Bulk insert to tables with Oracle identity columns causes Oracle to",
            "        # add sequence.nextval to it. Sequence.nextval cannot be used with the",
            "        # UNION operator. To prevent incorrect SQL, move UNION to a subquery.",
            "        return \"SELECT * FROM (%s)\" % \" UNION ALL \".join(query)",
            "",
            "    def subtract_temporals(self, internal_type, lhs, rhs):",
            "        if internal_type == \"DateField\":",
            "            lhs_sql, lhs_params = lhs",
            "            rhs_sql, rhs_params = rhs",
            "            params = (*lhs_params, *rhs_params)",
            "            return (",
            "                \"NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')\" % (lhs_sql, rhs_sql),",
            "                params,",
            "            )",
            "        return super().subtract_temporals(internal_type, lhs, rhs)",
            "",
            "    def bulk_batch_size(self, fields, objs):",
            "        \"\"\"Oracle restricts the number of parameters in a query.\"\"\"",
            "        if fields:",
            "            return self.connection.features.max_query_params // len(fields)",
            "        return len(objs)",
            "",
            "    def conditional_expression_supported_in_where_clause(self, expression):",
            "        \"\"\"",
            "        Oracle supports only EXISTS(...) or filters in the WHERE clause, others",
            "        must be compared with True.",
            "        \"\"\"",
            "        if isinstance(expression, (Exists, Lookup, WhereNode)):",
            "            return True",
            "        if isinstance(expression, ExpressionWrapper) and expression.conditional:",
            "            return self.conditional_expression_supported_in_where_clause(",
            "                expression.expression",
            "            )",
            "        if isinstance(expression, RawSQL) and expression.conditional:",
            "            return True",
            "        return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "108": [
                "DatabaseOperations",
                "date_trunc_sql"
            ],
            "131": [
                "DatabaseOperations",
                "_convert_field_to_tz"
            ],
            "150": [
                "DatabaseOperations",
                "datetime_cast_date_sql"
            ],
            "156": [
                "DatabaseOperations",
                "datetime_cast_time_sql"
            ],
            "167": [
                "DatabaseOperations",
                "datetime_extract_sql"
            ],
            "171": [
                "DatabaseOperations",
                "datetime_trunc_sql"
            ],
            "195": [
                "DatabaseOperations",
                "time_trunc_sql"
            ]
        },
        "addLocation": []
    }
}