{
    "nautobot/core/settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 645,
                "afterPatchRowNumber": 645,
                "PatchRowcode": "     ),"
            },
            "1": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 646,
                "PatchRowcode": "     \"NETWORK_DRIVERS\": ConstanceConfigItem("
            },
            "2": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 647,
                "PatchRowcode": "         default={},"
            },
            "3": {
                "beforePatchRowNumber": 648,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        help_text=mark_safe("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 648,
                "PatchRowcode": "+        help_text=mark_safe(  # noqa: S308"
            },
            "5": {
                "beforePatchRowNumber": 649,
                "afterPatchRowNumber": 649,
                "PatchRowcode": "             \"Extend or override default Platform.network_driver translations provided by \""
            },
            "6": {
                "beforePatchRowNumber": 650,
                "afterPatchRowNumber": 650,
                "PatchRowcode": "             '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '"
            },
            "7": {
                "beforePatchRowNumber": 651,
                "afterPatchRowNumber": 651,
                "PatchRowcode": "             \"Enter a dictionary in JSON format, for example:\\n\""
            }
        },
        "frontPatchFile": [
            "import os",
            "import platform",
            "import re",
            "import sys",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.settings_funcs import is_truthy, parse_redis_connection, ConstanceConfigItem  # noqa: F401",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI. There are also VERSION_MAJOR and VERSION_MINOR derived from this later.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can\u2019t do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "ALLOWED_URL_SCHEMES = (",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            ")",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# The directory where the Nautobot UI packaging is stored.",
            "NAUTOBOT_UI_DIR = os.path.join(NAUTOBOT_ROOT, \"ui\")",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (re.compile(r\"(username|password|passwd|pwd)((?:\\s+is.?|:)?\\s+)\\S+\", re.IGNORECASE), r\"\\1\\2{replacement}\"),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "VERSION_MAJOR, VERSION_MINOR = [int(v) for v in REST_FRAMEWORK_VERSION.split(\".\")]",
            "# We support all major.minor API versions from 2.0 to the present latest version.",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "assert VERSION_MAJOR == 2, f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {VERSION_MAJOR}\"",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{VERSION_MAJOR}.{minor}\" for minor in range(0, VERSION_MINOR + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (",
            "        \"nautobot.core.api.filter_backends.NautobotFilterBackend\",",
            "        \"rest_framework.filters.OrderingFilter\",",
            "    ),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.NautobotMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"nautobot.core.api.renderers.NautobotJSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "        \"nautobot.core.api.renderers.NautobotCSVRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (",
            "        \"rest_framework.parsers.JSONParser\",",
            "        \"nautobot.core.api.parsers.NautobotCSVParser\",",
            "    ),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise. Default to current (i.e. latest)",
            "    \"DEFAULT_VERSION\": REST_FRAMEWORK_VERSION,",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"ORDERING_PARAM\": \"sort\",  # This is not meant to be changed by users, but is used internally by the API",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.core.api.utils.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"SWAGGER_UI_SETTINGS\": {",
            "        \"deepLinking\": True,",
            "        \"displayOperationId\": True,",
            "    },",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    # Do not list all possible enum values in the description of filter fields and the like",
            "    # In addition to being highly verbose, it's inaccurate for filter fields like *__ic and *__re",
            "    \"ENUM_GENERATE_CHOICE_DESCRIPTION\": False,",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"IPAddressTypeChoices\": \"nautobot.ipam.choices.IPAddressTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"PrefixTypeChoices\": \"nautobot.ipam.choices.PrefixTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "# Only PostgresSQL is supported, so database driver is hard-coded. This can",
            "# still be overloaded in custom settings.",
            "# https://docs.djangoproject.com/en/stable/ref/settings/#databases",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\")",
            "",
            "# Default overrides",
            "ALLOWED_HOSTS = os.getenv(\"NAUTOBOT_ALLOWED_HOSTS\", \"\").split(\" \")",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = (\"127.0.0.1\", \"::1\")",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = \"test\" in sys.argv",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # Log to null handler instead of stderr during testing",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"handlers\": {\"console\": {\"level\": \"INFO\", \"class\": \"logging.NullHandler\"}},",
            "        \"loggers\": {\"nautobot\": {\"handlers\": [\"console\"], \"level\": \"INFO\"}},",
            "    }",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "SHORT_TIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_TIME_FORMAT\", \"H:i:s\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_results\",",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.virtualization\",",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (",
            "    os.path.join(BASE_DIR, \"project-static\"),",
            "    os.path.join(NAUTOBOT_UI_DIR, \"build\", \"static\"),",
            ")",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.core.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"BANNER_BOTTOM\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ),",
            "    \"BANNER_LOGIN\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the top of the login page.\",",
            "    ),",
            "    \"BANNER_TOP\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the top of all pages.\",",
            "    ),",
            "    \"CHANGELOG_RETENTION\": ConstanceConfigItem(",
            "        default=90,",
            "        help_text=\"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "        field_type=int,",
            "    ),",
            "    \"DEVICE_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Device names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the device name alone as the natural key for Device objects. \"",
            "        \"Set this to False to use the sequence (name, tenant, location) as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"DEPLOYMENT_ID\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "        field_type=str,",
            "    ),",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": ConstanceConfigItem(",
            "        default=0,",
            "        help_text=\"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "        field_type=int,",
            "    ),",
            "    \"FEEDBACK_BUTTON_ENABLED\": ConstanceConfigItem(",
            "        default=True,",
            "        help_text=\"Whether to show the Feedback button in the new UI sidebar.\",",
            "        field_type=bool,",
            "    ),",
            "    \"HIDE_RESTRICTED_UI\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"If set to True, users with limited permissions will not be shown menu items and home-page elements that \"",
            "        \"they do not have permission to access.\",",
            "        field_type=bool,",
            "    ),",
            "    \"LOCATION_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Location names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the location name alone as the natural key for Location objects. \"",
            "        \"Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) \"",
            "        \"as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"MAX_PAGE_SIZE\": ConstanceConfigItem(",
            "        default=1000,",
            "        help_text=\"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "        field_type=int,",
            "    ),",
            "    \"PAGINATE_COUNT\": ConstanceConfigItem(",
            "        default=50,",
            "        help_text=\"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "        field_type=int,",
            "    ),",
            "    \"PER_PAGE_DEFAULTS\": ConstanceConfigItem(",
            "        default=[25, 50, 100, 250, 500, 1000],",
            "        help_text=\"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        field_type=\"per_page_defaults_field\",",
            "    ),",
            "    \"NETWORK_DRIVERS\": ConstanceConfigItem(",
            "        default={},",
            "        help_text=mark_safe(",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            \"<pre>{\\n\"",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        field_type=\"optional_json_field\",",
            "    ),",
            "    \"PREFER_IPV4\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "        field_type=bool,",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": ConstanceConfigItem(",
            "        default=22, help_text=\"Default height (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": ConstanceConfigItem(",
            "        default=230, help_text=\"Default width (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RELEASE_CHECK_TIMEOUT\": ConstanceConfigItem(",
            "        default=24 * 3600,",
            "        help_text=\"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_timeout_field\",",
            "    ),",
            "    \"RELEASE_CHECK_URL\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_url_field\",",
            "    ),",
            "    \"SUPPORT_MESSAGE\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Help message to include on 4xx and 5xx error pages. Markdown is supported.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ),",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Natural Keys\": [\"DEVICE_NAME_AS_NATURAL_KEY\", \"LOCATION_NAME_AS_NATURAL_KEY\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"],",
            "    \"Rack Elevation Rendering\": [\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"HIDE_RESTRICTED_UI\", \"FEEDBACK_BUTTON_ENABLED\", \"SUPPORT_MESSAGE\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=1),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results",
            "CELERY_RESULT_BACKEND = \"nautobot.core.celery.backends.NautobotDatabaseBackend\"",
            "",
            "# Enables extended task result attributes (name, args, kwargs, worker, retries, queue, delivery_info) to be written to backend.",
            "CELERY_RESULT_EXTENDED = True",
            "",
            "# A value of None or 0 means results will never expire (depending on backend specifications).",
            "CELERY_RESULT_EXPIRES = None",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# If enabled, a `task-sent` event will be sent for every task so tasks can be tracked before they\u2019re consumed by a worker.",
            "CELERY_TASK_SEND_SENT_EVENT = True",
            "",
            "# If enabled stdout and stderr of running jobs will be redirected to the task logger.",
            "CELERY_WORKER_REDIRECT_STDOUTS = is_truthy(os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS\", \"True\"))",
            "",
            "# The log level of log messages generated by redirected job stdout and stderr. Can be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`.",
            "CELERY_WORKER_REDIRECT_STDOUTS_LEVEL = os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL\", \"WARNING\")",
            "",
            "# Send task-related events so that tasks can be monitored using tools like flower. Sets the default value for the workers -E argument.",
            "CELERY_WORKER_SEND_TASK_EVENTS = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(\",\")",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]",
            "",
            "",
            "# Custom JSON schema serializer field type mappingss. These will be added to",
            "# `NautobotProcessingMixin.TYPE_MAP`.",
            "# Format: `{serializer_field_class.__name__}` => `{json_schema_type}`",
            "# See: https://github.com/yoyowallet/drf-react-template-framework#settings",
            "DRF_REACT_TEMPLATE_TYPE_MAP = {",
            "    \"ContentTypeField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"CustomFieldsDataField\": {\"type\": \"object\", \"widget\": \"textarea\"},",
            "    \"DateTimeField\": {\"type\": \"string\", \"format\": \"date-time\", \"widget\": \"date-time\"},",
            "    \"ImageField\": {\"type\": \"string\", \"format\": \"data-url\"},",
            "    \"IPFieldSerializer\": {\"type\": \"string\"},",
            "    \"JSONField\": {\"type\": \"string\", \"widget\": \"textarea\"},",
            "    \"MultipleChoiceJSONField\": {\"type\": \"array\", \"required\": [], \"enum\": \"choices\"},",
            "    \"ManyRelatedField\": {\"type\": \"array\", \"required\": []},",
            "    #",
            "    # Foreign Key fields",
            "    #",
            "    # enum=choices is the one that works in the UI as a related field but it",
            "    # includes ALL related objects in the schema.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    # readOnly=True disables the fields in the UI; not what we want.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"readOnly\": True},",
            "    # type=string results in a free text field; also not what we want. For now,",
            "    # however, this will keep things moving so the unit tests pass.",
            "    \"NautobotHyperlinkedRelatedField\": {\"type\": \"object\"},",
            "    \"PrimaryKeyRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"RelationshipsDataField\": {\"type\": \"object\"},",
            "    \"SlugField\": {\"type\": \"string\"},",
            "    \"TimeZoneSerializerField\": {\"type\": \"string\"},",
            "    \"UUIDField\": {\"type\": \"string\", \"format\": \"uuid\"},",
            "}",
            "",
            "# Turn on or off new ui feature",
            "ENABLE_ALPHA_UI = is_truthy(os.getenv(\"NAUTOBOT_ENABLE_ALPHA_UI\", \"False\"))"
        ],
        "afterPatchFile": [
            "import os",
            "import platform",
            "import re",
            "import sys",
            "",
            "from django.contrib.messages import constants as messages",
            "import django.forms",
            "from django.utils.safestring import mark_safe",
            "",
            "from nautobot import __version__",
            "from nautobot.core.settings_funcs import is_truthy, parse_redis_connection, ConstanceConfigItem  # noqa: F401",
            "",
            "#",
            "# Environment setup",
            "#",
            "",
            "# This is used for display in the UI. There are also VERSION_MAJOR and VERSION_MINOR derived from this later.",
            "VERSION = __version__",
            "",
            "# Hostname of the system. This is displayed in the web UI footers along with the",
            "# version.",
            "HOSTNAME = platform.node()",
            "",
            "# Set the base directory two levels up (i.e. the base nautobot/ directory)",
            "BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))",
            "",
            "# Set the swapable User model to the Nautobot custom User model",
            "AUTH_USER_MODEL = \"users.User\"",
            "",
            "# Set the default AutoField for 3rd party apps",
            "# N.B. Ideally this would be a `UUIDField`, but due to Django restrictions",
            "#      we can\u2019t do that yet",
            "DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"",
            "",
            "",
            "###############################################################",
            "# NAUTOBOT - Settings for Nautobot internals/plugins/defaults #",
            "###############################################################",
            "",
            "#",
            "# Nautobot optional settings/defaults",
            "#",
            "ALLOWED_URL_SCHEMES = (",
            "    \"file\",",
            "    \"ftp\",",
            "    \"ftps\",",
            "    \"http\",",
            "    \"https\",",
            "    \"irc\",",
            "    \"mailto\",",
            "    \"sftp\",",
            "    \"ssh\",",
            "    \"tel\",",
            "    \"telnet\",",
            "    \"tftp\",",
            "    \"vnc\",",
            "    \"xmpp\",",
            ")",
            "",
            "# Base directory wherein all created files (jobs, git repositories, file uploads, static files) will be stored)",
            "NAUTOBOT_ROOT = os.getenv(\"NAUTOBOT_ROOT\", os.path.expanduser(\"~/.nautobot\"))",
            "",
            "# The directory where the Nautobot UI packaging is stored.",
            "NAUTOBOT_UI_DIR = os.path.join(NAUTOBOT_ROOT, \"ui\")",
            "",
            "# Disable linking of Config Context objects via Dynamic Groups by default. This could cause performance impacts",
            "# when a large number of dynamic groups are present",
            "CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED\", \"False\"))",
            "",
            "# Exclude potentially sensitive models from wildcard view exemption. These may still be exempted",
            "# by specifying the model individually in the EXEMPT_VIEW_PERMISSIONS configuration parameter.",
            "EXEMPT_EXCLUDE_MODELS = (",
            "    (\"auth\", \"group\"),",
            "    (\"users\", \"user\"),",
            "    (\"users\", \"objectpermission\"),",
            ")",
            "",
            "# Models to exempt from the enforcement of view permissions",
            "EXEMPT_VIEW_PERMISSIONS = []",
            "",
            "# The file path to a directory where cloned Git repositories will be located",
            "GIT_ROOT = os.getenv(\"NAUTOBOT_GIT_ROOT\", os.path.join(NAUTOBOT_ROOT, \"git\").rstrip(\"/\"))",
            "",
            "# HTTP proxies to use for outbound requests originating from Nautobot (e.g. when sending webhook requests)",
            "HTTP_PROXIES = None",
            "",
            "# Send anonymized installation metrics when post_upgrade or send_installation_metrics management commands are run",
            "INSTALLATION_METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_INSTALLATION_METRICS_ENABLED\", \"True\"))",
            "",
            "# The file path to a directory where locally installed Jobs can be discovered",
            "JOBS_ROOT = os.getenv(\"NAUTOBOT_JOBS_ROOT\", os.path.join(NAUTOBOT_ROOT, \"jobs\").rstrip(\"/\"))",
            "",
            "# Log Nautobot deprecation warnings. Note that this setting is ignored (deprecation logs always enabled) if DEBUG = True",
            "LOG_DEPRECATION_WARNINGS = is_truthy(os.getenv(\"NAUTOBOT_LOG_DEPRECATION_WARNINGS\", \"False\"))",
            "",
            "MAINTENANCE_MODE = is_truthy(os.getenv(\"NAUTOBOT_MAINTENANCE_MODE\", \"False\"))",
            "# Metrics",
            "METRICS_ENABLED = is_truthy(os.getenv(\"NAUTOBOT_METRICS_ENABLED\", \"False\"))",
            "",
            "# Napalm",
            "NAPALM_ARGS = {}",
            "NAPALM_PASSWORD = os.getenv(\"NAUTOBOT_NAPALM_PASSWORD\", \"\")",
            "NAPALM_TIMEOUT = int(os.getenv(\"NAUTOBOT_NAPALM_TIMEOUT\", \"30\"))",
            "NAPALM_USERNAME = os.getenv(\"NAUTOBOT_NAPALM_USERNAME\", \"\")",
            "",
            "# Plugins",
            "PLUGINS = []",
            "PLUGINS_CONFIG = {}",
            "",
            "# Global 3rd-party authentication settings",
            "EXTERNAL_AUTH_DEFAULT_GROUPS = []",
            "EXTERNAL_AUTH_DEFAULT_PERMISSIONS = {}",
            "",
            "# Remote auth backend settings",
            "REMOTE_AUTH_AUTO_CREATE_USER = False",
            "REMOTE_AUTH_HEADER = \"HTTP_REMOTE_USER\"",
            "",
            "# SSO backend settings https://python-social-auth.readthedocs.io/en/latest/configuration/settings.html",
            "SOCIAL_AUTH_POSTGRES_JSONFIELD = False",
            "# Nautobot related - May be overridden if using custom social auth backend",
            "SOCIAL_AUTH_BACKEND_PREFIX = \"social_core.backends\"",
            "",
            "# Job log entry sanitization and similar",
            "SANITIZER_PATTERNS = [",
            "    # General removal of username-like and password-like tokens",
            "    (re.compile(r\"(https?://)?\\S+\\s*@\", re.IGNORECASE), r\"\\1{replacement}@\"),",
            "    (re.compile(r\"(username|password|passwd|pwd)((?:\\s+is.?|:)?\\s+)\\S+\", re.IGNORECASE), r\"\\1\\2{replacement}\"),",
            "]",
            "",
            "# Storage",
            "STORAGE_BACKEND = None",
            "STORAGE_CONFIG = {}",
            "",
            "# Test runner that is aware of our use of \"integration\" tags and only runs",
            "# integration tests if explicitly passed in with `nautobot-server test --tag integration`.",
            "TEST_RUNNER = \"nautobot.core.tests.runner.NautobotTestRunner\"",
            "# Disable test data factories by default so as not to cause issues for plugins.",
            "# The nautobot_config.py that Nautobot core uses for its own tests will override this to True.",
            "TEST_USE_FACTORIES = is_truthy(os.getenv(\"NAUTOBOT_TEST_USE_FACTORIES\", \"False\"))",
            "# Pseudo-random number generator seed, for reproducibility of test results.",
            "TEST_FACTORY_SEED = os.getenv(\"NAUTOBOT_TEST_FACTORY_SEED\", None)",
            "",
            "#",
            "# django-slowtests",
            "#",
            "",
            "# Performance test uses `NautobotPerformanceTestRunner` to run, which is only available once you have `django-slowtests` installed in your dev environment.",
            "# `invoke performance-test` and adding `--performance-report` or `--performance-snapshot` at the end of the `invoke` command",
            "# will automatically opt to NautobotPerformanceTestRunner to run the tests.",
            "",
            "# The baseline file that the performance test is running against",
            "# TODO we need to replace the baselines in this file with more consistent results at least for CI",
            "TEST_PERFORMANCE_BASELINE_FILE = os.getenv(",
            "    \"NAUTOBOT_TEST_PERFORMANCE_BASELINE_FILE\", \"nautobot/core/tests/performance_baselines.yml\"",
            ")",
            "",
            "#",
            "# Django Prometheus",
            "#",
            "",
            "PROMETHEUS_EXPORT_MIGRATIONS = False",
            "",
            "",
            "#",
            "# Django filters",
            "#",
            "",
            "FILTERS_NULL_CHOICE_LABEL = \"None\"",
            "FILTERS_NULL_CHOICE_VALUE = \"null\"",
            "",
            "STRICT_FILTERING = is_truthy(os.getenv(\"NAUTOBOT_STRICT_FILTERING\", \"True\"))",
            "",
            "#",
            "# Django REST framework (API)",
            "#",
            "",
            "REST_FRAMEWORK_VERSION = VERSION.rsplit(\".\", 1)[0]  # Use major.minor as API version",
            "VERSION_MAJOR, VERSION_MINOR = [int(v) for v in REST_FRAMEWORK_VERSION.split(\".\")]",
            "# We support all major.minor API versions from 2.0 to the present latest version.",
            "# Similar logic exists in tasks.py, please keep them in sync!",
            "assert VERSION_MAJOR == 2, f\"REST_FRAMEWORK_ALLOWED_VERSIONS needs to be updated to handle version {VERSION_MAJOR}\"",
            "REST_FRAMEWORK_ALLOWED_VERSIONS = [f\"{VERSION_MAJOR}.{minor}\" for minor in range(0, VERSION_MINOR + 1)]",
            "",
            "REST_FRAMEWORK = {",
            "    \"ALLOWED_VERSIONS\": REST_FRAMEWORK_ALLOWED_VERSIONS,",
            "    \"DEFAULT_AUTHENTICATION_CLASSES\": (",
            "        \"rest_framework.authentication.SessionAuthentication\",",
            "        \"nautobot.core.api.authentication.TokenAuthentication\",",
            "    ),",
            "    \"DEFAULT_FILTER_BACKENDS\": (",
            "        \"nautobot.core.api.filter_backends.NautobotFilterBackend\",",
            "        \"rest_framework.filters.OrderingFilter\",",
            "    ),",
            "    \"DEFAULT_METADATA_CLASS\": \"nautobot.core.api.metadata.NautobotMetadata\",",
            "    \"DEFAULT_PAGINATION_CLASS\": \"nautobot.core.api.pagination.OptionalLimitOffsetPagination\",",
            "    \"DEFAULT_PERMISSION_CLASSES\": (\"nautobot.core.api.authentication.TokenPermissions\",),",
            "    \"DEFAULT_RENDERER_CLASSES\": (",
            "        \"nautobot.core.api.renderers.NautobotJSONRenderer\",",
            "        \"nautobot.core.api.renderers.FormlessBrowsableAPIRenderer\",",
            "        \"nautobot.core.api.renderers.NautobotCSVRenderer\",",
            "    ),",
            "    \"DEFAULT_PARSER_CLASSES\": (",
            "        \"rest_framework.parsers.JSONParser\",",
            "        \"nautobot.core.api.parsers.NautobotCSVParser\",",
            "    ),",
            "    \"DEFAULT_SCHEMA_CLASS\": \"nautobot.core.api.schema.NautobotAutoSchema\",",
            "    # Version to use if the client doesn't request otherwise. Default to current (i.e. latest)",
            "    \"DEFAULT_VERSION\": REST_FRAMEWORK_VERSION,",
            "    \"DEFAULT_VERSIONING_CLASS\": \"nautobot.core.api.versioning.NautobotAPIVersioning\",",
            "    \"ORDERING_PARAM\": \"sort\",  # This is not meant to be changed by users, but is used internally by the API",
            "    \"PAGE_SIZE\": None,",
            "    \"SCHEMA_COERCE_METHOD_NAMES\": {",
            "        # Default mappings",
            "        \"retrieve\": \"read\",",
            "        \"destroy\": \"delete\",",
            "        # Custom operations",
            "        \"bulk_destroy\": \"bulk_delete\",",
            "    },",
            "    \"VIEW_NAME_FUNCTION\": \"nautobot.core.api.utils.get_view_name\",",
            "}",
            "",
            "",
            "#",
            "# drf_spectacular (OpenAPI/Swagger)",
            "#",
            "",
            "SPECTACULAR_SETTINGS = {",
            "    \"TITLE\": \"API Documentation\",",
            "    \"DESCRIPTION\": \"Source of truth and network automation platform\",",
            "    \"LICENSE\": {\"name\": \"Apache v2 License\"},",
            "    \"VERSION\": VERSION,",
            "    # For a semblance of backwards-compatibility with drf-yasg / OpenAPI 2.0, where \"/api\" was a common \"basePath\"",
            "    # in the schema.",
            "    # OpenAPI 3.0 removes \"basePath\" in favor of \"servers\", so we now declare \"/api\" as the server relative URL and",
            "    # trim it from all of the individual paths correspondingly.",
            "    # See also https://github.com/nautobot/nautobot-ansible/pull/135 for an example of why this is desirable.",
            "    \"SERVERS\": [{\"url\": \"/api\"}],",
            "    \"SCHEMA_PATH_PREFIX\": \"/api\",",
            "    \"SCHEMA_PATH_PREFIX_TRIM\": True,",
            "    # use sidecar - locally packaged UI files, not CDN",
            "    \"SWAGGER_UI_DIST\": \"SIDECAR\",",
            "    \"SWAGGER_UI_FAVICON_HREF\": \"SIDECAR\",",
            "    \"SWAGGER_UI_SETTINGS\": {",
            "        \"deepLinking\": True,",
            "        \"displayOperationId\": True,",
            "    },",
            "    \"REDOC_DIST\": \"SIDECAR\",",
            "    # Do not list all possible enum values in the description of filter fields and the like",
            "    # In addition to being highly verbose, it's inaccurate for filter fields like *__ic and *__re",
            "    \"ENUM_GENERATE_CHOICE_DESCRIPTION\": False,",
            "    \"ENUM_NAME_OVERRIDES\": {",
            "        # These choice enums need to be overridden because they get assigned to the `type` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"type\".",
            "        \"CableTypeChoices\": \"nautobot.dcim.choices.CableTypeChoices\",",
            "        \"ConsolePortTypeChoices\": \"nautobot.dcim.choices.ConsolePortTypeChoices\",",
            "        \"CustomFieldTypeChoices\": \"nautobot.extras.choices.CustomFieldTypeChoices\",",
            "        \"InterfaceTypeChoices\": \"nautobot.dcim.choices.InterfaceTypeChoices\",",
            "        \"IPAddressTypeChoices\": \"nautobot.ipam.choices.IPAddressTypeChoices\",",
            "        \"PortTypeChoices\": \"nautobot.dcim.choices.PortTypeChoices\",",
            "        \"PowerFeedTypeChoices\": \"nautobot.dcim.choices.PowerFeedTypeChoices\",",
            "        \"PowerOutletTypeChoices\": \"nautobot.dcim.choices.PowerOutletTypeChoices\",",
            "        \"PowerPortTypeChoices\": \"nautobot.dcim.choices.PowerPortTypeChoices\",",
            "        \"PrefixTypeChoices\": \"nautobot.ipam.choices.PrefixTypeChoices\",",
            "        \"RackTypeChoices\": \"nautobot.dcim.choices.RackTypeChoices\",",
            "        \"RelationshipTypeChoices\": \"nautobot.extras.choices.RelationshipTypeChoices\",",
            "        # These choice enums need to be overridden because they get assigned to different names with the same choice set and",
            "        # result in this error:",
            "        #   encountered multiple names for the same choice set",
            "        \"JobExecutionTypeIntervalChoices\": \"nautobot.extras.choices.JobExecutionType\",",
            "        # These choice enums need to be overridden because they get assigned to the `protocol` field and",
            "        # result in this error:",
            "        #    enum naming encountered a non-optimally resolvable collision for fields named \"protocol\".",
            "        \"InterfaceRedundancyGroupProtocolChoices\": \"nautobot.dcim.choices.InterfaceRedundancyGroupProtocolChoices\",",
            "        \"ServiceProtocolChoices\": \"nautobot.ipam.choices.ServiceProtocolChoices\",",
            "    },",
            "    # Create separate schema components for PATCH requests (fields generally are not `required` on PATCH)",
            "    \"COMPONENT_SPLIT_PATCH\": True,",
            "    # Create separate schema components for request vs response where appropriate",
            "    \"COMPONENT_SPLIT_REQUEST\": True,",
            "}",
            "",
            "",
            "##############################################",
            "# DJANGO - Core settings required for Django #",
            "##############################################",
            "",
            "#",
            "# Databases",
            "#",
            "",
            "# Only PostgresSQL is supported, so database driver is hard-coded. This can",
            "# still be overloaded in custom settings.",
            "# https://docs.djangoproject.com/en/stable/ref/settings/#databases",
            "DATABASES = {",
            "    \"default\": {",
            "        \"NAME\": os.getenv(\"NAUTOBOT_DB_NAME\", \"nautobot\"),",
            "        \"USER\": os.getenv(\"NAUTOBOT_DB_USER\", \"\"),",
            "        \"PASSWORD\": os.getenv(\"NAUTOBOT_DB_PASSWORD\", \"\"),",
            "        \"HOST\": os.getenv(\"NAUTOBOT_DB_HOST\", \"localhost\"),",
            "        \"PORT\": os.getenv(\"NAUTOBOT_DB_PORT\", \"\"),",
            "        \"CONN_MAX_AGE\": int(os.getenv(\"NAUTOBOT_DB_TIMEOUT\", \"300\")),",
            "        \"ENGINE\": os.getenv(",
            "            \"NAUTOBOT_DB_ENGINE\",",
            "            \"django_prometheus.db.backends.postgresql\" if METRICS_ENABLED else \"django.db.backends.postgresql\",",
            "        ),",
            "    }",
            "}",
            "",
            "# Ensure proper Unicode handling for MySQL",
            "if DATABASES[\"default\"][\"ENGINE\"] == \"django.db.backends.mysql\":",
            "    DATABASES[\"default\"][\"OPTIONS\"] = {\"charset\": \"utf8mb4\"}",
            "",
            "# The secret key is used to encrypt session keys and salt passwords.",
            "SECRET_KEY = os.getenv(\"NAUTOBOT_SECRET_KEY\")",
            "",
            "# Default overrides",
            "ALLOWED_HOSTS = os.getenv(\"NAUTOBOT_ALLOWED_HOSTS\", \"\").split(\" \")",
            "CSRF_TRUSTED_ORIGINS = []",
            "CSRF_FAILURE_VIEW = \"nautobot.core.views.csrf_failure\"",
            "DATE_FORMAT = os.getenv(\"NAUTOBOT_DATE_FORMAT\", \"N j, Y\")",
            "DATETIME_FORMAT = os.getenv(\"NAUTOBOT_DATETIME_FORMAT\", \"N j, Y g:i a\")",
            "DEBUG = is_truthy(os.getenv(\"NAUTOBOT_DEBUG\", \"False\"))",
            "INTERNAL_IPS = (\"127.0.0.1\", \"::1\")",
            "FORCE_SCRIPT_NAME = None",
            "",
            "TESTING = \"test\" in sys.argv",
            "",
            "LOG_LEVEL = \"DEBUG\" if DEBUG else \"INFO\"",
            "",
            "if TESTING:",
            "    # Log to null handler instead of stderr during testing",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"handlers\": {\"console\": {\"level\": \"INFO\", \"class\": \"logging.NullHandler\"}},",
            "        \"loggers\": {\"nautobot\": {\"handlers\": [\"console\"], \"level\": \"INFO\"}},",
            "    }",
            "else:",
            "    LOGGING = {",
            "        \"version\": 1,",
            "        \"disable_existing_loggers\": False,",
            "        \"formatters\": {",
            "            \"normal\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)s :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "            \"verbose\": {",
            "                \"format\": \"%(asctime)s.%(msecs)03d %(levelname)-7s %(name)-20s %(filename)-15s %(funcName)30s() :\\n  %(message)s\",",
            "                \"datefmt\": \"%H:%M:%S\",",
            "            },",
            "        },",
            "        \"handlers\": {",
            "            \"normal_console\": {",
            "                \"level\": \"INFO\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"normal\",",
            "            },",
            "            \"verbose_console\": {",
            "                \"level\": \"DEBUG\",",
            "                \"class\": \"logging.StreamHandler\",",
            "                \"formatter\": \"verbose\",",
            "            },",
            "        },",
            "        \"loggers\": {",
            "            \"django\": {\"handlers\": [\"normal_console\"], \"level\": \"INFO\"},",
            "            \"nautobot\": {",
            "                \"handlers\": [\"verbose_console\" if DEBUG else \"normal_console\"],",
            "                \"level\": LOG_LEVEL,",
            "            },",
            "        },",
            "    }",
            "",
            "MEDIA_ROOT = os.path.join(NAUTOBOT_ROOT, \"media\").rstrip(\"/\")",
            "SESSION_EXPIRE_AT_BROWSER_CLOSE = is_truthy(os.getenv(\"NAUTOBOT_SESSION_EXPIRE_AT_BROWSER_CLOSE\", \"False\"))",
            "SESSION_COOKIE_AGE = int(os.getenv(\"NAUTOBOT_SESSION_COOKIE_AGE\", \"1209600\"))  # 2 weeks, in seconds",
            "SESSION_FILE_PATH = os.getenv(\"NAUTOBOT_SESSION_FILE_PATH\", None)",
            "SHORT_DATE_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATE_FORMAT\", \"Y-m-d\")",
            "SHORT_DATETIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_DATETIME_FORMAT\", \"Y-m-d H:i\")",
            "SHORT_TIME_FORMAT = os.getenv(\"NAUTOBOT_SHORT_TIME_FORMAT\", \"H:i:s\")",
            "TIME_FORMAT = os.getenv(\"NAUTOBOT_TIME_FORMAT\", \"g:i a\")",
            "TIME_ZONE = os.getenv(\"NAUTOBOT_TIME_ZONE\", \"UTC\")",
            "",
            "# Disable importing the WSGI module before starting the server application. This is required for",
            "# uWSGI postfork callbacks to execute as is currently required in `nautobot.core.wsgi`.",
            "WEBSERVER_WARMUP = False",
            "",
            "# Installed apps and Django plugins. Nautobot plugins will be appended here later.",
            "INSTALLED_APPS = [",
            "    \"django.contrib.auth\",",
            "    \"django.contrib.contenttypes\",",
            "    \"django.contrib.sessions\",",
            "    \"django.contrib.messages\",",
            "    \"django.contrib.staticfiles\",",
            "    \"django.contrib.humanize\",",
            "    \"corsheaders\",",
            "    \"django_filters\",",
            "    \"django_jinja\",",
            "    \"django_tables2\",",
            "    \"django_prometheus\",",
            "    \"social_django\",",
            "    \"taggit\",",
            "    \"timezone_field\",",
            "    \"nautobot.core.apps.NautobotConstanceConfig\",  # overridden form of \"constance\" AppConfig",
            "    \"nautobot.core\",",
            "    \"django.contrib.admin\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_beat\",  # Must be after `nautobot.core` for template overrides",
            "    \"django_celery_results\",",
            "    \"rest_framework\",  # Must be after `nautobot.core` for template overrides",
            "    \"db_file_storage\",",
            "    \"nautobot.circuits\",",
            "    \"nautobot.dcim\",",
            "    \"nautobot.ipam\",",
            "    \"nautobot.extras\",",
            "    \"nautobot.tenancy\",",
            "    \"nautobot.users\",",
            "    \"nautobot.virtualization\",",
            "    \"drf_spectacular\",",
            "    \"drf_spectacular_sidecar\",",
            "    \"graphene_django\",",
            "    \"health_check\",",
            "    \"health_check.storage\",",
            "    \"django_extensions\",",
            "    \"constance.backends.database\",",
            "    \"django_ajax_tables\",",
            "]",
            "",
            "# Middleware",
            "MIDDLEWARE = [",
            "    \"django_prometheus.middleware.PrometheusBeforeMiddleware\",",
            "    \"corsheaders.middleware.CorsMiddleware\",",
            "    \"django.contrib.sessions.middleware.SessionMiddleware\",",
            "    \"django.middleware.common.CommonMiddleware\",",
            "    \"django.middleware.csrf.CsrfViewMiddleware\",",
            "    \"django.contrib.auth.middleware.AuthenticationMiddleware\",",
            "    \"django.contrib.messages.middleware.MessageMiddleware\",",
            "    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",",
            "    \"django.middleware.security.SecurityMiddleware\",",
            "    \"nautobot.core.middleware.ExceptionHandlingMiddleware\",",
            "    \"nautobot.core.middleware.RemoteUserMiddleware\",",
            "    \"nautobot.core.middleware.ExternalAuthMiddleware\",",
            "    \"nautobot.core.middleware.ObjectChangeMiddleware\",",
            "    \"django_prometheus.middleware.PrometheusAfterMiddleware\",",
            "]",
            "",
            "ROOT_URLCONF = \"nautobot.core.urls\"",
            "",
            "TEMPLATES = [",
            "    {",
            "        \"NAME\": \"django\",",
            "        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": True,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "        },",
            "    },",
            "    {",
            "        \"NAME\": \"jinja\",",
            "        \"BACKEND\": \"django_jinja.backend.Jinja2\",",
            "        \"DIRS\": [],",
            "        \"APP_DIRS\": False,",
            "        \"OPTIONS\": {",
            "            \"context_processors\": [",
            "                \"django.template.context_processors.debug\",",
            "                \"django.template.context_processors.request\",",
            "                \"django.template.context_processors.media\",",
            "                \"django.contrib.auth.context_processors.auth\",",
            "                \"django.contrib.messages.context_processors.messages\",",
            "                \"social_django.context_processors.backends\",",
            "                \"social_django.context_processors.login_redirect\",",
            "                \"nautobot.core.context_processors.settings\",",
            "                \"nautobot.core.context_processors.sso_auth\",",
            "            ],",
            "            \"environment\": \"jinja2.sandbox.SandboxedEnvironment\",",
            "        },",
            "    },",
            "]",
            "",
            "# Set up authentication backends",
            "AUTHENTICATION_BACKENDS = [",
            "    # Always check object permissions",
            "    \"nautobot.core.authentication.ObjectPermissionBackend\",",
            "]",
            "",
            "# Internationalization",
            "LANGUAGE_CODE = \"en-us\"",
            "USE_I18N = True",
            "USE_TZ = True",
            "",
            "# WSGI",
            "WSGI_APPLICATION = \"nautobot.core.wsgi.application\"",
            "SECURE_PROXY_SSL_HEADER = (\"HTTP_X_FORWARDED_PROTO\", \"https\")",
            "USE_X_FORWARDED_HOST = True",
            "X_FRAME_OPTIONS = \"DENY\"",
            "",
            "# Static files (CSS, JavaScript, Images)",
            "STATIC_ROOT = os.path.join(NAUTOBOT_ROOT, \"static\")",
            "STATIC_URL = \"static/\"",
            "STATICFILES_DIRS = (",
            "    os.path.join(BASE_DIR, \"project-static\"),",
            "    os.path.join(NAUTOBOT_UI_DIR, \"build\", \"static\"),",
            ")",
            "",
            "# Media",
            "MEDIA_URL = \"media/\"",
            "",
            "# Disable default limit of 1000 fields per request. Needed for bulk deletion of objects. (Added in Django 1.10.)",
            "DATA_UPLOAD_MAX_NUMBER_FIELDS = None",
            "",
            "# Messages",
            "MESSAGE_TAGS = {",
            "    messages.ERROR: \"danger\",",
            "}",
            "",
            "# Authentication URLs",
            "# This is the URL route name for the login view.",
            "LOGIN_URL = \"login\"",
            "",
            "# This is the URL route name for the home page (index) view.",
            "LOGIN_REDIRECT_URL = \"home\"",
            "",
            "#",
            "# django-constance",
            "#",
            "",
            "CONSTANCE_BACKEND = \"constance.backends.database.DatabaseBackend\"",
            "CONSTANCE_DATABASE_PREFIX = \"constance:nautobot:\"",
            "CONSTANCE_DATABASE_CACHE_BACKEND = \"default\"",
            "CONSTANCE_IGNORE_ADMIN_VERSION_CHECK = True  # avoid potential errors in a multi-node deployment",
            "",
            "CONSTANCE_ADDITIONAL_FIELDS = {",
            "    \"per_page_defaults_field\": [",
            "        \"nautobot.core.forms.fields.JSONArrayFormField\",",
            "        {",
            "            \"widget\": \"django.forms.TextInput\",",
            "            \"base_field\": django.forms.IntegerField(min_value=1),",
            "        },",
            "    ],",
            "    \"release_check_timeout_field\": [",
            "        \"django.forms.IntegerField\",",
            "        {",
            "            \"min_value\": 3600,",
            "        },",
            "    ],",
            "    \"release_check_url_field\": [",
            "        \"django.forms.URLField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "    \"optional_json_field\": [",
            "        \"django.forms.fields.JSONField\",",
            "        {",
            "            \"required\": False,",
            "        },",
            "    ],",
            "}",
            "",
            "CONSTANCE_CONFIG = {",
            "    \"BANNER_BOTTOM\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the bottom of all pages.\",",
            "    ),",
            "    \"BANNER_LOGIN\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the top of the login page.\",",
            "    ),",
            "    \"BANNER_TOP\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Custom HTML to display in a banner at the top of all pages.\",",
            "    ),",
            "    \"CHANGELOG_RETENTION\": ConstanceConfigItem(",
            "        default=90,",
            "        help_text=\"Number of days to retain object changelog history.\\nSet this to 0 to retain changes indefinitely.\",",
            "        field_type=int,",
            "    ),",
            "    \"DEVICE_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Device names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the device name alone as the natural key for Device objects. \"",
            "        \"Set this to False to use the sequence (name, tenant, location) as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"DEPLOYMENT_ID\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Randomly generated UUID used to identify this installation.\\n\"",
            "        \"Used for sending anonymous installation metrics, when settings.INSTALLATION_METRICS_ENABLED is set to True.\",",
            "        field_type=str,",
            "    ),",
            "    \"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\": ConstanceConfigItem(",
            "        default=0,",
            "        help_text=\"Dynamic Group member cache timeout in seconds. This is the amount of time that a Dynamic Group's member list \"",
            "        \"will be cached in Django cache backend. Since retrieving the member list of a Dynamic Group can be a very \"",
            "        \"expensive operation, especially in reverse, this cache is used to speed up the process of retrieving the \"",
            "        \"member list. This cache is invalidated when a Dynamic Group is saved. Set to 0 to disable caching.\",",
            "        field_type=int,",
            "    ),",
            "    \"FEEDBACK_BUTTON_ENABLED\": ConstanceConfigItem(",
            "        default=True,",
            "        help_text=\"Whether to show the Feedback button in the new UI sidebar.\",",
            "        field_type=bool,",
            "    ),",
            "    \"HIDE_RESTRICTED_UI\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"If set to True, users with limited permissions will not be shown menu items and home-page elements that \"",
            "        \"they do not have permission to access.\",",
            "        field_type=bool,",
            "    ),",
            "    \"LOCATION_NAME_AS_NATURAL_KEY\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Location names are not guaranteed globally-unique by Nautobot but in practice they often are. \"",
            "        \"Set this to True to use the location name alone as the natural key for Location objects. \"",
            "        \"Set this to False to use the sequence (name, parent__name, parent__parent__name, ...) \"",
            "        \"as the natural key instead.\",",
            "        field_type=bool,",
            "    ),",
            "    \"MAX_PAGE_SIZE\": ConstanceConfigItem(",
            "        default=1000,",
            "        help_text=\"Maximum number of objects that a user can list in one UI page or one API call.\\n\"",
            "        \"If set to 0, a user can retrieve an unlimited number of objects.\",",
            "        field_type=int,",
            "    ),",
            "    \"PAGINATE_COUNT\": ConstanceConfigItem(",
            "        default=50,",
            "        help_text=\"Default number of objects to display per page when listing objects in the UI and/or REST API.\",",
            "        field_type=int,",
            "    ),",
            "    \"PER_PAGE_DEFAULTS\": ConstanceConfigItem(",
            "        default=[25, 50, 100, 250, 500, 1000],",
            "        help_text=\"Pagination options to present to the user to choose amongst.\\n\"",
            "        \"For proper user experience, this list should include the PAGINATE_COUNT and MAX_PAGE_SIZE values as options.\",",
            "        # Use custom field type defined above",
            "        field_type=\"per_page_defaults_field\",",
            "    ),",
            "    \"NETWORK_DRIVERS\": ConstanceConfigItem(",
            "        default={},",
            "        help_text=mark_safe(  # noqa: S308",
            "            \"Extend or override default Platform.network_driver translations provided by \"",
            "            '<a href=\"https://netutils.readthedocs.io/en/latest/user/lib_use_cases_lib_mapper/\">netutils</a>. '",
            "            \"Enter a dictionary in JSON format, for example:\\n\"",
            "            \"<pre>{\\n\"",
            "            '    \"netmiko\": {\"my_network_driver\": \"cisco_ios\"},\\n'",
            "            '    \"pyats\": {\"my_network_driver\": \"iosxe\"} \\n'",
            "            \"}</pre>\",",
            "        ),",
            "        # Use custom field type defined above",
            "        field_type=\"optional_json_field\",",
            "    ),",
            "    \"PREFER_IPV4\": ConstanceConfigItem(",
            "        default=False,",
            "        help_text=\"Whether to prefer IPv4 primary addresses over IPv6 primary addresses for devices.\",",
            "        field_type=bool,",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\": ConstanceConfigItem(",
            "        default=22, help_text=\"Default height (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\": ConstanceConfigItem(",
            "        default=230, help_text=\"Default width (in pixels) of a rack unit in a rack elevation diagram\", field_type=int",
            "    ),",
            "    \"RELEASE_CHECK_TIMEOUT\": ConstanceConfigItem(",
            "        default=24 * 3600,",
            "        help_text=\"Number of seconds (must be at least 3600, or one hour) to cache the result of a release check \"",
            "        \"before checking again for a new release.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_timeout_field\",",
            "    ),",
            "    \"RELEASE_CHECK_URL\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"URL of GitHub repository REST API endpoint to poll periodically for availability of new Nautobot releases.\\n\"",
            "        'This can be set to the official repository \"https://api.github.com/repos/nautobot/nautobot/releases\" or '",
            "        \"a custom fork.\\nSet this to an empty string to disable automatic update checks.\",",
            "        # Use custom field type defined above",
            "        field_type=\"release_check_url_field\",",
            "    ),",
            "    \"SUPPORT_MESSAGE\": ConstanceConfigItem(",
            "        default=\"\",",
            "        help_text=\"Help message to include on 4xx and 5xx error pages. Markdown is supported.\\n\"",
            "        \"If unspecified, instructions to join Network to Code's Slack community will be provided.\",",
            "    ),",
            "}",
            "",
            "CONSTANCE_CONFIG_FIELDSETS = {",
            "    \"Banners\": [\"BANNER_LOGIN\", \"BANNER_TOP\", \"BANNER_BOTTOM\"],",
            "    \"Change Logging\": [\"CHANGELOG_RETENTION\"],",
            "    \"Device Connectivity\": [\"NETWORK_DRIVERS\", \"PREFER_IPV4\"],",
            "    \"Installation Metrics\": [\"DEPLOYMENT_ID\"],",
            "    \"Natural Keys\": [\"DEVICE_NAME_AS_NATURAL_KEY\", \"LOCATION_NAME_AS_NATURAL_KEY\"],",
            "    \"Pagination\": [\"PAGINATE_COUNT\", \"MAX_PAGE_SIZE\", \"PER_PAGE_DEFAULTS\"],",
            "    \"Performance\": [\"DYNAMIC_GROUPS_MEMBER_CACHE_TIMEOUT\"],",
            "    \"Rack Elevation Rendering\": [\"RACK_ELEVATION_DEFAULT_UNIT_HEIGHT\", \"RACK_ELEVATION_DEFAULT_UNIT_WIDTH\"],",
            "    \"Release Checking\": [\"RELEASE_CHECK_URL\", \"RELEASE_CHECK_TIMEOUT\"],",
            "    \"User Interface\": [\"HIDE_RESTRICTED_UI\", \"FEEDBACK_BUTTON_ENABLED\", \"SUPPORT_MESSAGE\"],",
            "}",
            "",
            "#",
            "# From django-cors-headers",
            "#",
            "",
            "# If True, all origins will be allowed. Other settings restricting allowed origins will be ignored.",
            "# Defaults to False. Setting this to True can be dangerous, as it allows any website to make",
            "# cross-origin requests to yours. Generally you'll want to restrict the list of allowed origins with",
            "# CORS_ALLOWED_ORIGINS or CORS_ALLOWED_ORIGIN_REGEXES.",
            "CORS_ALLOW_ALL_ORIGINS = is_truthy(os.getenv(\"NAUTOBOT_CORS_ALLOW_ALL_ORIGINS\", \"False\"))",
            "",
            "# A list of strings representing regexes that match Origins that are authorized to make cross-site",
            "# HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGIN_REGEXES = []",
            "",
            "# A list of origins that are authorized to make cross-site HTTP requests. Defaults to [].",
            "CORS_ALLOWED_ORIGINS = []",
            "",
            "#",
            "# GraphQL",
            "#",
            "",
            "GRAPHENE = {",
            "    \"SCHEMA\": \"nautobot.core.graphql.schema_init.schema\",",
            "    \"DJANGO_CHOICE_FIELD_ENUM_V3_NAMING\": True,  # any field with a name of type will break in Graphene otherwise.",
            "}",
            "GRAPHQL_CUSTOM_FIELD_PREFIX = \"cf\"",
            "GRAPHQL_RELATIONSHIP_PREFIX = \"rel\"",
            "GRAPHQL_COMPUTED_FIELD_PREFIX = \"cpf\"",
            "",
            "",
            "#",
            "# Caching",
            "#",
            "",
            "# The django-redis cache is used to establish concurrent locks using Redis.",
            "CACHES = {",
            "    \"default\": {",
            "        \"BACKEND\": os.getenv(",
            "            \"NAUTOBOT_CACHES_BACKEND\",",
            "            \"django_prometheus.cache.backends.redis.RedisCache\" if METRICS_ENABLED else \"django_redis.cache.RedisCache\",",
            "        ),",
            "        \"LOCATION\": parse_redis_connection(redis_database=1),",
            "        \"TIMEOUT\": 300,",
            "        \"OPTIONS\": {",
            "            \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",",
            "            \"PASSWORD\": \"\",",
            "        },",
            "    }",
            "}",
            "",
            "# Number of seconds to cache ContentType lookups. Set to 0 to disable caching.",
            "CONTENT_TYPE_CACHE_TIMEOUT = int(os.getenv(\"NAUTOBOT_CONTENT_TYPE_CACHE_TIMEOUT\", \"0\"))",
            "",
            "#",
            "# Celery (used for background processing)",
            "#",
            "",
            "# Celery broker URL used to tell workers where queues are located",
            "CELERY_BROKER_URL = os.getenv(\"NAUTOBOT_CELERY_BROKER_URL\", parse_redis_connection(redis_database=0))",
            "",
            "# Celery results backend URL to tell workers where to publish task results",
            "CELERY_RESULT_BACKEND = \"nautobot.core.celery.backends.NautobotDatabaseBackend\"",
            "",
            "# Enables extended task result attributes (name, args, kwargs, worker, retries, queue, delivery_info) to be written to backend.",
            "CELERY_RESULT_EXTENDED = True",
            "",
            "# A value of None or 0 means results will never expire (depending on backend specifications).",
            "CELERY_RESULT_EXPIRES = None",
            "",
            "# Instruct celery to report the started status of a job, instead of just `pending`, `finished`, or `failed`",
            "CELERY_TASK_TRACK_STARTED = True",
            "",
            "# If enabled, a `task-sent` event will be sent for every task so tasks can be tracked before they\u2019re consumed by a worker.",
            "CELERY_TASK_SEND_SENT_EVENT = True",
            "",
            "# If enabled stdout and stderr of running jobs will be redirected to the task logger.",
            "CELERY_WORKER_REDIRECT_STDOUTS = is_truthy(os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS\", \"True\"))",
            "",
            "# The log level of log messages generated by redirected job stdout and stderr. Can be one of `DEBUG`, `INFO`, `WARNING`, `ERROR`, or `CRITICAL`.",
            "CELERY_WORKER_REDIRECT_STDOUTS_LEVEL = os.getenv(\"NAUTOBOT_CELERY_WORKER_REDIRECT_STDOUTS_LEVEL\", \"WARNING\")",
            "",
            "# Send task-related events so that tasks can be monitored using tools like flower. Sets the default value for the workers -E argument.",
            "CELERY_WORKER_SEND_TASK_EVENTS = True",
            "",
            "# Default celery queue name that will be used by workers and tasks if no queue is specified",
            "CELERY_TASK_DEFAULT_QUEUE = os.getenv(\"NAUTOBOT_CELERY_TASK_DEFAULT_QUEUE\", \"default\")",
            "",
            "# Global task time limits (seconds)",
            "# Exceeding the soft limit will result in a SoftTimeLimitExceeded exception,",
            "# while exceeding the hard limit will result in a SIGKILL.",
            "CELERY_TASK_SOFT_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_SOFT_TIME_LIMIT\", str(5 * 60)))",
            "CELERY_TASK_TIME_LIMIT = int(os.getenv(\"NAUTOBOT_CELERY_TASK_TIME_LIMIT\", str(10 * 60)))",
            "",
            "# Ports for prometheus metric HTTP server running on the celery worker.",
            "# Normally this should be set to a single port, unless you have multiple workers running on a single machine, i.e.",
            "# sharing the same available ports. In that case you need to specify a range of ports greater than or equal to the",
            "# highest amount of workers you are running on a single machine (comma-separated, like \"8080,8081,8082\"). You can then",
            "# use the `target_limit` parameter to the Prometheus `scrape_config` to ensure you are not getting duplicate metrics in",
            "# that case. Set this to an empty string to disable it.",
            "CELERY_WORKER_PROMETHEUS_PORTS = []",
            "if os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\"):",
            "    CELERY_WORKER_PROMETHEUS_PORTS = [",
            "        int(value) for value in os.getenv(\"NAUTOBOT_CELERY_WORKER_PROMETHEUS_PORTS\").split(\",\")",
            "    ]",
            "",
            "# These settings define the custom nautobot serialization encoding as an accepted data encoding format",
            "# and register that format for task input and result serialization",
            "CELERY_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_RESULT_ACCEPT_CONTENT = [\"nautobot_json\"]",
            "CELERY_TASK_SERIALIZER = \"nautobot_json\"",
            "CELERY_RESULT_SERIALIZER = \"nautobot_json\"",
            "",
            "CELERY_BEAT_SCHEDULER = \"nautobot.core.celery.schedulers:NautobotDatabaseScheduler\"",
            "",
            "# Sets an age out timer of redis lock. This is NOT implicitly applied to locks, must be added",
            "# to a lock creation as `timeout=settings.REDIS_LOCK_TIMEOUT`",
            "REDIS_LOCK_TIMEOUT = int(os.getenv(\"NAUTOBOT_REDIS_LOCK_TIMEOUT\", \"600\"))",
            "",
            "#",
            "# Custom branding (logo and title)",
            "#",
            "",
            "# Branding logo locations. The logo takes the place of the Nautobot logo in the top right of the nav bar.",
            "# The filepath should be relative to the `MEDIA_ROOT`.",
            "BRANDING_FILEPATHS = {",
            "    \"logo\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_LOGO\", None),  # Navbar logo",
            "    \"favicon\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_FAVICON\", None),  # Browser favicon",
            "    \"icon_16\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_16\", None),  # 16x16px icon",
            "    \"icon_32\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_32\", None),  # 32x32px icon",
            "    \"icon_180\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_180\", None",
            "    ),  # 180x180px icon - used for the apple-touch-icon header",
            "    \"icon_192\": os.getenv(\"NAUTOBOT_BRANDING_FILEPATHS_ICON_192\", None),  # 192x192px icon",
            "    \"icon_mask\": os.getenv(",
            "        \"NAUTOBOT_BRANDING_FILEPATHS_ICON_MASK\", None",
            "    ),  # mono-chrome icon used for the mask-icon header",
            "}",
            "",
            "# Title to use in place of \"Nautobot\"",
            "BRANDING_TITLE = os.getenv(\"NAUTOBOT_BRANDING_TITLE\", \"Nautobot\")",
            "",
            "# Prepended to CSV, YAML and export template filenames (i.e. `nautobot_device.yml`)",
            "BRANDING_PREPENDED_FILENAME = os.getenv(\"NAUTOBOT_BRANDING_PREPENDED_FILENAME\", \"nautobot_\")",
            "",
            "# Branding URLs (links in the bottom right of the footer)",
            "BRANDING_URLS = {",
            "    \"code\": os.getenv(\"NAUTOBOT_BRANDING_URLS_CODE\", \"https://github.com/nautobot/nautobot\"),",
            "    \"docs\": os.getenv(\"NAUTOBOT_BRANDING_URLS_DOCS\", None),",
            "    \"help\": os.getenv(\"NAUTOBOT_BRANDING_URLS_HELP\", \"https://github.com/nautobot/nautobot/wiki\"),",
            "}",
            "",
            "# Undocumented link in the bottom right of the footer which is meant to persist any custom branding changes.",
            "BRANDING_POWERED_BY_URL = \"https://docs.nautobot.com/\"",
            "",
            "#",
            "# Django extensions settings",
            "#",
            "",
            "# Dont load the 'taggit' app, since we have our own custom `Tag` and `TaggedItem` models",
            "SHELL_PLUS_DONT_LOAD = [\"taggit\"]",
            "",
            "#",
            "# UI settings",
            "#",
            "",
            "",
            "# UI_RACK_VIEW_TRUNCATE_FUNCTION",
            "def UI_RACK_VIEW_TRUNCATE_FUNCTION(device_display_name):",
            "    \"\"\"Given device display name, truncate to fit the rack elevation view.",
            "",
            "    :param device_display_name: Full display name of the device attempting to be rendered in the rack elevation.",
            "    :type device_display_name: str",
            "",
            "    :return: Truncated device name",
            "    :type: str",
            "    \"\"\"",
            "    return str(device_display_name).split(\".\")[0]",
            "",
            "",
            "# Custom JSON schema serializer field type mappingss. These will be added to",
            "# `NautobotProcessingMixin.TYPE_MAP`.",
            "# Format: `{serializer_field_class.__name__}` => `{json_schema_type}`",
            "# See: https://github.com/yoyowallet/drf-react-template-framework#settings",
            "DRF_REACT_TEMPLATE_TYPE_MAP = {",
            "    \"ContentTypeField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"CustomFieldsDataField\": {\"type\": \"object\", \"widget\": \"textarea\"},",
            "    \"DateTimeField\": {\"type\": \"string\", \"format\": \"date-time\", \"widget\": \"date-time\"},",
            "    \"ImageField\": {\"type\": \"string\", \"format\": \"data-url\"},",
            "    \"IPFieldSerializer\": {\"type\": \"string\"},",
            "    \"JSONField\": {\"type\": \"string\", \"widget\": \"textarea\"},",
            "    \"MultipleChoiceJSONField\": {\"type\": \"array\", \"required\": [], \"enum\": \"choices\"},",
            "    \"ManyRelatedField\": {\"type\": \"array\", \"required\": []},",
            "    #",
            "    # Foreign Key fields",
            "    #",
            "    # enum=choices is the one that works in the UI as a related field but it",
            "    # includes ALL related objects in the schema.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    # readOnly=True disables the fields in the UI; not what we want.",
            "    # \"NautobotHyperlinkedRelatedField\": {\"type\": \"string\", \"readOnly\": True},",
            "    # type=string results in a free text field; also not what we want. For now,",
            "    # however, this will keep things moving so the unit tests pass.",
            "    \"NautobotHyperlinkedRelatedField\": {\"type\": \"object\"},",
            "    \"PrimaryKeyRelatedField\": {\"type\": \"string\", \"enum\": \"choices\"},",
            "    \"RelationshipsDataField\": {\"type\": \"object\"},",
            "    \"SlugField\": {\"type\": \"string\"},",
            "    \"TimeZoneSerializerField\": {\"type\": \"string\"},",
            "    \"UUIDField\": {\"type\": \"string\", \"format\": \"uuid\"},",
            "}",
            "",
            "# Turn on or off new ui feature",
            "ENABLE_ALPHA_UI = is_truthy(os.getenv(\"NAUTOBOT_ENABLE_ALPHA_UI\", \"False\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "648": []
        },
        "addLocation": []
    },
    "nautobot/core/tables.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django.core.exceptions import FieldDoesNotExist"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from django.db.models.fields.related import RelatedField"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.urls import reverse"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape, format_html"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from django.utils.html import escape, format_html, format_html_join"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.utils.safestring import mark_safe"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from django.utils.text import Truncator"
            },
            "7": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import django_tables2"
            },
            "8": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     @property"
            },
            "10": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     def header(self):"
            },
            "11": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return mark_safe('<input type=\"checkbox\" class=\"toggle\" title=\"Toggle all\" />')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        return mark_safe('<input type=\"checkbox\" class=\"toggle\" title=\"Toggle all\" />')  # noqa: S308"
            },
            "13": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " class BooleanColumn(django_tables2.Column):"
            },
            "16": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "             name = bound_column.name"
            },
            "17": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "             css_class = getattr(record, f\"get_{name}_class\")()"
            },
            "18": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "             label = getattr(record, f\"get_{name}_display\")()"
            },
            "19": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return mark_safe(f'<span class=\"label label-{css_class}\">{label}</span>')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+            return format_html('<span class=\"label label-{}\">{}</span>', css_class, label)"
            },
            "21": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "         return self.default"
            },
            "22": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 264,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 265,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "     \"\"\""
            },
            "25": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 270,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "     def render(self, value):"
            },
            "27": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return mark_safe(f'<span class=\"label color-block\" style=\"background-color: #{value}\">&nbsp;</span>')"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+        return format_html('<span class=\"label color-block\" style=\"background-color: #{}\">&nbsp;</span>', value)"
            },
            "29": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 273,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 274,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 275,
                "PatchRowcode": " class ColoredLabelColumn(django_tables2.TemplateColumn):"
            },
            "32": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "             url = reverse(self.viewname, kwargs=self.view_kwargs)"
            },
            "33": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "             if self.url_params:"
            },
            "34": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "                 url += \"?\" + \"&\".join([f\"{k}={getattr(record, v)}\" for k, v in self.url_params.items()])"
            },
            "35": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return mark_safe(f'<a href=\"{url}\">{value}</a>')"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+            return format_html('<a href=\"{}\">{}</a>', url, value)"
            },
            "37": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "         return value"
            },
            "38": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 311,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "         super().__init__(*args, **kwargs)"
            },
            "41": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 394,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "     def render(self, record, bound_column, value):  # pylint: disable=arguments-differ"
            },
            "43": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        template = \"\""
            },
            "44": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         if self.customfield.type == choices.CustomFieldTypeChoices.TYPE_BOOLEAN:"
            },
            "45": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "             template = helpers.render_boolean(value)"
            },
            "46": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_MULTISELECT:"
            },
            "47": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for v in value:"
            },
            "48": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                template += format_html('<span class=\"label label-default\">{}</span> ', v)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+            template = format_html_join(\" \", '<span class=\"label label-default\">{}</span>', ((v,) for v in value))"
            },
            "50": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "         elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_SELECT:"
            },
            "51": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "             template = format_html('<span class=\"label label-default\">{}</span>', value)"
            },
            "52": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_URL:"
            },
            "53": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "             template = format_html('<a href=\"{}\">{}</a>', value, value)"
            },
            "54": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "         else:"
            },
            "55": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "             template = escape(value)"
            },
            "56": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 406,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return mark_safe(template)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+        return template"
            },
            "59": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 408,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 409,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 410,
                "PatchRowcode": " class RelationshipColumn(django_tables2.Column):"
            },
            "62": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 433,
                "PatchRowcode": "             else:"
            },
            "63": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "                 value = [v for v in value if v.destination_id == record.id]"
            },
            "64": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 435,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        template = \"\""
            },
            "66": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "         # Handle Symmetric Relationships"
            },
            "67": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 437,
                "PatchRowcode": "         # List `value` could be empty here [] after the filtering from above"
            },
            "68": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "         if len(value) < 1:"
            },
            "69": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "             return \"\u2014\""
            },
            "70": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "71": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Handle Relationships on the many side."
            },
            "72": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if self.relationship.has_many(self.peer_side):"
            },
            "73": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                v = value[0]"
            },
            "74": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                meta = type(v.get_peer(record))._meta"
            },
            "75": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                name = meta.verbose_name_plural if len(value) > 1 else meta.verbose_name"
            },
            "76": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                template += format_html("
            },
            "77": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    '<a href=\"{}?relationship={}&{}_id={}\">{} {}</a>',"
            },
            "78": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    reverse(\"extras:relationshipassociation_list\"),"
            },
            "79": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    self.relationship.key,"
            },
            "80": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    self.side,"
            },
            "81": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    record.id,"
            },
            "82": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    len(value),"
            },
            "83": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    name,"
            },
            "84": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "85": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Handle Relationships on the one side."
            },
            "86": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "87": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                v = value[0]"
            },
            "88": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                peer = v.get_peer(record)"
            },
            "89": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                template += format_html('<a href=\"{}\">{}</a>', peer.get_absolute_url(), peer)"
            },
            "90": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 440,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return mark_safe(template)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        # Handle Relationships on the many side."
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+        if self.relationship.has_many(self.peer_side):"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+            v = value[0]"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+            meta = type(v.get_peer(record))._meta"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+            name = meta.verbose_name_plural if len(value) > 1 else meta.verbose_name"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+            return format_html("
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 447,
                "PatchRowcode": "+                '<a href=\"{}?relationship={}&{}_id={}\">{} {}</a>',"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+                reverse(\"extras:relationshipassociation_list\"),"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+                self.relationship.key,"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+                self.side,"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+                record.id,"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+                len(value),"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+                name,"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+            )"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+        # Handle Relationships on the one side."
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+        else:"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+            v = value[0]"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+            peer = v.get_peer(record)"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+            return format_html('<a href=\"{}\">{}</a>', peer.get_absolute_url(), peer)"
            }
        },
        "frontPatchFile": [
            "from django.contrib.auth.models import AnonymousUser",
            "from django.contrib.contenttypes.fields import GenericForeignKey",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import FieldDoesNotExist",
            "from django.db.models.fields.related import RelatedField",
            "from django.urls import reverse",
            "from django.utils.html import escape, format_html",
            "from django.utils.safestring import mark_safe",
            "from django.utils.text import Truncator",
            "import django_tables2",
            "from django_tables2.data import TableQuerysetData",
            "from django_tables2.utils import Accessor",
            "from tree_queries.models import TreeNode",
            "",
            "from nautobot.core.templatetags import helpers",
            "from nautobot.core.utils import lookup",
            "from nautobot.extras import choices, models",
            "",
            "",
            "class BaseTable(django_tables2.Table):",
            "    \"\"\"",
            "    Default table for object lists",
            "",
            "    :param user: Personalize table display for the given user (optional). Has no effect if AnonymousUser is passed.",
            "    \"\"\"",
            "",
            "    class Meta:",
            "        attrs = {",
            "            \"class\": \"table table-hover table-headings\",",
            "        }",
            "",
            "    def __init__(self, *args, user=None, **kwargs):",
            "        # Add custom field columns",
            "        obj_type = ContentType.objects.get_for_model(self._meta.model)",
            "",
            "        for cf in models.CustomField.objects.filter(content_types=obj_type):",
            "            name = cf.add_prefix_to_cf_key()",
            "            self.base_columns[name] = CustomFieldColumn(cf)",
            "",
            "        for cpf in models.ComputedField.objects.filter(content_type=obj_type):",
            "            self.base_columns[f\"cpf_{cpf.key}\"] = ComputedFieldColumn(cpf)",
            "",
            "        for relationship in models.Relationship.objects.filter(source_type=obj_type):",
            "            if not relationship.symmetric:",
            "                self.base_columns[f\"cr_{relationship.key}_src\"] = RelationshipColumn(",
            "                    relationship, side=choices.RelationshipSideChoices.SIDE_SOURCE",
            "                )",
            "            else:",
            "                self.base_columns[f\"cr_{relationship.key}_peer\"] = RelationshipColumn(",
            "                    relationship, side=choices.RelationshipSideChoices.SIDE_PEER",
            "                )",
            "",
            "        for relationship in models.Relationship.objects.filter(destination_type=obj_type):",
            "            if not relationship.symmetric:",
            "                self.base_columns[f\"cr_{relationship.key}_dst\"] = RelationshipColumn(",
            "                    relationship, side=choices.RelationshipSideChoices.SIDE_DESTINATION",
            "                )",
            "            # symmetric relationships are already handled above in the source_type case",
            "",
            "        model = getattr(self.Meta, \"model\", None)",
            "        # Disable ordering on these TreeNode Models Table because TreeNode do not support sorting",
            "        if model and issubclass(model, TreeNode):",
            "            kwargs[\"orderable\"] = False",
            "",
            "        # Init table",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Set default empty_text if none was provided",
            "        if self.empty_text is None:",
            "            self.empty_text = f\"No {self._meta.model._meta.verbose_name_plural} found\"",
            "",
            "        # Hide non-default columns",
            "        default_columns = list(getattr(self.Meta, \"default_columns\", []))",
            "        extra_columns = [c[0] for c in kwargs.get(\"extra_columns\", [])]  # extra_columns is a list of tuples",
            "        if default_columns:",
            "            for column in self.columns:",
            "                if column.name not in default_columns and column.name not in extra_columns:",
            "                    # Hide the column if it is non-default *and* not manually specified as an extra column",
            "                    self.columns.hide(column.name)",
            "",
            "        # Apply custom column ordering for user",
            "        if user is not None and not isinstance(user, AnonymousUser):",
            "            columns = user.get_config(f\"tables.{self.__class__.__name__}.columns\")",
            "            if columns:",
            "                pk = self.base_columns.pop(\"pk\", None)",
            "                actions = self.base_columns.pop(\"actions\", None)",
            "",
            "                for name, column in self.base_columns.items():",
            "                    if name in columns:",
            "                        self.columns.show(name)",
            "                    else:",
            "                        self.columns.hide(name)",
            "                self.sequence = [c for c in columns if c in self.base_columns]",
            "",
            "                # Always include PK and actions column, if defined on the table",
            "                if pk:",
            "                    self.base_columns[\"pk\"] = pk",
            "                    self.sequence.insert(0, \"pk\")",
            "                if actions:",
            "                    self.base_columns[\"actions\"] = actions",
            "                    self.sequence.append(\"actions\")",
            "",
            "        # Dynamically update the table's QuerySet to ensure related fields are pre-fetched",
            "        if isinstance(self.data, TableQuerysetData):",
            "            # v2 TODO(jathan): Replace prefetch_related with select_related",
            "            prefetch_fields = []",
            "            for column in self.columns:",
            "                if column.visible:",
            "                    model = getattr(self.Meta, \"model\")",
            "                    accessor = column.accessor",
            "                    prefetch_path = []",
            "                    for field_name in accessor.split(accessor.SEPARATOR):",
            "                        try:",
            "                            field = model._meta.get_field(field_name)",
            "                        except FieldDoesNotExist:",
            "                            break",
            "                        if isinstance(field, RelatedField):",
            "                            # Follow ForeignKeys to the related model",
            "                            prefetch_path.append(field_name)",
            "                            model = field.remote_field.model",
            "                        elif isinstance(field, GenericForeignKey):",
            "                            # Can't prefetch beyond a GenericForeignKey",
            "                            prefetch_path.append(field_name)",
            "                            break",
            "                    if prefetch_path:",
            "                        prefetch_fields.append(\"__\".join(prefetch_path))",
            "            self.data.data = self.data.data.prefetch_related(None).prefetch_related(*prefetch_fields)",
            "",
            "    @property",
            "    def configurable_columns(self):",
            "        selected_columns = [",
            "            (name, self.columns[name].verbose_name) for name in self.sequence if name not in [\"pk\", \"actions\"]",
            "        ]",
            "        available_columns = [",
            "            (name, column.verbose_name)",
            "            for name, column in self.columns.items()",
            "            if name not in self.sequence and name not in [\"pk\", \"actions\"]",
            "        ]",
            "        return selected_columns + available_columns",
            "",
            "    @property",
            "    def visible_columns(self):",
            "        return [name for name in self.sequence if self.columns[name].visible]",
            "",
            "",
            "#",
            "# Table columns",
            "#",
            "",
            "",
            "class ToggleColumn(django_tables2.CheckBoxColumn):",
            "    \"\"\"",
            "    Extend CheckBoxColumn to add a \"toggle all\" checkbox in the column header.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        default = kwargs.pop(\"default\", \"\")",
            "        visible = kwargs.pop(\"visible\", False)",
            "        if \"attrs\" not in kwargs:",
            "            kwargs[\"attrs\"] = {\"td\": {\"class\": \"min-width\"}}",
            "        super().__init__(*args, default=default, visible=visible, **kwargs)",
            "",
            "    @property",
            "    def header(self):",
            "        return mark_safe('<input type=\"checkbox\" class=\"toggle\" title=\"Toggle all\" />')",
            "",
            "",
            "class BooleanColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Custom implementation of BooleanColumn to render a nicely-formatted checkmark or X icon instead of a Unicode",
            "    character.",
            "    \"\"\"",
            "",
            "    def render(self, value):",
            "        return helpers.render_boolean(value)",
            "",
            "",
            "class ButtonsColumn(django_tables2.TemplateColumn):",
            "    \"\"\"",
            "    Render edit, delete, and changelog buttons for an object.",
            "",
            "    :param model: Model class to use for calculating URL view names",
            "    :param prepend_template: Additional template content to render in the column (optional)",
            "    :param return_url_extra: String to append to the return URL (e.g. for specifying a tab) (optional)",
            "    \"\"\"",
            "",
            "    buttons = (\"changelog\", \"edit\", \"delete\")",
            "    attrs = {\"td\": {\"class\": \"text-right text-nowrap noprint\"}}",
            "    # Note that braces are escaped to allow for string formatting prior to template rendering",
            "    template_code = \"\"\"",
            "    {{% if \"changelog\" in buttons %}}",
            "        <a href=\"{{% url '{changelog_route}' {pk_field}=record.{pk_field} %}}\" class=\"btn btn-default btn-xs\" title=\"Change log\">",
            "            <i class=\"mdi mdi-history\"></i>",
            "        </a>",
            "    {{% endif %}}",
            "    {{% if \"edit\" in buttons and perms.{app_label}.change_{model_name} %}}",
            "        <a href=\"{{% url '{edit_route}' {pk_field}=record.{pk_field} %}}?return_url={{{{ request.path }}}}{{{{ return_url_extra }}}}\" class=\"btn btn-xs btn-warning\" title=\"Edit\">",
            "            <i class=\"mdi mdi-pencil\"></i>",
            "        </a>",
            "    {{% endif %}}",
            "    {{% if \"delete\" in buttons and perms.{app_label}.delete_{model_name} %}}",
            "        <a href=\"{{% url '{delete_route}' {pk_field}=record.{pk_field} %}}?return_url={{{{ request.path }}}}{{{{ return_url_extra }}}}\" class=\"btn btn-xs btn-danger\" title=\"Delete\">",
            "            <i class=\"mdi mdi-trash-can-outline\"></i>",
            "        </a>",
            "    {{% endif %}}",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        model,",
            "        *args,",
            "        pk_field=\"pk\",",
            "        buttons=None,",
            "        prepend_template=None,",
            "        return_url_extra=\"\",",
            "        **kwargs,",
            "    ):",
            "        if prepend_template:",
            "            prepend_template = prepend_template.replace(\"{\", \"{{\")",
            "            prepend_template = prepend_template.replace(\"}\", \"}}\")",
            "            self.template_code = prepend_template + self.template_code",
            "",
            "        app_label = model._meta.app_label",
            "        changelog_route = lookup.get_route_for_model(model, \"changelog\")",
            "        edit_route = lookup.get_route_for_model(model, \"edit\")",
            "        delete_route = lookup.get_route_for_model(model, \"delete\")",
            "",
            "        template_code = self.template_code.format(",
            "            app_label=app_label,",
            "            model_name=model._meta.model_name,",
            "            changelog_route=changelog_route,",
            "            edit_route=edit_route,",
            "            delete_route=delete_route,",
            "            pk_field=pk_field,",
            "            buttons=buttons,",
            "        )",
            "",
            "        super().__init__(template_code=template_code, *args, **kwargs)",
            "",
            "        self.extra_context.update(",
            "            {",
            "                \"buttons\": buttons or self.buttons,",
            "                \"return_url_extra\": return_url_extra,",
            "            }",
            "        )",
            "",
            "    def header(self):  # pylint: disable=invalid-overridden-method",
            "        return \"\"",
            "",
            "",
            "class ChoiceFieldColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Render a ChoiceField value inside a <span> indicating a particular CSS class. This is useful for displaying colored",
            "    choices. The CSS class is derived by calling .get_FOO_class() on the row record.",
            "    \"\"\"",
            "",
            "    def render(self, record, bound_column, value):  # pylint: disable=arguments-differ",
            "        if value:",
            "            name = bound_column.name",
            "            css_class = getattr(record, f\"get_{name}_class\")()",
            "            label = getattr(record, f\"get_{name}_display\")()",
            "            return mark_safe(f'<span class=\"label label-{css_class}\">{label}</span>')",
            "        return self.default",
            "",
            "",
            "class ColorColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display a color (#RRGGBB).",
            "    \"\"\"",
            "",
            "    def render(self, value):",
            "        return mark_safe(f'<span class=\"label color-block\" style=\"background-color: #{value}\">&nbsp;</span>')",
            "",
            "",
            "class ColoredLabelColumn(django_tables2.TemplateColumn):",
            "    \"\"\"",
            "    Render a colored label (e.g. for DeviceRoles).",
            "    \"\"\"",
            "",
            "    template_code = \"\"\"",
            "    {% load helpers %}",
            "    {% if value %}<label class=\"label\" style=\"color: {{ value.color|fgcolor }}; background-color: #{{ value.color }}\">{{ value }}</label>{% else %}&mdash;{% endif %}",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(template_code=self.template_code, *args, **kwargs)",
            "",
            "",
            "class LinkedCountColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Render a count of related objects linked to a filtered URL.",
            "",
            "    :param viewname: The view name to use for URL resolution",
            "    :param view_kwargs: Additional kwargs to pass for URL resolution (optional)",
            "    :param url_params: A dict of query parameters to append to the URL (e.g. ?foo=bar) (optional)",
            "    \"\"\"",
            "",
            "    def __init__(self, viewname, *args, view_kwargs=None, url_params=None, default=0, **kwargs):",
            "        self.viewname = viewname",
            "        self.view_kwargs = view_kwargs or {}",
            "        self.url_params = url_params",
            "        super().__init__(*args, default=default, **kwargs)",
            "",
            "    def render(self, record, value):  # pylint: disable=arguments-differ",
            "        if value:",
            "            url = reverse(self.viewname, kwargs=self.view_kwargs)",
            "            if self.url_params:",
            "                url += \"?\" + \"&\".join([f\"{k}={getattr(record, v)}\" for k, v in self.url_params.items()])",
            "            return mark_safe(f'<a href=\"{url}\">{value}</a>')",
            "        return value",
            "",
            "",
            "class TagColumn(django_tables2.TemplateColumn):",
            "    \"\"\"",
            "    Display a list of tags assigned to the object.",
            "    \"\"\"",
            "",
            "    template_code = \"\"\"",
            "    {% for tag in value.all %}",
            "        {% include 'utilities/templatetags/tag.html' %}",
            "    {% empty %}",
            "        <span class=\"text-muted\">&mdash;</span>",
            "    {% endfor %}",
            "    \"\"\"",
            "",
            "    def __init__(self, url_name=None):",
            "        super().__init__(template_code=self.template_code, extra_context={\"url_name\": url_name})",
            "",
            "",
            "class ContentTypesColumn(django_tables2.ManyToManyColumn):",
            "    \"\"\"",
            "    Display a list of `content_types` m2m assigned to an object.",
            "",
            "    Default sorting of content-types is by pk. This sorting comes at a per-row",
            "    performance hit to querysets for table views. If this becomes an issue,",
            "    set `sort_items=False`.",
            "",
            "    :param sort_items: Whether to sort by `(app_label, name)`. (default: True)",
            "    :param truncate_words:",
            "        Number of words at which to truncate, or `None` to disable. (default: None)",
            "    \"\"\"",
            "",
            "    def __init__(self, sort_items=True, truncate_words=None, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.sort_items = sort_items",
            "        self.truncate_words = truncate_words",
            "",
            "    def filter(self, qs):",
            "        \"\"\"Overload filter to optionally sort items.\"\"\"",
            "        if self.sort_items:",
            "            qs = qs.order_by(\"app_label\", \"model\")",
            "        return qs.all()",
            "",
            "    def render(self, value):",
            "        \"\"\"Overload render to optionally truncate words.\"\"\"",
            "        value = super().render(value)",
            "        if self.truncate_words is not None:",
            "            trunc = Truncator(value)",
            "            value = trunc.words(self.truncate_words)",
            "        return value",
            "",
            "",
            "class ComputedFieldColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display computed fields in the appropriate format.",
            "    \"\"\"",
            "",
            "    def __init__(self, computedfield, *args, **kwargs):",
            "        self.computedfield = computedfield",
            "        kwargs[\"verbose_name\"] = computedfield.label",
            "        kwargs[\"empty_values\"] = []",
            "        kwargs[\"orderable\"] = False",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def render(self, record):",
            "        return self.computedfield.render({\"obj\": record})",
            "",
            "",
            "class CustomFieldColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display custom fields in the appropriate format.",
            "    \"\"\"",
            "",
            "    # Add [] to empty_values so when there is no choice populated for multiselect_cf i.e. [], \"\u2014\" is returned automatically.",
            "    empty_values = (None, \"\", [])",
            "",
            "    def __init__(self, customfield, *args, **kwargs):",
            "        self.customfield = customfield",
            "        kwargs[\"accessor\"] = Accessor(f\"_custom_field_data__{customfield.key}\")",
            "        kwargs[\"verbose_name\"] = customfield.label",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def render(self, record, bound_column, value):  # pylint: disable=arguments-differ",
            "        template = \"\"",
            "        if self.customfield.type == choices.CustomFieldTypeChoices.TYPE_BOOLEAN:",
            "            template = helpers.render_boolean(value)",
            "        elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "            for v in value:",
            "                template += format_html('<span class=\"label label-default\">{}</span> ', v)",
            "        elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_SELECT:",
            "            template = format_html('<span class=\"label label-default\">{}</span>', value)",
            "        elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_URL:",
            "            template = format_html('<a href=\"{}\">{}</a>', value, value)",
            "        else:",
            "            template = escape(value)",
            "",
            "        return mark_safe(template)",
            "",
            "",
            "class RelationshipColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display relationship association instances in the appropriate format.",
            "    \"\"\"",
            "",
            "    # Add [] to empty_values so when there is no relationship associations i.e. [], \"\u2014\" is returned automatically.",
            "    empty_values = (None, \"\", [])",
            "",
            "    def __init__(self, relationship, side, *args, **kwargs):",
            "        self.relationship = relationship",
            "        self.side = side",
            "        self.peer_side = choices.RelationshipSideChoices.OPPOSITE[side]",
            "        kwargs.setdefault(\"verbose_name\", relationship.get_label(side))",
            "        kwargs.setdefault(\"accessor\", Accessor(\"associations\"))",
            "        super().__init__(orderable=False, *args, **kwargs)",
            "",
            "    def render(self, record, value):  # pylint: disable=arguments-differ",
            "        # Filter the relationship associations by the relationship instance.",
            "        # Since associations accessor returns all the relationship associations regardless of the relationship.",
            "        value = [v for v in value if v.relationship == self.relationship]",
            "        if not self.relationship.symmetric:",
            "            if self.side == choices.RelationshipSideChoices.SIDE_SOURCE:",
            "                value = [v for v in value if v.source_id == record.id]",
            "            else:",
            "                value = [v for v in value if v.destination_id == record.id]",
            "",
            "        template = \"\"",
            "        # Handle Symmetric Relationships",
            "        # List `value` could be empty here [] after the filtering from above",
            "        if len(value) < 1:",
            "            return \"\u2014\"",
            "        else:",
            "            # Handle Relationships on the many side.",
            "            if self.relationship.has_many(self.peer_side):",
            "                v = value[0]",
            "                meta = type(v.get_peer(record))._meta",
            "                name = meta.verbose_name_plural if len(value) > 1 else meta.verbose_name",
            "                template += format_html(",
            "                    '<a href=\"{}?relationship={}&{}_id={}\">{} {}</a>',",
            "                    reverse(\"extras:relationshipassociation_list\"),",
            "                    self.relationship.key,",
            "                    self.side,",
            "                    record.id,",
            "                    len(value),",
            "                    name,",
            "                )",
            "            # Handle Relationships on the one side.",
            "            else:",
            "                v = value[0]",
            "                peer = v.get_peer(record)",
            "                template += format_html('<a href=\"{}\">{}</a>', peer.get_absolute_url(), peer)",
            "",
            "        return mark_safe(template)"
        ],
        "afterPatchFile": [
            "from django.contrib.auth.models import AnonymousUser",
            "from django.contrib.contenttypes.fields import GenericForeignKey",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import FieldDoesNotExist",
            "from django.db.models.fields.related import RelatedField",
            "from django.urls import reverse",
            "from django.utils.html import escape, format_html, format_html_join",
            "from django.utils.safestring import mark_safe",
            "from django.utils.text import Truncator",
            "import django_tables2",
            "from django_tables2.data import TableQuerysetData",
            "from django_tables2.utils import Accessor",
            "from tree_queries.models import TreeNode",
            "",
            "from nautobot.core.templatetags import helpers",
            "from nautobot.core.utils import lookup",
            "from nautobot.extras import choices, models",
            "",
            "",
            "class BaseTable(django_tables2.Table):",
            "    \"\"\"",
            "    Default table for object lists",
            "",
            "    :param user: Personalize table display for the given user (optional). Has no effect if AnonymousUser is passed.",
            "    \"\"\"",
            "",
            "    class Meta:",
            "        attrs = {",
            "            \"class\": \"table table-hover table-headings\",",
            "        }",
            "",
            "    def __init__(self, *args, user=None, **kwargs):",
            "        # Add custom field columns",
            "        obj_type = ContentType.objects.get_for_model(self._meta.model)",
            "",
            "        for cf in models.CustomField.objects.filter(content_types=obj_type):",
            "            name = cf.add_prefix_to_cf_key()",
            "            self.base_columns[name] = CustomFieldColumn(cf)",
            "",
            "        for cpf in models.ComputedField.objects.filter(content_type=obj_type):",
            "            self.base_columns[f\"cpf_{cpf.key}\"] = ComputedFieldColumn(cpf)",
            "",
            "        for relationship in models.Relationship.objects.filter(source_type=obj_type):",
            "            if not relationship.symmetric:",
            "                self.base_columns[f\"cr_{relationship.key}_src\"] = RelationshipColumn(",
            "                    relationship, side=choices.RelationshipSideChoices.SIDE_SOURCE",
            "                )",
            "            else:",
            "                self.base_columns[f\"cr_{relationship.key}_peer\"] = RelationshipColumn(",
            "                    relationship, side=choices.RelationshipSideChoices.SIDE_PEER",
            "                )",
            "",
            "        for relationship in models.Relationship.objects.filter(destination_type=obj_type):",
            "            if not relationship.symmetric:",
            "                self.base_columns[f\"cr_{relationship.key}_dst\"] = RelationshipColumn(",
            "                    relationship, side=choices.RelationshipSideChoices.SIDE_DESTINATION",
            "                )",
            "            # symmetric relationships are already handled above in the source_type case",
            "",
            "        model = getattr(self.Meta, \"model\", None)",
            "        # Disable ordering on these TreeNode Models Table because TreeNode do not support sorting",
            "        if model and issubclass(model, TreeNode):",
            "            kwargs[\"orderable\"] = False",
            "",
            "        # Init table",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Set default empty_text if none was provided",
            "        if self.empty_text is None:",
            "            self.empty_text = f\"No {self._meta.model._meta.verbose_name_plural} found\"",
            "",
            "        # Hide non-default columns",
            "        default_columns = list(getattr(self.Meta, \"default_columns\", []))",
            "        extra_columns = [c[0] for c in kwargs.get(\"extra_columns\", [])]  # extra_columns is a list of tuples",
            "        if default_columns:",
            "            for column in self.columns:",
            "                if column.name not in default_columns and column.name not in extra_columns:",
            "                    # Hide the column if it is non-default *and* not manually specified as an extra column",
            "                    self.columns.hide(column.name)",
            "",
            "        # Apply custom column ordering for user",
            "        if user is not None and not isinstance(user, AnonymousUser):",
            "            columns = user.get_config(f\"tables.{self.__class__.__name__}.columns\")",
            "            if columns:",
            "                pk = self.base_columns.pop(\"pk\", None)",
            "                actions = self.base_columns.pop(\"actions\", None)",
            "",
            "                for name, column in self.base_columns.items():",
            "                    if name in columns:",
            "                        self.columns.show(name)",
            "                    else:",
            "                        self.columns.hide(name)",
            "                self.sequence = [c for c in columns if c in self.base_columns]",
            "",
            "                # Always include PK and actions column, if defined on the table",
            "                if pk:",
            "                    self.base_columns[\"pk\"] = pk",
            "                    self.sequence.insert(0, \"pk\")",
            "                if actions:",
            "                    self.base_columns[\"actions\"] = actions",
            "                    self.sequence.append(\"actions\")",
            "",
            "        # Dynamically update the table's QuerySet to ensure related fields are pre-fetched",
            "        if isinstance(self.data, TableQuerysetData):",
            "            # v2 TODO(jathan): Replace prefetch_related with select_related",
            "            prefetch_fields = []",
            "            for column in self.columns:",
            "                if column.visible:",
            "                    model = getattr(self.Meta, \"model\")",
            "                    accessor = column.accessor",
            "                    prefetch_path = []",
            "                    for field_name in accessor.split(accessor.SEPARATOR):",
            "                        try:",
            "                            field = model._meta.get_field(field_name)",
            "                        except FieldDoesNotExist:",
            "                            break",
            "                        if isinstance(field, RelatedField):",
            "                            # Follow ForeignKeys to the related model",
            "                            prefetch_path.append(field_name)",
            "                            model = field.remote_field.model",
            "                        elif isinstance(field, GenericForeignKey):",
            "                            # Can't prefetch beyond a GenericForeignKey",
            "                            prefetch_path.append(field_name)",
            "                            break",
            "                    if prefetch_path:",
            "                        prefetch_fields.append(\"__\".join(prefetch_path))",
            "            self.data.data = self.data.data.prefetch_related(None).prefetch_related(*prefetch_fields)",
            "",
            "    @property",
            "    def configurable_columns(self):",
            "        selected_columns = [",
            "            (name, self.columns[name].verbose_name) for name in self.sequence if name not in [\"pk\", \"actions\"]",
            "        ]",
            "        available_columns = [",
            "            (name, column.verbose_name)",
            "            for name, column in self.columns.items()",
            "            if name not in self.sequence and name not in [\"pk\", \"actions\"]",
            "        ]",
            "        return selected_columns + available_columns",
            "",
            "    @property",
            "    def visible_columns(self):",
            "        return [name for name in self.sequence if self.columns[name].visible]",
            "",
            "",
            "#",
            "# Table columns",
            "#",
            "",
            "",
            "class ToggleColumn(django_tables2.CheckBoxColumn):",
            "    \"\"\"",
            "    Extend CheckBoxColumn to add a \"toggle all\" checkbox in the column header.",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        default = kwargs.pop(\"default\", \"\")",
            "        visible = kwargs.pop(\"visible\", False)",
            "        if \"attrs\" not in kwargs:",
            "            kwargs[\"attrs\"] = {\"td\": {\"class\": \"min-width\"}}",
            "        super().__init__(*args, default=default, visible=visible, **kwargs)",
            "",
            "    @property",
            "    def header(self):",
            "        return mark_safe('<input type=\"checkbox\" class=\"toggle\" title=\"Toggle all\" />')  # noqa: S308",
            "",
            "",
            "class BooleanColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Custom implementation of BooleanColumn to render a nicely-formatted checkmark or X icon instead of a Unicode",
            "    character.",
            "    \"\"\"",
            "",
            "    def render(self, value):",
            "        return helpers.render_boolean(value)",
            "",
            "",
            "class ButtonsColumn(django_tables2.TemplateColumn):",
            "    \"\"\"",
            "    Render edit, delete, and changelog buttons for an object.",
            "",
            "    :param model: Model class to use for calculating URL view names",
            "    :param prepend_template: Additional template content to render in the column (optional)",
            "    :param return_url_extra: String to append to the return URL (e.g. for specifying a tab) (optional)",
            "    \"\"\"",
            "",
            "    buttons = (\"changelog\", \"edit\", \"delete\")",
            "    attrs = {\"td\": {\"class\": \"text-right text-nowrap noprint\"}}",
            "    # Note that braces are escaped to allow for string formatting prior to template rendering",
            "    template_code = \"\"\"",
            "    {{% if \"changelog\" in buttons %}}",
            "        <a href=\"{{% url '{changelog_route}' {pk_field}=record.{pk_field} %}}\" class=\"btn btn-default btn-xs\" title=\"Change log\">",
            "            <i class=\"mdi mdi-history\"></i>",
            "        </a>",
            "    {{% endif %}}",
            "    {{% if \"edit\" in buttons and perms.{app_label}.change_{model_name} %}}",
            "        <a href=\"{{% url '{edit_route}' {pk_field}=record.{pk_field} %}}?return_url={{{{ request.path }}}}{{{{ return_url_extra }}}}\" class=\"btn btn-xs btn-warning\" title=\"Edit\">",
            "            <i class=\"mdi mdi-pencil\"></i>",
            "        </a>",
            "    {{% endif %}}",
            "    {{% if \"delete\" in buttons and perms.{app_label}.delete_{model_name} %}}",
            "        <a href=\"{{% url '{delete_route}' {pk_field}=record.{pk_field} %}}?return_url={{{{ request.path }}}}{{{{ return_url_extra }}}}\" class=\"btn btn-xs btn-danger\" title=\"Delete\">",
            "            <i class=\"mdi mdi-trash-can-outline\"></i>",
            "        </a>",
            "    {{% endif %}}",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        model,",
            "        *args,",
            "        pk_field=\"pk\",",
            "        buttons=None,",
            "        prepend_template=None,",
            "        return_url_extra=\"\",",
            "        **kwargs,",
            "    ):",
            "        if prepend_template:",
            "            prepend_template = prepend_template.replace(\"{\", \"{{\")",
            "            prepend_template = prepend_template.replace(\"}\", \"}}\")",
            "            self.template_code = prepend_template + self.template_code",
            "",
            "        app_label = model._meta.app_label",
            "        changelog_route = lookup.get_route_for_model(model, \"changelog\")",
            "        edit_route = lookup.get_route_for_model(model, \"edit\")",
            "        delete_route = lookup.get_route_for_model(model, \"delete\")",
            "",
            "        template_code = self.template_code.format(",
            "            app_label=app_label,",
            "            model_name=model._meta.model_name,",
            "            changelog_route=changelog_route,",
            "            edit_route=edit_route,",
            "            delete_route=delete_route,",
            "            pk_field=pk_field,",
            "            buttons=buttons,",
            "        )",
            "",
            "        super().__init__(template_code=template_code, *args, **kwargs)",
            "",
            "        self.extra_context.update(",
            "            {",
            "                \"buttons\": buttons or self.buttons,",
            "                \"return_url_extra\": return_url_extra,",
            "            }",
            "        )",
            "",
            "    def header(self):  # pylint: disable=invalid-overridden-method",
            "        return \"\"",
            "",
            "",
            "class ChoiceFieldColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Render a ChoiceField value inside a <span> indicating a particular CSS class. This is useful for displaying colored",
            "    choices. The CSS class is derived by calling .get_FOO_class() on the row record.",
            "    \"\"\"",
            "",
            "    def render(self, record, bound_column, value):  # pylint: disable=arguments-differ",
            "        if value:",
            "            name = bound_column.name",
            "            css_class = getattr(record, f\"get_{name}_class\")()",
            "            label = getattr(record, f\"get_{name}_display\")()",
            "            return format_html('<span class=\"label label-{}\">{}</span>', css_class, label)",
            "        return self.default",
            "",
            "",
            "class ColorColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display a color (#RRGGBB).",
            "    \"\"\"",
            "",
            "    def render(self, value):",
            "        return format_html('<span class=\"label color-block\" style=\"background-color: #{}\">&nbsp;</span>', value)",
            "",
            "",
            "class ColoredLabelColumn(django_tables2.TemplateColumn):",
            "    \"\"\"",
            "    Render a colored label (e.g. for DeviceRoles).",
            "    \"\"\"",
            "",
            "    template_code = \"\"\"",
            "    {% load helpers %}",
            "    {% if value %}<label class=\"label\" style=\"color: {{ value.color|fgcolor }}; background-color: #{{ value.color }}\">{{ value }}</label>{% else %}&mdash;{% endif %}",
            "    \"\"\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(template_code=self.template_code, *args, **kwargs)",
            "",
            "",
            "class LinkedCountColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Render a count of related objects linked to a filtered URL.",
            "",
            "    :param viewname: The view name to use for URL resolution",
            "    :param view_kwargs: Additional kwargs to pass for URL resolution (optional)",
            "    :param url_params: A dict of query parameters to append to the URL (e.g. ?foo=bar) (optional)",
            "    \"\"\"",
            "",
            "    def __init__(self, viewname, *args, view_kwargs=None, url_params=None, default=0, **kwargs):",
            "        self.viewname = viewname",
            "        self.view_kwargs = view_kwargs or {}",
            "        self.url_params = url_params",
            "        super().__init__(*args, default=default, **kwargs)",
            "",
            "    def render(self, record, value):  # pylint: disable=arguments-differ",
            "        if value:",
            "            url = reverse(self.viewname, kwargs=self.view_kwargs)",
            "            if self.url_params:",
            "                url += \"?\" + \"&\".join([f\"{k}={getattr(record, v)}\" for k, v in self.url_params.items()])",
            "            return format_html('<a href=\"{}\">{}</a>', url, value)",
            "        return value",
            "",
            "",
            "class TagColumn(django_tables2.TemplateColumn):",
            "    \"\"\"",
            "    Display a list of tags assigned to the object.",
            "    \"\"\"",
            "",
            "    template_code = \"\"\"",
            "    {% for tag in value.all %}",
            "        {% include 'utilities/templatetags/tag.html' %}",
            "    {% empty %}",
            "        <span class=\"text-muted\">&mdash;</span>",
            "    {% endfor %}",
            "    \"\"\"",
            "",
            "    def __init__(self, url_name=None):",
            "        super().__init__(template_code=self.template_code, extra_context={\"url_name\": url_name})",
            "",
            "",
            "class ContentTypesColumn(django_tables2.ManyToManyColumn):",
            "    \"\"\"",
            "    Display a list of `content_types` m2m assigned to an object.",
            "",
            "    Default sorting of content-types is by pk. This sorting comes at a per-row",
            "    performance hit to querysets for table views. If this becomes an issue,",
            "    set `sort_items=False`.",
            "",
            "    :param sort_items: Whether to sort by `(app_label, name)`. (default: True)",
            "    :param truncate_words:",
            "        Number of words at which to truncate, or `None` to disable. (default: None)",
            "    \"\"\"",
            "",
            "    def __init__(self, sort_items=True, truncate_words=None, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.sort_items = sort_items",
            "        self.truncate_words = truncate_words",
            "",
            "    def filter(self, qs):",
            "        \"\"\"Overload filter to optionally sort items.\"\"\"",
            "        if self.sort_items:",
            "            qs = qs.order_by(\"app_label\", \"model\")",
            "        return qs.all()",
            "",
            "    def render(self, value):",
            "        \"\"\"Overload render to optionally truncate words.\"\"\"",
            "        value = super().render(value)",
            "        if self.truncate_words is not None:",
            "            trunc = Truncator(value)",
            "            value = trunc.words(self.truncate_words)",
            "        return value",
            "",
            "",
            "class ComputedFieldColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display computed fields in the appropriate format.",
            "    \"\"\"",
            "",
            "    def __init__(self, computedfield, *args, **kwargs):",
            "        self.computedfield = computedfield",
            "        kwargs[\"verbose_name\"] = computedfield.label",
            "        kwargs[\"empty_values\"] = []",
            "        kwargs[\"orderable\"] = False",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def render(self, record):",
            "        return self.computedfield.render({\"obj\": record})",
            "",
            "",
            "class CustomFieldColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display custom fields in the appropriate format.",
            "    \"\"\"",
            "",
            "    # Add [] to empty_values so when there is no choice populated for multiselect_cf i.e. [], \"\u2014\" is returned automatically.",
            "    empty_values = (None, \"\", [])",
            "",
            "    def __init__(self, customfield, *args, **kwargs):",
            "        self.customfield = customfield",
            "        kwargs[\"accessor\"] = Accessor(f\"_custom_field_data__{customfield.key}\")",
            "        kwargs[\"verbose_name\"] = customfield.label",
            "",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def render(self, record, bound_column, value):  # pylint: disable=arguments-differ",
            "        if self.customfield.type == choices.CustomFieldTypeChoices.TYPE_BOOLEAN:",
            "            template = helpers.render_boolean(value)",
            "        elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "            template = format_html_join(\" \", '<span class=\"label label-default\">{}</span>', ((v,) for v in value))",
            "        elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_SELECT:",
            "            template = format_html('<span class=\"label label-default\">{}</span>', value)",
            "        elif self.customfield.type == choices.CustomFieldTypeChoices.TYPE_URL:",
            "            template = format_html('<a href=\"{}\">{}</a>', value, value)",
            "        else:",
            "            template = escape(value)",
            "",
            "        return template",
            "",
            "",
            "class RelationshipColumn(django_tables2.Column):",
            "    \"\"\"",
            "    Display relationship association instances in the appropriate format.",
            "    \"\"\"",
            "",
            "    # Add [] to empty_values so when there is no relationship associations i.e. [], \"\u2014\" is returned automatically.",
            "    empty_values = (None, \"\", [])",
            "",
            "    def __init__(self, relationship, side, *args, **kwargs):",
            "        self.relationship = relationship",
            "        self.side = side",
            "        self.peer_side = choices.RelationshipSideChoices.OPPOSITE[side]",
            "        kwargs.setdefault(\"verbose_name\", relationship.get_label(side))",
            "        kwargs.setdefault(\"accessor\", Accessor(\"associations\"))",
            "        super().__init__(orderable=False, *args, **kwargs)",
            "",
            "    def render(self, record, value):  # pylint: disable=arguments-differ",
            "        # Filter the relationship associations by the relationship instance.",
            "        # Since associations accessor returns all the relationship associations regardless of the relationship.",
            "        value = [v for v in value if v.relationship == self.relationship]",
            "        if not self.relationship.symmetric:",
            "            if self.side == choices.RelationshipSideChoices.SIDE_SOURCE:",
            "                value = [v for v in value if v.source_id == record.id]",
            "            else:",
            "                value = [v for v in value if v.destination_id == record.id]",
            "",
            "        # Handle Symmetric Relationships",
            "        # List `value` could be empty here [] after the filtering from above",
            "        if len(value) < 1:",
            "            return \"\u2014\"",
            "",
            "        # Handle Relationships on the many side.",
            "        if self.relationship.has_many(self.peer_side):",
            "            v = value[0]",
            "            meta = type(v.get_peer(record))._meta",
            "            name = meta.verbose_name_plural if len(value) > 1 else meta.verbose_name",
            "            return format_html(",
            "                '<a href=\"{}?relationship={}&{}_id={}\">{} {}</a>',",
            "                reverse(\"extras:relationshipassociation_list\"),",
            "                self.relationship.key,",
            "                self.side,",
            "                record.id,",
            "                len(value),",
            "                name,",
            "            )",
            "        # Handle Relationships on the one side.",
            "        else:",
            "            v = value[0]",
            "            peer = v.get_peer(record)",
            "            return format_html('<a href=\"{}\">{}</a>', peer.get_absolute_url(), peer)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "7": [],
            "165": [
                "ToggleColumn",
                "header"
            ],
            "262": [
                "ChoiceFieldColumn",
                "render"
            ],
            "272": [
                "ColorColumn",
                "render"
            ],
            "309": [
                "LinkedCountColumn",
                "render"
            ],
            "396": [
                "CustomFieldColumn",
                "render"
            ],
            "400": [
                "CustomFieldColumn",
                "render"
            ],
            "401": [
                "CustomFieldColumn",
                "render"
            ],
            "409": [
                "CustomFieldColumn",
                "render"
            ],
            "438": [
                "RelationshipColumn",
                "render"
            ],
            "443": [
                "RelationshipColumn",
                "render"
            ],
            "444": [
                "RelationshipColumn",
                "render"
            ],
            "445": [
                "RelationshipColumn",
                "render"
            ],
            "446": [
                "RelationshipColumn",
                "render"
            ],
            "447": [
                "RelationshipColumn",
                "render"
            ],
            "448": [
                "RelationshipColumn",
                "render"
            ],
            "449": [
                "RelationshipColumn",
                "render"
            ],
            "450": [
                "RelationshipColumn",
                "render"
            ],
            "451": [
                "RelationshipColumn",
                "render"
            ],
            "452": [
                "RelationshipColumn",
                "render"
            ],
            "453": [
                "RelationshipColumn",
                "render"
            ],
            "454": [
                "RelationshipColumn",
                "render"
            ],
            "455": [
                "RelationshipColumn",
                "render"
            ],
            "456": [
                "RelationshipColumn",
                "render"
            ],
            "457": [
                "RelationshipColumn",
                "render"
            ],
            "458": [
                "RelationshipColumn",
                "render"
            ],
            "459": [
                "RelationshipColumn",
                "render"
            ],
            "460": [
                "RelationshipColumn",
                "render"
            ],
            "461": [
                "RelationshipColumn",
                "render"
            ],
            "462": [
                "RelationshipColumn",
                "render"
            ],
            "464": [
                "RelationshipColumn",
                "render"
            ]
        },
        "addLocation": []
    },
    "nautobot/core/templatetags/helpers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from nautobot.core.utils import color, config, data, lookup"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from nautobot.core.utils.navigation import is_route_new_ui_ready"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-HTML_TRUE = '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>'"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-HTML_FALSE = '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-HTML_NONE = '<span class=\"text-muted\">&mdash;</span>'"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+HTML_TRUE = mark_safe('<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>')  # noqa: S308"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+HTML_FALSE = mark_safe('<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>')  # noqa: S308"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+HTML_NONE = mark_safe('<span class=\"text-muted\">&mdash;</span>')  # noqa: S308"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " DEFAULT_SUPPORT_MESSAGE = ("
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     \"If further assistance is required, please join the `#nautobot` channel \""
            },
            "12": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     if value:"
            },
            "14": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         return value"
            },
            "15": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return mark_safe(HTML_NONE)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+    return HTML_NONE"
            },
            "17": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " @library.filter()"
            },
            "20": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "     match = re.match(r\"^(.*?<\\w+) ?(.*)$\", element_str, flags=re.DOTALL)"
            },
            "21": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     if not match:"
            },
            "22": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         return element_str"
            },
            "23": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return mark_safe(match.group(1) + format_html(' id=\"{}\" ', id_str) + match.group(2))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    return mark_safe(match.group(1) + format_html(' id=\"{}\" ', id_str) + match.group(2))  # noqa: S308"
            },
            "25": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " @library.filter()"
            },
            "28": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'"
            },
            "29": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     \"\"\""
            },
            "30": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     if value is None:"
            },
            "31": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return mark_safe(HTML_NONE)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        return HTML_NONE"
            },
            "33": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     if bool(value):"
            },
            "34": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return mark_safe(HTML_TRUE)"
            },
            "35": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return mark_safe(HTML_FALSE)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        return HTML_TRUE"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    return HTML_FALSE"
            },
            "38": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " @library.filter()"
            },
            "41": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "     # Render Markdown"
            },
            "42": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     html = markdown(value, extensions=[\"fenced_code\", \"tables\"])"
            },
            "43": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return mark_safe(html)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+    return mark_safe(html)  # noqa: S308"
            },
            "46": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " @library.filter()"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import json",
            "import logging",
            "import re",
            "",
            "from django import template",
            "from django.conf import settings",
            "from django.contrib.staticfiles.finders import find",
            "from django.templatetags.static import StaticNode, static",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import format_html, strip_tags",
            "from django.utils.text import slugify as django_slugify",
            "from django.utils.safestring import mark_safe",
            "from django_jinja import library",
            "from markdown import markdown",
            "import yaml",
            "",
            "from nautobot.apps.config import get_app_settings_or_config",
            "from nautobot.core import forms",
            "from nautobot.core.utils import color, config, data, lookup",
            "from nautobot.core.utils.navigation import is_route_new_ui_ready",
            "",
            "HTML_TRUE = '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>'",
            "HTML_FALSE = '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'",
            "HTML_NONE = '<span class=\"text-muted\">&mdash;</span>'",
            "",
            "DEFAULT_SUPPORT_MESSAGE = (",
            "    \"If further assistance is required, please join the `#nautobot` channel \"",
            "    \"on [Network to Code's Slack community](https://slack.networktocode.com/) and post your question.\"",
            ")",
            "",
            "register = template.Library()",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "#",
            "# Filters",
            "#",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def hyperlinked_object(value, field=\"display\"):",
            "    \"\"\"Render and link to a Django model instance, if any, or render a placeholder if not.",
            "",
            "    Uses the specified object field if available, otherwise uses the string representation of the object.",
            "    If the object defines `get_absolute_url()` this will be used to hyperlink the displayed object;",
            "    additionally if there is an `object.description` this will be used as the title of the hyperlink.",
            "",
            "    Args:",
            "        value (Union[django.db.models.Model, None]): Instance of a Django model or None.",
            "        field (Optional[str]): Name of the field to use for the display value. Defaults to \"display\".",
            "",
            "    Returns:",
            "        (str): String representation of the value (hyperlinked if it defines get_absolute_url()) or a placeholder.",
            "",
            "    Examples:",
            "        >>> hyperlinked_object(device)",
            "        '<a href=\"/dcim/devices/3faafe8c-bdd6-4317-88dc-f791e6988caa/\">Device 1</a>'",
            "        >>> hyperlinked_object(device_role)",
            "        '<a href=\"/dcim/device-roles/router/\" title=\"Devices that are routers, not switches\">Router</a>'",
            "        >>> hyperlinked_object(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> hyperlinked_object(\"Hello\")",
            "        'Hello'",
            "        >>> hyperlinked_object(location)",
            "        '<a href=\"/dcim/locations/leaf/\">Root \u2192 Intermediate \u2192 Leaf</a>'",
            "        >>> hyperlinked_object(location, \"name\")",
            "        '<a href=\"/dcim/locations/leaf/\">Leaf</a>'",
            "    \"\"\"",
            "    if value is None:",
            "        return placeholder(value)",
            "    display = getattr(value, field) if hasattr(value, field) else str(value)",
            "    if hasattr(value, \"get_absolute_url\"):",
            "        if hasattr(value, \"description\") and value.description:",
            "            return format_html('<a href=\"{}\" title=\"{}\">{}</a>', value.get_absolute_url(), value.description, display)",
            "        return format_html('<a href=\"{}\">{}</a>', value.get_absolute_url(), display)",
            "    return format_html(\"{}\", display)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def placeholder(value):",
            "    \"\"\"Render a muted placeholder if value is falsey, else render the value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "",
            "    Returns:",
            "        (str): Placeholder in HTML, or the string representation of the value.",
            "",
            "    Example:",
            "        >>> placeholder(\"\")",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> placeholder(\"hello\")",
            "        \"hello\"",
            "    \"\"\"",
            "    if value:",
            "        return value",
            "    return mark_safe(HTML_NONE)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def add_html_id(element_str, id_str):",
            "    \"\"\"Add an HTML `id=\"...\"` attribute to the given HTML element string.",
            "",
            "    Args:",
            "        element_str (str): String describing an HTML element.",
            "        id_str (str): String to add as the `id` attribute of the element_str.",
            "",
            "    Returns:",
            "        (str): HTML string with added `id`.",
            "",
            "    Example:",
            "        >>> add_html_id(\"<div></div>\", \"my-div\")",
            "        '<div id=\"my-div\"></div>'",
            "        >>> add_html_id('<a href=\"...\" title=\"...\">Hello!</a>', \"my-a\")",
            "        '<a id=\"my-a\" href=\"...\" title=\"...\">Hello!</a>'",
            "    \"\"\"",
            "    match = re.match(r\"^(.*?<\\w+) ?(.*)$\", element_str, flags=re.DOTALL)",
            "    if not match:",
            "        return element_str",
            "    return mark_safe(match.group(1) + format_html(' id=\"{}\" ', id_str) + match.group(2))",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_boolean(value):",
            "    \"\"\"Render HTML from a computed boolean value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "            A truthy value (for example non-empty string / True / non-zero number) is considered True.",
            "            A falsey value other than None (for example \"\" or 0 or False) is considered False.",
            "            A value of None is considered neither True nor False.",
            "",
            "    Returns:",
            "        (str): HTML",
            "            '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>' if True value",
            "            - or -",
            "            '<span class=\"text-muted\">&mdash;</span>' if None value",
            "            - or -",
            "            '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>' if False value",
            "",
            "    Examples:",
            "        >>> render_boolean(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> render_boolean(True or \"arbitrary string\" or 1)",
            "        '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>'",
            "        >>> render_boolean(False or \"\" or 0)",
            "        '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'",
            "    \"\"\"",
            "    if value is None:",
            "        return mark_safe(HTML_NONE)",
            "    if bool(value):",
            "        return mark_safe(HTML_TRUE)",
            "    return mark_safe(HTML_FALSE)",
            "",
            "",
            "@library.filter()",
            "@register.filter(is_safe=True)",
            "def render_markdown(value):",
            "    \"\"\"",
            "    Render text as Markdown",
            "",
            "    Example:",
            "        {{ text | render_markdown }}",
            "    \"\"\"",
            "    # Strip HTML tags",
            "    value = strip_tags(value)",
            "",
            "    # Sanitize Markdown links",
            "    schemes = \"|\".join(settings.ALLOWED_URL_SCHEMES)",
            "    pattern = rf\"\\[(.+)\\]\\((?!({schemes})).*:(.+)\\)\"",
            "    value = re.sub(pattern, \"[\\\\1](\\\\3)\", value, flags=re.IGNORECASE)",
            "",
            "    # Render Markdown",
            "    html = markdown(value, extensions=[\"fenced_code\", \"tables\"])",
            "",
            "    return mark_safe(html)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_json(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted JSON.",
            "    \"\"\"",
            "    return json.dumps(value, indent=4, sort_keys=True, ensure_ascii=False)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_yaml(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted YAML.",
            "    \"\"\"",
            "    return yaml.dump(json.loads(json.dumps(value, ensure_ascii=False)), allow_unicode=True)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meta(obj, attr):",
            "    \"\"\"",
            "    Return the specified Meta attribute of a model. This is needed because Django does not permit templates",
            "    to access attributes which begin with an underscore (e.g. _meta).",
            "",
            "    Args:",
            "        obj (models.Model): Class or Instance of a Django Model",
            "        attr (str): name of the attribute to access",
            "",
            "    Returns:",
            "        (any): return the value of the attribute",
            "    \"\"\"",
            "    return getattr(obj._meta, attr, \"\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action. Does not perform any validation.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        (str): return the name of the view for the model/action provided.",
            "    Examples:",
            "        >>> viewname(Device, \"list\")",
            "        \"dcim:device_list\"",
            "    \"\"\"",
            "    return lookup.get_route_for_model(model, action)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def validated_viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action if valid, or None if invalid.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        (Union[str, None]): return the name of the view for the model/action provided if valid, or None if invalid.",
            "    \"\"\"",
            "    viewname_str = lookup.get_route_for_model(model, action)",
            "",
            "    try:",
            "        # Validate and return the view name. We don't return the actual URL yet because many of the templates",
            "        # are written to pass a name to {% url %}.",
            "        reverse(viewname_str)",
            "        return viewname_str",
            "    except NoReverseMatch:",
            "        return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def bettertitle(value):",
            "    \"\"\"",
            "    Alternative to the builtin title(); capitalizes words without replacing letters that are already uppercase.",
            "",
            "    Args:",
            "        value (str): string to convert to Title Case",
            "",
            "    Returns:",
            "        (str): string in Title format",
            "",
            "    Example:",
            "        >>> bettertitle(\"IP address\")",
            "        \"IP Address\"",
            "    \"\"\"",
            "    return \" \".join([w[0].upper() + w[1:] for w in value.split()])",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def humanize_speed(speed):",
            "    \"\"\"",
            "    Humanize speeds given in Kbps. Examples:",
            "",
            "        1544 => \"1.544 Mbps\"",
            "        100000 => \"100 Mbps\"",
            "        10000000 => \"10 Gbps\"",
            "    \"\"\"",
            "    if not speed:",
            "        return \"\"",
            "    if speed >= 1000000000 and speed % 1000000000 == 0:",
            "        return f\"{int(speed / 1000000000)} Tbps\"",
            "    elif speed >= 1000000 and speed % 1000000 == 0:",
            "        return f\"{int(speed / 1000000)} Gbps\"",
            "    elif speed >= 1000 and speed % 1000 == 0:",
            "        return f\"{int(speed / 1000)} Mbps\"",
            "    elif speed >= 1000:",
            "        return f\"{float(speed) / 1000} Mbps\"",
            "    else:",
            "        return f\"{speed} Kbps\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def tzoffset(value):",
            "    \"\"\"",
            "    Returns the hour offset of a given time zone using the current time.",
            "    \"\"\"",
            "    return datetime.datetime.now(value).strftime(\"%z\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def fgcolor(value):",
            "    \"\"\"",
            "    Return the ideal foreground color (block or white) given an arbitrary background color in RRGGBB format.",
            "",
            "    Args:",
            "        value (str): Color in RRGGBB format, with or without #",
            "",
            "    Returns:",
            "        (str): ideal foreground color, either black (#000000) or white (#ffffff)",
            "",
            "    Example:",
            "        >>> fgcolor(\"#999999\")",
            "        \"#ffffff\"",
            "    \"\"\"",
            "    value = value.lower().strip(\"#\")",
            "    if not re.match(\"^[0-9a-f]{6}$\", value):",
            "        return \"\"",
            "    return f\"#{color.foreground_color(value)}\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def divide(x, y):",
            "    \"\"\"Return x/y (rounded).",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        (int): x/y (rounded)",
            "",
            "    Examples:",
            "        >>> divide(10, 3)",
            "        3",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def percentage(x, y):",
            "    \"\"\"Return x/y as a percentage.",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        (int): x/y as a percentage",
            "",
            "    Examples:",
            "        >>> percentage(2, 10)",
            "        20",
            "",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y * 100)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_docs_url(model):",
            "    \"\"\"Return the likely static documentation path for the specified model, if it can be found/predicted.",
            "",
            "    - Core models, as of 2.0, are usually at `docs/user-guide/core-data-model/{app_label}/{model_name}.html`.",
            "        - Models in the `extras` app are usually at `docs/user-guide/platform-functionality/{model_name}.html`.",
            "    - Apps (plugins) are generally expected to be documented at `{app_label}/docs/models/{model_name}.html`.",
            "",
            "    Any model can define a `documentation_static_path` class attribute if it needs to override the above expectations.",
            "",
            "    If a file doesn't exist at the expected static path, this will return None.",
            "",
            "    Args:",
            "        model (models.Model): Instance of a Django model",
            "",
            "    Returns:",
            "        (Union[str, None]): static URL for the documentation of the object or None if not found.",
            "",
            "    Example:",
            "        >>> get_docs_url(location_instance)",
            "        \"static/docs/models/dcim/location.html\"",
            "    \"\"\"",
            "    if hasattr(model, \"documentation_static_path\"):",
            "        path = model.documentation_static_path",
            "    elif model._meta.app_label in settings.PLUGINS:",
            "        path = f\"{model._meta.app_label}/docs/models/{model._meta.model_name}.html\"",
            "    elif model._meta.app_label == \"extras\":",
            "        path = f\"docs/user-guide/platform-functionality/{model._meta.model_name}.html\"",
            "    else:",
            "        path = f\"docs/user-guide/core-data-model/{model._meta.app_label}/{model._meta.model_name}.html\"",
            "",
            "    # Check to see if documentation exists in any of the static paths.",
            "    if find(path):",
            "        return static(path)",
            "    logger.debug(\"No documentation found for %s (expected to find it at %s)\", type(model), path)",
            "    return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *all* permissions in the list.",
            "    \"\"\"",
            "    return user.has_perms(permissions_list)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_one_or_more_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *at least one* permissions in the list.",
            "    \"\"\"",
            "",
            "    for permission in permissions_list:",
            "        if user.has_perm(permission):",
            "            return True",
            "    return False",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def split(string, sep=\",\"):",
            "    \"\"\"Split a string by the given value (default: comma)",
            "",
            "    Args:",
            "        string (str): string to split into a list",
            "        sep (str default=,): separator to look for in the string",
            "",
            "    Returns:",
            "        (list[str]): List of string, if the separator wasn't found, list of 1",
            "    \"\"\"",
            "    return string.split(sep)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def as_range(n):",
            "    \"\"\"Return a range of n items.",
            "",
            "    Args:",
            "        n (int, str): Number of element in the range",
            "",
            "    Returns:",
            "        (Union[list, Range]): range function from o to the value provided. Returns an empty list if n is not valid.",
            "",
            "    Example:",
            "        {% for i in record.ancestors.count|as_range %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "        {% endfor %}",
            "    \"\"\"",
            "    try:",
            "        int(n)",
            "    except (TypeError, ValueError):",
            "        return []",
            "    return range(int(n))",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meters_to_feet(n):",
            "    \"\"\"Convert a length from meters to feet.",
            "",
            "    Args:",
            "        n (int, float, str): Number of meters to convert",
            "",
            "    Returns:",
            "        (float): Value in feet",
            "    \"\"\"",
            "    return float(n) * 3.28084",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_item(d, key):",
            "    \"\"\"Access a specific item/key in a dictionary",
            "",
            "    Args:",
            "        d (dict): dictionary containing the data to access",
            "        key (str): name of the item/key to access",
            "",
            "    Returns:",
            "        (any): Value of the item in the dictionary provided",
            "",
            "    Example:",
            "        >>> get_item(data, key)",
            "        \"value\"",
            "    \"\"\"",
            "    return d.get(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def settings_or_config(key, app_name=None):",
            "    \"\"\"Get a value from Django settings (if specified there) or Constance configuration (otherwise).\"\"\"",
            "    if app_name:",
            "        return get_app_settings_or_config(app_name, key)",
            "    return config.get_settings_or_config(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def quote_string(value):",
            "    \"\"\"Add literal quote characters around the provided value if it's a string.\"\"\"",
            "    if isinstance(value, str):",
            "        return f'\"{value}\"'",
            "    return value",
            "",
            "",
            "@library.filter()",
            "def slugify(value):",
            "    \"\"\"Return a slugified version of the value.\"\"\"",
            "    return django_slugify(value)",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "@register.simple_tag()",
            "def get_attr(obj, attr, default=None):",
            "    return getattr(obj, attr, default)",
            "",
            "",
            "@register.simple_tag()",
            "def querystring(request, **kwargs):",
            "    \"\"\"",
            "    Append or update the page number in a querystring.",
            "    \"\"\"",
            "    querydict = request.GET.copy()",
            "    for k, v in kwargs.items():",
            "        if v is not None:",
            "            querydict[k] = str(v)",
            "        elif k in querydict:",
            "            querydict.pop(k)",
            "    query_string = querydict.urlencode(safe=\"/\")",
            "    if query_string:",
            "        return \"?\" + query_string",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph(utilization_data, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Wrapper for a horizontal bar graph indicating a percentage of utilization from a tuple of data.",
            "",
            "    Takes the utilization_data that is a namedtuple with numerator and denominator field names and passes them into",
            "    the utilization_graph_raw_data to handle the generation graph data.",
            "",
            "    Args:",
            "        utilization_data (UtilizationData): Namedtuple with numerator and denominator keys",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        (dict): Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # See https://github.com/nautobot/nautobot/issues/1169",
            "    # If `get_utilization()` threw an exception, utilization_data will be an empty string",
            "    # rather than a UtilizationData instance. Avoid a potentially confusing exception in that case.",
            "    if not isinstance(utilization_data, data.UtilizationData):",
            "        return {}",
            "    return utilization_graph_raw_data(",
            "        numerator=utilization_data.numerator,",
            "        denominator=utilization_data.denominator,",
            "        warning_threshold=warning_threshold,",
            "        danger_threshold=danger_threshold,",
            "    )",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph_raw_data(numerator, denominator, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Display a horizontal bar graph indicating a percentage of utilization.",
            "",
            "    Args:",
            "        numerator (int): Numerator for creating a percentage",
            "        denominator (int): Denominator for creating a percentage",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        (dict): Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # Check for possible division by zero error",
            "    if denominator == 0:",
            "        utilization = 0",
            "    else:",
            "        utilization = int(float(numerator) / denominator * 100)",
            "",
            "    return {",
            "        \"utilization\": utilization,",
            "        \"warning_threshold\": warning_threshold,",
            "        \"danger_threshold\": danger_threshold,",
            "        \"utilization_count\": numerator,",
            "        \"total_count\": denominator,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/tag.html\")",
            "def tag(tag, url_name=None):  # pylint: disable=redefined-outer-name",
            "    \"\"\"",
            "    Display a tag, optionally linked to a filtered list of objects.",
            "    \"\"\"",
            "    return {",
            "        \"tag\": tag,",
            "        \"url_name\": url_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/badge.html\")",
            "def badge(value, show_empty=False):",
            "    \"\"\"",
            "    Display the specified number as a badge.",
            "    \"\"\"",
            "    return {",
            "        \"value\": value,",
            "        \"show_empty\": show_empty,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/table_config_form.html\")",
            "def table_config_form(table, table_name=None):",
            "    return {",
            "        \"table_name\": table_name or table.__class__.__name__,",
            "        \"table_config_form\": forms.TableConfigForm(table=table),",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/filter_form_modal.html\")",
            "def filter_form_modal(",
            "    filter_form,",
            "    dynamic_filter_form,",
            "    model_plural_name,",
            "    filter_form_name=\"FilterForm\",",
            "    dynamic_filter_form_name=\"DynamicFilterForm\",",
            "):",
            "    return {",
            "        \"model_plural_name\": model_plural_name,",
            "        \"filter_form\": filter_form,",
            "        \"filter_form_name\": filter_form_name,",
            "        \"dynamic_filter_form\": dynamic_filter_form,",
            "        \"dynamic_filter_form_name\": dynamic_filter_form_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/modal_form_as_dialog.html\")",
            "def modal_form_as_dialog(form, editing=False, form_name=None, obj=None, obj_type=None):",
            "    \"\"\"Generate a form in a modal view.",
            "",
            "    Create an overlaying modal view which holds a Django form.",
            "",
            "    Inside of the template the template tag needs to be used with the correct inputs. A button will",
            "    also need to be create to open and close the modal. See below for an example:",
            "",
            "    ```",
            "    {% modal_form_as_dialog form editing=False form_name=\"CreateDevice\" obj=obj obj_type=\"Device\" %}",
            "    <a class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#CreateDevice_form\" title=\"Query Form\">Create Device</a>",
            "    ```",
            "    Args:",
            "        form (django.form.Forms): Django form object.",
            "        editing (bool, optional): Is the form creating or editing an object? Defaults to False for create.",
            "        form_name ([type], optional): Name of form. Defaults to None. If None get name from class name.",
            "        obj (django.model.Object, optional): If editing an existing model object, the object needs to be passed in. Defaults to None.",
            "        obj_type (string, optional): Used in title of form to display object type. Defaults to None.",
            "",
            "    Returns:",
            "        (dict): Passed in values used to render HTML.",
            "    \"\"\"",
            "    return {",
            "        \"editing\": editing,",
            "        \"form\": form,",
            "        \"form_action_url\": form.get_action_url(),",
            "        \"form_name\": form_name or form.__class__.__name__,",
            "        \"obj\": obj,",
            "        \"obj_type\": obj_type,",
            "    }",
            "",
            "",
            "@register.simple_tag",
            "def custom_branding_or_static(branding_asset, static_asset):",
            "    \"\"\"",
            "    This tag attempts to return custom branding assets relative to the MEDIA_ROOT and MEDIA_URL, if such",
            "    branding has been configured in settings, else it returns stock branding via static.",
            "    \"\"\"",
            "    if settings.BRANDING_FILEPATHS.get(branding_asset):",
            "        return f\"{ settings.MEDIA_URL }{ settings.BRANDING_FILEPATHS.get(branding_asset) }\"",
            "    return StaticNode.handle_simple(static_asset)",
            "",
            "",
            "@register.simple_tag",
            "def support_message():",
            "    \"\"\"",
            "    Return the configured support message (if any) or else the default.",
            "    \"\"\"",
            "    try:",
            "        message = config.get_settings_or_config(\"SUPPORT_MESSAGE\")",
            "    except AttributeError:",
            "        message = \"\"",
            "    if not message:",
            "        message = DEFAULT_SUPPORT_MESSAGE",
            "    return render_markdown(message)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def hyperlinked_object_with_color(obj):",
            "    \"\"\"Render the display view of an object.\"\"\"",
            "    if obj:",
            "        content = f'<span class=\"label\" style=\"color: {fgcolor(obj.color)}; background-color: #{obj.color}\">{hyperlinked_object(obj)}</span>'",
            "        return format_html(content)",
            "    return \"\u2014\"",
            "",
            "",
            "@register.filter()",
            "def queryset_to_pks(obj):",
            "    \"\"\"Return all object UUIDs as a string separated by `,`\"\"\"",
            "    result = list(obj.values_list(\"pk\", flat=True)) if obj else []",
            "    result = [str(entry) for entry in result]",
            "    return \",\".join(result)",
            "",
            "",
            "#",
            "# Navigation",
            "#",
            "",
            "",
            "@register.filter()",
            "def is_new_ui_ready(url_path):",
            "    \"\"\"Return True if url_path is NewUI Ready else False\"\"\"",
            "    return is_route_new_ui_ready(url_path)"
        ],
        "afterPatchFile": [
            "import datetime",
            "import json",
            "import logging",
            "import re",
            "",
            "from django import template",
            "from django.conf import settings",
            "from django.contrib.staticfiles.finders import find",
            "from django.templatetags.static import StaticNode, static",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import format_html, strip_tags",
            "from django.utils.text import slugify as django_slugify",
            "from django.utils.safestring import mark_safe",
            "from django_jinja import library",
            "from markdown import markdown",
            "import yaml",
            "",
            "from nautobot.apps.config import get_app_settings_or_config",
            "from nautobot.core import forms",
            "from nautobot.core.utils import color, config, data, lookup",
            "from nautobot.core.utils.navigation import is_route_new_ui_ready",
            "",
            "HTML_TRUE = mark_safe('<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>')  # noqa: S308",
            "HTML_FALSE = mark_safe('<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>')  # noqa: S308",
            "HTML_NONE = mark_safe('<span class=\"text-muted\">&mdash;</span>')  # noqa: S308",
            "",
            "DEFAULT_SUPPORT_MESSAGE = (",
            "    \"If further assistance is required, please join the `#nautobot` channel \"",
            "    \"on [Network to Code's Slack community](https://slack.networktocode.com/) and post your question.\"",
            ")",
            "",
            "register = template.Library()",
            "",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "#",
            "# Filters",
            "#",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def hyperlinked_object(value, field=\"display\"):",
            "    \"\"\"Render and link to a Django model instance, if any, or render a placeholder if not.",
            "",
            "    Uses the specified object field if available, otherwise uses the string representation of the object.",
            "    If the object defines `get_absolute_url()` this will be used to hyperlink the displayed object;",
            "    additionally if there is an `object.description` this will be used as the title of the hyperlink.",
            "",
            "    Args:",
            "        value (Union[django.db.models.Model, None]): Instance of a Django model or None.",
            "        field (Optional[str]): Name of the field to use for the display value. Defaults to \"display\".",
            "",
            "    Returns:",
            "        (str): String representation of the value (hyperlinked if it defines get_absolute_url()) or a placeholder.",
            "",
            "    Examples:",
            "        >>> hyperlinked_object(device)",
            "        '<a href=\"/dcim/devices/3faafe8c-bdd6-4317-88dc-f791e6988caa/\">Device 1</a>'",
            "        >>> hyperlinked_object(device_role)",
            "        '<a href=\"/dcim/device-roles/router/\" title=\"Devices that are routers, not switches\">Router</a>'",
            "        >>> hyperlinked_object(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> hyperlinked_object(\"Hello\")",
            "        'Hello'",
            "        >>> hyperlinked_object(location)",
            "        '<a href=\"/dcim/locations/leaf/\">Root \u2192 Intermediate \u2192 Leaf</a>'",
            "        >>> hyperlinked_object(location, \"name\")",
            "        '<a href=\"/dcim/locations/leaf/\">Leaf</a>'",
            "    \"\"\"",
            "    if value is None:",
            "        return placeholder(value)",
            "    display = getattr(value, field) if hasattr(value, field) else str(value)",
            "    if hasattr(value, \"get_absolute_url\"):",
            "        if hasattr(value, \"description\") and value.description:",
            "            return format_html('<a href=\"{}\" title=\"{}\">{}</a>', value.get_absolute_url(), value.description, display)",
            "        return format_html('<a href=\"{}\">{}</a>', value.get_absolute_url(), display)",
            "    return format_html(\"{}\", display)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def placeholder(value):",
            "    \"\"\"Render a muted placeholder if value is falsey, else render the value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "",
            "    Returns:",
            "        (str): Placeholder in HTML, or the string representation of the value.",
            "",
            "    Example:",
            "        >>> placeholder(\"\")",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> placeholder(\"hello\")",
            "        \"hello\"",
            "    \"\"\"",
            "    if value:",
            "        return value",
            "    return HTML_NONE",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def add_html_id(element_str, id_str):",
            "    \"\"\"Add an HTML `id=\"...\"` attribute to the given HTML element string.",
            "",
            "    Args:",
            "        element_str (str): String describing an HTML element.",
            "        id_str (str): String to add as the `id` attribute of the element_str.",
            "",
            "    Returns:",
            "        (str): HTML string with added `id`.",
            "",
            "    Example:",
            "        >>> add_html_id(\"<div></div>\", \"my-div\")",
            "        '<div id=\"my-div\"></div>'",
            "        >>> add_html_id('<a href=\"...\" title=\"...\">Hello!</a>', \"my-a\")",
            "        '<a id=\"my-a\" href=\"...\" title=\"...\">Hello!</a>'",
            "    \"\"\"",
            "    match = re.match(r\"^(.*?<\\w+) ?(.*)$\", element_str, flags=re.DOTALL)",
            "    if not match:",
            "        return element_str",
            "    return mark_safe(match.group(1) + format_html(' id=\"{}\" ', id_str) + match.group(2))  # noqa: S308",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_boolean(value):",
            "    \"\"\"Render HTML from a computed boolean value.",
            "",
            "    Args:",
            "        value (any): Input value, can be any variable.",
            "            A truthy value (for example non-empty string / True / non-zero number) is considered True.",
            "            A falsey value other than None (for example \"\" or 0 or False) is considered False.",
            "            A value of None is considered neither True nor False.",
            "",
            "    Returns:",
            "        (str): HTML",
            "            '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>' if True value",
            "            - or -",
            "            '<span class=\"text-muted\">&mdash;</span>' if None value",
            "            - or -",
            "            '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>' if False value",
            "",
            "    Examples:",
            "        >>> render_boolean(None)",
            "        '<span class=\"text-muted\">&mdash;</span>'",
            "        >>> render_boolean(True or \"arbitrary string\" or 1)",
            "        '<span class=\"text-success\"><i class=\"mdi mdi-check-bold\" title=\"Yes\"></i></span>'",
            "        >>> render_boolean(False or \"\" or 0)",
            "        '<span class=\"text-danger\"><i class=\"mdi mdi-close-thick\" title=\"No\"></i></span>'",
            "    \"\"\"",
            "    if value is None:",
            "        return HTML_NONE",
            "    if bool(value):",
            "        return HTML_TRUE",
            "    return HTML_FALSE",
            "",
            "",
            "@library.filter()",
            "@register.filter(is_safe=True)",
            "def render_markdown(value):",
            "    \"\"\"",
            "    Render text as Markdown",
            "",
            "    Example:",
            "        {{ text | render_markdown }}",
            "    \"\"\"",
            "    # Strip HTML tags",
            "    value = strip_tags(value)",
            "",
            "    # Sanitize Markdown links",
            "    schemes = \"|\".join(settings.ALLOWED_URL_SCHEMES)",
            "    pattern = rf\"\\[(.+)\\]\\((?!({schemes})).*:(.+)\\)\"",
            "    value = re.sub(pattern, \"[\\\\1](\\\\3)\", value, flags=re.IGNORECASE)",
            "",
            "    # Render Markdown",
            "    html = markdown(value, extensions=[\"fenced_code\", \"tables\"])",
            "",
            "    return mark_safe(html)  # noqa: S308",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_json(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted JSON.",
            "    \"\"\"",
            "    return json.dumps(value, indent=4, sort_keys=True, ensure_ascii=False)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def render_yaml(value):",
            "    \"\"\"",
            "    Render a dictionary as formatted YAML.",
            "    \"\"\"",
            "    return yaml.dump(json.loads(json.dumps(value, ensure_ascii=False)), allow_unicode=True)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meta(obj, attr):",
            "    \"\"\"",
            "    Return the specified Meta attribute of a model. This is needed because Django does not permit templates",
            "    to access attributes which begin with an underscore (e.g. _meta).",
            "",
            "    Args:",
            "        obj (models.Model): Class or Instance of a Django Model",
            "        attr (str): name of the attribute to access",
            "",
            "    Returns:",
            "        (any): return the value of the attribute",
            "    \"\"\"",
            "    return getattr(obj._meta, attr, \"\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action. Does not perform any validation.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        (str): return the name of the view for the model/action provided.",
            "    Examples:",
            "        >>> viewname(Device, \"list\")",
            "        \"dcim:device_list\"",
            "    \"\"\"",
            "    return lookup.get_route_for_model(model, action)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def validated_viewname(model, action):",
            "    \"\"\"",
            "    Return the view name for the given model and action if valid, or None if invalid.",
            "",
            "    Args:",
            "        model (models.Model): Class or Instance of a Django Model",
            "        action (str): name of the action in the viewname",
            "",
            "    Returns:",
            "        (Union[str, None]): return the name of the view for the model/action provided if valid, or None if invalid.",
            "    \"\"\"",
            "    viewname_str = lookup.get_route_for_model(model, action)",
            "",
            "    try:",
            "        # Validate and return the view name. We don't return the actual URL yet because many of the templates",
            "        # are written to pass a name to {% url %}.",
            "        reverse(viewname_str)",
            "        return viewname_str",
            "    except NoReverseMatch:",
            "        return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def bettertitle(value):",
            "    \"\"\"",
            "    Alternative to the builtin title(); capitalizes words without replacing letters that are already uppercase.",
            "",
            "    Args:",
            "        value (str): string to convert to Title Case",
            "",
            "    Returns:",
            "        (str): string in Title format",
            "",
            "    Example:",
            "        >>> bettertitle(\"IP address\")",
            "        \"IP Address\"",
            "    \"\"\"",
            "    return \" \".join([w[0].upper() + w[1:] for w in value.split()])",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def humanize_speed(speed):",
            "    \"\"\"",
            "    Humanize speeds given in Kbps. Examples:",
            "",
            "        1544 => \"1.544 Mbps\"",
            "        100000 => \"100 Mbps\"",
            "        10000000 => \"10 Gbps\"",
            "    \"\"\"",
            "    if not speed:",
            "        return \"\"",
            "    if speed >= 1000000000 and speed % 1000000000 == 0:",
            "        return f\"{int(speed / 1000000000)} Tbps\"",
            "    elif speed >= 1000000 and speed % 1000000 == 0:",
            "        return f\"{int(speed / 1000000)} Gbps\"",
            "    elif speed >= 1000 and speed % 1000 == 0:",
            "        return f\"{int(speed / 1000)} Mbps\"",
            "    elif speed >= 1000:",
            "        return f\"{float(speed) / 1000} Mbps\"",
            "    else:",
            "        return f\"{speed} Kbps\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def tzoffset(value):",
            "    \"\"\"",
            "    Returns the hour offset of a given time zone using the current time.",
            "    \"\"\"",
            "    return datetime.datetime.now(value).strftime(\"%z\")",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def fgcolor(value):",
            "    \"\"\"",
            "    Return the ideal foreground color (block or white) given an arbitrary background color in RRGGBB format.",
            "",
            "    Args:",
            "        value (str): Color in RRGGBB format, with or without #",
            "",
            "    Returns:",
            "        (str): ideal foreground color, either black (#000000) or white (#ffffff)",
            "",
            "    Example:",
            "        >>> fgcolor(\"#999999\")",
            "        \"#ffffff\"",
            "    \"\"\"",
            "    value = value.lower().strip(\"#\")",
            "    if not re.match(\"^[0-9a-f]{6}$\", value):",
            "        return \"\"",
            "    return f\"#{color.foreground_color(value)}\"",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def divide(x, y):",
            "    \"\"\"Return x/y (rounded).",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        (int): x/y (rounded)",
            "",
            "    Examples:",
            "        >>> divide(10, 3)",
            "        3",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def percentage(x, y):",
            "    \"\"\"Return x/y as a percentage.",
            "",
            "    Args:",
            "        x (int or float): dividend number",
            "        y (int or float): divisor number",
            "",
            "    Returns:",
            "        (int): x/y as a percentage",
            "",
            "    Examples:",
            "        >>> percentage(2, 10)",
            "        20",
            "",
            "    \"\"\"",
            "    if x is None or y is None:",
            "        return None",
            "    return round(x / y * 100)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_docs_url(model):",
            "    \"\"\"Return the likely static documentation path for the specified model, if it can be found/predicted.",
            "",
            "    - Core models, as of 2.0, are usually at `docs/user-guide/core-data-model/{app_label}/{model_name}.html`.",
            "        - Models in the `extras` app are usually at `docs/user-guide/platform-functionality/{model_name}.html`.",
            "    - Apps (plugins) are generally expected to be documented at `{app_label}/docs/models/{model_name}.html`.",
            "",
            "    Any model can define a `documentation_static_path` class attribute if it needs to override the above expectations.",
            "",
            "    If a file doesn't exist at the expected static path, this will return None.",
            "",
            "    Args:",
            "        model (models.Model): Instance of a Django model",
            "",
            "    Returns:",
            "        (Union[str, None]): static URL for the documentation of the object or None if not found.",
            "",
            "    Example:",
            "        >>> get_docs_url(location_instance)",
            "        \"static/docs/models/dcim/location.html\"",
            "    \"\"\"",
            "    if hasattr(model, \"documentation_static_path\"):",
            "        path = model.documentation_static_path",
            "    elif model._meta.app_label in settings.PLUGINS:",
            "        path = f\"{model._meta.app_label}/docs/models/{model._meta.model_name}.html\"",
            "    elif model._meta.app_label == \"extras\":",
            "        path = f\"docs/user-guide/platform-functionality/{model._meta.model_name}.html\"",
            "    else:",
            "        path = f\"docs/user-guide/core-data-model/{model._meta.app_label}/{model._meta.model_name}.html\"",
            "",
            "    # Check to see if documentation exists in any of the static paths.",
            "    if find(path):",
            "        return static(path)",
            "    logger.debug(\"No documentation found for %s (expected to find it at %s)\", type(model), path)",
            "    return None",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *all* permissions in the list.",
            "    \"\"\"",
            "    return user.has_perms(permissions_list)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def has_one_or_more_perms(user, permissions_list):",
            "    \"\"\"",
            "    Return True if the user has *at least one* permissions in the list.",
            "    \"\"\"",
            "",
            "    for permission in permissions_list:",
            "        if user.has_perm(permission):",
            "            return True",
            "    return False",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def split(string, sep=\",\"):",
            "    \"\"\"Split a string by the given value (default: comma)",
            "",
            "    Args:",
            "        string (str): string to split into a list",
            "        sep (str default=,): separator to look for in the string",
            "",
            "    Returns:",
            "        (list[str]): List of string, if the separator wasn't found, list of 1",
            "    \"\"\"",
            "    return string.split(sep)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def as_range(n):",
            "    \"\"\"Return a range of n items.",
            "",
            "    Args:",
            "        n (int, str): Number of element in the range",
            "",
            "    Returns:",
            "        (Union[list, Range]): range function from o to the value provided. Returns an empty list if n is not valid.",
            "",
            "    Example:",
            "        {% for i in record.ancestors.count|as_range %}",
            "            <i class=\"mdi mdi-circle-small\"></i>",
            "        {% endfor %}",
            "    \"\"\"",
            "    try:",
            "        int(n)",
            "    except (TypeError, ValueError):",
            "        return []",
            "    return range(int(n))",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def meters_to_feet(n):",
            "    \"\"\"Convert a length from meters to feet.",
            "",
            "    Args:",
            "        n (int, float, str): Number of meters to convert",
            "",
            "    Returns:",
            "        (float): Value in feet",
            "    \"\"\"",
            "    return float(n) * 3.28084",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def get_item(d, key):",
            "    \"\"\"Access a specific item/key in a dictionary",
            "",
            "    Args:",
            "        d (dict): dictionary containing the data to access",
            "        key (str): name of the item/key to access",
            "",
            "    Returns:",
            "        (any): Value of the item in the dictionary provided",
            "",
            "    Example:",
            "        >>> get_item(data, key)",
            "        \"value\"",
            "    \"\"\"",
            "    return d.get(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def settings_or_config(key, app_name=None):",
            "    \"\"\"Get a value from Django settings (if specified there) or Constance configuration (otherwise).\"\"\"",
            "    if app_name:",
            "        return get_app_settings_or_config(app_name, key)",
            "    return config.get_settings_or_config(key)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def quote_string(value):",
            "    \"\"\"Add literal quote characters around the provided value if it's a string.\"\"\"",
            "    if isinstance(value, str):",
            "        return f'\"{value}\"'",
            "    return value",
            "",
            "",
            "@library.filter()",
            "def slugify(value):",
            "    \"\"\"Return a slugified version of the value.\"\"\"",
            "    return django_slugify(value)",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "@register.simple_tag()",
            "def get_attr(obj, attr, default=None):",
            "    return getattr(obj, attr, default)",
            "",
            "",
            "@register.simple_tag()",
            "def querystring(request, **kwargs):",
            "    \"\"\"",
            "    Append or update the page number in a querystring.",
            "    \"\"\"",
            "    querydict = request.GET.copy()",
            "    for k, v in kwargs.items():",
            "        if v is not None:",
            "            querydict[k] = str(v)",
            "        elif k in querydict:",
            "            querydict.pop(k)",
            "    query_string = querydict.urlencode(safe=\"/\")",
            "    if query_string:",
            "        return \"?\" + query_string",
            "    else:",
            "        return \"\"",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph(utilization_data, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Wrapper for a horizontal bar graph indicating a percentage of utilization from a tuple of data.",
            "",
            "    Takes the utilization_data that is a namedtuple with numerator and denominator field names and passes them into",
            "    the utilization_graph_raw_data to handle the generation graph data.",
            "",
            "    Args:",
            "        utilization_data (UtilizationData): Namedtuple with numerator and denominator keys",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        (dict): Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # See https://github.com/nautobot/nautobot/issues/1169",
            "    # If `get_utilization()` threw an exception, utilization_data will be an empty string",
            "    # rather than a UtilizationData instance. Avoid a potentially confusing exception in that case.",
            "    if not isinstance(utilization_data, data.UtilizationData):",
            "        return {}",
            "    return utilization_graph_raw_data(",
            "        numerator=utilization_data.numerator,",
            "        denominator=utilization_data.denominator,",
            "        warning_threshold=warning_threshold,",
            "        danger_threshold=danger_threshold,",
            "    )",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/utilization_graph.html\")",
            "def utilization_graph_raw_data(numerator, denominator, warning_threshold=75, danger_threshold=90):",
            "    \"\"\"Display a horizontal bar graph indicating a percentage of utilization.",
            "",
            "    Args:",
            "        numerator (int): Numerator for creating a percentage",
            "        denominator (int): Denominator for creating a percentage",
            "        warning_threshold (int, optional): Warning Threshold Value. Defaults to 75.",
            "        danger_threshold (int, optional): Danger Threshold Value. Defaults to 90.",
            "",
            "    Returns:",
            "        (dict): Dictionary with utilization, warning threshold, danger threshold, utilization count, and total count for",
            "                display",
            "    \"\"\"",
            "    # Check for possible division by zero error",
            "    if denominator == 0:",
            "        utilization = 0",
            "    else:",
            "        utilization = int(float(numerator) / denominator * 100)",
            "",
            "    return {",
            "        \"utilization\": utilization,",
            "        \"warning_threshold\": warning_threshold,",
            "        \"danger_threshold\": danger_threshold,",
            "        \"utilization_count\": numerator,",
            "        \"total_count\": denominator,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/tag.html\")",
            "def tag(tag, url_name=None):  # pylint: disable=redefined-outer-name",
            "    \"\"\"",
            "    Display a tag, optionally linked to a filtered list of objects.",
            "    \"\"\"",
            "    return {",
            "        \"tag\": tag,",
            "        \"url_name\": url_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/badge.html\")",
            "def badge(value, show_empty=False):",
            "    \"\"\"",
            "    Display the specified number as a badge.",
            "    \"\"\"",
            "    return {",
            "        \"value\": value,",
            "        \"show_empty\": show_empty,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/table_config_form.html\")",
            "def table_config_form(table, table_name=None):",
            "    return {",
            "        \"table_name\": table_name or table.__class__.__name__,",
            "        \"table_config_form\": forms.TableConfigForm(table=table),",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/filter_form_modal.html\")",
            "def filter_form_modal(",
            "    filter_form,",
            "    dynamic_filter_form,",
            "    model_plural_name,",
            "    filter_form_name=\"FilterForm\",",
            "    dynamic_filter_form_name=\"DynamicFilterForm\",",
            "):",
            "    return {",
            "        \"model_plural_name\": model_plural_name,",
            "        \"filter_form\": filter_form,",
            "        \"filter_form_name\": filter_form_name,",
            "        \"dynamic_filter_form\": dynamic_filter_form,",
            "        \"dynamic_filter_form_name\": dynamic_filter_form_name,",
            "    }",
            "",
            "",
            "@register.inclusion_tag(\"utilities/templatetags/modal_form_as_dialog.html\")",
            "def modal_form_as_dialog(form, editing=False, form_name=None, obj=None, obj_type=None):",
            "    \"\"\"Generate a form in a modal view.",
            "",
            "    Create an overlaying modal view which holds a Django form.",
            "",
            "    Inside of the template the template tag needs to be used with the correct inputs. A button will",
            "    also need to be create to open and close the modal. See below for an example:",
            "",
            "    ```",
            "    {% modal_form_as_dialog form editing=False form_name=\"CreateDevice\" obj=obj obj_type=\"Device\" %}",
            "    <a class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#CreateDevice_form\" title=\"Query Form\">Create Device</a>",
            "    ```",
            "    Args:",
            "        form (django.form.Forms): Django form object.",
            "        editing (bool, optional): Is the form creating or editing an object? Defaults to False for create.",
            "        form_name ([type], optional): Name of form. Defaults to None. If None get name from class name.",
            "        obj (django.model.Object, optional): If editing an existing model object, the object needs to be passed in. Defaults to None.",
            "        obj_type (string, optional): Used in title of form to display object type. Defaults to None.",
            "",
            "    Returns:",
            "        (dict): Passed in values used to render HTML.",
            "    \"\"\"",
            "    return {",
            "        \"editing\": editing,",
            "        \"form\": form,",
            "        \"form_action_url\": form.get_action_url(),",
            "        \"form_name\": form_name or form.__class__.__name__,",
            "        \"obj\": obj,",
            "        \"obj_type\": obj_type,",
            "    }",
            "",
            "",
            "@register.simple_tag",
            "def custom_branding_or_static(branding_asset, static_asset):",
            "    \"\"\"",
            "    This tag attempts to return custom branding assets relative to the MEDIA_ROOT and MEDIA_URL, if such",
            "    branding has been configured in settings, else it returns stock branding via static.",
            "    \"\"\"",
            "    if settings.BRANDING_FILEPATHS.get(branding_asset):",
            "        return f\"{ settings.MEDIA_URL }{ settings.BRANDING_FILEPATHS.get(branding_asset) }\"",
            "    return StaticNode.handle_simple(static_asset)",
            "",
            "",
            "@register.simple_tag",
            "def support_message():",
            "    \"\"\"",
            "    Return the configured support message (if any) or else the default.",
            "    \"\"\"",
            "    try:",
            "        message = config.get_settings_or_config(\"SUPPORT_MESSAGE\")",
            "    except AttributeError:",
            "        message = \"\"",
            "    if not message:",
            "        message = DEFAULT_SUPPORT_MESSAGE",
            "    return render_markdown(message)",
            "",
            "",
            "@library.filter()",
            "@register.filter()",
            "def hyperlinked_object_with_color(obj):",
            "    \"\"\"Render the display view of an object.\"\"\"",
            "    if obj:",
            "        content = f'<span class=\"label\" style=\"color: {fgcolor(obj.color)}; background-color: #{obj.color}\">{hyperlinked_object(obj)}</span>'",
            "        return format_html(content)",
            "    return \"\u2014\"",
            "",
            "",
            "@register.filter()",
            "def queryset_to_pks(obj):",
            "    \"\"\"Return all object UUIDs as a string separated by `,`\"\"\"",
            "    result = list(obj.values_list(\"pk\", flat=True)) if obj else []",
            "    result = [str(entry) for entry in result]",
            "    return \",\".join(result)",
            "",
            "",
            "#",
            "# Navigation",
            "#",
            "",
            "",
            "@register.filter()",
            "def is_new_ui_ready(url_path):",
            "    \"\"\"Return True if url_path is NewUI Ready else False\"\"\"",
            "    return is_route_new_ui_ready(url_path)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [
                "HTML_TRUE"
            ],
            "24": [
                "HTML_FALSE"
            ],
            "25": [
                "HTML_NONE"
            ],
            "102": [
                "placeholder"
            ],
            "126": [
                "add_html_id"
            ],
            "157": [
                "render_boolean"
            ],
            "159": [
                "render_boolean"
            ],
            "160": [
                "render_boolean"
            ],
            "183": [
                "render_markdown"
            ]
        },
        "addLocation": []
    },
    "nautobot/core/utils/data.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     rendering_engine = engines[\"jinja\"]"
            },
            "2": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     template = rendering_engine.from_string(template_code)"
            },
            "3": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return template.render(context=context)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    # For reasons unknown to me, django-jinja2 `template.render()` implicitly calls `mark_safe()` on the rendered text."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    # This is a security risk in general, especially so in our case because we're often using this function to render"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    # a user-provided template and don't want to open ourselves up to script injection or similar issues."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    # There's no `mark_unsafe()` function, but concatenating a SafeString to an ordinary string (even \"\") suffices."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+    return \"\" + template.render(context=context)"
            },
            "9": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 108,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 109,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 110,
                "PatchRowcode": " def shallow_compare_dict(source_dict, destination_dict, exclude=None):"
            }
        },
        "frontPatchFile": [
            "from collections import OrderedDict, namedtuple",
            "from decimal import Decimal",
            "import uuid",
            "",
            "from django.core import validators",
            "from django.template import engines",
            "",
            "from nautobot.dcim import choices  # TODO move dcim.choices.CableLengthUnitChoices into core",
            "",
            "",
            "# Setup UtilizationData named tuple for use by multiple methods",
            "UtilizationData = namedtuple(\"UtilizationData\", [\"numerator\", \"denominator\"])",
            "",
            "",
            "def deepmerge(original, new):",
            "    \"\"\"",
            "    Deep merge two dictionaries (new into original) and return a new dict",
            "    \"\"\"",
            "    merged = OrderedDict(original)",
            "    for key, val in new.items():",
            "        if key in original and isinstance(original[key], dict) and isinstance(val, dict):",
            "            merged[key] = deepmerge(original[key], val)",
            "        else:",
            "            merged[key] = val",
            "    return merged",
            "",
            "",
            "def flatten_dict(d, prefix=\"\", separator=\".\"):",
            "    \"\"\"",
            "    Flatten nested dictionaries into a single level by joining key names with a separator.",
            "",
            "    :param d: The dictionary to be flattened",
            "    :param prefix: Initial prefix (if any)",
            "    :param separator: The character to use when concatenating key names",
            "    \"\"\"",
            "    ret = {}",
            "    for k, v in d.items():",
            "        key = separator.join([prefix, k]) if prefix else k",
            "        if isinstance(v, dict):",
            "            ret.update(flatten_dict(v, prefix=key))",
            "        else:",
            "            ret[key] = v",
            "    return ret",
            "",
            "",
            "def flatten_iterable(iterable):",
            "    \"\"\"",
            "    Flatten a nested iterable such as a list of lists, keeping strings intact.",
            "",
            "    :param iterable: The iterable to be flattened",
            "    :returns: generator",
            "    \"\"\"",
            "    for i in iterable:",
            "        if hasattr(i, \"__iter__\") and not isinstance(i, str):",
            "            for j in flatten_iterable(i):",
            "                yield j",
            "        else:",
            "            yield i",
            "",
            "",
            "def is_uuid(value):",
            "    try:",
            "        if isinstance(value, uuid.UUID) or uuid.UUID(value):",
            "            return True",
            "    except (ValueError, TypeError, AttributeError):",
            "        pass",
            "    return False",
            "",
            "",
            "def is_url(value):",
            "    \"\"\"",
            "    Validate whether a value is a URL.",
            "",
            "    Args:",
            "        value (str): String to validate.",
            "",
            "    Returns:",
            "        (bool): True if the value is a valid URL, False otherwise.",
            "    \"\"\"",
            "    try:",
            "        return validators.URLValidator()(value) is None",
            "    except validators.ValidationError:",
            "        return False",
            "",
            "",
            "def merge_dicts_without_collision(d1, d2):",
            "    \"\"\"",
            "    Merge two dicts into a new dict, but raise a ValueError if any key exists with differing values across both dicts.",
            "    \"\"\"",
            "    intersection = d1.keys() & d2.keys()",
            "    for k in intersection:",
            "        if d1[k] != d2[k]:",
            "            raise ValueError(f'Conflicting values for key \"{k}\": ({d1[k]!r}, {d2[k]!r})')",
            "    return {**d1, **d2}",
            "",
            "",
            "def render_jinja2(template_code, context):",
            "    \"\"\"",
            "    Render a Jinja2 template with the provided context. Return the rendered content.",
            "    \"\"\"",
            "    rendering_engine = engines[\"jinja\"]",
            "    template = rendering_engine.from_string(template_code)",
            "    return template.render(context=context)",
            "",
            "",
            "def shallow_compare_dict(source_dict, destination_dict, exclude=None):",
            "    \"\"\"",
            "    Return a new dictionary of the different keys. The values of `destination_dict` are returned. Only the equality of",
            "    the first layer of keys/values is checked. `exclude` is a list or tuple of keys to be ignored.",
            "    \"\"\"",
            "    difference = {}",
            "",
            "    for key in destination_dict:",
            "        if source_dict.get(key) != destination_dict[key]:",
            "            if isinstance(exclude, (list, tuple)) and key in exclude:",
            "                continue",
            "            difference[key] = destination_dict[key]",
            "",
            "    return difference",
            "",
            "",
            "def to_meters(length, unit):",
            "    \"\"\"",
            "    Convert the given length to meters.",
            "    \"\"\"",
            "    length = int(length)",
            "    if length < 0:",
            "        raise ValueError(\"Length must be a positive integer\")",
            "",
            "    valid_units = choices.CableLengthUnitChoices.values()",
            "    if unit not in valid_units:",
            "        raise ValueError(f\"Unknown unit {unit}. Must be one of the following: {', '.join(valid_units)}\")",
            "",
            "    if unit == choices.CableLengthUnitChoices.UNIT_METER:",
            "        return length",
            "    if unit == choices.CableLengthUnitChoices.UNIT_CENTIMETER:",
            "        return length / 100",
            "    if unit == choices.CableLengthUnitChoices.UNIT_FOOT:",
            "        return length * Decimal(\"0.3048\")",
            "    if unit == choices.CableLengthUnitChoices.UNIT_INCH:",
            "        return length * Decimal(\"0.3048\") * 12",
            "    raise ValueError(f\"Unknown unit {unit}. Must be 'm', 'cm', 'ft', or 'in'.\")"
        ],
        "afterPatchFile": [
            "from collections import OrderedDict, namedtuple",
            "from decimal import Decimal",
            "import uuid",
            "",
            "from django.core import validators",
            "from django.template import engines",
            "",
            "from nautobot.dcim import choices  # TODO move dcim.choices.CableLengthUnitChoices into core",
            "",
            "",
            "# Setup UtilizationData named tuple for use by multiple methods",
            "UtilizationData = namedtuple(\"UtilizationData\", [\"numerator\", \"denominator\"])",
            "",
            "",
            "def deepmerge(original, new):",
            "    \"\"\"",
            "    Deep merge two dictionaries (new into original) and return a new dict",
            "    \"\"\"",
            "    merged = OrderedDict(original)",
            "    for key, val in new.items():",
            "        if key in original and isinstance(original[key], dict) and isinstance(val, dict):",
            "            merged[key] = deepmerge(original[key], val)",
            "        else:",
            "            merged[key] = val",
            "    return merged",
            "",
            "",
            "def flatten_dict(d, prefix=\"\", separator=\".\"):",
            "    \"\"\"",
            "    Flatten nested dictionaries into a single level by joining key names with a separator.",
            "",
            "    :param d: The dictionary to be flattened",
            "    :param prefix: Initial prefix (if any)",
            "    :param separator: The character to use when concatenating key names",
            "    \"\"\"",
            "    ret = {}",
            "    for k, v in d.items():",
            "        key = separator.join([prefix, k]) if prefix else k",
            "        if isinstance(v, dict):",
            "            ret.update(flatten_dict(v, prefix=key))",
            "        else:",
            "            ret[key] = v",
            "    return ret",
            "",
            "",
            "def flatten_iterable(iterable):",
            "    \"\"\"",
            "    Flatten a nested iterable such as a list of lists, keeping strings intact.",
            "",
            "    :param iterable: The iterable to be flattened",
            "    :returns: generator",
            "    \"\"\"",
            "    for i in iterable:",
            "        if hasattr(i, \"__iter__\") and not isinstance(i, str):",
            "            for j in flatten_iterable(i):",
            "                yield j",
            "        else:",
            "            yield i",
            "",
            "",
            "def is_uuid(value):",
            "    try:",
            "        if isinstance(value, uuid.UUID) or uuid.UUID(value):",
            "            return True",
            "    except (ValueError, TypeError, AttributeError):",
            "        pass",
            "    return False",
            "",
            "",
            "def is_url(value):",
            "    \"\"\"",
            "    Validate whether a value is a URL.",
            "",
            "    Args:",
            "        value (str): String to validate.",
            "",
            "    Returns:",
            "        (bool): True if the value is a valid URL, False otherwise.",
            "    \"\"\"",
            "    try:",
            "        return validators.URLValidator()(value) is None",
            "    except validators.ValidationError:",
            "        return False",
            "",
            "",
            "def merge_dicts_without_collision(d1, d2):",
            "    \"\"\"",
            "    Merge two dicts into a new dict, but raise a ValueError if any key exists with differing values across both dicts.",
            "    \"\"\"",
            "    intersection = d1.keys() & d2.keys()",
            "    for k in intersection:",
            "        if d1[k] != d2[k]:",
            "            raise ValueError(f'Conflicting values for key \"{k}\": ({d1[k]!r}, {d2[k]!r})')",
            "    return {**d1, **d2}",
            "",
            "",
            "def render_jinja2(template_code, context):",
            "    \"\"\"",
            "    Render a Jinja2 template with the provided context. Return the rendered content.",
            "    \"\"\"",
            "    rendering_engine = engines[\"jinja\"]",
            "    template = rendering_engine.from_string(template_code)",
            "    # For reasons unknown to me, django-jinja2 `template.render()` implicitly calls `mark_safe()` on the rendered text.",
            "    # This is a security risk in general, especially so in our case because we're often using this function to render",
            "    # a user-provided template and don't want to open ourselves up to script injection or similar issues.",
            "    # There's no `mark_unsafe()` function, but concatenating a SafeString to an ordinary string (even \"\") suffices.",
            "    return \"\" + template.render(context=context)",
            "",
            "",
            "def shallow_compare_dict(source_dict, destination_dict, exclude=None):",
            "    \"\"\"",
            "    Return a new dictionary of the different keys. The values of `destination_dict` are returned. Only the equality of",
            "    the first layer of keys/values is checked. `exclude` is a list or tuple of keys to be ignored.",
            "    \"\"\"",
            "    difference = {}",
            "",
            "    for key in destination_dict:",
            "        if source_dict.get(key) != destination_dict[key]:",
            "            if isinstance(exclude, (list, tuple)) and key in exclude:",
            "                continue",
            "            difference[key] = destination_dict[key]",
            "",
            "    return difference",
            "",
            "",
            "def to_meters(length, unit):",
            "    \"\"\"",
            "    Convert the given length to meters.",
            "    \"\"\"",
            "    length = int(length)",
            "    if length < 0:",
            "        raise ValueError(\"Length must be a positive integer\")",
            "",
            "    valid_units = choices.CableLengthUnitChoices.values()",
            "    if unit not in valid_units:",
            "        raise ValueError(f\"Unknown unit {unit}. Must be one of the following: {', '.join(valid_units)}\")",
            "",
            "    if unit == choices.CableLengthUnitChoices.UNIT_METER:",
            "        return length",
            "    if unit == choices.CableLengthUnitChoices.UNIT_CENTIMETER:",
            "        return length / 100",
            "    if unit == choices.CableLengthUnitChoices.UNIT_FOOT:",
            "        return length * Decimal(\"0.3048\")",
            "    if unit == choices.CableLengthUnitChoices.UNIT_INCH:",
            "        return length * Decimal(\"0.3048\") * 12",
            "    raise ValueError(f\"Unknown unit {unit}. Must be 'm', 'cm', 'ft', or 'in'.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "103": [
                "render_jinja2"
            ]
        },
        "addLocation": []
    },
    "nautobot/core/views/generic.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from django.http import HttpResponse, JsonResponse"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from django.shortcuts import get_object_or_404, redirect, render"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from django.utils.http import is_safe_url"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from django.views.generic import View"
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from django_tables2 import RequestConfig"
            },
            "9": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from rest_framework.exceptions import ParseError"
            },
            "10": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "             if not filterset.is_valid():"
            },
            "11": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "                 messages.error("
            },
            "12": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "                     request,"
            },
            "13": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mark_safe(f\"Invalid filters were specified: {filterset.errors}\"),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                    format_html(\"Invalid filters were specified: {}\", filterset.errors),"
            },
            "15": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "                 )"
            },
            "16": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "                 self.queryset = self.queryset.none()"
            },
            "17": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 214,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         msg = f\"{verb} {self.queryset.model._meta.verbose_name}\""
            },
            "19": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "         logger.info(f\"{msg} {obj} (PK: {obj.pk})\")"
            },
            "20": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         if hasattr(obj, \"get_absolute_url\"):"
            },
            "21": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+            msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)"
            },
            "23": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "         else:"
            },
            "24": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            msg = f\"{msg} {escape(obj)}\""
            },
            "25": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        messages.success(request, mark_safe(msg))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 401,
                "PatchRowcode": "+            msg = format_html(\"{} {}\", msg, obj)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 402,
                "PatchRowcode": "+        messages.success(request, msg)"
            },
            "28": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 403,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "     def post(self, request, *args, **kwargs):"
            },
            "30": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "         logger = logging.getLogger(__name__ + \".ObjectEditView\")"
            },
            "31": {
                "beforePatchRowNumber": 752,
                "afterPatchRowNumber": 751,
                "PatchRowcode": "                 logger.info(f\"Import object {obj} (PK: {obj.pk})\")"
            },
            "32": {
                "beforePatchRowNumber": 753,
                "afterPatchRowNumber": 752,
                "PatchRowcode": "                 messages.success("
            },
            "33": {
                "beforePatchRowNumber": 754,
                "afterPatchRowNumber": 753,
                "PatchRowcode": "                     request,"
            },
            "34": {
                "beforePatchRowNumber": 755,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mark_safe(f'Imported object: <a href=\"{obj.get_absolute_url()}\">{obj}</a>'),"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 754,
                "PatchRowcode": "+                    format_html('Imported object: <a href=\"{}\">{}</a>', obj.get_absolute_url(), obj),"
            },
            "36": {
                "beforePatchRowNumber": 756,
                "afterPatchRowNumber": 755,
                "PatchRowcode": "                 )"
            },
            "37": {
                "beforePatchRowNumber": 757,
                "afterPatchRowNumber": 756,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 758,
                "afterPatchRowNumber": 757,
                "PatchRowcode": "                 if \"_addanother\" in request.POST:"
            }
        },
        "frontPatchFile": [
            "from copy import deepcopy",
            "from io import BytesIO",
            "import logging",
            "import re",
            "",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction, IntegrityError",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput",
            "from django.http import HttpResponse, JsonResponse",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.utils.html import escape",
            "from django.utils.http import is_safe_url",
            "from django.utils.safestring import mark_safe",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "from rest_framework.exceptions import ParseError",
            "",
            "from nautobot.core.api.parsers import NautobotCSVParser",
            "from nautobot.core.api.utils import get_serializer_for_model",
            "from nautobot.core.forms import SearchForm",
            "from nautobot.core.exceptions import AbortTransaction",
            "from nautobot.core.forms import (",
            "    BootstrapMixin,",
            "    BulkRenameForm,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    ImportForm,",
            "    TableConfigForm,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.core.forms.forms import DynamicFilterFormSet",
            "from nautobot.core.templatetags.helpers import bettertitle, validated_viewname",
            "from nautobot.core.utils.config import get_settings_or_config",
            "from nautobot.core.utils.permissions import get_permission_for_model",
            "from nautobot.core.utils.requests import (",
            "    convert_querydict_to_factory_formset_acceptable_querydict,",
            "    get_filterable_params_from_filter_params,",
            "    normalize_querydict,",
            ")",
            "from nautobot.core.views.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.core.views.mixins import GetReturnURLMixin, ObjectPermissionRequiredMixin",
            "from nautobot.core.views.utils import (",
            "    check_filter_for_display,",
            "    get_csv_form_fields_from_serializer_class,",
            "    handle_protectederror,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.extras.models import ExportTemplate",
            "from nautobot.extras.utils import remove_prefix_from_cf_key",
            "",
            "",
            "class ObjectView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Retrieve a single object for display.",
            "",
            "    queryset: The base queryset for retrieving the object",
            "    template_name: Name of the template to use",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    def get_template_name(self):",
            "        \"\"\"",
            "        Return self.template_name if set. Otherwise, resolve the template path by model app_label and name.",
            "        \"\"\"",
            "        if self.template_name is not None:",
            "            return self.template_name",
            "        model_opts = self.queryset.model._meta",
            "        return f\"{model_opts.app_label}/{model_opts.model_name}.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request (Request): The current request",
            "            instance (Model): The object being viewed",
            "",
            "        Returns:",
            "            (dict): Additional context data",
            "        \"\"\"",
            "        return {",
            "            \"active_tab\": request.GET.get(\"tab\", \"main\"),",
            "        }",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Generic GET handler for accessing an object.",
            "        \"\"\"",
            "        instance = get_object_or_404(self.queryset, **kwargs)",
            "",
            "        # TODO: this feels inelegant - should the tabs lookup be a dedicated endpoint rather than piggybacking",
            "        # on the object-retrieve endpoint?",
            "        # TODO: similar functionality probably needed in NautobotUIViewSet as well, not currently present",
            "        if request.GET.get(\"viewconfig\", None) == \"true\":",
            "            # TODO: we shouldn't be importing a private-named function from another module. Should it be renamed?",
            "            from nautobot.extras.templatetags.plugins import _get_registered_content",
            "",
            "            temp_fake_context = {",
            "                \"object\": instance,",
            "                \"request\": request,",
            "                \"settings\": {},",
            "                \"csrf_token\": \"\",",
            "                \"perms\": {},",
            "            }",
            "",
            "            plugin_tabs = _get_registered_content(instance, \"detail_tabs\", temp_fake_context, return_html=False)",
            "            resp = {\"tabs\": plugin_tabs}",
            "            return JsonResponse(resp)",
            "        else:",
            "            return render(",
            "                request,",
            "                self.get_template_name(),",
            "                {",
            "                    \"object\": instance,",
            "                    \"verbose_name\": self.queryset.model._meta.verbose_name,",
            "                    \"verbose_name_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                    **self.get_extra_context(request, instance),",
            "                },",
            "            )",
            "",
            "",
            "class ObjectListView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    List a series of objects.",
            "",
            "    queryset: The queryset of objects to display. Note: Prefetching related objects is not necessary, as the",
            "      table will prefetch objects as needed depending on the columns being displayed.",
            "    filter: A django-filter FilterSet that is applied to the queryset",
            "    filter_form: The form used to render filter options",
            "    table: The django-tables2 Table used to render the objects list",
            "    template_name: The name of the template",
            "    non_filter_params: List of query parameters that are **not** used for queryset filtering",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    filterset_form = None",
            "    table = None",
            "    template_name = \"generic/object_list.html\"",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset())",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    # TODO: remove this as well?",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        yaml_data = [obj.to_yaml() for obj in self.queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def validate_action_buttons(self, request):",
            "        \"\"\"Verify actions in self.action_buttons are valid view actions.\"\"\"",
            "",
            "        always_valid_actions = (\"export\",)",
            "        valid_actions = []",
            "        invalid_actions = []",
            "        # added check for whether the action_buttons exist because of issue #2107",
            "        if self.action_buttons is None:",
            "            self.action_buttons = []",
            "        for action in self.action_buttons:",
            "            if action in always_valid_actions or validated_viewname(self.queryset.model, action) is not None:",
            "                valid_actions.append(action)",
            "            else:",
            "                invalid_actions.append(action)",
            "        if invalid_actions:",
            "            messages.error(request, f\"Missing views for action(s) {', '.join(invalid_actions)}\")",
            "        return valid_actions",
            "",
            "    def get(self, request):",
            "        model = self.queryset.model",
            "        content_type = ContentType.objects.get_for_model(model)",
            "",
            "        display_filter_params = []",
            "        dynamic_filter_form = None",
            "        filter_form = None",
            "",
            "        if self.filterset:",
            "            filter_params = self.get_filter_params(request)",
            "            filterset = self.filterset(filter_params, self.queryset)",
            "            self.queryset = filterset.qs",
            "            if not filterset.is_valid():",
            "                messages.error(",
            "                    request,",
            "                    mark_safe(f\"Invalid filters were specified: {filterset.errors}\"),",
            "                )",
            "                self.queryset = self.queryset.none()",
            "",
            "            display_filter_params = [",
            "                check_filter_for_display(filterset.filters, field_name, values)",
            "                for field_name, values in filter_params.items()",
            "            ]",
            "",
            "            if request.GET:",
            "                factory_formset_params = convert_querydict_to_factory_formset_acceptable_querydict(",
            "                    request.GET, filterset",
            "                )",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset, data=factory_formset_params)",
            "            else:",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset)",
            "",
            "            if self.filterset_form:",
            "                filter_form = self.filterset_form(filter_params, label_suffix=\"\")",
            "",
            "        # Check for export template rendering",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(self.queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{self.queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Provide a hook to tweak the queryset based on the request immediately prior to rendering the object list",
            "        self.queryset = self.alter_queryset(request)",
            "",
            "        # Compile a dictionary indicating which permissions are available to the current user for this model",
            "        permissions = {}",
            "        for action in (\"add\", \"change\", \"delete\", \"view\"):",
            "            perm_name = get_permission_for_model(model, action)",
            "            permissions[action] = request.user.has_perm(perm_name)",
            "",
            "        table = None",
            "        table_config_form = None",
            "        if self.table:",
            "            # Construct the objects table",
            "            # Order By is needed in the table `__init__` method",
            "            order_by = self.request.GET.getlist(\"sort\")",
            "            table = self.table(self.queryset, user=request.user, order_by=order_by)",
            "            if \"pk\" in table.base_columns and (permissions[\"change\"] or permissions[\"delete\"]):",
            "                table.columns.show(\"pk\")",
            "",
            "            # Apply the request context",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(table)",
            "            table_config_form = TableConfigForm(table=table)",
            "            max_page_size = get_settings_or_config(\"MAX_PAGE_SIZE\")",
            "            if max_page_size and paginate[\"per_page\"] > max_page_size:",
            "                messages.warning(",
            "                    request,",
            "                    f'Requested \"per_page\" is too large. No more than {max_page_size} items may be displayed at a time.',",
            "                )",
            "",
            "        # For the search form field, use a custom placeholder.",
            "        q_placeholder = \"Search \" + bettertitle(model._meta.verbose_name_plural)",
            "        search_form = SearchForm(data=request.GET, q_placeholder=q_placeholder)",
            "",
            "        valid_actions = self.validate_action_buttons(request)",
            "",
            "        context = {",
            "            \"content_type\": content_type,",
            "            \"table\": table,",
            "            \"permissions\": permissions,",
            "            \"action_buttons\": valid_actions,",
            "            \"table_config_form\": table_config_form,",
            "            \"filter_params\": display_filter_params,",
            "            \"filter_form\": filter_form,",
            "            \"dynamic_filter_form\": dynamic_filter_form,",
            "            \"search_form\": search_form,",
            "            \"list_url\": validated_viewname(model, \"list\"),",
            "            \"title\": bettertitle(model._meta.verbose_name_plural),",
            "        }",
            "",
            "        # `extra_context()` would require `request` access, however `request` parameter cannot simply be",
            "        # added to `extra_context()` because  this method has been used by multiple apps without any parameters.",
            "        # Changing 'def extra context()' to 'def extra context(request)' might break current methods",
            "        # in plugins and core that either override or implement it without request.",
            "        setattr(self, \"request\", request)",
            "        context.update(self.extra_context())",
            "",
            "        return render(request, self.template_name, context)",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        return self.queryset.all()",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class ObjectEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create or edit a single object.",
            "",
            "    queryset: The base queryset for the object being modified",
            "    model_form: The form used to create or edit the object",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    template_name = \"generic/object_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        # self._permission_action is set by dispatch() to either \"add\" or \"change\" depending on whether",
            "        # we are modifying an existing object or creating a new one.",
            "        return get_permission_for_model(self.queryset.model, self._permission_action)",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by PK, name, or slug, if provided.",
            "        for field in (\"pk\", \"name\", \"slug\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request (HttpRequest): The current request",
            "            instance (Model): The object being edited",
            "",
            "        Returns:",
            "            (dict): Additional context data",
            "        \"\"\"",
            "        return {}",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed. For example, a parent object can be defined",
            "        # given some parameter from the request URL.",
            "        return obj",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Determine required permission based on whether we are editing an existing object",
            "        self._permission_action = \"change\" if kwargs else \"add\"",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "",
            "        initial_data = normalize_querydict(request.GET, form_class=self.model_form)",
            "        form = self.model_form(instance=obj, initial=initial_data)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "    def successful_post(self, request, obj, created, logger):",
            "        \"\"\"Callback after the form is successfully saved but before redirecting the user.\"\"\"",
            "        verb = \"Created\" if created else \"Modified\"",
            "        msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "        logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "        if hasattr(obj, \"get_absolute_url\"):",
            "            msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'",
            "        else:",
            "            msg = f\"{msg} {escape(obj)}\"",
            "        messages.success(request, mark_safe(msg))",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".ObjectEditView\")",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "                self.successful_post(request, obj, object_created, logger)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete a single object.",
            "",
            "    queryset: The base queryset for the object being deleted",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by PK, name, or slug, if provided.",
            "        for field in (\"pk\", \"name\", \"slug\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get(self, request, **kwargs):",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(initial=request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".ObjectDeleteView\")",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                obj.delete()",
            "            except ProtectedError as e:",
            "                logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "                handle_protectederror([obj], request, e)",
            "                return redirect(obj.get_absolute_url())",
            "",
            "            msg = f\"Deleted {self.queryset.model._meta.verbose_name} {obj}\"",
            "            logger.info(msg)",
            "            messages.success(request, msg)",
            "",
            "            return_url = form.cleaned_data.get(\"return_url\")",
            "            if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                return redirect(return_url)",
            "            else:",
            "                return redirect(self.get_return_url(request, obj))",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class BulkCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create new objects in bulk.",
            "",
            "    queryset: Base queryset for the objects being created",
            "    form: Form class which provides the `pattern` field",
            "    model_form: The ModelForm used to create individual objects",
            "    pattern_target: Name of the field to be evaluated as a pattern (if any)",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    pattern_target = \"\"",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        # Set initial values for visible form fields from query args",
            "        initial = {}",
            "        for field in getattr(self.model_form._meta, \"fields\", []):",
            "            if request.GET.get(field):",
            "                initial[field] = request.GET[field]",
            "",
            "        form = self.form()",
            "        model_form = self.model_form(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkCreateView\")",
            "        model = self.queryset.model",
            "        form = self.form(request.POST)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "            pattern = form.cleaned_data[\"pattern\"]",
            "            new_objs = []",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    # Create objects from the expanded. Abort the transaction on the first validation error.",
            "                    for value in pattern:",
            "                        # Reinstantiate the model form each time to avoid overwriting the same instance. Use a mutable",
            "                        # copy of the POST QueryDict so that we can update the target field value.",
            "                        model_form = self.model_form(request.POST.copy())",
            "                        model_form.data[self.pattern_target] = value",
            "",
            "                        # Validate each new object independently.",
            "                        if model_form.is_valid():",
            "                            obj = model_form.save()",
            "                            logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "                            new_objs.append(obj)",
            "                        else:",
            "                            # Copy any errors on the pattern target field to the pattern form.",
            "                            errors = model_form.errors.as_data()",
            "                            if errors.get(self.pattern_target):",
            "                                form.add_error(\"pattern\", errors[self.pattern_target])",
            "                            # Raise an IntegrityError to break the for loop and abort the transaction.",
            "                            raise IntegrityError()",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                    # If we make it to this point, validation has succeeded on all new objects.",
            "                    msg = f\"Added {len(new_objs)} {model._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.path)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            except IntegrityError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object creation failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"obj_type\": model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import a single object (YAML or JSON format).",
            "",
            "    queryset: Base queryset for the objects being created",
            "    model_form: The ModelForm used to create individual objects",
            "    related_object_forms: A dictionary mapping of forms to be used for the creation of related (child) objects",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    related_object_forms = {}",
            "    template_name = \"generic/object_import.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = ImportForm()",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".ObjectImportView\")",
            "        form = ImportForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Import form validation was successful\")",
            "",
            "            # Initialize model form",
            "            data = form.cleaned_data[\"data\"]",
            "            model_form = self.model_form(data)",
            "            restrict_form_fields(model_form, request.user)",
            "",
            "            # Assign default values for any fields which were not specified. We have to do this manually because passing",
            "            # 'initial=' to the form on initialization merely sets default values for the widgets. Since widgets are not",
            "            # used for YAML/JSON import, we first bind the imported data normally, then update the form's data with the",
            "            # applicable field defaults as needed prior to form validation.",
            "            for field_name, field in model_form.fields.items():",
            "                if field_name not in data and hasattr(field, \"initial\"):",
            "                    model_form.data[field_name] = field.initial",
            "",
            "            if model_form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Save the primary object",
            "                        obj = model_form.save()",
            "",
            "                        # Enforce object-level permissions",
            "                        self.queryset.get(pk=obj.pk)",
            "",
            "                        logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "",
            "                        # Iterate through the related object forms (if any), validating and saving each instance.",
            "                        for (",
            "                            field_name,",
            "                            related_object_form,",
            "                        ) in self.related_object_forms.items():",
            "                            logger.debug(\"Processing form for related objects: {related_object_form}\")",
            "",
            "                            related_obj_pks = []",
            "                            for i, rel_obj_data in enumerate(data.get(field_name, [])):",
            "                                f = related_object_form(obj, rel_obj_data)",
            "",
            "                                for subfield_name, field in f.fields.items():",
            "                                    if subfield_name not in rel_obj_data and hasattr(field, \"initial\"):",
            "                                        f.data[subfield_name] = field.initial",
            "",
            "                                if f.is_valid():",
            "                                    related_obj = f.save()",
            "                                    related_obj_pks.append(related_obj.pk)",
            "                                else:",
            "                                    # Replicate errors on the related object form to the primary form for display",
            "                                    for subfield_name, errors in f.errors.items():",
            "                                        for err in errors:",
            "                                            err_msg = f\"{field_name}[{i}] {subfield_name}: {err}\"",
            "                                            model_form.add_error(None, err_msg)",
            "                                    raise AbortTransaction()",
            "",
            "                            # Enforce object-level permissions on related objects",
            "                            model = related_object_form.Meta.model",
            "                            if model.objects.filter(pk__in=related_obj_pks).count() != len(related_obj_pks):",
            "                                raise ObjectDoesNotExist",
            "",
            "                except AbortTransaction:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            if not model_form.errors:",
            "                logger.info(f\"Import object {obj} (PK: {obj.pk})\")",
            "                messages.success(",
            "                    request,",
            "                    mark_safe(f'Imported object: <a href=\"{obj.get_absolute_url()}\">{obj}</a>'),",
            "                )",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            else:",
            "                logger.debug(\"Model form validation failed\")",
            "",
            "                # Replicate model form errors for display",
            "                for field, errors in model_form.errors.items():",
            "                    for err in errors:",
            "                        if field == \"__all__\":",
            "                            form.add_error(None, err)",
            "                        else:",
            "                            form.add_error(None, f\"{field}: {err}\")",
            "",
            "        else:",
            "            logger.debug(\"Import form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import objects in bulk (CSV format).",
            "",
            "    queryset: Base queryset for the model",
            "    table: The django-tables2 Table used to render the list of imported objects",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_import.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.serializer_class = get_serializer_for_model(self.queryset.model)",
            "        self.fields = get_csv_form_fields_from_serializer_class(self.serializer_class)",
            "        self.required_field_names = [",
            "            field[\"name\"]",
            "            for field in get_csv_form_fields_from_serializer_class(self.serializer_class)",
            "            if field[\"required\"]",
            "        ]",
            "",
            "    def _import_form(self, *args, **kwargs):",
            "        class CSVImportForm(BootstrapMixin, Form):",
            "            csv_data = CSVDataField(required_field_names=self.required_field_names)",
            "            csv_file = CSVFileField()",
            "",
            "        return CSVImportForm(*args, **kwargs)",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": self._import_form(),",
            "                \"fields\": self.fields,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-data\",",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkImportView\")",
            "        new_objs = []",
            "        form = self._import_form(request.POST, request.FILES)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                # Iterate through CSV data and bind each row to a new model form instance.",
            "                with transaction.atomic():",
            "                    if request.FILES:",
            "                        field_name = \"csv_file\"",
            "                    else:",
            "                        field_name = \"csv_data\"",
            "                    csvtext = form.cleaned_data[field_name]",
            "",
            "                    try:",
            "                        data = NautobotCSVParser().parse(",
            "                            stream=BytesIO(csvtext.encode(\"utf-8\")),",
            "                            parser_context={\"request\": request, \"serializer_class\": self.serializer_class},",
            "                        )",
            "                        serializer = self.serializer_class(data=data, context={\"request\": request}, many=True)",
            "                        if serializer.is_valid():",
            "                            new_objs = serializer.save()",
            "                        else:",
            "                            for row, errors in enumerate(serializer.errors, start=1):",
            "                                for field, err in errors.items():",
            "                                    form.add_error(field_name, f\"Row {row}: {field}: {err[0]}\")",
            "                            raise ValidationError(\"\")",
            "                    except ParseError as exc:",
            "                        form.add_error(None, str(exc))",
            "                        raise ValidationError(\"\")",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                # Compile a table containing the imported objects",
            "                obj_table = self.table(new_objs)",
            "",
            "                if new_objs:",
            "                    msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return render(",
            "                        request,",
            "                        \"import_success.html\",",
            "                        {",
            "                            \"table\": obj_table,",
            "                            \"return_url\": self.get_return_url(request),",
            "                        },",
            "                    )",
            "",
            "            except ValidationError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object import failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"fields\": self.fields,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-file\" if form.has_error(\"csv_file\") else \"csv-data\",",
            "            },",
            "        )",
            "",
            "",
            "class BulkEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Edit objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being edited",
            "    form: The form class used to edit objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed.",
            "        # For example, a parent object can be defined given some parameter from the request URL.",
            "        return obj",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".BulkEditView\")",
            "        model = self.queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = list(self.filterset(request.GET, model.objects.only(\"pk\")).qs.values_list(\"pk\", flat=True))",
            "            else:",
            "                pk_list = list(model.objects.all().values_list(\"pk\", flat=True))",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        if \"_apply\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "                form_custom_fields = getattr(form, \"custom_fields\", [])",
            "                form_relationships = getattr(form, \"relationships\", [])",
            "                standard_fields = [",
            "                    field",
            "                    for field in form.fields",
            "                    if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "                ]",
            "                nullified_fields = request.POST.getlist(\"_nullify\")",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        updated_objects = []",
            "                        for obj in self.queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                            obj = self.alter_obj(obj, request, [], kwargs)",
            "",
            "                            # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                            for name in standard_fields:",
            "                                try:",
            "                                    model_field = model._meta.get_field(name)",
            "                                except FieldDoesNotExist:",
            "                                    # This form field is used to modify a field rather than set its value directly",
            "                                    model_field = None",
            "",
            "                                # Handle nullification",
            "                                if name in form.nullable_fields and name in nullified_fields:",
            "                                    if isinstance(model_field, ManyToManyField):",
            "                                        getattr(obj, name).set([])",
            "                                    else:",
            "                                        setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "",
            "                                # ManyToManyFields",
            "                                elif isinstance(model_field, ManyToManyField):",
            "                                    if form.cleaned_data[name]:",
            "                                        getattr(obj, name).set(form.cleaned_data[name])",
            "                                # Normal fields",
            "                                elif form.cleaned_data[name] not in (None, \"\"):",
            "                                    setattr(obj, name, form.cleaned_data[name])",
            "",
            "                            # Update custom fields",
            "                            for field_name in form_custom_fields:",
            "                                if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                                    obj.cf[remove_prefix_from_cf_key(field_name)] = None",
            "                                elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                                    obj.cf[remove_prefix_from_cf_key(field_name)] = form.cleaned_data[field_name]",
            "",
            "                            obj.full_clean()",
            "                            obj.save()",
            "                            updated_objects.append(obj)",
            "                            logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                            # Add/remove tags",
            "                            if form.cleaned_data.get(\"add_tags\", None):",
            "                                obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                            if form.cleaned_data.get(\"remove_tags\", None):",
            "                                obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                            if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                                # Add/remove relationship associations",
            "                                form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                                form.save_note(instance=obj, user=request.user)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(",
            "                            updated_objects",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    if updated_objects:",
            "                        msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "                        logger.info(msg)",
            "                        messages.success(self.request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                except ValidationError as e:",
            "                    messages.error(self.request, f\"{obj} failed validation: {e}\")",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            # Include the PK list as initial data for the form",
            "            initial_data = {\"pk\": pk_list}",
            "",
            "            # Check for other contextual data needed for the form. We avoid passing all of request.GET because the",
            "            # filter values will conflict with the bulk edit form fields.",
            "            # TODO: Find a better way to accomplish this",
            "            if \"device\" in request.GET:",
            "                initial_data[\"device\"] = request.GET.get(\"device\")",
            "            elif \"device_type\" in request.GET:",
            "                initial_data[\"device_type\"] = request.GET.get(\"device_type\")",
            "",
            "            form = self.form(model, initial=initial_data)",
            "            restrict_form_fields(form, request.user)",
            "",
            "        # Retrieve objects being edited",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(request, f\"No {model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"table\": table,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class BulkRenameView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    An extendable view for renaming objects in bulk.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_bulk_rename.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Create a new Form class from BulkRenameForm",
            "        class _Form(BulkRenameForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput())",
            "",
            "        self.form = _Form",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkRenameView\")",
            "        query_pks = request.POST.getlist(\"pk\")",
            "        selected_objects = self.queryset.filter(pk__in=query_pks) if query_pks else None",
            "",
            "        # selected_objects would return False; if no query_pks or invalid query_pks",
            "        if not selected_objects:",
            "            messages.warning(request, f\"No valid {self.queryset.model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        if \"_preview\" in request.POST or \"_apply\" in request.POST:",
            "            form = self.form(request.POST, initial={\"pk\": query_pks})",
            "            if form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        renamed_pks = []",
            "                        for obj in selected_objects:",
            "                            find = form.cleaned_data[\"find\"]",
            "                            replace = form.cleaned_data[\"replace\"]",
            "                            if form.cleaned_data[\"use_regex\"]:",
            "                                try:",
            "                                    obj.new_name = re.sub(find, replace, obj.name)",
            "                                # Catch regex group reference errors",
            "                                except re.error:",
            "                                    obj.new_name = obj.name",
            "                            else:",
            "                                obj.new_name = obj.name.replace(find, replace)",
            "                            renamed_pks.append(obj.pk)",
            "",
            "                        if \"_apply\" in request.POST:",
            "                            for obj in selected_objects:",
            "                                obj.name = obj.new_name",
            "                                obj.save()",
            "",
            "                            # Enforce constrained permissions",
            "                            if self.queryset.filter(pk__in=renamed_pks).count() != len(selected_objects):",
            "                                raise ObjectDoesNotExist",
            "",
            "                            messages.success(",
            "                                request,",
            "                                f\"Renamed {len(selected_objects)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                            )",
            "                            return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        else:",
            "            form = self.form(initial={\"pk\": query_pks})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"selected_objects\": selected_objects,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"parent_name\": self.get_selected_objects_parents_name(selected_objects),",
            "            },",
            "        )",
            "",
            "    def get_selected_objects_parents_name(self, selected_objects):",
            "        \"\"\"",
            "        Return selected_objects parent name.",
            "",
            "        This method is intended to be overridden by child classes to return the parent name of the selected objects.",
            "",
            "        Args:",
            "            selected_objects (list[BaseModel]): The objects being renamed",
            "",
            "        Returns:",
            "            (str): The parent name of the selected objects",
            "        \"\"\"",
            "",
            "        return \"\"",
            "",
            "",
            "class BulkDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being deleted",
            "    form: The form class used to delete objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".BulkDeleteView\")",
            "        model = self.queryset.model",
            "",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = list(self.filterset(request.GET, model.objects.only(\"pk\")).qs.values_list(\"pk\", flat=True))",
            "            else:",
            "                pk_list = list(model.objects.all().values_list(\"pk\", flat=True))",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        form_cls = self.get_form()",
            "",
            "        if \"_confirm\" in request.POST:",
            "            form = form_cls(request.POST)",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                # Delete objects",
            "                queryset = self.queryset.filter(pk__in=pk_list)",
            "",
            "                self.perform_pre_delete(request, queryset)",
            "                try:",
            "                    _, deleted_info = queryset.delete()",
            "                    deleted_count = deleted_info[model._meta.label]",
            "                except ProtectedError as e:",
            "                    logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "                    handle_protectederror(queryset, request, e)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                logger.info(msg)",
            "                messages.success(request, msg)",
            "                return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = form_cls(",
            "                initial={",
            "                    \"pk\": pk_list,",
            "                    \"return_url\": self.get_return_url(request),",
            "                }",
            "            )",
            "",
            "        # Retrieve objects being deleted",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"table\": table,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        pass",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "    def get_form(self):",
            "        \"\"\"",
            "        Provide a standard bulk delete form if none has been specified for the view",
            "        \"\"\"",
            "",
            "        class BulkDeleteForm(ConfirmationForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput)",
            "",
            "        if self.form:",
            "            return self.form",
            "",
            "        return BulkDeleteForm",
            "",
            "",
            "#",
            "# Device/VirtualMachine components",
            "#",
            "",
            "",
            "# TODO: Replace with BulkCreateView",
            "class ComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a Device or VirtualMachine.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = self.form(initial=request.GET)",
            "        model_form = self.model_form(request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"model_form\": model_form,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".ComponentCreateView\")",
            "        form = self.form(request.POST, initial=request.GET)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            new_components = []",
            "            data = deepcopy(request.POST)",
            "",
            "            names = form.cleaned_data[\"name_pattern\"]",
            "            labels = form.cleaned_data.get(\"label_pattern\")",
            "            for i, name in enumerate(names):",
            "                label = labels[i] if labels else None",
            "                # Initialize the individual component form",
            "                data[\"name\"] = name",
            "                data[\"label\"] = label",
            "                if hasattr(form, \"get_iterative_data\"):",
            "                    data.update(form.get_iterative_data(i))",
            "                component_form = self.model_form(data)",
            "",
            "                if component_form.is_valid():",
            "                    new_components.append(component_form)",
            "                else:",
            "                    for field, errors in component_form.errors.as_data().items():",
            "                        # Assign errors on the child form's name/label field to name_pattern/label_pattern on the parent form",
            "                        if field == \"name\":",
            "                            field = \"name_pattern\"",
            "                        elif field == \"label\":",
            "                            field = \"label_pattern\"",
            "                        for e in errors:",
            "                            err_str = \", \".join(e)",
            "                            form.add_error(field, f\"{name}: {err_str}\")",
            "",
            "            if not form.errors:",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Create the new components",
            "                        new_objs = []",
            "                        for component_form in new_components:",
            "                            obj = component_form.save()",
            "                            new_objs.append(obj)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    messages.success(",
            "                        request,",
            "                        f\"Added {len(new_components)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                    )",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.get_full_path())",
            "                    else:",
            "                        return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a set of Devices or VirtualMachines.",
            "    \"\"\"",
            "",
            "    parent_model = None",
            "    parent_field = None",
            "    form = None",
            "    queryset = None",
            "    model_form = None",
            "    filterset = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_add_component.html\"",
            "",
            "    def get_required_permission(self):",
            "        return f\"dcim.add_{self.queryset.model._meta.model_name}\"",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkComponentCreateView\")",
            "        parent_model_name = self.parent_model._meta.verbose_name_plural",
            "        model_name = self.queryset.model._meta.verbose_name_plural",
            "        model = self.queryset.model",
            "",
            "        # Are we editing *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\") and self.filterset is not None:",
            "            pk_list = [obj.pk for obj in self.filterset(request.GET, self.parent_model.objects.only(\"pk\")).qs]",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        selected_objects = self.parent_model.objects.filter(pk__in=pk_list)",
            "        if not selected_objects:",
            "            messages.warning(",
            "                request,",
            "                f\"No {self.parent_model._meta.verbose_name_plural} were selected.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        table = self.table(selected_objects)",
            "",
            "        if \"_create\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                new_components = []",
            "                data = deepcopy(form.cleaned_data)",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        for obj in data[\"pk\"]:",
            "                            names = data[\"name_pattern\"]",
            "                            labels = data[\"label_pattern\"] if \"label_pattern\" in data else None",
            "                            for i, name in enumerate(names):",
            "                                label = labels[i] if labels else None",
            "",
            "                                component_data = {",
            "                                    self.parent_field: obj.pk,",
            "                                    \"name\": name,",
            "                                    \"label\": label,",
            "                                }",
            "                                component_data.update(data)",
            "                                component_form = self.model_form(component_data)",
            "                                if component_form.is_valid():",
            "                                    instance = component_form.save()",
            "                                    logger.debug(f\"Created {instance} on {instance.parent}\")",
            "                                    new_components.append(instance)",
            "                                else:",
            "                                    for (",
            "                                        field,",
            "                                        errors,",
            "                                    ) in component_form.errors.as_data().items():",
            "                                        for e in errors:",
            "                                            err_str = \", \".join(e)",
            "                                            form.add_error(",
            "                                                field,",
            "                                                f\"{obj} {name}: {err_str}\",",
            "                                            )",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_components]).count() != len(",
            "                            new_components",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                except IntegrityError:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "                if not form.errors:",
            "                    msg = f\"Added {len(new_components)} {model_name} to {len(form.cleaned_data['pk'])} {parent_model_name}.\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = self.form(model, initial={\"pk\": pk_list})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"parent_model_name\": parent_model_name,",
            "                \"model_name\": model_name,",
            "                \"table\": table,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )"
        ],
        "afterPatchFile": [
            "from copy import deepcopy",
            "from io import BytesIO",
            "import logging",
            "import re",
            "",
            "from django.conf import settings",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction, IntegrityError",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput",
            "from django.http import HttpResponse, JsonResponse",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.utils.html import format_html",
            "from django.utils.http import is_safe_url",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "from rest_framework.exceptions import ParseError",
            "",
            "from nautobot.core.api.parsers import NautobotCSVParser",
            "from nautobot.core.api.utils import get_serializer_for_model",
            "from nautobot.core.forms import SearchForm",
            "from nautobot.core.exceptions import AbortTransaction",
            "from nautobot.core.forms import (",
            "    BootstrapMixin,",
            "    BulkRenameForm,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    ImportForm,",
            "    TableConfigForm,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.core.forms.forms import DynamicFilterFormSet",
            "from nautobot.core.templatetags.helpers import bettertitle, validated_viewname",
            "from nautobot.core.utils.config import get_settings_or_config",
            "from nautobot.core.utils.permissions import get_permission_for_model",
            "from nautobot.core.utils.requests import (",
            "    convert_querydict_to_factory_formset_acceptable_querydict,",
            "    get_filterable_params_from_filter_params,",
            "    normalize_querydict,",
            ")",
            "from nautobot.core.views.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.core.views.mixins import GetReturnURLMixin, ObjectPermissionRequiredMixin",
            "from nautobot.core.views.utils import (",
            "    check_filter_for_display,",
            "    get_csv_form_fields_from_serializer_class,",
            "    handle_protectederror,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.extras.models import ExportTemplate",
            "from nautobot.extras.utils import remove_prefix_from_cf_key",
            "",
            "",
            "class ObjectView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Retrieve a single object for display.",
            "",
            "    queryset: The base queryset for retrieving the object",
            "    template_name: Name of the template to use",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    def get_template_name(self):",
            "        \"\"\"",
            "        Return self.template_name if set. Otherwise, resolve the template path by model app_label and name.",
            "        \"\"\"",
            "        if self.template_name is not None:",
            "            return self.template_name",
            "        model_opts = self.queryset.model._meta",
            "        return f\"{model_opts.app_label}/{model_opts.model_name}.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request (Request): The current request",
            "            instance (Model): The object being viewed",
            "",
            "        Returns:",
            "            (dict): Additional context data",
            "        \"\"\"",
            "        return {",
            "            \"active_tab\": request.GET.get(\"tab\", \"main\"),",
            "        }",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Generic GET handler for accessing an object.",
            "        \"\"\"",
            "        instance = get_object_or_404(self.queryset, **kwargs)",
            "",
            "        # TODO: this feels inelegant - should the tabs lookup be a dedicated endpoint rather than piggybacking",
            "        # on the object-retrieve endpoint?",
            "        # TODO: similar functionality probably needed in NautobotUIViewSet as well, not currently present",
            "        if request.GET.get(\"viewconfig\", None) == \"true\":",
            "            # TODO: we shouldn't be importing a private-named function from another module. Should it be renamed?",
            "            from nautobot.extras.templatetags.plugins import _get_registered_content",
            "",
            "            temp_fake_context = {",
            "                \"object\": instance,",
            "                \"request\": request,",
            "                \"settings\": {},",
            "                \"csrf_token\": \"\",",
            "                \"perms\": {},",
            "            }",
            "",
            "            plugin_tabs = _get_registered_content(instance, \"detail_tabs\", temp_fake_context, return_html=False)",
            "            resp = {\"tabs\": plugin_tabs}",
            "            return JsonResponse(resp)",
            "        else:",
            "            return render(",
            "                request,",
            "                self.get_template_name(),",
            "                {",
            "                    \"object\": instance,",
            "                    \"verbose_name\": self.queryset.model._meta.verbose_name,",
            "                    \"verbose_name_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                    **self.get_extra_context(request, instance),",
            "                },",
            "            )",
            "",
            "",
            "class ObjectListView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    List a series of objects.",
            "",
            "    queryset: The queryset of objects to display. Note: Prefetching related objects is not necessary, as the",
            "      table will prefetch objects as needed depending on the columns being displayed.",
            "    filter: A django-filter FilterSet that is applied to the queryset",
            "    filter_form: The form used to render filter options",
            "    table: The django-tables2 Table used to render the objects list",
            "    template_name: The name of the template",
            "    non_filter_params: List of query parameters that are **not** used for queryset filtering",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    filterset_form = None",
            "    table = None",
            "    template_name = \"generic/object_list.html\"",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset())",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"view\")",
            "",
            "    # TODO: remove this as well?",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        yaml_data = [obj.to_yaml() for obj in self.queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def validate_action_buttons(self, request):",
            "        \"\"\"Verify actions in self.action_buttons are valid view actions.\"\"\"",
            "",
            "        always_valid_actions = (\"export\",)",
            "        valid_actions = []",
            "        invalid_actions = []",
            "        # added check for whether the action_buttons exist because of issue #2107",
            "        if self.action_buttons is None:",
            "            self.action_buttons = []",
            "        for action in self.action_buttons:",
            "            if action in always_valid_actions or validated_viewname(self.queryset.model, action) is not None:",
            "                valid_actions.append(action)",
            "            else:",
            "                invalid_actions.append(action)",
            "        if invalid_actions:",
            "            messages.error(request, f\"Missing views for action(s) {', '.join(invalid_actions)}\")",
            "        return valid_actions",
            "",
            "    def get(self, request):",
            "        model = self.queryset.model",
            "        content_type = ContentType.objects.get_for_model(model)",
            "",
            "        display_filter_params = []",
            "        dynamic_filter_form = None",
            "        filter_form = None",
            "",
            "        if self.filterset:",
            "            filter_params = self.get_filter_params(request)",
            "            filterset = self.filterset(filter_params, self.queryset)",
            "            self.queryset = filterset.qs",
            "            if not filterset.is_valid():",
            "                messages.error(",
            "                    request,",
            "                    format_html(\"Invalid filters were specified: {}\", filterset.errors),",
            "                )",
            "                self.queryset = self.queryset.none()",
            "",
            "            display_filter_params = [",
            "                check_filter_for_display(filterset.filters, field_name, values)",
            "                for field_name, values in filter_params.items()",
            "            ]",
            "",
            "            if request.GET:",
            "                factory_formset_params = convert_querydict_to_factory_formset_acceptable_querydict(",
            "                    request.GET, filterset",
            "                )",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset, data=factory_formset_params)",
            "            else:",
            "                dynamic_filter_form = DynamicFilterFormSet(filterset=filterset)",
            "",
            "            if self.filterset_form:",
            "                filter_form = self.filterset_form(filter_params, label_suffix=\"\")",
            "",
            "        # Check for export template rendering",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(self.queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"{settings.BRANDING_PREPENDED_FILENAME}{self.queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        # Provide a hook to tweak the queryset based on the request immediately prior to rendering the object list",
            "        self.queryset = self.alter_queryset(request)",
            "",
            "        # Compile a dictionary indicating which permissions are available to the current user for this model",
            "        permissions = {}",
            "        for action in (\"add\", \"change\", \"delete\", \"view\"):",
            "            perm_name = get_permission_for_model(model, action)",
            "            permissions[action] = request.user.has_perm(perm_name)",
            "",
            "        table = None",
            "        table_config_form = None",
            "        if self.table:",
            "            # Construct the objects table",
            "            # Order By is needed in the table `__init__` method",
            "            order_by = self.request.GET.getlist(\"sort\")",
            "            table = self.table(self.queryset, user=request.user, order_by=order_by)",
            "            if \"pk\" in table.base_columns and (permissions[\"change\"] or permissions[\"delete\"]):",
            "                table.columns.show(\"pk\")",
            "",
            "            # Apply the request context",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(table)",
            "            table_config_form = TableConfigForm(table=table)",
            "            max_page_size = get_settings_or_config(\"MAX_PAGE_SIZE\")",
            "            if max_page_size and paginate[\"per_page\"] > max_page_size:",
            "                messages.warning(",
            "                    request,",
            "                    f'Requested \"per_page\" is too large. No more than {max_page_size} items may be displayed at a time.',",
            "                )",
            "",
            "        # For the search form field, use a custom placeholder.",
            "        q_placeholder = \"Search \" + bettertitle(model._meta.verbose_name_plural)",
            "        search_form = SearchForm(data=request.GET, q_placeholder=q_placeholder)",
            "",
            "        valid_actions = self.validate_action_buttons(request)",
            "",
            "        context = {",
            "            \"content_type\": content_type,",
            "            \"table\": table,",
            "            \"permissions\": permissions,",
            "            \"action_buttons\": valid_actions,",
            "            \"table_config_form\": table_config_form,",
            "            \"filter_params\": display_filter_params,",
            "            \"filter_form\": filter_form,",
            "            \"dynamic_filter_form\": dynamic_filter_form,",
            "            \"search_form\": search_form,",
            "            \"list_url\": validated_viewname(model, \"list\"),",
            "            \"title\": bettertitle(model._meta.verbose_name_plural),",
            "        }",
            "",
            "        # `extra_context()` would require `request` access, however `request` parameter cannot simply be",
            "        # added to `extra_context()` because  this method has been used by multiple apps without any parameters.",
            "        # Changing 'def extra context()' to 'def extra context(request)' might break current methods",
            "        # in plugins and core that either override or implement it without request.",
            "        setattr(self, \"request\", request)",
            "        context.update(self.extra_context())",
            "",
            "        return render(request, self.template_name, context)",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        return self.queryset.all()",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class ObjectEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create or edit a single object.",
            "",
            "    queryset: The base queryset for the object being modified",
            "    model_form: The form used to create or edit the object",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    template_name = \"generic/object_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        # self._permission_action is set by dispatch() to either \"add\" or \"change\" depending on whether",
            "        # we are modifying an existing object or creating a new one.",
            "        return get_permission_for_model(self.queryset.model, self._permission_action)",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by PK, name, or slug, if provided.",
            "        for field in (\"pk\", \"name\", \"slug\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "",
            "        Args:",
            "            request (HttpRequest): The current request",
            "            instance (Model): The object being edited",
            "",
            "        Returns:",
            "            (dict): Additional context data",
            "        \"\"\"",
            "        return {}",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed. For example, a parent object can be defined",
            "        # given some parameter from the request URL.",
            "        return obj",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Determine required permission based on whether we are editing an existing object",
            "        self._permission_action = \"change\" if kwargs else \"add\"",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "",
            "        initial_data = normalize_querydict(request.GET, form_class=self.model_form)",
            "        form = self.model_form(instance=obj, initial=initial_data)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "    def successful_post(self, request, obj, created, logger):",
            "        \"\"\"Callback after the form is successfully saved but before redirecting the user.\"\"\"",
            "        verb = \"Created\" if created else \"Modified\"",
            "        msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "        logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "        if hasattr(obj, \"get_absolute_url\"):",
            "            msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "        else:",
            "            msg = format_html(\"{} {}\", msg, obj)",
            "        messages.success(request, msg)",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".ObjectEditView\")",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "                self.successful_post(request, obj, object_created, logger)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete a single object.",
            "",
            "    queryset: The base queryset for the object being deleted",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get_object(self, kwargs):",
            "        \"\"\"Retrieve an object based on `kwargs`.\"\"\"",
            "        # Look up an existing object by PK, name, or slug, if provided.",
            "        for field in (\"pk\", \"name\", \"slug\"):",
            "            if field in kwargs:",
            "                return get_object_or_404(self.queryset, **{field: kwargs[field]})",
            "        return self.queryset.model()",
            "",
            "    def get(self, request, **kwargs):",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(initial=request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".ObjectDeleteView\")",
            "        obj = self.get_object(kwargs)",
            "        form = ConfirmationForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                obj.delete()",
            "            except ProtectedError as e:",
            "                logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "                handle_protectederror([obj], request, e)",
            "                return redirect(obj.get_absolute_url())",
            "",
            "            msg = f\"Deleted {self.queryset.model._meta.verbose_name} {obj}\"",
            "            logger.info(msg)",
            "            messages.success(request, msg)",
            "",
            "            return_url = form.cleaned_data.get(\"return_url\")",
            "            if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                return redirect(return_url)",
            "            else:",
            "                return redirect(self.get_return_url(request, obj))",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class BulkCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Create new objects in bulk.",
            "",
            "    queryset: Base queryset for the objects being created",
            "    form: Form class which provides the `pattern` field",
            "    model_form: The ModelForm used to create individual objects",
            "    pattern_target: Name of the field to be evaluated as a pattern (if any)",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    pattern_target = \"\"",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        # Set initial values for visible form fields from query args",
            "        initial = {}",
            "        for field in getattr(self.model_form._meta, \"fields\", []):",
            "            if request.GET.get(field):",
            "                initial[field] = request.GET[field]",
            "",
            "        form = self.form()",
            "        model_form = self.model_form(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj_type\": self.model_form._meta.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkCreateView\")",
            "        model = self.queryset.model",
            "        form = self.form(request.POST)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "            pattern = form.cleaned_data[\"pattern\"]",
            "            new_objs = []",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    # Create objects from the expanded. Abort the transaction on the first validation error.",
            "                    for value in pattern:",
            "                        # Reinstantiate the model form each time to avoid overwriting the same instance. Use a mutable",
            "                        # copy of the POST QueryDict so that we can update the target field value.",
            "                        model_form = self.model_form(request.POST.copy())",
            "                        model_form.data[self.pattern_target] = value",
            "",
            "                        # Validate each new object independently.",
            "                        if model_form.is_valid():",
            "                            obj = model_form.save()",
            "                            logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "                            new_objs.append(obj)",
            "                        else:",
            "                            # Copy any errors on the pattern target field to the pattern form.",
            "                            errors = model_form.errors.as_data()",
            "                            if errors.get(self.pattern_target):",
            "                                form.add_error(\"pattern\", errors[self.pattern_target])",
            "                            # Raise an IntegrityError to break the for loop and abort the transaction.",
            "                            raise IntegrityError()",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                    # If we make it to this point, validation has succeeded on all new objects.",
            "                    msg = f\"Added {len(new_objs)} {model._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.path)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            except IntegrityError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object creation failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"obj_type\": model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import a single object (YAML or JSON format).",
            "",
            "    queryset: Base queryset for the objects being created",
            "    model_form: The ModelForm used to create individual objects",
            "    related_object_forms: A dictionary mapping of forms to be used for the creation of related (child) objects",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    model_form = None",
            "    related_object_forms = {}",
            "    template_name = \"generic/object_import.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = ImportForm()",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".ObjectImportView\")",
            "        form = ImportForm(request.POST)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Import form validation was successful\")",
            "",
            "            # Initialize model form",
            "            data = form.cleaned_data[\"data\"]",
            "            model_form = self.model_form(data)",
            "            restrict_form_fields(model_form, request.user)",
            "",
            "            # Assign default values for any fields which were not specified. We have to do this manually because passing",
            "            # 'initial=' to the form on initialization merely sets default values for the widgets. Since widgets are not",
            "            # used for YAML/JSON import, we first bind the imported data normally, then update the form's data with the",
            "            # applicable field defaults as needed prior to form validation.",
            "            for field_name, field in model_form.fields.items():",
            "                if field_name not in data and hasattr(field, \"initial\"):",
            "                    model_form.data[field_name] = field.initial",
            "",
            "            if model_form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Save the primary object",
            "                        obj = model_form.save()",
            "",
            "                        # Enforce object-level permissions",
            "                        self.queryset.get(pk=obj.pk)",
            "",
            "                        logger.debug(f\"Created {obj} (PK: {obj.pk})\")",
            "",
            "                        # Iterate through the related object forms (if any), validating and saving each instance.",
            "                        for (",
            "                            field_name,",
            "                            related_object_form,",
            "                        ) in self.related_object_forms.items():",
            "                            logger.debug(\"Processing form for related objects: {related_object_form}\")",
            "",
            "                            related_obj_pks = []",
            "                            for i, rel_obj_data in enumerate(data.get(field_name, [])):",
            "                                f = related_object_form(obj, rel_obj_data)",
            "",
            "                                for subfield_name, field in f.fields.items():",
            "                                    if subfield_name not in rel_obj_data and hasattr(field, \"initial\"):",
            "                                        f.data[subfield_name] = field.initial",
            "",
            "                                if f.is_valid():",
            "                                    related_obj = f.save()",
            "                                    related_obj_pks.append(related_obj.pk)",
            "                                else:",
            "                                    # Replicate errors on the related object form to the primary form for display",
            "                                    for subfield_name, errors in f.errors.items():",
            "                                        for err in errors:",
            "                                            err_msg = f\"{field_name}[{i}] {subfield_name}: {err}\"",
            "                                            model_form.add_error(None, err_msg)",
            "                                    raise AbortTransaction()",
            "",
            "                            # Enforce object-level permissions on related objects",
            "                            model = related_object_form.Meta.model",
            "                            if model.objects.filter(pk__in=related_obj_pks).count() != len(related_obj_pks):",
            "                                raise ObjectDoesNotExist",
            "",
            "                except AbortTransaction:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            if not model_form.errors:",
            "                logger.info(f\"Import object {obj} (PK: {obj.pk})\")",
            "                messages.success(",
            "                    request,",
            "                    format_html('Imported object: <a href=\"{}\">{}</a>', obj.get_absolute_url(), obj),",
            "                )",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(return_url)",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            else:",
            "                logger.debug(\"Model form validation failed\")",
            "",
            "                # Replicate model form errors for display",
            "                for field, errors in model_form.errors.items():",
            "                    for err in errors:",
            "                        if field == \"__all__\":",
            "                            form.add_error(None, err)",
            "                        else:",
            "                            form.add_error(None, f\"{field}: {err}\")",
            "",
            "        else:",
            "            logger.debug(\"Import form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkImportView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Import objects in bulk (CSV format).",
            "",
            "    queryset: Base queryset for the model",
            "    table: The django-tables2 Table used to render the list of imported objects",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_import.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "        self.serializer_class = get_serializer_for_model(self.queryset.model)",
            "        self.fields = get_csv_form_fields_from_serializer_class(self.serializer_class)",
            "        self.required_field_names = [",
            "            field[\"name\"]",
            "            for field in get_csv_form_fields_from_serializer_class(self.serializer_class)",
            "            if field[\"required\"]",
            "        ]",
            "",
            "    def _import_form(self, *args, **kwargs):",
            "        class CSVImportForm(BootstrapMixin, Form):",
            "            csv_data = CSVDataField(required_field_names=self.required_field_names)",
            "            csv_file = CSVFileField()",
            "",
            "        return CSVImportForm(*args, **kwargs)",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": self._import_form(),",
            "                \"fields\": self.fields,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-data\",",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkImportView\")",
            "        new_objs = []",
            "        form = self._import_form(request.POST, request.FILES)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                # Iterate through CSV data and bind each row to a new model form instance.",
            "                with transaction.atomic():",
            "                    if request.FILES:",
            "                        field_name = \"csv_file\"",
            "                    else:",
            "                        field_name = \"csv_data\"",
            "                    csvtext = form.cleaned_data[field_name]",
            "",
            "                    try:",
            "                        data = NautobotCSVParser().parse(",
            "                            stream=BytesIO(csvtext.encode(\"utf-8\")),",
            "                            parser_context={\"request\": request, \"serializer_class\": self.serializer_class},",
            "                        )",
            "                        serializer = self.serializer_class(data=data, context={\"request\": request}, many=True)",
            "                        if serializer.is_valid():",
            "                            new_objs = serializer.save()",
            "                        else:",
            "                            for row, errors in enumerate(serializer.errors, start=1):",
            "                                for field, err in errors.items():",
            "                                    form.add_error(field_name, f\"Row {row}: {field}: {err[0]}\")",
            "                            raise ValidationError(\"\")",
            "                    except ParseError as exc:",
            "                        form.add_error(None, str(exc))",
            "                        raise ValidationError(\"\")",
            "",
            "                    # Enforce object-level permissions",
            "                    if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                        raise ObjectDoesNotExist",
            "",
            "                # Compile a table containing the imported objects",
            "                obj_table = self.table(new_objs)",
            "",
            "                if new_objs:",
            "                    msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return render(",
            "                        request,",
            "                        \"import_success.html\",",
            "                        {",
            "                            \"table\": obj_table,",
            "                            \"return_url\": self.get_return_url(request),",
            "                        },",
            "                    )",
            "",
            "            except ValidationError:",
            "                pass",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object import failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"fields\": self.fields,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"active_tab\": \"csv-file\" if form.has_error(\"csv_file\") else \"csv-data\",",
            "            },",
            "        )",
            "",
            "",
            "class BulkEditView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Edit objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being edited",
            "    form: The form class used to edit objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_edit.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # Allow views to add extra info to an object before it is processed.",
            "        # For example, a parent object can be defined given some parameter from the request URL.",
            "        return obj",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".BulkEditView\")",
            "        model = self.queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = list(self.filterset(request.GET, model.objects.only(\"pk\")).qs.values_list(\"pk\", flat=True))",
            "            else:",
            "                pk_list = list(model.objects.all().values_list(\"pk\", flat=True))",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        if \"_apply\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "                form_custom_fields = getattr(form, \"custom_fields\", [])",
            "                form_relationships = getattr(form, \"relationships\", [])",
            "                standard_fields = [",
            "                    field",
            "                    for field in form.fields",
            "                    if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "                ]",
            "                nullified_fields = request.POST.getlist(\"_nullify\")",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        updated_objects = []",
            "                        for obj in self.queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                            obj = self.alter_obj(obj, request, [], kwargs)",
            "",
            "                            # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                            for name in standard_fields:",
            "                                try:",
            "                                    model_field = model._meta.get_field(name)",
            "                                except FieldDoesNotExist:",
            "                                    # This form field is used to modify a field rather than set its value directly",
            "                                    model_field = None",
            "",
            "                                # Handle nullification",
            "                                if name in form.nullable_fields and name in nullified_fields:",
            "                                    if isinstance(model_field, ManyToManyField):",
            "                                        getattr(obj, name).set([])",
            "                                    else:",
            "                                        setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "",
            "                                # ManyToManyFields",
            "                                elif isinstance(model_field, ManyToManyField):",
            "                                    if form.cleaned_data[name]:",
            "                                        getattr(obj, name).set(form.cleaned_data[name])",
            "                                # Normal fields",
            "                                elif form.cleaned_data[name] not in (None, \"\"):",
            "                                    setattr(obj, name, form.cleaned_data[name])",
            "",
            "                            # Update custom fields",
            "                            for field_name in form_custom_fields:",
            "                                if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                                    obj.cf[remove_prefix_from_cf_key(field_name)] = None",
            "                                elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                                    obj.cf[remove_prefix_from_cf_key(field_name)] = form.cleaned_data[field_name]",
            "",
            "                            obj.full_clean()",
            "                            obj.save()",
            "                            updated_objects.append(obj)",
            "                            logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                            # Add/remove tags",
            "                            if form.cleaned_data.get(\"add_tags\", None):",
            "                                obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                            if form.cleaned_data.get(\"remove_tags\", None):",
            "                                obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                            if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                                # Add/remove relationship associations",
            "                                form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                                form.save_note(instance=obj, user=request.user)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(",
            "                            updated_objects",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    if updated_objects:",
            "                        msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "                        logger.info(msg)",
            "                        messages.success(self.request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                except ValidationError as e:",
            "                    messages.error(self.request, f\"{obj} failed validation: {e}\")",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            # Include the PK list as initial data for the form",
            "            initial_data = {\"pk\": pk_list}",
            "",
            "            # Check for other contextual data needed for the form. We avoid passing all of request.GET because the",
            "            # filter values will conflict with the bulk edit form fields.",
            "            # TODO: Find a better way to accomplish this",
            "            if \"device\" in request.GET:",
            "                initial_data[\"device\"] = request.GET.get(\"device\")",
            "            elif \"device_type\" in request.GET:",
            "                initial_data[\"device_type\"] = request.GET.get(\"device_type\")",
            "",
            "            form = self.form(model, initial=initial_data)",
            "            restrict_form_fields(form, request.user)",
            "",
            "        # Retrieve objects being edited",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(request, f\"No {model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"table\": table,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "",
            "class BulkRenameView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    An extendable view for renaming objects in bulk.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    template_name = \"generic/object_bulk_rename.html\"",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        super().__init__(*args, **kwargs)",
            "",
            "        # Create a new Form class from BulkRenameForm",
            "        class _Form(BulkRenameForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput())",
            "",
            "        self.form = _Form",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"change\")",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkRenameView\")",
            "        query_pks = request.POST.getlist(\"pk\")",
            "        selected_objects = self.queryset.filter(pk__in=query_pks) if query_pks else None",
            "",
            "        # selected_objects would return False; if no query_pks or invalid query_pks",
            "        if not selected_objects:",
            "            messages.warning(request, f\"No valid {self.queryset.model._meta.verbose_name_plural} were selected.\")",
            "            return redirect(self.get_return_url(request))",
            "",
            "        if \"_preview\" in request.POST or \"_apply\" in request.POST:",
            "            form = self.form(request.POST, initial={\"pk\": query_pks})",
            "            if form.is_valid():",
            "                try:",
            "                    with transaction.atomic():",
            "                        renamed_pks = []",
            "                        for obj in selected_objects:",
            "                            find = form.cleaned_data[\"find\"]",
            "                            replace = form.cleaned_data[\"replace\"]",
            "                            if form.cleaned_data[\"use_regex\"]:",
            "                                try:",
            "                                    obj.new_name = re.sub(find, replace, obj.name)",
            "                                # Catch regex group reference errors",
            "                                except re.error:",
            "                                    obj.new_name = obj.name",
            "                            else:",
            "                                obj.new_name = obj.name.replace(find, replace)",
            "                            renamed_pks.append(obj.pk)",
            "",
            "                        if \"_apply\" in request.POST:",
            "                            for obj in selected_objects:",
            "                                obj.name = obj.new_name",
            "                                obj.save()",
            "",
            "                            # Enforce constrained permissions",
            "                            if self.queryset.filter(pk__in=renamed_pks).count() != len(selected_objects):",
            "                                raise ObjectDoesNotExist",
            "",
            "                            messages.success(",
            "                                request,",
            "                                f\"Renamed {len(selected_objects)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                            )",
            "                            return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Object update failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        else:",
            "            form = self.form(initial={\"pk\": query_pks})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"obj_type_plural\": self.queryset.model._meta.verbose_name_plural,",
            "                \"selected_objects\": selected_objects,",
            "                \"return_url\": self.get_return_url(request),",
            "                \"parent_name\": self.get_selected_objects_parents_name(selected_objects),",
            "            },",
            "        )",
            "",
            "    def get_selected_objects_parents_name(self, selected_objects):",
            "        \"\"\"",
            "        Return selected_objects parent name.",
            "",
            "        This method is intended to be overridden by child classes to return the parent name of the selected objects.",
            "",
            "        Args:",
            "            selected_objects (list[BaseModel]): The objects being renamed",
            "",
            "        Returns:",
            "            (str): The parent name of the selected objects",
            "        \"\"\"",
            "",
            "        return \"\"",
            "",
            "",
            "class BulkDeleteView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Delete objects in bulk.",
            "",
            "    queryset: Custom queryset to use when retrieving objects (e.g. to select related objects)",
            "    filter: FilterSet to apply when deleting by QuerySet",
            "    table: The table used to display devices being deleted",
            "    form: The form class used to delete objects in bulk",
            "    template_name: The name of the template",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    filterset = None",
            "    table = None",
            "    form = None",
            "    template_name = \"generic/object_bulk_delete.html\"",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"delete\")",
            "",
            "    def get(self, request):",
            "        return redirect(self.get_return_url(request))",
            "",
            "    def post(self, request, **kwargs):",
            "        logger = logging.getLogger(__name__ + \".BulkDeleteView\")",
            "        model = self.queryset.model",
            "",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            if self.filterset is not None:",
            "                pk_list = list(self.filterset(request.GET, model.objects.only(\"pk\")).qs.values_list(\"pk\", flat=True))",
            "            else:",
            "                pk_list = list(model.objects.all().values_list(\"pk\", flat=True))",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        form_cls = self.get_form()",
            "",
            "        if \"_confirm\" in request.POST:",
            "            form = form_cls(request.POST)",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                # Delete objects",
            "                queryset = self.queryset.filter(pk__in=pk_list)",
            "",
            "                self.perform_pre_delete(request, queryset)",
            "                try:",
            "                    _, deleted_info = queryset.delete()",
            "                    deleted_count = deleted_info[model._meta.label]",
            "                except ProtectedError as e:",
            "                    logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "                    handle_protectederror(queryset, request, e)",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                logger.info(msg)",
            "                messages.success(request, msg)",
            "                return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = form_cls(",
            "                initial={",
            "                    \"pk\": pk_list,",
            "                    \"return_url\": self.get_return_url(request),",
            "                }",
            "            )",
            "",
            "        # Retrieve objects being deleted",
            "        table = self.table(self.queryset.filter(pk__in=pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        context = {",
            "            \"form\": form,",
            "            \"obj_type_plural\": model._meta.verbose_name_plural,",
            "            \"table\": table,",
            "            \"return_url\": self.get_return_url(request),",
            "        }",
            "        context.update(self.extra_context())",
            "        return render(request, self.template_name, context)",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        pass",
            "",
            "    def extra_context(self):",
            "        return {}",
            "",
            "    def get_form(self):",
            "        \"\"\"",
            "        Provide a standard bulk delete form if none has been specified for the view",
            "        \"\"\"",
            "",
            "        class BulkDeleteForm(ConfirmationForm):",
            "            pk = ModelMultipleChoiceField(queryset=self.queryset, widget=MultipleHiddenInput)",
            "",
            "        if self.form:",
            "            return self.form",
            "",
            "        return BulkDeleteForm",
            "",
            "",
            "#",
            "# Device/VirtualMachine components",
            "#",
            "",
            "",
            "# TODO: Replace with BulkCreateView",
            "class ComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a Device or VirtualMachine.",
            "    \"\"\"",
            "",
            "    queryset = None",
            "    form = None",
            "    model_form = None",
            "    template_name = None",
            "",
            "    def get_required_permission(self):",
            "        return get_permission_for_model(self.queryset.model, \"add\")",
            "",
            "    def get(self, request):",
            "        form = self.form(initial=request.GET)",
            "        model_form = self.model_form(request.GET)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"model_form\": model_form,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".ComponentCreateView\")",
            "        form = self.form(request.POST, initial=request.GET)",
            "        model_form = self.model_form(request.POST)",
            "",
            "        if form.is_valid():",
            "            new_components = []",
            "            data = deepcopy(request.POST)",
            "",
            "            names = form.cleaned_data[\"name_pattern\"]",
            "            labels = form.cleaned_data.get(\"label_pattern\")",
            "            for i, name in enumerate(names):",
            "                label = labels[i] if labels else None",
            "                # Initialize the individual component form",
            "                data[\"name\"] = name",
            "                data[\"label\"] = label",
            "                if hasattr(form, \"get_iterative_data\"):",
            "                    data.update(form.get_iterative_data(i))",
            "                component_form = self.model_form(data)",
            "",
            "                if component_form.is_valid():",
            "                    new_components.append(component_form)",
            "                else:",
            "                    for field, errors in component_form.errors.as_data().items():",
            "                        # Assign errors on the child form's name/label field to name_pattern/label_pattern on the parent form",
            "                        if field == \"name\":",
            "                            field = \"name_pattern\"",
            "                        elif field == \"label\":",
            "                            field = \"label_pattern\"",
            "                        for e in errors:",
            "                            err_str = \", \".join(e)",
            "                            form.add_error(field, f\"{name}: {err_str}\")",
            "",
            "            if not form.errors:",
            "                try:",
            "                    with transaction.atomic():",
            "                        # Create the new components",
            "                        new_objs = []",
            "                        for component_form in new_components:",
            "                            obj = component_form.save()",
            "                            new_objs.append(obj)",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                            raise ObjectDoesNotExist",
            "",
            "                    messages.success(",
            "                        request,",
            "                        f\"Added {len(new_components)} {self.queryset.model._meta.verbose_name_plural}\",",
            "                    )",
            "                    if \"_addanother\" in request.POST:",
            "                        return redirect(request.get_full_path())",
            "                    else:",
            "                        return redirect(self.get_return_url(request))",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"component_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"model_form\": model_form,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )",
            "",
            "",
            "class BulkComponentCreateView(GetReturnURLMixin, ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    Add one or more components (e.g. interfaces, console ports, etc.) to a set of Devices or VirtualMachines.",
            "    \"\"\"",
            "",
            "    parent_model = None",
            "    parent_field = None",
            "    form = None",
            "    queryset = None",
            "    model_form = None",
            "    filterset = None",
            "    table = None",
            "    template_name = \"generic/object_bulk_add_component.html\"",
            "",
            "    def get_required_permission(self):",
            "        return f\"dcim.add_{self.queryset.model._meta.model_name}\"",
            "",
            "    def post(self, request):",
            "        logger = logging.getLogger(__name__ + \".BulkComponentCreateView\")",
            "        parent_model_name = self.parent_model._meta.verbose_name_plural",
            "        model_name = self.queryset.model._meta.verbose_name_plural",
            "        model = self.queryset.model",
            "",
            "        # Are we editing *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\") and self.filterset is not None:",
            "            pk_list = [obj.pk for obj in self.filterset(request.GET, self.parent_model.objects.only(\"pk\")).qs]",
            "        else:",
            "            pk_list = request.POST.getlist(\"pk\")",
            "",
            "        selected_objects = self.parent_model.objects.filter(pk__in=pk_list)",
            "        if not selected_objects:",
            "            messages.warning(",
            "                request,",
            "                f\"No {self.parent_model._meta.verbose_name_plural} were selected.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        table = self.table(selected_objects)",
            "",
            "        if \"_create\" in request.POST:",
            "            form = self.form(model, request.POST)",
            "",
            "            if form.is_valid():",
            "                logger.debug(\"Form validation was successful\")",
            "",
            "                new_components = []",
            "                data = deepcopy(form.cleaned_data)",
            "",
            "                try:",
            "                    with transaction.atomic():",
            "                        for obj in data[\"pk\"]:",
            "                            names = data[\"name_pattern\"]",
            "                            labels = data[\"label_pattern\"] if \"label_pattern\" in data else None",
            "                            for i, name in enumerate(names):",
            "                                label = labels[i] if labels else None",
            "",
            "                                component_data = {",
            "                                    self.parent_field: obj.pk,",
            "                                    \"name\": name,",
            "                                    \"label\": label,",
            "                                }",
            "                                component_data.update(data)",
            "                                component_form = self.model_form(component_data)",
            "                                if component_form.is_valid():",
            "                                    instance = component_form.save()",
            "                                    logger.debug(f\"Created {instance} on {instance.parent}\")",
            "                                    new_components.append(instance)",
            "                                else:",
            "                                    for (",
            "                                        field,",
            "                                        errors,",
            "                                    ) in component_form.errors.as_data().items():",
            "                                        for e in errors:",
            "                                            err_str = \", \".join(e)",
            "                                            form.add_error(",
            "                                                field,",
            "                                                f\"{obj} {name}: {err_str}\",",
            "                                            )",
            "",
            "                        # Enforce object-level permissions",
            "                        if self.queryset.filter(pk__in=[obj.pk for obj in new_components]).count() != len(",
            "                            new_components",
            "                        ):",
            "                            raise ObjectDoesNotExist",
            "",
            "                except IntegrityError:",
            "                    pass",
            "",
            "                except ObjectDoesNotExist:",
            "                    msg = \"Component creation failed due to object-level permissions violation\"",
            "                    logger.debug(msg)",
            "                    form.add_error(None, msg)",
            "",
            "                if not form.errors:",
            "                    msg = f\"Added {len(new_components)} {model_name} to {len(form.cleaned_data['pk'])} {parent_model_name}.\"",
            "                    logger.info(msg)",
            "                    messages.success(request, msg)",
            "",
            "                    return redirect(self.get_return_url(request))",
            "",
            "            else:",
            "                logger.debug(\"Form validation failed\")",
            "",
            "        else:",
            "            form = self.form(model, initial={\"pk\": pk_list})",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"form\": form,",
            "                \"parent_model_name\": parent_model_name,",
            "                \"model_name\": model_name,",
            "                \"table\": table,",
            "                \"return_url\": self.get_return_url(request),",
            "            },",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": [],
            "21": [],
            "212": [
                "ObjectListView",
                "get"
            ],
            "400": [
                "ObjectEditView",
                "successful_post"
            ],
            "402": [
                "ObjectEditView",
                "successful_post"
            ],
            "403": [
                "ObjectEditView",
                "successful_post"
            ],
            "755": [
                "ObjectImportView",
                "post"
            ]
        },
        "addLocation": []
    },
    "nautobot/core/views/mixins.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from django.urls import reverse"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from django.urls.exceptions import NoReverseMatch"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from django.utils.http import is_safe_url"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.html import escape"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from django.views.generic.edit import FormView"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from rest_framework import mixins, exceptions"
            },
            "9": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": 621,
                "PatchRowcode": "             if not self.filterset.is_valid():"
            },
            "10": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": 622,
                "PatchRowcode": "                 messages.error("
            },
            "11": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": 623,
                "PatchRowcode": "                     self.request,"
            },
            "12": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    mark_safe(f\"Invalid filters were specified: {self.filterset.errors}\"),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+                    format_html(\"Invalid filters were specified: {}\", self.filterset.errors),"
            },
            "14": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": 625,
                "PatchRowcode": "                 )"
            },
            "15": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": 626,
                "PatchRowcode": "                 queryset = queryset.none()"
            },
            "16": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 627,
                "PatchRowcode": "         return queryset"
            },
            "17": {
                "beforePatchRowNumber": 748,
                "afterPatchRowNumber": 747,
                "PatchRowcode": "             msg = f'{\"Created\" if object_created else \"Modified\"} {queryset.model._meta.verbose_name}'"
            },
            "18": {
                "beforePatchRowNumber": 749,
                "afterPatchRowNumber": 748,
                "PatchRowcode": "             self.logger.info(f\"{msg} {obj} (PK: {obj.pk})\")"
            },
            "19": {
                "beforePatchRowNumber": 750,
                "afterPatchRowNumber": 749,
                "PatchRowcode": "             if hasattr(obj, \"get_absolute_url\"):"
            },
            "20": {
                "beforePatchRowNumber": 751,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 750,
                "PatchRowcode": "+                msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)"
            },
            "22": {
                "beforePatchRowNumber": 752,
                "afterPatchRowNumber": 751,
                "PatchRowcode": "             else:"
            },
            "23": {
                "beforePatchRowNumber": 753,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                msg = f\"{msg} { escape(obj)}\""
            },
            "24": {
                "beforePatchRowNumber": 754,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            messages.success(request, mark_safe(msg))"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 752,
                "PatchRowcode": "+                msg = format_html(\"{} {}\", msg, obj)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 753,
                "PatchRowcode": "+            messages.success(request, msg)"
            },
            "27": {
                "beforePatchRowNumber": 755,
                "afterPatchRowNumber": 754,
                "PatchRowcode": "             if \"_addanother\" in request.POST:"
            },
            "28": {
                "beforePatchRowNumber": 756,
                "afterPatchRowNumber": 755,
                "PatchRowcode": "                 # If the object has clone_fields, pre-populate a new instance of the form"
            },
            "29": {
                "beforePatchRowNumber": 757,
                "afterPatchRowNumber": 756,
                "PatchRowcode": "                 if hasattr(obj, \"clone_fields\"):"
            }
        },
        "frontPatchFile": [
            "from io import BytesIO",
            "import logging",
            "",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.auth.mixins import AccessMixin",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ImproperlyConfigured,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput",
            "from django.http import HttpResponse",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.loader import select_template, TemplateDoesNotExist",
            "from django.urls import reverse",
            "from django.urls.exceptions import NoReverseMatch",
            "from django.utils.http import is_safe_url",
            "from django.utils.html import escape",
            "from django.utils.safestring import mark_safe",
            "from django.views.generic.edit import FormView",
            "",
            "from rest_framework import mixins, exceptions",
            "from rest_framework.decorators import action as drf_action",
            "from rest_framework.parsers import FormParser, MultiPartParser",
            "from rest_framework.response import Response",
            "from rest_framework.viewsets import GenericViewSet",
            "",
            "from drf_spectacular.utils import extend_schema",
            "",
            "from nautobot.core.api.parsers import NautobotCSVParser",
            "from nautobot.core.api.views import BulkDestroyModelMixin, BulkUpdateModelMixin",
            "from nautobot.core.forms import (",
            "    BootstrapMixin,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.core.utils import lookup, permissions",
            "from nautobot.core.views.renderers import NautobotHTMLRenderer",
            "from nautobot.core.utils.requests import get_filterable_params_from_filter_params",
            "from nautobot.core.views.utils import (",
            "    get_csv_form_fields_from_serializer_class,",
            "    handle_protectederror,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.extras.models import ExportTemplate",
            "from nautobot.extras.forms import NoteForm",
            "from nautobot.extras.tables import ObjectChangeTable, NoteTable",
            "from nautobot.extras.utils import remove_prefix_from_cf_key",
            "",
            "PERMISSIONS_ACTION_MAP = {",
            "    \"list\": \"view\",",
            "    \"retrieve\": \"view\",",
            "    \"destroy\": \"delete\",",
            "    \"create\": \"add\",",
            "    \"update\": \"change\",",
            "    \"bulk_create\": \"add\",",
            "    \"bulk_destroy\": \"delete\",",
            "    \"bulk_update\": \"change\",",
            "    \"changelog\": \"view\",",
            "    \"notes\": \"view\",",
            "}",
            "",
            "",
            "class ContentTypePermissionRequiredMixin(AccessMixin):",
            "    \"\"\"",
            "    Similar to Django's built-in PermissionRequiredMixin, but extended to check model-level permission assignments.",
            "    This is related to ObjectPermissionRequiredMixin, except that is does not enforce object-level permissions,",
            "    and fits within Nautobot's custom permission enforcement system.",
            "",
            "    additional_permissions: An optional iterable of statically declared permissions to evaluate in addition to those",
            "                            derived from the object type",
            "    \"\"\"",
            "",
            "    additional_permissions = []",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Return the specific permission necessary to perform the requested action on an object.",
            "        \"\"\"",
            "        raise NotImplementedError(f\"{self.__class__.__name__} must implement get_required_permission()\")",
            "",
            "    def has_permission(self):",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "",
            "        # Check that the user has been granted the required permission(s).",
            "        if user.has_perms((permission_required, *self.additional_permissions)):",
            "            return True",
            "",
            "        return False",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.has_permission():",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "class AdminRequiredMixin(AccessMixin):",
            "    \"\"\"",
            "    Allows access only to admin users.",
            "    \"\"\"",
            "",
            "    def has_permission(self):",
            "        return bool(",
            "            self.request.user",
            "            and self.request.user.is_active",
            "            and (self.request.user.is_staff or self.request.user.is_superuser)",
            "        )",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.has_permission():",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "class ObjectPermissionRequiredMixin(AccessMixin):",
            "    \"\"\"",
            "    Similar to Django's built-in PermissionRequiredMixin, but extended to check for both model-level and object-level",
            "    permission assignments. If the user has only object-level permissions assigned, the view's queryset is filtered",
            "    to return only those objects on which the user is permitted to perform the specified action.",
            "",
            "    additional_permissions: An optional iterable of statically declared permissions to evaluate in addition to those",
            "                            derived from the object type",
            "    \"\"\"",
            "",
            "    additional_permissions = []",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Return the specific permission necessary to perform the requested action on an object.",
            "        \"\"\"",
            "        raise NotImplementedError(f\"{self.__class__.__name__} must implement get_required_permission()\")",
            "",
            "    def has_permission(self):",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "",
            "        # Check that the user has been granted the required permission(s).",
            "        if user.has_perms((permission_required, *self.additional_permissions)):",
            "            # Update the view's QuerySet to filter only the permitted objects",
            "            action = permissions.resolve_permission(permission_required)[1]",
            "            self.queryset = self.queryset.restrict(user, action)",
            "",
            "            return True",
            "",
            "        return False",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not hasattr(self, \"queryset\"):",
            "            raise ImproperlyConfigured(",
            "                (",
            "                    f\"{self.__class__.__name__} has no queryset defined. \"",
            "                    \"ObjectPermissionRequiredMixin may only be used on views which define a base queryset\"",
            "                )",
            "            )",
            "",
            "        if not self.has_permission():",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "class GetReturnURLMixin:",
            "    \"\"\"",
            "    Provides logic for determining where a user should be redirected after processing a form.",
            "    \"\"\"",
            "",
            "    default_return_url = None",
            "",
            "    def get_return_url(self, request, obj=None):",
            "        # First, see if `return_url` was specified as a query parameter or form data. Use this URL only if it's",
            "        # considered safe.",
            "        query_param = request.GET.get(\"return_url\") or request.POST.get(\"return_url\")",
            "        if query_param and is_safe_url(url=query_param, allowed_hosts=request.get_host()):",
            "            return query_param",
            "",
            "        # Next, check if the object being modified (if any) has an absolute URL.",
            "        # Note that the use of both `obj.present_in_database` and `obj.pk` is correct here because this conditional",
            "        # handles all three of the create, update, and delete operations. When Django deletes an instance",
            "        # from the DB, it sets the instance's PK field to None, regardless of the use of a UUID.",
            "        try:",
            "            if obj is not None and obj.present_in_database and obj.pk:",
            "                return obj.get_absolute_url()",
            "        except AttributeError:",
            "            # Model has no get_absolute_url() method or no reverse match",
            "            pass",
            "",
            "        # Fall back to the default URL (if specified) for the view.",
            "        if self.default_return_url is not None:",
            "            return reverse(self.default_return_url)",
            "",
            "        # Attempt to dynamically resolve the list view for the object",
            "        if hasattr(self, \"queryset\"):",
            "            try:",
            "                return reverse(lookup.get_route_for_model(self.queryset.model, \"list\"))",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        # If all else fails, return home. Ideally this should never happen.",
            "        return reverse(\"home\")",
            "",
            "",
            "@extend_schema(exclude=True)",
            "class NautobotViewSetMixin(GenericViewSet, AccessMixin, GetReturnURLMixin, FormView):",
            "    \"\"\"",
            "    NautobotViewSetMixin is an aggregation of various mixins from DRF, Django and Nautobot to acheive the desired behavior pattern for NautobotUIViewSet",
            "    \"\"\"",
            "",
            "    renderer_classes = [NautobotHTMLRenderer]",
            "    logger = logging.getLogger(__name__)",
            "    # Attributes that need to be specified: form_class, queryset, serializer_class, table_class for most mixins.",
            "    # filterset and filter_params will be initialized in filter_queryset() in ObjectListViewMixin",
            "    filter_params = None",
            "    filterset = None",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    form_class = None",
            "    create_form_class = None",
            "    update_form_class = None",
            "    parser_classes = [FormParser, MultiPartParser]",
            "    queryset = None",
            "    # serializer_class has to be specified to eliminate the need to override retrieve() in the RetrieveModelMixin for now.",
            "    serializer_class = None",
            "    table_class = None",
            "    notes_form_class = NoteForm",
            "",
            "    def get_permissions_for_model(self, model, actions):",
            "        \"\"\"",
            "        Resolve the named permissions for a given model (or instance) and a list of actions (e.g. view or add).",
            "",
            "        :param model: A model or instance",
            "        :param actions: A list of actions to perform on the model",
            "        \"\"\"",
            "        model_permissions = []",
            "        for action in actions:",
            "            if action not in (\"view\", \"add\", \"change\", \"delete\"):",
            "                raise ValueError(f\"Unsupported action: {action}\")",
            "            model_permissions.append(f\"{model._meta.app_label}.{action}_{model._meta.model_name}\")",
            "        return model_permissions",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Obtain the permissions needed to perform certain actions on a model.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        try:",
            "            actions = [PERMISSIONS_ACTION_MAP[self.action]]",
            "        except KeyError:",
            "            messages.error(",
            "                self.request,",
            "                \"This action is not permitted. Please use the buttons at the bottom of the table for Bulk Delete and Bulk Update\",",
            "            )",
            "        return self.get_permissions_for_model(queryset.model, actions)",
            "",
            "    def check_permissions(self, request):",
            "        \"\"\"",
            "        Check whether the user has the permissions needed to perform certain actions.",
            "        \"\"\"",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "        # Check that the user has been granted the required permission(s) one by one.",
            "        # In case the permission has `message` or `code`` attribute, we want to include those information in the permission_denied error.",
            "        for permission in permission_required:",
            "            # If the user does not have the permission required, we raise DRF's `NotAuthenticated` or `PermissionDenied` exception",
            "            # which will be handled by self.handle_no_permission() in the UI appropriately in the dispatch() method",
            "            # Cast permission to a list since has_perms() takes a list type parameter.",
            "            if not user.has_perms([permission]):",
            "                self.permission_denied(",
            "                    request,",
            "                    message=getattr(permission, \"message\", None),",
            "                    code=getattr(permission, \"code\", None),",
            "                )",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Override the default dispatch() method to check permissions first.",
            "        Used to determine whether the user has permissions to a view and object-level permissions.",
            "        Using AccessMixin handle_no_permission() to deal with Object-Level permissions and API-Level permissions in one pass.",
            "        \"\"\"",
            "        # self.initialize_request() converts a WSGI request and returns an API request object which can be passed into self.check_permissions()",
            "        # If the user is not authenticated or does not have the permission to perform certain actions,",
            "        # DRF NotAuthenticated or PermissionDenied exception can be raised appropriately and handled by self.handle_no_permission() in the UI.",
            "        # initialize_request() also instantiates self.action which is needed for permission checks.",
            "        api_request = self.initialize_request(request, *args, **kwargs)",
            "        try:",
            "            self.check_permissions(api_request)",
            "        # check_permissions() could raise NotAuthenticated and PermissionDenied Error.",
            "        # We handle them by a single except statement since self.handle_no_permission() is able to handle both errors",
            "        except (exceptions.NotAuthenticated, exceptions.PermissionDenied):",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_table_class(self):",
            "        # Check if self.table_class is specified in the ModelViewSet before performing subsequent actions",
            "        # If not, display an error message",
            "        if self.action == \"notes\":",
            "            return NoteTable",
            "        elif self.action == \"changelog\":",
            "            return ObjectChangeTable",
            "",
            "        assert (",
            "            self.table_class is not None",
            "        ), f\"'{self.__class__.__name__}' should include a `table_class` attribute for bulk operations\"",
            "",
            "        return self.table_class",
            "",
            "    def _process_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_destroy_form() is not implemented\")",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy objects after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_destroy_form() is not implemented\")",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_create_or_update_form() is not implemented\")",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to edit objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_update_form() is not implemented\")",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        \"\"\"",
            "        Helper method to create objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_create_form() is not implemented\")",
            "",
            "    def _handle_object_does_not_exist(self, form):",
            "        msg = \"Object import failed due to object-level permissions violation\"",
            "        self.logger.debug(msg)",
            "        self.has_error = True",
            "        form.add_error(None, msg)",
            "        return form",
            "",
            "    def _handle_not_implemented_error(self):",
            "        # Blanket handler for NotImplementedError raised by form helper functions",
            "        msg = \"Please provide the appropriate mixin before using this helper function\"",
            "        messages.error(self.request, msg)",
            "        self.has_error = True",
            "",
            "    def _handle_validation_error(self, e):",
            "        # For bulk_create/bulk_update view, self.obj is not set since there are multiple",
            "        # The errors will be rendered on the form itself.",
            "        if self.action not in [\"bulk_create\", \"bulk_update\"]:",
            "            messages.error(self.request, f\"{self.obj} failed validation: {e}\")",
            "        self.has_error = True",
            "",
            "    def form_valid(self, form):",
            "        \"\"\"",
            "        Handle valid forms and redirect to success_url.",
            "        \"\"\"",
            "        request = self.request",
            "        self.has_error = False",
            "        queryset = self.get_queryset()",
            "        try:",
            "            if self.action == \"destroy\":",
            "                self._process_destroy_form(form)",
            "            elif self.action == \"bulk_destroy\":",
            "                self._process_bulk_destroy_form(form)",
            "            elif self.action in [\"create\", \"update\"]:",
            "                self._process_create_or_update_form(form)",
            "            elif self.action == \"bulk_update\":",
            "                self._process_bulk_update_form(form)",
            "            elif self.action == \"bulk_create\":",
            "                self.obj_table = self._process_bulk_create_form(form)",
            "        except ValidationError as e:",
            "            self._handle_validation_error(e)",
            "        except ObjectDoesNotExist:",
            "            form = self._handle_object_does_not_exist(form)",
            "        except NotImplementedError:",
            "            self._handle_not_implemented_error()",
            "",
            "        if not self.has_error:",
            "            self.logger.debug(\"Form validation was successful\")",
            "            if self.action == \"bulk_create\":",
            "                return Response(",
            "                    {",
            "                        \"table\": self.obj_table,",
            "                        \"template\": \"import_success.html\",",
            "                    }",
            "                )",
            "            return super().form_valid(form)",
            "        else:",
            "            # render the form with the error message.",
            "            data = {}",
            "            if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "                pk_list = self.pk_list",
            "                table_class = self.get_table_class()",
            "                table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "                if not table.rows:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                    )",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                data.update({\"table\": table})",
            "            data.update({\"form\": form})",
            "            return Response(data)",
            "",
            "    def form_invalid(self, form):",
            "        \"\"\"",
            "        Handle invalid forms.",
            "        \"\"\"",
            "        data = {}",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "            pk_list = self.pk_list",
            "            table_class = self.get_table_class()",
            "            table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "            if not table.rows:",
            "                messages.warning(",
            "                    request,",
            "                    f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                )",
            "                return redirect(self.get_return_url(request))",
            "",
            "            data = {",
            "                \"table\": table,",
            "            }",
            "        data.update({\"form\": form})",
            "        return Response(data)",
            "",
            "    def get_object(self):",
            "        \"\"\"",
            "        Returns the object the view is displaying.",
            "        You may want to override this if you need to provide non-standard",
            "        queryset lookups.  Eg if objects are referenced using multiple",
            "        keyword arguments in the url conf.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        # Perform the lookup filtering.",
            "        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field",
            "        if lookup_url_kwarg not in self.kwargs:",
            "            return queryset.model()",
            "        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}",
            "        obj = get_object_or_404(queryset, **filter_kwargs)",
            "",
            "        return obj",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset_class())",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Get the list of items for this view.",
            "        This must be an iterable, and may be a queryset.",
            "        Defaults to using `self.queryset`.",
            "        This method should always be used rather than accessing `self.queryset`",
            "        directly, as `self.queryset` gets evaluated only once, and those results",
            "        are cached for all subsequent requests.",
            "        Override the original `get_queryset()` to apply permission specific to the user and action.",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        return queryset.restrict(self.request.user, PERMISSIONS_ACTION_MAP[self.action])",
            "",
            "    def get_extra_context(self, request, instance=None):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "        request: The current request",
            "        instance: The object being viewed",
            "        \"\"\"",
            "        return {}",
            "",
            "    def get_template_name(self):",
            "        # Use \"<app>/<model>_<action> if available, else fall back to generic templates",
            "        queryset = self.get_queryset()",
            "        model_opts = queryset.model._meta",
            "        app_label = model_opts.app_label",
            "        action = self.action",
            "",
            "        try:",
            "            template_name = f\"{app_label}/{model_opts.model_name}_{action}.html\"",
            "            select_template([template_name])",
            "        except TemplateDoesNotExist:",
            "            try:",
            "                if action == \"create\":",
            "                    # When the action is `create`, try {object}_update.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_create.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_update.html\"",
            "                    select_template([template_name])",
            "                elif action == \"update\":",
            "                    # When the action is `update`, try {object}_create.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_update.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_create.html\"",
            "                    select_template([template_name])",
            "                else:",
            "                    # No special case fallback, fall back to generic/object_{action}.html",
            "                    raise TemplateDoesNotExist(\"\")",
            "            except TemplateDoesNotExist:",
            "                template_name = f\"generic/object_{action}.html\"",
            "        return template_name",
            "",
            "    def get_form(self, *args, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form for different views if specified.",
            "        If not, return instantiated form using form_class.",
            "        \"\"\"",
            "        form = getattr(self, f\"{self.action}_form\", None)",
            "        if not form:",
            "            form_class = self.get_form_class()",
            "            if not form_class:",
            "                self.logger.debug(f\"{self.action}_form_class is not defined\")",
            "                return None",
            "            form = form_class(*args, **kwargs)",
            "        return form",
            "",
            "    def get_form_class(self, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form_class for different views.",
            "        \"\"\"",
            "",
            "        if self.action in [\"create\", \"update\"]:",
            "            if getattr(self, f\"{self.action}_form_class\"):",
            "                form_class = getattr(self, f\"{self.action}_form_class\")",
            "            else:",
            "                form_class = getattr(self, \"form_class\", None)",
            "        elif self.action == \"bulk_create\":",
            "            required_field_names = [",
            "                field[\"name\"]",
            "                for field in get_csv_form_fields_from_serializer_class(self.serializer_class)",
            "                if field[\"required\"]",
            "            ]",
            "",
            "            class BulkCreateForm(BootstrapMixin, Form):",
            "                csv_data = CSVDataField(required_field_names=required_field_names)",
            "                csv_file = CSVFileField()",
            "",
            "            form_class = BulkCreateForm",
            "        else:",
            "            form_class = getattr(self, f\"{self.action}_form_class\", None)",
            "",
            "        if not form_class:",
            "            if self.action == \"bulk_destroy\":",
            "                queryset = self.get_queryset()",
            "",
            "                class BulkDestroyForm(ConfirmationForm):",
            "                    pk = ModelMultipleChoiceField(queryset=queryset, widget=MultipleHiddenInput)",
            "",
            "                return BulkDestroyForm",
            "            else:",
            "                # Check for request first and then kwargs for form_class specified.",
            "                form_class = self.request.data.get(\"form_class\", None)",
            "                if not form_class:",
            "                    form_class = kwargs.get(\"form_class\", None)",
            "        return form_class",
            "",
            "    def form_save(self, form, **kwargs):",
            "        \"\"\"",
            "        Generic method to save the object from form.",
            "        Should be overriden by user if customization is needed.",
            "        \"\"\"",
            "        return form.save()",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        queryset = self.get_queryset()",
            "        return queryset.all()",
            "",
            "",
            "class ObjectDetailViewMixin(NautobotViewSetMixin, mixins.RetrieveModelMixin):",
            "    \"\"\"",
            "    UI mixin to retrieve a model instance.",
            "    \"\"\"",
            "",
            "    def retrieve(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Retrieve a model instance.",
            "        \"\"\"",
            "        instance = self.get_object()",
            "        serializer = self.get_serializer(instance)",
            "",
            "        context = serializer.data",
            "        context[\"use_new_ui\"] = True",
            "        return Response(context)",
            "",
            "",
            "class ObjectListViewMixin(NautobotViewSetMixin, mixins.ListModelMixin):",
            "    \"\"\"",
            "    UI mixin to list a model queryset",
            "    \"\"\"",
            "",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def filter_queryset(self, queryset):",
            "        \"\"\"",
            "        Filter a query with request querystrings.",
            "        \"\"\"",
            "        if self.filterset_class is not None:",
            "            self.filter_params = self.get_filter_params(self.request)",
            "            self.filterset = self.filterset_class(self.filter_params, queryset)",
            "            queryset = self.filterset.qs",
            "            if not self.filterset.is_valid():",
            "                messages.error(",
            "                    self.request,",
            "                    mark_safe(f\"Invalid filters were specified: {self.filterset.errors}\"),",
            "                )",
            "                queryset = queryset.none()",
            "        return queryset",
            "",
            "    def check_for_export(self, request, model, content_type):",
            "        # Check for export template rendering",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"nautobot_{queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        return None",
            "",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        yaml_data = [obj.to_yaml() for obj in queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def list(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        List the model instances.",
            "        \"\"\"",
            "        context = {\"use_new_ui\": True}",
            "        if \"export\" in request.GET:",
            "            queryset = self.get_queryset()",
            "            model = queryset.model",
            "            content_type = ContentType.objects.get_for_model(model)",
            "            response = self.check_for_export(request, model, content_type)",
            "            if response is not None:",
            "                return response",
            "        return Response(context)",
            "",
            "",
            "class ObjectDestroyViewMixin(NautobotViewSetMixin, mixins.DestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to destroy a model instance.",
            "    \"\"\"",
            "",
            "    destroy_form_class = ConfirmationForm",
            "",
            "    def _process_destroy_form(self, form):",
            "        request = self.request",
            "        obj = self.obj",
            "        queryset = self.get_queryset()",
            "        try:",
            "            with transaction.atomic():",
            "                obj.delete()",
            "                msg = f\"Deleted {queryset.model._meta.verbose_name} {obj}\"",
            "                self.logger.info(msg)",
            "                messages.success(request, msg)",
            "                self.success_url = self.get_return_url(request, obj)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "            handle_protectederror([obj], request, e)",
            "            self.success_url = obj.get_absolute_url()",
            "",
            "    def destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectDeleteConfirmationForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_destroy() which validates the form and perform the action of delete.",
            "        Override to add more variables to Response",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_destroy(request, **kwargs)",
            "        return Response(context)",
            "",
            "    def perform_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        Function to validate the ObjectDeleteConfirmationForm and to delete the object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectEditViewMixin(NautobotViewSetMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to create or update a model instance.",
            "    \"\"\"",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            object_created = not form.instance.present_in_database",
            "            obj = self.form_save(form)",
            "",
            "            # Check that the new object conforms with any assigned object-level permissions",
            "            queryset.get(pk=obj.pk)",
            "",
            "            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                form.save_note(instance=obj, user=request.user)",
            "",
            "            msg = f'{\"Created\" if object_created else \"Modified\"} {queryset.model._meta.verbose_name}'",
            "            self.logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "            if hasattr(obj, \"get_absolute_url\"):",
            "                msg = f'{msg} <a href=\"{obj.get_absolute_url()}\">{escape(obj)}</a>'",
            "            else:",
            "                msg = f\"{msg} { escape(obj)}\"",
            "            messages.success(request, mark_safe(msg))",
            "            if \"_addanother\" in request.POST:",
            "                # If the object has clone_fields, pre-populate a new instance of the form",
            "                if hasattr(obj, \"clone_fields\"):",
            "                    url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                    self.success_url = url",
            "                self.success_url = request.get_full_path()",
            "            else:",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    self.success_url = return_url",
            "                else:",
            "                    self.success_url = self.get_return_url(request, obj)",
            "",
            "    def create(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_create() which validates the form and perform the action of create.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_create(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's CreateModelMixin.perform_create(self, serializer) API",
            "    def perform_create(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectForm and to create a new object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    def update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectEditForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_update() which validates the form and perform the action of update/partial_update of an existing object.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_update(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's UpdateModelMixin.perform_update(self, serializer) API",
            "    def perform_update(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectEditForm and to update/partial_update an existing object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkDestroyViewMixin(NautobotViewSetMixin, BulkDestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk destroy model instances.",
            "    \"\"\"",
            "",
            "    bulk_destroy_form_class = None",
            "    filterset_class = None",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        request = self.request",
            "        pk_list = self.pk_list",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Delete objects",
            "        queryset = queryset.filter(pk__in=pk_list)",
            "",
            "        try:",
            "            with transaction.atomic():",
            "                deleted_count = queryset.delete()[1][model._meta.label]",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                self.logger.info(msg)",
            "                self.success_url = self.get_return_url(request)",
            "                messages.success(request, msg)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "            handle_protectederror(queryset, request, e)",
            "            self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_destroy().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk destroy.",
            "        \"\"\"",
            "        return self.perform_bulk_destroy(request, **kwargs)",
            "",
            "    def perform_bulk_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        request.POST \"_delete\": Function to render the user selection of objects in a table form/BulkDestroyConfirmationForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_confirm\": Function to validate the table form/BulkDestroyConfirmationForm and to perform the action of bulk destroy. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            filter_params = self.get_filter_params(request)",
            "            if not filter_params:",
            "                self.pk_list = model.objects.only(\"pk\").all().values_list(\"pk\", flat=True)",
            "            elif self.filterset_class is None:",
            "                raise NotImplementedError(\"filterset_class must be defined to use _all\")",
            "            else:",
            "                self.pk_list = self.filterset_class(filter_params, model.objects.only(\"pk\")).qs",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        form_class = self.get_form_class(**kwargs)",
            "        data = {}",
            "        if \"_confirm\" in request.POST:",
            "            form = form_class(request.POST)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectBulkCreateViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to bulk create model instances.",
            "    \"\"\"",
            "",
            "    bulk_create_active_tab = \"csv-data\"",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        # Iterate through CSV data and bind each row to a new model form instance.",
            "        new_objs = []",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            if request.FILES:",
            "                field_name = \"csv_file\"",
            "                # Set the bulk_create_active_tab to \"csv-file\"",
            "                # In case the form validation fails, the user will be redirected",
            "                # to the tab with errors rendered on the form.",
            "                self.bulk_create_active_tab = \"csv-file\"",
            "            else:",
            "                field_name = \"csv_data\"",
            "",
            "            csvtext = form.cleaned_data[field_name]",
            "            try:",
            "                data = NautobotCSVParser().parse(",
            "                    stream=BytesIO(csvtext.encode(\"utf-8\")),",
            "                    parser_context={\"request\": request, \"serializer_class\": self.serializer_class},",
            "                )",
            "                serializer = self.serializer_class(data=data, context={\"request\": request}, many=True)",
            "                if serializer.is_valid():",
            "                    new_objs = serializer.save()",
            "                else:",
            "                    for row, errors in enumerate(serializer.errors, start=1):",
            "                        for field, err in errors.items():",
            "                            form.add_error(field_name, f\"Row {row}: {field}: {err[0]}\")",
            "                    raise ValidationError(\"\")",
            "            except exceptions.ParseError as exc:",
            "                form.add_error(None, str(exc))",
            "                raise ValidationError(\"\")",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                raise ObjectDoesNotExist",
            "",
            "        # Compile a table containing the imported objects",
            "        table_class = self.get_table_class()",
            "        obj_table = table_class(new_objs)",
            "        if new_objs:",
            "            msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(request, msg)",
            "        return obj_table",
            "",
            "    def bulk_create(self, request, *args, **kwargs):",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_bulk_create(request)",
            "        return Response(context)",
            "",
            "    def perform_bulk_create(self, request):",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST, request.FILES)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkUpdateViewMixin(NautobotViewSetMixin, BulkUpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk update model instances.",
            "    \"\"\"",
            "",
            "    filterset_class = None",
            "    bulk_update_form_class = None",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        form_custom_fields = getattr(form, \"custom_fields\", [])",
            "        form_relationships = getattr(form, \"relationships\", [])",
            "        # Standard fields are those that are intrinsic to self.model in the form",
            "        # Relationships, custom fields, object_note are extrinsic fields",
            "        # PK is used to identify an existing instance, not to modify the object",
            "        standard_fields = [",
            "            field",
            "            for field in form.fields",
            "            if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "        ]",
            "        nullified_fields = request.POST.getlist(\"_nullify\")",
            "        with transaction.atomic():",
            "            updated_objects = []",
            "            for obj in queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                self.obj = obj",
            "                # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                for name in standard_fields:",
            "                    try:",
            "                        model_field = model._meta.get_field(name)",
            "                    except FieldDoesNotExist:",
            "                        # This form field is used to modify a field rather than set its value directly",
            "                        model_field = None",
            "                    # Handle nullification",
            "                    if name in form.nullable_fields and name in nullified_fields:",
            "                        if isinstance(model_field, ManyToManyField):",
            "                            getattr(obj, name).set([])",
            "                        else:",
            "                            setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "                    # ManyToManyFields",
            "                    elif isinstance(model_field, ManyToManyField):",
            "                        if form.cleaned_data[name]:",
            "                            getattr(obj, name).set(form.cleaned_data[name])",
            "                    # Normal fields",
            "                    elif form.cleaned_data[name] not in (None, \"\"):",
            "                        setattr(obj, name, form.cleaned_data[name])",
            "                # Update custom fields",
            "                for field_name in form_custom_fields:",
            "                    if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                        obj.cf[remove_prefix_from_cf_key(field_name)] = None",
            "                    elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                        obj.cf[remove_prefix_from_cf_key(field_name)] = form.cleaned_data[field_name]",
            "",
            "                obj.validated_save()",
            "                updated_objects.append(obj)",
            "                self.logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                # Add/remove tags",
            "                if form.cleaned_data.get(\"add_tags\", None):",
            "                    obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                if form.cleaned_data.get(\"remove_tags\", None):",
            "                    obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                    # Add/remove relationship associations",
            "                    form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(updated_objects):",
            "                raise ObjectDoesNotExist",
            "        if updated_objects:",
            "            msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(self.request, msg)",
            "        self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_update().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk update.",
            "        \"\"\"",
            "        return self.perform_bulk_update(request, **kwargs)",
            "",
            "    # TODO: this conflicts with BulkUpdateModelMixin.perform_bulk_update(self, objects, update_data, partial)",
            "    def perform_bulk_update(self, request, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        request.POST \"_edit\": Function to render the user selection of objects in a table form/BulkUpdateForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_apply\": Function to validate the table form/BulkUpdateForm and to perform the action of bulk update. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            filter_params = self.get_filter_params(request)",
            "            if not filter_params:",
            "                self.pk_list = model.objects.only(\"pk\").all().values_list(\"pk\", flat=True)",
            "            elif self.filterset_class is None:",
            "                raise NotImplementedError(\"filterset_class must be defined to use _all\")",
            "            else:",
            "                self.pk_list = self.filterset_class(filter_params, model.objects.only(\"pk\")).qs",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        data = {}",
            "        form_class = self.get_form_class()",
            "        if \"_apply\" in request.POST:",
            "            self.kwargs = kwargs",
            "            form = form_class(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected to update.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectChangeLogViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to list a model's changelog queryset",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def changelog(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)",
            "",
            "",
            "class ObjectNotesViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI Mixin for an Object's Notes.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def notes(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)"
        ],
        "afterPatchFile": [
            "from io import BytesIO",
            "import logging",
            "",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.contrib.auth.mixins import AccessMixin",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ImproperlyConfigured,",
            "    ObjectDoesNotExist,",
            "    ValidationError,",
            ")",
            "from django.db import transaction",
            "from django.db.models import ManyToManyField, ProtectedError",
            "from django.forms import Form, ModelMultipleChoiceField, MultipleHiddenInput",
            "from django.http import HttpResponse",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.loader import select_template, TemplateDoesNotExist",
            "from django.urls import reverse",
            "from django.urls.exceptions import NoReverseMatch",
            "from django.utils.http import is_safe_url",
            "from django.utils.html import format_html",
            "from django.views.generic.edit import FormView",
            "",
            "from rest_framework import mixins, exceptions",
            "from rest_framework.decorators import action as drf_action",
            "from rest_framework.parsers import FormParser, MultiPartParser",
            "from rest_framework.response import Response",
            "from rest_framework.viewsets import GenericViewSet",
            "",
            "from drf_spectacular.utils import extend_schema",
            "",
            "from nautobot.core.api.parsers import NautobotCSVParser",
            "from nautobot.core.api.views import BulkDestroyModelMixin, BulkUpdateModelMixin",
            "from nautobot.core.forms import (",
            "    BootstrapMixin,",
            "    ConfirmationForm,",
            "    CSVDataField,",
            "    CSVFileField,",
            "    restrict_form_fields,",
            ")",
            "from nautobot.core.utils import lookup, permissions",
            "from nautobot.core.views.renderers import NautobotHTMLRenderer",
            "from nautobot.core.utils.requests import get_filterable_params_from_filter_params",
            "from nautobot.core.views.utils import (",
            "    get_csv_form_fields_from_serializer_class,",
            "    handle_protectederror,",
            "    prepare_cloned_fields,",
            ")",
            "from nautobot.extras.models import ExportTemplate",
            "from nautobot.extras.forms import NoteForm",
            "from nautobot.extras.tables import ObjectChangeTable, NoteTable",
            "from nautobot.extras.utils import remove_prefix_from_cf_key",
            "",
            "PERMISSIONS_ACTION_MAP = {",
            "    \"list\": \"view\",",
            "    \"retrieve\": \"view\",",
            "    \"destroy\": \"delete\",",
            "    \"create\": \"add\",",
            "    \"update\": \"change\",",
            "    \"bulk_create\": \"add\",",
            "    \"bulk_destroy\": \"delete\",",
            "    \"bulk_update\": \"change\",",
            "    \"changelog\": \"view\",",
            "    \"notes\": \"view\",",
            "}",
            "",
            "",
            "class ContentTypePermissionRequiredMixin(AccessMixin):",
            "    \"\"\"",
            "    Similar to Django's built-in PermissionRequiredMixin, but extended to check model-level permission assignments.",
            "    This is related to ObjectPermissionRequiredMixin, except that is does not enforce object-level permissions,",
            "    and fits within Nautobot's custom permission enforcement system.",
            "",
            "    additional_permissions: An optional iterable of statically declared permissions to evaluate in addition to those",
            "                            derived from the object type",
            "    \"\"\"",
            "",
            "    additional_permissions = []",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Return the specific permission necessary to perform the requested action on an object.",
            "        \"\"\"",
            "        raise NotImplementedError(f\"{self.__class__.__name__} must implement get_required_permission()\")",
            "",
            "    def has_permission(self):",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "",
            "        # Check that the user has been granted the required permission(s).",
            "        if user.has_perms((permission_required, *self.additional_permissions)):",
            "            return True",
            "",
            "        return False",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.has_permission():",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "class AdminRequiredMixin(AccessMixin):",
            "    \"\"\"",
            "    Allows access only to admin users.",
            "    \"\"\"",
            "",
            "    def has_permission(self):",
            "        return bool(",
            "            self.request.user",
            "            and self.request.user.is_active",
            "            and (self.request.user.is_staff or self.request.user.is_superuser)",
            "        )",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.has_permission():",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "class ObjectPermissionRequiredMixin(AccessMixin):",
            "    \"\"\"",
            "    Similar to Django's built-in PermissionRequiredMixin, but extended to check for both model-level and object-level",
            "    permission assignments. If the user has only object-level permissions assigned, the view's queryset is filtered",
            "    to return only those objects on which the user is permitted to perform the specified action.",
            "",
            "    additional_permissions: An optional iterable of statically declared permissions to evaluate in addition to those",
            "                            derived from the object type",
            "    \"\"\"",
            "",
            "    additional_permissions = []",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Return the specific permission necessary to perform the requested action on an object.",
            "        \"\"\"",
            "        raise NotImplementedError(f\"{self.__class__.__name__} must implement get_required_permission()\")",
            "",
            "    def has_permission(self):",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "",
            "        # Check that the user has been granted the required permission(s).",
            "        if user.has_perms((permission_required, *self.additional_permissions)):",
            "            # Update the view's QuerySet to filter only the permitted objects",
            "            action = permissions.resolve_permission(permission_required)[1]",
            "            self.queryset = self.queryset.restrict(user, action)",
            "",
            "            return True",
            "",
            "        return False",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not hasattr(self, \"queryset\"):",
            "            raise ImproperlyConfigured(",
            "                (",
            "                    f\"{self.__class__.__name__} has no queryset defined. \"",
            "                    \"ObjectPermissionRequiredMixin may only be used on views which define a base queryset\"",
            "                )",
            "            )",
            "",
            "        if not self.has_permission():",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "",
            "class GetReturnURLMixin:",
            "    \"\"\"",
            "    Provides logic for determining where a user should be redirected after processing a form.",
            "    \"\"\"",
            "",
            "    default_return_url = None",
            "",
            "    def get_return_url(self, request, obj=None):",
            "        # First, see if `return_url` was specified as a query parameter or form data. Use this URL only if it's",
            "        # considered safe.",
            "        query_param = request.GET.get(\"return_url\") or request.POST.get(\"return_url\")",
            "        if query_param and is_safe_url(url=query_param, allowed_hosts=request.get_host()):",
            "            return query_param",
            "",
            "        # Next, check if the object being modified (if any) has an absolute URL.",
            "        # Note that the use of both `obj.present_in_database` and `obj.pk` is correct here because this conditional",
            "        # handles all three of the create, update, and delete operations. When Django deletes an instance",
            "        # from the DB, it sets the instance's PK field to None, regardless of the use of a UUID.",
            "        try:",
            "            if obj is not None and obj.present_in_database and obj.pk:",
            "                return obj.get_absolute_url()",
            "        except AttributeError:",
            "            # Model has no get_absolute_url() method or no reverse match",
            "            pass",
            "",
            "        # Fall back to the default URL (if specified) for the view.",
            "        if self.default_return_url is not None:",
            "            return reverse(self.default_return_url)",
            "",
            "        # Attempt to dynamically resolve the list view for the object",
            "        if hasattr(self, \"queryset\"):",
            "            try:",
            "                return reverse(lookup.get_route_for_model(self.queryset.model, \"list\"))",
            "            except NoReverseMatch:",
            "                pass",
            "",
            "        # If all else fails, return home. Ideally this should never happen.",
            "        return reverse(\"home\")",
            "",
            "",
            "@extend_schema(exclude=True)",
            "class NautobotViewSetMixin(GenericViewSet, AccessMixin, GetReturnURLMixin, FormView):",
            "    \"\"\"",
            "    NautobotViewSetMixin is an aggregation of various mixins from DRF, Django and Nautobot to acheive the desired behavior pattern for NautobotUIViewSet",
            "    \"\"\"",
            "",
            "    renderer_classes = [NautobotHTMLRenderer]",
            "    logger = logging.getLogger(__name__)",
            "    # Attributes that need to be specified: form_class, queryset, serializer_class, table_class for most mixins.",
            "    # filterset and filter_params will be initialized in filter_queryset() in ObjectListViewMixin",
            "    filter_params = None",
            "    filterset = None",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    form_class = None",
            "    create_form_class = None",
            "    update_form_class = None",
            "    parser_classes = [FormParser, MultiPartParser]",
            "    queryset = None",
            "    # serializer_class has to be specified to eliminate the need to override retrieve() in the RetrieveModelMixin for now.",
            "    serializer_class = None",
            "    table_class = None",
            "    notes_form_class = NoteForm",
            "",
            "    def get_permissions_for_model(self, model, actions):",
            "        \"\"\"",
            "        Resolve the named permissions for a given model (or instance) and a list of actions (e.g. view or add).",
            "",
            "        :param model: A model or instance",
            "        :param actions: A list of actions to perform on the model",
            "        \"\"\"",
            "        model_permissions = []",
            "        for action in actions:",
            "            if action not in (\"view\", \"add\", \"change\", \"delete\"):",
            "                raise ValueError(f\"Unsupported action: {action}\")",
            "            model_permissions.append(f\"{model._meta.app_label}.{action}_{model._meta.model_name}\")",
            "        return model_permissions",
            "",
            "    def get_required_permission(self):",
            "        \"\"\"",
            "        Obtain the permissions needed to perform certain actions on a model.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        try:",
            "            actions = [PERMISSIONS_ACTION_MAP[self.action]]",
            "        except KeyError:",
            "            messages.error(",
            "                self.request,",
            "                \"This action is not permitted. Please use the buttons at the bottom of the table for Bulk Delete and Bulk Update\",",
            "            )",
            "        return self.get_permissions_for_model(queryset.model, actions)",
            "",
            "    def check_permissions(self, request):",
            "        \"\"\"",
            "        Check whether the user has the permissions needed to perform certain actions.",
            "        \"\"\"",
            "        user = self.request.user",
            "        permission_required = self.get_required_permission()",
            "        # Check that the user has been granted the required permission(s) one by one.",
            "        # In case the permission has `message` or `code`` attribute, we want to include those information in the permission_denied error.",
            "        for permission in permission_required:",
            "            # If the user does not have the permission required, we raise DRF's `NotAuthenticated` or `PermissionDenied` exception",
            "            # which will be handled by self.handle_no_permission() in the UI appropriately in the dispatch() method",
            "            # Cast permission to a list since has_perms() takes a list type parameter.",
            "            if not user.has_perms([permission]):",
            "                self.permission_denied(",
            "                    request,",
            "                    message=getattr(permission, \"message\", None),",
            "                    code=getattr(permission, \"code\", None),",
            "                )",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Override the default dispatch() method to check permissions first.",
            "        Used to determine whether the user has permissions to a view and object-level permissions.",
            "        Using AccessMixin handle_no_permission() to deal with Object-Level permissions and API-Level permissions in one pass.",
            "        \"\"\"",
            "        # self.initialize_request() converts a WSGI request and returns an API request object which can be passed into self.check_permissions()",
            "        # If the user is not authenticated or does not have the permission to perform certain actions,",
            "        # DRF NotAuthenticated or PermissionDenied exception can be raised appropriately and handled by self.handle_no_permission() in the UI.",
            "        # initialize_request() also instantiates self.action which is needed for permission checks.",
            "        api_request = self.initialize_request(request, *args, **kwargs)",
            "        try:",
            "            self.check_permissions(api_request)",
            "        # check_permissions() could raise NotAuthenticated and PermissionDenied Error.",
            "        # We handle them by a single except statement since self.handle_no_permission() is able to handle both errors",
            "        except (exceptions.NotAuthenticated, exceptions.PermissionDenied):",
            "            return self.handle_no_permission()",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_table_class(self):",
            "        # Check if self.table_class is specified in the ModelViewSet before performing subsequent actions",
            "        # If not, display an error message",
            "        if self.action == \"notes\":",
            "            return NoteTable",
            "        elif self.action == \"changelog\":",
            "            return ObjectChangeTable",
            "",
            "        assert (",
            "            self.table_class is not None",
            "        ), f\"'{self.__class__.__name__}' should include a `table_class` attribute for bulk operations\"",
            "",
            "        return self.table_class",
            "",
            "    def _process_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_destroy_form() is not implemented\")",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        \"\"\"",
            "        Helper method to destroy objects after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_destroy_form() is not implemented\")",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_create_or_update_form() is not implemented\")",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to edit objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_update_form() is not implemented\")",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        \"\"\"",
            "        Helper method to create objects in bulk after the form is validated successfully.",
            "        \"\"\"",
            "        raise NotImplementedError(\"_process_bulk_create_form() is not implemented\")",
            "",
            "    def _handle_object_does_not_exist(self, form):",
            "        msg = \"Object import failed due to object-level permissions violation\"",
            "        self.logger.debug(msg)",
            "        self.has_error = True",
            "        form.add_error(None, msg)",
            "        return form",
            "",
            "    def _handle_not_implemented_error(self):",
            "        # Blanket handler for NotImplementedError raised by form helper functions",
            "        msg = \"Please provide the appropriate mixin before using this helper function\"",
            "        messages.error(self.request, msg)",
            "        self.has_error = True",
            "",
            "    def _handle_validation_error(self, e):",
            "        # For bulk_create/bulk_update view, self.obj is not set since there are multiple",
            "        # The errors will be rendered on the form itself.",
            "        if self.action not in [\"bulk_create\", \"bulk_update\"]:",
            "            messages.error(self.request, f\"{self.obj} failed validation: {e}\")",
            "        self.has_error = True",
            "",
            "    def form_valid(self, form):",
            "        \"\"\"",
            "        Handle valid forms and redirect to success_url.",
            "        \"\"\"",
            "        request = self.request",
            "        self.has_error = False",
            "        queryset = self.get_queryset()",
            "        try:",
            "            if self.action == \"destroy\":",
            "                self._process_destroy_form(form)",
            "            elif self.action == \"bulk_destroy\":",
            "                self._process_bulk_destroy_form(form)",
            "            elif self.action in [\"create\", \"update\"]:",
            "                self._process_create_or_update_form(form)",
            "            elif self.action == \"bulk_update\":",
            "                self._process_bulk_update_form(form)",
            "            elif self.action == \"bulk_create\":",
            "                self.obj_table = self._process_bulk_create_form(form)",
            "        except ValidationError as e:",
            "            self._handle_validation_error(e)",
            "        except ObjectDoesNotExist:",
            "            form = self._handle_object_does_not_exist(form)",
            "        except NotImplementedError:",
            "            self._handle_not_implemented_error()",
            "",
            "        if not self.has_error:",
            "            self.logger.debug(\"Form validation was successful\")",
            "            if self.action == \"bulk_create\":",
            "                return Response(",
            "                    {",
            "                        \"table\": self.obj_table,",
            "                        \"template\": \"import_success.html\",",
            "                    }",
            "                )",
            "            return super().form_valid(form)",
            "        else:",
            "            # render the form with the error message.",
            "            data = {}",
            "            if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "                pk_list = self.pk_list",
            "                table_class = self.get_table_class()",
            "                table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "                if not table.rows:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                    )",
            "                    return redirect(self.get_return_url(request))",
            "",
            "                data.update({\"table\": table})",
            "            data.update({\"form\": form})",
            "            return Response(data)",
            "",
            "    def form_invalid(self, form):",
            "        \"\"\"",
            "        Handle invalid forms.",
            "        \"\"\"",
            "        data = {}",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        if self.action in [\"bulk_update\", \"bulk_destroy\"]:",
            "            pk_list = self.pk_list",
            "            table_class = self.get_table_class()",
            "            table = table_class(queryset.filter(pk__in=pk_list), orderable=False)",
            "            if not table.rows:",
            "                messages.warning(",
            "                    request,",
            "                    f\"No {queryset.model._meta.verbose_name_plural} were selected for {self.action}.\",",
            "                )",
            "                return redirect(self.get_return_url(request))",
            "",
            "            data = {",
            "                \"table\": table,",
            "            }",
            "        data.update({\"form\": form})",
            "        return Response(data)",
            "",
            "    def get_object(self):",
            "        \"\"\"",
            "        Returns the object the view is displaying.",
            "        You may want to override this if you need to provide non-standard",
            "        queryset lookups.  Eg if objects are referenced using multiple",
            "        keyword arguments in the url conf.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        # Perform the lookup filtering.",
            "        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field",
            "        if lookup_url_kwarg not in self.kwargs:",
            "            return queryset.model()",
            "        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}",
            "        obj = get_object_or_404(queryset, **filter_kwargs)",
            "",
            "        return obj",
            "",
            "    def get_filter_params(self, request):",
            "        \"\"\"Helper function - take request.GET and discard any parameters that are not used for queryset filtering.\"\"\"",
            "        filter_params = request.GET.copy()",
            "        return get_filterable_params_from_filter_params(filter_params, self.non_filter_params, self.filterset_class())",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Get the list of items for this view.",
            "        This must be an iterable, and may be a queryset.",
            "        Defaults to using `self.queryset`.",
            "        This method should always be used rather than accessing `self.queryset`",
            "        directly, as `self.queryset` gets evaluated only once, and those results",
            "        are cached for all subsequent requests.",
            "        Override the original `get_queryset()` to apply permission specific to the user and action.",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        return queryset.restrict(self.request.user, PERMISSIONS_ACTION_MAP[self.action])",
            "",
            "    def get_extra_context(self, request, instance=None):",
            "        \"\"\"",
            "        Return any additional context data for the template.",
            "        request: The current request",
            "        instance: The object being viewed",
            "        \"\"\"",
            "        return {}",
            "",
            "    def get_template_name(self):",
            "        # Use \"<app>/<model>_<action> if available, else fall back to generic templates",
            "        queryset = self.get_queryset()",
            "        model_opts = queryset.model._meta",
            "        app_label = model_opts.app_label",
            "        action = self.action",
            "",
            "        try:",
            "            template_name = f\"{app_label}/{model_opts.model_name}_{action}.html\"",
            "            select_template([template_name])",
            "        except TemplateDoesNotExist:",
            "            try:",
            "                if action == \"create\":",
            "                    # When the action is `create`, try {object}_update.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_create.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_update.html\"",
            "                    select_template([template_name])",
            "                elif action == \"update\":",
            "                    # When the action is `update`, try {object}_create.html as a fallback",
            "                    # If both are not defined, fall back to generic/object_update.html",
            "                    template_name = f\"{app_label}/{model_opts.model_name}_create.html\"",
            "                    select_template([template_name])",
            "                else:",
            "                    # No special case fallback, fall back to generic/object_{action}.html",
            "                    raise TemplateDoesNotExist(\"\")",
            "            except TemplateDoesNotExist:",
            "                template_name = f\"generic/object_{action}.html\"",
            "        return template_name",
            "",
            "    def get_form(self, *args, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form for different views if specified.",
            "        If not, return instantiated form using form_class.",
            "        \"\"\"",
            "        form = getattr(self, f\"{self.action}_form\", None)",
            "        if not form:",
            "            form_class = self.get_form_class()",
            "            if not form_class:",
            "                self.logger.debug(f\"{self.action}_form_class is not defined\")",
            "                return None",
            "            form = form_class(*args, **kwargs)",
            "        return form",
            "",
            "    def get_form_class(self, **kwargs):",
            "        \"\"\"",
            "        Helper function to get form_class for different views.",
            "        \"\"\"",
            "",
            "        if self.action in [\"create\", \"update\"]:",
            "            if getattr(self, f\"{self.action}_form_class\"):",
            "                form_class = getattr(self, f\"{self.action}_form_class\")",
            "            else:",
            "                form_class = getattr(self, \"form_class\", None)",
            "        elif self.action == \"bulk_create\":",
            "            required_field_names = [",
            "                field[\"name\"]",
            "                for field in get_csv_form_fields_from_serializer_class(self.serializer_class)",
            "                if field[\"required\"]",
            "            ]",
            "",
            "            class BulkCreateForm(BootstrapMixin, Form):",
            "                csv_data = CSVDataField(required_field_names=required_field_names)",
            "                csv_file = CSVFileField()",
            "",
            "            form_class = BulkCreateForm",
            "        else:",
            "            form_class = getattr(self, f\"{self.action}_form_class\", None)",
            "",
            "        if not form_class:",
            "            if self.action == \"bulk_destroy\":",
            "                queryset = self.get_queryset()",
            "",
            "                class BulkDestroyForm(ConfirmationForm):",
            "                    pk = ModelMultipleChoiceField(queryset=queryset, widget=MultipleHiddenInput)",
            "",
            "                return BulkDestroyForm",
            "            else:",
            "                # Check for request first and then kwargs for form_class specified.",
            "                form_class = self.request.data.get(\"form_class\", None)",
            "                if not form_class:",
            "                    form_class = kwargs.get(\"form_class\", None)",
            "        return form_class",
            "",
            "    def form_save(self, form, **kwargs):",
            "        \"\"\"",
            "        Generic method to save the object from form.",
            "        Should be overriden by user if customization is needed.",
            "        \"\"\"",
            "        return form.save()",
            "",
            "    def alter_queryset(self, request):",
            "        # .all() is necessary to avoid caching queries",
            "        queryset = self.get_queryset()",
            "        return queryset.all()",
            "",
            "",
            "class ObjectDetailViewMixin(NautobotViewSetMixin, mixins.RetrieveModelMixin):",
            "    \"\"\"",
            "    UI mixin to retrieve a model instance.",
            "    \"\"\"",
            "",
            "    def retrieve(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Retrieve a model instance.",
            "        \"\"\"",
            "        instance = self.get_object()",
            "        serializer = self.get_serializer(instance)",
            "",
            "        context = serializer.data",
            "        context[\"use_new_ui\"] = True",
            "        return Response(context)",
            "",
            "",
            "class ObjectListViewMixin(NautobotViewSetMixin, mixins.ListModelMixin):",
            "    \"\"\"",
            "    UI mixin to list a model queryset",
            "    \"\"\"",
            "",
            "    action_buttons = (\"add\", \"import\", \"export\")",
            "    filterset_class = None",
            "    filterset_form_class = None",
            "    non_filter_params = (",
            "        \"export\",  # trigger for CSV/export-template/YAML export",
            "        \"page\",  # used by django-tables2.RequestConfig",
            "        \"per_page\",  # used by get_paginate_count",
            "        \"sort\",  # table sorting",
            "    )",
            "",
            "    def filter_queryset(self, queryset):",
            "        \"\"\"",
            "        Filter a query with request querystrings.",
            "        \"\"\"",
            "        if self.filterset_class is not None:",
            "            self.filter_params = self.get_filter_params(self.request)",
            "            self.filterset = self.filterset_class(self.filter_params, queryset)",
            "            queryset = self.filterset.qs",
            "            if not self.filterset.is_valid():",
            "                messages.error(",
            "                    self.request,",
            "                    format_html(\"Invalid filters were specified: {}\", self.filterset.errors),",
            "                )",
            "                queryset = queryset.none()",
            "        return queryset",
            "",
            "    def check_for_export(self, request, model, content_type):",
            "        # Check for export template rendering",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        if request.GET.get(\"export\"):",
            "            et = get_object_or_404(",
            "                ExportTemplate,",
            "                content_type=content_type,",
            "                name=request.GET.get(\"export\"),",
            "            )",
            "            try:",
            "                return et.render_to_response(queryset)",
            "            except Exception as e:",
            "                messages.error(",
            "                    request,",
            "                    f\"There was an error rendering the selected export template ({et.name}): {e}\",",
            "                )",
            "",
            "        # Check for YAML export support",
            "        elif \"export\" in request.GET and hasattr(model, \"to_yaml\"):",
            "            response = HttpResponse(self.queryset_to_yaml(), content_type=\"text/yaml\")",
            "            filename = f\"nautobot_{queryset.model._meta.verbose_name_plural}.yaml\"",
            "            response[\"Content-Disposition\"] = f'attachment; filename=\"{filename}\"'",
            "            return response",
            "",
            "        return None",
            "",
            "    def queryset_to_yaml(self):",
            "        \"\"\"",
            "        Export the queryset of objects as concatenated YAML documents.",
            "        \"\"\"",
            "        queryset = self.filter_queryset(self.get_queryset())",
            "        yaml_data = [obj.to_yaml() for obj in queryset]",
            "",
            "        return \"---\\n\".join(yaml_data)",
            "",
            "    def list(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        List the model instances.",
            "        \"\"\"",
            "        context = {\"use_new_ui\": True}",
            "        if \"export\" in request.GET:",
            "            queryset = self.get_queryset()",
            "            model = queryset.model",
            "            content_type = ContentType.objects.get_for_model(model)",
            "            response = self.check_for_export(request, model, content_type)",
            "            if response is not None:",
            "                return response",
            "        return Response(context)",
            "",
            "",
            "class ObjectDestroyViewMixin(NautobotViewSetMixin, mixins.DestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to destroy a model instance.",
            "    \"\"\"",
            "",
            "    destroy_form_class = ConfirmationForm",
            "",
            "    def _process_destroy_form(self, form):",
            "        request = self.request",
            "        obj = self.obj",
            "        queryset = self.get_queryset()",
            "        try:",
            "            with transaction.atomic():",
            "                obj.delete()",
            "                msg = f\"Deleted {queryset.model._meta.verbose_name} {obj}\"",
            "                self.logger.info(msg)",
            "                messages.success(request, msg)",
            "                self.success_url = self.get_return_url(request, obj)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete object\")",
            "            handle_protectederror([obj], request, e)",
            "            self.success_url = obj.get_absolute_url()",
            "",
            "    def destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectDeleteConfirmationForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_destroy() which validates the form and perform the action of delete.",
            "        Override to add more variables to Response",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_destroy(request, **kwargs)",
            "        return Response(context)",
            "",
            "    def perform_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        Function to validate the ObjectDeleteConfirmationForm and to delete the object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectEditViewMixin(NautobotViewSetMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to create or update a model instance.",
            "    \"\"\"",
            "",
            "    def _process_create_or_update_form(self, form):",
            "        \"\"\"",
            "        Helper method to create or update an object after the form is validated successfully.",
            "        \"\"\"",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            object_created = not form.instance.present_in_database",
            "            obj = self.form_save(form)",
            "",
            "            # Check that the new object conforms with any assigned object-level permissions",
            "            queryset.get(pk=obj.pk)",
            "",
            "            if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                form.save_note(instance=obj, user=request.user)",
            "",
            "            msg = f'{\"Created\" if object_created else \"Modified\"} {queryset.model._meta.verbose_name}'",
            "            self.logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "            if hasattr(obj, \"get_absolute_url\"):",
            "                msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "            else:",
            "                msg = format_html(\"{} {}\", msg, obj)",
            "            messages.success(request, msg)",
            "            if \"_addanother\" in request.POST:",
            "                # If the object has clone_fields, pre-populate a new instance of the form",
            "                if hasattr(obj, \"clone_fields\"):",
            "                    url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                    self.success_url = url",
            "                self.success_url = request.get_full_path()",
            "            else:",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if return_url is not None and is_safe_url(url=return_url, allowed_hosts=request.get_host()):",
            "                    self.success_url = return_url",
            "                else:",
            "                    self.success_url = self.get_return_url(request, obj)",
            "",
            "    def create(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_create() which validates the form and perform the action of create.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_create(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's CreateModelMixin.perform_create(self, serializer) API",
            "    def perform_create(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectForm and to create a new object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "    def update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        request.GET: render the ObjectEditForm which is passed to NautobotHTMLRenderer as Response.",
            "        request.POST: call perform_update() which validates the form and perform the action of update/partial_update of an existing object.",
            "        Override to add more variables to Response.",
            "        \"\"\"",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_update(request, *args, **kwargs)",
            "        return Response(context)",
            "",
            "    # TODO: this conflicts with DRF's UpdateModelMixin.perform_update(self, serializer) API",
            "    def perform_update(self, request, *args, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        Function to validate the ObjectEditForm and to update/partial_update an existing object.",
            "        \"\"\"",
            "        self.obj = self.get_object()",
            "        form_class = self.get_form_class()",
            "        form = form_class(data=request.POST, files=request.FILES, instance=self.obj)",
            "        restrict_form_fields(form, request.user)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkDestroyViewMixin(NautobotViewSetMixin, BulkDestroyModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk destroy model instances.",
            "    \"\"\"",
            "",
            "    bulk_destroy_form_class = None",
            "    filterset_class = None",
            "",
            "    def _process_bulk_destroy_form(self, form):",
            "        request = self.request",
            "        pk_list = self.pk_list",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Delete objects",
            "        queryset = queryset.filter(pk__in=pk_list)",
            "",
            "        try:",
            "            with transaction.atomic():",
            "                deleted_count = queryset.delete()[1][model._meta.label]",
            "                msg = f\"Deleted {deleted_count} {model._meta.verbose_name_plural}\"",
            "                self.logger.info(msg)",
            "                self.success_url = self.get_return_url(request)",
            "                messages.success(request, msg)",
            "        except ProtectedError as e:",
            "            self.logger.info(\"Caught ProtectedError while attempting to delete objects\")",
            "            handle_protectederror(queryset, request, e)",
            "            self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_destroy(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_destroy().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk destroy.",
            "        \"\"\"",
            "        return self.perform_bulk_destroy(request, **kwargs)",
            "",
            "    def perform_bulk_destroy(self, request, **kwargs):",
            "        \"\"\"",
            "        request.POST \"_delete\": Function to render the user selection of objects in a table form/BulkDestroyConfirmationForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_confirm\": Function to validate the table form/BulkDestroyConfirmationForm and to perform the action of bulk destroy. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        # Are we deleting *all* objects in the queryset or just a selected subset?",
            "        if request.POST.get(\"_all\"):",
            "            filter_params = self.get_filter_params(request)",
            "            if not filter_params:",
            "                self.pk_list = model.objects.only(\"pk\").all().values_list(\"pk\", flat=True)",
            "            elif self.filterset_class is None:",
            "                raise NotImplementedError(\"filterset_class must be defined to use _all\")",
            "            else:",
            "                self.pk_list = self.filterset_class(filter_params, model.objects.only(\"pk\")).qs",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        form_class = self.get_form_class(**kwargs)",
            "        data = {}",
            "        if \"_confirm\" in request.POST:",
            "            form = form_class(request.POST)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected for deletion.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectBulkCreateViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to bulk create model instances.",
            "    \"\"\"",
            "",
            "    bulk_create_active_tab = \"csv-data\"",
            "",
            "    def _process_bulk_create_form(self, form):",
            "        # Iterate through CSV data and bind each row to a new model form instance.",
            "        new_objs = []",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        with transaction.atomic():",
            "            if request.FILES:",
            "                field_name = \"csv_file\"",
            "                # Set the bulk_create_active_tab to \"csv-file\"",
            "                # In case the form validation fails, the user will be redirected",
            "                # to the tab with errors rendered on the form.",
            "                self.bulk_create_active_tab = \"csv-file\"",
            "            else:",
            "                field_name = \"csv_data\"",
            "",
            "            csvtext = form.cleaned_data[field_name]",
            "            try:",
            "                data = NautobotCSVParser().parse(",
            "                    stream=BytesIO(csvtext.encode(\"utf-8\")),",
            "                    parser_context={\"request\": request, \"serializer_class\": self.serializer_class},",
            "                )",
            "                serializer = self.serializer_class(data=data, context={\"request\": request}, many=True)",
            "                if serializer.is_valid():",
            "                    new_objs = serializer.save()",
            "                else:",
            "                    for row, errors in enumerate(serializer.errors, start=1):",
            "                        for field, err in errors.items():",
            "                            form.add_error(field_name, f\"Row {row}: {field}: {err[0]}\")",
            "                    raise ValidationError(\"\")",
            "            except exceptions.ParseError as exc:",
            "                form.add_error(None, str(exc))",
            "                raise ValidationError(\"\")",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in new_objs]).count() != len(new_objs):",
            "                raise ObjectDoesNotExist",
            "",
            "        # Compile a table containing the imported objects",
            "        table_class = self.get_table_class()",
            "        obj_table = table_class(new_objs)",
            "        if new_objs:",
            "            msg = f\"Imported {len(new_objs)} {new_objs[0]._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(request, msg)",
            "        return obj_table",
            "",
            "    def bulk_create(self, request, *args, **kwargs):",
            "        context = {}",
            "        if request.method == \"POST\":",
            "            return self.perform_bulk_create(request)",
            "        return Response(context)",
            "",
            "    def perform_bulk_create(self, request):",
            "        form_class = self.get_form_class()",
            "        form = form_class(request.POST, request.FILES)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        else:",
            "            return self.form_invalid(form)",
            "",
            "",
            "class ObjectBulkUpdateViewMixin(NautobotViewSetMixin, BulkUpdateModelMixin):",
            "    \"\"\"",
            "    UI mixin to bulk update model instances.",
            "    \"\"\"",
            "",
            "    filterset_class = None",
            "    bulk_update_form_class = None",
            "",
            "    def _process_bulk_update_form(self, form):",
            "        request = self.request",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "        form_custom_fields = getattr(form, \"custom_fields\", [])",
            "        form_relationships = getattr(form, \"relationships\", [])",
            "        # Standard fields are those that are intrinsic to self.model in the form",
            "        # Relationships, custom fields, object_note are extrinsic fields",
            "        # PK is used to identify an existing instance, not to modify the object",
            "        standard_fields = [",
            "            field",
            "            for field in form.fields",
            "            if field not in form_custom_fields + form_relationships + [\"pk\"] + [\"object_note\"]",
            "        ]",
            "        nullified_fields = request.POST.getlist(\"_nullify\")",
            "        with transaction.atomic():",
            "            updated_objects = []",
            "            for obj in queryset.filter(pk__in=form.cleaned_data[\"pk\"]):",
            "                self.obj = obj",
            "                # Update standard fields. If a field is listed in _nullify, delete its value.",
            "                for name in standard_fields:",
            "                    try:",
            "                        model_field = model._meta.get_field(name)",
            "                    except FieldDoesNotExist:",
            "                        # This form field is used to modify a field rather than set its value directly",
            "                        model_field = None",
            "                    # Handle nullification",
            "                    if name in form.nullable_fields and name in nullified_fields:",
            "                        if isinstance(model_field, ManyToManyField):",
            "                            getattr(obj, name).set([])",
            "                        else:",
            "                            setattr(obj, name, None if model_field is not None and model_field.null else \"\")",
            "                    # ManyToManyFields",
            "                    elif isinstance(model_field, ManyToManyField):",
            "                        if form.cleaned_data[name]:",
            "                            getattr(obj, name).set(form.cleaned_data[name])",
            "                    # Normal fields",
            "                    elif form.cleaned_data[name] not in (None, \"\"):",
            "                        setattr(obj, name, form.cleaned_data[name])",
            "                # Update custom fields",
            "                for field_name in form_custom_fields:",
            "                    if field_name in form.nullable_fields and field_name in nullified_fields:",
            "                        obj.cf[remove_prefix_from_cf_key(field_name)] = None",
            "                    elif form.cleaned_data.get(field_name) not in (None, \"\", []):",
            "                        obj.cf[remove_prefix_from_cf_key(field_name)] = form.cleaned_data[field_name]",
            "",
            "                obj.validated_save()",
            "                updated_objects.append(obj)",
            "                self.logger.debug(f\"Saved {obj} (PK: {obj.pk})\")",
            "",
            "                # Add/remove tags",
            "                if form.cleaned_data.get(\"add_tags\", None):",
            "                    obj.tags.add(*form.cleaned_data[\"add_tags\"])",
            "                if form.cleaned_data.get(\"remove_tags\", None):",
            "                    obj.tags.remove(*form.cleaned_data[\"remove_tags\"])",
            "",
            "                if hasattr(form, \"save_relationships\") and callable(form.save_relationships):",
            "                    # Add/remove relationship associations",
            "                    form.save_relationships(instance=obj, nullified_fields=nullified_fields)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "            # Enforce object-level permissions",
            "            if queryset.filter(pk__in=[obj.pk for obj in updated_objects]).count() != len(updated_objects):",
            "                raise ObjectDoesNotExist",
            "        if updated_objects:",
            "            msg = f\"Updated {len(updated_objects)} {model._meta.verbose_name_plural}\"",
            "            self.logger.info(msg)",
            "            messages.success(self.request, msg)",
            "        self.success_url = self.get_return_url(request)",
            "",
            "    def bulk_update(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Call perform_bulk_update().",
            "        The function exist to keep the DRF's get/post pattern of {action}/perform_{action}, we will need it when we transition from using forms to serializers in the UI.",
            "        User should override this function to handle any actions as needed before bulk update.",
            "        \"\"\"",
            "        return self.perform_bulk_update(request, **kwargs)",
            "",
            "    # TODO: this conflicts with BulkUpdateModelMixin.perform_bulk_update(self, objects, update_data, partial)",
            "    def perform_bulk_update(self, request, **kwargs):  # pylint: disable=arguments-differ",
            "        \"\"\"",
            "        request.POST \"_edit\": Function to render the user selection of objects in a table form/BulkUpdateForm via Response that is passed to NautobotHTMLRenderer.",
            "        request.POST \"_apply\": Function to validate the table form/BulkUpdateForm and to perform the action of bulk update. Render the form with errors if exceptions are raised.",
            "        \"\"\"",
            "        queryset = self.get_queryset()",
            "        model = queryset.model",
            "",
            "        # If we are editing *all* objects in the queryset, replace the PK list with all matched objects.",
            "        if request.POST.get(\"_all\"):",
            "            filter_params = self.get_filter_params(request)",
            "            if not filter_params:",
            "                self.pk_list = model.objects.only(\"pk\").all().values_list(\"pk\", flat=True)",
            "            elif self.filterset_class is None:",
            "                raise NotImplementedError(\"filterset_class must be defined to use _all\")",
            "            else:",
            "                self.pk_list = self.filterset_class(filter_params, model.objects.only(\"pk\")).qs",
            "        else:",
            "            self.pk_list = request.POST.getlist(\"pk\")",
            "        data = {}",
            "        form_class = self.get_form_class()",
            "        if \"_apply\" in request.POST:",
            "            self.kwargs = kwargs",
            "            form = form_class(model, request.POST)",
            "            restrict_form_fields(form, request.user)",
            "            if form.is_valid():",
            "                return self.form_valid(form)",
            "            else:",
            "                return self.form_invalid(form)",
            "        table_class = self.get_table_class()",
            "        table = table_class(queryset.filter(pk__in=self.pk_list), orderable=False)",
            "        if not table.rows:",
            "            messages.warning(",
            "                request,",
            "                f\"No {queryset.model._meta.verbose_name_plural} were selected to update.\",",
            "            )",
            "            return redirect(self.get_return_url(request))",
            "        data.update({\"table\": table})",
            "        return Response(data)",
            "",
            "",
            "class ObjectChangeLogViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI mixin to list a model's changelog queryset",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def changelog(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)",
            "",
            "",
            "class ObjectNotesViewMixin(NautobotViewSetMixin):",
            "    \"\"\"",
            "    UI Mixin for an Object's Notes.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    @drf_action(detail=True)",
            "    def notes(self, request, *args, **kwargs):",
            "        data = {",
            "            \"base_template\": self.base_template,",
            "        }",
            "        return Response(data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "23": [],
            "625": [
                "ObjectListViewMixin",
                "filter_queryset"
            ],
            "751": [
                "ObjectEditViewMixin",
                "_process_create_or_update_form"
            ],
            "753": [
                "ObjectEditViewMixin",
                "_process_create_or_update_form"
            ],
            "754": [
                "ObjectEditViewMixin",
                "_process_create_or_update_form"
            ]
        },
        "addLocation": []
    }
}