{
    "hyper_bump_it/_hyper_bump_it/cli/interactive/file_validation.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from rich.text import Text"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ... import ui"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from ... import files, ui"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from ...config import FileDefinition"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from ...error import FormatError"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from ...format_pattern import FormatContext, TextFormatter"
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     BadSearchPattern = auto()"
            },
            "9": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     BadReplacePattern = auto()"
            },
            "10": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     SearchPatternNotFound = auto()"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    ProjectRootTraversal = auto()"
            },
            "12": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " @dataclass"
            },
            "15": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def __call__(self, definition: FileDefinition) -> Optional[ValidationFailure]:"
            },
            "16": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         matched_files = list(self._project_root.glob(definition.file_glob))"
            },
            "17": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         if ("
            },
            "18": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result := self._validate_matched_files(definition, matched_files)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            result := self._validate_matched_files("
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                definition, matched_files, self._project_root"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            )"
            },
            "22": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         ) is not None:"
            },
            "23": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             return result"
            },
            "24": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         return self._check_file_contents(search_text, matched_files)"
            },
            "26": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     def _validate_matched_files("
            },
            "28": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, definition: FileDefinition, matched_files: list[Path]"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        self, definition: FileDefinition, matched_files: list[Path], project_root: Path"
            },
            "30": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     ) -> Optional[ValidationFailure]:"
            },
            "31": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         if len(matched_files) == 0:"
            },
            "32": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             return ValidationFailure("
            },
            "33": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                 )"
            },
            "34": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             )"
            },
            "35": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             return ValidationFailure(FailureType.KeystoneMultipleFiles, message)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        for file in matched_files:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+            if not files.is_contained_within(file, project_root):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                message = Text(\"Matched files must be within the project root. '\")"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                message.append(definition.file_glob, style=\"file.glob\")"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                message.append(\"' matched: '\")"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                message.append(str(file), style=\"file.path\")"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                message.append(\"'\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                return ValidationFailure(FailureType.ProjectRootTraversal, message)"
            },
            "44": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         return None"
            },
            "45": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     @staticmethod"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Validate a file definition to see if it could be used for a specific project.",
            "\"\"\"",
            "from dataclasses import dataclass",
            "from enum import Enum, auto",
            "from pathlib import Path",
            "from typing import Optional",
            "",
            "from rich.text import Text",
            "",
            "from ... import ui",
            "from ...config import FileDefinition",
            "from ...error import FormatError",
            "from ...format_pattern import FormatContext, TextFormatter",
            "from ...version import Version",
            "",
            "_FAKE_NEXT_VERSION = Version(1, 2, 3)",
            "",
            "",
            "class FailureType(Enum):",
            "    NoFiles = auto()",
            "    KeystoneMultipleFiles = auto()",
            "    BadSearchPattern = auto()",
            "    BadReplacePattern = auto()",
            "    SearchPatternNotFound = auto()",
            "",
            "",
            "@dataclass",
            "class ValidationFailure:",
            "    failure_type: FailureType",
            "    description: Text",
            "",
            "",
            "class DefinitionValidator:",
            "    def __init__(self, current_version: Version, project_root: Path) -> None:",
            "        self._project_root = project_root",
            "        self._text_formatter = TextFormatter(",
            "            current_version=current_version, new_version=_FAKE_NEXT_VERSION",
            "        )",
            "",
            "    def __call__(self, definition: FileDefinition) -> Optional[ValidationFailure]:",
            "        matched_files = list(self._project_root.glob(definition.file_glob))",
            "        if (",
            "            result := self._validate_matched_files(definition, matched_files)",
            "        ) is not None:",
            "            return result",
            "",
            "        try:",
            "            search_text = self._text_formatter.format(",
            "                definition.search_format_pattern, context=FormatContext.search",
            "            )",
            "        except FormatError as ex:",
            "            return ValidationFailure(FailureType.BadSearchPattern, Text(str(ex)))",
            "",
            "        if definition.replace_format_pattern is not None:",
            "            try:",
            "                self._text_formatter.format(",
            "                    definition.replace_format_pattern, context=FormatContext.replace",
            "                )",
            "            except FormatError as ex:",
            "                return ValidationFailure(FailureType.BadReplacePattern, Text(str(ex)))",
            "        return self._check_file_contents(search_text, matched_files)",
            "",
            "    def _validate_matched_files(",
            "        self, definition: FileDefinition, matched_files: list[Path]",
            "    ) -> Optional[ValidationFailure]:",
            "        if len(matched_files) == 0:",
            "            return ValidationFailure(",
            "                FailureType.NoFiles,",
            "                Text(\"'\")",
            "                .append(definition.file_glob, style=\"file.glob\")",
            "                .append(\"' did not match any files in the project root: \")",
            "                .append(str(self._project_root), style=\"file.path\"),",
            "            )",
            "        if definition.keystone and len(matched_files) != 1:",
            "            message = Text(\"Keystone files can only match one file. '\")",
            "            message.append(definition.file_glob, style=\"file.glob\")",
            "            message.append(\"' matched: \")",
            "            message.append_text(",
            "                ui.list_styled_values(",
            "                    (",
            "                        str(file.relative_to(self._project_root))",
            "                        for file in matched_files",
            "                    ),",
            "                    style=\"file.path\",",
            "                    quoted=True,",
            "                )",
            "            )",
            "            return ValidationFailure(FailureType.KeystoneMultipleFiles, message)",
            "        return None",
            "",
            "    @staticmethod",
            "    def _check_file_contents(",
            "        search_text: str, matched_files: list[Path]",
            "    ) -> Optional[ValidationFailure]:",
            "        for file in matched_files:",
            "            if search_text not in file.read_text():",
            "                return ValidationFailure(",
            "                    FailureType.SearchPatternNotFound,",
            "                    Text(\"The search text '\")",
            "                    .append(search_text, style=\"format.text\")",
            "                    .append(\"' was not found in matched file '\")",
            "                    .append(str(file), style=\"file.path\")",
            "                    .append(\"'\"),",
            "                )",
            "        return None"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Validate a file definition to see if it could be used for a specific project.",
            "\"\"\"",
            "from dataclasses import dataclass",
            "from enum import Enum, auto",
            "from pathlib import Path",
            "from typing import Optional",
            "",
            "from rich.text import Text",
            "",
            "from ... import files, ui",
            "from ...config import FileDefinition",
            "from ...error import FormatError",
            "from ...format_pattern import FormatContext, TextFormatter",
            "from ...version import Version",
            "",
            "_FAKE_NEXT_VERSION = Version(1, 2, 3)",
            "",
            "",
            "class FailureType(Enum):",
            "    NoFiles = auto()",
            "    KeystoneMultipleFiles = auto()",
            "    BadSearchPattern = auto()",
            "    BadReplacePattern = auto()",
            "    SearchPatternNotFound = auto()",
            "    ProjectRootTraversal = auto()",
            "",
            "",
            "@dataclass",
            "class ValidationFailure:",
            "    failure_type: FailureType",
            "    description: Text",
            "",
            "",
            "class DefinitionValidator:",
            "    def __init__(self, current_version: Version, project_root: Path) -> None:",
            "        self._project_root = project_root",
            "        self._text_formatter = TextFormatter(",
            "            current_version=current_version, new_version=_FAKE_NEXT_VERSION",
            "        )",
            "",
            "    def __call__(self, definition: FileDefinition) -> Optional[ValidationFailure]:",
            "        matched_files = list(self._project_root.glob(definition.file_glob))",
            "        if (",
            "            result := self._validate_matched_files(",
            "                definition, matched_files, self._project_root",
            "            )",
            "        ) is not None:",
            "            return result",
            "",
            "        try:",
            "            search_text = self._text_formatter.format(",
            "                definition.search_format_pattern, context=FormatContext.search",
            "            )",
            "        except FormatError as ex:",
            "            return ValidationFailure(FailureType.BadSearchPattern, Text(str(ex)))",
            "",
            "        if definition.replace_format_pattern is not None:",
            "            try:",
            "                self._text_formatter.format(",
            "                    definition.replace_format_pattern, context=FormatContext.replace",
            "                )",
            "            except FormatError as ex:",
            "                return ValidationFailure(FailureType.BadReplacePattern, Text(str(ex)))",
            "        return self._check_file_contents(search_text, matched_files)",
            "",
            "    def _validate_matched_files(",
            "        self, definition: FileDefinition, matched_files: list[Path], project_root: Path",
            "    ) -> Optional[ValidationFailure]:",
            "        if len(matched_files) == 0:",
            "            return ValidationFailure(",
            "                FailureType.NoFiles,",
            "                Text(\"'\")",
            "                .append(definition.file_glob, style=\"file.glob\")",
            "                .append(\"' did not match any files in the project root: \")",
            "                .append(str(self._project_root), style=\"file.path\"),",
            "            )",
            "        if definition.keystone and len(matched_files) != 1:",
            "            message = Text(\"Keystone files can only match one file. '\")",
            "            message.append(definition.file_glob, style=\"file.glob\")",
            "            message.append(\"' matched: \")",
            "            message.append_text(",
            "                ui.list_styled_values(",
            "                    (",
            "                        str(file.relative_to(self._project_root))",
            "                        for file in matched_files",
            "                    ),",
            "                    style=\"file.path\",",
            "                    quoted=True,",
            "                )",
            "            )",
            "            return ValidationFailure(FailureType.KeystoneMultipleFiles, message)",
            "        for file in matched_files:",
            "            if not files.is_contained_within(file, project_root):",
            "                message = Text(\"Matched files must be within the project root. '\")",
            "                message.append(definition.file_glob, style=\"file.glob\")",
            "                message.append(\"' matched: '\")",
            "                message.append(str(file), style=\"file.path\")",
            "                message.append(\"'\")",
            "                return ValidationFailure(FailureType.ProjectRootTraversal, message)",
            "        return None",
            "",
            "    @staticmethod",
            "    def _check_file_contents(",
            "        search_text: str, matched_files: list[Path]",
            "    ) -> Optional[ValidationFailure]:",
            "        for file in matched_files:",
            "            if search_text not in file.read_text():",
            "                return ValidationFailure(",
            "                    FailureType.SearchPatternNotFound,",
            "                    Text(\"The search text '\")",
            "                    .append(search_text, style=\"format.text\")",
            "                    .append(\"' was not found in matched file '\")",
            "                    .append(str(file), style=\"file.path\")",
            "                    .append(\"'\"),",
            "                )",
            "        return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "44": [
                "DefinitionValidator",
                "__call__"
            ],
            "65": [
                "DefinitionValidator",
                "_validate_matched_files"
            ]
        },
        "addLocation": []
    },
    "hyper_bump_it/_hyper_bump_it/error.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         return message"
            },
            "1": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+class PathTraversalError(BumpItError):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    def __init__(self, project_root: Path, file_glob: str, matched_file: Path) -> None:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        self.project_root = project_root"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        self.file_glob = file_glob"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        self.matched_file = matched_file"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        super().__init__("
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            f\"Matched files must be within the project root ({self.project_root}). '{self.file_glob}' matched: '{self.matched_file}'\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        )"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    def __rich__(self) -> Text:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        message = Text(\"Matched files must be within the project root (\")"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        message.append(str(self.project_root), style=\"file.path\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        message.append(\"). '\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        message.append(self.file_glob, style=\"file.glob\")"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        message.append(\"' matched: '\")"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        message.append(str(self.matched_file), style=\"file.path\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        message.append(\"'\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        return message"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " class KeystoneError(BumpItError):"
            },
            "24": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     \"\"\"Base for keystone file errors\"\"\""
            },
            "25": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Errors raised by the library.",
            "\"\"\"",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Callable, Collection, Literal, TypeVar, Union",
            "",
            "from pydantic import ValidationError",
            "from rich.text import Text",
            "",
            "from . import ui",
            "",
            "if TYPE_CHECKING:",
            "    from pydantic_core import ErrorDetails",
            "",
            "",
            "class BumpItError(Exception):",
            "    \"\"\"Base for library errors\"\"\"",
            "",
            "    def __rich__(self) -> Text:",
            "        return Text(str(self))",
            "",
            "",
            "class FormatError(BumpItError):",
            "    \"\"\"Base for formatting errors\"\"\"",
            "",
            "",
            "class FormatKeyError(FormatError):",
            "    \"\"\"Pattern referenced an invalid key\"\"\"",
            "",
            "    def __init__(self, format_pattern: str, valid_keys: Collection[str]) -> None:",
            "        self.format_pattern = format_pattern",
            "        self.valid_keys = FormatKeyError._sort_keys(valid_keys)",
            "        super().__init__(",
            "            f\"Format pattern '{self.format_pattern}' used an invalid key. \"",
            "            f\"Valid keys are: {_list_str_values(self.valid_keys)}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Format pattern '\")",
            "        message.append(self.format_pattern, style=\"invalid\")",
            "        message.append(\"' used an invalid key.\\nValid keys are: \")",
            "        message.append_text(ui.list_styled_values(self.valid_keys, \"valid\"))",
            "        return message",
            "",
            "    @staticmethod",
            "    def _sort_keys(valid_keys: Collection[str]) -> tuple[str, ...]:",
            "        \"\"\"",
            "        Re-order keys for display to the user.",
            "",
            "        The ordering first sorts by general keys, current keys, new keys.",
            "        Within each of those sections, the order is based on the order of the version parts. Any",
            "        helper keys go after the version part keys.",
            "        \"\"\"",
            "        from .format_pattern import keys  # prevents circular import",
            "",
            "        preferred_order = {",
            "            keys.VERSION: 0,",
            "            keys.MAJOR: 1,",
            "            keys.MINOR: 2,",
            "            keys.PATCH: 3,",
            "            keys.PRERELEASE: 4,",
            "            keys.BUILD: 5,",
            "            keys.TODAY: 6,",
            "        }",
            "",
            "        def _key_order(value: str) -> tuple[int, str, int]:",
            "            parts = value.split(\"_\")",
            "            part_count = len(parts)",
            "            if part_count == 1:",
            "                return part_count, \"\", preferred_order[parts[0]]",
            "            return len(parts), parts[0], preferred_order[parts[1]]",
            "",
            "        return tuple(sorted(valid_keys, key=_key_order))",
            "",
            "",
            "class FormatPatternError(FormatError):",
            "    \"\"\"Pattern was not properly formed\"\"\"",
            "",
            "    def __init__(self, format_pattern: str, error: str) -> None:",
            "        self.format_pattern = format_pattern",
            "        self.error = error",
            "        super().__init__(",
            "            f\"Format pattern '{self.format_pattern}' was invalid: {self.error}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Format pattern '\")",
            "        message.append(self.format_pattern, style=\"invalid\")",
            "        message.append(\"' was invalid:\\n\")",
            "        message.append(self.error, style=\"error.msg\")",
            "        return message",
            "",
            "",
            "class TodayFormatKeyError(FormatError):",
            "    \"\"\"Today key using unsupported format directive\"\"\"",
            "",
            "    def __init__(self, date_format_pattern: str, valid_keys: Collection[str]) -> None:",
            "        self.date_format_pattern = date_format_pattern",
            "        self.valid_keys = valid_keys",
            "        super().__init__(",
            "            f\"Today format directive '{self.date_format_pattern}' used an unsupported key for \"",
            "            f\"keystone parsing. Valid keys are: {_list_str_values(self.valid_keys)}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Today format directive '\")",
            "        message.append(self.date_format_pattern, style=\"invalid\")",
            "        message.append(",
            "            \"' used an unsupported key for keystone parsing.\\nValid keys are: \"",
            "        )",
            "        message.append_text(ui.list_styled_values(self.valid_keys, \"valid\"))",
            "        return message",
            "",
            "",
            "class IncompleteKeystoneVersionError(FormatError):",
            "    def __init__(self, file: Path, search_pattern: str) -> None:",
            "        self.file = file",
            "        self.search_pattern = search_pattern",
            "        super().__init__(",
            "            f\"Keystone version found in file '{self.file}' using pattern '{self.search_pattern}'\"",
            "            f\" was incomplete.\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Keystone version found in file '\")",
            "        message.append(str(self.file), style=\"file.path\")",
            "        message.append(\"' using pattern '\")",
            "        message.append(str(self.search_pattern), style=\"invalid\")",
            "        message.append(\"' was incomplete.\")",
            "        return message",
            "",
            "",
            "class FileGlobError(BumpItError):",
            "    def __init__(self, working_dir: Path, file_glob: str) -> None:",
            "        self.working_dir = working_dir",
            "        self.file_glob = file_glob",
            "        super().__init__(",
            "            f\"File glob '{self.file_glob}' did not match any files in '{self.working_dir}'.\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"File glob '\")",
            "        message.append(self.file_glob, style=\"file.glob\")",
            "        message.append(\"' did not match any files in '\")",
            "        message.append(str(self.working_dir), style=\"file.path\")",
            "        message.append(\"'.\")",
            "        return message",
            "",
            "",
            "class KeystoneError(BumpItError):",
            "    \"\"\"Base for keystone file errors\"\"\"",
            "",
            "",
            "class KeystoneFileGlobError(KeystoneError):",
            "    _NO_MATCH_TEXT = \"No files matched\"",
            "",
            "    def __init__(self, file_glob: str, matches: list[Path]) -> None:",
            "        self.file_glob = file_glob",
            "        self.matches = matches",
            "        message = (",
            "            f\"The file glob ({self.file_glob}) \"",
            "            \"for the keystone files must match exactly one file.\"",
            "        )",
            "        if self.matches:",
            "            message = f\"{message} Matched: {_list_values(self.matches, str)}\"",
            "        else:",
            "            message = f\"{message} {KeystoneFileGlobError._NO_MATCH_TEXT}\"",
            "        super().__init__(message)",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"The file glob (\")",
            "        message.append(self.file_glob, style=\"file.glob\")",
            "        message.append(\") for the keystone files must match exactly one file.\\n\")",
            "        if self.matches:",
            "            message.append(\"Matched: \")",
            "            message.append_text(",
            "                ui.list_styled_values(",
            "                    [str(match) for match in self.matches], style=\"file.path\"",
            "                )",
            "            )",
            "        else:",
            "            message.append(KeystoneFileGlobError._NO_MATCH_TEXT)",
            "        return message",
            "",
            "",
            "class SearchTextNotFound(KeystoneError):",
            "    def __init__(self, file: Path, search_pattern: str) -> None:",
            "        self.file = file",
            "        self.search_pattern = search_pattern",
            "        super().__init__(",
            "            f\"The search pattern '{self.search_pattern}' was not found in file '{self.file}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"The search pattern '\")",
            "        message.append(self.search_pattern, style=\"format.pattern\")",
            "        message.append(\"' was not found in file '\")",
            "        message.append(str(self.file), style=\"file.path\")",
            "        message.append(\"'\")",
            "        return message",
            "",
            "",
            "class VersionNotFound(KeystoneError):",
            "    def __init__(self, file: Path, search_pattern: str) -> None:",
            "        self.file = file",
            "        self.search_pattern = search_pattern",
            "        super().__init__(",
            "            f\"Current version not found in file '{self.file}' using pattern \"",
            "            f\"'{self.search_pattern}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Current version not found in file '\")",
            "        message.append(str(self.file), style=\"file.path\")",
            "        message.append(\"' using pattern '\")",
            "        message.append(self.search_pattern, style=\"valid\")",
            "        message.append(\"'\")",
            "        return message",
            "",
            "",
            "class GitError(BumpItError):",
            "    \"\"\"Base for git errors\"\"\"",
            "",
            "    def __init__(self, project_root: Path, message_suffix: str) -> None:",
            "        self.project_root = project_root",
            "        super().__init__(f\"The project root '{self.project_root}' {message_suffix}\")",
            "",
            "    @property",
            "    def _message_prefix(self) -> Text:",
            "        return (",
            "            Text(\"The project root '\")",
            "            .append(str(self.project_root), style=\"file.path\")",
            "            .append(\"' \")",
            "        )",
            "",
            "",
            "class GitErrorSimple(GitError):",
            "    \"\"\"Base for git errors that don't need styling of the suffix\"\"\"",
            "",
            "    def __init__(self, project_root: Path, message_suffix: str) -> None:",
            "        self.message_suffix = message_suffix",
            "        super().__init__(project_root, self.message_suffix)",
            "",
            "    def __rich__(self) -> Text:",
            "        return self._message_prefix.append(self.message_suffix)",
            "",
            "",
            "class NoRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"is not a git repository\")",
            "",
            "",
            "class EmptyRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"has no commits\")",
            "",
            "",
            "class DirtyRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"has uncommitted changes\")",
            "",
            "",
            "class DetachedRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"is not currently on a branch\")",
            "",
            "",
            "class MissingRemoteError(GitError):",
            "    def __init__(self, remote: str, project_root: Path) -> None:",
            "        self.remote = remote",
            "        super().__init__(project_root, f\"does not define the remote '{self.remote}'\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return (",
            "            self._message_prefix.append(\"does not define the \")",
            "            .append(\"remote\", style=\"emphasis\")",
            "            .append(\" '\")",
            "            .append(self.remote, style=\"vcs.remote\")",
            "            .append(\"'\")",
            "        )",
            "",
            "",
            "class DisallowedInitialBranchError(GitError):",
            "    def __init__(",
            "        self,",
            "        allowed_initial_branches: frozenset[str],",
            "        active_branch: str,",
            "        project_root: Path,",
            "    ) -> None:",
            "        self.allowed_initial_branches = allowed_initial_branches",
            "        self.active_branch = active_branch",
            "        if len(self.allowed_initial_branches) == 1:",
            "            must_message = f\"'{self._first_branch}'\"",
            "        else:",
            "            branches = \"', '\".join(self.allowed_initial_branches)",
            "            must_message = f\"one of: '{branches}'\"",
            "        super().__init__(",
            "            project_root,",
            "            f\"is currently on branch '{self.active_branch}', \"",
            "            f\"which is not allowed. Must be {must_message}.\",",
            "        )",
            "",
            "    @property",
            "    def _first_branch(self) -> str:",
            "        return next(iter(self.allowed_initial_branches))",
            "",
            "    def __rich__(self) -> Text:",
            "        message = self._message_prefix.append(\"is currently on branch '\")",
            "        message.append(self.active_branch, style=\"vcs.branch\")",
            "        message.append(\"', which is not allowed. Must be \")",
            "        if len(self.allowed_initial_branches) == 1:",
            "            message.append(\"'\")",
            "            message.append(self._first_branch, style=\"vcs.branch\")",
            "            message.append(\"'\")",
            "        else:",
            "            message.append(\"one of: \")",
            "            message.append_text(",
            "                ui.list_styled_values(",
            "                    self.allowed_initial_branches, style=\"vcs.branch\", quoted=True",
            "                )",
            "            )",
            "        message.append(\".\")",
            "        return message",
            "",
            "",
            "class AlreadyExistsError(GitError):",
            "    def __init__(",
            "        self,",
            "        ref_type: Union[Literal[\"branch\"], Literal[\"tag\"]],",
            "        name: str,",
            "        project_root: Path,",
            "    ) -> None:",
            "        self.project_root = project_root",
            "        self.ref_type = ref_type",
            "        self.name = name",
            "        super().__init__(",
            "            project_root, f\"already has a {self.ref_type} named '{self.name}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        return (",
            "            self._message_prefix.append(\"already has a \")",
            "            .append(self.ref_type, style=\"emphasis\")",
            "            .append(\" named '\")",
            "            .append(self.name, style=f\"vcs.{self.ref_type}\")",
            "            .append(\"'\")",
            "        )",
            "",
            "",
            "class ConfigurationError(BumpItError):",
            "    \"\"\"Base for configuration errors\"\"\"",
            "",
            "",
            "class ConfigurationFileNotFoundError(ConfigurationError):",
            "    def __init__(self, project_root: Path) -> None:",
            "        self.project_root = project_root",
            "        super().__init__(",
            "            f\"No configuration file found in directory {self.project_root}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        return Text(\"No configuration file found in directory \").append(",
            "            str(self.project_root), style=\"file.path\"",
            "        )",
            "",
            "",
            "class ConfigurationAlreadyExistsError(ConfigurationError):",
            "    def __init__(self, config_file: Path) -> None:",
            "        self.config_file = config_file",
            "        super().__init__(f\"A configuration already exist in {self.config_file}\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return Text(\"A configuration already exist in \").append(",
            "            str(self.config_file), style=\"file.path\"",
            "        )",
            "",
            "",
            "class ConfigurationFileError(ConfigurationError):",
            "    def __init__(",
            "        self, file: Path, message_suffix: Union[str, Callable[[], str]]",
            "    ) -> None:",
            "        self.file = file",
            "        if not isinstance(message_suffix, str):",
            "            message_suffix = message_suffix()",
            "        super().__init__(f\"The configuration file ({self.file}) {message_suffix}\")",
            "",
            "    @property",
            "    def _message_prefix(self) -> Text:",
            "        return (",
            "            Text(\"The configuration file (\")",
            "            .append(str(self.file), style=\"file.path\")",
            "            .append(\") \")",
            "        )",
            "",
            "",
            "class ConfigurationFileReadError(ConfigurationFileError):",
            "    def __init__(self, file: Path, cause: Exception) -> None:",
            "        self.cause = cause",
            "        super().__init__(file, f\"could not be read: {self.cause}\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return self._message_prefix.append(\"could not be read:\\n\").append(",
            "            str(self.cause), style=\"error.msg\"",
            "        )",
            "",
            "",
            "class SubTableNotExistError(ConfigurationFileError):",
            "    def __init__(self, file: Path, sub_tables: tuple[str, str]) -> None:",
            "        self.sub_table = \".\".join(sub_tables)",
            "        super().__init__(file, f\"is missing the sub-table '{self.sub_table}'\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return (",
            "            self._message_prefix.append(\"is missing the sub-table '\")",
            "            .append(str(self.sub_table), style=\"valid\")",
            "            .append(\"'\")",
            "        )",
            "",
            "",
            "class InvalidConfigurationError(ConfigurationFileError):",
            "    def __init__(self, file: Path, cause: ValidationError) -> None:",
            "        self.cause = cause",
            "        super().__init__(file, lambda: self._append_message_suffix(Text()).plain)",
            "",
            "    def __rich__(self) -> Text:",
            "        return self._append_message_suffix(self._message_prefix)",
            "",
            "    # Slightly customized variant of pydantic's ValidationError.__str__() to make it more end-user",
            "    # friendly and enhanced with rich styles.",
            "    def _append_message_suffix(self, initial_text: Text) -> Text:",
            "        errors = self.cause.errors()",
            "        num_errors = len(errors)",
            "",
            "        message = initial_text.append(\"is not valid:\\n\")",
            "        message.append(f\"{num_errors} validation error\")",
            "        if num_errors != 1:",
            "            message.append(\"s\")",
            "        message.append(\" for \")",
            "        message.append(self.cause.title, style=\"emphasis\")",
            "        message.append(\"\\n\")",
            "        message.append(InvalidConfigurationError._display_errors(errors))",
            "        return message",
            "",
            "    @staticmethod",
            "    def _display_errors(errors: list[\"ErrorDetails\"]) -> Text:",
            "        return Text(\"\\n\").join(",
            "            InvalidConfigurationError._display_error_loc(e)",
            "            .append(\"  \")",
            "            .append(e[\"msg\"], style=\"error.msg\")",
            "            for e in errors",
            "        )",
            "",
            "    @staticmethod",
            "    def _display_error_loc(error: \"ErrorDetails\") -> Text:",
            "        if len(error[\"loc\"]) == 0:",
            "            return Text(\"\")",
            "        return (",
            "            Text(\".\")",
            "            .join(Text(str(e), style=\"error.loc\") for e in error[\"loc\"])",
            "            .append(\"\\n\")",
            "        )",
            "",
            "",
            "def first_error_message(ex: ValidationError) -> str:",
            "    first_error = ex.errors(include_context=True)[0]",
            "    if (ctx := first_error.get(\"ctx\")) is not None:",
            "        if (ctx_error := ctx.get(\"error\")) is not None:",
            "            return str(ctx_error)",
            "    return first_error[\"msg\"]",
            "",
            "",
            "TValue = TypeVar(\"TValue\")",
            "",
            "",
            "def _list_str_values(values: Collection[str]) -> str:",
            "    return \", \".join(value for value in values)",
            "",
            "",
            "def _list_values(values: Collection[TValue], to_str: Callable[[TValue], str]) -> str:",
            "    return \", \".join(to_str(value) for value in values)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Errors raised by the library.",
            "\"\"\"",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Callable, Collection, Literal, TypeVar, Union",
            "",
            "from pydantic import ValidationError",
            "from rich.text import Text",
            "",
            "from . import ui",
            "",
            "if TYPE_CHECKING:",
            "    from pydantic_core import ErrorDetails",
            "",
            "",
            "class BumpItError(Exception):",
            "    \"\"\"Base for library errors\"\"\"",
            "",
            "    def __rich__(self) -> Text:",
            "        return Text(str(self))",
            "",
            "",
            "class FormatError(BumpItError):",
            "    \"\"\"Base for formatting errors\"\"\"",
            "",
            "",
            "class FormatKeyError(FormatError):",
            "    \"\"\"Pattern referenced an invalid key\"\"\"",
            "",
            "    def __init__(self, format_pattern: str, valid_keys: Collection[str]) -> None:",
            "        self.format_pattern = format_pattern",
            "        self.valid_keys = FormatKeyError._sort_keys(valid_keys)",
            "        super().__init__(",
            "            f\"Format pattern '{self.format_pattern}' used an invalid key. \"",
            "            f\"Valid keys are: {_list_str_values(self.valid_keys)}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Format pattern '\")",
            "        message.append(self.format_pattern, style=\"invalid\")",
            "        message.append(\"' used an invalid key.\\nValid keys are: \")",
            "        message.append_text(ui.list_styled_values(self.valid_keys, \"valid\"))",
            "        return message",
            "",
            "    @staticmethod",
            "    def _sort_keys(valid_keys: Collection[str]) -> tuple[str, ...]:",
            "        \"\"\"",
            "        Re-order keys for display to the user.",
            "",
            "        The ordering first sorts by general keys, current keys, new keys.",
            "        Within each of those sections, the order is based on the order of the version parts. Any",
            "        helper keys go after the version part keys.",
            "        \"\"\"",
            "        from .format_pattern import keys  # prevents circular import",
            "",
            "        preferred_order = {",
            "            keys.VERSION: 0,",
            "            keys.MAJOR: 1,",
            "            keys.MINOR: 2,",
            "            keys.PATCH: 3,",
            "            keys.PRERELEASE: 4,",
            "            keys.BUILD: 5,",
            "            keys.TODAY: 6,",
            "        }",
            "",
            "        def _key_order(value: str) -> tuple[int, str, int]:",
            "            parts = value.split(\"_\")",
            "            part_count = len(parts)",
            "            if part_count == 1:",
            "                return part_count, \"\", preferred_order[parts[0]]",
            "            return len(parts), parts[0], preferred_order[parts[1]]",
            "",
            "        return tuple(sorted(valid_keys, key=_key_order))",
            "",
            "",
            "class FormatPatternError(FormatError):",
            "    \"\"\"Pattern was not properly formed\"\"\"",
            "",
            "    def __init__(self, format_pattern: str, error: str) -> None:",
            "        self.format_pattern = format_pattern",
            "        self.error = error",
            "        super().__init__(",
            "            f\"Format pattern '{self.format_pattern}' was invalid: {self.error}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Format pattern '\")",
            "        message.append(self.format_pattern, style=\"invalid\")",
            "        message.append(\"' was invalid:\\n\")",
            "        message.append(self.error, style=\"error.msg\")",
            "        return message",
            "",
            "",
            "class TodayFormatKeyError(FormatError):",
            "    \"\"\"Today key using unsupported format directive\"\"\"",
            "",
            "    def __init__(self, date_format_pattern: str, valid_keys: Collection[str]) -> None:",
            "        self.date_format_pattern = date_format_pattern",
            "        self.valid_keys = valid_keys",
            "        super().__init__(",
            "            f\"Today format directive '{self.date_format_pattern}' used an unsupported key for \"",
            "            f\"keystone parsing. Valid keys are: {_list_str_values(self.valid_keys)}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Today format directive '\")",
            "        message.append(self.date_format_pattern, style=\"invalid\")",
            "        message.append(",
            "            \"' used an unsupported key for keystone parsing.\\nValid keys are: \"",
            "        )",
            "        message.append_text(ui.list_styled_values(self.valid_keys, \"valid\"))",
            "        return message",
            "",
            "",
            "class IncompleteKeystoneVersionError(FormatError):",
            "    def __init__(self, file: Path, search_pattern: str) -> None:",
            "        self.file = file",
            "        self.search_pattern = search_pattern",
            "        super().__init__(",
            "            f\"Keystone version found in file '{self.file}' using pattern '{self.search_pattern}'\"",
            "            f\" was incomplete.\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Keystone version found in file '\")",
            "        message.append(str(self.file), style=\"file.path\")",
            "        message.append(\"' using pattern '\")",
            "        message.append(str(self.search_pattern), style=\"invalid\")",
            "        message.append(\"' was incomplete.\")",
            "        return message",
            "",
            "",
            "class FileGlobError(BumpItError):",
            "    def __init__(self, working_dir: Path, file_glob: str) -> None:",
            "        self.working_dir = working_dir",
            "        self.file_glob = file_glob",
            "        super().__init__(",
            "            f\"File glob '{self.file_glob}' did not match any files in '{self.working_dir}'.\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"File glob '\")",
            "        message.append(self.file_glob, style=\"file.glob\")",
            "        message.append(\"' did not match any files in '\")",
            "        message.append(str(self.working_dir), style=\"file.path\")",
            "        message.append(\"'.\")",
            "        return message",
            "",
            "",
            "class PathTraversalError(BumpItError):",
            "    def __init__(self, project_root: Path, file_glob: str, matched_file: Path) -> None:",
            "        self.project_root = project_root",
            "        self.file_glob = file_glob",
            "        self.matched_file = matched_file",
            "        super().__init__(",
            "            f\"Matched files must be within the project root ({self.project_root}). '{self.file_glob}' matched: '{self.matched_file}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Matched files must be within the project root (\")",
            "        message.append(str(self.project_root), style=\"file.path\")",
            "        message.append(\"). '\")",
            "        message.append(self.file_glob, style=\"file.glob\")",
            "        message.append(\"' matched: '\")",
            "        message.append(str(self.matched_file), style=\"file.path\")",
            "        message.append(\"'\")",
            "        return message",
            "",
            "",
            "class KeystoneError(BumpItError):",
            "    \"\"\"Base for keystone file errors\"\"\"",
            "",
            "",
            "class KeystoneFileGlobError(KeystoneError):",
            "    _NO_MATCH_TEXT = \"No files matched\"",
            "",
            "    def __init__(self, file_glob: str, matches: list[Path]) -> None:",
            "        self.file_glob = file_glob",
            "        self.matches = matches",
            "        message = (",
            "            f\"The file glob ({self.file_glob}) \"",
            "            \"for the keystone files must match exactly one file.\"",
            "        )",
            "        if self.matches:",
            "            message = f\"{message} Matched: {_list_values(self.matches, str)}\"",
            "        else:",
            "            message = f\"{message} {KeystoneFileGlobError._NO_MATCH_TEXT}\"",
            "        super().__init__(message)",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"The file glob (\")",
            "        message.append(self.file_glob, style=\"file.glob\")",
            "        message.append(\") for the keystone files must match exactly one file.\\n\")",
            "        if self.matches:",
            "            message.append(\"Matched: \")",
            "            message.append_text(",
            "                ui.list_styled_values(",
            "                    [str(match) for match in self.matches], style=\"file.path\"",
            "                )",
            "            )",
            "        else:",
            "            message.append(KeystoneFileGlobError._NO_MATCH_TEXT)",
            "        return message",
            "",
            "",
            "class SearchTextNotFound(KeystoneError):",
            "    def __init__(self, file: Path, search_pattern: str) -> None:",
            "        self.file = file",
            "        self.search_pattern = search_pattern",
            "        super().__init__(",
            "            f\"The search pattern '{self.search_pattern}' was not found in file '{self.file}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"The search pattern '\")",
            "        message.append(self.search_pattern, style=\"format.pattern\")",
            "        message.append(\"' was not found in file '\")",
            "        message.append(str(self.file), style=\"file.path\")",
            "        message.append(\"'\")",
            "        return message",
            "",
            "",
            "class VersionNotFound(KeystoneError):",
            "    def __init__(self, file: Path, search_pattern: str) -> None:",
            "        self.file = file",
            "        self.search_pattern = search_pattern",
            "        super().__init__(",
            "            f\"Current version not found in file '{self.file}' using pattern \"",
            "            f\"'{self.search_pattern}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        message = Text(\"Current version not found in file '\")",
            "        message.append(str(self.file), style=\"file.path\")",
            "        message.append(\"' using pattern '\")",
            "        message.append(self.search_pattern, style=\"valid\")",
            "        message.append(\"'\")",
            "        return message",
            "",
            "",
            "class GitError(BumpItError):",
            "    \"\"\"Base for git errors\"\"\"",
            "",
            "    def __init__(self, project_root: Path, message_suffix: str) -> None:",
            "        self.project_root = project_root",
            "        super().__init__(f\"The project root '{self.project_root}' {message_suffix}\")",
            "",
            "    @property",
            "    def _message_prefix(self) -> Text:",
            "        return (",
            "            Text(\"The project root '\")",
            "            .append(str(self.project_root), style=\"file.path\")",
            "            .append(\"' \")",
            "        )",
            "",
            "",
            "class GitErrorSimple(GitError):",
            "    \"\"\"Base for git errors that don't need styling of the suffix\"\"\"",
            "",
            "    def __init__(self, project_root: Path, message_suffix: str) -> None:",
            "        self.message_suffix = message_suffix",
            "        super().__init__(project_root, self.message_suffix)",
            "",
            "    def __rich__(self) -> Text:",
            "        return self._message_prefix.append(self.message_suffix)",
            "",
            "",
            "class NoRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"is not a git repository\")",
            "",
            "",
            "class EmptyRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"has no commits\")",
            "",
            "",
            "class DirtyRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"has uncommitted changes\")",
            "",
            "",
            "class DetachedRepositoryError(GitErrorSimple):",
            "    def __init__(self, project_root: Path) -> None:",
            "        super().__init__(project_root, \"is not currently on a branch\")",
            "",
            "",
            "class MissingRemoteError(GitError):",
            "    def __init__(self, remote: str, project_root: Path) -> None:",
            "        self.remote = remote",
            "        super().__init__(project_root, f\"does not define the remote '{self.remote}'\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return (",
            "            self._message_prefix.append(\"does not define the \")",
            "            .append(\"remote\", style=\"emphasis\")",
            "            .append(\" '\")",
            "            .append(self.remote, style=\"vcs.remote\")",
            "            .append(\"'\")",
            "        )",
            "",
            "",
            "class DisallowedInitialBranchError(GitError):",
            "    def __init__(",
            "        self,",
            "        allowed_initial_branches: frozenset[str],",
            "        active_branch: str,",
            "        project_root: Path,",
            "    ) -> None:",
            "        self.allowed_initial_branches = allowed_initial_branches",
            "        self.active_branch = active_branch",
            "        if len(self.allowed_initial_branches) == 1:",
            "            must_message = f\"'{self._first_branch}'\"",
            "        else:",
            "            branches = \"', '\".join(self.allowed_initial_branches)",
            "            must_message = f\"one of: '{branches}'\"",
            "        super().__init__(",
            "            project_root,",
            "            f\"is currently on branch '{self.active_branch}', \"",
            "            f\"which is not allowed. Must be {must_message}.\",",
            "        )",
            "",
            "    @property",
            "    def _first_branch(self) -> str:",
            "        return next(iter(self.allowed_initial_branches))",
            "",
            "    def __rich__(self) -> Text:",
            "        message = self._message_prefix.append(\"is currently on branch '\")",
            "        message.append(self.active_branch, style=\"vcs.branch\")",
            "        message.append(\"', which is not allowed. Must be \")",
            "        if len(self.allowed_initial_branches) == 1:",
            "            message.append(\"'\")",
            "            message.append(self._first_branch, style=\"vcs.branch\")",
            "            message.append(\"'\")",
            "        else:",
            "            message.append(\"one of: \")",
            "            message.append_text(",
            "                ui.list_styled_values(",
            "                    self.allowed_initial_branches, style=\"vcs.branch\", quoted=True",
            "                )",
            "            )",
            "        message.append(\".\")",
            "        return message",
            "",
            "",
            "class AlreadyExistsError(GitError):",
            "    def __init__(",
            "        self,",
            "        ref_type: Union[Literal[\"branch\"], Literal[\"tag\"]],",
            "        name: str,",
            "        project_root: Path,",
            "    ) -> None:",
            "        self.project_root = project_root",
            "        self.ref_type = ref_type",
            "        self.name = name",
            "        super().__init__(",
            "            project_root, f\"already has a {self.ref_type} named '{self.name}'\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        return (",
            "            self._message_prefix.append(\"already has a \")",
            "            .append(self.ref_type, style=\"emphasis\")",
            "            .append(\" named '\")",
            "            .append(self.name, style=f\"vcs.{self.ref_type}\")",
            "            .append(\"'\")",
            "        )",
            "",
            "",
            "class ConfigurationError(BumpItError):",
            "    \"\"\"Base for configuration errors\"\"\"",
            "",
            "",
            "class ConfigurationFileNotFoundError(ConfigurationError):",
            "    def __init__(self, project_root: Path) -> None:",
            "        self.project_root = project_root",
            "        super().__init__(",
            "            f\"No configuration file found in directory {self.project_root}\"",
            "        )",
            "",
            "    def __rich__(self) -> Text:",
            "        return Text(\"No configuration file found in directory \").append(",
            "            str(self.project_root), style=\"file.path\"",
            "        )",
            "",
            "",
            "class ConfigurationAlreadyExistsError(ConfigurationError):",
            "    def __init__(self, config_file: Path) -> None:",
            "        self.config_file = config_file",
            "        super().__init__(f\"A configuration already exist in {self.config_file}\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return Text(\"A configuration already exist in \").append(",
            "            str(self.config_file), style=\"file.path\"",
            "        )",
            "",
            "",
            "class ConfigurationFileError(ConfigurationError):",
            "    def __init__(",
            "        self, file: Path, message_suffix: Union[str, Callable[[], str]]",
            "    ) -> None:",
            "        self.file = file",
            "        if not isinstance(message_suffix, str):",
            "            message_suffix = message_suffix()",
            "        super().__init__(f\"The configuration file ({self.file}) {message_suffix}\")",
            "",
            "    @property",
            "    def _message_prefix(self) -> Text:",
            "        return (",
            "            Text(\"The configuration file (\")",
            "            .append(str(self.file), style=\"file.path\")",
            "            .append(\") \")",
            "        )",
            "",
            "",
            "class ConfigurationFileReadError(ConfigurationFileError):",
            "    def __init__(self, file: Path, cause: Exception) -> None:",
            "        self.cause = cause",
            "        super().__init__(file, f\"could not be read: {self.cause}\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return self._message_prefix.append(\"could not be read:\\n\").append(",
            "            str(self.cause), style=\"error.msg\"",
            "        )",
            "",
            "",
            "class SubTableNotExistError(ConfigurationFileError):",
            "    def __init__(self, file: Path, sub_tables: tuple[str, str]) -> None:",
            "        self.sub_table = \".\".join(sub_tables)",
            "        super().__init__(file, f\"is missing the sub-table '{self.sub_table}'\")",
            "",
            "    def __rich__(self) -> Text:",
            "        return (",
            "            self._message_prefix.append(\"is missing the sub-table '\")",
            "            .append(str(self.sub_table), style=\"valid\")",
            "            .append(\"'\")",
            "        )",
            "",
            "",
            "class InvalidConfigurationError(ConfigurationFileError):",
            "    def __init__(self, file: Path, cause: ValidationError) -> None:",
            "        self.cause = cause",
            "        super().__init__(file, lambda: self._append_message_suffix(Text()).plain)",
            "",
            "    def __rich__(self) -> Text:",
            "        return self._append_message_suffix(self._message_prefix)",
            "",
            "    # Slightly customized variant of pydantic's ValidationError.__str__() to make it more end-user",
            "    # friendly and enhanced with rich styles.",
            "    def _append_message_suffix(self, initial_text: Text) -> Text:",
            "        errors = self.cause.errors()",
            "        num_errors = len(errors)",
            "",
            "        message = initial_text.append(\"is not valid:\\n\")",
            "        message.append(f\"{num_errors} validation error\")",
            "        if num_errors != 1:",
            "            message.append(\"s\")",
            "        message.append(\" for \")",
            "        message.append(self.cause.title, style=\"emphasis\")",
            "        message.append(\"\\n\")",
            "        message.append(InvalidConfigurationError._display_errors(errors))",
            "        return message",
            "",
            "    @staticmethod",
            "    def _display_errors(errors: list[\"ErrorDetails\"]) -> Text:",
            "        return Text(\"\\n\").join(",
            "            InvalidConfigurationError._display_error_loc(e)",
            "            .append(\"  \")",
            "            .append(e[\"msg\"], style=\"error.msg\")",
            "            for e in errors",
            "        )",
            "",
            "    @staticmethod",
            "    def _display_error_loc(error: \"ErrorDetails\") -> Text:",
            "        if len(error[\"loc\"]) == 0:",
            "            return Text(\"\")",
            "        return (",
            "            Text(\".\")",
            "            .join(Text(str(e), style=\"error.loc\") for e in error[\"loc\"])",
            "            .append(\"\\n\")",
            "        )",
            "",
            "",
            "def first_error_message(ex: ValidationError) -> str:",
            "    first_error = ex.errors(include_context=True)[0]",
            "    if (ctx := first_error.get(\"ctx\")) is not None:",
            "        if (ctx_error := ctx.get(\"error\")) is not None:",
            "            return str(ctx_error)",
            "    return first_error[\"msg\"]",
            "",
            "",
            "TValue = TypeVar(\"TValue\")",
            "",
            "",
            "def _list_str_values(values: Collection[str]) -> str:",
            "    return \", \".join(value for value in values)",
            "",
            "",
            "def _list_values(values: Collection[TValue], to_str: Callable[[TValue], str]) -> str:",
            "    return \", \".join(to_str(value) for value in values)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.template.Templar.template"
        ]
    },
    "hyper_bump_it/_hyper_bump_it/files.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from . import format_pattern"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from .config import File"
            },
            "3": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .error import FileGlobError, SearchTextNotFound"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from .error import FileGlobError, PathTraversalError, SearchTextNotFound"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from .format_pattern import FormatContext, TextFormatter, keys"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from .planned_changes import PlannedChange"
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     changes = ["
            },
            "10": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         _planned_change_for("
            },
            "11": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            file.resolve(),"
            },
            "13": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "             config.search_format_pattern,"
            },
            "14": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "             config.replace_format_pattern,"
            },
            "15": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "             formatter,"
            },
            "16": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "             project_root,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+            config.file_glob,"
            },
            "18": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         )"
            },
            "19": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         for file in project_root.glob(config.file_glob)"
            },
            "20": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     ]"
            },
            "21": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     replace_pattern: str,"
            },
            "22": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     formatter: TextFormatter,"
            },
            "23": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     project_root: Path,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    file_glob: str,"
            },
            "25": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " ) -> PlannedChange:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    if not is_contained_within(file, project_root):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        raise PathTraversalError(project_root, file_glob, file)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     file_data = file.read_bytes()"
            },
            "30": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     file_text = file_data.decode()"
            },
            "31": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         raise ValueError("
            },
            "33": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             f\"Given file '{change.file}' does not exist. PlannedChange is not valid.\""
            },
            "34": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         )"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+def is_contained_within(file: Path, project_root: Path) -> bool:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    return file.resolve().is_relative_to(project_root.resolve())"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Operation on files.",
            "\"\"\"",
            "",
            "from pathlib import Path",
            "",
            "from . import format_pattern",
            "from .config import File",
            "from .error import FileGlobError, SearchTextNotFound",
            "from .format_pattern import FormatContext, TextFormatter, keys",
            "from .planned_changes import PlannedChange",
            "",
            "",
            "def collect_planned_changes(",
            "    project_root: Path, config: File, formatter: TextFormatter",
            ") -> list[PlannedChange]:",
            "    \"\"\"",
            "    Aggregate a collection of changes that would occur across multiple files.",
            "",
            "    :param project_root: Root directory to start looking for files.",
            "    :param config: Configuration of how the changes should operate.",
            "    :param formatter: Object that converts format patterns into text.",
            "    :return: Descriptions of the change that would occur.",
            "    :raises FileGlobError: Glob pattern for selecting files did not find any files.",
            "    :raises SearchTextNotFound: A file did not contain the produced search text.",
            "    \"\"\"",
            "    changes = [",
            "        _planned_change_for(",
            "            file,",
            "            config.search_format_pattern,",
            "            config.replace_format_pattern,",
            "            formatter,",
            "            project_root,",
            "        )",
            "        for file in project_root.glob(config.file_glob)",
            "    ]",
            "    if not changes:",
            "        raise FileGlobError(project_root, config.file_glob)",
            "    return changes",
            "",
            "",
            "def _planned_change_for(",
            "    file: Path,",
            "    search_pattern: str,",
            "    replace_pattern: str,",
            "    formatter: TextFormatter,",
            "    project_root: Path,",
            ") -> PlannedChange:",
            "    file_data = file.read_bytes()",
            "    file_text = file_data.decode()",
            "",
            "    replace_text = formatter.format(replace_pattern, FormatContext.replace)",
            "    search_text_maybe = formatter.format(search_pattern, FormatContext.search)",
            "",
            "    if TextFormatter.is_used(keys.TODAY, search_text_maybe):",
            "        # we need to convert the search text into a regex in order to match any date",
            "        updated_text, no_replacement = _today_replace(",
            "            search_text_maybe, file_text, replace_text",
            "        )",
            "    else:",
            "        no_replacement = search_text_maybe not in file_text",
            "        updated_text = file_text.replace(search_text_maybe, replace_text)",
            "",
            "    if no_replacement:",
            "        raise SearchTextNotFound(file.relative_to(project_root), search_pattern)",
            "",
            "    return PlannedChange(",
            "        file,",
            "        project_root,",
            "        old_content=file_text,",
            "        new_content=updated_text,",
            "        newline=PlannedChange.detect_line_ending(file_data),",
            "    )",
            "",
            "",
            "def _today_replace(",
            "    partial_format_pattern: str,",
            "    file_text: str,",
            "    replace_text: str,",
            ") -> tuple[str, bool]:",
            "    # The first pass formatted all the keys except \"today\". Now, that is the only key to convert",
            "    # into a regex pattern.",
            "    match_pattern = format_pattern.create_matching_pattern(partial_format_pattern)",
            "    updated_text, replace_count = match_pattern.subn(replace_text, file_text)",
            "    return updated_text, replace_count == 0",
            "",
            "",
            "def perform_change(change: PlannedChange) -> None:",
            "    try:",
            "        with change.file.open(\"w\", newline=change.newline) as f:",
            "            f.write(change.new_content)",
            "    except FileNotFoundError:",
            "        raise ValueError(",
            "            f\"Given file '{change.file}' does not exist. PlannedChange is not valid.\"",
            "        )"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Operation on files.",
            "\"\"\"",
            "",
            "from pathlib import Path",
            "",
            "from . import format_pattern",
            "from .config import File",
            "from .error import FileGlobError, PathTraversalError, SearchTextNotFound",
            "from .format_pattern import FormatContext, TextFormatter, keys",
            "from .planned_changes import PlannedChange",
            "",
            "",
            "def collect_planned_changes(",
            "    project_root: Path, config: File, formatter: TextFormatter",
            ") -> list[PlannedChange]:",
            "    \"\"\"",
            "    Aggregate a collection of changes that would occur across multiple files.",
            "",
            "    :param project_root: Root directory to start looking for files.",
            "    :param config: Configuration of how the changes should operate.",
            "    :param formatter: Object that converts format patterns into text.",
            "    :return: Descriptions of the change that would occur.",
            "    :raises FileGlobError: Glob pattern for selecting files did not find any files.",
            "    :raises SearchTextNotFound: A file did not contain the produced search text.",
            "    \"\"\"",
            "    changes = [",
            "        _planned_change_for(",
            "            file.resolve(),",
            "            config.search_format_pattern,",
            "            config.replace_format_pattern,",
            "            formatter,",
            "            project_root,",
            "            config.file_glob,",
            "        )",
            "        for file in project_root.glob(config.file_glob)",
            "    ]",
            "    if not changes:",
            "        raise FileGlobError(project_root, config.file_glob)",
            "    return changes",
            "",
            "",
            "def _planned_change_for(",
            "    file: Path,",
            "    search_pattern: str,",
            "    replace_pattern: str,",
            "    formatter: TextFormatter,",
            "    project_root: Path,",
            "    file_glob: str,",
            ") -> PlannedChange:",
            "    if not is_contained_within(file, project_root):",
            "        raise PathTraversalError(project_root, file_glob, file)",
            "",
            "    file_data = file.read_bytes()",
            "    file_text = file_data.decode()",
            "",
            "    replace_text = formatter.format(replace_pattern, FormatContext.replace)",
            "    search_text_maybe = formatter.format(search_pattern, FormatContext.search)",
            "",
            "    if TextFormatter.is_used(keys.TODAY, search_text_maybe):",
            "        # we need to convert the search text into a regex in order to match any date",
            "        updated_text, no_replacement = _today_replace(",
            "            search_text_maybe, file_text, replace_text",
            "        )",
            "    else:",
            "        no_replacement = search_text_maybe not in file_text",
            "        updated_text = file_text.replace(search_text_maybe, replace_text)",
            "",
            "    if no_replacement:",
            "        raise SearchTextNotFound(file.relative_to(project_root), search_pattern)",
            "",
            "    return PlannedChange(",
            "        file,",
            "        project_root,",
            "        old_content=file_text,",
            "        new_content=updated_text,",
            "        newline=PlannedChange.detect_line_ending(file_data),",
            "    )",
            "",
            "",
            "def _today_replace(",
            "    partial_format_pattern: str,",
            "    file_text: str,",
            "    replace_text: str,",
            ") -> tuple[str, bool]:",
            "    # The first pass formatted all the keys except \"today\". Now, that is the only key to convert",
            "    # into a regex pattern.",
            "    match_pattern = format_pattern.create_matching_pattern(partial_format_pattern)",
            "    updated_text, replace_count = match_pattern.subn(replace_text, file_text)",
            "    return updated_text, replace_count == 0",
            "",
            "",
            "def perform_change(change: PlannedChange) -> None:",
            "    try:",
            "        with change.file.open(\"w\", newline=change.newline) as f:",
            "            f.write(change.new_content)",
            "    except FileNotFoundError:",
            "        raise ValueError(",
            "            f\"Given file '{change.file}' does not exist. PlannedChange is not valid.\"",
            "        )",
            "",
            "",
            "def is_contained_within(file: Path, project_root: Path) -> bool:",
            "    return file.resolve().is_relative_to(project_root.resolve())"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "9": [],
            "29": [
                "collect_planned_changes"
            ]
        },
        "addLocation": []
    }
}