{
    "Tests/test_image.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 775,
                "afterPatchRowNumber": 775,
                "PatchRowcode": "         with pytest.warns(DeprecationWarning):"
            },
            "1": {
                "beforePatchRowNumber": 776,
                "afterPatchRowNumber": 776,
                "PatchRowcode": "             assert test_module.PILLOW_VERSION > \"7.0.0\""
            },
            "2": {
                "beforePatchRowNumber": 777,
                "afterPatchRowNumber": 777,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 778,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_overrun(self):"
            },
            "4": {
                "beforePatchRowNumber": 779,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"For overrun completeness, test as:"
            },
            "5": {
                "beforePatchRowNumber": 780,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        valgrind pytest -qq Tests/test_image.py::TestImage::test_overrun | grep decode.c"
            },
            "6": {
                "beforePatchRowNumber": 781,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for file in ["
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 778,
                "PatchRowcode": "+    @pytest.mark.parametrize(\"path\", ["
            },
            "9": {
                "beforePatchRowNumber": 783,
                "afterPatchRowNumber": 779,
                "PatchRowcode": "             \"fli_overrun.bin\","
            },
            "10": {
                "beforePatchRowNumber": 784,
                "afterPatchRowNumber": 780,
                "PatchRowcode": "             \"sgi_overrun.bin\","
            },
            "11": {
                "beforePatchRowNumber": 785,
                "afterPatchRowNumber": 781,
                "PatchRowcode": "             \"sgi_overrun_expandrow.bin\","
            },
            "12": {
                "beforePatchRowNumber": 786,
                "afterPatchRowNumber": 782,
                "PatchRowcode": "             \"sgi_overrun_expandrow2.bin\","
            },
            "13": {
                "beforePatchRowNumber": 787,
                "afterPatchRowNumber": 783,
                "PatchRowcode": "             \"pcx_overrun.bin\","
            },
            "14": {
                "beforePatchRowNumber": 788,
                "afterPatchRowNumber": 784,
                "PatchRowcode": "             \"pcx_overrun2.bin\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 785,
                "PatchRowcode": "+            \"ossfuzz-4836216264589312.pcx\","
            },
            "16": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": 786,
                "PatchRowcode": "             \"01r_00.pcx\","
            },
            "17": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ]:"
            },
            "18": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            with Image.open(os.path.join(\"Tests/images\", file)) as im:"
            },
            "19": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                try:"
            },
            "20": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    im.load()"
            },
            "21": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    assert False"
            },
            "22": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                except OSError as e:"
            },
            "23": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    assert str(e) == \"buffer overrun when reading image file\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 787,
                "PatchRowcode": "+        ])"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 788,
                "PatchRowcode": "+    def test_overrun(self, path):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 789,
                "PatchRowcode": "+        \"\"\"For overrun completeness, test as:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 790,
                "PatchRowcode": "+        valgrind pytest -qq Tests/test_image.py::TestImage::test_overrun | grep decode.c"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 791,
                "PatchRowcode": "+        \"\"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 792,
                "PatchRowcode": "+        with Image.open(os.path.join(\"Tests/images\", path)) as im:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 793,
                "PatchRowcode": "+            try:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 794,
                "PatchRowcode": "+                im.load()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 795,
                "PatchRowcode": "+                assert False"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 796,
                "PatchRowcode": "+            except OSError as e:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 797,
                "PatchRowcode": "+                assert (str(e) == \"buffer overrun when reading image file\" or"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 798,
                "PatchRowcode": "+                        \"image file is truncated\" in str(e))"
            },
            "36": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": 799,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 800,
                "PatchRowcode": "+    def test_fli_overrun2(self):"
            },
            "38": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": 801,
                "PatchRowcode": "         with Image.open(\"Tests/images/fli_overrun2.bin\") as im:"
            },
            "39": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": 802,
                "PatchRowcode": "             try:"
            },
            "40": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": 803,
                "PatchRowcode": "                 im.seek(1)"
            }
        },
        "frontPatchFile": [
            "import io",
            "import os",
            "import shutil",
            "import tempfile",
            "",
            "import pytest",
            "",
            "import PIL",
            "from PIL import Image, ImageDraw, ImagePalette, ImageShow, UnidentifiedImageError",
            "",
            "from .helper import (",
            "    assert_image_equal,",
            "    assert_image_similar,",
            "    assert_not_all_same,",
            "    hopper,",
            "    is_win32,",
            "    skip_unless_feature,",
            ")",
            "",
            "",
            "class TestImage:",
            "    def test_image_modes_success(self):",
            "        for mode in [",
            "            \"1\",",
            "            \"P\",",
            "            \"PA\",",
            "            \"L\",",
            "            \"LA\",",
            "            \"La\",",
            "            \"F\",",
            "            \"I\",",
            "            \"I;16\",",
            "            \"I;16L\",",
            "            \"I;16B\",",
            "            \"I;16N\",",
            "            \"RGB\",",
            "            \"RGBX\",",
            "            \"RGBA\",",
            "            \"RGBa\",",
            "            \"CMYK\",",
            "            \"YCbCr\",",
            "            \"LAB\",",
            "            \"HSV\",",
            "        ]:",
            "            Image.new(mode, (1, 1))",
            "",
            "    def test_image_modes_fail(self):",
            "        for mode in [",
            "            \"\",",
            "            \"bad\",",
            "            \"very very long\",",
            "            \"BGR;15\",",
            "            \"BGR;16\",",
            "            \"BGR;24\",",
            "            \"BGR;32\",",
            "        ]:",
            "            with pytest.raises(ValueError) as e:",
            "                Image.new(mode, (1, 1))",
            "            assert str(e.value) == \"unrecognized image mode\"",
            "",
            "    def test_exception_inheritance(self):",
            "        assert issubclass(UnidentifiedImageError, OSError)",
            "",
            "    def test_sanity(self):",
            "",
            "        im = Image.new(\"L\", (100, 100))",
            "        assert repr(im)[:45] == \"<PIL.Image.Image image mode=L size=100x100 at\"",
            "        assert im.mode == \"L\"",
            "        assert im.size == (100, 100)",
            "",
            "        im = Image.new(\"RGB\", (100, 100))",
            "        assert repr(im)[:45] == \"<PIL.Image.Image image mode=RGB size=100x100 \"",
            "        assert im.mode == \"RGB\"",
            "        assert im.size == (100, 100)",
            "",
            "        Image.new(\"L\", (100, 100), None)",
            "        im2 = Image.new(\"L\", (100, 100), 0)",
            "        im3 = Image.new(\"L\", (100, 100), \"black\")",
            "",
            "        assert im2.getcolors() == [(10000, 0)]",
            "        assert im3.getcolors() == [(10000, 0)]",
            "",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"X\", (100, 100))",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"\", (100, 100))",
            "        # with pytest.raises(MemoryError):",
            "        #   Image.new(\"L\", (1000000, 1000000))",
            "",
            "    def test_open_formats(self):",
            "        PNGFILE = \"Tests/images/hopper.png\"",
            "        JPGFILE = \"Tests/images/hopper.jpg\"",
            "",
            "        with pytest.raises(TypeError):",
            "            Image.open(PNGFILE, formats=123)",
            "",
            "        for formats in [[\"JPEG\"], (\"JPEG\",)]:",
            "            with pytest.raises(UnidentifiedImageError):",
            "                Image.open(PNGFILE, formats=formats)",
            "",
            "            with Image.open(JPGFILE, formats=formats) as im:",
            "                assert im.mode == \"RGB\"",
            "                assert im.size == (128, 128)",
            "",
            "        for file in [PNGFILE, JPGFILE]:",
            "            with Image.open(file, formats=None) as im:",
            "                assert im.mode == \"RGB\"",
            "                assert im.size == (128, 128)",
            "",
            "    def test_width_height(self):",
            "        im = Image.new(\"RGB\", (1, 2))",
            "        assert im.width == 1",
            "        assert im.height == 2",
            "",
            "        with pytest.raises(AttributeError):",
            "            im.size = (3, 4)",
            "",
            "    def test_invalid_image(self):",
            "        import io",
            "",
            "        im = io.BytesIO(b\"\")",
            "        with pytest.raises(UnidentifiedImageError):",
            "            Image.open(im)",
            "",
            "    def test_bad_mode(self):",
            "        with pytest.raises(ValueError):",
            "            Image.open(\"filename\", \"bad mode\")",
            "",
            "    def test_stringio(self):",
            "        with pytest.raises(ValueError):",
            "            Image.open(io.StringIO())",
            "",
            "    def test_pathlib(self, tmp_path):",
            "        from PIL.Image import Path",
            "",
            "        with Image.open(Path(\"Tests/images/multipage-mmap.tiff\")) as im:",
            "            assert im.mode == \"P\"",
            "            assert im.size == (10, 10)",
            "",
            "        with Image.open(Path(\"Tests/images/hopper.jpg\")) as im:",
            "            assert im.mode == \"RGB\"",
            "            assert im.size == (128, 128)",
            "",
            "            temp_file = str(tmp_path / \"temp.jpg\")",
            "            if os.path.exists(temp_file):",
            "                os.remove(temp_file)",
            "            im.save(Path(temp_file))",
            "",
            "    def test_fp_name(self, tmp_path):",
            "        temp_file = str(tmp_path / \"temp.jpg\")",
            "",
            "        class FP:",
            "            def write(a, b):",
            "                pass",
            "",
            "        fp = FP()",
            "        fp.name = temp_file",
            "",
            "        im = hopper()",
            "        im.save(fp)",
            "",
            "    def test_tempfile(self):",
            "        # see #1460, pathlib support breaks tempfile.TemporaryFile on py27",
            "        # Will error out on save on 3.0.0",
            "        im = hopper()",
            "        with tempfile.TemporaryFile() as fp:",
            "            im.save(fp, \"JPEG\")",
            "            fp.seek(0)",
            "            with Image.open(fp) as reloaded:",
            "                assert_image_similar(im, reloaded, 20)",
            "",
            "    def test_unknown_extension(self, tmp_path):",
            "        im = hopper()",
            "        temp_file = str(tmp_path / \"temp.unknown\")",
            "        with pytest.raises(ValueError):",
            "            im.save(temp_file)",
            "",
            "    def test_internals(self):",
            "        im = Image.new(\"L\", (100, 100))",
            "        im.readonly = 1",
            "        im._copy()",
            "        assert not im.readonly",
            "",
            "        im.readonly = 1",
            "        im.paste(0, (0, 0, 100, 100))",
            "        assert not im.readonly",
            "",
            "    @pytest.mark.skipif(is_win32(), reason=\"Test requires opening tempfile twice\")",
            "    def test_readonly_save(self, tmp_path):",
            "        temp_file = str(tmp_path / \"temp.bmp\")",
            "        shutil.copy(\"Tests/images/rgb32bf-rgba.bmp\", temp_file)",
            "",
            "        with Image.open(temp_file) as im:",
            "            assert im.readonly",
            "            im.save(temp_file)",
            "",
            "    def test_dump(self, tmp_path):",
            "        im = Image.new(\"L\", (10, 10))",
            "        im._dump(str(tmp_path / \"temp_L.ppm\"))",
            "",
            "        im = Image.new(\"RGB\", (10, 10))",
            "        im._dump(str(tmp_path / \"temp_RGB.ppm\"))",
            "",
            "        im = Image.new(\"HSV\", (10, 10))",
            "        with pytest.raises(ValueError):",
            "            im._dump(str(tmp_path / \"temp_HSV.ppm\"))",
            "",
            "    def test_comparison_with_other_type(self):",
            "        # Arrange",
            "        item = Image.new(\"RGB\", (25, 25), \"#000\")",
            "        num = 12",
            "",
            "        # Act/Assert",
            "        # Shouldn't cause AttributeError (#774)",
            "        assert item is not None",
            "        assert item != num",
            "",
            "    def test_expand_x(self):",
            "        # Arrange",
            "        im = hopper()",
            "        orig_size = im.size",
            "        xmargin = 5",
            "",
            "        # Act",
            "        im = im._expand(xmargin)",
            "",
            "        # Assert",
            "        assert im.size[0] == orig_size[0] + 2 * xmargin",
            "        assert im.size[1] == orig_size[1] + 2 * xmargin",
            "",
            "    def test_expand_xy(self):",
            "        # Arrange",
            "        im = hopper()",
            "        orig_size = im.size",
            "        xmargin = 5",
            "        ymargin = 3",
            "",
            "        # Act",
            "        im = im._expand(xmargin, ymargin)",
            "",
            "        # Assert",
            "        assert im.size[0] == orig_size[0] + 2 * xmargin",
            "        assert im.size[1] == orig_size[1] + 2 * ymargin",
            "",
            "    def test_getbands(self):",
            "        # Assert",
            "        assert hopper(\"RGB\").getbands() == (\"R\", \"G\", \"B\")",
            "        assert hopper(\"YCbCr\").getbands() == (\"Y\", \"Cb\", \"Cr\")",
            "",
            "    def test_getchannel_wrong_params(self):",
            "        im = hopper()",
            "",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(-1)",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(3)",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(\"Z\")",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(\"1\")",
            "",
            "    def test_getchannel(self):",
            "        im = hopper(\"YCbCr\")",
            "        Y, Cb, Cr = im.split()",
            "",
            "        assert_image_equal(Y, im.getchannel(0))",
            "        assert_image_equal(Y, im.getchannel(\"Y\"))",
            "        assert_image_equal(Cb, im.getchannel(1))",
            "        assert_image_equal(Cb, im.getchannel(\"Cb\"))",
            "        assert_image_equal(Cr, im.getchannel(2))",
            "        assert_image_equal(Cr, im.getchannel(\"Cr\"))",
            "",
            "    def test_getbbox(self):",
            "        # Arrange",
            "        im = hopper()",
            "",
            "        # Act",
            "        bbox = im.getbbox()",
            "",
            "        # Assert",
            "        assert bbox == (0, 0, 128, 128)",
            "",
            "    def test_ne(self):",
            "        # Arrange",
            "        im1 = Image.new(\"RGB\", (25, 25), \"black\")",
            "        im2 = Image.new(\"RGB\", (25, 25), \"white\")",
            "",
            "        # Act / Assert",
            "        assert im1 != im2",
            "",
            "    def test_alpha_composite(self):",
            "        # https://stackoverflow.com/questions/3374878",
            "        # Arrange",
            "        expected_colors = sorted(",
            "            [",
            "                (1122, (128, 127, 0, 255)),",
            "                (1089, (0, 255, 0, 255)),",
            "                (3300, (255, 0, 0, 255)),",
            "                (1156, (170, 85, 0, 192)),",
            "                (1122, (0, 255, 0, 128)),",
            "                (1122, (255, 0, 0, 128)),",
            "                (1089, (0, 255, 0, 0)),",
            "            ]",
            "        )",
            "",
            "        dst = Image.new(\"RGBA\", size=(100, 100), color=(0, 255, 0, 255))",
            "        draw = ImageDraw.Draw(dst)",
            "        draw.rectangle((0, 33, 100, 66), fill=(0, 255, 0, 128))",
            "        draw.rectangle((0, 67, 100, 100), fill=(0, 255, 0, 0))",
            "        src = Image.new(\"RGBA\", size=(100, 100), color=(255, 0, 0, 255))",
            "        draw = ImageDraw.Draw(src)",
            "        draw.rectangle((33, 0, 66, 100), fill=(255, 0, 0, 128))",
            "        draw.rectangle((67, 0, 100, 100), fill=(255, 0, 0, 0))",
            "",
            "        # Act",
            "        img = Image.alpha_composite(dst, src)",
            "",
            "        # Assert",
            "        img_colors = sorted(img.getcolors())",
            "        assert img_colors == expected_colors",
            "",
            "    def test_alpha_inplace(self):",
            "        src = Image.new(\"RGBA\", (128, 128), \"blue\")",
            "",
            "        over = Image.new(\"RGBA\", (128, 128), \"red\")",
            "        mask = hopper(\"L\")",
            "        over.putalpha(mask)",
            "",
            "        target = Image.alpha_composite(src, over)",
            "",
            "        # basic",
            "        full = src.copy()",
            "        full.alpha_composite(over)",
            "        assert_image_equal(full, target)",
            "",
            "        # with offset down to right",
            "        offset = src.copy()",
            "        offset.alpha_composite(over, (64, 64))",
            "        assert_image_equal(offset.crop((64, 64, 127, 127)), target.crop((0, 0, 63, 63)))",
            "        assert offset.size == (128, 128)",
            "",
            "        # offset and crop",
            "        box = src.copy()",
            "        box.alpha_composite(over, (64, 64), (0, 0, 32, 32))",
            "        assert_image_equal(box.crop((64, 64, 96, 96)), target.crop((0, 0, 32, 32)))",
            "        assert_image_equal(box.crop((96, 96, 128, 128)), src.crop((0, 0, 32, 32)))",
            "        assert box.size == (128, 128)",
            "",
            "        # source point",
            "        source = src.copy()",
            "        source.alpha_composite(over, (32, 32), (32, 32, 96, 96))",
            "",
            "        assert_image_equal(source.crop((32, 32, 96, 96)), target.crop((32, 32, 96, 96)))",
            "        assert source.size == (128, 128)",
            "",
            "        # errors",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, \"invalid source\")",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, 0), \"invalid destination\")",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, 0)",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, 0), 0)",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, -1))",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, 0), (0, -1))",
            "",
            "    def test_registered_extensions_uninitialized(self):",
            "        # Arrange",
            "        Image._initialized = 0",
            "        extension = Image.EXTENSION",
            "        Image.EXTENSION = {}",
            "",
            "        # Act",
            "        Image.registered_extensions()",
            "",
            "        # Assert",
            "        assert Image._initialized == 2",
            "",
            "        # Restore the original state and assert",
            "        Image.EXTENSION = extension",
            "        assert Image.EXTENSION",
            "",
            "    def test_registered_extensions(self):",
            "        # Arrange",
            "        # Open an image to trigger plugin registration",
            "        with Image.open(\"Tests/images/rgb.jpg\"):",
            "            pass",
            "",
            "        # Act",
            "        extensions = Image.registered_extensions()",
            "",
            "        # Assert",
            "        assert extensions",
            "        for ext in [\".cur\", \".icns\", \".tif\", \".tiff\"]:",
            "            assert ext in extensions",
            "",
            "    def test_effect_mandelbrot(self):",
            "        # Arrange",
            "        size = (512, 512)",
            "        extent = (-3, -2.5, 2, 2.5)",
            "        quality = 100",
            "",
            "        # Act",
            "        im = Image.effect_mandelbrot(size, extent, quality)",
            "",
            "        # Assert",
            "        assert im.size == (512, 512)",
            "        with Image.open(\"Tests/images/effect_mandelbrot.png\") as im2:",
            "            assert_image_equal(im, im2)",
            "",
            "    def test_effect_mandelbrot_bad_arguments(self):",
            "        # Arrange",
            "        size = (512, 512)",
            "        # Get coordinates the wrong way round:",
            "        extent = (+3, +2.5, -2, -2.5)",
            "        # Quality < 2:",
            "        quality = 1",
            "",
            "        # Act/Assert",
            "        with pytest.raises(ValueError):",
            "            Image.effect_mandelbrot(size, extent, quality)",
            "",
            "    def test_effect_noise(self):",
            "        # Arrange",
            "        size = (100, 100)",
            "        sigma = 128",
            "",
            "        # Act",
            "        im = Image.effect_noise(size, sigma)",
            "",
            "        # Assert",
            "        assert im.size == (100, 100)",
            "        assert im.mode == \"L\"",
            "        p0 = im.getpixel((0, 0))",
            "        p1 = im.getpixel((0, 1))",
            "        p2 = im.getpixel((0, 2))",
            "        p3 = im.getpixel((0, 3))",
            "        p4 = im.getpixel((0, 4))",
            "        assert_not_all_same([p0, p1, p2, p3, p4])",
            "",
            "    def test_effect_spread(self):",
            "        # Arrange",
            "        im = hopper()",
            "        distance = 10",
            "",
            "        # Act",
            "        im2 = im.effect_spread(distance)",
            "",
            "        # Assert",
            "        assert im.size == (128, 128)",
            "        with Image.open(\"Tests/images/effect_spread.png\") as im3:",
            "            assert_image_similar(im2, im3, 110)",
            "",
            "    def test_effect_spread_zero(self):",
            "        # Arrange",
            "        im = hopper()",
            "        distance = 0",
            "",
            "        # Act",
            "        im2 = im.effect_spread(distance)",
            "",
            "        # Assert",
            "        assert_image_equal(im, im2)",
            "",
            "    def test_check_size(self):",
            "        # Checking that the _check_size function throws value errors when we want it to",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"RGB\", 0)  # not a tuple",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"RGB\", (0,))  # Tuple too short",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"RGB\", (-1, -1))  # w,h < 0",
            "",
            "        # this should pass with 0 sized images, #2259",
            "        im = Image.new(\"L\", (0, 0))",
            "        assert im.size == (0, 0)",
            "",
            "        im = Image.new(\"L\", (0, 100))",
            "        assert im.size == (0, 100)",
            "",
            "        im = Image.new(\"L\", (100, 0))",
            "        assert im.size == (100, 0)",
            "",
            "        assert Image.new(\"RGB\", (1, 1))",
            "        # Should pass lists too",
            "        i = Image.new(\"RGB\", [1, 1])",
            "        assert isinstance(i.size, tuple)",
            "",
            "    def test_storage_neg(self):",
            "        # Storage.c accepted negative values for xsize, ysize.  Was",
            "        # test_neg_ppm, but the core function for that has been",
            "        # removed Calling directly into core to test the error in",
            "        # Storage.c, rather than the size check above",
            "",
            "        with pytest.raises(ValueError):",
            "            Image.core.fill(\"RGB\", (2, -2), (0, 0, 0))",
            "",
            "    def test_one_item_tuple(self):",
            "        for mode in (\"I\", \"F\", \"L\"):",
            "            im = Image.new(mode, (100, 100), (5,))",
            "            px = im.load()",
            "            assert px[0, 0] == 5",
            "",
            "    def test_linear_gradient_wrong_mode(self):",
            "        # Arrange",
            "        wrong_mode = \"RGB\"",
            "",
            "        # Act / Assert",
            "        with pytest.raises(ValueError):",
            "            Image.linear_gradient(wrong_mode)",
            "",
            "    def test_linear_gradient(self):",
            "",
            "        # Arrange",
            "        target_file = \"Tests/images/linear_gradient.png\"",
            "        for mode in [\"L\", \"P\"]:",
            "",
            "            # Act",
            "            im = Image.linear_gradient(mode)",
            "",
            "            # Assert",
            "            assert im.size == (256, 256)",
            "            assert im.mode == mode",
            "            assert im.getpixel((0, 0)) == 0",
            "            assert im.getpixel((255, 255)) == 255",
            "            with Image.open(target_file) as target:",
            "                target = target.convert(mode)",
            "            assert_image_equal(im, target)",
            "",
            "    def test_radial_gradient_wrong_mode(self):",
            "        # Arrange",
            "        wrong_mode = \"RGB\"",
            "",
            "        # Act / Assert",
            "        with pytest.raises(ValueError):",
            "            Image.radial_gradient(wrong_mode)",
            "",
            "    def test_radial_gradient(self):",
            "",
            "        # Arrange",
            "        target_file = \"Tests/images/radial_gradient.png\"",
            "        for mode in [\"L\", \"P\"]:",
            "",
            "            # Act",
            "            im = Image.radial_gradient(mode)",
            "",
            "            # Assert",
            "            assert im.size == (256, 256)",
            "            assert im.mode == mode",
            "            assert im.getpixel((0, 0)) == 255",
            "            assert im.getpixel((128, 128)) == 0",
            "            with Image.open(target_file) as target:",
            "                target = target.convert(mode)",
            "            assert_image_equal(im, target)",
            "",
            "    def test_register_extensions(self):",
            "        test_format = \"a\"",
            "        exts = [\"b\", \"c\"]",
            "        for ext in exts:",
            "            Image.register_extension(test_format, ext)",
            "        ext_individual = Image.EXTENSION.copy()",
            "        for ext in exts:",
            "            del Image.EXTENSION[ext]",
            "",
            "        Image.register_extensions(test_format, exts)",
            "        ext_multiple = Image.EXTENSION.copy()",
            "        for ext in exts:",
            "            del Image.EXTENSION[ext]",
            "",
            "        assert ext_individual == ext_multiple",
            "",
            "    def test_remap_palette(self):",
            "        # Test illegal image mode",
            "        with hopper() as im:",
            "            with pytest.raises(ValueError):",
            "                im.remap_palette(None)",
            "",
            "    def test__new(self):",
            "        im = hopper(\"RGB\")",
            "        im_p = hopper(\"P\")",
            "",
            "        blank_p = Image.new(\"P\", (10, 10))",
            "        blank_pa = Image.new(\"PA\", (10, 10))",
            "        blank_p.palette = None",
            "        blank_pa.palette = None",
            "",
            "        def _make_new(base_image, im, palette_result=None):",
            "            new_im = base_image._new(im)",
            "            assert new_im.mode == im.mode",
            "            assert new_im.size == im.size",
            "            assert new_im.info == base_image.info",
            "            if palette_result is not None:",
            "                assert new_im.palette.tobytes() == palette_result.tobytes()",
            "            else:",
            "                assert new_im.palette is None",
            "",
            "        _make_new(im, im_p, im_p.palette)",
            "        _make_new(im_p, im, None)",
            "        _make_new(im, blank_p, ImagePalette.ImagePalette())",
            "        _make_new(im, blank_pa, ImagePalette.ImagePalette())",
            "",
            "    def test_p_from_rgb_rgba(self):",
            "        for mode, color in [",
            "            (\"RGB\", \"#DDEEFF\"),",
            "            (\"RGB\", (221, 238, 255)),",
            "            (\"RGBA\", (221, 238, 255, 255)),",
            "        ]:",
            "            im = Image.new(\"P\", (100, 100), color)",
            "            expected = Image.new(mode, (100, 100), color)",
            "            assert_image_equal(im.convert(mode), expected)",
            "",
            "    def test_showxv_deprecation(self):",
            "        class TestViewer(ImageShow.Viewer):",
            "            def show_image(self, image, **options):",
            "                return True",
            "",
            "        viewer = TestViewer()",
            "        ImageShow.register(viewer, -1)",
            "",
            "        im = Image.new(\"RGB\", (50, 50), \"white\")",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            Image._showxv(im)",
            "",
            "        # Restore original state",
            "        ImageShow._viewers.pop(0)",
            "",
            "    def test_no_resource_warning_on_save(self, tmp_path):",
            "        # https://github.com/python-pillow/Pillow/issues/835",
            "        # Arrange",
            "        test_file = \"Tests/images/hopper.png\"",
            "        temp_file = str(tmp_path / \"temp.jpg\")",
            "",
            "        # Act/Assert",
            "        with Image.open(test_file) as im:",
            "            pytest.warns(None, im.save, temp_file)",
            "",
            "    def test_load_on_nonexclusive_multiframe(self):",
            "        with open(\"Tests/images/frozenpond.mpo\", \"rb\") as fp:",
            "",
            "            def act(fp):",
            "                im = Image.open(fp)",
            "                im.load()",
            "",
            "            act(fp)",
            "",
            "            with Image.open(fp) as im:",
            "                im.load()",
            "",
            "            assert not fp.closed",
            "",
            "    def test_exif_jpeg(self, tmp_path):",
            "        with Image.open(\"Tests/images/exif-72dpi-int.jpg\") as im:  # Little endian",
            "            exif = im.getexif()",
            "            assert 258 not in exif",
            "            assert 274 in exif",
            "            assert 40960 in exif",
            "            assert exif[40963] == 450",
            "            assert exif[11] == \"gThumb 3.0.1\"",
            "",
            "            out = str(tmp_path / \"temp.jpg\")",
            "            exif[258] = 8",
            "            del exif[274]",
            "            del exif[40960]",
            "            exif[40963] = 455",
            "            exif[11] = \"Pillow test\"",
            "            im.save(out, exif=exif)",
            "        with Image.open(out) as reloaded:",
            "            reloaded_exif = reloaded.getexif()",
            "            assert reloaded_exif[258] == 8",
            "            assert 274 not in reloaded_exif",
            "            assert 40960 not in reloaded_exif",
            "            assert reloaded_exif[40963] == 455",
            "            assert reloaded_exif[11] == \"Pillow test\"",
            "",
            "        with Image.open(\"Tests/images/no-dpi-in-exif.jpg\") as im:  # Big endian",
            "            exif = im.getexif()",
            "            assert 258 not in exif",
            "            assert 40962 in exif",
            "            assert exif[40963] == 200",
            "            assert exif[305] == \"Adobe Photoshop CC 2017 (Macintosh)\"",
            "",
            "            out = str(tmp_path / \"temp.jpg\")",
            "            exif[258] = 8",
            "            del exif[34665]",
            "            exif[40963] = 455",
            "            exif[305] = \"Pillow test\"",
            "            im.save(out, exif=exif)",
            "        with Image.open(out) as reloaded:",
            "            reloaded_exif = reloaded.getexif()",
            "            assert reloaded_exif[258] == 8",
            "            assert 34665 not in reloaded_exif",
            "            assert reloaded_exif[40963] == 455",
            "            assert reloaded_exif[305] == \"Pillow test\"",
            "",
            "    @skip_unless_feature(\"webp\")",
            "    @skip_unless_feature(\"webp_anim\")",
            "    def test_exif_webp(self, tmp_path):",
            "        with Image.open(\"Tests/images/hopper.webp\") as im:",
            "            exif = im.getexif()",
            "            assert exif == {}",
            "",
            "            out = str(tmp_path / \"temp.webp\")",
            "            exif[258] = 8",
            "            exif[40963] = 455",
            "            exif[305] = \"Pillow test\"",
            "",
            "            def check_exif():",
            "                with Image.open(out) as reloaded:",
            "                    reloaded_exif = reloaded.getexif()",
            "                    assert reloaded_exif[258] == 8",
            "                    assert reloaded_exif[40963] == 455",
            "                    assert reloaded_exif[305] == \"Pillow test\"",
            "",
            "            im.save(out, exif=exif)",
            "            check_exif()",
            "            im.save(out, exif=exif, save_all=True)",
            "            check_exif()",
            "",
            "    def test_exif_png(self, tmp_path):",
            "        with Image.open(\"Tests/images/exif.png\") as im:",
            "            exif = im.getexif()",
            "            assert exif == {274: 1}",
            "",
            "            out = str(tmp_path / \"temp.png\")",
            "            exif[258] = 8",
            "            del exif[274]",
            "            exif[40963] = 455",
            "            exif[305] = \"Pillow test\"",
            "            im.save(out, exif=exif)",
            "",
            "        with Image.open(out) as reloaded:",
            "            reloaded_exif = reloaded.getexif()",
            "            assert reloaded_exif == {258: 8, 40963: 455, 305: \"Pillow test\"}",
            "",
            "    def test_exif_interop(self):",
            "        with Image.open(\"Tests/images/flower.jpg\") as im:",
            "            exif = im.getexif()",
            "            assert exif.get_ifd(0xA005) == {",
            "                1: \"R98\",",
            "                2: b\"0100\",",
            "                4097: 2272,",
            "                4098: 1704,",
            "            }",
            "",
            "    @pytest.mark.parametrize(",
            "        \"test_module\",",
            "        [PIL, Image],",
            "    )",
            "    def test_pillow_version(self, test_module):",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION == PIL.__version__",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            str(test_module.PILLOW_VERSION)",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert int(test_module.PILLOW_VERSION[0]) >= 7",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION < \"9.9.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION <= \"9.9.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION != \"7.0.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION >= \"7.0.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION > \"7.0.0\"",
            "",
            "    def test_overrun(self):",
            "        \"\"\"For overrun completeness, test as:",
            "        valgrind pytest -qq Tests/test_image.py::TestImage::test_overrun | grep decode.c",
            "        \"\"\"",
            "        for file in [",
            "            \"fli_overrun.bin\",",
            "            \"sgi_overrun.bin\",",
            "            \"sgi_overrun_expandrow.bin\",",
            "            \"sgi_overrun_expandrow2.bin\",",
            "            \"pcx_overrun.bin\",",
            "            \"pcx_overrun2.bin\",",
            "            \"01r_00.pcx\",",
            "        ]:",
            "            with Image.open(os.path.join(\"Tests/images\", file)) as im:",
            "                try:",
            "                    im.load()",
            "                    assert False",
            "                except OSError as e:",
            "                    assert str(e) == \"buffer overrun when reading image file\"",
            "",
            "        with Image.open(\"Tests/images/fli_overrun2.bin\") as im:",
            "            try:",
            "                im.seek(1)",
            "                assert False",
            "            except OSError as e:",
            "                assert str(e) == \"buffer overrun when reading image file\"",
            "",
            "    def test_show_deprecation(self, monkeypatch):",
            "        monkeypatch.setattr(Image, \"_show\", lambda *args, **kwargs: None)",
            "",
            "        im = Image.new(\"RGB\", (50, 50), \"white\")",
            "",
            "        with pytest.warns(None) as raised:",
            "            im.show()",
            "        assert not raised",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            im.show(command=\"mock\")",
            "",
            "",
            "class MockEncoder:",
            "    pass",
            "",
            "",
            "def mock_encode(*args):",
            "    encoder = MockEncoder()",
            "    encoder.args = args",
            "    return encoder",
            "",
            "",
            "class TestRegistry:",
            "    def test_encode_registry(self):",
            "",
            "        Image.register_encoder(\"MOCK\", mock_encode)",
            "        assert \"MOCK\" in Image.ENCODERS",
            "",
            "        enc = Image._getencoder(\"RGB\", \"MOCK\", (\"args\",), extra=(\"extra\",))",
            "",
            "        assert isinstance(enc, MockEncoder)",
            "        assert enc.args == (\"RGB\", \"args\", \"extra\")",
            "",
            "    def test_encode_registry_fail(self):",
            "        with pytest.raises(OSError):",
            "            Image._getencoder(\"RGB\", \"DoesNotExist\", (\"args\",), extra=(\"extra\",))"
        ],
        "afterPatchFile": [
            "import io",
            "import os",
            "import shutil",
            "import tempfile",
            "",
            "import pytest",
            "",
            "import PIL",
            "from PIL import Image, ImageDraw, ImagePalette, ImageShow, UnidentifiedImageError",
            "",
            "from .helper import (",
            "    assert_image_equal,",
            "    assert_image_similar,",
            "    assert_not_all_same,",
            "    hopper,",
            "    is_win32,",
            "    skip_unless_feature,",
            ")",
            "",
            "",
            "class TestImage:",
            "    def test_image_modes_success(self):",
            "        for mode in [",
            "            \"1\",",
            "            \"P\",",
            "            \"PA\",",
            "            \"L\",",
            "            \"LA\",",
            "            \"La\",",
            "            \"F\",",
            "            \"I\",",
            "            \"I;16\",",
            "            \"I;16L\",",
            "            \"I;16B\",",
            "            \"I;16N\",",
            "            \"RGB\",",
            "            \"RGBX\",",
            "            \"RGBA\",",
            "            \"RGBa\",",
            "            \"CMYK\",",
            "            \"YCbCr\",",
            "            \"LAB\",",
            "            \"HSV\",",
            "        ]:",
            "            Image.new(mode, (1, 1))",
            "",
            "    def test_image_modes_fail(self):",
            "        for mode in [",
            "            \"\",",
            "            \"bad\",",
            "            \"very very long\",",
            "            \"BGR;15\",",
            "            \"BGR;16\",",
            "            \"BGR;24\",",
            "            \"BGR;32\",",
            "        ]:",
            "            with pytest.raises(ValueError) as e:",
            "                Image.new(mode, (1, 1))",
            "            assert str(e.value) == \"unrecognized image mode\"",
            "",
            "    def test_exception_inheritance(self):",
            "        assert issubclass(UnidentifiedImageError, OSError)",
            "",
            "    def test_sanity(self):",
            "",
            "        im = Image.new(\"L\", (100, 100))",
            "        assert repr(im)[:45] == \"<PIL.Image.Image image mode=L size=100x100 at\"",
            "        assert im.mode == \"L\"",
            "        assert im.size == (100, 100)",
            "",
            "        im = Image.new(\"RGB\", (100, 100))",
            "        assert repr(im)[:45] == \"<PIL.Image.Image image mode=RGB size=100x100 \"",
            "        assert im.mode == \"RGB\"",
            "        assert im.size == (100, 100)",
            "",
            "        Image.new(\"L\", (100, 100), None)",
            "        im2 = Image.new(\"L\", (100, 100), 0)",
            "        im3 = Image.new(\"L\", (100, 100), \"black\")",
            "",
            "        assert im2.getcolors() == [(10000, 0)]",
            "        assert im3.getcolors() == [(10000, 0)]",
            "",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"X\", (100, 100))",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"\", (100, 100))",
            "        # with pytest.raises(MemoryError):",
            "        #   Image.new(\"L\", (1000000, 1000000))",
            "",
            "    def test_open_formats(self):",
            "        PNGFILE = \"Tests/images/hopper.png\"",
            "        JPGFILE = \"Tests/images/hopper.jpg\"",
            "",
            "        with pytest.raises(TypeError):",
            "            Image.open(PNGFILE, formats=123)",
            "",
            "        for formats in [[\"JPEG\"], (\"JPEG\",)]:",
            "            with pytest.raises(UnidentifiedImageError):",
            "                Image.open(PNGFILE, formats=formats)",
            "",
            "            with Image.open(JPGFILE, formats=formats) as im:",
            "                assert im.mode == \"RGB\"",
            "                assert im.size == (128, 128)",
            "",
            "        for file in [PNGFILE, JPGFILE]:",
            "            with Image.open(file, formats=None) as im:",
            "                assert im.mode == \"RGB\"",
            "                assert im.size == (128, 128)",
            "",
            "    def test_width_height(self):",
            "        im = Image.new(\"RGB\", (1, 2))",
            "        assert im.width == 1",
            "        assert im.height == 2",
            "",
            "        with pytest.raises(AttributeError):",
            "            im.size = (3, 4)",
            "",
            "    def test_invalid_image(self):",
            "        import io",
            "",
            "        im = io.BytesIO(b\"\")",
            "        with pytest.raises(UnidentifiedImageError):",
            "            Image.open(im)",
            "",
            "    def test_bad_mode(self):",
            "        with pytest.raises(ValueError):",
            "            Image.open(\"filename\", \"bad mode\")",
            "",
            "    def test_stringio(self):",
            "        with pytest.raises(ValueError):",
            "            Image.open(io.StringIO())",
            "",
            "    def test_pathlib(self, tmp_path):",
            "        from PIL.Image import Path",
            "",
            "        with Image.open(Path(\"Tests/images/multipage-mmap.tiff\")) as im:",
            "            assert im.mode == \"P\"",
            "            assert im.size == (10, 10)",
            "",
            "        with Image.open(Path(\"Tests/images/hopper.jpg\")) as im:",
            "            assert im.mode == \"RGB\"",
            "            assert im.size == (128, 128)",
            "",
            "            temp_file = str(tmp_path / \"temp.jpg\")",
            "            if os.path.exists(temp_file):",
            "                os.remove(temp_file)",
            "            im.save(Path(temp_file))",
            "",
            "    def test_fp_name(self, tmp_path):",
            "        temp_file = str(tmp_path / \"temp.jpg\")",
            "",
            "        class FP:",
            "            def write(a, b):",
            "                pass",
            "",
            "        fp = FP()",
            "        fp.name = temp_file",
            "",
            "        im = hopper()",
            "        im.save(fp)",
            "",
            "    def test_tempfile(self):",
            "        # see #1460, pathlib support breaks tempfile.TemporaryFile on py27",
            "        # Will error out on save on 3.0.0",
            "        im = hopper()",
            "        with tempfile.TemporaryFile() as fp:",
            "            im.save(fp, \"JPEG\")",
            "            fp.seek(0)",
            "            with Image.open(fp) as reloaded:",
            "                assert_image_similar(im, reloaded, 20)",
            "",
            "    def test_unknown_extension(self, tmp_path):",
            "        im = hopper()",
            "        temp_file = str(tmp_path / \"temp.unknown\")",
            "        with pytest.raises(ValueError):",
            "            im.save(temp_file)",
            "",
            "    def test_internals(self):",
            "        im = Image.new(\"L\", (100, 100))",
            "        im.readonly = 1",
            "        im._copy()",
            "        assert not im.readonly",
            "",
            "        im.readonly = 1",
            "        im.paste(0, (0, 0, 100, 100))",
            "        assert not im.readonly",
            "",
            "    @pytest.mark.skipif(is_win32(), reason=\"Test requires opening tempfile twice\")",
            "    def test_readonly_save(self, tmp_path):",
            "        temp_file = str(tmp_path / \"temp.bmp\")",
            "        shutil.copy(\"Tests/images/rgb32bf-rgba.bmp\", temp_file)",
            "",
            "        with Image.open(temp_file) as im:",
            "            assert im.readonly",
            "            im.save(temp_file)",
            "",
            "    def test_dump(self, tmp_path):",
            "        im = Image.new(\"L\", (10, 10))",
            "        im._dump(str(tmp_path / \"temp_L.ppm\"))",
            "",
            "        im = Image.new(\"RGB\", (10, 10))",
            "        im._dump(str(tmp_path / \"temp_RGB.ppm\"))",
            "",
            "        im = Image.new(\"HSV\", (10, 10))",
            "        with pytest.raises(ValueError):",
            "            im._dump(str(tmp_path / \"temp_HSV.ppm\"))",
            "",
            "    def test_comparison_with_other_type(self):",
            "        # Arrange",
            "        item = Image.new(\"RGB\", (25, 25), \"#000\")",
            "        num = 12",
            "",
            "        # Act/Assert",
            "        # Shouldn't cause AttributeError (#774)",
            "        assert item is not None",
            "        assert item != num",
            "",
            "    def test_expand_x(self):",
            "        # Arrange",
            "        im = hopper()",
            "        orig_size = im.size",
            "        xmargin = 5",
            "",
            "        # Act",
            "        im = im._expand(xmargin)",
            "",
            "        # Assert",
            "        assert im.size[0] == orig_size[0] + 2 * xmargin",
            "        assert im.size[1] == orig_size[1] + 2 * xmargin",
            "",
            "    def test_expand_xy(self):",
            "        # Arrange",
            "        im = hopper()",
            "        orig_size = im.size",
            "        xmargin = 5",
            "        ymargin = 3",
            "",
            "        # Act",
            "        im = im._expand(xmargin, ymargin)",
            "",
            "        # Assert",
            "        assert im.size[0] == orig_size[0] + 2 * xmargin",
            "        assert im.size[1] == orig_size[1] + 2 * ymargin",
            "",
            "    def test_getbands(self):",
            "        # Assert",
            "        assert hopper(\"RGB\").getbands() == (\"R\", \"G\", \"B\")",
            "        assert hopper(\"YCbCr\").getbands() == (\"Y\", \"Cb\", \"Cr\")",
            "",
            "    def test_getchannel_wrong_params(self):",
            "        im = hopper()",
            "",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(-1)",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(3)",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(\"Z\")",
            "        with pytest.raises(ValueError):",
            "            im.getchannel(\"1\")",
            "",
            "    def test_getchannel(self):",
            "        im = hopper(\"YCbCr\")",
            "        Y, Cb, Cr = im.split()",
            "",
            "        assert_image_equal(Y, im.getchannel(0))",
            "        assert_image_equal(Y, im.getchannel(\"Y\"))",
            "        assert_image_equal(Cb, im.getchannel(1))",
            "        assert_image_equal(Cb, im.getchannel(\"Cb\"))",
            "        assert_image_equal(Cr, im.getchannel(2))",
            "        assert_image_equal(Cr, im.getchannel(\"Cr\"))",
            "",
            "    def test_getbbox(self):",
            "        # Arrange",
            "        im = hopper()",
            "",
            "        # Act",
            "        bbox = im.getbbox()",
            "",
            "        # Assert",
            "        assert bbox == (0, 0, 128, 128)",
            "",
            "    def test_ne(self):",
            "        # Arrange",
            "        im1 = Image.new(\"RGB\", (25, 25), \"black\")",
            "        im2 = Image.new(\"RGB\", (25, 25), \"white\")",
            "",
            "        # Act / Assert",
            "        assert im1 != im2",
            "",
            "    def test_alpha_composite(self):",
            "        # https://stackoverflow.com/questions/3374878",
            "        # Arrange",
            "        expected_colors = sorted(",
            "            [",
            "                (1122, (128, 127, 0, 255)),",
            "                (1089, (0, 255, 0, 255)),",
            "                (3300, (255, 0, 0, 255)),",
            "                (1156, (170, 85, 0, 192)),",
            "                (1122, (0, 255, 0, 128)),",
            "                (1122, (255, 0, 0, 128)),",
            "                (1089, (0, 255, 0, 0)),",
            "            ]",
            "        )",
            "",
            "        dst = Image.new(\"RGBA\", size=(100, 100), color=(0, 255, 0, 255))",
            "        draw = ImageDraw.Draw(dst)",
            "        draw.rectangle((0, 33, 100, 66), fill=(0, 255, 0, 128))",
            "        draw.rectangle((0, 67, 100, 100), fill=(0, 255, 0, 0))",
            "        src = Image.new(\"RGBA\", size=(100, 100), color=(255, 0, 0, 255))",
            "        draw = ImageDraw.Draw(src)",
            "        draw.rectangle((33, 0, 66, 100), fill=(255, 0, 0, 128))",
            "        draw.rectangle((67, 0, 100, 100), fill=(255, 0, 0, 0))",
            "",
            "        # Act",
            "        img = Image.alpha_composite(dst, src)",
            "",
            "        # Assert",
            "        img_colors = sorted(img.getcolors())",
            "        assert img_colors == expected_colors",
            "",
            "    def test_alpha_inplace(self):",
            "        src = Image.new(\"RGBA\", (128, 128), \"blue\")",
            "",
            "        over = Image.new(\"RGBA\", (128, 128), \"red\")",
            "        mask = hopper(\"L\")",
            "        over.putalpha(mask)",
            "",
            "        target = Image.alpha_composite(src, over)",
            "",
            "        # basic",
            "        full = src.copy()",
            "        full.alpha_composite(over)",
            "        assert_image_equal(full, target)",
            "",
            "        # with offset down to right",
            "        offset = src.copy()",
            "        offset.alpha_composite(over, (64, 64))",
            "        assert_image_equal(offset.crop((64, 64, 127, 127)), target.crop((0, 0, 63, 63)))",
            "        assert offset.size == (128, 128)",
            "",
            "        # offset and crop",
            "        box = src.copy()",
            "        box.alpha_composite(over, (64, 64), (0, 0, 32, 32))",
            "        assert_image_equal(box.crop((64, 64, 96, 96)), target.crop((0, 0, 32, 32)))",
            "        assert_image_equal(box.crop((96, 96, 128, 128)), src.crop((0, 0, 32, 32)))",
            "        assert box.size == (128, 128)",
            "",
            "        # source point",
            "        source = src.copy()",
            "        source.alpha_composite(over, (32, 32), (32, 32, 96, 96))",
            "",
            "        assert_image_equal(source.crop((32, 32, 96, 96)), target.crop((32, 32, 96, 96)))",
            "        assert source.size == (128, 128)",
            "",
            "        # errors",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, \"invalid source\")",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, 0), \"invalid destination\")",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, 0)",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, 0), 0)",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, -1))",
            "        with pytest.raises(ValueError):",
            "            source.alpha_composite(over, (0, 0), (0, -1))",
            "",
            "    def test_registered_extensions_uninitialized(self):",
            "        # Arrange",
            "        Image._initialized = 0",
            "        extension = Image.EXTENSION",
            "        Image.EXTENSION = {}",
            "",
            "        # Act",
            "        Image.registered_extensions()",
            "",
            "        # Assert",
            "        assert Image._initialized == 2",
            "",
            "        # Restore the original state and assert",
            "        Image.EXTENSION = extension",
            "        assert Image.EXTENSION",
            "",
            "    def test_registered_extensions(self):",
            "        # Arrange",
            "        # Open an image to trigger plugin registration",
            "        with Image.open(\"Tests/images/rgb.jpg\"):",
            "            pass",
            "",
            "        # Act",
            "        extensions = Image.registered_extensions()",
            "",
            "        # Assert",
            "        assert extensions",
            "        for ext in [\".cur\", \".icns\", \".tif\", \".tiff\"]:",
            "            assert ext in extensions",
            "",
            "    def test_effect_mandelbrot(self):",
            "        # Arrange",
            "        size = (512, 512)",
            "        extent = (-3, -2.5, 2, 2.5)",
            "        quality = 100",
            "",
            "        # Act",
            "        im = Image.effect_mandelbrot(size, extent, quality)",
            "",
            "        # Assert",
            "        assert im.size == (512, 512)",
            "        with Image.open(\"Tests/images/effect_mandelbrot.png\") as im2:",
            "            assert_image_equal(im, im2)",
            "",
            "    def test_effect_mandelbrot_bad_arguments(self):",
            "        # Arrange",
            "        size = (512, 512)",
            "        # Get coordinates the wrong way round:",
            "        extent = (+3, +2.5, -2, -2.5)",
            "        # Quality < 2:",
            "        quality = 1",
            "",
            "        # Act/Assert",
            "        with pytest.raises(ValueError):",
            "            Image.effect_mandelbrot(size, extent, quality)",
            "",
            "    def test_effect_noise(self):",
            "        # Arrange",
            "        size = (100, 100)",
            "        sigma = 128",
            "",
            "        # Act",
            "        im = Image.effect_noise(size, sigma)",
            "",
            "        # Assert",
            "        assert im.size == (100, 100)",
            "        assert im.mode == \"L\"",
            "        p0 = im.getpixel((0, 0))",
            "        p1 = im.getpixel((0, 1))",
            "        p2 = im.getpixel((0, 2))",
            "        p3 = im.getpixel((0, 3))",
            "        p4 = im.getpixel((0, 4))",
            "        assert_not_all_same([p0, p1, p2, p3, p4])",
            "",
            "    def test_effect_spread(self):",
            "        # Arrange",
            "        im = hopper()",
            "        distance = 10",
            "",
            "        # Act",
            "        im2 = im.effect_spread(distance)",
            "",
            "        # Assert",
            "        assert im.size == (128, 128)",
            "        with Image.open(\"Tests/images/effect_spread.png\") as im3:",
            "            assert_image_similar(im2, im3, 110)",
            "",
            "    def test_effect_spread_zero(self):",
            "        # Arrange",
            "        im = hopper()",
            "        distance = 0",
            "",
            "        # Act",
            "        im2 = im.effect_spread(distance)",
            "",
            "        # Assert",
            "        assert_image_equal(im, im2)",
            "",
            "    def test_check_size(self):",
            "        # Checking that the _check_size function throws value errors when we want it to",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"RGB\", 0)  # not a tuple",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"RGB\", (0,))  # Tuple too short",
            "        with pytest.raises(ValueError):",
            "            Image.new(\"RGB\", (-1, -1))  # w,h < 0",
            "",
            "        # this should pass with 0 sized images, #2259",
            "        im = Image.new(\"L\", (0, 0))",
            "        assert im.size == (0, 0)",
            "",
            "        im = Image.new(\"L\", (0, 100))",
            "        assert im.size == (0, 100)",
            "",
            "        im = Image.new(\"L\", (100, 0))",
            "        assert im.size == (100, 0)",
            "",
            "        assert Image.new(\"RGB\", (1, 1))",
            "        # Should pass lists too",
            "        i = Image.new(\"RGB\", [1, 1])",
            "        assert isinstance(i.size, tuple)",
            "",
            "    def test_storage_neg(self):",
            "        # Storage.c accepted negative values for xsize, ysize.  Was",
            "        # test_neg_ppm, but the core function for that has been",
            "        # removed Calling directly into core to test the error in",
            "        # Storage.c, rather than the size check above",
            "",
            "        with pytest.raises(ValueError):",
            "            Image.core.fill(\"RGB\", (2, -2), (0, 0, 0))",
            "",
            "    def test_one_item_tuple(self):",
            "        for mode in (\"I\", \"F\", \"L\"):",
            "            im = Image.new(mode, (100, 100), (5,))",
            "            px = im.load()",
            "            assert px[0, 0] == 5",
            "",
            "    def test_linear_gradient_wrong_mode(self):",
            "        # Arrange",
            "        wrong_mode = \"RGB\"",
            "",
            "        # Act / Assert",
            "        with pytest.raises(ValueError):",
            "            Image.linear_gradient(wrong_mode)",
            "",
            "    def test_linear_gradient(self):",
            "",
            "        # Arrange",
            "        target_file = \"Tests/images/linear_gradient.png\"",
            "        for mode in [\"L\", \"P\"]:",
            "",
            "            # Act",
            "            im = Image.linear_gradient(mode)",
            "",
            "            # Assert",
            "            assert im.size == (256, 256)",
            "            assert im.mode == mode",
            "            assert im.getpixel((0, 0)) == 0",
            "            assert im.getpixel((255, 255)) == 255",
            "            with Image.open(target_file) as target:",
            "                target = target.convert(mode)",
            "            assert_image_equal(im, target)",
            "",
            "    def test_radial_gradient_wrong_mode(self):",
            "        # Arrange",
            "        wrong_mode = \"RGB\"",
            "",
            "        # Act / Assert",
            "        with pytest.raises(ValueError):",
            "            Image.radial_gradient(wrong_mode)",
            "",
            "    def test_radial_gradient(self):",
            "",
            "        # Arrange",
            "        target_file = \"Tests/images/radial_gradient.png\"",
            "        for mode in [\"L\", \"P\"]:",
            "",
            "            # Act",
            "            im = Image.radial_gradient(mode)",
            "",
            "            # Assert",
            "            assert im.size == (256, 256)",
            "            assert im.mode == mode",
            "            assert im.getpixel((0, 0)) == 255",
            "            assert im.getpixel((128, 128)) == 0",
            "            with Image.open(target_file) as target:",
            "                target = target.convert(mode)",
            "            assert_image_equal(im, target)",
            "",
            "    def test_register_extensions(self):",
            "        test_format = \"a\"",
            "        exts = [\"b\", \"c\"]",
            "        for ext in exts:",
            "            Image.register_extension(test_format, ext)",
            "        ext_individual = Image.EXTENSION.copy()",
            "        for ext in exts:",
            "            del Image.EXTENSION[ext]",
            "",
            "        Image.register_extensions(test_format, exts)",
            "        ext_multiple = Image.EXTENSION.copy()",
            "        for ext in exts:",
            "            del Image.EXTENSION[ext]",
            "",
            "        assert ext_individual == ext_multiple",
            "",
            "    def test_remap_palette(self):",
            "        # Test illegal image mode",
            "        with hopper() as im:",
            "            with pytest.raises(ValueError):",
            "                im.remap_palette(None)",
            "",
            "    def test__new(self):",
            "        im = hopper(\"RGB\")",
            "        im_p = hopper(\"P\")",
            "",
            "        blank_p = Image.new(\"P\", (10, 10))",
            "        blank_pa = Image.new(\"PA\", (10, 10))",
            "        blank_p.palette = None",
            "        blank_pa.palette = None",
            "",
            "        def _make_new(base_image, im, palette_result=None):",
            "            new_im = base_image._new(im)",
            "            assert new_im.mode == im.mode",
            "            assert new_im.size == im.size",
            "            assert new_im.info == base_image.info",
            "            if palette_result is not None:",
            "                assert new_im.palette.tobytes() == palette_result.tobytes()",
            "            else:",
            "                assert new_im.palette is None",
            "",
            "        _make_new(im, im_p, im_p.palette)",
            "        _make_new(im_p, im, None)",
            "        _make_new(im, blank_p, ImagePalette.ImagePalette())",
            "        _make_new(im, blank_pa, ImagePalette.ImagePalette())",
            "",
            "    def test_p_from_rgb_rgba(self):",
            "        for mode, color in [",
            "            (\"RGB\", \"#DDEEFF\"),",
            "            (\"RGB\", (221, 238, 255)),",
            "            (\"RGBA\", (221, 238, 255, 255)),",
            "        ]:",
            "            im = Image.new(\"P\", (100, 100), color)",
            "            expected = Image.new(mode, (100, 100), color)",
            "            assert_image_equal(im.convert(mode), expected)",
            "",
            "    def test_showxv_deprecation(self):",
            "        class TestViewer(ImageShow.Viewer):",
            "            def show_image(self, image, **options):",
            "                return True",
            "",
            "        viewer = TestViewer()",
            "        ImageShow.register(viewer, -1)",
            "",
            "        im = Image.new(\"RGB\", (50, 50), \"white\")",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            Image._showxv(im)",
            "",
            "        # Restore original state",
            "        ImageShow._viewers.pop(0)",
            "",
            "    def test_no_resource_warning_on_save(self, tmp_path):",
            "        # https://github.com/python-pillow/Pillow/issues/835",
            "        # Arrange",
            "        test_file = \"Tests/images/hopper.png\"",
            "        temp_file = str(tmp_path / \"temp.jpg\")",
            "",
            "        # Act/Assert",
            "        with Image.open(test_file) as im:",
            "            pytest.warns(None, im.save, temp_file)",
            "",
            "    def test_load_on_nonexclusive_multiframe(self):",
            "        with open(\"Tests/images/frozenpond.mpo\", \"rb\") as fp:",
            "",
            "            def act(fp):",
            "                im = Image.open(fp)",
            "                im.load()",
            "",
            "            act(fp)",
            "",
            "            with Image.open(fp) as im:",
            "                im.load()",
            "",
            "            assert not fp.closed",
            "",
            "    def test_exif_jpeg(self, tmp_path):",
            "        with Image.open(\"Tests/images/exif-72dpi-int.jpg\") as im:  # Little endian",
            "            exif = im.getexif()",
            "            assert 258 not in exif",
            "            assert 274 in exif",
            "            assert 40960 in exif",
            "            assert exif[40963] == 450",
            "            assert exif[11] == \"gThumb 3.0.1\"",
            "",
            "            out = str(tmp_path / \"temp.jpg\")",
            "            exif[258] = 8",
            "            del exif[274]",
            "            del exif[40960]",
            "            exif[40963] = 455",
            "            exif[11] = \"Pillow test\"",
            "            im.save(out, exif=exif)",
            "        with Image.open(out) as reloaded:",
            "            reloaded_exif = reloaded.getexif()",
            "            assert reloaded_exif[258] == 8",
            "            assert 274 not in reloaded_exif",
            "            assert 40960 not in reloaded_exif",
            "            assert reloaded_exif[40963] == 455",
            "            assert reloaded_exif[11] == \"Pillow test\"",
            "",
            "        with Image.open(\"Tests/images/no-dpi-in-exif.jpg\") as im:  # Big endian",
            "            exif = im.getexif()",
            "            assert 258 not in exif",
            "            assert 40962 in exif",
            "            assert exif[40963] == 200",
            "            assert exif[305] == \"Adobe Photoshop CC 2017 (Macintosh)\"",
            "",
            "            out = str(tmp_path / \"temp.jpg\")",
            "            exif[258] = 8",
            "            del exif[34665]",
            "            exif[40963] = 455",
            "            exif[305] = \"Pillow test\"",
            "            im.save(out, exif=exif)",
            "        with Image.open(out) as reloaded:",
            "            reloaded_exif = reloaded.getexif()",
            "            assert reloaded_exif[258] == 8",
            "            assert 34665 not in reloaded_exif",
            "            assert reloaded_exif[40963] == 455",
            "            assert reloaded_exif[305] == \"Pillow test\"",
            "",
            "    @skip_unless_feature(\"webp\")",
            "    @skip_unless_feature(\"webp_anim\")",
            "    def test_exif_webp(self, tmp_path):",
            "        with Image.open(\"Tests/images/hopper.webp\") as im:",
            "            exif = im.getexif()",
            "            assert exif == {}",
            "",
            "            out = str(tmp_path / \"temp.webp\")",
            "            exif[258] = 8",
            "            exif[40963] = 455",
            "            exif[305] = \"Pillow test\"",
            "",
            "            def check_exif():",
            "                with Image.open(out) as reloaded:",
            "                    reloaded_exif = reloaded.getexif()",
            "                    assert reloaded_exif[258] == 8",
            "                    assert reloaded_exif[40963] == 455",
            "                    assert reloaded_exif[305] == \"Pillow test\"",
            "",
            "            im.save(out, exif=exif)",
            "            check_exif()",
            "            im.save(out, exif=exif, save_all=True)",
            "            check_exif()",
            "",
            "    def test_exif_png(self, tmp_path):",
            "        with Image.open(\"Tests/images/exif.png\") as im:",
            "            exif = im.getexif()",
            "            assert exif == {274: 1}",
            "",
            "            out = str(tmp_path / \"temp.png\")",
            "            exif[258] = 8",
            "            del exif[274]",
            "            exif[40963] = 455",
            "            exif[305] = \"Pillow test\"",
            "            im.save(out, exif=exif)",
            "",
            "        with Image.open(out) as reloaded:",
            "            reloaded_exif = reloaded.getexif()",
            "            assert reloaded_exif == {258: 8, 40963: 455, 305: \"Pillow test\"}",
            "",
            "    def test_exif_interop(self):",
            "        with Image.open(\"Tests/images/flower.jpg\") as im:",
            "            exif = im.getexif()",
            "            assert exif.get_ifd(0xA005) == {",
            "                1: \"R98\",",
            "                2: b\"0100\",",
            "                4097: 2272,",
            "                4098: 1704,",
            "            }",
            "",
            "    @pytest.mark.parametrize(",
            "        \"test_module\",",
            "        [PIL, Image],",
            "    )",
            "    def test_pillow_version(self, test_module):",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION == PIL.__version__",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            str(test_module.PILLOW_VERSION)",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert int(test_module.PILLOW_VERSION[0]) >= 7",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION < \"9.9.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION <= \"9.9.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION != \"7.0.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION >= \"7.0.0\"",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            assert test_module.PILLOW_VERSION > \"7.0.0\"",
            "",
            "    @pytest.mark.parametrize(\"path\", [",
            "            \"fli_overrun.bin\",",
            "            \"sgi_overrun.bin\",",
            "            \"sgi_overrun_expandrow.bin\",",
            "            \"sgi_overrun_expandrow2.bin\",",
            "            \"pcx_overrun.bin\",",
            "            \"pcx_overrun2.bin\",",
            "            \"ossfuzz-4836216264589312.pcx\",",
            "            \"01r_00.pcx\",",
            "        ])",
            "    def test_overrun(self, path):",
            "        \"\"\"For overrun completeness, test as:",
            "        valgrind pytest -qq Tests/test_image.py::TestImage::test_overrun | grep decode.c",
            "        \"\"\"",
            "        with Image.open(os.path.join(\"Tests/images\", path)) as im:",
            "            try:",
            "                im.load()",
            "                assert False",
            "            except OSError as e:",
            "                assert (str(e) == \"buffer overrun when reading image file\" or",
            "                        \"image file is truncated\" in str(e))",
            "",
            "    def test_fli_overrun2(self):",
            "        with Image.open(\"Tests/images/fli_overrun2.bin\") as im:",
            "            try:",
            "                im.seek(1)",
            "                assert False",
            "            except OSError as e:",
            "                assert str(e) == \"buffer overrun when reading image file\"",
            "",
            "    def test_show_deprecation(self, monkeypatch):",
            "        monkeypatch.setattr(Image, \"_show\", lambda *args, **kwargs: None)",
            "",
            "        im = Image.new(\"RGB\", (50, 50), \"white\")",
            "",
            "        with pytest.warns(None) as raised:",
            "            im.show()",
            "        assert not raised",
            "",
            "        with pytest.warns(DeprecationWarning):",
            "            im.show(command=\"mock\")",
            "",
            "",
            "class MockEncoder:",
            "    pass",
            "",
            "",
            "def mock_encode(*args):",
            "    encoder = MockEncoder()",
            "    encoder.args = args",
            "    return encoder",
            "",
            "",
            "class TestRegistry:",
            "    def test_encode_registry(self):",
            "",
            "        Image.register_encoder(\"MOCK\", mock_encode)",
            "        assert \"MOCK\" in Image.ENCODERS",
            "",
            "        enc = Image._getencoder(\"RGB\", \"MOCK\", (\"args\",), extra=(\"extra\",))",
            "",
            "        assert isinstance(enc, MockEncoder)",
            "        assert enc.args == (\"RGB\", \"args\", \"extra\")",
            "",
            "    def test_encode_registry_fail(self):",
            "        with pytest.raises(OSError):",
            "            Image._getencoder(\"RGB\", \"DoesNotExist\", (\"args\",), extra=(\"extra\",))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "778": [
                "TestImage",
                "test_overrun"
            ],
            "779": [
                "TestImage",
                "test_overrun"
            ],
            "780": [
                "TestImage",
                "test_overrun"
            ],
            "781": [
                "TestImage",
                "test_overrun"
            ],
            "782": [
                "TestImage",
                "test_overrun"
            ],
            "790": [
                "TestImage",
                "test_overrun"
            ],
            "791": [
                "TestImage",
                "test_overrun"
            ],
            "792": [
                "TestImage",
                "test_overrun"
            ],
            "793": [
                "TestImage",
                "test_overrun"
            ],
            "794": [
                "TestImage",
                "test_overrun"
            ],
            "795": [
                "TestImage",
                "test_overrun"
            ],
            "796": [
                "TestImage",
                "test_overrun"
            ]
        },
        "addLocation": []
    },
    "src/PIL/PcxImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         version = s[1]"
            },
            "1": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         bits = s[3]"
            },
            "2": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         planes = s[65]"
            },
            "3": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        stride = i16(s, 66)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        ignored_stride = i16(s, 66)"
            },
            "5": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         logger.debug("
            },
            "6": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             \"PCX version %s, bits %s, planes %s, stride %s\","
            },
            "7": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "             version,"
            },
            "8": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             bits,"
            },
            "9": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             planes,"
            },
            "10": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            stride,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+            ignored_stride,"
            },
            "12": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         )"
            },
            "13": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         self.info[\"dpi\"] = i16(s, 12), i16(s, 14)"
            },
            "15": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         self.mode = mode"
            },
            "16": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]"
            },
            "17": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        # don't trust the passed in stride. Calculate for ourselves."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        # CVE-2020-35655"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        stride = (self._size[0] * bits + 7) // 8"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        stride += stride % 2"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         bbox = (0, 0) + self.size"
            },
            "24": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         logger.debug(\"size: %sx%s\", *self.size)"
            },
            "25": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# PCX file handling",
            "#",
            "# This format was originally used by ZSoft's popular PaintBrush",
            "# program for the IBM PC.  It is also supported by many MS-DOS and",
            "# Windows applications, including the Windows PaintBrush program in",
            "# Windows 3.",
            "#",
            "# history:",
            "# 1995-09-01 fl   Created",
            "# 1996-05-20 fl   Fixed RGB support",
            "# 1997-01-03 fl   Fixed 2-bit and 4-bit support",
            "# 1999-02-03 fl   Fixed 8-bit support (broken in 1.0b1)",
            "# 1999-02-07 fl   Added write support",
            "# 2002-06-09 fl   Made 2-bit and 4-bit support a bit more robust",
            "# 2002-07-30 fl   Seek from to current position, not beginning of file",
            "# 2003-06-03 fl   Extract DPI settings (info[\"dpi\"])",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-2003 by Fredrik Lundh.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import logging",
            "",
            "from . import Image, ImageFile, ImagePalette",
            "from ._binary import i16le as i16",
            "from ._binary import o8",
            "from ._binary import o16le as o16",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[0] == 10 and prefix[1] in [0, 2, 3, 5]",
            "",
            "",
            "##",
            "# Image plugin for Paintbrush images.",
            "",
            "",
            "class PcxImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"PCX\"",
            "    format_description = \"Paintbrush\"",
            "",
            "    def _open(self):",
            "",
            "        # header",
            "        s = self.fp.read(128)",
            "        if not _accept(s):",
            "            raise SyntaxError(\"not a PCX file\")",
            "",
            "        # image",
            "        bbox = i16(s, 4), i16(s, 6), i16(s, 8) + 1, i16(s, 10) + 1",
            "        if bbox[2] <= bbox[0] or bbox[3] <= bbox[1]:",
            "            raise SyntaxError(\"bad PCX image size\")",
            "        logger.debug(\"BBox: %s %s %s %s\", *bbox)",
            "",
            "        # format",
            "        version = s[1]",
            "        bits = s[3]",
            "        planes = s[65]",
            "        stride = i16(s, 66)",
            "        logger.debug(",
            "            \"PCX version %s, bits %s, planes %s, stride %s\",",
            "            version,",
            "            bits,",
            "            planes,",
            "            stride,",
            "        )",
            "",
            "        self.info[\"dpi\"] = i16(s, 12), i16(s, 14)",
            "",
            "        if bits == 1 and planes == 1:",
            "            mode = rawmode = \"1\"",
            "",
            "        elif bits == 1 and planes in (2, 4):",
            "            mode = \"P\"",
            "            rawmode = \"P;%dL\" % planes",
            "            self.palette = ImagePalette.raw(\"RGB\", s[16:64])",
            "",
            "        elif version == 5 and bits == 8 and planes == 1:",
            "            mode = rawmode = \"L\"",
            "            # FIXME: hey, this doesn't work with the incremental loader !!!",
            "            self.fp.seek(-769, io.SEEK_END)",
            "            s = self.fp.read(769)",
            "            if len(s) == 769 and s[0] == 12:",
            "                # check if the palette is linear greyscale",
            "                for i in range(256):",
            "                    if s[i * 3 + 1 : i * 3 + 4] != o8(i) * 3:",
            "                        mode = rawmode = \"P\"",
            "                        break",
            "                if mode == \"P\":",
            "                    self.palette = ImagePalette.raw(\"RGB\", s[1:])",
            "            self.fp.seek(128)",
            "",
            "        elif version == 5 and bits == 8 and planes == 3:",
            "            mode = \"RGB\"",
            "            rawmode = \"RGB;L\"",
            "",
            "        else:",
            "            raise OSError(\"unknown PCX mode\")",
            "",
            "        self.mode = mode",
            "        self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]",
            "",
            "        bbox = (0, 0) + self.size",
            "        logger.debug(\"size: %sx%s\", *self.size)",
            "",
            "        self.tile = [(\"pcx\", bbox, self.fp.tell(), (rawmode, planes * stride))]",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# save PCX files",
            "",
            "",
            "SAVE = {",
            "    # mode: (version, bits, planes, raw mode)",
            "    \"1\": (2, 1, 1, \"1\"),",
            "    \"L\": (5, 8, 1, \"L\"),",
            "    \"P\": (5, 8, 1, \"P\"),",
            "    \"RGB\": (5, 8, 3, \"RGB;L\"),",
            "}",
            "",
            "",
            "def _save(im, fp, filename):",
            "",
            "    try:",
            "        version, bits, planes, rawmode = SAVE[im.mode]",
            "    except KeyError as e:",
            "        raise ValueError(f\"Cannot save {im.mode} images as PCX\") from e",
            "",
            "    # bytes per plane",
            "    stride = (im.size[0] * bits + 7) // 8",
            "    # stride should be even",
            "    stride += stride % 2",
            "    # Stride needs to be kept in sync with the PcxEncode.c version.",
            "    # Ideally it should be passed in in the state, but the bytes value",
            "    # gets overwritten.",
            "",
            "    logger.debug(",
            "        \"PcxImagePlugin._save: xwidth: %d, bits: %d, stride: %d\",",
            "        im.size[0],",
            "        bits,",
            "        stride,",
            "    )",
            "",
            "    # under windows, we could determine the current screen size with",
            "    # \"Image.core.display_mode()[1]\", but I think that's overkill...",
            "",
            "    screen = im.size",
            "",
            "    dpi = 100, 100",
            "",
            "    # PCX header",
            "    fp.write(",
            "        o8(10)",
            "        + o8(version)",
            "        + o8(1)",
            "        + o8(bits)",
            "        + o16(0)",
            "        + o16(0)",
            "        + o16(im.size[0] - 1)",
            "        + o16(im.size[1] - 1)",
            "        + o16(dpi[0])",
            "        + o16(dpi[1])",
            "        + b\"\\0\" * 24",
            "        + b\"\\xFF\" * 24",
            "        + b\"\\0\"",
            "        + o8(planes)",
            "        + o16(stride)",
            "        + o16(1)",
            "        + o16(screen[0])",
            "        + o16(screen[1])",
            "        + b\"\\0\" * 54",
            "    )",
            "",
            "    assert fp.tell() == 128",
            "",
            "    ImageFile._save(im, fp, [(\"pcx\", (0, 0) + im.size, 0, (rawmode, bits * planes))])",
            "",
            "    if im.mode == \"P\":",
            "        # colour palette",
            "        fp.write(o8(12))",
            "        fp.write(im.im.getpalette(\"RGB\", \"RGB\"))  # 768 bytes",
            "    elif im.mode == \"L\":",
            "        # greyscale palette",
            "        fp.write(o8(12))",
            "        for i in range(256):",
            "            fp.write(o8(i) * 3)",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# registry",
            "",
            "",
            "Image.register_open(PcxImageFile.format, PcxImageFile, _accept)",
            "Image.register_save(PcxImageFile.format, _save)",
            "",
            "Image.register_extension(PcxImageFile.format, \".pcx\")",
            "",
            "Image.register_mime(PcxImageFile.format, \"image/x-pcx\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# PCX file handling",
            "#",
            "# This format was originally used by ZSoft's popular PaintBrush",
            "# program for the IBM PC.  It is also supported by many MS-DOS and",
            "# Windows applications, including the Windows PaintBrush program in",
            "# Windows 3.",
            "#",
            "# history:",
            "# 1995-09-01 fl   Created",
            "# 1996-05-20 fl   Fixed RGB support",
            "# 1997-01-03 fl   Fixed 2-bit and 4-bit support",
            "# 1999-02-03 fl   Fixed 8-bit support (broken in 1.0b1)",
            "# 1999-02-07 fl   Added write support",
            "# 2002-06-09 fl   Made 2-bit and 4-bit support a bit more robust",
            "# 2002-07-30 fl   Seek from to current position, not beginning of file",
            "# 2003-06-03 fl   Extract DPI settings (info[\"dpi\"])",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-2003 by Fredrik Lundh.",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import logging",
            "",
            "from . import Image, ImageFile, ImagePalette",
            "from ._binary import i16le as i16",
            "from ._binary import o8",
            "from ._binary import o16le as o16",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[0] == 10 and prefix[1] in [0, 2, 3, 5]",
            "",
            "",
            "##",
            "# Image plugin for Paintbrush images.",
            "",
            "",
            "class PcxImageFile(ImageFile.ImageFile):",
            "",
            "    format = \"PCX\"",
            "    format_description = \"Paintbrush\"",
            "",
            "    def _open(self):",
            "",
            "        # header",
            "        s = self.fp.read(128)",
            "        if not _accept(s):",
            "            raise SyntaxError(\"not a PCX file\")",
            "",
            "        # image",
            "        bbox = i16(s, 4), i16(s, 6), i16(s, 8) + 1, i16(s, 10) + 1",
            "        if bbox[2] <= bbox[0] or bbox[3] <= bbox[1]:",
            "            raise SyntaxError(\"bad PCX image size\")",
            "        logger.debug(\"BBox: %s %s %s %s\", *bbox)",
            "",
            "        # format",
            "        version = s[1]",
            "        bits = s[3]",
            "        planes = s[65]",
            "        ignored_stride = i16(s, 66)",
            "        logger.debug(",
            "            \"PCX version %s, bits %s, planes %s, stride %s\",",
            "            version,",
            "            bits,",
            "            planes,",
            "            ignored_stride,",
            "        )",
            "",
            "        self.info[\"dpi\"] = i16(s, 12), i16(s, 14)",
            "",
            "        if bits == 1 and planes == 1:",
            "            mode = rawmode = \"1\"",
            "",
            "        elif bits == 1 and planes in (2, 4):",
            "            mode = \"P\"",
            "            rawmode = \"P;%dL\" % planes",
            "            self.palette = ImagePalette.raw(\"RGB\", s[16:64])",
            "",
            "        elif version == 5 and bits == 8 and planes == 1:",
            "            mode = rawmode = \"L\"",
            "            # FIXME: hey, this doesn't work with the incremental loader !!!",
            "            self.fp.seek(-769, io.SEEK_END)",
            "            s = self.fp.read(769)",
            "            if len(s) == 769 and s[0] == 12:",
            "                # check if the palette is linear greyscale",
            "                for i in range(256):",
            "                    if s[i * 3 + 1 : i * 3 + 4] != o8(i) * 3:",
            "                        mode = rawmode = \"P\"",
            "                        break",
            "                if mode == \"P\":",
            "                    self.palette = ImagePalette.raw(\"RGB\", s[1:])",
            "            self.fp.seek(128)",
            "",
            "        elif version == 5 and bits == 8 and planes == 3:",
            "            mode = \"RGB\"",
            "            rawmode = \"RGB;L\"",
            "",
            "        else:",
            "            raise OSError(\"unknown PCX mode\")",
            "",
            "        self.mode = mode",
            "        self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]",
            "",
            "        # don't trust the passed in stride. Calculate for ourselves.",
            "        # CVE-2020-35655",
            "        stride = (self._size[0] * bits + 7) // 8",
            "        stride += stride % 2",
            "",
            "        bbox = (0, 0) + self.size",
            "        logger.debug(\"size: %sx%s\", *self.size)",
            "",
            "        self.tile = [(\"pcx\", bbox, self.fp.tell(), (rawmode, planes * stride))]",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# save PCX files",
            "",
            "",
            "SAVE = {",
            "    # mode: (version, bits, planes, raw mode)",
            "    \"1\": (2, 1, 1, \"1\"),",
            "    \"L\": (5, 8, 1, \"L\"),",
            "    \"P\": (5, 8, 1, \"P\"),",
            "    \"RGB\": (5, 8, 3, \"RGB;L\"),",
            "}",
            "",
            "",
            "def _save(im, fp, filename):",
            "",
            "    try:",
            "        version, bits, planes, rawmode = SAVE[im.mode]",
            "    except KeyError as e:",
            "        raise ValueError(f\"Cannot save {im.mode} images as PCX\") from e",
            "",
            "    # bytes per plane",
            "    stride = (im.size[0] * bits + 7) // 8",
            "    # stride should be even",
            "    stride += stride % 2",
            "    # Stride needs to be kept in sync with the PcxEncode.c version.",
            "    # Ideally it should be passed in in the state, but the bytes value",
            "    # gets overwritten.",
            "",
            "    logger.debug(",
            "        \"PcxImagePlugin._save: xwidth: %d, bits: %d, stride: %d\",",
            "        im.size[0],",
            "        bits,",
            "        stride,",
            "    )",
            "",
            "    # under windows, we could determine the current screen size with",
            "    # \"Image.core.display_mode()[1]\", but I think that's overkill...",
            "",
            "    screen = im.size",
            "",
            "    dpi = 100, 100",
            "",
            "    # PCX header",
            "    fp.write(",
            "        o8(10)",
            "        + o8(version)",
            "        + o8(1)",
            "        + o8(bits)",
            "        + o16(0)",
            "        + o16(0)",
            "        + o16(im.size[0] - 1)",
            "        + o16(im.size[1] - 1)",
            "        + o16(dpi[0])",
            "        + o16(dpi[1])",
            "        + b\"\\0\" * 24",
            "        + b\"\\xFF\" * 24",
            "        + b\"\\0\"",
            "        + o8(planes)",
            "        + o16(stride)",
            "        + o16(1)",
            "        + o16(screen[0])",
            "        + o16(screen[1])",
            "        + b\"\\0\" * 54",
            "    )",
            "",
            "    assert fp.tell() == 128",
            "",
            "    ImageFile._save(im, fp, [(\"pcx\", (0, 0) + im.size, 0, (rawmode, bits * planes))])",
            "",
            "    if im.mode == \"P\":",
            "        # colour palette",
            "        fp.write(o8(12))",
            "        fp.write(im.im.getpalette(\"RGB\", \"RGB\"))  # 768 bytes",
            "    elif im.mode == \"L\":",
            "        # greyscale palette",
            "        fp.write(o8(12))",
            "        for i in range(256):",
            "            fp.write(o8(i) * 3)",
            "",
            "",
            "# --------------------------------------------------------------------",
            "# registry",
            "",
            "",
            "Image.register_open(PcxImageFile.format, PcxImageFile, _accept)",
            "Image.register_save(PcxImageFile.format, _save)",
            "",
            "Image.register_extension(PcxImageFile.format, \".pcx\")",
            "",
            "Image.register_mime(PcxImageFile.format, \"image/x-pcx\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "69": [
                "PcxImageFile",
                "_open"
            ],
            "75": [
                "PcxImageFile",
                "_open"
            ]
        },
        "addLocation": []
    }
}